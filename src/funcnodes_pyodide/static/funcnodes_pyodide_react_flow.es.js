var pK = Object.defineProperty;
var mK = (e, t, n) => t in e ? pK(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : e[t] = n;
var Jr = (e, t, n) => mK(e, typeof t != "symbol" ? t + "" : t, n);
var Nw = window;
function hK(e, t) {
  for (var n = 0; n < t.length; n++) {
    const r = t[n];
    if (typeof r != "string" && !Array.isArray(r)) {
      for (const a in r)
        if (a !== "default" && !(a in e)) {
          const s = Object.getOwnPropertyDescriptor(r, a);
          s && Object.defineProperty(e, a, s.get ? s : {
            enumerable: !0,
            get: () => r[a]
          });
        }
    }
  }
  return Object.freeze(Object.defineProperty(e, Symbol.toStringTag, { value: "Module" }));
}
(function() {
  const t = document.createElement("link").relList;
  if (t && t.supports && t.supports("modulepreload")) return;
  for (const a of document.querySelectorAll('link[rel="modulepreload"]')) r(a);
  new MutationObserver((a) => {
    for (const s of a)
      if (s.type === "childList")
        for (const l of s.addedNodes) l.tagName === "LINK" && l.rel === "modulepreload" && r(l);
  }).observe(document, {
    childList: !0,
    subtree: !0
  });
  function n(a) {
    const s = {};
    return a.integrity && (s.integrity = a.integrity), a.referrerPolicy && (s.referrerPolicy = a.referrerPolicy), a.crossOrigin === "use-credentials" ? s.credentials = "include" : a.crossOrigin === "anonymous" ? s.credentials = "omit" : s.credentials = "same-origin", s;
  }
  function r(a) {
    if (a.ep) return;
    a.ep = !0;
    const s = n(a);
    fetch(a.href, s);
  }
})();
function b1(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var BO = { exports: {} }, ow = {};
var mj;
function gK() {
  if (mj) return ow;
  mj = 1;
  var e = /* @__PURE__ */ Symbol.for("react.transitional.element"), t = /* @__PURE__ */ Symbol.for("react.fragment");
  function n(r, a, s) {
    var l = null;
    if (s !== void 0 && (l = "" + s), a.key !== void 0 && (l = "" + a.key), "key" in a) {
      s = {};
      for (var c in a)
        c !== "key" && (s[c] = a[c]);
    } else s = a;
    return a = s.ref, {
      $$typeof: e,
      type: r,
      key: l,
      ref: a !== void 0 ? a : null,
      props: s
    };
  }
  return ow.Fragment = t, ow.jsx = n, ow.jsxs = n, ow;
}
var hj;
function vK() {
  return hj || (hj = 1, BO.exports = gK()), BO.exports;
}
var gj = vK(), UO = { exports: {} }, Et = {};
var vj;
function yK() {
  if (vj) return Et;
  vj = 1;
  var e = /* @__PURE__ */ Symbol.for("react.transitional.element"), t = /* @__PURE__ */ Symbol.for("react.portal"), n = /* @__PURE__ */ Symbol.for("react.fragment"), r = /* @__PURE__ */ Symbol.for("react.strict_mode"), a = /* @__PURE__ */ Symbol.for("react.profiler"), s = /* @__PURE__ */ Symbol.for("react.consumer"), l = /* @__PURE__ */ Symbol.for("react.context"), c = /* @__PURE__ */ Symbol.for("react.forward_ref"), d = /* @__PURE__ */ Symbol.for("react.suspense"), p = /* @__PURE__ */ Symbol.for("react.memo"), m = /* @__PURE__ */ Symbol.for("react.lazy"), h = /* @__PURE__ */ Symbol.for("react.activity"), v = Symbol.iterator;
  function y(F) {
    return F === null || typeof F != "object" ? null : (F = v && F[v] || F["@@iterator"], typeof F == "function" ? F : null);
  }
  var w = {
    isMounted: function() {
      return !1;
    },
    enqueueForceUpdate: function() {
    },
    enqueueReplaceState: function() {
    },
    enqueueSetState: function() {
    }
  }, x = Object.assign, b = {};
  function k(F, X, U) {
    this.props = F, this.context = X, this.refs = b, this.updater = U || w;
  }
  k.prototype.isReactComponent = {}, k.prototype.setState = function(F, X) {
    if (typeof F != "object" && typeof F != "function" && F != null)
      throw Error(
        "takes an object of state variables to update or a function which returns an object of state variables."
      );
    this.updater.enqueueSetState(this, F, X, "setState");
  }, k.prototype.forceUpdate = function(F) {
    this.updater.enqueueForceUpdate(this, F, "forceUpdate");
  };
  function C() {
  }
  C.prototype = k.prototype;
  function _(F, X, U) {
    this.props = F, this.context = X, this.refs = b, this.updater = U || w;
  }
  var O = _.prototype = new C();
  O.constructor = _, x(O, k.prototype), O.isPureReactComponent = !0;
  var N = Array.isArray;
  function R() {
  }
  var j = { H: null, A: null, T: null, S: null }, D = Object.prototype.hasOwnProperty;
  function $(F, X, U) {
    var H = U.ref;
    return {
      $$typeof: e,
      type: F,
      key: X,
      ref: H !== void 0 ? H : null,
      props: U
    };
  }
  function z(F, X) {
    return $(F.type, X, F.props);
  }
  function B(F) {
    return typeof F == "object" && F !== null && F.$$typeof === e;
  }
  function P(F) {
    var X = { "=": "=0", ":": "=2" };
    return "$" + F.replace(/[=:]/g, function(U) {
      return X[U];
    });
  }
  var W = /\/+/g;
  function I(F, X) {
    return typeof F == "object" && F !== null && F.key != null ? P("" + F.key) : X.toString(36);
  }
  function G(F) {
    switch (F.status) {
      case "fulfilled":
        return F.value;
      case "rejected":
        throw F.reason;
      default:
        switch (typeof F.status == "string" ? F.then(R, R) : (F.status = "pending", F.then(
          function(X) {
            F.status === "pending" && (F.status = "fulfilled", F.value = X);
          },
          function(X) {
            F.status === "pending" && (F.status = "rejected", F.reason = X);
          }
        )), F.status) {
          case "fulfilled":
            return F.value;
          case "rejected":
            throw F.reason;
        }
    }
    throw F;
  }
  function L(F, X, U, H, Q) {
    var re = typeof F;
    (re === "undefined" || re === "boolean") && (F = null);
    var de = !1;
    if (F === null) de = !0;
    else
      switch (re) {
        case "bigint":
        case "string":
        case "number":
          de = !0;
          break;
        case "object":
          switch (F.$$typeof) {
            case e:
            case t:
              de = !0;
              break;
            case m:
              return de = F._init, L(
                de(F._payload),
                X,
                U,
                H,
                Q
              );
          }
      }
    if (de)
      return Q = Q(F), de = H === "" ? "." + I(F, 0) : H, N(Q) ? (U = "", de != null && (U = de.replace(W, "$&/") + "/"), L(Q, X, U, "", function(ve) {
        return ve;
      })) : Q != null && (B(Q) && (Q = z(
        Q,
        U + (Q.key == null || F && F.key === Q.key ? "" : ("" + Q.key).replace(
          W,
          "$&/"
        ) + "/") + de
      )), X.push(Q)), 1;
    de = 0;
    var le = H === "" ? "." : H + ":";
    if (N(F))
      for (var me = 0; me < F.length; me++)
        H = F[me], re = le + I(H, me), de += L(
          H,
          X,
          U,
          re,
          Q
        );
    else if (me = y(F), typeof me == "function")
      for (F = me.call(F), me = 0; !(H = F.next()).done; )
        H = H.value, re = le + I(H, me++), de += L(
          H,
          X,
          U,
          re,
          Q
        );
    else if (re === "object") {
      if (typeof F.then == "function")
        return L(
          G(F),
          X,
          U,
          H,
          Q
        );
      throw X = String(F), Error(
        "Objects are not valid as a React child (found: " + (X === "[object Object]" ? "object with keys {" + Object.keys(F).join(", ") + "}" : X) + "). If you meant to render a collection of children, use an array instead."
      );
    }
    return de;
  }
  function K(F, X, U) {
    if (F == null) return F;
    var H = [], Q = 0;
    return L(F, H, "", "", function(re) {
      return X.call(U, re, Q++);
    }), H;
  }
  function q(F) {
    if (F._status === -1) {
      var X = F._result;
      X = X(), X.then(
        function(U) {
          (F._status === 0 || F._status === -1) && (F._status = 1, F._result = U);
        },
        function(U) {
          (F._status === 0 || F._status === -1) && (F._status = 2, F._result = U);
        }
      ), F._status === -1 && (F._status = 0, F._result = X);
    }
    if (F._status === 1) return F._result.default;
    throw F._result;
  }
  var Z = typeof reportError == "function" ? reportError : function(F) {
    if (typeof window == "object" && typeof window.ErrorEvent == "function") {
      var X = new window.ErrorEvent("error", {
        bubbles: !0,
        cancelable: !0,
        message: typeof F == "object" && F !== null && typeof F.message == "string" ? String(F.message) : String(F),
        error: F
      });
      if (!window.dispatchEvent(X)) return;
    } else if (typeof process == "object" && typeof process.emit == "function") {
      process.emit("uncaughtException", F);
      return;
    }
    console.error(F);
  }, V = {
    map: K,
    forEach: function(F, X, U) {
      K(
        F,
        function() {
          X.apply(this, arguments);
        },
        U
      );
    },
    count: function(F) {
      var X = 0;
      return K(F, function() {
        X++;
      }), X;
    },
    toArray: function(F) {
      return K(F, function(X) {
        return X;
      }) || [];
    },
    only: function(F) {
      if (!B(F))
        throw Error(
          "React.Children.only expected to receive a single React element child."
        );
      return F;
    }
  };
  return Et.Activity = h, Et.Children = V, Et.Component = k, Et.Fragment = n, Et.Profiler = a, Et.PureComponent = _, Et.StrictMode = r, Et.Suspense = d, Et.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = j, Et.__COMPILER_RUNTIME = {
    __proto__: null,
    c: function(F) {
      return j.H.useMemoCache(F);
    }
  }, Et.cache = function(F) {
    return function() {
      return F.apply(null, arguments);
    };
  }, Et.cacheSignal = function() {
    return null;
  }, Et.cloneElement = function(F, X, U) {
    if (F == null)
      throw Error(
        "The argument must be a React element, but you passed " + F + "."
      );
    var H = x({}, F.props), Q = F.key;
    if (X != null)
      for (re in X.key !== void 0 && (Q = "" + X.key), X)
        !D.call(X, re) || re === "key" || re === "__self" || re === "__source" || re === "ref" && X.ref === void 0 || (H[re] = X[re]);
    var re = arguments.length - 2;
    if (re === 1) H.children = U;
    else if (1 < re) {
      for (var de = Array(re), le = 0; le < re; le++)
        de[le] = arguments[le + 2];
      H.children = de;
    }
    return $(F.type, Q, H);
  }, Et.createContext = function(F) {
    return F = {
      $$typeof: l,
      _currentValue: F,
      _currentValue2: F,
      _threadCount: 0,
      Provider: null,
      Consumer: null
    }, F.Provider = F, F.Consumer = {
      $$typeof: s,
      _context: F
    }, F;
  }, Et.createElement = function(F, X, U) {
    var H, Q = {}, re = null;
    if (X != null)
      for (H in X.key !== void 0 && (re = "" + X.key), X)
        D.call(X, H) && H !== "key" && H !== "__self" && H !== "__source" && (Q[H] = X[H]);
    var de = arguments.length - 2;
    if (de === 1) Q.children = U;
    else if (1 < de) {
      for (var le = Array(de), me = 0; me < de; me++)
        le[me] = arguments[me + 2];
      Q.children = le;
    }
    if (F && F.defaultProps)
      for (H in de = F.defaultProps, de)
        Q[H] === void 0 && (Q[H] = de[H]);
    return $(F, re, Q);
  }, Et.createRef = function() {
    return { current: null };
  }, Et.forwardRef = function(F) {
    return { $$typeof: c, render: F };
  }, Et.isValidElement = B, Et.lazy = function(F) {
    return {
      $$typeof: m,
      _payload: { _status: -1, _result: F },
      _init: q
    };
  }, Et.memo = function(F, X) {
    return {
      $$typeof: p,
      type: F,
      compare: X === void 0 ? null : X
    };
  }, Et.startTransition = function(F) {
    var X = j.T, U = {};
    j.T = U;
    try {
      var H = F(), Q = j.S;
      Q !== null && Q(U, H), typeof H == "object" && H !== null && typeof H.then == "function" && H.then(R, Z);
    } catch (re) {
      Z(re);
    } finally {
      X !== null && U.types !== null && (X.types = U.types), j.T = X;
    }
  }, Et.unstable_useCacheRefresh = function() {
    return j.H.useCacheRefresh();
  }, Et.use = function(F) {
    return j.H.use(F);
  }, Et.useActionState = function(F, X, U) {
    return j.H.useActionState(F, X, U);
  }, Et.useCallback = function(F, X) {
    return j.H.useCallback(F, X);
  }, Et.useContext = function(F) {
    return j.H.useContext(F);
  }, Et.useDebugValue = function() {
  }, Et.useDeferredValue = function(F, X) {
    return j.H.useDeferredValue(F, X);
  }, Et.useEffect = function(F, X) {
    return j.H.useEffect(F, X);
  }, Et.useEffectEvent = function(F) {
    return j.H.useEffectEvent(F);
  }, Et.useId = function() {
    return j.H.useId();
  }, Et.useImperativeHandle = function(F, X, U) {
    return j.H.useImperativeHandle(F, X, U);
  }, Et.useInsertionEffect = function(F, X) {
    return j.H.useInsertionEffect(F, X);
  }, Et.useLayoutEffect = function(F, X) {
    return j.H.useLayoutEffect(F, X);
  }, Et.useMemo = function(F, X) {
    return j.H.useMemo(F, X);
  }, Et.useOptimistic = function(F, X) {
    return j.H.useOptimistic(F, X);
  }, Et.useReducer = function(F, X, U) {
    return j.H.useReducer(F, X, U);
  }, Et.useRef = function(F) {
    return j.H.useRef(F);
  }, Et.useState = function(F) {
    return j.H.useState(F);
  }, Et.useSyncExternalStore = function(F, X, U) {
    return j.H.useSyncExternalStore(
      F,
      X,
      U
    );
  }, Et.useTransition = function() {
    return j.H.useTransition();
  }, Et.version = "19.2.3", Et;
}
var yj;
function P3() {
  return yj || (yj = 1, UO.exports = yK()), UO.exports;
}
var M = P3();
const Qn = /* @__PURE__ */ b1(M), Gx = /* @__PURE__ */ hK({
  __proto__: null,
  default: Qn
}, [M]);
var VO = { exports: {} }, Bo = {};
var bj;
function bK() {
  if (bj) return Bo;
  bj = 1;
  var e = P3();
  function t(d) {
    var p = "https://react.dev/errors/" + d;
    if (1 < arguments.length) {
      p += "?args[]=" + encodeURIComponent(arguments[1]);
      for (var m = 2; m < arguments.length; m++)
        p += "&args[]=" + encodeURIComponent(arguments[m]);
    }
    return "Minified React error #" + d + "; visit " + p + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
  }
  function n() {
  }
  var r = {
    d: {
      f: n,
      r: function() {
        throw Error(t(522));
      },
      D: n,
      C: n,
      L: n,
      m: n,
      X: n,
      S: n,
      M: n
    },
    p: 0,
    findDOMNode: null
  }, a = /* @__PURE__ */ Symbol.for("react.portal");
  function s(d, p, m) {
    var h = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null;
    return {
      $$typeof: a,
      key: h == null ? null : "" + h,
      children: d,
      containerInfo: p,
      implementation: m
    };
  }
  var l = e.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE;
  function c(d, p) {
    if (d === "font") return "";
    if (typeof p == "string")
      return p === "use-credentials" ? p : "";
  }
  return Bo.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = r, Bo.createPortal = function(d, p) {
    var m = 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : null;
    if (!p || p.nodeType !== 1 && p.nodeType !== 9 && p.nodeType !== 11)
      throw Error(t(299));
    return s(d, p, null, m);
  }, Bo.flushSync = function(d) {
    var p = l.T, m = r.p;
    try {
      if (l.T = null, r.p = 2, d) return d();
    } finally {
      l.T = p, r.p = m, r.d.f();
    }
  }, Bo.preconnect = function(d, p) {
    typeof d == "string" && (p ? (p = p.crossOrigin, p = typeof p == "string" ? p === "use-credentials" ? p : "" : void 0) : p = null, r.d.C(d, p));
  }, Bo.prefetchDNS = function(d) {
    typeof d == "string" && r.d.D(d);
  }, Bo.preinit = function(d, p) {
    if (typeof d == "string" && p && typeof p.as == "string") {
      var m = p.as, h = c(m, p.crossOrigin), v = typeof p.integrity == "string" ? p.integrity : void 0, y = typeof p.fetchPriority == "string" ? p.fetchPriority : void 0;
      m === "style" ? r.d.S(
        d,
        typeof p.precedence == "string" ? p.precedence : void 0,
        {
          crossOrigin: h,
          integrity: v,
          fetchPriority: y
        }
      ) : m === "script" && r.d.X(d, {
        crossOrigin: h,
        integrity: v,
        fetchPriority: y,
        nonce: typeof p.nonce == "string" ? p.nonce : void 0
      });
    }
  }, Bo.preinitModule = function(d, p) {
    if (typeof d == "string")
      if (typeof p == "object" && p !== null) {
        if (p.as == null || p.as === "script") {
          var m = c(
            p.as,
            p.crossOrigin
          );
          r.d.M(d, {
            crossOrigin: m,
            integrity: typeof p.integrity == "string" ? p.integrity : void 0,
            nonce: typeof p.nonce == "string" ? p.nonce : void 0
          });
        }
      } else p == null && r.d.M(d);
  }, Bo.preload = function(d, p) {
    if (typeof d == "string" && typeof p == "object" && p !== null && typeof p.as == "string") {
      var m = p.as, h = c(m, p.crossOrigin);
      r.d.L(d, m, {
        crossOrigin: h,
        integrity: typeof p.integrity == "string" ? p.integrity : void 0,
        nonce: typeof p.nonce == "string" ? p.nonce : void 0,
        type: typeof p.type == "string" ? p.type : void 0,
        fetchPriority: typeof p.fetchPriority == "string" ? p.fetchPriority : void 0,
        referrerPolicy: typeof p.referrerPolicy == "string" ? p.referrerPolicy : void 0,
        imageSrcSet: typeof p.imageSrcSet == "string" ? p.imageSrcSet : void 0,
        imageSizes: typeof p.imageSizes == "string" ? p.imageSizes : void 0,
        media: typeof p.media == "string" ? p.media : void 0
      });
    }
  }, Bo.preloadModule = function(d, p) {
    if (typeof d == "string")
      if (p) {
        var m = c(p.as, p.crossOrigin);
        r.d.m(d, {
          as: typeof p.as == "string" && p.as !== "script" ? p.as : void 0,
          crossOrigin: m,
          integrity: typeof p.integrity == "string" ? p.integrity : void 0
        });
      } else r.d.m(d);
  }, Bo.requestFormReset = function(d) {
    r.d.r(d);
  }, Bo.unstable_batchedUpdates = function(d, p) {
    return d(p);
  }, Bo.useFormState = function(d, p, m) {
    return l.H.useFormState(d, p, m);
  }, Bo.useFormStatus = function() {
    return l.H.useHostTransitionStatus();
  }, Bo.version = "19.2.3", Bo;
}
var wj;
function w1() {
  if (wj) return VO.exports;
  wj = 1;
  function e() {
    if (!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != "function"))
      try {
        __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(e);
      } catch (t) {
        console.error(t);
      }
  }
  return e(), VO.exports = bK(), VO.exports;
}
var xm = w1();
const uh = /* @__PURE__ */ b1(xm), wK = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  get ArrayBufferDataStructure() {
    return B7;
  },
  get CTypeStructure() {
    return U7;
  },
  get DataPreviewViewRendererToHandlePreviewRenderer() {
    return iV;
  },
  get DataStructure() {
    return ml;
  },
  get DataViewRendererToDataPreviewViewRenderer() {
    return Ea;
  },
  get DataViewRendererToInputRenderer() {
    return sV;
  },
  get DataViewRendererToOverlayRenderer() {
    return J2;
  },
  get FuncNodes() {
    return fj;
  },
  get FuncNodesRenderer() {
    return pj;
  },
  get FuncNodesWorker() {
    return YR;
  },
  get JSONStructure() {
    return Yc;
  },
  get LATEST_VERSION() {
    return cK;
  },
  get TextStructure() {
    return V7;
  },
  get deep_merge() {
    return rd;
  },
  get deep_update() {
    return L3;
  },
  get object_factory_maker() {
    return H_;
  },
  get useFuncNodesContext() {
    return yn;
  },
  get useIOGetFullValue() {
    return SS;
  },
  get useIOStore() {
    return dr;
  },
  get useIOValueStore() {
    return mwe;
  },
  get useNodeStore() {
    return ki;
  },
  get useSetIOValue() {
    return _m;
  },
  get useSetIOValueOptions() {
    return pwe;
  },
  get useWorkerApi() {
    return xa;
  }
}, Symbol.toStringTag, { value: "Module" }));
function Oc(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var xj = { exports: {} }, aw = {}, Sj;
function xK() {
  if (Sj) return aw;
  Sj = 1;
  var e = /* @__PURE__ */ Symbol.for("react.transitional.element"), t = /* @__PURE__ */ Symbol.for("react.fragment");
  function n(r, a, s) {
    var l = null;
    if (s !== void 0 && (l = "" + s), a.key !== void 0 && (l = "" + a.key), "key" in a) {
      s = {};
      for (var c in a)
        c !== "key" && (s[c] = a[c]);
    } else s = a;
    return a = s.ref, {
      $$typeof: e,
      type: r,
      key: l,
      ref: a !== void 0 ? a : null,
      props: s
    };
  }
  return aw.Fragment = t, aw.jsx = n, aw.jsxs = n, aw;
}
var kj;
function SK() {
  return kj || (kj = 1, xj.exports = xK()), xj.exports;
}
var E = SK(), HO = { exports: {} }, iw = {}, _j = { exports: {} }, Ej = {}, Cj;
function kK() {
  return Cj || (Cj = 1, (function(e) {
    function t(L, K) {
      var q = L.length;
      L.push(K);
      e: for (; 0 < q; ) {
        var Z = q - 1 >>> 1, V = L[Z];
        if (0 < a(V, K))
          L[Z] = K, L[q] = V, q = Z;
        else break e;
      }
    }
    function n(L) {
      return L.length === 0 ? null : L[0];
    }
    function r(L) {
      if (L.length === 0) return null;
      var K = L[0], q = L.pop();
      if (q !== K) {
        L[0] = q;
        e: for (var Z = 0, V = L.length, F = V >>> 1; Z < F; ) {
          var X = 2 * (Z + 1) - 1, U = L[X], H = X + 1, Q = L[H];
          if (0 > a(U, q))
            H < V && 0 > a(Q, U) ? (L[Z] = Q, L[H] = q, Z = H) : (L[Z] = U, L[X] = q, Z = X);
          else if (H < V && 0 > a(Q, q))
            L[Z] = Q, L[H] = q, Z = H;
          else break e;
        }
      }
      return K;
    }
    function a(L, K) {
      var q = L.sortIndex - K.sortIndex;
      return q !== 0 ? q : L.id - K.id;
    }
    if (e.unstable_now = void 0, typeof performance == "object" && typeof performance.now == "function") {
      var s = performance;
      e.unstable_now = function() {
        return s.now();
      };
    } else {
      var l = Date, c = l.now();
      e.unstable_now = function() {
        return l.now() - c;
      };
    }
    var d = [], p = [], m = 1, h = null, v = 3, y = !1, w = !1, x = !1, b = !1, k = typeof setTimeout == "function" ? setTimeout : null, C = typeof clearTimeout == "function" ? clearTimeout : null, _ = typeof setImmediate < "u" ? setImmediate : null;
    function O(L) {
      for (var K = n(p); K !== null; ) {
        if (K.callback === null) r(p);
        else if (K.startTime <= L)
          r(p), K.sortIndex = K.expirationTime, t(d, K);
        else break;
        K = n(p);
      }
    }
    function N(L) {
      if (x = !1, O(L), !w)
        if (n(d) !== null)
          w = !0, R || (R = !0, P());
        else {
          var K = n(p);
          K !== null && G(N, K.startTime - L);
        }
    }
    var R = !1, j = -1, D = 5, $ = -1;
    function z() {
      return b ? !0 : !(e.unstable_now() - $ < D);
    }
    function B() {
      if (b = !1, R) {
        var L = e.unstable_now();
        $ = L;
        var K = !0;
        try {
          e: {
            w = !1, x && (x = !1, C(j), j = -1), y = !0;
            var q = v;
            try {
              t: {
                for (O(L), h = n(d); h !== null && !(h.expirationTime > L && z()); ) {
                  var Z = h.callback;
                  if (typeof Z == "function") {
                    h.callback = null, v = h.priorityLevel;
                    var V = Z(
                      h.expirationTime <= L
                    );
                    if (L = e.unstable_now(), typeof V == "function") {
                      h.callback = V, O(L), K = !0;
                      break t;
                    }
                    h === n(d) && r(d), O(L);
                  } else r(d);
                  h = n(d);
                }
                if (h !== null) K = !0;
                else {
                  var F = n(p);
                  F !== null && G(
                    N,
                    F.startTime - L
                  ), K = !1;
                }
              }
              break e;
            } finally {
              h = null, v = q, y = !1;
            }
            K = void 0;
          }
        } finally {
          K ? P() : R = !1;
        }
      }
    }
    var P;
    if (typeof _ == "function")
      P = function() {
        _(B);
      };
    else if (typeof MessageChannel < "u") {
      var W = new MessageChannel(), I = W.port2;
      W.port1.onmessage = B, P = function() {
        I.postMessage(null);
      };
    } else
      P = function() {
        k(B, 0);
      };
    function G(L, K) {
      j = k(function() {
        L(e.unstable_now());
      }, K);
    }
    e.unstable_IdlePriority = 5, e.unstable_ImmediatePriority = 1, e.unstable_LowPriority = 4, e.unstable_NormalPriority = 3, e.unstable_Profiling = null, e.unstable_UserBlockingPriority = 2, e.unstable_cancelCallback = function(L) {
      L.callback = null;
    }, e.unstable_forceFrameRate = function(L) {
      0 > L || 125 < L ? console.error(
        "forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"
      ) : D = 0 < L ? Math.floor(1e3 / L) : 5;
    }, e.unstable_getCurrentPriorityLevel = function() {
      return v;
    }, e.unstable_next = function(L) {
      switch (v) {
        case 1:
        case 2:
        case 3:
          var K = 3;
          break;
        default:
          K = v;
      }
      var q = v;
      v = K;
      try {
        return L();
      } finally {
        v = q;
      }
    }, e.unstable_requestPaint = function() {
      b = !0;
    }, e.unstable_runWithPriority = function(L, K) {
      switch (L) {
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
          break;
        default:
          L = 3;
      }
      var q = v;
      v = L;
      try {
        return K();
      } finally {
        v = q;
      }
    }, e.unstable_scheduleCallback = function(L, K, q) {
      var Z = e.unstable_now();
      switch (typeof q == "object" && q !== null ? (q = q.delay, q = typeof q == "number" && 0 < q ? Z + q : Z) : q = Z, L) {
        case 1:
          var V = -1;
          break;
        case 2:
          V = 250;
          break;
        case 5:
          V = 1073741823;
          break;
        case 4:
          V = 1e4;
          break;
        default:
          V = 5e3;
      }
      return V = q + V, L = {
        id: m++,
        callback: K,
        priorityLevel: L,
        startTime: q,
        expirationTime: V,
        sortIndex: -1
      }, q > Z ? (L.sortIndex = q, t(p, L), n(d) === null && L === n(p) && (x ? (C(j), j = -1) : x = !0, G(N, q - Z))) : (L.sortIndex = V, t(d, L), w || y || (w = !0, R || (R = !0, P()))), L;
    }, e.unstable_shouldYield = z, e.unstable_wrapCallback = function(L) {
      var K = v;
      return function() {
        var q = v;
        v = K;
        try {
          return L.apply(this, arguments);
        } finally {
          v = q;
        }
      };
    };
  })(Ej)), Ej;
}
var Oj;
function _K() {
  return Oj || (Oj = 1, _j.exports = kK()), _j.exports;
}
var Mj;
function EK() {
  if (Mj) return iw;
  Mj = 1;
  var e = _K(), t = Qn, n = uh;
  function r(o) {
    var i = "https://react.dev/errors/" + o;
    if (1 < arguments.length) {
      i += "?args[]=" + encodeURIComponent(arguments[1]);
      for (var u = 2; u < arguments.length; u++)
        i += "&args[]=" + encodeURIComponent(arguments[u]);
    }
    return "Minified React error #" + o + "; visit " + i + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
  }
  function a(o) {
    return !(!o || o.nodeType !== 1 && o.nodeType !== 9 && o.nodeType !== 11);
  }
  function s(o) {
    var i = o, u = o;
    if (o.alternate) for (; i.return; ) i = i.return;
    else {
      o = i;
      do
        i = o, (i.flags & 4098) !== 0 && (u = i.return), o = i.return;
      while (o);
    }
    return i.tag === 3 ? u : null;
  }
  function l(o) {
    if (o.tag === 13) {
      var i = o.memoizedState;
      if (i === null && (o = o.alternate, o !== null && (i = o.memoizedState)), i !== null) return i.dehydrated;
    }
    return null;
  }
  function c(o) {
    if (o.tag === 31) {
      var i = o.memoizedState;
      if (i === null && (o = o.alternate, o !== null && (i = o.memoizedState)), i !== null) return i.dehydrated;
    }
    return null;
  }
  function d(o) {
    if (s(o) !== o)
      throw Error(r(188));
  }
  function p(o) {
    var i = o.alternate;
    if (!i) {
      if (i = s(o), i === null) throw Error(r(188));
      return i !== o ? null : o;
    }
    for (var u = o, f = i; ; ) {
      var g = u.return;
      if (g === null) break;
      var S = g.alternate;
      if (S === null) {
        if (f = g.return, f !== null) {
          u = f;
          continue;
        }
        break;
      }
      if (g.child === S.child) {
        for (S = g.child; S; ) {
          if (S === u) return d(g), o;
          if (S === f) return d(g), i;
          S = S.sibling;
        }
        throw Error(r(188));
      }
      if (u.return !== f.return) u = g, f = S;
      else {
        for (var A = !1, T = g.child; T; ) {
          if (T === u) {
            A = !0, u = g, f = S;
            break;
          }
          if (T === f) {
            A = !0, f = g, u = S;
            break;
          }
          T = T.sibling;
        }
        if (!A) {
          for (T = S.child; T; ) {
            if (T === u) {
              A = !0, u = S, f = g;
              break;
            }
            if (T === f) {
              A = !0, f = S, u = g;
              break;
            }
            T = T.sibling;
          }
          if (!A) throw Error(r(189));
        }
      }
      if (u.alternate !== f) throw Error(r(190));
    }
    if (u.tag !== 3) throw Error(r(188));
    return u.stateNode.current === u ? o : i;
  }
  function m(o) {
    var i = o.tag;
    if (i === 5 || i === 26 || i === 27 || i === 6) return o;
    for (o = o.child; o !== null; ) {
      if (i = m(o), i !== null) return i;
      o = o.sibling;
    }
    return null;
  }
  var h = Object.assign, v = /* @__PURE__ */ Symbol.for("react.element"), y = /* @__PURE__ */ Symbol.for("react.transitional.element"), w = /* @__PURE__ */ Symbol.for("react.portal"), x = /* @__PURE__ */ Symbol.for("react.fragment"), b = /* @__PURE__ */ Symbol.for("react.strict_mode"), k = /* @__PURE__ */ Symbol.for("react.profiler"), C = /* @__PURE__ */ Symbol.for("react.consumer"), _ = /* @__PURE__ */ Symbol.for("react.context"), O = /* @__PURE__ */ Symbol.for("react.forward_ref"), N = /* @__PURE__ */ Symbol.for("react.suspense"), R = /* @__PURE__ */ Symbol.for("react.suspense_list"), j = /* @__PURE__ */ Symbol.for("react.memo"), D = /* @__PURE__ */ Symbol.for("react.lazy"), $ = /* @__PURE__ */ Symbol.for("react.activity"), z = /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel"), B = Symbol.iterator;
  function P(o) {
    return o === null || typeof o != "object" ? null : (o = B && o[B] || o["@@iterator"], typeof o == "function" ? o : null);
  }
  var W = /* @__PURE__ */ Symbol.for("react.client.reference");
  function I(o) {
    if (o == null) return null;
    if (typeof o == "function")
      return o.$$typeof === W ? null : o.displayName || o.name || null;
    if (typeof o == "string") return o;
    switch (o) {
      case x:
        return "Fragment";
      case k:
        return "Profiler";
      case b:
        return "StrictMode";
      case N:
        return "Suspense";
      case R:
        return "SuspenseList";
      case $:
        return "Activity";
    }
    if (typeof o == "object")
      switch (o.$$typeof) {
        case w:
          return "Portal";
        case _:
          return o.displayName || "Context";
        case C:
          return (o._context.displayName || "Context") + ".Consumer";
        case O:
          var i = o.render;
          return o = o.displayName, o || (o = i.displayName || i.name || "", o = o !== "" ? "ForwardRef(" + o + ")" : "ForwardRef"), o;
        case j:
          return i = o.displayName || null, i !== null ? i : I(o.type) || "Memo";
        case D:
          i = o._payload, o = o._init;
          try {
            return I(o(i));
          } catch {
          }
      }
    return null;
  }
  var G = Array.isArray, L = t.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, K = n.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, q = {
    pending: !1,
    data: null,
    method: null,
    action: null
  }, Z = [], V = -1;
  function F(o) {
    return { current: o };
  }
  function X(o) {
    0 > V || (o.current = Z[V], Z[V] = null, V--);
  }
  function U(o, i) {
    V++, Z[V] = o.current, o.current = i;
  }
  var H = F(null), Q = F(null), re = F(null), de = F(null);
  function le(o, i) {
    switch (U(re, i), U(Q, o), U(H, null), i.nodeType) {
      case 9:
      case 11:
        o = (o = i.documentElement) && (o = o.namespaceURI) ? Ob(o) : 0;
        break;
      default:
        if (o = i.tagName, i = i.namespaceURI)
          i = Ob(i), o = Mb(i, o);
        else
          switch (o) {
            case "svg":
              o = 1;
              break;
            case "math":
              o = 2;
              break;
            default:
              o = 0;
          }
    }
    X(H), U(H, o);
  }
  function me() {
    X(H), X(Q), X(re);
  }
  function ve(o) {
    o.memoizedState !== null && U(de, o);
    var i = H.current, u = Mb(i, o.type);
    i !== u && (U(Q, o), U(H, u));
  }
  function ae(o) {
    Q.current === o && (X(H), X(Q)), de.current === o && (X(de), Es._currentValue = q);
  }
  var se, pe;
  function ge(o) {
    if (se === void 0)
      try {
        throw Error();
      } catch (u) {
        var i = u.stack.trim().match(/\n( *(at )?)/);
        se = i && i[1] || "", pe = -1 < u.stack.indexOf(`
    at`) ? " (<anonymous>)" : -1 < u.stack.indexOf("@") ? "@unknown:0:0" : "";
      }
    return `
` + se + o + pe;
  }
  var xe = !1;
  function _e(o, i) {
    if (!o || xe) return "";
    xe = !0;
    var u = Error.prepareStackTrace;
    Error.prepareStackTrace = void 0;
    try {
      var f = {
        DetermineComponentFrameRoot: function() {
          try {
            if (i) {
              var fe = function() {
                throw Error();
              };
              if (Object.defineProperty(fe.prototype, "props", {
                set: function() {
                  throw Error();
                }
              }), typeof Reflect == "object" && Reflect.construct) {
                try {
                  Reflect.construct(fe, []);
                } catch (ie) {
                  var oe = ie;
                }
                Reflect.construct(o, [], fe);
              } else {
                try {
                  fe.call();
                } catch (ie) {
                  oe = ie;
                }
                o.call(fe.prototype);
              }
            } else {
              try {
                throw Error();
              } catch (ie) {
                oe = ie;
              }
              (fe = o()) && typeof fe.catch == "function" && fe.catch(function() {
              });
            }
          } catch (ie) {
            if (ie && oe && typeof ie.stack == "string")
              return [ie.stack, oe.stack];
          }
          return [null, null];
        }
      };
      f.DetermineComponentFrameRoot.displayName = "DetermineComponentFrameRoot";
      var g = Object.getOwnPropertyDescriptor(
        f.DetermineComponentFrameRoot,
        "name"
      );
      g && g.configurable && Object.defineProperty(
        f.DetermineComponentFrameRoot,
        "name",
        { value: "DetermineComponentFrameRoot" }
      );
      var S = f.DetermineComponentFrameRoot(), A = S[0], T = S[1];
      if (A && T) {
        var Y = A.split(`
`), ne = T.split(`
`);
        for (g = f = 0; f < Y.length && !Y[f].includes("DetermineComponentFrameRoot"); )
          f++;
        for (; g < ne.length && !ne[g].includes(
          "DetermineComponentFrameRoot"
        ); )
          g++;
        if (f === Y.length || g === ne.length)
          for (f = Y.length - 1, g = ne.length - 1; 1 <= f && 0 <= g && Y[f] !== ne[g]; )
            g--;
        for (; 1 <= f && 0 <= g; f--, g--)
          if (Y[f] !== ne[g]) {
            if (f !== 1 || g !== 1)
              do
                if (f--, g--, 0 > g || Y[f] !== ne[g]) {
                  var ue = `
` + Y[f].replace(" at new ", " at ");
                  return o.displayName && ue.includes("<anonymous>") && (ue = ue.replace("<anonymous>", o.displayName)), ue;
                }
              while (1 <= f && 0 <= g);
            break;
          }
      }
    } finally {
      xe = !1, Error.prepareStackTrace = u;
    }
    return (u = o ? o.displayName || o.name : "") ? ge(u) : "";
  }
  function We(o, i) {
    switch (o.tag) {
      case 26:
      case 27:
      case 5:
        return ge(o.type);
      case 16:
        return ge("Lazy");
      case 13:
        return o.child !== i && i !== null ? ge("Suspense Fallback") : ge("Suspense");
      case 19:
        return ge("SuspenseList");
      case 0:
      case 15:
        return _e(o.type, !1);
      case 11:
        return _e(o.type.render, !1);
      case 1:
        return _e(o.type, !0);
      case 31:
        return ge("Activity");
      default:
        return "";
    }
  }
  function Xe(o) {
    try {
      var i = "", u = null;
      do
        i += We(o, u), u = o, o = o.return;
      while (o);
      return i;
    } catch (f) {
      return `
Error generating stack: ` + f.message + `
` + f.stack;
    }
  }
  var et = Object.prototype.hasOwnProperty, tt = e.unstable_scheduleCallback, je = e.unstable_cancelCallback, an = e.unstable_shouldYield, dt = e.unstable_requestPaint, Ce = e.unstable_now, Me = e.unstable_getCurrentPriorityLevel, he = e.unstable_ImmediatePriority, ye = e.unstable_UserBlockingPriority, Ee = e.unstable_NormalPriority, Le = e.unstable_LowPriority, ze = e.unstable_IdlePriority, It = e.log, zt = e.unstable_setDisableYieldValue, Wt = null, Ot = null;
  function bn(o) {
    if (typeof It == "function" && zt(o), Ot && typeof Ot.setStrictMode == "function")
      try {
        Ot.setStrictMode(Wt, o);
      } catch {
      }
  }
  var Re = Math.clz32 ? Math.clz32 : To, Ft = Math.log, Xt = Math.LN2;
  function To(o) {
    return o >>>= 0, o === 0 ? 32 : 31 - (Ft(o) / Xt | 0) | 0;
  }
  var Lo = 256, dn = 262144, kn = 4194304;
  function wr(o) {
    var i = o & 42;
    if (i !== 0) return i;
    switch (o & -o) {
      case 1:
        return 1;
      case 2:
        return 2;
      case 4:
        return 4;
      case 8:
        return 8;
      case 16:
        return 16;
      case 32:
        return 32;
      case 64:
        return 64;
      case 128:
        return 128;
      case 256:
      case 512:
      case 1024:
      case 2048:
      case 4096:
      case 8192:
      case 16384:
      case 32768:
      case 65536:
      case 131072:
        return o & 261888;
      case 262144:
      case 524288:
      case 1048576:
      case 2097152:
        return o & 3932160;
      case 4194304:
      case 8388608:
      case 16777216:
      case 33554432:
        return o & 62914560;
      case 67108864:
        return 67108864;
      case 134217728:
        return 134217728;
      case 268435456:
        return 268435456;
      case 536870912:
        return 536870912;
      case 1073741824:
        return 0;
      default:
        return o;
    }
  }
  function Io(o, i, u) {
    var f = o.pendingLanes;
    if (f === 0) return 0;
    var g = 0, S = o.suspendedLanes, A = o.pingedLanes;
    o = o.warmLanes;
    var T = f & 134217727;
    return T !== 0 ? (f = T & ~S, f !== 0 ? g = wr(f) : (A &= T, A !== 0 ? g = wr(A) : u || (u = T & ~o, u !== 0 && (g = wr(u))))) : (T = f & ~S, T !== 0 ? g = wr(T) : A !== 0 ? g = wr(A) : u || (u = f & ~o, u !== 0 && (g = wr(u)))), g === 0 ? 0 : i !== 0 && i !== g && (i & S) === 0 && (S = g & -g, u = i & -i, S >= u || S === 32 && (u & 4194048) !== 0) ? i : g;
  }
  function pr(o, i) {
    return (o.pendingLanes & ~(o.suspendedLanes & ~o.pingedLanes) & i) === 0;
  }
  function hg(o, i) {
    switch (o) {
      case 1:
      case 2:
      case 4:
      case 8:
      case 64:
        return i + 250;
      case 16:
      case 32:
      case 128:
      case 256:
      case 512:
      case 1024:
      case 2048:
      case 4096:
      case 8192:
      case 16384:
      case 32768:
      case 65536:
      case 131072:
      case 262144:
      case 524288:
      case 1048576:
      case 2097152:
        return i + 5e3;
      case 4194304:
      case 8388608:
      case 16777216:
      case 33554432:
        return -1;
      case 67108864:
      case 134217728:
      case 268435456:
      case 536870912:
      case 1073741824:
        return -1;
      default:
        return -1;
    }
  }
  function xd() {
    var o = kn;
    return kn <<= 1, (kn & 62914560) === 0 && (kn = 4194304), o;
  }
  function zl(o) {
    for (var i = [], u = 0; 31 > u; u++) i.push(o);
    return i;
  }
  function ja(o, i) {
    o.pendingLanes |= i, i !== 268435456 && (o.suspendedLanes = 0, o.pingedLanes = 0, o.warmLanes = 0);
  }
  function gg(o, i, u, f, g, S) {
    var A = o.pendingLanes;
    o.pendingLanes = u, o.suspendedLanes = 0, o.pingedLanes = 0, o.warmLanes = 0, o.expiredLanes &= u, o.entangledLanes &= u, o.errorRecoveryDisabledLanes &= u, o.shellSuspendCounter = 0;
    var T = o.entanglements, Y = o.expirationTimes, ne = o.hiddenUpdates;
    for (u = A & ~u; 0 < u; ) {
      var ue = 31 - Re(u), fe = 1 << ue;
      T[ue] = 0, Y[ue] = -1;
      var oe = ne[ue];
      if (oe !== null)
        for (ne[ue] = null, ue = 0; ue < oe.length; ue++) {
          var ie = oe[ue];
          ie !== null && (ie.lane &= -536870913);
        }
      u &= ~fe;
    }
    f !== 0 && Sd(o, f, 0), S !== 0 && g === 0 && o.tag !== 0 && (o.suspendedLanes |= S & ~(A & ~i));
  }
  function Sd(o, i, u) {
    o.pendingLanes |= i, o.suspendedLanes &= ~i;
    var f = 31 - Re(i);
    o.entangledLanes |= i, o.entanglements[f] = o.entanglements[f] | 1073741824 | u & 261930;
  }
  function kd(o, i) {
    var u = o.entangledLanes |= i;
    for (o = o.entanglements; u; ) {
      var f = 31 - Re(u), g = 1 << f;
      g & i | o[f] & i && (o[f] |= i), u &= ~g;
    }
  }
  function _d(o, i) {
    var u = i & -i;
    return u = (u & 42) !== 0 ? 1 : Fl(u), (u & (o.suspendedLanes | i)) !== 0 ? 0 : u;
  }
  function Fl(o) {
    switch (o) {
      case 2:
        o = 1;
        break;
      case 8:
        o = 4;
        break;
      case 32:
        o = 16;
        break;
      case 256:
      case 512:
      case 1024:
      case 2048:
      case 4096:
      case 8192:
      case 16384:
      case 32768:
      case 65536:
      case 131072:
      case 262144:
      case 524288:
      case 1048576:
      case 2097152:
      case 4194304:
      case 8388608:
      case 16777216:
      case 33554432:
        o = 128;
        break;
      case 268435456:
        o = 134217728;
        break;
      default:
        o = 0;
    }
    return o;
  }
  function Bl(o) {
    return o &= -o, 2 < o ? 8 < o ? (o & 134217727) !== 0 ? 32 : 268435456 : 8 : 2;
  }
  function Ed() {
    var o = K.p;
    return o !== 0 ? o : (o = window.event, o === void 0 ? 32 : Qb(o.type));
  }
  function Cd(o, i) {
    var u = K.p;
    try {
      return K.p = o, i();
    } finally {
      K.p = u;
    }
  }
  var Dr = Math.random().toString(36).slice(2), Yt = "__reactFiber$" + Dr, mn = "__reactProps$" + Dr, zo = "__reactContainer$" + Dr, Xs = "__reactEvents$" + Dr, Tm = "__reactListeners$" + Dr, vg = "__reactHandles$" + Dr, Od = "__reactResources$" + Dr, Pa = "__reactMarker$" + Dr;
  function Ul(o) {
    delete o[Yt], delete o[mn], delete o[Xs], delete o[Tm], delete o[vg];
  }
  function Qo(o) {
    var i = o[Yt];
    if (i) return i;
    for (var u = o.parentNode; u; ) {
      if (i = u[zo] || u[Yt]) {
        if (u = i.alternate, i.child !== null || u !== null && u.child !== null)
          for (o = $b(o); o !== null; ) {
            if (u = o[Yt]) return u;
            o = $b(o);
          }
        return i;
      }
      o = u, u = o.parentNode;
    }
    return null;
  }
  function Jo(o) {
    if (o = o[Yt] || o[zo]) {
      var i = o.tag;
      if (i === 5 || i === 6 || i === 13 || i === 31 || i === 26 || i === 27 || i === 3)
        return o;
    }
    return null;
  }
  function ka(o) {
    var i = o.tag;
    if (i === 5 || i === 26 || i === 27 || i === 6) return o.stateNode;
    throw Error(r(33));
  }
  function Zo(o) {
    var i = o[Od];
    return i || (i = o[Od] = { hoistableStyles: /* @__PURE__ */ new Map(), hoistableScripts: /* @__PURE__ */ new Map() }), i;
  }
  function Bt(o) {
    o[Pa] = !0;
  }
  var Md = /* @__PURE__ */ new Set(), Nd = {};
  function oo(o, i) {
    ea(o, i), ea(o + "Capture", i);
  }
  function ea(o, i) {
    for (Nd[o] = i, o = 0; o < i.length; o++)
      Md.add(i[o]);
  }
  var yg = RegExp(
    "^[:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD][:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"
  ), Lc = {}, Rd = {};
  function bg(o) {
    return et.call(Rd, o) ? !0 : et.call(Lc, o) ? !1 : yg.test(o) ? Rd[o] = !0 : (Lc[o] = !0, !1);
  }
  function zi(o, i, u) {
    if (bg(i))
      if (u === null) o.removeAttribute(i);
      else {
        switch (typeof u) {
          case "undefined":
          case "function":
          case "symbol":
            o.removeAttribute(i);
            return;
          case "boolean":
            var f = i.toLowerCase().slice(0, 5);
            if (f !== "data-" && f !== "aria-") {
              o.removeAttribute(i);
              return;
            }
        }
        o.setAttribute(i, "" + u);
      }
  }
  function Fi(o, i, u) {
    if (u === null) o.removeAttribute(i);
    else {
      switch (typeof u) {
        case "undefined":
        case "function":
        case "symbol":
        case "boolean":
          o.removeAttribute(i);
          return;
      }
      o.setAttribute(i, "" + u);
    }
  }
  function xr(o, i, u, f) {
    if (f === null) o.removeAttribute(u);
    else {
      switch (typeof f) {
        case "undefined":
        case "function":
        case "symbol":
        case "boolean":
          o.removeAttribute(u);
          return;
      }
      o.setAttributeNS(i, u, "" + f);
    }
  }
  function Tn(o) {
    switch (typeof o) {
      case "bigint":
      case "boolean":
      case "number":
      case "string":
      case "undefined":
        return o;
      case "object":
        return o;
      default:
        return "";
    }
  }
  function Ad(o) {
    var i = o.type;
    return (o = o.nodeName) && o.toLowerCase() === "input" && (i === "checkbox" || i === "radio");
  }
  function wg(o, i, u) {
    var f = Object.getOwnPropertyDescriptor(
      o.constructor.prototype,
      i
    );
    if (!o.hasOwnProperty(i) && typeof f < "u" && typeof f.get == "function" && typeof f.set == "function") {
      var g = f.get, S = f.set;
      return Object.defineProperty(o, i, {
        configurable: !0,
        get: function() {
          return g.call(this);
        },
        set: function(A) {
          u = "" + A, S.call(this, A);
        }
      }), Object.defineProperty(o, i, {
        enumerable: f.enumerable
      }), {
        getValue: function() {
          return u;
        },
        setValue: function(A) {
          u = "" + A;
        },
        stopTracking: function() {
          o._valueTracker = null, delete o[i];
        }
      };
    }
  }
  function Ys(o) {
    if (!o._valueTracker) {
      var i = Ad(o) ? "checked" : "value";
      o._valueTracker = wg(
        o,
        i,
        "" + o[i]
      );
    }
  }
  function jd(o) {
    if (!o) return !1;
    var i = o._valueTracker;
    if (!i) return !0;
    var u = i.getValue(), f = "";
    return o && (f = Ad(o) ? o.checked ? "true" : "false" : o.value), o = f, o !== u ? (i.setValue(o), !0) : !1;
  }
  function Ei(o) {
    if (o = o || (typeof document < "u" ? document : void 0), typeof o > "u") return null;
    try {
      return o.activeElement || o.body;
    } catch {
      return o.body;
    }
  }
  var xg = /[\n"\\]/g;
  function Gn(o) {
    return o.replace(
      xg,
      function(i) {
        return "\\" + i.charCodeAt(0).toString(16) + " ";
      }
    );
  }
  function Bi(o, i, u, f, g, S, A, T) {
    o.name = "", A != null && typeof A != "function" && typeof A != "symbol" && typeof A != "boolean" ? o.type = A : o.removeAttribute("type"), i != null ? A === "number" ? (i === 0 && o.value === "" || o.value != i) && (o.value = "" + Tn(i)) : o.value !== "" + Tn(i) && (o.value = "" + Tn(i)) : A !== "submit" && A !== "reset" || o.removeAttribute("value"), i != null ? Vl(o, A, Tn(i)) : u != null ? Vl(o, A, Tn(u)) : f != null && o.removeAttribute("value"), g == null && S != null && (o.defaultChecked = !!S), g != null && (o.checked = g && typeof g != "function" && typeof g != "symbol"), T != null && typeof T != "function" && typeof T != "symbol" && typeof T != "boolean" ? o.name = "" + Tn(T) : o.removeAttribute("name");
  }
  function Pd(o, i, u, f, g, S, A, T) {
    if (S != null && typeof S != "function" && typeof S != "symbol" && typeof S != "boolean" && (o.type = S), i != null || u != null) {
      if (!(S !== "submit" && S !== "reset" || i != null)) {
        Ys(o);
        return;
      }
      u = u != null ? "" + Tn(u) : "", i = i != null ? "" + Tn(i) : u, T || i === o.value || (o.value = i), o.defaultValue = i;
    }
    f = f ?? g, f = typeof f != "function" && typeof f != "symbol" && !!f, o.checked = T ? o.checked : !!f, o.defaultChecked = !!f, A != null && typeof A != "function" && typeof A != "symbol" && typeof A != "boolean" && (o.name = A), Ys(o);
  }
  function Vl(o, i, u) {
    i === "number" && Ei(o.ownerDocument) === o || o.defaultValue === "" + u || (o.defaultValue = "" + u);
  }
  function Fo(o, i, u, f) {
    if (o = o.options, i) {
      i = {};
      for (var g = 0; g < u.length; g++)
        i["$" + u[g]] = !0;
      for (u = 0; u < o.length; u++)
        g = i.hasOwnProperty("$" + o[u].value), o[u].selected !== g && (o[u].selected = g), g && f && (o[u].defaultSelected = !0);
    } else {
      for (u = "" + Tn(u), i = null, g = 0; g < o.length; g++) {
        if (o[g].value === u) {
          o[g].selected = !0, f && (o[g].defaultSelected = !0);
          return;
        }
        i !== null || o[g].disabled || (i = o[g]);
      }
      i !== null && (i.selected = !0);
    }
  }
  function Sg(o, i, u) {
    if (i != null && (i = "" + Tn(i), i !== o.value && (o.value = i), u == null)) {
      o.defaultValue !== i && (o.defaultValue = i);
      return;
    }
    o.defaultValue = u != null ? "" + Tn(u) : "";
  }
  function kg(o, i, u, f) {
    if (i == null) {
      if (f != null) {
        if (u != null) throw Error(r(92));
        if (G(f)) {
          if (1 < f.length) throw Error(r(93));
          f = f[0];
        }
        u = f;
      }
      u == null && (u = ""), i = u;
    }
    u = Tn(i), o.defaultValue = u, f = o.textContent, f === u && f !== "" && f !== null && (o.value = f), Ys(o);
  }
  function Da(o, i) {
    if (i) {
      var u = o.firstChild;
      if (u && u === o.lastChild && u.nodeType === 3) {
        u.nodeValue = i;
        return;
      }
    }
    o.textContent = i;
  }
  var TE = new Set(
    "animationIterationCount aspectRatio borderImageOutset borderImageSlice borderImageWidth boxFlex boxFlexGroup boxOrdinalGroup columnCount columns flex flexGrow flexPositive flexShrink flexNegative flexOrder gridArea gridRow gridRowEnd gridRowSpan gridRowStart gridColumn gridColumnEnd gridColumnSpan gridColumnStart fontWeight lineClamp lineHeight opacity order orphans scale tabSize widows zIndex zoom fillOpacity floodOpacity stopOpacity strokeDasharray strokeDashoffset strokeMiterlimit strokeOpacity strokeWidth MozAnimationIterationCount MozBoxFlex MozBoxFlexGroup MozLineClamp msAnimationIterationCount msFlex msZoom msFlexGrow msFlexNegative msFlexOrder msFlexPositive msFlexShrink msGridColumn msGridColumnSpan msGridRow msGridRowSpan WebkitAnimationIterationCount WebkitBoxFlex WebKitBoxFlexGroup WebkitBoxOrdinalGroup WebkitColumnCount WebkitColumns WebkitFlex WebkitFlexGrow WebkitFlexPositive WebkitFlexShrink WebkitLineClamp".split(
      " "
    )
  );
  function _g(o, i, u) {
    var f = i.indexOf("--") === 0;
    u == null || typeof u == "boolean" || u === "" ? f ? o.setProperty(i, "") : i === "float" ? o.cssFloat = "" : o[i] = "" : f ? o.setProperty(i, u) : typeof u != "number" || u === 0 || TE.has(i) ? i === "float" ? o.cssFloat = u : o[i] = ("" + u).trim() : o[i] = u + "px";
  }
  function Eg(o, i, u) {
    if (i != null && typeof i != "object")
      throw Error(r(62));
    if (o = o.style, u != null) {
      for (var f in u)
        !u.hasOwnProperty(f) || i != null && i.hasOwnProperty(f) || (f.indexOf("--") === 0 ? o.setProperty(f, "") : f === "float" ? o.cssFloat = "" : o[f] = "");
      for (var g in i)
        f = i[g], i.hasOwnProperty(g) && u[g] !== f && _g(o, g, f);
    } else
      for (var S in i)
        i.hasOwnProperty(S) && _g(o, S, i[S]);
  }
  function Dd(o) {
    if (o.indexOf("-") === -1) return !1;
    switch (o) {
      case "annotation-xml":
      case "color-profile":
      case "font-face":
      case "font-face-src":
      case "font-face-uri":
      case "font-face-format":
      case "font-face-name":
      case "missing-glyph":
        return !1;
      default:
        return !0;
    }
  }
  var LE = /* @__PURE__ */ new Map([
    ["acceptCharset", "accept-charset"],
    ["htmlFor", "for"],
    ["httpEquiv", "http-equiv"],
    ["crossOrigin", "crossorigin"],
    ["accentHeight", "accent-height"],
    ["alignmentBaseline", "alignment-baseline"],
    ["arabicForm", "arabic-form"],
    ["baselineShift", "baseline-shift"],
    ["capHeight", "cap-height"],
    ["clipPath", "clip-path"],
    ["clipRule", "clip-rule"],
    ["colorInterpolation", "color-interpolation"],
    ["colorInterpolationFilters", "color-interpolation-filters"],
    ["colorProfile", "color-profile"],
    ["colorRendering", "color-rendering"],
    ["dominantBaseline", "dominant-baseline"],
    ["enableBackground", "enable-background"],
    ["fillOpacity", "fill-opacity"],
    ["fillRule", "fill-rule"],
    ["floodColor", "flood-color"],
    ["floodOpacity", "flood-opacity"],
    ["fontFamily", "font-family"],
    ["fontSize", "font-size"],
    ["fontSizeAdjust", "font-size-adjust"],
    ["fontStretch", "font-stretch"],
    ["fontStyle", "font-style"],
    ["fontVariant", "font-variant"],
    ["fontWeight", "font-weight"],
    ["glyphName", "glyph-name"],
    ["glyphOrientationHorizontal", "glyph-orientation-horizontal"],
    ["glyphOrientationVertical", "glyph-orientation-vertical"],
    ["horizAdvX", "horiz-adv-x"],
    ["horizOriginX", "horiz-origin-x"],
    ["imageRendering", "image-rendering"],
    ["letterSpacing", "letter-spacing"],
    ["lightingColor", "lighting-color"],
    ["markerEnd", "marker-end"],
    ["markerMid", "marker-mid"],
    ["markerStart", "marker-start"],
    ["overlinePosition", "overline-position"],
    ["overlineThickness", "overline-thickness"],
    ["paintOrder", "paint-order"],
    ["panose-1", "panose-1"],
    ["pointerEvents", "pointer-events"],
    ["renderingIntent", "rendering-intent"],
    ["shapeRendering", "shape-rendering"],
    ["stopColor", "stop-color"],
    ["stopOpacity", "stop-opacity"],
    ["strikethroughPosition", "strikethrough-position"],
    ["strikethroughThickness", "strikethrough-thickness"],
    ["strokeDasharray", "stroke-dasharray"],
    ["strokeDashoffset", "stroke-dashoffset"],
    ["strokeLinecap", "stroke-linecap"],
    ["strokeLinejoin", "stroke-linejoin"],
    ["strokeMiterlimit", "stroke-miterlimit"],
    ["strokeOpacity", "stroke-opacity"],
    ["strokeWidth", "stroke-width"],
    ["textAnchor", "text-anchor"],
    ["textDecoration", "text-decoration"],
    ["textRendering", "text-rendering"],
    ["transformOrigin", "transform-origin"],
    ["underlinePosition", "underline-position"],
    ["underlineThickness", "underline-thickness"],
    ["unicodeBidi", "unicode-bidi"],
    ["unicodeRange", "unicode-range"],
    ["unitsPerEm", "units-per-em"],
    ["vAlphabetic", "v-alphabetic"],
    ["vHanging", "v-hanging"],
    ["vIdeographic", "v-ideographic"],
    ["vMathematical", "v-mathematical"],
    ["vectorEffect", "vector-effect"],
    ["vertAdvY", "vert-adv-y"],
    ["vertOriginX", "vert-origin-x"],
    ["vertOriginY", "vert-origin-y"],
    ["wordSpacing", "word-spacing"],
    ["writingMode", "writing-mode"],
    ["xmlnsXlink", "xmlns:xlink"],
    ["xHeight", "x-height"]
  ]), IE = /^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*:/i;
  function Hl(o) {
    return IE.test("" + o) ? "javascript:throw new Error('React has blocked a javascript: URL as a security precaution.')" : o;
  }
  function $r() {
  }
  var $d = null;
  function Td(o) {
    return o = o.target || o.srcElement || window, o.correspondingUseElement && (o = o.correspondingUseElement), o.nodeType === 3 ? o.parentNode : o;
  }
  var $a = null, Ta = null;
  function Cg(o) {
    var i = Jo(o);
    if (i && (o = i.stateNode)) {
      var u = o[mn] || null;
      e: switch (o = i.stateNode, i.type) {
        case "input":
          if (Bi(
            o,
            u.value,
            u.defaultValue,
            u.defaultValue,
            u.checked,
            u.defaultChecked,
            u.type,
            u.name
          ), i = u.name, u.type === "radio" && i != null) {
            for (u = o; u.parentNode; ) u = u.parentNode;
            for (u = u.querySelectorAll(
              'input[name="' + Gn(
                "" + i
              ) + '"][type="radio"]'
            ), i = 0; i < u.length; i++) {
              var f = u[i];
              if (f !== o && f.form === o.form) {
                var g = f[mn] || null;
                if (!g) throw Error(r(90));
                Bi(
                  f,
                  g.value,
                  g.defaultValue,
                  g.defaultValue,
                  g.checked,
                  g.defaultChecked,
                  g.type,
                  g.name
                );
              }
            }
            for (i = 0; i < u.length; i++)
              f = u[i], f.form === o.form && jd(f);
          }
          break e;
        case "textarea":
          Sg(o, u.value, u.defaultValue);
          break e;
        case "select":
          i = u.value, i != null && Fo(o, !!u.multiple, i, !1);
      }
    }
  }
  var Ld = !1;
  function Og(o, i, u) {
    if (Ld) return o(i, u);
    Ld = !0;
    try {
      var f = o(i);
      return f;
    } finally {
      if (Ld = !1, ($a !== null || Ta !== null) && (Au(), $a && (i = $a, o = Ta, Ta = $a = null, Cg(i), o)))
        for (i = 0; i < o.length; i++) Cg(o[i]);
    }
  }
  function Ui(o, i) {
    var u = o.stateNode;
    if (u === null) return null;
    var f = u[mn] || null;
    if (f === null) return null;
    u = f[i];
    e: switch (i) {
      case "onClick":
      case "onClickCapture":
      case "onDoubleClick":
      case "onDoubleClickCapture":
      case "onMouseDown":
      case "onMouseDownCapture":
      case "onMouseMove":
      case "onMouseMoveCapture":
      case "onMouseUp":
      case "onMouseUpCapture":
      case "onMouseEnter":
        (f = !f.disabled) || (o = o.type, f = !(o === "button" || o === "input" || o === "select" || o === "textarea")), o = !f;
        break e;
      default:
        o = !1;
    }
    if (o) return null;
    if (u && typeof u != "function")
      throw Error(
        r(231, i, typeof u)
      );
    return u;
  }
  var Tr = !(typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u"), Id = !1;
  if (Tr)
    try {
      var Vi = {};
      Object.defineProperty(Vi, "passive", {
        get: function() {
          Id = !0;
        }
      }), window.addEventListener("test", Vi, Vi), window.removeEventListener("test", Vi, Vi);
    } catch {
      Id = !1;
    }
  var ao = null, zd = null, ql = null;
  function Mg() {
    if (ql) return ql;
    var o, i = zd, u = i.length, f, g = "value" in ao ? ao.value : ao.textContent, S = g.length;
    for (o = 0; o < u && i[o] === g[o]; o++) ;
    var A = u - o;
    for (f = 1; f <= A && i[u - f] === g[S - f]; f++) ;
    return ql = g.slice(o, 1 < f ? 1 - f : void 0);
  }
  function Wl(o) {
    var i = o.keyCode;
    return "charCode" in o ? (o = o.charCode, o === 0 && i === 13 && (o = 13)) : o = i, o === 10 && (o = 13), 32 <= o || o === 13 ? o : 0;
  }
  function Gl() {
    return !0;
  }
  function Ng() {
    return !1;
  }
  function _n(o) {
    function i(u, f, g, S, A) {
      this._reactName = u, this._targetInst = g, this.type = f, this.nativeEvent = S, this.target = A, this.currentTarget = null;
      for (var T in o)
        o.hasOwnProperty(T) && (u = o[T], this[T] = u ? u(S) : S[T]);
      return this.isDefaultPrevented = (S.defaultPrevented != null ? S.defaultPrevented : S.returnValue === !1) ? Gl : Ng, this.isPropagationStopped = Ng, this;
    }
    return h(i.prototype, {
      preventDefault: function() {
        this.defaultPrevented = !0;
        var u = this.nativeEvent;
        u && (u.preventDefault ? u.preventDefault() : typeof u.returnValue != "unknown" && (u.returnValue = !1), this.isDefaultPrevented = Gl);
      },
      stopPropagation: function() {
        var u = this.nativeEvent;
        u && (u.stopPropagation ? u.stopPropagation() : typeof u.cancelBubble != "unknown" && (u.cancelBubble = !0), this.isPropagationStopped = Gl);
      },
      persist: function() {
      },
      isPersistent: Gl
    }), i;
  }
  var ta = {
    eventPhase: 0,
    bubbles: 0,
    cancelable: 0,
    timeStamp: function(o) {
      return o.timeStamp || Date.now();
    },
    defaultPrevented: 0,
    isTrusted: 0
  }, Kl = _n(ta), Hi = h({}, ta, { view: 0, detail: 0 }), zE = _n(Hi), Fd, Bd, qi, Xl = h({}, Hi, {
    screenX: 0,
    screenY: 0,
    clientX: 0,
    clientY: 0,
    pageX: 0,
    pageY: 0,
    ctrlKey: 0,
    shiftKey: 0,
    altKey: 0,
    metaKey: 0,
    getModifierState: Vd,
    button: 0,
    buttons: 0,
    relatedTarget: function(o) {
      return o.relatedTarget === void 0 ? o.fromElement === o.srcElement ? o.toElement : o.fromElement : o.relatedTarget;
    },
    movementX: function(o) {
      return "movementX" in o ? o.movementX : (o !== qi && (qi && o.type === "mousemove" ? (Fd = o.screenX - qi.screenX, Bd = o.screenY - qi.screenY) : Bd = Fd = 0, qi = o), Fd);
    },
    movementY: function(o) {
      return "movementY" in o ? o.movementY : Bd;
    }
  }), Rg = _n(Xl), FE = h({}, Xl, { dataTransfer: 0 }), BE = _n(FE), UE = h({}, Hi, { relatedTarget: 0 }), Ud = _n(UE), VE = h({}, ta, {
    animationName: 0,
    elapsedTime: 0,
    pseudoElement: 0
  }), HE = _n(VE), qE = h({}, ta, {
    clipboardData: function(o) {
      return "clipboardData" in o ? o.clipboardData : window.clipboardData;
    }
  }), WE = _n(qE), GE = h({}, ta, { data: 0 }), Ag = _n(GE), KE = {
    Esc: "Escape",
    Spacebar: " ",
    Left: "ArrowLeft",
    Up: "ArrowUp",
    Right: "ArrowRight",
    Down: "ArrowDown",
    Del: "Delete",
    Win: "OS",
    Menu: "ContextMenu",
    Apps: "ContextMenu",
    Scroll: "ScrollLock",
    MozPrintableKey: "Unidentified"
  }, XE = {
    8: "Backspace",
    9: "Tab",
    12: "Clear",
    13: "Enter",
    16: "Shift",
    17: "Control",
    18: "Alt",
    19: "Pause",
    20: "CapsLock",
    27: "Escape",
    32: " ",
    33: "PageUp",
    34: "PageDown",
    35: "End",
    36: "Home",
    37: "ArrowLeft",
    38: "ArrowUp",
    39: "ArrowRight",
    40: "ArrowDown",
    45: "Insert",
    46: "Delete",
    112: "F1",
    113: "F2",
    114: "F3",
    115: "F4",
    116: "F5",
    117: "F6",
    118: "F7",
    119: "F8",
    120: "F9",
    121: "F10",
    122: "F11",
    123: "F12",
    144: "NumLock",
    145: "ScrollLock",
    224: "Meta"
  }, YE = {
    Alt: "altKey",
    Control: "ctrlKey",
    Meta: "metaKey",
    Shift: "shiftKey"
  };
  function QE(o) {
    var i = this.nativeEvent;
    return i.getModifierState ? i.getModifierState(o) : (o = YE[o]) ? !!i[o] : !1;
  }
  function Vd() {
    return QE;
  }
  var JE = h({}, Hi, {
    key: function(o) {
      if (o.key) {
        var i = KE[o.key] || o.key;
        if (i !== "Unidentified") return i;
      }
      return o.type === "keypress" ? (o = Wl(o), o === 13 ? "Enter" : String.fromCharCode(o)) : o.type === "keydown" || o.type === "keyup" ? XE[o.keyCode] || "Unidentified" : "";
    },
    code: 0,
    location: 0,
    ctrlKey: 0,
    shiftKey: 0,
    altKey: 0,
    metaKey: 0,
    repeat: 0,
    locale: 0,
    getModifierState: Vd,
    charCode: function(o) {
      return o.type === "keypress" ? Wl(o) : 0;
    },
    keyCode: function(o) {
      return o.type === "keydown" || o.type === "keyup" ? o.keyCode : 0;
    },
    which: function(o) {
      return o.type === "keypress" ? Wl(o) : o.type === "keydown" || o.type === "keyup" ? o.keyCode : 0;
    }
  }), ZE = _n(JE), eC = h({}, Xl, {
    pointerId: 0,
    width: 0,
    height: 0,
    pressure: 0,
    tangentialPressure: 0,
    tiltX: 0,
    tiltY: 0,
    twist: 0,
    pointerType: 0,
    isPrimary: 0
  }), jg = _n(eC), tC = h({}, Hi, {
    touches: 0,
    targetTouches: 0,
    changedTouches: 0,
    altKey: 0,
    metaKey: 0,
    ctrlKey: 0,
    shiftKey: 0,
    getModifierState: Vd
  }), nC = _n(tC), rC = h({}, ta, {
    propertyName: 0,
    elapsedTime: 0,
    pseudoElement: 0
  }), oC = _n(rC), aC = h({}, Xl, {
    deltaX: function(o) {
      return "deltaX" in o ? o.deltaX : "wheelDeltaX" in o ? -o.wheelDeltaX : 0;
    },
    deltaY: function(o) {
      return "deltaY" in o ? o.deltaY : "wheelDeltaY" in o ? -o.wheelDeltaY : "wheelDelta" in o ? -o.wheelDelta : 0;
    },
    deltaZ: 0,
    deltaMode: 0
  }), iC = _n(aC), sC = h({}, ta, {
    newState: 0,
    oldState: 0
  }), lC = _n(sC), uC = [9, 13, 27, 32], Hd = Tr && "CompositionEvent" in window, Wi = null;
  Tr && "documentMode" in document && (Wi = document.documentMode);
  var cC = Tr && "TextEvent" in window && !Wi, Pg = Tr && (!Hd || Wi && 8 < Wi && 11 >= Wi), Dg = " ", $g = !1;
  function Tg(o, i) {
    switch (o) {
      case "keyup":
        return uC.indexOf(i.keyCode) !== -1;
      case "keydown":
        return i.keyCode !== 229;
      case "keypress":
      case "mousedown":
      case "focusout":
        return !0;
      default:
        return !1;
    }
  }
  function Lg(o) {
    return o = o.detail, typeof o == "object" && "data" in o ? o.data : null;
  }
  var La = !1;
  function dC(o, i) {
    switch (o) {
      case "compositionend":
        return Lg(i);
      case "keypress":
        return i.which !== 32 ? null : ($g = !0, Dg);
      case "textInput":
        return o = i.data, o === Dg && $g ? null : o;
      default:
        return null;
    }
  }
  function fC(o, i) {
    if (La)
      return o === "compositionend" || !Hd && Tg(o, i) ? (o = Mg(), ql = zd = ao = null, La = !1, o) : null;
    switch (o) {
      case "paste":
        return null;
      case "keypress":
        if (!(i.ctrlKey || i.altKey || i.metaKey) || i.ctrlKey && i.altKey) {
          if (i.char && 1 < i.char.length)
            return i.char;
          if (i.which) return String.fromCharCode(i.which);
        }
        return null;
      case "compositionend":
        return Pg && i.locale !== "ko" ? null : i.data;
      default:
        return null;
    }
  }
  var pC = {
    color: !0,
    date: !0,
    datetime: !0,
    "datetime-local": !0,
    email: !0,
    month: !0,
    number: !0,
    password: !0,
    range: !0,
    search: !0,
    tel: !0,
    text: !0,
    time: !0,
    url: !0,
    week: !0
  };
  function Ig(o) {
    var i = o && o.nodeName && o.nodeName.toLowerCase();
    return i === "input" ? !!pC[o.type] : i === "textarea";
  }
  function zg(o, i, u, f) {
    $a ? Ta ? Ta.push(f) : Ta = [f] : $a = f, i = Iu(i, "onChange"), 0 < i.length && (u = new Kl(
      "onChange",
      "change",
      null,
      u,
      f
    ), o.push({ event: u, listeners: i }));
  }
  var Gi = null, Ki = null;
  function mC(o) {
    xb(o, 0);
  }
  function Yl(o) {
    var i = ka(o);
    if (jd(i)) return o;
  }
  function Fg(o, i) {
    if (o === "change") return i;
  }
  var Bg = !1;
  if (Tr) {
    var qd;
    if (Tr) {
      var Wd = "oninput" in document;
      if (!Wd) {
        var Ug = document.createElement("div");
        Ug.setAttribute("oninput", "return;"), Wd = typeof Ug.oninput == "function";
      }
      qd = Wd;
    } else qd = !1;
    Bg = qd && (!document.documentMode || 9 < document.documentMode);
  }
  function Vg() {
    Gi && (Gi.detachEvent("onpropertychange", Hg), Ki = Gi = null);
  }
  function Hg(o) {
    if (o.propertyName === "value" && Yl(Ki)) {
      var i = [];
      zg(
        i,
        Ki,
        o,
        Td(o)
      ), Og(mC, i);
    }
  }
  function hC(o, i, u) {
    o === "focusin" ? (Vg(), Gi = i, Ki = u, Gi.attachEvent("onpropertychange", Hg)) : o === "focusout" && Vg();
  }
  function gC(o) {
    if (o === "selectionchange" || o === "keyup" || o === "keydown")
      return Yl(Ki);
  }
  function vC(o, i) {
    if (o === "click") return Yl(i);
  }
  function yC(o, i) {
    if (o === "input" || o === "change")
      return Yl(i);
  }
  function bC(o, i) {
    return o === i && (o !== 0 || 1 / o === 1 / i) || o !== o && i !== i;
  }
  var Ln = typeof Object.is == "function" ? Object.is : bC;
  function Xi(o, i) {
    if (Ln(o, i)) return !0;
    if (typeof o != "object" || o === null || typeof i != "object" || i === null)
      return !1;
    var u = Object.keys(o), f = Object.keys(i);
    if (u.length !== f.length) return !1;
    for (f = 0; f < u.length; f++) {
      var g = u[f];
      if (!et.call(i, g) || !Ln(o[g], i[g]))
        return !1;
    }
    return !0;
  }
  function qg(o) {
    for (; o && o.firstChild; ) o = o.firstChild;
    return o;
  }
  function Wg(o, i) {
    var u = qg(o);
    o = 0;
    for (var f; u; ) {
      if (u.nodeType === 3) {
        if (f = o + u.textContent.length, o <= i && f >= i)
          return { node: u, offset: i - o };
        o = f;
      }
      e: {
        for (; u; ) {
          if (u.nextSibling) {
            u = u.nextSibling;
            break e;
          }
          u = u.parentNode;
        }
        u = void 0;
      }
      u = qg(u);
    }
  }
  function Gg(o, i) {
    return o && i ? o === i ? !0 : o && o.nodeType === 3 ? !1 : i && i.nodeType === 3 ? Gg(o, i.parentNode) : "contains" in o ? o.contains(i) : o.compareDocumentPosition ? !!(o.compareDocumentPosition(i) & 16) : !1 : !1;
  }
  function Kg(o) {
    o = o != null && o.ownerDocument != null && o.ownerDocument.defaultView != null ? o.ownerDocument.defaultView : window;
    for (var i = Ei(o.document); i instanceof o.HTMLIFrameElement; ) {
      try {
        var u = typeof i.contentWindow.location.href == "string";
      } catch {
        u = !1;
      }
      if (u) o = i.contentWindow;
      else break;
      i = Ei(o.document);
    }
    return i;
  }
  function Gd(o) {
    var i = o && o.nodeName && o.nodeName.toLowerCase();
    return i && (i === "input" && (o.type === "text" || o.type === "search" || o.type === "tel" || o.type === "url" || o.type === "password") || i === "textarea" || o.contentEditable === "true");
  }
  var wC = Tr && "documentMode" in document && 11 >= document.documentMode, Ia = null, Kd = null, Yi = null, Xd = !1;
  function Xg(o, i, u) {
    var f = u.window === u ? u.document : u.nodeType === 9 ? u : u.ownerDocument;
    Xd || Ia == null || Ia !== Ei(f) || (f = Ia, "selectionStart" in f && Gd(f) ? f = { start: f.selectionStart, end: f.selectionEnd } : (f = (f.ownerDocument && f.ownerDocument.defaultView || window).getSelection(), f = {
      anchorNode: f.anchorNode,
      anchorOffset: f.anchorOffset,
      focusNode: f.focusNode,
      focusOffset: f.focusOffset
    }), Yi && Xi(Yi, f) || (Yi = f, f = Iu(Kd, "onSelect"), 0 < f.length && (i = new Kl(
      "onSelect",
      "select",
      null,
      i,
      u
    ), o.push({ event: i, listeners: f }), i.target = Ia)));
  }
  function na(o, i) {
    var u = {};
    return u[o.toLowerCase()] = i.toLowerCase(), u["Webkit" + o] = "webkit" + i, u["Moz" + o] = "moz" + i, u;
  }
  var za = {
    animationend: na("Animation", "AnimationEnd"),
    animationiteration: na("Animation", "AnimationIteration"),
    animationstart: na("Animation", "AnimationStart"),
    transitionrun: na("Transition", "TransitionRun"),
    transitionstart: na("Transition", "TransitionStart"),
    transitioncancel: na("Transition", "TransitionCancel"),
    transitionend: na("Transition", "TransitionEnd")
  }, Yd = {}, Yg = {};
  Tr && (Yg = document.createElement("div").style, "AnimationEvent" in window || (delete za.animationend.animation, delete za.animationiteration.animation, delete za.animationstart.animation), "TransitionEvent" in window || delete za.transitionend.transition);
  function ra(o) {
    if (Yd[o]) return Yd[o];
    if (!za[o]) return o;
    var i = za[o], u;
    for (u in i)
      if (i.hasOwnProperty(u) && u in Yg)
        return Yd[o] = i[u];
    return o;
  }
  var Qg = ra("animationend"), Jg = ra("animationiteration"), Zg = ra("animationstart"), xC = ra("transitionrun"), SC = ra("transitionstart"), kC = ra("transitioncancel"), ev = ra("transitionend"), tv = /* @__PURE__ */ new Map(), Qd = "abort auxClick beforeToggle cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(
    " "
  );
  Qd.push("scrollEnd");
  function mr(o, i) {
    tv.set(o, i), oo(i, [o]);
  }
  var Ql = typeof reportError == "function" ? reportError : function(o) {
    if (typeof window == "object" && typeof window.ErrorEvent == "function") {
      var i = new window.ErrorEvent("error", {
        bubbles: !0,
        cancelable: !0,
        message: typeof o == "object" && o !== null && typeof o.message == "string" ? String(o.message) : String(o),
        error: o
      });
      if (!window.dispatchEvent(i)) return;
    } else if (typeof process == "object" && typeof process.emit == "function") {
      process.emit("uncaughtException", o);
      return;
    }
    console.error(o);
  }, Jn = [], Fa = 0, Jd = 0;
  function Jl() {
    for (var o = Fa, i = Jd = Fa = 0; i < o; ) {
      var u = Jn[i];
      Jn[i++] = null;
      var f = Jn[i];
      Jn[i++] = null;
      var g = Jn[i];
      Jn[i++] = null;
      var S = Jn[i];
      if (Jn[i++] = null, f !== null && g !== null) {
        var A = f.pending;
        A === null ? g.next = g : (g.next = A.next, A.next = g), f.pending = g;
      }
      S !== 0 && nv(u, g, S);
    }
  }
  function Zl(o, i, u, f) {
    Jn[Fa++] = o, Jn[Fa++] = i, Jn[Fa++] = u, Jn[Fa++] = f, Jd |= f, o.lanes |= f, o = o.alternate, o !== null && (o.lanes |= f);
  }
  function Zd(o, i, u, f) {
    return Zl(o, i, u, f), eu(o);
  }
  function oa(o, i) {
    return Zl(o, null, null, i), eu(o);
  }
  function nv(o, i, u) {
    o.lanes |= u;
    var f = o.alternate;
    f !== null && (f.lanes |= u);
    for (var g = !1, S = o.return; S !== null; )
      S.childLanes |= u, f = S.alternate, f !== null && (f.childLanes |= u), S.tag === 22 && (o = S.stateNode, o === null || o._visibility & 1 || (g = !0)), o = S, S = S.return;
    return o.tag === 3 ? (S = o.stateNode, g && i !== null && (g = 31 - Re(u), o = S.hiddenUpdates, f = o[g], f === null ? o[g] = [i] : f.push(i), i.lane = u | 536870912), S) : null;
  }
  function eu(o) {
    if (50 < ys)
      throw ys = 0, up = null, Error(r(185));
    for (var i = o.return; i !== null; )
      o = i, i = o.return;
    return o.tag === 3 ? o.stateNode : null;
  }
  var Ba = {};
  function _C(o, i, u, f) {
    this.tag = o, this.key = u, this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null, this.index = 0, this.refCleanup = this.ref = null, this.pendingProps = i, this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null, this.mode = f, this.subtreeFlags = this.flags = 0, this.deletions = null, this.childLanes = this.lanes = 0, this.alternate = null;
  }
  function In(o, i, u, f) {
    return new _C(o, i, u, f);
  }
  function ef(o) {
    return o = o.prototype, !(!o || !o.isReactComponent);
  }
  function Lr(o, i) {
    var u = o.alternate;
    return u === null ? (u = In(
      o.tag,
      i,
      o.key,
      o.mode
    ), u.elementType = o.elementType, u.type = o.type, u.stateNode = o.stateNode, u.alternate = o, o.alternate = u) : (u.pendingProps = i, u.type = o.type, u.flags = 0, u.subtreeFlags = 0, u.deletions = null), u.flags = o.flags & 65011712, u.childLanes = o.childLanes, u.lanes = o.lanes, u.child = o.child, u.memoizedProps = o.memoizedProps, u.memoizedState = o.memoizedState, u.updateQueue = o.updateQueue, i = o.dependencies, u.dependencies = i === null ? null : { lanes: i.lanes, firstContext: i.firstContext }, u.sibling = o.sibling, u.index = o.index, u.ref = o.ref, u.refCleanup = o.refCleanup, u;
  }
  function rv(o, i) {
    o.flags &= 65011714;
    var u = o.alternate;
    return u === null ? (o.childLanes = 0, o.lanes = i, o.child = null, o.subtreeFlags = 0, o.memoizedProps = null, o.memoizedState = null, o.updateQueue = null, o.dependencies = null, o.stateNode = null) : (o.childLanes = u.childLanes, o.lanes = u.lanes, o.child = u.child, o.subtreeFlags = 0, o.deletions = null, o.memoizedProps = u.memoizedProps, o.memoizedState = u.memoizedState, o.updateQueue = u.updateQueue, o.type = u.type, i = u.dependencies, o.dependencies = i === null ? null : {
      lanes: i.lanes,
      firstContext: i.firstContext
    }), o;
  }
  function tu(o, i, u, f, g, S) {
    var A = 0;
    if (f = o, typeof o == "function") ef(o) && (A = 1);
    else if (typeof o == "string")
      A = NO(
        o,
        u,
        H.current
      ) ? 26 : o === "html" || o === "head" || o === "body" ? 27 : 5;
    else
      e: switch (o) {
        case $:
          return o = In(31, u, i, g), o.elementType = $, o.lanes = S, o;
        case x:
          return aa(u.children, g, S, i);
        case b:
          A = 8, g |= 24;
          break;
        case k:
          return o = In(12, u, i, g | 2), o.elementType = k, o.lanes = S, o;
        case N:
          return o = In(13, u, i, g), o.elementType = N, o.lanes = S, o;
        case R:
          return o = In(19, u, i, g), o.elementType = R, o.lanes = S, o;
        default:
          if (typeof o == "object" && o !== null)
            switch (o.$$typeof) {
              case _:
                A = 10;
                break e;
              case C:
                A = 9;
                break e;
              case O:
                A = 11;
                break e;
              case j:
                A = 14;
                break e;
              case D:
                A = 16, f = null;
                break e;
            }
          A = 29, u = Error(
            r(130, o === null ? "null" : typeof o, "")
          ), f = null;
      }
    return i = In(A, u, i, g), i.elementType = o, i.type = f, i.lanes = S, i;
  }
  function aa(o, i, u, f) {
    return o = In(7, o, f, i), o.lanes = u, o;
  }
  function tf(o, i, u) {
    return o = In(6, o, null, i), o.lanes = u, o;
  }
  function ov(o) {
    var i = In(18, null, null, 0);
    return i.stateNode = o, i;
  }
  function nf(o, i, u) {
    return i = In(
      4,
      o.children !== null ? o.children : [],
      o.key,
      i
    ), i.lanes = u, i.stateNode = {
      containerInfo: o.containerInfo,
      pendingChildren: null,
      implementation: o.implementation
    }, i;
  }
  var av = /* @__PURE__ */ new WeakMap();
  function Zn(o, i) {
    if (typeof o == "object" && o !== null) {
      var u = av.get(o);
      return u !== void 0 ? u : (i = {
        value: o,
        source: i,
        stack: Xe(i)
      }, av.set(o, i), i);
    }
    return {
      value: o,
      source: i,
      stack: Xe(i)
    };
  }
  var Ua = [], Va = 0, nu = null, Qi = 0, er = [], tr = 0, io = null, Sr = 1, kr = "";
  function Ir(o, i) {
    Ua[Va++] = Qi, Ua[Va++] = nu, nu = o, Qi = i;
  }
  function iv(o, i, u) {
    er[tr++] = Sr, er[tr++] = kr, er[tr++] = io, io = o;
    var f = Sr;
    o = kr;
    var g = 32 - Re(f) - 1;
    f &= ~(1 << g), u += 1;
    var S = 32 - Re(i) + g;
    if (30 < S) {
      var A = g - g % 5;
      S = (f & (1 << A) - 1).toString(32), f >>= A, g -= A, Sr = 1 << 32 - Re(i) + g | u << g | f, kr = S + o;
    } else
      Sr = 1 << S | u << g | f, kr = o;
  }
  function rf(o) {
    o.return !== null && (Ir(o, 1), iv(o, 1, 0));
  }
  function of(o) {
    for (; o === nu; )
      nu = Ua[--Va], Ua[Va] = null, Qi = Ua[--Va], Ua[Va] = null;
    for (; o === io; )
      io = er[--tr], er[tr] = null, kr = er[--tr], er[tr] = null, Sr = er[--tr], er[tr] = null;
  }
  function sv(o, i) {
    er[tr++] = Sr, er[tr++] = kr, er[tr++] = io, Sr = i.id, kr = i.overflow, io = o;
  }
  var en = null, gt = null, Ge = !1, so = null, nr = !1, af = Error(r(519));
  function lo(o) {
    var i = Error(
      r(
        418,
        1 < arguments.length && arguments[1] !== void 0 && arguments[1] ? "text" : "HTML",
        ""
      )
    );
    throw Ji(Zn(i, o)), af;
  }
  function lv(o) {
    var i = o.stateNode, u = o.type, f = o.memoizedProps;
    switch (i[Yt] = o, i[mn] = f, u) {
      case "dialog":
        Be("cancel", i), Be("close", i);
        break;
      case "iframe":
      case "object":
      case "embed":
        Be("load", i);
        break;
      case "video":
      case "audio":
        for (u = 0; u < ws.length; u++)
          Be(ws[u], i);
        break;
      case "source":
        Be("error", i);
        break;
      case "img":
      case "image":
      case "link":
        Be("error", i), Be("load", i);
        break;
      case "details":
        Be("toggle", i);
        break;
      case "input":
        Be("invalid", i), Pd(
          i,
          f.value,
          f.defaultValue,
          f.checked,
          f.defaultChecked,
          f.type,
          f.name,
          !0
        );
        break;
      case "select":
        Be("invalid", i);
        break;
      case "textarea":
        Be("invalid", i), kg(i, f.value, f.defaultValue, f.children);
    }
    u = f.children, typeof u != "string" && typeof u != "number" && typeof u != "bigint" || i.textContent === "" + u || f.suppressHydrationWarning === !0 || Eb(i.textContent, u) ? (f.popover != null && (Be("beforetoggle", i), Be("toggle", i)), f.onScroll != null && Be("scroll", i), f.onScrollEnd != null && Be("scrollend", i), f.onClick != null && (i.onclick = $r), i = !0) : i = !1, i || lo(o, !0);
  }
  function uv(o) {
    for (en = o.return; en; )
      switch (en.tag) {
        case 5:
        case 31:
        case 13:
          nr = !1;
          return;
        case 27:
        case 3:
          nr = !0;
          return;
        default:
          en = en.return;
      }
  }
  function Ha(o) {
    if (o !== en) return !1;
    if (!Ge) return uv(o), Ge = !0, !1;
    var i = o.tag, u;
    if ((u = i !== 3 && i !== 27) && ((u = i === 5) && (u = o.type, u = !(u !== "form" && u !== "button") || _p(o.type, o.memoizedProps)), u = !u), u && gt && lo(o), uv(o), i === 13) {
      if (o = o.memoizedState, o = o !== null ? o.dehydrated : null, !o) throw Error(r(317));
      gt = Db(o);
    } else if (i === 31) {
      if (o = o.memoizedState, o = o !== null ? o.dehydrated : null, !o) throw Error(r(317));
      gt = Db(o);
    } else
      i === 27 ? (i = gt, ko(o.type) ? (o = Np, Np = null, gt = o) : gt = i) : gt = en ? rr(o.stateNode.nextSibling) : null;
    return !0;
  }
  function ia() {
    gt = en = null, Ge = !1;
  }
  function sf() {
    var o = so;
    return o !== null && (Mn === null ? Mn = o : Mn.push.apply(
      Mn,
      o
    ), so = null), o;
  }
  function Ji(o) {
    so === null ? so = [o] : so.push(o);
  }
  var lf = F(null), sa = null, zr = null;
  function uo(o, i, u) {
    U(lf, i._currentValue), i._currentValue = u;
  }
  function Fr(o) {
    o._currentValue = lf.current, X(lf);
  }
  function uf(o, i, u) {
    for (; o !== null; ) {
      var f = o.alternate;
      if ((o.childLanes & i) !== i ? (o.childLanes |= i, f !== null && (f.childLanes |= i)) : f !== null && (f.childLanes & i) !== i && (f.childLanes |= i), o === u) break;
      o = o.return;
    }
  }
  function cf(o, i, u, f) {
    var g = o.child;
    for (g !== null && (g.return = o); g !== null; ) {
      var S = g.dependencies;
      if (S !== null) {
        var A = g.child;
        S = S.firstContext;
        e: for (; S !== null; ) {
          var T = S;
          S = g;
          for (var Y = 0; Y < i.length; Y++)
            if (T.context === i[Y]) {
              S.lanes |= u, T = S.alternate, T !== null && (T.lanes |= u), uf(
                S.return,
                u,
                o
              ), f || (A = null);
              break e;
            }
          S = T.next;
        }
      } else if (g.tag === 18) {
        if (A = g.return, A === null) throw Error(r(341));
        A.lanes |= u, S = A.alternate, S !== null && (S.lanes |= u), uf(A, u, o), A = null;
      } else A = g.child;
      if (A !== null) A.return = g;
      else
        for (A = g; A !== null; ) {
          if (A === o) {
            A = null;
            break;
          }
          if (g = A.sibling, g !== null) {
            g.return = A.return, A = g;
            break;
          }
          A = A.return;
        }
      g = A;
    }
  }
  function qa(o, i, u, f) {
    o = null;
    for (var g = i, S = !1; g !== null; ) {
      if (!S) {
        if ((g.flags & 524288) !== 0) S = !0;
        else if ((g.flags & 262144) !== 0) break;
      }
      if (g.tag === 10) {
        var A = g.alternate;
        if (A === null) throw Error(r(387));
        if (A = A.memoizedProps, A !== null) {
          var T = g.type;
          Ln(g.pendingProps.value, A.value) || (o !== null ? o.push(T) : o = [T]);
        }
      } else if (g === de.current) {
        if (A = g.alternate, A === null) throw Error(r(387));
        A.memoizedState.memoizedState !== g.memoizedState.memoizedState && (o !== null ? o.push(Es) : o = [Es]);
      }
      g = g.return;
    }
    o !== null && cf(
      i,
      o,
      u,
      f
    ), i.flags |= 262144;
  }
  function ru(o) {
    for (o = o.firstContext; o !== null; ) {
      if (!Ln(
        o.context._currentValue,
        o.memoizedValue
      ))
        return !0;
      o = o.next;
    }
    return !1;
  }
  function la(o) {
    sa = o, zr = null, o = o.dependencies, o !== null && (o.firstContext = null);
  }
  function tn(o) {
    return cv(sa, o);
  }
  function ou(o, i) {
    return sa === null && la(o), cv(o, i);
  }
  function cv(o, i) {
    var u = i._currentValue;
    if (i = { context: i, memoizedValue: u, next: null }, zr === null) {
      if (o === null) throw Error(r(308));
      zr = i, o.dependencies = { lanes: 0, firstContext: i }, o.flags |= 524288;
    } else zr = zr.next = i;
    return u;
  }
  var EC = typeof AbortController < "u" ? AbortController : function() {
    var o = [], i = this.signal = {
      aborted: !1,
      addEventListener: function(u, f) {
        o.push(f);
      }
    };
    this.abort = function() {
      i.aborted = !0, o.forEach(function(u) {
        return u();
      });
    };
  }, CC = e.unstable_scheduleCallback, OC = e.unstable_NormalPriority, jt = {
    $$typeof: _,
    Consumer: null,
    Provider: null,
    _currentValue: null,
    _currentValue2: null,
    _threadCount: 0
  };
  function df() {
    return {
      controller: new EC(),
      data: /* @__PURE__ */ new Map(),
      refCount: 0
    };
  }
  function Zi(o) {
    o.refCount--, o.refCount === 0 && CC(OC, function() {
      o.controller.abort();
    });
  }
  var es = null, ff = 0, Wa = 0, Ga = null;
  function MC(o, i) {
    if (es === null) {
      var u = es = [];
      ff = 0, Wa = hp(), Ga = {
        status: "pending",
        value: void 0,
        then: function(f) {
          u.push(f);
        }
      };
    }
    return ff++, i.then(dv, dv), i;
  }
  function dv() {
    if (--ff === 0 && es !== null) {
      Ga !== null && (Ga.status = "fulfilled");
      var o = es;
      es = null, Wa = 0, Ga = null;
      for (var i = 0; i < o.length; i++) (0, o[i])();
    }
  }
  function NC(o, i) {
    var u = [], f = {
      status: "pending",
      value: null,
      reason: null,
      then: function(g) {
        u.push(g);
      }
    };
    return o.then(
      function() {
        f.status = "fulfilled", f.value = i;
        for (var g = 0; g < u.length; g++) (0, u[g])(i);
      },
      function(g) {
        for (f.status = "rejected", f.reason = g, g = 0; g < u.length; g++)
          (0, u[g])(void 0);
      }
    ), f;
  }
  var fv = L.S;
  L.S = function(o, i) {
    Xy = Ce(), typeof i == "object" && i !== null && typeof i.then == "function" && MC(o, i), fv !== null && fv(o, i);
  };
  var ua = F(null);
  function pf() {
    var o = ua.current;
    return o !== null ? o : lt.pooledCache;
  }
  function au(o, i) {
    i === null ? U(ua, ua.current) : U(ua, i.pool);
  }
  function pv() {
    var o = pf();
    return o === null ? null : { parent: jt._currentValue, pool: o };
  }
  var Ka = Error(r(460)), mf = Error(r(474)), iu = Error(r(542)), su = { then: function() {
  } };
  function mv(o) {
    return o = o.status, o === "fulfilled" || o === "rejected";
  }
  function hv(o, i, u) {
    switch (u = o[u], u === void 0 ? o.push(i) : u !== i && (i.then($r, $r), i = u), i.status) {
      case "fulfilled":
        return i.value;
      case "rejected":
        throw o = i.reason, vv(o), o;
      default:
        if (typeof i.status == "string") i.then($r, $r);
        else {
          if (o = lt, o !== null && 100 < o.shellSuspendCounter)
            throw Error(r(482));
          o = i, o.status = "pending", o.then(
            function(f) {
              if (i.status === "pending") {
                var g = i;
                g.status = "fulfilled", g.value = f;
              }
            },
            function(f) {
              if (i.status === "pending") {
                var g = i;
                g.status = "rejected", g.reason = f;
              }
            }
          );
        }
        switch (i.status) {
          case "fulfilled":
            return i.value;
          case "rejected":
            throw o = i.reason, vv(o), o;
        }
        throw da = i, Ka;
    }
  }
  function ca(o) {
    try {
      var i = o._init;
      return i(o._payload);
    } catch (u) {
      throw u !== null && typeof u == "object" && typeof u.then == "function" ? (da = u, Ka) : u;
    }
  }
  var da = null;
  function gv() {
    if (da === null) throw Error(r(459));
    var o = da;
    return da = null, o;
  }
  function vv(o) {
    if (o === Ka || o === iu)
      throw Error(r(483));
  }
  var Xa = null, ts = 0;
  function lu(o) {
    var i = ts;
    return ts += 1, Xa === null && (Xa = []), hv(Xa, o, i);
  }
  function ns(o, i) {
    i = i.props.ref, o.ref = i !== void 0 ? i : null;
  }
  function uu(o, i) {
    throw i.$$typeof === v ? Error(r(525)) : (o = Object.prototype.toString.call(i), Error(
      r(
        31,
        o === "[object Object]" ? "object with keys {" + Object.keys(i).join(", ") + "}" : o
      )
    ));
  }
  function yv(o) {
    function i(ee, J) {
      if (o) {
        var te = ee.deletions;
        te === null ? (ee.deletions = [J], ee.flags |= 16) : te.push(J);
      }
    }
    function u(ee, J) {
      if (!o) return null;
      for (; J !== null; )
        i(ee, J), J = J.sibling;
      return null;
    }
    function f(ee) {
      for (var J = /* @__PURE__ */ new Map(); ee !== null; )
        ee.key !== null ? J.set(ee.key, ee) : J.set(ee.index, ee), ee = ee.sibling;
      return J;
    }
    function g(ee, J) {
      return ee = Lr(ee, J), ee.index = 0, ee.sibling = null, ee;
    }
    function S(ee, J, te) {
      return ee.index = te, o ? (te = ee.alternate, te !== null ? (te = te.index, te < J ? (ee.flags |= 67108866, J) : te) : (ee.flags |= 67108866, J)) : (ee.flags |= 1048576, J);
    }
    function A(ee) {
      return o && ee.alternate === null && (ee.flags |= 67108866), ee;
    }
    function T(ee, J, te, ce) {
      return J === null || J.tag !== 6 ? (J = tf(te, ee.mode, ce), J.return = ee, J) : (J = g(J, te), J.return = ee, J);
    }
    function Y(ee, J, te, ce) {
      var Oe = te.type;
      return Oe === x ? ue(
        ee,
        J,
        te.props.children,
        ce,
        te.key
      ) : J !== null && (J.elementType === Oe || typeof Oe == "object" && Oe !== null && Oe.$$typeof === D && ca(Oe) === J.type) ? (J = g(J, te.props), ns(J, te), J.return = ee, J) : (J = tu(
        te.type,
        te.key,
        te.props,
        null,
        ee.mode,
        ce
      ), ns(J, te), J.return = ee, J);
    }
    function ne(ee, J, te, ce) {
      return J === null || J.tag !== 4 || J.stateNode.containerInfo !== te.containerInfo || J.stateNode.implementation !== te.implementation ? (J = nf(te, ee.mode, ce), J.return = ee, J) : (J = g(J, te.children || []), J.return = ee, J);
    }
    function ue(ee, J, te, ce, Oe) {
      return J === null || J.tag !== 7 ? (J = aa(
        te,
        ee.mode,
        ce,
        Oe
      ), J.return = ee, J) : (J = g(J, te), J.return = ee, J);
    }
    function fe(ee, J, te) {
      if (typeof J == "string" && J !== "" || typeof J == "number" || typeof J == "bigint")
        return J = tf(
          "" + J,
          ee.mode,
          te
        ), J.return = ee, J;
      if (typeof J == "object" && J !== null) {
        switch (J.$$typeof) {
          case y:
            return te = tu(
              J.type,
              J.key,
              J.props,
              null,
              ee.mode,
              te
            ), ns(te, J), te.return = ee, te;
          case w:
            return J = nf(
              J,
              ee.mode,
              te
            ), J.return = ee, J;
          case D:
            return J = ca(J), fe(ee, J, te);
        }
        if (G(J) || P(J))
          return J = aa(
            J,
            ee.mode,
            te,
            null
          ), J.return = ee, J;
        if (typeof J.then == "function")
          return fe(ee, lu(J), te);
        if (J.$$typeof === _)
          return fe(
            ee,
            ou(ee, J),
            te
          );
        uu(ee, J);
      }
      return null;
    }
    function oe(ee, J, te, ce) {
      var Oe = J !== null ? J.key : null;
      if (typeof te == "string" && te !== "" || typeof te == "number" || typeof te == "bigint")
        return Oe !== null ? null : T(ee, J, "" + te, ce);
      if (typeof te == "object" && te !== null) {
        switch (te.$$typeof) {
          case y:
            return te.key === Oe ? Y(ee, J, te, ce) : null;
          case w:
            return te.key === Oe ? ne(ee, J, te, ce) : null;
          case D:
            return te = ca(te), oe(ee, J, te, ce);
        }
        if (G(te) || P(te))
          return Oe !== null ? null : ue(ee, J, te, ce, null);
        if (typeof te.then == "function")
          return oe(
            ee,
            J,
            lu(te),
            ce
          );
        if (te.$$typeof === _)
          return oe(
            ee,
            J,
            ou(ee, te),
            ce
          );
        uu(ee, te);
      }
      return null;
    }
    function ie(ee, J, te, ce, Oe) {
      if (typeof ce == "string" && ce !== "" || typeof ce == "number" || typeof ce == "bigint")
        return ee = ee.get(te) || null, T(J, ee, "" + ce, Oe);
      if (typeof ce == "object" && ce !== null) {
        switch (ce.$$typeof) {
          case y:
            return ee = ee.get(
              ce.key === null ? te : ce.key
            ) || null, Y(J, ee, ce, Oe);
          case w:
            return ee = ee.get(
              ce.key === null ? te : ce.key
            ) || null, ne(J, ee, ce, Oe);
          case D:
            return ce = ca(ce), ie(
              ee,
              J,
              te,
              ce,
              Oe
            );
        }
        if (G(ce) || P(ce))
          return ee = ee.get(te) || null, ue(J, ee, ce, Oe, null);
        if (typeof ce.then == "function")
          return ie(
            ee,
            J,
            te,
            lu(ce),
            Oe
          );
        if (ce.$$typeof === _)
          return ie(
            ee,
            J,
            te,
            ou(J, ce),
            Oe
          );
        uu(J, ce);
      }
      return null;
    }
    function we(ee, J, te, ce) {
      for (var Oe = null, Ye = null, ke = J, Ie = J = 0, He = null; ke !== null && Ie < te.length; Ie++) {
        ke.index > Ie ? (He = ke, ke = null) : He = ke.sibling;
        var Qe = oe(
          ee,
          ke,
          te[Ie],
          ce
        );
        if (Qe === null) {
          ke === null && (ke = He);
          break;
        }
        o && ke && Qe.alternate === null && i(ee, ke), J = S(Qe, J, Ie), Ye === null ? Oe = Qe : Ye.sibling = Qe, Ye = Qe, ke = He;
      }
      if (Ie === te.length)
        return u(ee, ke), Ge && Ir(ee, Ie), Oe;
      if (ke === null) {
        for (; Ie < te.length; Ie++)
          ke = fe(ee, te[Ie], ce), ke !== null && (J = S(
            ke,
            J,
            Ie
          ), Ye === null ? Oe = ke : Ye.sibling = ke, Ye = ke);
        return Ge && Ir(ee, Ie), Oe;
      }
      for (ke = f(ke); Ie < te.length; Ie++)
        He = ie(
          ke,
          ee,
          Ie,
          te[Ie],
          ce
        ), He !== null && (o && He.alternate !== null && ke.delete(
          He.key === null ? Ie : He.key
        ), J = S(
          He,
          J,
          Ie
        ), Ye === null ? Oe = He : Ye.sibling = He, Ye = He);
      return o && ke.forEach(function(Mo) {
        return i(ee, Mo);
      }), Ge && Ir(ee, Ie), Oe;
    }
    function Ne(ee, J, te, ce) {
      if (te == null) throw Error(r(151));
      for (var Oe = null, Ye = null, ke = J, Ie = J = 0, He = null, Qe = te.next(); ke !== null && !Qe.done; Ie++, Qe = te.next()) {
        ke.index > Ie ? (He = ke, ke = null) : He = ke.sibling;
        var Mo = oe(ee, ke, Qe.value, ce);
        if (Mo === null) {
          ke === null && (ke = He);
          break;
        }
        o && ke && Mo.alternate === null && i(ee, ke), J = S(Mo, J, Ie), Ye === null ? Oe = Mo : Ye.sibling = Mo, Ye = Mo, ke = He;
      }
      if (Qe.done)
        return u(ee, ke), Ge && Ir(ee, Ie), Oe;
      if (ke === null) {
        for (; !Qe.done; Ie++, Qe = te.next())
          Qe = fe(ee, Qe.value, ce), Qe !== null && (J = S(Qe, J, Ie), Ye === null ? Oe = Qe : Ye.sibling = Qe, Ye = Qe);
        return Ge && Ir(ee, Ie), Oe;
      }
      for (ke = f(ke); !Qe.done; Ie++, Qe = te.next())
        Qe = ie(ke, ee, Ie, Qe.value, ce), Qe !== null && (o && Qe.alternate !== null && ke.delete(Qe.key === null ? Ie : Qe.key), J = S(Qe, J, Ie), Ye === null ? Oe = Qe : Ye.sibling = Qe, Ye = Qe);
      return o && ke.forEach(function(FO) {
        return i(ee, FO);
      }), Ge && Ir(ee, Ie), Oe;
    }
    function it(ee, J, te, ce) {
      if (typeof te == "object" && te !== null && te.type === x && te.key === null && (te = te.props.children), typeof te == "object" && te !== null) {
        switch (te.$$typeof) {
          case y:
            e: {
              for (var Oe = te.key; J !== null; ) {
                if (J.key === Oe) {
                  if (Oe = te.type, Oe === x) {
                    if (J.tag === 7) {
                      u(
                        ee,
                        J.sibling
                      ), ce = g(
                        J,
                        te.props.children
                      ), ce.return = ee, ee = ce;
                      break e;
                    }
                  } else if (J.elementType === Oe || typeof Oe == "object" && Oe !== null && Oe.$$typeof === D && ca(Oe) === J.type) {
                    u(
                      ee,
                      J.sibling
                    ), ce = g(J, te.props), ns(ce, te), ce.return = ee, ee = ce;
                    break e;
                  }
                  u(ee, J);
                  break;
                } else i(ee, J);
                J = J.sibling;
              }
              te.type === x ? (ce = aa(
                te.props.children,
                ee.mode,
                ce,
                te.key
              ), ce.return = ee, ee = ce) : (ce = tu(
                te.type,
                te.key,
                te.props,
                null,
                ee.mode,
                ce
              ), ns(ce, te), ce.return = ee, ee = ce);
            }
            return A(ee);
          case w:
            e: {
              for (Oe = te.key; J !== null; ) {
                if (J.key === Oe)
                  if (J.tag === 4 && J.stateNode.containerInfo === te.containerInfo && J.stateNode.implementation === te.implementation) {
                    u(
                      ee,
                      J.sibling
                    ), ce = g(J, te.children || []), ce.return = ee, ee = ce;
                    break e;
                  } else {
                    u(ee, J);
                    break;
                  }
                else i(ee, J);
                J = J.sibling;
              }
              ce = nf(te, ee.mode, ce), ce.return = ee, ee = ce;
            }
            return A(ee);
          case D:
            return te = ca(te), it(
              ee,
              J,
              te,
              ce
            );
        }
        if (G(te))
          return we(
            ee,
            J,
            te,
            ce
          );
        if (P(te)) {
          if (Oe = P(te), typeof Oe != "function") throw Error(r(150));
          return te = Oe.call(te), Ne(
            ee,
            J,
            te,
            ce
          );
        }
        if (typeof te.then == "function")
          return it(
            ee,
            J,
            lu(te),
            ce
          );
        if (te.$$typeof === _)
          return it(
            ee,
            J,
            ou(ee, te),
            ce
          );
        uu(ee, te);
      }
      return typeof te == "string" && te !== "" || typeof te == "number" || typeof te == "bigint" ? (te = "" + te, J !== null && J.tag === 6 ? (u(ee, J.sibling), ce = g(J, te), ce.return = ee, ee = ce) : (u(ee, J), ce = tf(te, ee.mode, ce), ce.return = ee, ee = ce), A(ee)) : u(ee, J);
    }
    return function(ee, J, te, ce) {
      try {
        ts = 0;
        var Oe = it(
          ee,
          J,
          te,
          ce
        );
        return Xa = null, Oe;
      } catch (ke) {
        if (ke === Ka || ke === iu) throw ke;
        var Ye = In(29, ke, null, ee.mode);
        return Ye.lanes = ce, Ye.return = ee, Ye;
      }
    };
  }
  var fa = yv(!0), bv = yv(!1), co = !1;
  function hf(o) {
    o.updateQueue = {
      baseState: o.memoizedState,
      firstBaseUpdate: null,
      lastBaseUpdate: null,
      shared: { pending: null, lanes: 0, hiddenCallbacks: null },
      callbacks: null
    };
  }
  function gf(o, i) {
    o = o.updateQueue, i.updateQueue === o && (i.updateQueue = {
      baseState: o.baseState,
      firstBaseUpdate: o.firstBaseUpdate,
      lastBaseUpdate: o.lastBaseUpdate,
      shared: o.shared,
      callbacks: null
    });
  }
  function fo(o) {
    return { lane: o, tag: 0, payload: null, callback: null, next: null };
  }
  function po(o, i, u) {
    var f = o.updateQueue;
    if (f === null) return null;
    if (f = f.shared, (Je & 2) !== 0) {
      var g = f.pending;
      return g === null ? i.next = i : (i.next = g.next, g.next = i), f.pending = i, i = eu(o), nv(o, null, u), i;
    }
    return Zl(o, f, i, u), eu(o);
  }
  function rs(o, i, u) {
    if (i = i.updateQueue, i !== null && (i = i.shared, (u & 4194048) !== 0)) {
      var f = i.lanes;
      f &= o.pendingLanes, u |= f, i.lanes = u, kd(o, u);
    }
  }
  function vf(o, i) {
    var u = o.updateQueue, f = o.alternate;
    if (f !== null && (f = f.updateQueue, u === f)) {
      var g = null, S = null;
      if (u = u.firstBaseUpdate, u !== null) {
        do {
          var A = {
            lane: u.lane,
            tag: u.tag,
            payload: u.payload,
            callback: null,
            next: null
          };
          S === null ? g = S = A : S = S.next = A, u = u.next;
        } while (u !== null);
        S === null ? g = S = i : S = S.next = i;
      } else g = S = i;
      u = {
        baseState: f.baseState,
        firstBaseUpdate: g,
        lastBaseUpdate: S,
        shared: f.shared,
        callbacks: f.callbacks
      }, o.updateQueue = u;
      return;
    }
    o = u.lastBaseUpdate, o === null ? u.firstBaseUpdate = i : o.next = i, u.lastBaseUpdate = i;
  }
  var yf = !1;
  function os() {
    if (yf) {
      var o = Ga;
      if (o !== null) throw o;
    }
  }
  function as(o, i, u, f) {
    yf = !1;
    var g = o.updateQueue;
    co = !1;
    var S = g.firstBaseUpdate, A = g.lastBaseUpdate, T = g.shared.pending;
    if (T !== null) {
      g.shared.pending = null;
      var Y = T, ne = Y.next;
      Y.next = null, A === null ? S = ne : A.next = ne, A = Y;
      var ue = o.alternate;
      ue !== null && (ue = ue.updateQueue, T = ue.lastBaseUpdate, T !== A && (T === null ? ue.firstBaseUpdate = ne : T.next = ne, ue.lastBaseUpdate = Y));
    }
    if (S !== null) {
      var fe = g.baseState;
      A = 0, ue = ne = Y = null, T = S;
      do {
        var oe = T.lane & -536870913, ie = oe !== T.lane;
        if (ie ? (Ve & oe) === oe : (f & oe) === oe) {
          oe !== 0 && oe === Wa && (yf = !0), ue !== null && (ue = ue.next = {
            lane: 0,
            tag: T.tag,
            payload: T.payload,
            callback: null,
            next: null
          });
          e: {
            var we = o, Ne = T;
            oe = i;
            var it = u;
            switch (Ne.tag) {
              case 1:
                if (we = Ne.payload, typeof we == "function") {
                  fe = we.call(it, fe, oe);
                  break e;
                }
                fe = we;
                break e;
              case 3:
                we.flags = we.flags & -65537 | 128;
              case 0:
                if (we = Ne.payload, oe = typeof we == "function" ? we.call(it, fe, oe) : we, oe == null) break e;
                fe = h({}, fe, oe);
                break e;
              case 2:
                co = !0;
            }
          }
          oe = T.callback, oe !== null && (o.flags |= 64, ie && (o.flags |= 8192), ie = g.callbacks, ie === null ? g.callbacks = [oe] : ie.push(oe));
        } else
          ie = {
            lane: oe,
            tag: T.tag,
            payload: T.payload,
            callback: T.callback,
            next: null
          }, ue === null ? (ne = ue = ie, Y = fe) : ue = ue.next = ie, A |= oe;
        if (T = T.next, T === null) {
          if (T = g.shared.pending, T === null)
            break;
          ie = T, T = ie.next, ie.next = null, g.lastBaseUpdate = ie, g.shared.pending = null;
        }
      } while (!0);
      ue === null && (Y = fe), g.baseState = Y, g.firstBaseUpdate = ne, g.lastBaseUpdate = ue, S === null && (g.shared.lanes = 0), yo |= A, o.lanes = A, o.memoizedState = fe;
    }
  }
  function wv(o, i) {
    if (typeof o != "function")
      throw Error(r(191, o));
    o.call(i);
  }
  function xv(o, i) {
    var u = o.callbacks;
    if (u !== null)
      for (o.callbacks = null, o = 0; o < u.length; o++)
        wv(u[o], i);
  }
  var Ya = F(null), cu = F(0);
  function Sv(o, i) {
    o = Xr, U(cu, o), U(Ya, i), Xr = o | i.baseLanes;
  }
  function bf() {
    U(cu, Xr), U(Ya, Ya.current);
  }
  function wf() {
    Xr = cu.current, X(Ya), X(cu);
  }
  var zn = F(null), lr = null;
  function mo(o) {
    var i = o.alternate;
    U(Mt, Mt.current & 1), U(zn, o), lr === null && (i === null || Ya.current !== null || i.memoizedState !== null) && (lr = o);
  }
  function xf(o) {
    U(Mt, Mt.current), U(zn, o), lr === null && (lr = o);
  }
  function kv(o) {
    o.tag === 22 ? (U(Mt, Mt.current), U(zn, o), lr === null && (lr = o)) : ho();
  }
  function ho() {
    U(Mt, Mt.current), U(zn, zn.current);
  }
  function Fn(o) {
    X(zn), lr === o && (lr = null), X(Mt);
  }
  var Mt = F(0);
  function du(o) {
    for (var i = o; i !== null; ) {
      if (i.tag === 13) {
        var u = i.memoizedState;
        if (u !== null && (u = u.dehydrated, u === null || Op(u) || Mp(u)))
          return i;
      } else if (i.tag === 19 && (i.memoizedProps.revealOrder === "forwards" || i.memoizedProps.revealOrder === "backwards" || i.memoizedProps.revealOrder === "unstable_legacy-backwards" || i.memoizedProps.revealOrder === "together")) {
        if ((i.flags & 128) !== 0) return i;
      } else if (i.child !== null) {
        i.child.return = i, i = i.child;
        continue;
      }
      if (i === o) break;
      for (; i.sibling === null; ) {
        if (i.return === null || i.return === o) return null;
        i = i.return;
      }
      i.sibling.return = i.return, i = i.sibling;
    }
    return null;
  }
  var Br = 0, Te = null, ot = null, Pt = null, fu = !1, Qa = !1, pa = !1, pu = 0, is = 0, Ja = null, RC = 0;
  function xt() {
    throw Error(r(321));
  }
  function Sf(o, i) {
    if (i === null) return !1;
    for (var u = 0; u < i.length && u < o.length; u++)
      if (!Ln(o[u], i[u])) return !1;
    return !0;
  }
  function kf(o, i, u, f, g, S) {
    return Br = S, Te = i, i.memoizedState = null, i.updateQueue = null, i.lanes = 0, L.H = o === null || o.memoizedState === null ? iy : If, pa = !1, S = u(f, g), pa = !1, Qa && (S = Ev(
      i,
      u,
      f,
      g
    )), _v(o), S;
  }
  function _v(o) {
    L.H = us;
    var i = ot !== null && ot.next !== null;
    if (Br = 0, Pt = ot = Te = null, fu = !1, is = 0, Ja = null, i) throw Error(r(300));
    o === null || Dt || (o = o.dependencies, o !== null && ru(o) && (Dt = !0));
  }
  function Ev(o, i, u, f) {
    Te = o;
    var g = 0;
    do {
      if (Qa && (Ja = null), is = 0, Qa = !1, 25 <= g) throw Error(r(301));
      if (g += 1, Pt = ot = null, o.updateQueue != null) {
        var S = o.updateQueue;
        S.lastEffect = null, S.events = null, S.stores = null, S.memoCache != null && (S.memoCache.index = 0);
      }
      L.H = sy, S = i(u, f);
    } while (Qa);
    return S;
  }
  function AC() {
    var o = L.H, i = o.useState()[0];
    return i = typeof i.then == "function" ? ss(i) : i, o = o.useState()[0], (ot !== null ? ot.memoizedState : null) !== o && (Te.flags |= 1024), i;
  }
  function _f() {
    var o = pu !== 0;
    return pu = 0, o;
  }
  function Ef(o, i, u) {
    i.updateQueue = o.updateQueue, i.flags &= -2053, o.lanes &= ~u;
  }
  function Cf(o) {
    if (fu) {
      for (o = o.memoizedState; o !== null; ) {
        var i = o.queue;
        i !== null && (i.pending = null), o = o.next;
      }
      fu = !1;
    }
    Br = 0, Pt = ot = Te = null, Qa = !1, is = pu = 0, Ja = null;
  }
  function hn() {
    var o = {
      memoizedState: null,
      baseState: null,
      baseQueue: null,
      queue: null,
      next: null
    };
    return Pt === null ? Te.memoizedState = Pt = o : Pt = Pt.next = o, Pt;
  }
  function Nt() {
    if (ot === null) {
      var o = Te.alternate;
      o = o !== null ? o.memoizedState : null;
    } else o = ot.next;
    var i = Pt === null ? Te.memoizedState : Pt.next;
    if (i !== null)
      Pt = i, ot = o;
    else {
      if (o === null)
        throw Te.alternate === null ? Error(r(467)) : Error(r(310));
      ot = o, o = {
        memoizedState: ot.memoizedState,
        baseState: ot.baseState,
        baseQueue: ot.baseQueue,
        queue: ot.queue,
        next: null
      }, Pt === null ? Te.memoizedState = Pt = o : Pt = Pt.next = o;
    }
    return Pt;
  }
  function mu() {
    return { lastEffect: null, events: null, stores: null, memoCache: null };
  }
  function ss(o) {
    var i = is;
    return is += 1, Ja === null && (Ja = []), o = hv(Ja, o, i), i = Te, (Pt === null ? i.memoizedState : Pt.next) === null && (i = i.alternate, L.H = i === null || i.memoizedState === null ? iy : If), o;
  }
  function hu(o) {
    if (o !== null && typeof o == "object") {
      if (typeof o.then == "function") return ss(o);
      if (o.$$typeof === _) return tn(o);
    }
    throw Error(r(438, String(o)));
  }
  function Of(o) {
    var i = null, u = Te.updateQueue;
    if (u !== null && (i = u.memoCache), i == null) {
      var f = Te.alternate;
      f !== null && (f = f.updateQueue, f !== null && (f = f.memoCache, f != null && (i = {
        data: f.data.map(function(g) {
          return g.slice();
        }),
        index: 0
      })));
    }
    if (i == null && (i = { data: [], index: 0 }), u === null && (u = mu(), Te.updateQueue = u), u.memoCache = i, u = i.data[i.index], u === void 0)
      for (u = i.data[i.index] = Array(o), f = 0; f < o; f++)
        u[f] = z;
    return i.index++, u;
  }
  function Ur(o, i) {
    return typeof i == "function" ? i(o) : i;
  }
  function gu(o) {
    var i = Nt();
    return Mf(i, ot, o);
  }
  function Mf(o, i, u) {
    var f = o.queue;
    if (f === null) throw Error(r(311));
    f.lastRenderedReducer = u;
    var g = o.baseQueue, S = f.pending;
    if (S !== null) {
      if (g !== null) {
        var A = g.next;
        g.next = S.next, S.next = A;
      }
      i.baseQueue = g = S, f.pending = null;
    }
    if (S = o.baseState, g === null) o.memoizedState = S;
    else {
      i = g.next;
      var T = A = null, Y = null, ne = i, ue = !1;
      do {
        var fe = ne.lane & -536870913;
        if (fe !== ne.lane ? (Ve & fe) === fe : (Br & fe) === fe) {
          var oe = ne.revertLane;
          if (oe === 0)
            Y !== null && (Y = Y.next = {
              lane: 0,
              revertLane: 0,
              gesture: null,
              action: ne.action,
              hasEagerState: ne.hasEagerState,
              eagerState: ne.eagerState,
              next: null
            }), fe === Wa && (ue = !0);
          else if ((Br & oe) === oe) {
            ne = ne.next, oe === Wa && (ue = !0);
            continue;
          } else
            fe = {
              lane: 0,
              revertLane: ne.revertLane,
              gesture: null,
              action: ne.action,
              hasEagerState: ne.hasEagerState,
              eagerState: ne.eagerState,
              next: null
            }, Y === null ? (T = Y = fe, A = S) : Y = Y.next = fe, Te.lanes |= oe, yo |= oe;
          fe = ne.action, pa && u(S, fe), S = ne.hasEagerState ? ne.eagerState : u(S, fe);
        } else
          oe = {
            lane: fe,
            revertLane: ne.revertLane,
            gesture: ne.gesture,
            action: ne.action,
            hasEagerState: ne.hasEagerState,
            eagerState: ne.eagerState,
            next: null
          }, Y === null ? (T = Y = oe, A = S) : Y = Y.next = oe, Te.lanes |= fe, yo |= fe;
        ne = ne.next;
      } while (ne !== null && ne !== i);
      if (Y === null ? A = S : Y.next = T, !Ln(S, o.memoizedState) && (Dt = !0, ue && (u = Ga, u !== null)))
        throw u;
      o.memoizedState = S, o.baseState = A, o.baseQueue = Y, f.lastRenderedState = S;
    }
    return g === null && (f.lanes = 0), [o.memoizedState, f.dispatch];
  }
  function Nf(o) {
    var i = Nt(), u = i.queue;
    if (u === null) throw Error(r(311));
    u.lastRenderedReducer = o;
    var f = u.dispatch, g = u.pending, S = i.memoizedState;
    if (g !== null) {
      u.pending = null;
      var A = g = g.next;
      do
        S = o(S, A.action), A = A.next;
      while (A !== g);
      Ln(S, i.memoizedState) || (Dt = !0), i.memoizedState = S, i.baseQueue === null && (i.baseState = S), u.lastRenderedState = S;
    }
    return [S, f];
  }
  function Cv(o, i, u) {
    var f = Te, g = Nt(), S = Ge;
    if (S) {
      if (u === void 0) throw Error(r(407));
      u = u();
    } else u = i();
    var A = !Ln(
      (ot || g).memoizedState,
      u
    );
    if (A && (g.memoizedState = u, Dt = !0), g = g.queue, jf(Nv.bind(null, f, g, o), [
      o
    ]), g.getSnapshot !== i || A || Pt !== null && Pt.memoizedState.tag & 1) {
      if (f.flags |= 2048, Za(
        9,
        { destroy: void 0 },
        Mv.bind(
          null,
          f,
          g,
          u,
          i
        ),
        null
      ), lt === null) throw Error(r(349));
      S || (Br & 127) !== 0 || Ov(f, i, u);
    }
    return u;
  }
  function Ov(o, i, u) {
    o.flags |= 16384, o = { getSnapshot: i, value: u }, i = Te.updateQueue, i === null ? (i = mu(), Te.updateQueue = i, i.stores = [o]) : (u = i.stores, u === null ? i.stores = [o] : u.push(o));
  }
  function Mv(o, i, u, f) {
    i.value = u, i.getSnapshot = f, Rv(i) && Av(o);
  }
  function Nv(o, i, u) {
    return u(function() {
      Rv(i) && Av(o);
    });
  }
  function Rv(o) {
    var i = o.getSnapshot;
    o = o.value;
    try {
      var u = i();
      return !Ln(o, u);
    } catch {
      return !0;
    }
  }
  function Av(o) {
    var i = oa(o, 2);
    i !== null && Nn(i, o, 2);
  }
  function Rf(o) {
    var i = hn();
    if (typeof o == "function") {
      var u = o;
      if (o = u(), pa) {
        bn(!0);
        try {
          u();
        } finally {
          bn(!1);
        }
      }
    }
    return i.memoizedState = i.baseState = o, i.queue = {
      pending: null,
      lanes: 0,
      dispatch: null,
      lastRenderedReducer: Ur,
      lastRenderedState: o
    }, i;
  }
  function jv(o, i, u, f) {
    return o.baseState = u, Mf(
      o,
      ot,
      typeof f == "function" ? f : Ur
    );
  }
  function jC(o, i, u, f, g) {
    if (bu(o)) throw Error(r(485));
    if (o = i.action, o !== null) {
      var S = {
        payload: g,
        action: o,
        next: null,
        isTransition: !0,
        status: "pending",
        value: null,
        reason: null,
        listeners: [],
        then: function(A) {
          S.listeners.push(A);
        }
      };
      L.T !== null ? u(!0) : S.isTransition = !1, f(S), u = i.pending, u === null ? (S.next = i.pending = S, Pv(i, S)) : (S.next = u.next, i.pending = u.next = S);
    }
  }
  function Pv(o, i) {
    var u = i.action, f = i.payload, g = o.state;
    if (i.isTransition) {
      var S = L.T, A = {};
      L.T = A;
      try {
        var T = u(g, f), Y = L.S;
        Y !== null && Y(A, T), Dv(o, i, T);
      } catch (ne) {
        Af(o, i, ne);
      } finally {
        S !== null && A.types !== null && (S.types = A.types), L.T = S;
      }
    } else
      try {
        S = u(g, f), Dv(o, i, S);
      } catch (ne) {
        Af(o, i, ne);
      }
  }
  function Dv(o, i, u) {
    u !== null && typeof u == "object" && typeof u.then == "function" ? u.then(
      function(f) {
        $v(o, i, f);
      },
      function(f) {
        return Af(o, i, f);
      }
    ) : $v(o, i, u);
  }
  function $v(o, i, u) {
    i.status = "fulfilled", i.value = u, Tv(i), o.state = u, i = o.pending, i !== null && (u = i.next, u === i ? o.pending = null : (u = u.next, i.next = u, Pv(o, u)));
  }
  function Af(o, i, u) {
    var f = o.pending;
    if (o.pending = null, f !== null) {
      f = f.next;
      do
        i.status = "rejected", i.reason = u, Tv(i), i = i.next;
      while (i !== f);
    }
    o.action = null;
  }
  function Tv(o) {
    o = o.listeners;
    for (var i = 0; i < o.length; i++) (0, o[i])();
  }
  function Lv(o, i) {
    return i;
  }
  function Iv(o, i) {
    if (Ge) {
      var u = lt.formState;
      if (u !== null) {
        e: {
          var f = Te;
          if (Ge) {
            if (gt) {
              t: {
                for (var g = gt, S = nr; g.nodeType !== 8; ) {
                  if (!S) {
                    g = null;
                    break t;
                  }
                  if (g = rr(
                    g.nextSibling
                  ), g === null) {
                    g = null;
                    break t;
                  }
                }
                S = g.data, g = S === "F!" || S === "F" ? g : null;
              }
              if (g) {
                gt = rr(
                  g.nextSibling
                ), f = g.data === "F!";
                break e;
              }
            }
            lo(f);
          }
          f = !1;
        }
        f && (i = u[0]);
      }
    }
    return u = hn(), u.memoizedState = u.baseState = i, f = {
      pending: null,
      lanes: 0,
      dispatch: null,
      lastRenderedReducer: Lv,
      lastRenderedState: i
    }, u.queue = f, u = ry.bind(
      null,
      Te,
      f
    ), f.dispatch = u, f = Rf(!1), S = Lf.bind(
      null,
      Te,
      !1,
      f.queue
    ), f = hn(), g = {
      state: i,
      dispatch: null,
      action: o,
      pending: null
    }, f.queue = g, u = jC.bind(
      null,
      Te,
      g,
      S,
      u
    ), g.dispatch = u, f.memoizedState = o, [i, u, !1];
  }
  function zv(o) {
    var i = Nt();
    return Fv(i, ot, o);
  }
  function Fv(o, i, u) {
    if (i = Mf(
      o,
      i,
      Lv
    )[0], o = gu(Ur)[0], typeof i == "object" && i !== null && typeof i.then == "function")
      try {
        var f = ss(i);
      } catch (A) {
        throw A === Ka ? iu : A;
      }
    else f = i;
    i = Nt();
    var g = i.queue, S = g.dispatch;
    return u !== i.memoizedState && (Te.flags |= 2048, Za(
      9,
      { destroy: void 0 },
      PC.bind(null, g, u),
      null
    )), [f, S, o];
  }
  function PC(o, i) {
    o.action = i;
  }
  function Bv(o) {
    var i = Nt(), u = ot;
    if (u !== null)
      return Fv(i, u, o);
    Nt(), i = i.memoizedState, u = Nt();
    var f = u.queue.dispatch;
    return u.memoizedState = o, [i, f, !1];
  }
  function Za(o, i, u, f) {
    return o = { tag: o, create: u, deps: f, inst: i, next: null }, i = Te.updateQueue, i === null && (i = mu(), Te.updateQueue = i), u = i.lastEffect, u === null ? i.lastEffect = o.next = o : (f = u.next, u.next = o, o.next = f, i.lastEffect = o), o;
  }
  function Uv() {
    return Nt().memoizedState;
  }
  function vu(o, i, u, f) {
    var g = hn();
    Te.flags |= o, g.memoizedState = Za(
      1 | i,
      { destroy: void 0 },
      u,
      f === void 0 ? null : f
    );
  }
  function yu(o, i, u, f) {
    var g = Nt();
    f = f === void 0 ? null : f;
    var S = g.memoizedState.inst;
    ot !== null && f !== null && Sf(f, ot.memoizedState.deps) ? g.memoizedState = Za(i, S, u, f) : (Te.flags |= o, g.memoizedState = Za(
      1 | i,
      S,
      u,
      f
    ));
  }
  function Vv(o, i) {
    vu(8390656, 8, o, i);
  }
  function jf(o, i) {
    yu(2048, 8, o, i);
  }
  function DC(o) {
    Te.flags |= 4;
    var i = Te.updateQueue;
    if (i === null)
      i = mu(), Te.updateQueue = i, i.events = [o];
    else {
      var u = i.events;
      u === null ? i.events = [o] : u.push(o);
    }
  }
  function Hv(o) {
    var i = Nt().memoizedState;
    return DC({ ref: i, nextImpl: o }), function() {
      if ((Je & 2) !== 0) throw Error(r(440));
      return i.impl.apply(void 0, arguments);
    };
  }
  function qv(o, i) {
    return yu(4, 2, o, i);
  }
  function Wv(o, i) {
    return yu(4, 4, o, i);
  }
  function Gv(o, i) {
    if (typeof i == "function") {
      o = o();
      var u = i(o);
      return function() {
        typeof u == "function" ? u() : i(null);
      };
    }
    if (i != null)
      return o = o(), i.current = o, function() {
        i.current = null;
      };
  }
  function Kv(o, i, u) {
    u = u != null ? u.concat([o]) : null, yu(4, 4, Gv.bind(null, i, o), u);
  }
  function Pf() {
  }
  function Xv(o, i) {
    var u = Nt();
    i = i === void 0 ? null : i;
    var f = u.memoizedState;
    return i !== null && Sf(i, f[1]) ? f[0] : (u.memoizedState = [o, i], o);
  }
  function Yv(o, i) {
    var u = Nt();
    i = i === void 0 ? null : i;
    var f = u.memoizedState;
    if (i !== null && Sf(i, f[1]))
      return f[0];
    if (f = o(), pa) {
      bn(!0);
      try {
        o();
      } finally {
        bn(!1);
      }
    }
    return u.memoizedState = [f, i], f;
  }
  function Df(o, i, u) {
    return u === void 0 || (Br & 1073741824) !== 0 && (Ve & 261930) === 0 ? o.memoizedState = i : (o.memoizedState = u, o = Qy(), Te.lanes |= o, yo |= o, u);
  }
  function Qv(o, i, u, f) {
    return Ln(u, i) ? u : Ya.current !== null ? (o = Df(o, u, f), Ln(o, i) || (Dt = !0), o) : (Br & 42) === 0 || (Br & 1073741824) !== 0 && (Ve & 261930) === 0 ? (Dt = !0, o.memoizedState = u) : (o = Qy(), Te.lanes |= o, yo |= o, i);
  }
  function Jv(o, i, u, f, g) {
    var S = K.p;
    K.p = S !== 0 && 8 > S ? S : 8;
    var A = L.T, T = {};
    L.T = T, Lf(o, !1, i, u);
    try {
      var Y = g(), ne = L.S;
      if (ne !== null && ne(T, Y), Y !== null && typeof Y == "object" && typeof Y.then == "function") {
        var ue = NC(
          Y,
          f
        );
        ls(
          o,
          i,
          ue,
          Vn(o)
        );
      } else
        ls(
          o,
          i,
          f,
          Vn(o)
        );
    } catch (fe) {
      ls(
        o,
        i,
        { then: function() {
        }, status: "rejected", reason: fe },
        Vn()
      );
    } finally {
      K.p = S, A !== null && T.types !== null && (A.types = T.types), L.T = A;
    }
  }
  function $C() {
  }
  function $f(o, i, u, f) {
    if (o.tag !== 5) throw Error(r(476));
    var g = Zv(o).queue;
    Jv(
      o,
      g,
      i,
      q,
      u === null ? $C : function() {
        return ey(o), u(f);
      }
    );
  }
  function Zv(o) {
    var i = o.memoizedState;
    if (i !== null) return i;
    i = {
      memoizedState: q,
      baseState: q,
      baseQueue: null,
      queue: {
        pending: null,
        lanes: 0,
        dispatch: null,
        lastRenderedReducer: Ur,
        lastRenderedState: q
      },
      next: null
    };
    var u = {};
    return i.next = {
      memoizedState: u,
      baseState: u,
      baseQueue: null,
      queue: {
        pending: null,
        lanes: 0,
        dispatch: null,
        lastRenderedReducer: Ur,
        lastRenderedState: u
      },
      next: null
    }, o.memoizedState = i, o = o.alternate, o !== null && (o.memoizedState = i), i;
  }
  function ey(o) {
    var i = Zv(o);
    i.next === null && (i = o.alternate.memoizedState), ls(
      o,
      i.next.queue,
      {},
      Vn()
    );
  }
  function Tf() {
    return tn(Es);
  }
  function ty() {
    return Nt().memoizedState;
  }
  function ny() {
    return Nt().memoizedState;
  }
  function TC(o) {
    for (var i = o.return; i !== null; ) {
      switch (i.tag) {
        case 24:
        case 3:
          var u = Vn();
          o = fo(u);
          var f = po(i, o, u);
          f !== null && (Nn(f, i, u), rs(f, i, u)), i = { cache: df() }, o.payload = i;
          return;
      }
      i = i.return;
    }
  }
  function LC(o, i, u) {
    var f = Vn();
    u = {
      lane: f,
      revertLane: 0,
      gesture: null,
      action: u,
      hasEagerState: !1,
      eagerState: null,
      next: null
    }, bu(o) ? oy(i, u) : (u = Zd(o, i, u, f), u !== null && (Nn(u, o, f), ay(u, i, f)));
  }
  function ry(o, i, u) {
    var f = Vn();
    ls(o, i, u, f);
  }
  function ls(o, i, u, f) {
    var g = {
      lane: f,
      revertLane: 0,
      gesture: null,
      action: u,
      hasEagerState: !1,
      eagerState: null,
      next: null
    };
    if (bu(o)) oy(i, g);
    else {
      var S = o.alternate;
      if (o.lanes === 0 && (S === null || S.lanes === 0) && (S = i.lastRenderedReducer, S !== null))
        try {
          var A = i.lastRenderedState, T = S(A, u);
          if (g.hasEagerState = !0, g.eagerState = T, Ln(T, A))
            return Zl(o, i, g, 0), lt === null && Jl(), !1;
        } catch {
        }
      if (u = Zd(o, i, g, f), u !== null)
        return Nn(u, o, f), ay(u, i, f), !0;
    }
    return !1;
  }
  function Lf(o, i, u, f) {
    if (f = {
      lane: 2,
      revertLane: hp(),
      gesture: null,
      action: f,
      hasEagerState: !1,
      eagerState: null,
      next: null
    }, bu(o)) {
      if (i) throw Error(r(479));
    } else
      i = Zd(
        o,
        u,
        f,
        2
      ), i !== null && Nn(i, o, 2);
  }
  function bu(o) {
    var i = o.alternate;
    return o === Te || i !== null && i === Te;
  }
  function oy(o, i) {
    Qa = fu = !0;
    var u = o.pending;
    u === null ? i.next = i : (i.next = u.next, u.next = i), o.pending = i;
  }
  function ay(o, i, u) {
    if ((u & 4194048) !== 0) {
      var f = i.lanes;
      f &= o.pendingLanes, u |= f, i.lanes = u, kd(o, u);
    }
  }
  var us = {
    readContext: tn,
    use: hu,
    useCallback: xt,
    useContext: xt,
    useEffect: xt,
    useImperativeHandle: xt,
    useLayoutEffect: xt,
    useInsertionEffect: xt,
    useMemo: xt,
    useReducer: xt,
    useRef: xt,
    useState: xt,
    useDebugValue: xt,
    useDeferredValue: xt,
    useTransition: xt,
    useSyncExternalStore: xt,
    useId: xt,
    useHostTransitionStatus: xt,
    useFormState: xt,
    useActionState: xt,
    useOptimistic: xt,
    useMemoCache: xt,
    useCacheRefresh: xt
  };
  us.useEffectEvent = xt;
  var iy = {
    readContext: tn,
    use: hu,
    useCallback: function(o, i) {
      return hn().memoizedState = [
        o,
        i === void 0 ? null : i
      ], o;
    },
    useContext: tn,
    useEffect: Vv,
    useImperativeHandle: function(o, i, u) {
      u = u != null ? u.concat([o]) : null, vu(
        4194308,
        4,
        Gv.bind(null, i, o),
        u
      );
    },
    useLayoutEffect: function(o, i) {
      return vu(4194308, 4, o, i);
    },
    useInsertionEffect: function(o, i) {
      vu(4, 2, o, i);
    },
    useMemo: function(o, i) {
      var u = hn();
      i = i === void 0 ? null : i;
      var f = o();
      if (pa) {
        bn(!0);
        try {
          o();
        } finally {
          bn(!1);
        }
      }
      return u.memoizedState = [f, i], f;
    },
    useReducer: function(o, i, u) {
      var f = hn();
      if (u !== void 0) {
        var g = u(i);
        if (pa) {
          bn(!0);
          try {
            u(i);
          } finally {
            bn(!1);
          }
        }
      } else g = i;
      return f.memoizedState = f.baseState = g, o = {
        pending: null,
        lanes: 0,
        dispatch: null,
        lastRenderedReducer: o,
        lastRenderedState: g
      }, f.queue = o, o = o.dispatch = LC.bind(
        null,
        Te,
        o
      ), [f.memoizedState, o];
    },
    useRef: function(o) {
      var i = hn();
      return o = { current: o }, i.memoizedState = o;
    },
    useState: function(o) {
      o = Rf(o);
      var i = o.queue, u = ry.bind(null, Te, i);
      return i.dispatch = u, [o.memoizedState, u];
    },
    useDebugValue: Pf,
    useDeferredValue: function(o, i) {
      var u = hn();
      return Df(u, o, i);
    },
    useTransition: function() {
      var o = Rf(!1);
      return o = Jv.bind(
        null,
        Te,
        o.queue,
        !0,
        !1
      ), hn().memoizedState = o, [!1, o];
    },
    useSyncExternalStore: function(o, i, u) {
      var f = Te, g = hn();
      if (Ge) {
        if (u === void 0)
          throw Error(r(407));
        u = u();
      } else {
        if (u = i(), lt === null)
          throw Error(r(349));
        (Ve & 127) !== 0 || Ov(f, i, u);
      }
      g.memoizedState = u;
      var S = { value: u, getSnapshot: i };
      return g.queue = S, Vv(Nv.bind(null, f, S, o), [
        o
      ]), f.flags |= 2048, Za(
        9,
        { destroy: void 0 },
        Mv.bind(
          null,
          f,
          S,
          u,
          i
        ),
        null
      ), u;
    },
    useId: function() {
      var o = hn(), i = lt.identifierPrefix;
      if (Ge) {
        var u = kr, f = Sr;
        u = (f & ~(1 << 32 - Re(f) - 1)).toString(32) + u, i = "_" + i + "R_" + u, u = pu++, 0 < u && (i += "H" + u.toString(32)), i += "_";
      } else
        u = RC++, i = "_" + i + "r_" + u.toString(32) + "_";
      return o.memoizedState = i;
    },
    useHostTransitionStatus: Tf,
    useFormState: Iv,
    useActionState: Iv,
    useOptimistic: function(o) {
      var i = hn();
      i.memoizedState = i.baseState = o;
      var u = {
        pending: null,
        lanes: 0,
        dispatch: null,
        lastRenderedReducer: null,
        lastRenderedState: null
      };
      return i.queue = u, i = Lf.bind(
        null,
        Te,
        !0,
        u
      ), u.dispatch = i, [o, i];
    },
    useMemoCache: Of,
    useCacheRefresh: function() {
      return hn().memoizedState = TC.bind(
        null,
        Te
      );
    },
    useEffectEvent: function(o) {
      var i = hn(), u = { impl: o };
      return i.memoizedState = u, function() {
        if ((Je & 2) !== 0)
          throw Error(r(440));
        return u.impl.apply(void 0, arguments);
      };
    }
  }, If = {
    readContext: tn,
    use: hu,
    useCallback: Xv,
    useContext: tn,
    useEffect: jf,
    useImperativeHandle: Kv,
    useInsertionEffect: qv,
    useLayoutEffect: Wv,
    useMemo: Yv,
    useReducer: gu,
    useRef: Uv,
    useState: function() {
      return gu(Ur);
    },
    useDebugValue: Pf,
    useDeferredValue: function(o, i) {
      var u = Nt();
      return Qv(
        u,
        ot.memoizedState,
        o,
        i
      );
    },
    useTransition: function() {
      var o = gu(Ur)[0], i = Nt().memoizedState;
      return [
        typeof o == "boolean" ? o : ss(o),
        i
      ];
    },
    useSyncExternalStore: Cv,
    useId: ty,
    useHostTransitionStatus: Tf,
    useFormState: zv,
    useActionState: zv,
    useOptimistic: function(o, i) {
      var u = Nt();
      return jv(u, ot, o, i);
    },
    useMemoCache: Of,
    useCacheRefresh: ny
  };
  If.useEffectEvent = Hv;
  var sy = {
    readContext: tn,
    use: hu,
    useCallback: Xv,
    useContext: tn,
    useEffect: jf,
    useImperativeHandle: Kv,
    useInsertionEffect: qv,
    useLayoutEffect: Wv,
    useMemo: Yv,
    useReducer: Nf,
    useRef: Uv,
    useState: function() {
      return Nf(Ur);
    },
    useDebugValue: Pf,
    useDeferredValue: function(o, i) {
      var u = Nt();
      return ot === null ? Df(u, o, i) : Qv(
        u,
        ot.memoizedState,
        o,
        i
      );
    },
    useTransition: function() {
      var o = Nf(Ur)[0], i = Nt().memoizedState;
      return [
        typeof o == "boolean" ? o : ss(o),
        i
      ];
    },
    useSyncExternalStore: Cv,
    useId: ty,
    useHostTransitionStatus: Tf,
    useFormState: Bv,
    useActionState: Bv,
    useOptimistic: function(o, i) {
      var u = Nt();
      return ot !== null ? jv(u, ot, o, i) : (u.baseState = o, [o, u.queue.dispatch]);
    },
    useMemoCache: Of,
    useCacheRefresh: ny
  };
  sy.useEffectEvent = Hv;
  function zf(o, i, u, f) {
    i = o.memoizedState, u = u(f, i), u = u == null ? i : h({}, i, u), o.memoizedState = u, o.lanes === 0 && (o.updateQueue.baseState = u);
  }
  var Ff = {
    enqueueSetState: function(o, i, u) {
      o = o._reactInternals;
      var f = Vn(), g = fo(f);
      g.payload = i, u != null && (g.callback = u), i = po(o, g, f), i !== null && (Nn(i, o, f), rs(i, o, f));
    },
    enqueueReplaceState: function(o, i, u) {
      o = o._reactInternals;
      var f = Vn(), g = fo(f);
      g.tag = 1, g.payload = i, u != null && (g.callback = u), i = po(o, g, f), i !== null && (Nn(i, o, f), rs(i, o, f));
    },
    enqueueForceUpdate: function(o, i) {
      o = o._reactInternals;
      var u = Vn(), f = fo(u);
      f.tag = 2, i != null && (f.callback = i), i = po(o, f, u), i !== null && (Nn(i, o, u), rs(i, o, u));
    }
  };
  function ly(o, i, u, f, g, S, A) {
    return o = o.stateNode, typeof o.shouldComponentUpdate == "function" ? o.shouldComponentUpdate(f, S, A) : i.prototype && i.prototype.isPureReactComponent ? !Xi(u, f) || !Xi(g, S) : !0;
  }
  function uy(o, i, u, f) {
    o = i.state, typeof i.componentWillReceiveProps == "function" && i.componentWillReceiveProps(u, f), typeof i.UNSAFE_componentWillReceiveProps == "function" && i.UNSAFE_componentWillReceiveProps(u, f), i.state !== o && Ff.enqueueReplaceState(i, i.state, null);
  }
  function ma(o, i) {
    var u = i;
    if ("ref" in i) {
      u = {};
      for (var f in i)
        f !== "ref" && (u[f] = i[f]);
    }
    if (o = o.defaultProps) {
      u === i && (u = h({}, u));
      for (var g in o)
        u[g] === void 0 && (u[g] = o[g]);
    }
    return u;
  }
  function cy(o) {
    Ql(o);
  }
  function dy(o) {
    console.error(o);
  }
  function fy(o) {
    Ql(o);
  }
  function wu(o, i) {
    try {
      var u = o.onUncaughtError;
      u(i.value, { componentStack: i.stack });
    } catch (f) {
      setTimeout(function() {
        throw f;
      });
    }
  }
  function py(o, i, u) {
    try {
      var f = o.onCaughtError;
      f(u.value, {
        componentStack: u.stack,
        errorBoundary: i.tag === 1 ? i.stateNode : null
      });
    } catch (g) {
      setTimeout(function() {
        throw g;
      });
    }
  }
  function Bf(o, i, u) {
    return u = fo(u), u.tag = 3, u.payload = { element: null }, u.callback = function() {
      wu(o, i);
    }, u;
  }
  function my(o) {
    return o = fo(o), o.tag = 3, o;
  }
  function hy(o, i, u, f) {
    var g = u.type.getDerivedStateFromError;
    if (typeof g == "function") {
      var S = f.value;
      o.payload = function() {
        return g(S);
      }, o.callback = function() {
        py(i, u, f);
      };
    }
    var A = u.stateNode;
    A !== null && typeof A.componentDidCatch == "function" && (o.callback = function() {
      py(i, u, f), typeof g != "function" && (bo === null ? bo = /* @__PURE__ */ new Set([this]) : bo.add(this));
      var T = f.stack;
      this.componentDidCatch(f.value, {
        componentStack: T !== null ? T : ""
      });
    });
  }
  function IC(o, i, u, f, g) {
    if (u.flags |= 32768, f !== null && typeof f == "object" && typeof f.then == "function") {
      if (i = u.alternate, i !== null && qa(
        i,
        u,
        g,
        !0
      ), u = zn.current, u !== null) {
        switch (u.tag) {
          case 31:
          case 13:
            return lr === null ? ju() : u.alternate === null && St === 0 && (St = 3), u.flags &= -257, u.flags |= 65536, u.lanes = g, f === su ? u.flags |= 16384 : (i = u.updateQueue, i === null ? u.updateQueue = /* @__PURE__ */ new Set([f]) : i.add(f), fp(o, f, g)), !1;
          case 22:
            return u.flags |= 65536, f === su ? u.flags |= 16384 : (i = u.updateQueue, i === null ? (i = {
              transitions: null,
              markerInstances: null,
              retryQueue: /* @__PURE__ */ new Set([f])
            }, u.updateQueue = i) : (u = i.retryQueue, u === null ? i.retryQueue = /* @__PURE__ */ new Set([f]) : u.add(f)), fp(o, f, g)), !1;
        }
        throw Error(r(435, u.tag));
      }
      return fp(o, f, g), ju(), !1;
    }
    if (Ge)
      return i = zn.current, i !== null ? ((i.flags & 65536) === 0 && (i.flags |= 256), i.flags |= 65536, i.lanes = g, f !== af && (o = Error(r(422), { cause: f }), Ji(Zn(o, u)))) : (f !== af && (i = Error(r(423), {
        cause: f
      }), Ji(
        Zn(i, u)
      )), o = o.current.alternate, o.flags |= 65536, g &= -g, o.lanes |= g, f = Zn(f, u), g = Bf(
        o.stateNode,
        f,
        g
      ), vf(o, g), St !== 4 && (St = 2)), !1;
    var S = Error(r(520), { cause: f });
    if (S = Zn(S, u), vs === null ? vs = [S] : vs.push(S), St !== 4 && (St = 2), i === null) return !0;
    f = Zn(f, u), u = i;
    do {
      switch (u.tag) {
        case 3:
          return u.flags |= 65536, o = g & -g, u.lanes |= o, o = Bf(u.stateNode, f, o), vf(u, o), !1;
        case 1:
          if (i = u.type, S = u.stateNode, (u.flags & 128) === 0 && (typeof i.getDerivedStateFromError == "function" || S !== null && typeof S.componentDidCatch == "function" && (bo === null || !bo.has(S))))
            return u.flags |= 65536, g &= -g, u.lanes |= g, g = my(g), hy(
              g,
              o,
              u,
              f
            ), vf(u, g), !1;
      }
      u = u.return;
    } while (u !== null);
    return !1;
  }
  var Uf = Error(r(461)), Dt = !1;
  function nn(o, i, u, f) {
    i.child = o === null ? bv(i, null, u, f) : fa(
      i,
      o.child,
      u,
      f
    );
  }
  function gy(o, i, u, f, g) {
    u = u.render;
    var S = i.ref;
    if ("ref" in f) {
      var A = {};
      for (var T in f)
        T !== "ref" && (A[T] = f[T]);
    } else A = f;
    return la(i), f = kf(
      o,
      i,
      u,
      A,
      S,
      g
    ), T = _f(), o !== null && !Dt ? (Ef(o, i, g), Vr(o, i, g)) : (Ge && T && rf(i), i.flags |= 1, nn(o, i, f, g), i.child);
  }
  function vy(o, i, u, f, g) {
    if (o === null) {
      var S = u.type;
      return typeof S == "function" && !ef(S) && S.defaultProps === void 0 && u.compare === null ? (i.tag = 15, i.type = S, yy(
        o,
        i,
        S,
        f,
        g
      )) : (o = tu(
        u.type,
        null,
        f,
        i,
        i.mode,
        g
      ), o.ref = i.ref, o.return = i, i.child = o);
    }
    if (S = o.child, !Yf(o, g)) {
      var A = S.memoizedProps;
      if (u = u.compare, u = u !== null ? u : Xi, u(A, f) && o.ref === i.ref)
        return Vr(o, i, g);
    }
    return i.flags |= 1, o = Lr(S, f), o.ref = i.ref, o.return = i, i.child = o;
  }
  function yy(o, i, u, f, g) {
    if (o !== null) {
      var S = o.memoizedProps;
      if (Xi(S, f) && o.ref === i.ref)
        if (Dt = !1, i.pendingProps = f = S, Yf(o, g))
          (o.flags & 131072) !== 0 && (Dt = !0);
        else
          return i.lanes = o.lanes, Vr(o, i, g);
    }
    return Vf(
      o,
      i,
      u,
      f,
      g
    );
  }
  function by(o, i, u, f) {
    var g = f.children, S = o !== null ? o.memoizedState : null;
    if (o === null && i.stateNode === null && (i.stateNode = {
      _visibility: 1,
      _pendingMarkers: null,
      _retryCache: null,
      _transitions: null
    }), f.mode === "hidden") {
      if ((i.flags & 128) !== 0) {
        if (S = S !== null ? S.baseLanes | u : u, o !== null) {
          for (f = i.child = o.child, g = 0; f !== null; )
            g = g | f.lanes | f.childLanes, f = f.sibling;
          f = g & ~S;
        } else f = 0, i.child = null;
        return wy(
          o,
          i,
          S,
          u,
          f
        );
      }
      if ((u & 536870912) !== 0)
        i.memoizedState = { baseLanes: 0, cachePool: null }, o !== null && au(
          i,
          S !== null ? S.cachePool : null
        ), S !== null ? Sv(i, S) : bf(), kv(i);
      else
        return f = i.lanes = 536870912, wy(
          o,
          i,
          S !== null ? S.baseLanes | u : u,
          u,
          f
        );
    } else
      S !== null ? (au(i, S.cachePool), Sv(i, S), ho(), i.memoizedState = null) : (o !== null && au(i, null), bf(), ho());
    return nn(o, i, g, u), i.child;
  }
  function cs(o, i) {
    return o !== null && o.tag === 22 || i.stateNode !== null || (i.stateNode = {
      _visibility: 1,
      _pendingMarkers: null,
      _retryCache: null,
      _transitions: null
    }), i.sibling;
  }
  function wy(o, i, u, f, g) {
    var S = pf();
    return S = S === null ? null : { parent: jt._currentValue, pool: S }, i.memoizedState = {
      baseLanes: u,
      cachePool: S
    }, o !== null && au(i, null), bf(), kv(i), o !== null && qa(o, i, f, !0), i.childLanes = g, null;
  }
  function xu(o, i) {
    return i = ku(
      { mode: i.mode, children: i.children },
      o.mode
    ), i.ref = o.ref, o.child = i, i.return = o, i;
  }
  function xy(o, i, u) {
    return fa(i, o.child, null, u), o = xu(i, i.pendingProps), o.flags |= 2, Fn(i), i.memoizedState = null, o;
  }
  function zC(o, i, u) {
    var f = i.pendingProps, g = (i.flags & 128) !== 0;
    if (i.flags &= -129, o === null) {
      if (Ge) {
        if (f.mode === "hidden")
          return o = xu(i, f), i.lanes = 536870912, cs(null, o);
        if (xf(i), (o = gt) ? (o = Pb(
          o,
          nr
        ), o = o !== null && o.data === "&" ? o : null, o !== null && (i.memoizedState = {
          dehydrated: o,
          treeContext: io !== null ? { id: Sr, overflow: kr } : null,
          retryLane: 536870912,
          hydrationErrors: null
        }, u = ov(o), u.return = i, i.child = u, en = i, gt = null)) : o = null, o === null) throw lo(i);
        return i.lanes = 536870912, null;
      }
      return xu(i, f);
    }
    var S = o.memoizedState;
    if (S !== null) {
      var A = S.dehydrated;
      if (xf(i), g)
        if (i.flags & 256)
          i.flags &= -257, i = xy(
            o,
            i,
            u
          );
        else if (i.memoizedState !== null)
          i.child = o.child, i.flags |= 128, i = null;
        else throw Error(r(558));
      else if (Dt || qa(o, i, u, !1), g = (u & o.childLanes) !== 0, Dt || g) {
        if (f = lt, f !== null && (A = _d(f, u), A !== 0 && A !== S.retryLane))
          throw S.retryLane = A, oa(o, A), Nn(f, o, A), Uf;
        ju(), i = xy(
          o,
          i,
          u
        );
      } else
        o = S.treeContext, gt = rr(A.nextSibling), en = i, Ge = !0, so = null, nr = !1, o !== null && sv(i, o), i = xu(i, f), i.flags |= 4096;
      return i;
    }
    return o = Lr(o.child, {
      mode: f.mode,
      children: f.children
    }), o.ref = i.ref, i.child = o, o.return = i, o;
  }
  function Su(o, i) {
    var u = i.ref;
    if (u === null)
      o !== null && o.ref !== null && (i.flags |= 4194816);
    else {
      if (typeof u != "function" && typeof u != "object")
        throw Error(r(284));
      (o === null || o.ref !== u) && (i.flags |= 4194816);
    }
  }
  function Vf(o, i, u, f, g) {
    return la(i), u = kf(
      o,
      i,
      u,
      f,
      void 0,
      g
    ), f = _f(), o !== null && !Dt ? (Ef(o, i, g), Vr(o, i, g)) : (Ge && f && rf(i), i.flags |= 1, nn(o, i, u, g), i.child);
  }
  function Sy(o, i, u, f, g, S) {
    return la(i), i.updateQueue = null, u = Ev(
      i,
      f,
      u,
      g
    ), _v(o), f = _f(), o !== null && !Dt ? (Ef(o, i, S), Vr(o, i, S)) : (Ge && f && rf(i), i.flags |= 1, nn(o, i, u, S), i.child);
  }
  function ky(o, i, u, f, g) {
    if (la(i), i.stateNode === null) {
      var S = Ba, A = u.contextType;
      typeof A == "object" && A !== null && (S = tn(A)), S = new u(f, S), i.memoizedState = S.state !== null && S.state !== void 0 ? S.state : null, S.updater = Ff, i.stateNode = S, S._reactInternals = i, S = i.stateNode, S.props = f, S.state = i.memoizedState, S.refs = {}, hf(i), A = u.contextType, S.context = typeof A == "object" && A !== null ? tn(A) : Ba, S.state = i.memoizedState, A = u.getDerivedStateFromProps, typeof A == "function" && (zf(
        i,
        u,
        A,
        f
      ), S.state = i.memoizedState), typeof u.getDerivedStateFromProps == "function" || typeof S.getSnapshotBeforeUpdate == "function" || typeof S.UNSAFE_componentWillMount != "function" && typeof S.componentWillMount != "function" || (A = S.state, typeof S.componentWillMount == "function" && S.componentWillMount(), typeof S.UNSAFE_componentWillMount == "function" && S.UNSAFE_componentWillMount(), A !== S.state && Ff.enqueueReplaceState(S, S.state, null), as(i, f, S, g), os(), S.state = i.memoizedState), typeof S.componentDidMount == "function" && (i.flags |= 4194308), f = !0;
    } else if (o === null) {
      S = i.stateNode;
      var T = i.memoizedProps, Y = ma(u, T);
      S.props = Y;
      var ne = S.context, ue = u.contextType;
      A = Ba, typeof ue == "object" && ue !== null && (A = tn(ue));
      var fe = u.getDerivedStateFromProps;
      ue = typeof fe == "function" || typeof S.getSnapshotBeforeUpdate == "function", T = i.pendingProps !== T, ue || typeof S.UNSAFE_componentWillReceiveProps != "function" && typeof S.componentWillReceiveProps != "function" || (T || ne !== A) && uy(
        i,
        S,
        f,
        A
      ), co = !1;
      var oe = i.memoizedState;
      S.state = oe, as(i, f, S, g), os(), ne = i.memoizedState, T || oe !== ne || co ? (typeof fe == "function" && (zf(
        i,
        u,
        fe,
        f
      ), ne = i.memoizedState), (Y = co || ly(
        i,
        u,
        Y,
        f,
        oe,
        ne,
        A
      )) ? (ue || typeof S.UNSAFE_componentWillMount != "function" && typeof S.componentWillMount != "function" || (typeof S.componentWillMount == "function" && S.componentWillMount(), typeof S.UNSAFE_componentWillMount == "function" && S.UNSAFE_componentWillMount()), typeof S.componentDidMount == "function" && (i.flags |= 4194308)) : (typeof S.componentDidMount == "function" && (i.flags |= 4194308), i.memoizedProps = f, i.memoizedState = ne), S.props = f, S.state = ne, S.context = A, f = Y) : (typeof S.componentDidMount == "function" && (i.flags |= 4194308), f = !1);
    } else {
      S = i.stateNode, gf(o, i), A = i.memoizedProps, ue = ma(u, A), S.props = ue, fe = i.pendingProps, oe = S.context, ne = u.contextType, Y = Ba, typeof ne == "object" && ne !== null && (Y = tn(ne)), T = u.getDerivedStateFromProps, (ne = typeof T == "function" || typeof S.getSnapshotBeforeUpdate == "function") || typeof S.UNSAFE_componentWillReceiveProps != "function" && typeof S.componentWillReceiveProps != "function" || (A !== fe || oe !== Y) && uy(
        i,
        S,
        f,
        Y
      ), co = !1, oe = i.memoizedState, S.state = oe, as(i, f, S, g), os();
      var ie = i.memoizedState;
      A !== fe || oe !== ie || co || o !== null && o.dependencies !== null && ru(o.dependencies) ? (typeof T == "function" && (zf(
        i,
        u,
        T,
        f
      ), ie = i.memoizedState), (ue = co || ly(
        i,
        u,
        ue,
        f,
        oe,
        ie,
        Y
      ) || o !== null && o.dependencies !== null && ru(o.dependencies)) ? (ne || typeof S.UNSAFE_componentWillUpdate != "function" && typeof S.componentWillUpdate != "function" || (typeof S.componentWillUpdate == "function" && S.componentWillUpdate(f, ie, Y), typeof S.UNSAFE_componentWillUpdate == "function" && S.UNSAFE_componentWillUpdate(
        f,
        ie,
        Y
      )), typeof S.componentDidUpdate == "function" && (i.flags |= 4), typeof S.getSnapshotBeforeUpdate == "function" && (i.flags |= 1024)) : (typeof S.componentDidUpdate != "function" || A === o.memoizedProps && oe === o.memoizedState || (i.flags |= 4), typeof S.getSnapshotBeforeUpdate != "function" || A === o.memoizedProps && oe === o.memoizedState || (i.flags |= 1024), i.memoizedProps = f, i.memoizedState = ie), S.props = f, S.state = ie, S.context = Y, f = ue) : (typeof S.componentDidUpdate != "function" || A === o.memoizedProps && oe === o.memoizedState || (i.flags |= 4), typeof S.getSnapshotBeforeUpdate != "function" || A === o.memoizedProps && oe === o.memoizedState || (i.flags |= 1024), f = !1);
    }
    return S = f, Su(o, i), f = (i.flags & 128) !== 0, S || f ? (S = i.stateNode, u = f && typeof u.getDerivedStateFromError != "function" ? null : S.render(), i.flags |= 1, o !== null && f ? (i.child = fa(
      i,
      o.child,
      null,
      g
    ), i.child = fa(
      i,
      null,
      u,
      g
    )) : nn(o, i, u, g), i.memoizedState = S.state, o = i.child) : o = Vr(
      o,
      i,
      g
    ), o;
  }
  function _y(o, i, u, f) {
    return ia(), i.flags |= 256, nn(o, i, u, f), i.child;
  }
  var Hf = {
    dehydrated: null,
    treeContext: null,
    retryLane: 0,
    hydrationErrors: null
  };
  function qf(o) {
    return { baseLanes: o, cachePool: pv() };
  }
  function Wf(o, i, u) {
    return o = o !== null ? o.childLanes & ~u : 0, i && (o |= Un), o;
  }
  function Ey(o, i, u) {
    var f = i.pendingProps, g = !1, S = (i.flags & 128) !== 0, A;
    if ((A = S) || (A = o !== null && o.memoizedState === null ? !1 : (Mt.current & 2) !== 0), A && (g = !0, i.flags &= -129), A = (i.flags & 32) !== 0, i.flags &= -33, o === null) {
      if (Ge) {
        if (g ? mo(i) : ho(), (o = gt) ? (o = Pb(
          o,
          nr
        ), o = o !== null && o.data !== "&" ? o : null, o !== null && (i.memoizedState = {
          dehydrated: o,
          treeContext: io !== null ? { id: Sr, overflow: kr } : null,
          retryLane: 536870912,
          hydrationErrors: null
        }, u = ov(o), u.return = i, i.child = u, en = i, gt = null)) : o = null, o === null) throw lo(i);
        return Mp(o) ? i.lanes = 32 : i.lanes = 536870912, null;
      }
      var T = f.children;
      return f = f.fallback, g ? (ho(), g = i.mode, T = ku(
        { mode: "hidden", children: T },
        g
      ), f = aa(
        f,
        g,
        u,
        null
      ), T.return = i, f.return = i, T.sibling = f, i.child = T, f = i.child, f.memoizedState = qf(u), f.childLanes = Wf(
        o,
        A,
        u
      ), i.memoizedState = Hf, cs(null, f)) : (mo(i), Gf(i, T));
    }
    var Y = o.memoizedState;
    if (Y !== null && (T = Y.dehydrated, T !== null)) {
      if (S)
        i.flags & 256 ? (mo(i), i.flags &= -257, i = Kf(
          o,
          i,
          u
        )) : i.memoizedState !== null ? (ho(), i.child = o.child, i.flags |= 128, i = null) : (ho(), T = f.fallback, g = i.mode, f = ku(
          { mode: "visible", children: f.children },
          g
        ), T = aa(
          T,
          g,
          u,
          null
        ), T.flags |= 2, f.return = i, T.return = i, f.sibling = T, i.child = f, fa(
          i,
          o.child,
          null,
          u
        ), f = i.child, f.memoizedState = qf(u), f.childLanes = Wf(
          o,
          A,
          u
        ), i.memoizedState = Hf, i = cs(null, f));
      else if (mo(i), Mp(T)) {
        if (A = T.nextSibling && T.nextSibling.dataset, A) var ne = A.dgst;
        A = ne, f = Error(r(419)), f.stack = "", f.digest = A, Ji({ value: f, source: null, stack: null }), i = Kf(
          o,
          i,
          u
        );
      } else if (Dt || qa(o, i, u, !1), A = (u & o.childLanes) !== 0, Dt || A) {
        if (A = lt, A !== null && (f = _d(A, u), f !== 0 && f !== Y.retryLane))
          throw Y.retryLane = f, oa(o, f), Nn(A, o, f), Uf;
        Op(T) || ju(), i = Kf(
          o,
          i,
          u
        );
      } else
        Op(T) ? (i.flags |= 192, i.child = o.child, i = null) : (o = Y.treeContext, gt = rr(
          T.nextSibling
        ), en = i, Ge = !0, so = null, nr = !1, o !== null && sv(i, o), i = Gf(
          i,
          f.children
        ), i.flags |= 4096);
      return i;
    }
    return g ? (ho(), T = f.fallback, g = i.mode, Y = o.child, ne = Y.sibling, f = Lr(Y, {
      mode: "hidden",
      children: f.children
    }), f.subtreeFlags = Y.subtreeFlags & 65011712, ne !== null ? T = Lr(
      ne,
      T
    ) : (T = aa(
      T,
      g,
      u,
      null
    ), T.flags |= 2), T.return = i, f.return = i, f.sibling = T, i.child = f, cs(null, f), f = i.child, T = o.child.memoizedState, T === null ? T = qf(u) : (g = T.cachePool, g !== null ? (Y = jt._currentValue, g = g.parent !== Y ? { parent: Y, pool: Y } : g) : g = pv(), T = {
      baseLanes: T.baseLanes | u,
      cachePool: g
    }), f.memoizedState = T, f.childLanes = Wf(
      o,
      A,
      u
    ), i.memoizedState = Hf, cs(o.child, f)) : (mo(i), u = o.child, o = u.sibling, u = Lr(u, {
      mode: "visible",
      children: f.children
    }), u.return = i, u.sibling = null, o !== null && (A = i.deletions, A === null ? (i.deletions = [o], i.flags |= 16) : A.push(o)), i.child = u, i.memoizedState = null, u);
  }
  function Gf(o, i) {
    return i = ku(
      { mode: "visible", children: i },
      o.mode
    ), i.return = o, o.child = i;
  }
  function ku(o, i) {
    return o = In(22, o, null, i), o.lanes = 0, o;
  }
  function Kf(o, i, u) {
    return fa(i, o.child, null, u), o = Gf(
      i,
      i.pendingProps.children
    ), o.flags |= 2, i.memoizedState = null, o;
  }
  function Cy(o, i, u) {
    o.lanes |= i;
    var f = o.alternate;
    f !== null && (f.lanes |= i), uf(o.return, i, u);
  }
  function Xf(o, i, u, f, g, S) {
    var A = o.memoizedState;
    A === null ? o.memoizedState = {
      isBackwards: i,
      rendering: null,
      renderingStartTime: 0,
      last: f,
      tail: u,
      tailMode: g,
      treeForkCount: S
    } : (A.isBackwards = i, A.rendering = null, A.renderingStartTime = 0, A.last = f, A.tail = u, A.tailMode = g, A.treeForkCount = S);
  }
  function Oy(o, i, u) {
    var f = i.pendingProps, g = f.revealOrder, S = f.tail;
    f = f.children;
    var A = Mt.current, T = (A & 2) !== 0;
    if (T ? (A = A & 1 | 2, i.flags |= 128) : A &= 1, U(Mt, A), nn(o, i, f, u), f = Ge ? Qi : 0, !T && o !== null && (o.flags & 128) !== 0)
      e: for (o = i.child; o !== null; ) {
        if (o.tag === 13)
          o.memoizedState !== null && Cy(o, u, i);
        else if (o.tag === 19)
          Cy(o, u, i);
        else if (o.child !== null) {
          o.child.return = o, o = o.child;
          continue;
        }
        if (o === i) break e;
        for (; o.sibling === null; ) {
          if (o.return === null || o.return === i)
            break e;
          o = o.return;
        }
        o.sibling.return = o.return, o = o.sibling;
      }
    switch (g) {
      case "forwards":
        for (u = i.child, g = null; u !== null; )
          o = u.alternate, o !== null && du(o) === null && (g = u), u = u.sibling;
        u = g, u === null ? (g = i.child, i.child = null) : (g = u.sibling, u.sibling = null), Xf(
          i,
          !1,
          g,
          u,
          S,
          f
        );
        break;
      case "backwards":
      case "unstable_legacy-backwards":
        for (u = null, g = i.child, i.child = null; g !== null; ) {
          if (o = g.alternate, o !== null && du(o) === null) {
            i.child = g;
            break;
          }
          o = g.sibling, g.sibling = u, u = g, g = o;
        }
        Xf(
          i,
          !0,
          u,
          null,
          S,
          f
        );
        break;
      case "together":
        Xf(
          i,
          !1,
          null,
          null,
          void 0,
          f
        );
        break;
      default:
        i.memoizedState = null;
    }
    return i.child;
  }
  function Vr(o, i, u) {
    if (o !== null && (i.dependencies = o.dependencies), yo |= i.lanes, (u & i.childLanes) === 0)
      if (o !== null) {
        if (qa(
          o,
          i,
          u,
          !1
        ), (u & i.childLanes) === 0)
          return null;
      } else return null;
    if (o !== null && i.child !== o.child)
      throw Error(r(153));
    if (i.child !== null) {
      for (o = i.child, u = Lr(o, o.pendingProps), i.child = u, u.return = i; o.sibling !== null; )
        o = o.sibling, u = u.sibling = Lr(o, o.pendingProps), u.return = i;
      u.sibling = null;
    }
    return i.child;
  }
  function Yf(o, i) {
    return (o.lanes & i) !== 0 ? !0 : (o = o.dependencies, !!(o !== null && ru(o)));
  }
  function FC(o, i, u) {
    switch (i.tag) {
      case 3:
        le(i, i.stateNode.containerInfo), uo(i, jt, o.memoizedState.cache), ia();
        break;
      case 27:
      case 5:
        ve(i);
        break;
      case 4:
        le(i, i.stateNode.containerInfo);
        break;
      case 10:
        uo(
          i,
          i.type,
          i.memoizedProps.value
        );
        break;
      case 31:
        if (i.memoizedState !== null)
          return i.flags |= 128, xf(i), null;
        break;
      case 13:
        var f = i.memoizedState;
        if (f !== null)
          return f.dehydrated !== null ? (mo(i), i.flags |= 128, null) : (u & i.child.childLanes) !== 0 ? Ey(o, i, u) : (mo(i), o = Vr(
            o,
            i,
            u
          ), o !== null ? o.sibling : null);
        mo(i);
        break;
      case 19:
        var g = (o.flags & 128) !== 0;
        if (f = (u & i.childLanes) !== 0, f || (qa(
          o,
          i,
          u,
          !1
        ), f = (u & i.childLanes) !== 0), g) {
          if (f)
            return Oy(
              o,
              i,
              u
            );
          i.flags |= 128;
        }
        if (g = i.memoizedState, g !== null && (g.rendering = null, g.tail = null, g.lastEffect = null), U(Mt, Mt.current), f) break;
        return null;
      case 22:
        return i.lanes = 0, by(
          o,
          i,
          u,
          i.pendingProps
        );
      case 24:
        uo(i, jt, o.memoizedState.cache);
    }
    return Vr(o, i, u);
  }
  function My(o, i, u) {
    if (o !== null)
      if (o.memoizedProps !== i.pendingProps)
        Dt = !0;
      else {
        if (!Yf(o, u) && (i.flags & 128) === 0)
          return Dt = !1, FC(
            o,
            i,
            u
          );
        Dt = (o.flags & 131072) !== 0;
      }
    else
      Dt = !1, Ge && (i.flags & 1048576) !== 0 && iv(i, Qi, i.index);
    switch (i.lanes = 0, i.tag) {
      case 16:
        e: {
          var f = i.pendingProps;
          if (o = ca(i.elementType), i.type = o, typeof o == "function")
            ef(o) ? (f = ma(o, f), i.tag = 1, i = ky(
              null,
              i,
              o,
              f,
              u
            )) : (i.tag = 0, i = Vf(
              null,
              i,
              o,
              f,
              u
            ));
          else {
            if (o != null) {
              var g = o.$$typeof;
              if (g === O) {
                i.tag = 11, i = gy(
                  null,
                  i,
                  o,
                  f,
                  u
                );
                break e;
              } else if (g === j) {
                i.tag = 14, i = vy(
                  null,
                  i,
                  o,
                  f,
                  u
                );
                break e;
              }
            }
            throw i = I(o) || o, Error(r(306, i, ""));
          }
        }
        return i;
      case 0:
        return Vf(
          o,
          i,
          i.type,
          i.pendingProps,
          u
        );
      case 1:
        return f = i.type, g = ma(
          f,
          i.pendingProps
        ), ky(
          o,
          i,
          f,
          g,
          u
        );
      case 3:
        e: {
          if (le(
            i,
            i.stateNode.containerInfo
          ), o === null) throw Error(r(387));
          f = i.pendingProps;
          var S = i.memoizedState;
          g = S.element, gf(o, i), as(i, f, null, u);
          var A = i.memoizedState;
          if (f = A.cache, uo(i, jt, f), f !== S.cache && cf(
            i,
            [jt],
            u,
            !0
          ), os(), f = A.element, S.isDehydrated)
            if (S = {
              element: f,
              isDehydrated: !1,
              cache: A.cache
            }, i.updateQueue.baseState = S, i.memoizedState = S, i.flags & 256) {
              i = _y(
                o,
                i,
                f,
                u
              );
              break e;
            } else if (f !== g) {
              g = Zn(
                Error(r(424)),
                i
              ), Ji(g), i = _y(
                o,
                i,
                f,
                u
              );
              break e;
            } else
              for (o = i.stateNode.containerInfo, o.nodeType === 9 ? o = o.body : o = o.nodeName === "HTML" ? o.ownerDocument.body : o, gt = rr(o.firstChild), en = i, Ge = !0, so = null, nr = !0, u = bv(
                i,
                null,
                f,
                u
              ), i.child = u; u; )
                u.flags = u.flags & -3 | 4096, u = u.sibling;
          else {
            if (ia(), f === g) {
              i = Vr(
                o,
                i,
                u
              );
              break e;
            }
            nn(o, i, f, u);
          }
          i = i.child;
        }
        return i;
      case 26:
        return Su(o, i), o === null ? (u = zb(
          i.type,
          null,
          i.pendingProps,
          null
        )) ? i.memoizedState = u : Ge || (u = i.type, o = i.pendingProps, f = zu(
          re.current
        ).createElement(u), f[Yt] = i, f[mn] = o, rn(f, u, o), Bt(f), i.stateNode = f) : i.memoizedState = zb(
          i.type,
          o.memoizedProps,
          i.pendingProps,
          o.memoizedState
        ), null;
      case 27:
        return ve(i), o === null && Ge && (f = i.stateNode = Tb(
          i.type,
          i.pendingProps,
          re.current
        ), en = i, nr = !0, g = gt, ko(i.type) ? (Np = g, gt = rr(f.firstChild)) : gt = g), nn(
          o,
          i,
          i.pendingProps.children,
          u
        ), Su(o, i), o === null && (i.flags |= 4194304), i.child;
      case 5:
        return o === null && Ge && ((g = f = gt) && (f = gO(
          f,
          i.type,
          i.pendingProps,
          nr
        ), f !== null ? (i.stateNode = f, en = i, gt = rr(f.firstChild), nr = !1, g = !0) : g = !1), g || lo(i)), ve(i), g = i.type, S = i.pendingProps, A = o !== null ? o.memoizedProps : null, f = S.children, _p(g, S) ? f = null : A !== null && _p(g, A) && (i.flags |= 32), i.memoizedState !== null && (g = kf(
          o,
          i,
          AC,
          null,
          null,
          u
        ), Es._currentValue = g), Su(o, i), nn(o, i, f, u), i.child;
      case 6:
        return o === null && Ge && ((o = u = gt) && (u = vO(
          u,
          i.pendingProps,
          nr
        ), u !== null ? (i.stateNode = u, en = i, gt = null, o = !0) : o = !1), o || lo(i)), null;
      case 13:
        return Ey(o, i, u);
      case 4:
        return le(
          i,
          i.stateNode.containerInfo
        ), f = i.pendingProps, o === null ? i.child = fa(
          i,
          null,
          f,
          u
        ) : nn(o, i, f, u), i.child;
      case 11:
        return gy(
          o,
          i,
          i.type,
          i.pendingProps,
          u
        );
      case 7:
        return nn(
          o,
          i,
          i.pendingProps,
          u
        ), i.child;
      case 8:
        return nn(
          o,
          i,
          i.pendingProps.children,
          u
        ), i.child;
      case 12:
        return nn(
          o,
          i,
          i.pendingProps.children,
          u
        ), i.child;
      case 10:
        return f = i.pendingProps, uo(i, i.type, f.value), nn(o, i, f.children, u), i.child;
      case 9:
        return g = i.type._context, f = i.pendingProps.children, la(i), g = tn(g), f = f(g), i.flags |= 1, nn(o, i, f, u), i.child;
      case 14:
        return vy(
          o,
          i,
          i.type,
          i.pendingProps,
          u
        );
      case 15:
        return yy(
          o,
          i,
          i.type,
          i.pendingProps,
          u
        );
      case 19:
        return Oy(o, i, u);
      case 31:
        return zC(o, i, u);
      case 22:
        return by(
          o,
          i,
          u,
          i.pendingProps
        );
      case 24:
        return la(i), f = tn(jt), o === null ? (g = pf(), g === null && (g = lt, S = df(), g.pooledCache = S, S.refCount++, S !== null && (g.pooledCacheLanes |= u), g = S), i.memoizedState = { parent: f, cache: g }, hf(i), uo(i, jt, g)) : ((o.lanes & u) !== 0 && (gf(o, i), as(i, null, null, u), os()), g = o.memoizedState, S = i.memoizedState, g.parent !== f ? (g = { parent: f, cache: f }, i.memoizedState = g, i.lanes === 0 && (i.memoizedState = i.updateQueue.baseState = g), uo(i, jt, f)) : (f = S.cache, uo(i, jt, f), f !== g.cache && cf(
          i,
          [jt],
          u,
          !0
        ))), nn(
          o,
          i,
          i.pendingProps.children,
          u
        ), i.child;
      case 29:
        throw i.pendingProps;
    }
    throw Error(r(156, i.tag));
  }
  function Hr(o) {
    o.flags |= 4;
  }
  function Qf(o, i, u, f, g) {
    if ((i = (o.mode & 32) !== 0) && (i = !1), i) {
      if (o.flags |= 16777216, (g & 335544128) === g)
        if (o.stateNode.complete) o.flags |= 8192;
        else if (tb()) o.flags |= 8192;
        else
          throw da = su, mf;
    } else o.flags &= -16777217;
  }
  function Ny(o, i) {
    if (i.type !== "stylesheet" || (i.state.loading & 4) !== 0)
      o.flags &= -16777217;
    else if (o.flags |= 16777216, !Hb(i))
      if (tb()) o.flags |= 8192;
      else
        throw da = su, mf;
  }
  function _u(o, i) {
    i !== null && (o.flags |= 4), o.flags & 16384 && (i = o.tag !== 22 ? xd() : 536870912, o.lanes |= i, ri |= i);
  }
  function ds(o, i) {
    if (!Ge)
      switch (o.tailMode) {
        case "hidden":
          i = o.tail;
          for (var u = null; i !== null; )
            i.alternate !== null && (u = i), i = i.sibling;
          u === null ? o.tail = null : u.sibling = null;
          break;
        case "collapsed":
          u = o.tail;
          for (var f = null; u !== null; )
            u.alternate !== null && (f = u), u = u.sibling;
          f === null ? i || o.tail === null ? o.tail = null : o.tail.sibling = null : f.sibling = null;
      }
  }
  function vt(o) {
    var i = o.alternate !== null && o.alternate.child === o.child, u = 0, f = 0;
    if (i)
      for (var g = o.child; g !== null; )
        u |= g.lanes | g.childLanes, f |= g.subtreeFlags & 65011712, f |= g.flags & 65011712, g.return = o, g = g.sibling;
    else
      for (g = o.child; g !== null; )
        u |= g.lanes | g.childLanes, f |= g.subtreeFlags, f |= g.flags, g.return = o, g = g.sibling;
    return o.subtreeFlags |= f, o.childLanes = u, i;
  }
  function BC(o, i, u) {
    var f = i.pendingProps;
    switch (of(i), i.tag) {
      case 16:
      case 15:
      case 0:
      case 11:
      case 7:
      case 8:
      case 12:
      case 9:
      case 14:
        return vt(i), null;
      case 1:
        return vt(i), null;
      case 3:
        return u = i.stateNode, f = null, o !== null && (f = o.memoizedState.cache), i.memoizedState.cache !== f && (i.flags |= 2048), Fr(jt), me(), u.pendingContext && (u.context = u.pendingContext, u.pendingContext = null), (o === null || o.child === null) && (Ha(i) ? Hr(i) : o === null || o.memoizedState.isDehydrated && (i.flags & 256) === 0 || (i.flags |= 1024, sf())), vt(i), null;
      case 26:
        var g = i.type, S = i.memoizedState;
        return o === null ? (Hr(i), S !== null ? (vt(i), Ny(i, S)) : (vt(i), Qf(
          i,
          g,
          null,
          f,
          u
        ))) : S ? S !== o.memoizedState ? (Hr(i), vt(i), Ny(i, S)) : (vt(i), i.flags &= -16777217) : (o = o.memoizedProps, o !== f && Hr(i), vt(i), Qf(
          i,
          g,
          o,
          f,
          u
        )), null;
      case 27:
        if (ae(i), u = re.current, g = i.type, o !== null && i.stateNode != null)
          o.memoizedProps !== f && Hr(i);
        else {
          if (!f) {
            if (i.stateNode === null)
              throw Error(r(166));
            return vt(i), null;
          }
          o = H.current, Ha(i) ? lv(i) : (o = Tb(g, f, u), i.stateNode = o, Hr(i));
        }
        return vt(i), null;
      case 5:
        if (ae(i), g = i.type, o !== null && i.stateNode != null)
          o.memoizedProps !== f && Hr(i);
        else {
          if (!f) {
            if (i.stateNode === null)
              throw Error(r(166));
            return vt(i), null;
          }
          if (S = H.current, Ha(i))
            lv(i);
          else {
            var A = zu(
              re.current
            );
            switch (S) {
              case 1:
                S = A.createElementNS(
                  "http://www.w3.org/2000/svg",
                  g
                );
                break;
              case 2:
                S = A.createElementNS(
                  "http://www.w3.org/1998/Math/MathML",
                  g
                );
                break;
              default:
                switch (g) {
                  case "svg":
                    S = A.createElementNS(
                      "http://www.w3.org/2000/svg",
                      g
                    );
                    break;
                  case "math":
                    S = A.createElementNS(
                      "http://www.w3.org/1998/Math/MathML",
                      g
                    );
                    break;
                  case "script":
                    S = A.createElement("div"), S.innerHTML = "<script><\/script>", S = S.removeChild(
                      S.firstChild
                    );
                    break;
                  case "select":
                    S = typeof f.is == "string" ? A.createElement("select", {
                      is: f.is
                    }) : A.createElement("select"), f.multiple ? S.multiple = !0 : f.size && (S.size = f.size);
                    break;
                  default:
                    S = typeof f.is == "string" ? A.createElement(g, { is: f.is }) : A.createElement(g);
                }
            }
            S[Yt] = i, S[mn] = f;
            e: for (A = i.child; A !== null; ) {
              if (A.tag === 5 || A.tag === 6)
                S.appendChild(A.stateNode);
              else if (A.tag !== 4 && A.tag !== 27 && A.child !== null) {
                A.child.return = A, A = A.child;
                continue;
              }
              if (A === i) break e;
              for (; A.sibling === null; ) {
                if (A.return === null || A.return === i)
                  break e;
                A = A.return;
              }
              A.sibling.return = A.return, A = A.sibling;
            }
            i.stateNode = S;
            e: switch (rn(S, g, f), g) {
              case "button":
              case "input":
              case "select":
              case "textarea":
                f = !!f.autoFocus;
                break e;
              case "img":
                f = !0;
                break e;
              default:
                f = !1;
            }
            f && Hr(i);
          }
        }
        return vt(i), Qf(
          i,
          i.type,
          o === null ? null : o.memoizedProps,
          i.pendingProps,
          u
        ), null;
      case 6:
        if (o && i.stateNode != null)
          o.memoizedProps !== f && Hr(i);
        else {
          if (typeof f != "string" && i.stateNode === null)
            throw Error(r(166));
          if (o = re.current, Ha(i)) {
            if (o = i.stateNode, u = i.memoizedProps, f = null, g = en, g !== null)
              switch (g.tag) {
                case 27:
                case 5:
                  f = g.memoizedProps;
              }
            o[Yt] = i, o = !!(o.nodeValue === u || f !== null && f.suppressHydrationWarning === !0 || Eb(o.nodeValue, u)), o || lo(i, !0);
          } else
            o = zu(o).createTextNode(
              f
            ), o[Yt] = i, i.stateNode = o;
        }
        return vt(i), null;
      case 31:
        if (u = i.memoizedState, o === null || o.memoizedState !== null) {
          if (f = Ha(i), u !== null) {
            if (o === null) {
              if (!f) throw Error(r(318));
              if (o = i.memoizedState, o = o !== null ? o.dehydrated : null, !o) throw Error(r(557));
              o[Yt] = i;
            } else
              ia(), (i.flags & 128) === 0 && (i.memoizedState = null), i.flags |= 4;
            vt(i), o = !1;
          } else
            u = sf(), o !== null && o.memoizedState !== null && (o.memoizedState.hydrationErrors = u), o = !0;
          if (!o)
            return i.flags & 256 ? (Fn(i), i) : (Fn(i), null);
          if ((i.flags & 128) !== 0)
            throw Error(r(558));
        }
        return vt(i), null;
      case 13:
        if (f = i.memoizedState, o === null || o.memoizedState !== null && o.memoizedState.dehydrated !== null) {
          if (g = Ha(i), f !== null && f.dehydrated !== null) {
            if (o === null) {
              if (!g) throw Error(r(318));
              if (g = i.memoizedState, g = g !== null ? g.dehydrated : null, !g) throw Error(r(317));
              g[Yt] = i;
            } else
              ia(), (i.flags & 128) === 0 && (i.memoizedState = null), i.flags |= 4;
            vt(i), g = !1;
          } else
            g = sf(), o !== null && o.memoizedState !== null && (o.memoizedState.hydrationErrors = g), g = !0;
          if (!g)
            return i.flags & 256 ? (Fn(i), i) : (Fn(i), null);
        }
        return Fn(i), (i.flags & 128) !== 0 ? (i.lanes = u, i) : (u = f !== null, o = o !== null && o.memoizedState !== null, u && (f = i.child, g = null, f.alternate !== null && f.alternate.memoizedState !== null && f.alternate.memoizedState.cachePool !== null && (g = f.alternate.memoizedState.cachePool.pool), S = null, f.memoizedState !== null && f.memoizedState.cachePool !== null && (S = f.memoizedState.cachePool.pool), S !== g && (f.flags |= 2048)), u !== o && u && (i.child.flags |= 8192), _u(i, i.updateQueue), vt(i), null);
      case 4:
        return me(), o === null && bp(i.stateNode.containerInfo), vt(i), null;
      case 10:
        return Fr(i.type), vt(i), null;
      case 19:
        if (X(Mt), f = i.memoizedState, f === null) return vt(i), null;
        if (g = (i.flags & 128) !== 0, S = f.rendering, S === null)
          if (g) ds(f, !1);
          else {
            if (St !== 0 || o !== null && (o.flags & 128) !== 0)
              for (o = i.child; o !== null; ) {
                if (S = du(o), S !== null) {
                  for (i.flags |= 128, ds(f, !1), o = S.updateQueue, i.updateQueue = o, _u(i, o), i.subtreeFlags = 0, o = u, u = i.child; u !== null; )
                    rv(u, o), u = u.sibling;
                  return U(
                    Mt,
                    Mt.current & 1 | 2
                  ), Ge && Ir(i, f.treeForkCount), i.child;
                }
                o = o.sibling;
              }
            f.tail !== null && Ce() > Nu && (i.flags |= 128, g = !0, ds(f, !1), i.lanes = 4194304);
          }
        else {
          if (!g)
            if (o = du(S), o !== null) {
              if (i.flags |= 128, g = !0, o = o.updateQueue, i.updateQueue = o, _u(i, o), ds(f, !0), f.tail === null && f.tailMode === "hidden" && !S.alternate && !Ge)
                return vt(i), null;
            } else
              2 * Ce() - f.renderingStartTime > Nu && u !== 536870912 && (i.flags |= 128, g = !0, ds(f, !1), i.lanes = 4194304);
          f.isBackwards ? (S.sibling = i.child, i.child = S) : (o = f.last, o !== null ? o.sibling = S : i.child = S, f.last = S);
        }
        return f.tail !== null ? (o = f.tail, f.rendering = o, f.tail = o.sibling, f.renderingStartTime = Ce(), o.sibling = null, u = Mt.current, U(
          Mt,
          g ? u & 1 | 2 : u & 1
        ), Ge && Ir(i, f.treeForkCount), o) : (vt(i), null);
      case 22:
      case 23:
        return Fn(i), wf(), f = i.memoizedState !== null, o !== null ? o.memoizedState !== null !== f && (i.flags |= 8192) : f && (i.flags |= 8192), f ? (u & 536870912) !== 0 && (i.flags & 128) === 0 && (vt(i), i.subtreeFlags & 6 && (i.flags |= 8192)) : vt(i), u = i.updateQueue, u !== null && _u(i, u.retryQueue), u = null, o !== null && o.memoizedState !== null && o.memoizedState.cachePool !== null && (u = o.memoizedState.cachePool.pool), f = null, i.memoizedState !== null && i.memoizedState.cachePool !== null && (f = i.memoizedState.cachePool.pool), f !== u && (i.flags |= 2048), o !== null && X(ua), null;
      case 24:
        return u = null, o !== null && (u = o.memoizedState.cache), i.memoizedState.cache !== u && (i.flags |= 2048), Fr(jt), vt(i), null;
      case 25:
        return null;
      case 30:
        return null;
    }
    throw Error(r(156, i.tag));
  }
  function UC(o, i) {
    switch (of(i), i.tag) {
      case 1:
        return o = i.flags, o & 65536 ? (i.flags = o & -65537 | 128, i) : null;
      case 3:
        return Fr(jt), me(), o = i.flags, (o & 65536) !== 0 && (o & 128) === 0 ? (i.flags = o & -65537 | 128, i) : null;
      case 26:
      case 27:
      case 5:
        return ae(i), null;
      case 31:
        if (i.memoizedState !== null) {
          if (Fn(i), i.alternate === null)
            throw Error(r(340));
          ia();
        }
        return o = i.flags, o & 65536 ? (i.flags = o & -65537 | 128, i) : null;
      case 13:
        if (Fn(i), o = i.memoizedState, o !== null && o.dehydrated !== null) {
          if (i.alternate === null)
            throw Error(r(340));
          ia();
        }
        return o = i.flags, o & 65536 ? (i.flags = o & -65537 | 128, i) : null;
      case 19:
        return X(Mt), null;
      case 4:
        return me(), null;
      case 10:
        return Fr(i.type), null;
      case 22:
      case 23:
        return Fn(i), wf(), o !== null && X(ua), o = i.flags, o & 65536 ? (i.flags = o & -65537 | 128, i) : null;
      case 24:
        return Fr(jt), null;
      case 25:
        return null;
      default:
        return null;
    }
  }
  function Ry(o, i) {
    switch (of(i), i.tag) {
      case 3:
        Fr(jt), me();
        break;
      case 26:
      case 27:
      case 5:
        ae(i);
        break;
      case 4:
        me();
        break;
      case 31:
        i.memoizedState !== null && Fn(i);
        break;
      case 13:
        Fn(i);
        break;
      case 19:
        X(Mt);
        break;
      case 10:
        Fr(i.type);
        break;
      case 22:
      case 23:
        Fn(i), wf(), o !== null && X(ua);
        break;
      case 24:
        Fr(jt);
    }
  }
  function fs(o, i) {
    try {
      var u = i.updateQueue, f = u !== null ? u.lastEffect : null;
      if (f !== null) {
        var g = f.next;
        u = g;
        do {
          if ((u.tag & o) === o) {
            f = void 0;
            var S = u.create, A = u.inst;
            f = S(), A.destroy = f;
          }
          u = u.next;
        } while (u !== g);
      }
    } catch (T) {
      rt(i, i.return, T);
    }
  }
  function go(o, i, u) {
    try {
      var f = i.updateQueue, g = f !== null ? f.lastEffect : null;
      if (g !== null) {
        var S = g.next;
        f = S;
        do {
          if ((f.tag & o) === o) {
            var A = f.inst, T = A.destroy;
            if (T !== void 0) {
              A.destroy = void 0, g = i;
              var Y = u, ne = T;
              try {
                ne();
              } catch (ue) {
                rt(
                  g,
                  Y,
                  ue
                );
              }
            }
          }
          f = f.next;
        } while (f !== S);
      }
    } catch (ue) {
      rt(i, i.return, ue);
    }
  }
  function Ay(o) {
    var i = o.updateQueue;
    if (i !== null) {
      var u = o.stateNode;
      try {
        xv(i, u);
      } catch (f) {
        rt(o, o.return, f);
      }
    }
  }
  function jy(o, i, u) {
    u.props = ma(
      o.type,
      o.memoizedProps
    ), u.state = o.memoizedState;
    try {
      u.componentWillUnmount();
    } catch (f) {
      rt(o, i, f);
    }
  }
  function ps(o, i) {
    try {
      var u = o.ref;
      if (u !== null) {
        switch (o.tag) {
          case 26:
          case 27:
          case 5:
            var f = o.stateNode;
            break;
          case 30:
            f = o.stateNode;
            break;
          default:
            f = o.stateNode;
        }
        typeof u == "function" ? o.refCleanup = u(f) : u.current = f;
      }
    } catch (g) {
      rt(o, i, g);
    }
  }
  function _r(o, i) {
    var u = o.ref, f = o.refCleanup;
    if (u !== null)
      if (typeof f == "function")
        try {
          f();
        } catch (g) {
          rt(o, i, g);
        } finally {
          o.refCleanup = null, o = o.alternate, o != null && (o.refCleanup = null);
        }
      else if (typeof u == "function")
        try {
          u(null);
        } catch (g) {
          rt(o, i, g);
        }
      else u.current = null;
  }
  function Py(o) {
    var i = o.type, u = o.memoizedProps, f = o.stateNode;
    try {
      e: switch (i) {
        case "button":
        case "input":
        case "select":
        case "textarea":
          u.autoFocus && f.focus();
          break e;
        case "img":
          u.src ? f.src = u.src : u.srcSet && (f.srcset = u.srcSet);
      }
    } catch (g) {
      rt(o, o.return, g);
    }
  }
  function Jf(o, i, u) {
    try {
      var f = o.stateNode;
      cO(f, o.type, u, i), f[mn] = i;
    } catch (g) {
      rt(o, o.return, g);
    }
  }
  function Dy(o) {
    return o.tag === 5 || o.tag === 3 || o.tag === 26 || o.tag === 27 && ko(o.type) || o.tag === 4;
  }
  function Zf(o) {
    e: for (; ; ) {
      for (; o.sibling === null; ) {
        if (o.return === null || Dy(o.return)) return null;
        o = o.return;
      }
      for (o.sibling.return = o.return, o = o.sibling; o.tag !== 5 && o.tag !== 6 && o.tag !== 18; ) {
        if (o.tag === 27 && ko(o.type) || o.flags & 2 || o.child === null || o.tag === 4) continue e;
        o.child.return = o, o = o.child;
      }
      if (!(o.flags & 2)) return o.stateNode;
    }
  }
  function ep(o, i, u) {
    var f = o.tag;
    if (f === 5 || f === 6)
      o = o.stateNode, i ? (u.nodeType === 9 ? u.body : u.nodeName === "HTML" ? u.ownerDocument.body : u).insertBefore(o, i) : (i = u.nodeType === 9 ? u.body : u.nodeName === "HTML" ? u.ownerDocument.body : u, i.appendChild(o), u = u._reactRootContainer, u != null || i.onclick !== null || (i.onclick = $r));
    else if (f !== 4 && (f === 27 && ko(o.type) && (u = o.stateNode, i = null), o = o.child, o !== null))
      for (ep(o, i, u), o = o.sibling; o !== null; )
        ep(o, i, u), o = o.sibling;
  }
  function Eu(o, i, u) {
    var f = o.tag;
    if (f === 5 || f === 6)
      o = o.stateNode, i ? u.insertBefore(o, i) : u.appendChild(o);
    else if (f !== 4 && (f === 27 && ko(o.type) && (u = o.stateNode), o = o.child, o !== null))
      for (Eu(o, i, u), o = o.sibling; o !== null; )
        Eu(o, i, u), o = o.sibling;
  }
  function $y(o) {
    var i = o.stateNode, u = o.memoizedProps;
    try {
      for (var f = o.type, g = i.attributes; g.length; )
        i.removeAttributeNode(g[0]);
      rn(i, f, u), i[Yt] = o, i[mn] = u;
    } catch (S) {
      rt(o, o.return, S);
    }
  }
  var qr = !1, $t = !1, tp = !1, Ty = typeof WeakSet == "function" ? WeakSet : Set, Qt = null;
  function VC(o, i) {
    if (o = o.containerInfo, Sp = Wu, o = Kg(o), Gd(o)) {
      if ("selectionStart" in o)
        var u = {
          start: o.selectionStart,
          end: o.selectionEnd
        };
      else
        e: {
          u = (u = o.ownerDocument) && u.defaultView || window;
          var f = u.getSelection && u.getSelection();
          if (f && f.rangeCount !== 0) {
            u = f.anchorNode;
            var g = f.anchorOffset, S = f.focusNode;
            f = f.focusOffset;
            try {
              u.nodeType, S.nodeType;
            } catch {
              u = null;
              break e;
            }
            var A = 0, T = -1, Y = -1, ne = 0, ue = 0, fe = o, oe = null;
            t: for (; ; ) {
              for (var ie; fe !== u || g !== 0 && fe.nodeType !== 3 || (T = A + g), fe !== S || f !== 0 && fe.nodeType !== 3 || (Y = A + f), fe.nodeType === 3 && (A += fe.nodeValue.length), (ie = fe.firstChild) !== null; )
                oe = fe, fe = ie;
              for (; ; ) {
                if (fe === o) break t;
                if (oe === u && ++ne === g && (T = A), oe === S && ++ue === f && (Y = A), (ie = fe.nextSibling) !== null) break;
                fe = oe, oe = fe.parentNode;
              }
              fe = ie;
            }
            u = T === -1 || Y === -1 ? null : { start: T, end: Y };
          } else u = null;
        }
      u = u || { start: 0, end: 0 };
    } else u = null;
    for (kp = { focusedElem: o, selectionRange: u }, Wu = !1, Qt = i; Qt !== null; )
      if (i = Qt, o = i.child, (i.subtreeFlags & 1028) !== 0 && o !== null)
        o.return = i, Qt = o;
      else
        for (; Qt !== null; ) {
          switch (i = Qt, S = i.alternate, o = i.flags, i.tag) {
            case 0:
              if ((o & 4) !== 0 && (o = i.updateQueue, o = o !== null ? o.events : null, o !== null))
                for (u = 0; u < o.length; u++)
                  g = o[u], g.ref.impl = g.nextImpl;
              break;
            case 11:
            case 15:
              break;
            case 1:
              if ((o & 1024) !== 0 && S !== null) {
                o = void 0, u = i, g = S.memoizedProps, S = S.memoizedState, f = u.stateNode;
                try {
                  var we = ma(
                    u.type,
                    g
                  );
                  o = f.getSnapshotBeforeUpdate(
                    we,
                    S
                  ), f.__reactInternalSnapshotBeforeUpdate = o;
                } catch (Ne) {
                  rt(
                    u,
                    u.return,
                    Ne
                  );
                }
              }
              break;
            case 3:
              if ((o & 1024) !== 0) {
                if (o = i.stateNode.containerInfo, u = o.nodeType, u === 9)
                  Cp(o);
                else if (u === 1)
                  switch (o.nodeName) {
                    case "HEAD":
                    case "HTML":
                    case "BODY":
                      Cp(o);
                      break;
                    default:
                      o.textContent = "";
                  }
              }
              break;
            case 5:
            case 26:
            case 27:
            case 6:
            case 4:
            case 17:
              break;
            default:
              if ((o & 1024) !== 0) throw Error(r(163));
          }
          if (o = i.sibling, o !== null) {
            o.return = i.return, Qt = o;
            break;
          }
          Qt = i.return;
        }
  }
  function Ly(o, i, u) {
    var f = u.flags;
    switch (u.tag) {
      case 0:
      case 11:
      case 15:
        Gr(o, u), f & 4 && fs(5, u);
        break;
      case 1:
        if (Gr(o, u), f & 4)
          if (o = u.stateNode, i === null)
            try {
              o.componentDidMount();
            } catch (A) {
              rt(u, u.return, A);
            }
          else {
            var g = ma(
              u.type,
              i.memoizedProps
            );
            i = i.memoizedState;
            try {
              o.componentDidUpdate(
                g,
                i,
                o.__reactInternalSnapshotBeforeUpdate
              );
            } catch (A) {
              rt(
                u,
                u.return,
                A
              );
            }
          }
        f & 64 && Ay(u), f & 512 && ps(u, u.return);
        break;
      case 3:
        if (Gr(o, u), f & 64 && (o = u.updateQueue, o !== null)) {
          if (i = null, u.child !== null)
            switch (u.child.tag) {
              case 27:
              case 5:
                i = u.child.stateNode;
                break;
              case 1:
                i = u.child.stateNode;
            }
          try {
            xv(o, i);
          } catch (A) {
            rt(u, u.return, A);
          }
        }
        break;
      case 27:
        i === null && f & 4 && $y(u);
      case 26:
      case 5:
        Gr(o, u), i === null && f & 4 && Py(u), f & 512 && ps(u, u.return);
        break;
      case 12:
        Gr(o, u);
        break;
      case 31:
        Gr(o, u), f & 4 && Fy(o, u);
        break;
      case 13:
        Gr(o, u), f & 4 && By(o, u), f & 64 && (o = u.memoizedState, o !== null && (o = o.dehydrated, o !== null && (u = JC.bind(
          null,
          u
        ), yO(o, u))));
        break;
      case 22:
        if (f = u.memoizedState !== null || qr, !f) {
          i = i !== null && i.memoizedState !== null || $t, g = qr;
          var S = $t;
          qr = f, ($t = i) && !S ? Kr(
            o,
            u,
            (u.subtreeFlags & 8772) !== 0
          ) : Gr(o, u), qr = g, $t = S;
        }
        break;
      case 30:
        break;
      default:
        Gr(o, u);
    }
  }
  function Iy(o) {
    var i = o.alternate;
    i !== null && (o.alternate = null, Iy(i)), o.child = null, o.deletions = null, o.sibling = null, o.tag === 5 && (i = o.stateNode, i !== null && Ul(i)), o.stateNode = null, o.return = null, o.dependencies = null, o.memoizedProps = null, o.memoizedState = null, o.pendingProps = null, o.stateNode = null, o.updateQueue = null;
  }
  var yt = null, En = !1;
  function Wr(o, i, u) {
    for (u = u.child; u !== null; )
      zy(o, i, u), u = u.sibling;
  }
  function zy(o, i, u) {
    if (Ot && typeof Ot.onCommitFiberUnmount == "function")
      try {
        Ot.onCommitFiberUnmount(Wt, u);
      } catch {
      }
    switch (u.tag) {
      case 26:
        $t || _r(u, i), Wr(
          o,
          i,
          u
        ), u.memoizedState ? u.memoizedState.count-- : u.stateNode && (u = u.stateNode, u.parentNode.removeChild(u));
        break;
      case 27:
        $t || _r(u, i);
        var f = yt, g = En;
        ko(u.type) && (yt = u.stateNode, En = !1), Wr(
          o,
          i,
          u
        ), Ss(u.stateNode), yt = f, En = g;
        break;
      case 5:
        $t || _r(u, i);
      case 6:
        if (f = yt, g = En, yt = null, Wr(
          o,
          i,
          u
        ), yt = f, En = g, yt !== null)
          if (En)
            try {
              (yt.nodeType === 9 ? yt.body : yt.nodeName === "HTML" ? yt.ownerDocument.body : yt).removeChild(u.stateNode);
            } catch (S) {
              rt(
                u,
                i,
                S
              );
            }
          else
            try {
              yt.removeChild(u.stateNode);
            } catch (S) {
              rt(
                u,
                i,
                S
              );
            }
        break;
      case 18:
        yt !== null && (En ? (o = yt, Ab(
          o.nodeType === 9 ? o.body : o.nodeName === "HTML" ? o.ownerDocument.body : o,
          u.stateNode
        ), di(o)) : Ab(yt, u.stateNode));
        break;
      case 4:
        f = yt, g = En, yt = u.stateNode.containerInfo, En = !0, Wr(
          o,
          i,
          u
        ), yt = f, En = g;
        break;
      case 0:
      case 11:
      case 14:
      case 15:
        go(2, u, i), $t || go(4, u, i), Wr(
          o,
          i,
          u
        );
        break;
      case 1:
        $t || (_r(u, i), f = u.stateNode, typeof f.componentWillUnmount == "function" && jy(
          u,
          i,
          f
        )), Wr(
          o,
          i,
          u
        );
        break;
      case 21:
        Wr(
          o,
          i,
          u
        );
        break;
      case 22:
        $t = (f = $t) || u.memoizedState !== null, Wr(
          o,
          i,
          u
        ), $t = f;
        break;
      default:
        Wr(
          o,
          i,
          u
        );
    }
  }
  function Fy(o, i) {
    if (i.memoizedState === null && (o = i.alternate, o !== null && (o = o.memoizedState, o !== null))) {
      o = o.dehydrated;
      try {
        di(o);
      } catch (u) {
        rt(i, i.return, u);
      }
    }
  }
  function By(o, i) {
    if (i.memoizedState === null && (o = i.alternate, o !== null && (o = o.memoizedState, o !== null && (o = o.dehydrated, o !== null))))
      try {
        di(o);
      } catch (u) {
        rt(i, i.return, u);
      }
  }
  function HC(o) {
    switch (o.tag) {
      case 31:
      case 13:
      case 19:
        var i = o.stateNode;
        return i === null && (i = o.stateNode = new Ty()), i;
      case 22:
        return o = o.stateNode, i = o._retryCache, i === null && (i = o._retryCache = new Ty()), i;
      default:
        throw Error(r(435, o.tag));
    }
  }
  function Cu(o, i) {
    var u = HC(o);
    i.forEach(function(f) {
      if (!u.has(f)) {
        u.add(f);
        var g = ZC.bind(null, o, f);
        f.then(g, g);
      }
    });
  }
  function Cn(o, i) {
    var u = i.deletions;
    if (u !== null)
      for (var f = 0; f < u.length; f++) {
        var g = u[f], S = o, A = i, T = A;
        e: for (; T !== null; ) {
          switch (T.tag) {
            case 27:
              if (ko(T.type)) {
                yt = T.stateNode, En = !1;
                break e;
              }
              break;
            case 5:
              yt = T.stateNode, En = !1;
              break e;
            case 3:
            case 4:
              yt = T.stateNode.containerInfo, En = !0;
              break e;
          }
          T = T.return;
        }
        if (yt === null) throw Error(r(160));
        zy(S, A, g), yt = null, En = !1, S = g.alternate, S !== null && (S.return = null), g.return = null;
      }
    if (i.subtreeFlags & 13886)
      for (i = i.child; i !== null; )
        Uy(i, o), i = i.sibling;
  }
  var hr = null;
  function Uy(o, i) {
    var u = o.alternate, f = o.flags;
    switch (o.tag) {
      case 0:
      case 11:
      case 14:
      case 15:
        Cn(i, o), On(o), f & 4 && (go(3, o, o.return), fs(3, o), go(5, o, o.return));
        break;
      case 1:
        Cn(i, o), On(o), f & 512 && ($t || u === null || _r(u, u.return)), f & 64 && qr && (o = o.updateQueue, o !== null && (f = o.callbacks, f !== null && (u = o.shared.hiddenCallbacks, o.shared.hiddenCallbacks = u === null ? f : u.concat(f))));
        break;
      case 26:
        var g = hr;
        if (Cn(i, o), On(o), f & 512 && ($t || u === null || _r(u, u.return)), f & 4) {
          var S = u !== null ? u.memoizedState : null;
          if (f = o.memoizedState, u === null)
            if (f === null)
              if (o.stateNode === null) {
                e: {
                  f = o.type, u = o.memoizedProps, g = g.ownerDocument || g;
                  t: switch (f) {
                    case "title":
                      S = g.getElementsByTagName("title")[0], (!S || S[Pa] || S[Yt] || S.namespaceURI === "http://www.w3.org/2000/svg" || S.hasAttribute("itemprop")) && (S = g.createElement(f), g.head.insertBefore(
                        S,
                        g.querySelector("head > title")
                      )), rn(S, f, u), S[Yt] = o, Bt(S), f = S;
                      break e;
                    case "link":
                      var A = Ub(
                        "link",
                        "href",
                        g
                      ).get(f + (u.href || ""));
                      if (A) {
                        for (var T = 0; T < A.length; T++)
                          if (S = A[T], S.getAttribute("href") === (u.href == null || u.href === "" ? null : u.href) && S.getAttribute("rel") === (u.rel == null ? null : u.rel) && S.getAttribute("title") === (u.title == null ? null : u.title) && S.getAttribute("crossorigin") === (u.crossOrigin == null ? null : u.crossOrigin)) {
                            A.splice(T, 1);
                            break t;
                          }
                      }
                      S = g.createElement(f), rn(S, f, u), g.head.appendChild(S);
                      break;
                    case "meta":
                      if (A = Ub(
                        "meta",
                        "content",
                        g
                      ).get(f + (u.content || ""))) {
                        for (T = 0; T < A.length; T++)
                          if (S = A[T], S.getAttribute("content") === (u.content == null ? null : "" + u.content) && S.getAttribute("name") === (u.name == null ? null : u.name) && S.getAttribute("property") === (u.property == null ? null : u.property) && S.getAttribute("http-equiv") === (u.httpEquiv == null ? null : u.httpEquiv) && S.getAttribute("charset") === (u.charSet == null ? null : u.charSet)) {
                            A.splice(T, 1);
                            break t;
                          }
                      }
                      S = g.createElement(f), rn(S, f, u), g.head.appendChild(S);
                      break;
                    default:
                      throw Error(r(468, f));
                  }
                  S[Yt] = o, Bt(S), f = S;
                }
                o.stateNode = f;
              } else
                Vb(
                  g,
                  o.type,
                  o.stateNode
                );
            else
              o.stateNode = Bb(
                g,
                f,
                o.memoizedProps
              );
          else
            S !== f ? (S === null ? u.stateNode !== null && (u = u.stateNode, u.parentNode.removeChild(u)) : S.count--, f === null ? Vb(
              g,
              o.type,
              o.stateNode
            ) : Bb(
              g,
              f,
              o.memoizedProps
            )) : f === null && o.stateNode !== null && Jf(
              o,
              o.memoizedProps,
              u.memoizedProps
            );
        }
        break;
      case 27:
        Cn(i, o), On(o), f & 512 && ($t || u === null || _r(u, u.return)), u !== null && f & 4 && Jf(
          o,
          o.memoizedProps,
          u.memoizedProps
        );
        break;
      case 5:
        if (Cn(i, o), On(o), f & 512 && ($t || u === null || _r(u, u.return)), o.flags & 32) {
          g = o.stateNode;
          try {
            Da(g, "");
          } catch (we) {
            rt(o, o.return, we);
          }
        }
        f & 4 && o.stateNode != null && (g = o.memoizedProps, Jf(
          o,
          g,
          u !== null ? u.memoizedProps : g
        )), f & 1024 && (tp = !0);
        break;
      case 6:
        if (Cn(i, o), On(o), f & 4) {
          if (o.stateNode === null)
            throw Error(r(162));
          f = o.memoizedProps, u = o.stateNode;
          try {
            u.nodeValue = f;
          } catch (we) {
            rt(o, o.return, we);
          }
        }
        break;
      case 3:
        if (Uu = null, g = hr, hr = Fu(i.containerInfo), Cn(i, o), hr = g, On(o), f & 4 && u !== null && u.memoizedState.isDehydrated)
          try {
            di(i.containerInfo);
          } catch (we) {
            rt(o, o.return, we);
          }
        tp && (tp = !1, Vy(o));
        break;
      case 4:
        f = hr, hr = Fu(
          o.stateNode.containerInfo
        ), Cn(i, o), On(o), hr = f;
        break;
      case 12:
        Cn(i, o), On(o);
        break;
      case 31:
        Cn(i, o), On(o), f & 4 && (f = o.updateQueue, f !== null && (o.updateQueue = null, Cu(o, f)));
        break;
      case 13:
        Cn(i, o), On(o), o.child.flags & 8192 && o.memoizedState !== null != (u !== null && u.memoizedState !== null) && (Mu = Ce()), f & 4 && (f = o.updateQueue, f !== null && (o.updateQueue = null, Cu(o, f)));
        break;
      case 22:
        g = o.memoizedState !== null;
        var Y = u !== null && u.memoizedState !== null, ne = qr, ue = $t;
        if (qr = ne || g, $t = ue || Y, Cn(i, o), $t = ue, qr = ne, On(o), f & 8192)
          e: for (i = o.stateNode, i._visibility = g ? i._visibility & -2 : i._visibility | 1, g && (u === null || Y || qr || $t || ha(o)), u = null, i = o; ; ) {
            if (i.tag === 5 || i.tag === 26) {
              if (u === null) {
                Y = u = i;
                try {
                  if (S = Y.stateNode, g)
                    A = S.style, typeof A.setProperty == "function" ? A.setProperty("display", "none", "important") : A.display = "none";
                  else {
                    T = Y.stateNode;
                    var fe = Y.memoizedProps.style, oe = fe != null && fe.hasOwnProperty("display") ? fe.display : null;
                    T.style.display = oe == null || typeof oe == "boolean" ? "" : ("" + oe).trim();
                  }
                } catch (we) {
                  rt(Y, Y.return, we);
                }
              }
            } else if (i.tag === 6) {
              if (u === null) {
                Y = i;
                try {
                  Y.stateNode.nodeValue = g ? "" : Y.memoizedProps;
                } catch (we) {
                  rt(Y, Y.return, we);
                }
              }
            } else if (i.tag === 18) {
              if (u === null) {
                Y = i;
                try {
                  var ie = Y.stateNode;
                  g ? jb(ie, !0) : jb(Y.stateNode, !1);
                } catch (we) {
                  rt(Y, Y.return, we);
                }
              }
            } else if ((i.tag !== 22 && i.tag !== 23 || i.memoizedState === null || i === o) && i.child !== null) {
              i.child.return = i, i = i.child;
              continue;
            }
            if (i === o) break e;
            for (; i.sibling === null; ) {
              if (i.return === null || i.return === o) break e;
              u === i && (u = null), i = i.return;
            }
            u === i && (u = null), i.sibling.return = i.return, i = i.sibling;
          }
        f & 4 && (f = o.updateQueue, f !== null && (u = f.retryQueue, u !== null && (f.retryQueue = null, Cu(o, u))));
        break;
      case 19:
        Cn(i, o), On(o), f & 4 && (f = o.updateQueue, f !== null && (o.updateQueue = null, Cu(o, f)));
        break;
      case 30:
        break;
      case 21:
        break;
      default:
        Cn(i, o), On(o);
    }
  }
  function On(o) {
    var i = o.flags;
    if (i & 2) {
      try {
        for (var u, f = o.return; f !== null; ) {
          if (Dy(f)) {
            u = f;
            break;
          }
          f = f.return;
        }
        if (u == null) throw Error(r(160));
        switch (u.tag) {
          case 27:
            var g = u.stateNode, S = Zf(o);
            Eu(o, S, g);
            break;
          case 5:
            var A = u.stateNode;
            u.flags & 32 && (Da(A, ""), u.flags &= -33);
            var T = Zf(o);
            Eu(o, T, A);
            break;
          case 3:
          case 4:
            var Y = u.stateNode.containerInfo, ne = Zf(o);
            ep(
              o,
              ne,
              Y
            );
            break;
          default:
            throw Error(r(161));
        }
      } catch (ue) {
        rt(o, o.return, ue);
      }
      o.flags &= -3;
    }
    i & 4096 && (o.flags &= -4097);
  }
  function Vy(o) {
    if (o.subtreeFlags & 1024)
      for (o = o.child; o !== null; ) {
        var i = o;
        Vy(i), i.tag === 5 && i.flags & 1024 && i.stateNode.reset(), o = o.sibling;
      }
  }
  function Gr(o, i) {
    if (i.subtreeFlags & 8772)
      for (i = i.child; i !== null; )
        Ly(o, i.alternate, i), i = i.sibling;
  }
  function ha(o) {
    for (o = o.child; o !== null; ) {
      var i = o;
      switch (i.tag) {
        case 0:
        case 11:
        case 14:
        case 15:
          go(4, i, i.return), ha(i);
          break;
        case 1:
          _r(i, i.return);
          var u = i.stateNode;
          typeof u.componentWillUnmount == "function" && jy(
            i,
            i.return,
            u
          ), ha(i);
          break;
        case 27:
          Ss(i.stateNode);
        case 26:
        case 5:
          _r(i, i.return), ha(i);
          break;
        case 22:
          i.memoizedState === null && ha(i);
          break;
        case 30:
          ha(i);
          break;
        default:
          ha(i);
      }
      o = o.sibling;
    }
  }
  function Kr(o, i, u) {
    for (u = u && (i.subtreeFlags & 8772) !== 0, i = i.child; i !== null; ) {
      var f = i.alternate, g = o, S = i, A = S.flags;
      switch (S.tag) {
        case 0:
        case 11:
        case 15:
          Kr(
            g,
            S,
            u
          ), fs(4, S);
          break;
        case 1:
          if (Kr(
            g,
            S,
            u
          ), f = S, g = f.stateNode, typeof g.componentDidMount == "function")
            try {
              g.componentDidMount();
            } catch (ne) {
              rt(f, f.return, ne);
            }
          if (f = S, g = f.updateQueue, g !== null) {
            var T = f.stateNode;
            try {
              var Y = g.shared.hiddenCallbacks;
              if (Y !== null)
                for (g.shared.hiddenCallbacks = null, g = 0; g < Y.length; g++)
                  wv(Y[g], T);
            } catch (ne) {
              rt(f, f.return, ne);
            }
          }
          u && A & 64 && Ay(S), ps(S, S.return);
          break;
        case 27:
          $y(S);
        case 26:
        case 5:
          Kr(
            g,
            S,
            u
          ), u && f === null && A & 4 && Py(S), ps(S, S.return);
          break;
        case 12:
          Kr(
            g,
            S,
            u
          );
          break;
        case 31:
          Kr(
            g,
            S,
            u
          ), u && A & 4 && Fy(g, S);
          break;
        case 13:
          Kr(
            g,
            S,
            u
          ), u && A & 4 && By(g, S);
          break;
        case 22:
          S.memoizedState === null && Kr(
            g,
            S,
            u
          ), ps(S, S.return);
          break;
        case 30:
          break;
        default:
          Kr(
            g,
            S,
            u
          );
      }
      i = i.sibling;
    }
  }
  function np(o, i) {
    var u = null;
    o !== null && o.memoizedState !== null && o.memoizedState.cachePool !== null && (u = o.memoizedState.cachePool.pool), o = null, i.memoizedState !== null && i.memoizedState.cachePool !== null && (o = i.memoizedState.cachePool.pool), o !== u && (o != null && o.refCount++, u != null && Zi(u));
  }
  function rp(o, i) {
    o = null, i.alternate !== null && (o = i.alternate.memoizedState.cache), i = i.memoizedState.cache, i !== o && (i.refCount++, o != null && Zi(o));
  }
  function gr(o, i, u, f) {
    if (i.subtreeFlags & 10256)
      for (i = i.child; i !== null; )
        Hy(
          o,
          i,
          u,
          f
        ), i = i.sibling;
  }
  function Hy(o, i, u, f) {
    var g = i.flags;
    switch (i.tag) {
      case 0:
      case 11:
      case 15:
        gr(
          o,
          i,
          u,
          f
        ), g & 2048 && fs(9, i);
        break;
      case 1:
        gr(
          o,
          i,
          u,
          f
        );
        break;
      case 3:
        gr(
          o,
          i,
          u,
          f
        ), g & 2048 && (o = null, i.alternate !== null && (o = i.alternate.memoizedState.cache), i = i.memoizedState.cache, i !== o && (i.refCount++, o != null && Zi(o)));
        break;
      case 12:
        if (g & 2048) {
          gr(
            o,
            i,
            u,
            f
          ), o = i.stateNode;
          try {
            var S = i.memoizedProps, A = S.id, T = S.onPostCommit;
            typeof T == "function" && T(
              A,
              i.alternate === null ? "mount" : "update",
              o.passiveEffectDuration,
              -0
            );
          } catch (Y) {
            rt(i, i.return, Y);
          }
        } else
          gr(
            o,
            i,
            u,
            f
          );
        break;
      case 31:
        gr(
          o,
          i,
          u,
          f
        );
        break;
      case 13:
        gr(
          o,
          i,
          u,
          f
        );
        break;
      case 23:
        break;
      case 22:
        S = i.stateNode, A = i.alternate, i.memoizedState !== null ? S._visibility & 2 ? gr(
          o,
          i,
          u,
          f
        ) : ms(o, i) : S._visibility & 2 ? gr(
          o,
          i,
          u,
          f
        ) : (S._visibility |= 2, ei(
          o,
          i,
          u,
          f,
          (i.subtreeFlags & 10256) !== 0 || !1
        )), g & 2048 && np(A, i);
        break;
      case 24:
        gr(
          o,
          i,
          u,
          f
        ), g & 2048 && rp(i.alternate, i);
        break;
      default:
        gr(
          o,
          i,
          u,
          f
        );
    }
  }
  function ei(o, i, u, f, g) {
    for (g = g && ((i.subtreeFlags & 10256) !== 0 || !1), i = i.child; i !== null; ) {
      var S = o, A = i, T = u, Y = f, ne = A.flags;
      switch (A.tag) {
        case 0:
        case 11:
        case 15:
          ei(
            S,
            A,
            T,
            Y,
            g
          ), fs(8, A);
          break;
        case 23:
          break;
        case 22:
          var ue = A.stateNode;
          A.memoizedState !== null ? ue._visibility & 2 ? ei(
            S,
            A,
            T,
            Y,
            g
          ) : ms(
            S,
            A
          ) : (ue._visibility |= 2, ei(
            S,
            A,
            T,
            Y,
            g
          )), g && ne & 2048 && np(
            A.alternate,
            A
          );
          break;
        case 24:
          ei(
            S,
            A,
            T,
            Y,
            g
          ), g && ne & 2048 && rp(A.alternate, A);
          break;
        default:
          ei(
            S,
            A,
            T,
            Y,
            g
          );
      }
      i = i.sibling;
    }
  }
  function ms(o, i) {
    if (i.subtreeFlags & 10256)
      for (i = i.child; i !== null; ) {
        var u = o, f = i, g = f.flags;
        switch (f.tag) {
          case 22:
            ms(u, f), g & 2048 && np(
              f.alternate,
              f
            );
            break;
          case 24:
            ms(u, f), g & 2048 && rp(f.alternate, f);
            break;
          default:
            ms(u, f);
        }
        i = i.sibling;
      }
  }
  var hs = 8192;
  function ti(o, i, u) {
    if (o.subtreeFlags & hs)
      for (o = o.child; o !== null; )
        qy(
          o,
          i,
          u
        ), o = o.sibling;
  }
  function qy(o, i, u) {
    switch (o.tag) {
      case 26:
        ti(
          o,
          i,
          u
        ), o.flags & hs && o.memoizedState !== null && RO(
          u,
          hr,
          o.memoizedState,
          o.memoizedProps
        );
        break;
      case 5:
        ti(
          o,
          i,
          u
        );
        break;
      case 3:
      case 4:
        var f = hr;
        hr = Fu(o.stateNode.containerInfo), ti(
          o,
          i,
          u
        ), hr = f;
        break;
      case 22:
        o.memoizedState === null && (f = o.alternate, f !== null && f.memoizedState !== null ? (f = hs, hs = 16777216, ti(
          o,
          i,
          u
        ), hs = f) : ti(
          o,
          i,
          u
        ));
        break;
      default:
        ti(
          o,
          i,
          u
        );
    }
  }
  function Wy(o) {
    var i = o.alternate;
    if (i !== null && (o = i.child, o !== null)) {
      i.child = null;
      do
        i = o.sibling, o.sibling = null, o = i;
      while (o !== null);
    }
  }
  function gs(o) {
    var i = o.deletions;
    if ((o.flags & 16) !== 0) {
      if (i !== null)
        for (var u = 0; u < i.length; u++) {
          var f = i[u];
          Qt = f, Ky(
            f,
            o
          );
        }
      Wy(o);
    }
    if (o.subtreeFlags & 10256)
      for (o = o.child; o !== null; )
        Gy(o), o = o.sibling;
  }
  function Gy(o) {
    switch (o.tag) {
      case 0:
      case 11:
      case 15:
        gs(o), o.flags & 2048 && go(9, o, o.return);
        break;
      case 3:
        gs(o);
        break;
      case 12:
        gs(o);
        break;
      case 22:
        var i = o.stateNode;
        o.memoizedState !== null && i._visibility & 2 && (o.return === null || o.return.tag !== 13) ? (i._visibility &= -3, Ou(o)) : gs(o);
        break;
      default:
        gs(o);
    }
  }
  function Ou(o) {
    var i = o.deletions;
    if ((o.flags & 16) !== 0) {
      if (i !== null)
        for (var u = 0; u < i.length; u++) {
          var f = i[u];
          Qt = f, Ky(
            f,
            o
          );
        }
      Wy(o);
    }
    for (o = o.child; o !== null; ) {
      switch (i = o, i.tag) {
        case 0:
        case 11:
        case 15:
          go(8, i, i.return), Ou(i);
          break;
        case 22:
          u = i.stateNode, u._visibility & 2 && (u._visibility &= -3, Ou(i));
          break;
        default:
          Ou(i);
      }
      o = o.sibling;
    }
  }
  function Ky(o, i) {
    for (; Qt !== null; ) {
      var u = Qt;
      switch (u.tag) {
        case 0:
        case 11:
        case 15:
          go(8, u, i);
          break;
        case 23:
        case 22:
          if (u.memoizedState !== null && u.memoizedState.cachePool !== null) {
            var f = u.memoizedState.cachePool.pool;
            f != null && f.refCount++;
          }
          break;
        case 24:
          Zi(u.memoizedState.cache);
      }
      if (f = u.child, f !== null) f.return = u, Qt = f;
      else
        e: for (u = o; Qt !== null; ) {
          f = Qt;
          var g = f.sibling, S = f.return;
          if (Iy(f), f === u) {
            Qt = null;
            break e;
          }
          if (g !== null) {
            g.return = S, Qt = g;
            break e;
          }
          Qt = S;
        }
    }
  }
  var qC = {
    getCacheForType: function(o) {
      var i = tn(jt), u = i.data.get(o);
      return u === void 0 && (u = o(), i.data.set(o, u)), u;
    },
    cacheSignal: function() {
      return tn(jt).controller.signal;
    }
  }, WC = typeof WeakMap == "function" ? WeakMap : Map, Je = 0, lt = null, Fe = null, Ve = 0, nt = 0, Bn = null, vo = !1, ni = !1, op = !1, Xr = 0, St = 0, yo = 0, ga = 0, ap = 0, Un = 0, ri = 0, vs = null, Mn = null, ip = !1, Mu = 0, Xy = 0, Nu = 1 / 0, Ru = null, bo = null, Ut = 0, wo = null, oi = null, Yr = 0, sp = 0, lp = null, Yy = null, ys = 0, up = null;
  function Vn() {
    return (Je & 2) !== 0 && Ve !== 0 ? Ve & -Ve : L.T !== null ? hp() : Ed();
  }
  function Qy() {
    if (Un === 0)
      if ((Ve & 536870912) === 0 || Ge) {
        var o = dn;
        dn <<= 1, (dn & 3932160) === 0 && (dn = 262144), Un = o;
      } else Un = 536870912;
    return o = zn.current, o !== null && (o.flags |= 32), Un;
  }
  function Nn(o, i, u) {
    (o === lt && (nt === 2 || nt === 9) || o.cancelPendingCommit !== null) && (ai(o, 0), xo(
      o,
      Ve,
      Un,
      !1
    )), ja(o, u), ((Je & 2) === 0 || o !== lt) && (o === lt && ((Je & 2) === 0 && (ga |= u), St === 4 && xo(
      o,
      Ve,
      Un,
      !1
    )), Er(o));
  }
  function Jy(o, i, u) {
    if ((Je & 6) !== 0) throw Error(r(327));
    var f = !u && (i & 127) === 0 && (i & o.expiredLanes) === 0 || pr(o, i), g = f ? XC(o, i) : dp(o, i, !0), S = f;
    do {
      if (g === 0) {
        ni && !f && xo(o, i, 0, !1);
        break;
      } else {
        if (u = o.current.alternate, S && !GC(u)) {
          g = dp(o, i, !1), S = !1;
          continue;
        }
        if (g === 2) {
          if (S = i, o.errorRecoveryDisabledLanes & S)
            var A = 0;
          else
            A = o.pendingLanes & -536870913, A = A !== 0 ? A : A & 536870912 ? 536870912 : 0;
          if (A !== 0) {
            i = A;
            e: {
              var T = o;
              g = vs;
              var Y = T.current.memoizedState.isDehydrated;
              if (Y && (ai(T, A).flags |= 256), A = dp(
                T,
                A,
                !1
              ), A !== 2) {
                if (op && !Y) {
                  T.errorRecoveryDisabledLanes |= S, ga |= S, g = 4;
                  break e;
                }
                S = Mn, Mn = g, S !== null && (Mn === null ? Mn = S : Mn.push.apply(
                  Mn,
                  S
                ));
              }
              g = A;
            }
            if (S = !1, g !== 2) continue;
          }
        }
        if (g === 1) {
          ai(o, 0), xo(o, i, 0, !0);
          break;
        }
        e: {
          switch (f = o, S = g, S) {
            case 0:
            case 1:
              throw Error(r(345));
            case 4:
              if ((i & 4194048) !== i) break;
            case 6:
              xo(
                f,
                i,
                Un,
                !vo
              );
              break e;
            case 2:
              Mn = null;
              break;
            case 3:
            case 5:
              break;
            default:
              throw Error(r(329));
          }
          if ((i & 62914560) === i && (g = Mu + 300 - Ce(), 10 < g)) {
            if (xo(
              f,
              i,
              Un,
              !vo
            ), Io(f, 0, !0) !== 0) break e;
            Yr = i, f.timeoutHandle = Nb(
              Zy.bind(
                null,
                f,
                u,
                Mn,
                Ru,
                ip,
                i,
                Un,
                ga,
                ri,
                vo,
                S,
                "Throttled",
                -0,
                0
              ),
              g
            );
            break e;
          }
          Zy(
            f,
            u,
            Mn,
            Ru,
            ip,
            i,
            Un,
            ga,
            ri,
            vo,
            S,
            null,
            -0,
            0
          );
        }
      }
      break;
    } while (!0);
    Er(o);
  }
  function Zy(o, i, u, f, g, S, A, T, Y, ne, ue, fe, oe, ie) {
    if (o.timeoutHandle = -1, fe = i.subtreeFlags, fe & 8192 || (fe & 16785408) === 16785408) {
      fe = {
        stylesheets: null,
        count: 0,
        imgCount: 0,
        imgBytes: 0,
        suspenseyImages: [],
        waitingForImages: !0,
        waitingForViewTransition: !1,
        unsuspend: $r
      }, qy(
        i,
        S,
        fe
      );
      var we = (S & 62914560) === S ? Mu - Ce() : (S & 4194048) === S ? Xy - Ce() : 0;
      if (we = AO(
        fe,
        we
      ), we !== null) {
        Yr = S, o.cancelPendingCommit = we(
          sb.bind(
            null,
            o,
            i,
            S,
            u,
            f,
            g,
            A,
            T,
            Y,
            ue,
            fe,
            null,
            oe,
            ie
          )
        ), xo(o, S, A, !ne);
        return;
      }
    }
    sb(
      o,
      i,
      S,
      u,
      f,
      g,
      A,
      T,
      Y
    );
  }
  function GC(o) {
    for (var i = o; ; ) {
      var u = i.tag;
      if ((u === 0 || u === 11 || u === 15) && i.flags & 16384 && (u = i.updateQueue, u !== null && (u = u.stores, u !== null)))
        for (var f = 0; f < u.length; f++) {
          var g = u[f], S = g.getSnapshot;
          g = g.value;
          try {
            if (!Ln(S(), g)) return !1;
          } catch {
            return !1;
          }
        }
      if (u = i.child, i.subtreeFlags & 16384 && u !== null)
        u.return = i, i = u;
      else {
        if (i === o) break;
        for (; i.sibling === null; ) {
          if (i.return === null || i.return === o) return !0;
          i = i.return;
        }
        i.sibling.return = i.return, i = i.sibling;
      }
    }
    return !0;
  }
  function xo(o, i, u, f) {
    i &= ~ap, i &= ~ga, o.suspendedLanes |= i, o.pingedLanes &= ~i, f && (o.warmLanes |= i), f = o.expirationTimes;
    for (var g = i; 0 < g; ) {
      var S = 31 - Re(g), A = 1 << S;
      f[S] = -1, g &= ~A;
    }
    u !== 0 && Sd(o, u, i);
  }
  function Au() {
    return (Je & 6) === 0 ? (bs(0), !1) : !0;
  }
  function cp() {
    if (Fe !== null) {
      if (nt === 0)
        var o = Fe.return;
      else
        o = Fe, zr = sa = null, Cf(o), Xa = null, ts = 0, o = Fe;
      for (; o !== null; )
        Ry(o.alternate, o), o = o.return;
      Fe = null;
    }
  }
  function ai(o, i) {
    var u = o.timeoutHandle;
    u !== -1 && (o.timeoutHandle = -1, pO(u)), u = o.cancelPendingCommit, u !== null && (o.cancelPendingCommit = null, u()), Yr = 0, cp(), lt = o, Fe = u = Lr(o.current, null), Ve = i, nt = 0, Bn = null, vo = !1, ni = pr(o, i), op = !1, ri = Un = ap = ga = yo = St = 0, Mn = vs = null, ip = !1, (i & 8) !== 0 && (i |= i & 32);
    var f = o.entangledLanes;
    if (f !== 0)
      for (o = o.entanglements, f &= i; 0 < f; ) {
        var g = 31 - Re(f), S = 1 << g;
        i |= o[g], f &= ~S;
      }
    return Xr = i, Jl(), u;
  }
  function eb(o, i) {
    Te = null, L.H = us, i === Ka || i === iu ? (i = gv(), nt = 3) : i === mf ? (i = gv(), nt = 4) : nt = i === Uf ? 8 : i !== null && typeof i == "object" && typeof i.then == "function" ? 6 : 1, Bn = i, Fe === null && (St = 1, wu(
      o,
      Zn(i, o.current)
    ));
  }
  function tb() {
    var o = zn.current;
    return o === null ? !0 : (Ve & 4194048) === Ve ? lr === null : (Ve & 62914560) === Ve || (Ve & 536870912) !== 0 ? o === lr : !1;
  }
  function nb() {
    var o = L.H;
    return L.H = us, o === null ? us : o;
  }
  function rb() {
    var o = L.A;
    return L.A = qC, o;
  }
  function ju() {
    St = 4, vo || (Ve & 4194048) !== Ve && zn.current !== null || (ni = !0), (yo & 134217727) === 0 && (ga & 134217727) === 0 || lt === null || xo(
      lt,
      Ve,
      Un,
      !1
    );
  }
  function dp(o, i, u) {
    var f = Je;
    Je |= 2;
    var g = nb(), S = rb();
    (lt !== o || Ve !== i) && (Ru = null, ai(o, i)), i = !1;
    var A = St;
    e: do
      try {
        if (nt !== 0 && Fe !== null) {
          var T = Fe, Y = Bn;
          switch (nt) {
            case 8:
              cp(), A = 6;
              break e;
            case 3:
            case 2:
            case 9:
            case 6:
              zn.current === null && (i = !0);
              var ne = nt;
              if (nt = 0, Bn = null, ii(o, T, Y, ne), u && ni) {
                A = 0;
                break e;
              }
              break;
            default:
              ne = nt, nt = 0, Bn = null, ii(o, T, Y, ne);
          }
        }
        KC(), A = St;
        break;
      } catch (ue) {
        eb(o, ue);
      }
    while (!0);
    return i && o.shellSuspendCounter++, zr = sa = null, Je = f, L.H = g, L.A = S, Fe === null && (lt = null, Ve = 0, Jl()), A;
  }
  function KC() {
    for (; Fe !== null; ) ob(Fe);
  }
  function XC(o, i) {
    var u = Je;
    Je |= 2;
    var f = nb(), g = rb();
    lt !== o || Ve !== i ? (Ru = null, Nu = Ce() + 500, ai(o, i)) : ni = pr(
      o,
      i
    );
    e: do
      try {
        if (nt !== 0 && Fe !== null) {
          i = Fe;
          var S = Bn;
          t: switch (nt) {
            case 1:
              nt = 0, Bn = null, ii(o, i, S, 1);
              break;
            case 2:
            case 9:
              if (mv(S)) {
                nt = 0, Bn = null, ab(i);
                break;
              }
              i = function() {
                nt !== 2 && nt !== 9 || lt !== o || (nt = 7), Er(o);
              }, S.then(i, i);
              break e;
            case 3:
              nt = 7;
              break e;
            case 4:
              nt = 5;
              break e;
            case 7:
              mv(S) ? (nt = 0, Bn = null, ab(i)) : (nt = 0, Bn = null, ii(o, i, S, 7));
              break;
            case 5:
              var A = null;
              switch (Fe.tag) {
                case 26:
                  A = Fe.memoizedState;
                case 5:
                case 27:
                  var T = Fe;
                  if (A ? Hb(A) : T.stateNode.complete) {
                    nt = 0, Bn = null;
                    var Y = T.sibling;
                    if (Y !== null) Fe = Y;
                    else {
                      var ne = T.return;
                      ne !== null ? (Fe = ne, Pu(ne)) : Fe = null;
                    }
                    break t;
                  }
              }
              nt = 0, Bn = null, ii(o, i, S, 5);
              break;
            case 6:
              nt = 0, Bn = null, ii(o, i, S, 6);
              break;
            case 8:
              cp(), St = 6;
              break e;
            default:
              throw Error(r(462));
          }
        }
        YC();
        break;
      } catch (ue) {
        eb(o, ue);
      }
    while (!0);
    return zr = sa = null, L.H = f, L.A = g, Je = u, Fe !== null ? 0 : (lt = null, Ve = 0, Jl(), St);
  }
  function YC() {
    for (; Fe !== null && !an(); )
      ob(Fe);
  }
  function ob(o) {
    var i = My(o.alternate, o, Xr);
    o.memoizedProps = o.pendingProps, i === null ? Pu(o) : Fe = i;
  }
  function ab(o) {
    var i = o, u = i.alternate;
    switch (i.tag) {
      case 15:
      case 0:
        i = Sy(
          u,
          i,
          i.pendingProps,
          i.type,
          void 0,
          Ve
        );
        break;
      case 11:
        i = Sy(
          u,
          i,
          i.pendingProps,
          i.type.render,
          i.ref,
          Ve
        );
        break;
      case 5:
        Cf(i);
      default:
        Ry(u, i), i = Fe = rv(i, Xr), i = My(u, i, Xr);
    }
    o.memoizedProps = o.pendingProps, i === null ? Pu(o) : Fe = i;
  }
  function ii(o, i, u, f) {
    zr = sa = null, Cf(i), Xa = null, ts = 0;
    var g = i.return;
    try {
      if (IC(
        o,
        g,
        i,
        u,
        Ve
      )) {
        St = 1, wu(
          o,
          Zn(u, o.current)
        ), Fe = null;
        return;
      }
    } catch (S) {
      if (g !== null) throw Fe = g, S;
      St = 1, wu(
        o,
        Zn(u, o.current)
      ), Fe = null;
      return;
    }
    i.flags & 32768 ? (Ge || f === 1 ? o = !0 : ni || (Ve & 536870912) !== 0 ? o = !1 : (vo = o = !0, (f === 2 || f === 9 || f === 3 || f === 6) && (f = zn.current, f !== null && f.tag === 13 && (f.flags |= 16384))), ib(i, o)) : Pu(i);
  }
  function Pu(o) {
    var i = o;
    do {
      if ((i.flags & 32768) !== 0) {
        ib(
          i,
          vo
        );
        return;
      }
      o = i.return;
      var u = BC(
        i.alternate,
        i,
        Xr
      );
      if (u !== null) {
        Fe = u;
        return;
      }
      if (i = i.sibling, i !== null) {
        Fe = i;
        return;
      }
      Fe = i = o;
    } while (i !== null);
    St === 0 && (St = 5);
  }
  function ib(o, i) {
    do {
      var u = UC(o.alternate, o);
      if (u !== null) {
        u.flags &= 32767, Fe = u;
        return;
      }
      if (u = o.return, u !== null && (u.flags |= 32768, u.subtreeFlags = 0, u.deletions = null), !i && (o = o.sibling, o !== null)) {
        Fe = o;
        return;
      }
      Fe = o = u;
    } while (o !== null);
    St = 6, Fe = null;
  }
  function sb(o, i, u, f, g, S, A, T, Y) {
    o.cancelPendingCommit = null;
    do
      Du();
    while (Ut !== 0);
    if ((Je & 6) !== 0) throw Error(r(327));
    if (i !== null) {
      if (i === o.current) throw Error(r(177));
      if (S = i.lanes | i.childLanes, S |= Jd, gg(
        o,
        u,
        S,
        A,
        T,
        Y
      ), o === lt && (Fe = lt = null, Ve = 0), oi = i, wo = o, Yr = u, sp = S, lp = g, Yy = f, (i.subtreeFlags & 10256) !== 0 || (i.flags & 10256) !== 0 ? (o.callbackNode = null, o.callbackPriority = 0, eO(Ee, function() {
        return fb(), null;
      })) : (o.callbackNode = null, o.callbackPriority = 0), f = (i.flags & 13878) !== 0, (i.subtreeFlags & 13878) !== 0 || f) {
        f = L.T, L.T = null, g = K.p, K.p = 2, A = Je, Je |= 4;
        try {
          VC(o, i, u);
        } finally {
          Je = A, K.p = g, L.T = f;
        }
      }
      Ut = 1, lb(), ub(), cb();
    }
  }
  function lb() {
    if (Ut === 1) {
      Ut = 0;
      var o = wo, i = oi, u = (i.flags & 13878) !== 0;
      if ((i.subtreeFlags & 13878) !== 0 || u) {
        u = L.T, L.T = null;
        var f = K.p;
        K.p = 2;
        var g = Je;
        Je |= 4;
        try {
          Uy(i, o);
          var S = kp, A = Kg(o.containerInfo), T = S.focusedElem, Y = S.selectionRange;
          if (A !== T && T && T.ownerDocument && Gg(
            T.ownerDocument.documentElement,
            T
          )) {
            if (Y !== null && Gd(T)) {
              var ne = Y.start, ue = Y.end;
              if (ue === void 0 && (ue = ne), "selectionStart" in T)
                T.selectionStart = ne, T.selectionEnd = Math.min(
                  ue,
                  T.value.length
                );
              else {
                var fe = T.ownerDocument || document, oe = fe && fe.defaultView || window;
                if (oe.getSelection) {
                  var ie = oe.getSelection(), we = T.textContent.length, Ne = Math.min(Y.start, we), it = Y.end === void 0 ? Ne : Math.min(Y.end, we);
                  !ie.extend && Ne > it && (A = it, it = Ne, Ne = A);
                  var ee = Wg(
                    T,
                    Ne
                  ), J = Wg(
                    T,
                    it
                  );
                  if (ee && J && (ie.rangeCount !== 1 || ie.anchorNode !== ee.node || ie.anchorOffset !== ee.offset || ie.focusNode !== J.node || ie.focusOffset !== J.offset)) {
                    var te = fe.createRange();
                    te.setStart(ee.node, ee.offset), ie.removeAllRanges(), Ne > it ? (ie.addRange(te), ie.extend(J.node, J.offset)) : (te.setEnd(J.node, J.offset), ie.addRange(te));
                  }
                }
              }
            }
            for (fe = [], ie = T; ie = ie.parentNode; )
              ie.nodeType === 1 && fe.push({
                element: ie,
                left: ie.scrollLeft,
                top: ie.scrollTop
              });
            for (typeof T.focus == "function" && T.focus(), T = 0; T < fe.length; T++) {
              var ce = fe[T];
              ce.element.scrollLeft = ce.left, ce.element.scrollTop = ce.top;
            }
          }
          Wu = !!Sp, kp = Sp = null;
        } finally {
          Je = g, K.p = f, L.T = u;
        }
      }
      o.current = i, Ut = 2;
    }
  }
  function ub() {
    if (Ut === 2) {
      Ut = 0;
      var o = wo, i = oi, u = (i.flags & 8772) !== 0;
      if ((i.subtreeFlags & 8772) !== 0 || u) {
        u = L.T, L.T = null;
        var f = K.p;
        K.p = 2;
        var g = Je;
        Je |= 4;
        try {
          Ly(o, i.alternate, i);
        } finally {
          Je = g, K.p = f, L.T = u;
        }
      }
      Ut = 3;
    }
  }
  function cb() {
    if (Ut === 4 || Ut === 3) {
      Ut = 0, dt();
      var o = wo, i = oi, u = Yr, f = Yy;
      (i.subtreeFlags & 10256) !== 0 || (i.flags & 10256) !== 0 ? Ut = 5 : (Ut = 0, oi = wo = null, db(o, o.pendingLanes));
      var g = o.pendingLanes;
      if (g === 0 && (bo = null), Bl(u), i = i.stateNode, Ot && typeof Ot.onCommitFiberRoot == "function")
        try {
          Ot.onCommitFiberRoot(
            Wt,
            i,
            void 0,
            (i.current.flags & 128) === 128
          );
        } catch {
        }
      if (f !== null) {
        i = L.T, g = K.p, K.p = 2, L.T = null;
        try {
          for (var S = o.onRecoverableError, A = 0; A < f.length; A++) {
            var T = f[A];
            S(T.value, {
              componentStack: T.stack
            });
          }
        } finally {
          L.T = i, K.p = g;
        }
      }
      (Yr & 3) !== 0 && Du(), Er(o), g = o.pendingLanes, (u & 261930) !== 0 && (g & 42) !== 0 ? o === up ? ys++ : (ys = 0, up = o) : ys = 0, bs(0);
    }
  }
  function db(o, i) {
    (o.pooledCacheLanes &= i) === 0 && (i = o.pooledCache, i != null && (o.pooledCache = null, Zi(i)));
  }
  function Du() {
    return lb(), ub(), cb(), fb();
  }
  function fb() {
    if (Ut !== 5) return !1;
    var o = wo, i = sp;
    sp = 0;
    var u = Bl(Yr), f = L.T, g = K.p;
    try {
      K.p = 32 > u ? 32 : u, L.T = null, u = lp, lp = null;
      var S = wo, A = Yr;
      if (Ut = 0, oi = wo = null, Yr = 0, (Je & 6) !== 0) throw Error(r(331));
      var T = Je;
      if (Je |= 4, Gy(S.current), Hy(
        S,
        S.current,
        A,
        u
      ), Je = T, bs(0, !1), Ot && typeof Ot.onPostCommitFiberRoot == "function")
        try {
          Ot.onPostCommitFiberRoot(Wt, S);
        } catch {
        }
      return !0;
    } finally {
      K.p = g, L.T = f, db(o, i);
    }
  }
  function pb(o, i, u) {
    i = Zn(u, i), i = Bf(o.stateNode, i, 2), o = po(o, i, 2), o !== null && (ja(o, 2), Er(o));
  }
  function rt(o, i, u) {
    if (o.tag === 3)
      pb(o, o, u);
    else
      for (; i !== null; ) {
        if (i.tag === 3) {
          pb(
            i,
            o,
            u
          );
          break;
        } else if (i.tag === 1) {
          var f = i.stateNode;
          if (typeof i.type.getDerivedStateFromError == "function" || typeof f.componentDidCatch == "function" && (bo === null || !bo.has(f))) {
            o = Zn(u, o), u = my(2), f = po(i, u, 2), f !== null && (hy(
              u,
              f,
              i,
              o
            ), ja(f, 2), Er(f));
            break;
          }
        }
        i = i.return;
      }
  }
  function fp(o, i, u) {
    var f = o.pingCache;
    if (f === null) {
      f = o.pingCache = new WC();
      var g = /* @__PURE__ */ new Set();
      f.set(i, g);
    } else
      g = f.get(i), g === void 0 && (g = /* @__PURE__ */ new Set(), f.set(i, g));
    g.has(u) || (op = !0, g.add(u), o = QC.bind(null, o, i, u), i.then(o, o));
  }
  function QC(o, i, u) {
    var f = o.pingCache;
    f !== null && f.delete(i), o.pingedLanes |= o.suspendedLanes & u, o.warmLanes &= ~u, lt === o && (Ve & u) === u && (St === 4 || St === 3 && (Ve & 62914560) === Ve && 300 > Ce() - Mu ? (Je & 2) === 0 && ai(o, 0) : ap |= u, ri === Ve && (ri = 0)), Er(o);
  }
  function mb(o, i) {
    i === 0 && (i = xd()), o = oa(o, i), o !== null && (ja(o, i), Er(o));
  }
  function JC(o) {
    var i = o.memoizedState, u = 0;
    i !== null && (u = i.retryLane), mb(o, u);
  }
  function ZC(o, i) {
    var u = 0;
    switch (o.tag) {
      case 31:
      case 13:
        var f = o.stateNode, g = o.memoizedState;
        g !== null && (u = g.retryLane);
        break;
      case 19:
        f = o.stateNode;
        break;
      case 22:
        f = o.stateNode._retryCache;
        break;
      default:
        throw Error(r(314));
    }
    f !== null && f.delete(i), mb(o, u);
  }
  function eO(o, i) {
    return tt(o, i);
  }
  var $u = null, si = null, pp = !1, Tu = !1, mp = !1, So = 0;
  function Er(o) {
    o !== si && o.next === null && (si === null ? $u = si = o : si = si.next = o), Tu = !0, pp || (pp = !0, nO());
  }
  function bs(o, i) {
    if (!mp && Tu) {
      mp = !0;
      do
        for (var u = !1, f = $u; f !== null; ) {
          if (o !== 0) {
            var g = f.pendingLanes;
            if (g === 0) var S = 0;
            else {
              var A = f.suspendedLanes, T = f.pingedLanes;
              S = (1 << 31 - Re(42 | o) + 1) - 1, S &= g & ~(A & ~T), S = S & 201326741 ? S & 201326741 | 1 : S ? S | 2 : 0;
            }
            S !== 0 && (u = !0, yb(f, S));
          } else
            S = Ve, S = Io(
              f,
              f === lt ? S : 0,
              f.cancelPendingCommit !== null || f.timeoutHandle !== -1
            ), (S & 3) === 0 || pr(f, S) || (u = !0, yb(f, S));
          f = f.next;
        }
      while (u);
      mp = !1;
    }
  }
  function tO() {
    hb();
  }
  function hb() {
    Tu = pp = !1;
    var o = 0;
    So !== 0 && fO() && (o = So);
    for (var i = Ce(), u = null, f = $u; f !== null; ) {
      var g = f.next, S = gb(f, i);
      S === 0 ? (f.next = null, u === null ? $u = g : u.next = g, g === null && (si = u)) : (u = f, (o !== 0 || (S & 3) !== 0) && (Tu = !0)), f = g;
    }
    Ut !== 0 && Ut !== 5 || bs(o), So !== 0 && (So = 0);
  }
  function gb(o, i) {
    for (var u = o.suspendedLanes, f = o.pingedLanes, g = o.expirationTimes, S = o.pendingLanes & -62914561; 0 < S; ) {
      var A = 31 - Re(S), T = 1 << A, Y = g[A];
      Y === -1 ? ((T & u) === 0 || (T & f) !== 0) && (g[A] = hg(T, i)) : Y <= i && (o.expiredLanes |= T), S &= ~T;
    }
    if (i = lt, u = Ve, u = Io(
      o,
      o === i ? u : 0,
      o.cancelPendingCommit !== null || o.timeoutHandle !== -1
    ), f = o.callbackNode, u === 0 || o === i && (nt === 2 || nt === 9) || o.cancelPendingCommit !== null)
      return f !== null && f !== null && je(f), o.callbackNode = null, o.callbackPriority = 0;
    if ((u & 3) === 0 || pr(o, u)) {
      if (i = u & -u, i === o.callbackPriority) return i;
      switch (f !== null && je(f), Bl(u)) {
        case 2:
        case 8:
          u = ye;
          break;
        case 32:
          u = Ee;
          break;
        case 268435456:
          u = ze;
          break;
        default:
          u = Ee;
      }
      return f = vb.bind(null, o), u = tt(u, f), o.callbackPriority = i, o.callbackNode = u, i;
    }
    return f !== null && f !== null && je(f), o.callbackPriority = 2, o.callbackNode = null, 2;
  }
  function vb(o, i) {
    if (Ut !== 0 && Ut !== 5)
      return o.callbackNode = null, o.callbackPriority = 0, null;
    var u = o.callbackNode;
    if (Du() && o.callbackNode !== u)
      return null;
    var f = Ve;
    return f = Io(
      o,
      o === lt ? f : 0,
      o.cancelPendingCommit !== null || o.timeoutHandle !== -1
    ), f === 0 ? null : (Jy(o, f, i), gb(o, Ce()), o.callbackNode != null && o.callbackNode === u ? vb.bind(null, o) : null);
  }
  function yb(o, i) {
    if (Du()) return null;
    Jy(o, i, !0);
  }
  function nO() {
    mO(function() {
      (Je & 6) !== 0 ? tt(
        he,
        tO
      ) : hb();
    });
  }
  function hp() {
    if (So === 0) {
      var o = Wa;
      o === 0 && (o = Lo, Lo <<= 1, (Lo & 261888) === 0 && (Lo = 256)), So = o;
    }
    return So;
  }
  function bb(o) {
    return o == null || typeof o == "symbol" || typeof o == "boolean" ? null : typeof o == "function" ? o : Hl("" + o);
  }
  function wb(o, i) {
    var u = i.ownerDocument.createElement("input");
    return u.name = i.name, u.value = i.value, o.id && u.setAttribute("form", o.id), i.parentNode.insertBefore(u, i), o = new FormData(o), u.parentNode.removeChild(u), o;
  }
  function rO(o, i, u, f, g) {
    if (i === "submit" && u && u.stateNode === g) {
      var S = bb(
        (g[mn] || null).action
      ), A = f.submitter;
      A && (i = (i = A[mn] || null) ? bb(i.formAction) : A.getAttribute("formAction"), i !== null && (S = i, A = null));
      var T = new Kl(
        "action",
        "action",
        null,
        f,
        g
      );
      o.push({
        event: T,
        listeners: [
          {
            instance: null,
            listener: function() {
              if (f.defaultPrevented) {
                if (So !== 0) {
                  var Y = A ? wb(g, A) : new FormData(g);
                  $f(
                    u,
                    {
                      pending: !0,
                      data: Y,
                      method: g.method,
                      action: S
                    },
                    null,
                    Y
                  );
                }
              } else
                typeof S == "function" && (T.preventDefault(), Y = A ? wb(g, A) : new FormData(g), $f(
                  u,
                  {
                    pending: !0,
                    data: Y,
                    method: g.method,
                    action: S
                  },
                  S,
                  Y
                ));
            },
            currentTarget: g
          }
        ]
      });
    }
  }
  for (var gp = 0; gp < Qd.length; gp++) {
    var vp = Qd[gp], oO = vp.toLowerCase(), aO = vp[0].toUpperCase() + vp.slice(1);
    mr(
      oO,
      "on" + aO
    );
  }
  mr(Qg, "onAnimationEnd"), mr(Jg, "onAnimationIteration"), mr(Zg, "onAnimationStart"), mr("dblclick", "onDoubleClick"), mr("focusin", "onFocus"), mr("focusout", "onBlur"), mr(xC, "onTransitionRun"), mr(SC, "onTransitionStart"), mr(kC, "onTransitionCancel"), mr(ev, "onTransitionEnd"), ea("onMouseEnter", ["mouseout", "mouseover"]), ea("onMouseLeave", ["mouseout", "mouseover"]), ea("onPointerEnter", ["pointerout", "pointerover"]), ea("onPointerLeave", ["pointerout", "pointerover"]), oo(
    "onChange",
    "change click focusin focusout input keydown keyup selectionchange".split(" ")
  ), oo(
    "onSelect",
    "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(
      " "
    )
  ), oo("onBeforeInput", [
    "compositionend",
    "keypress",
    "textInput",
    "paste"
  ]), oo(
    "onCompositionEnd",
    "compositionend focusout keydown keypress keyup mousedown".split(" ")
  ), oo(
    "onCompositionStart",
    "compositionstart focusout keydown keypress keyup mousedown".split(" ")
  ), oo(
    "onCompositionUpdate",
    "compositionupdate focusout keydown keypress keyup mousedown".split(" ")
  );
  var ws = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(
    " "
  ), iO = new Set(
    "beforetoggle cancel close invalid load scroll scrollend toggle".split(" ").concat(ws)
  );
  function xb(o, i) {
    i = (i & 4) !== 0;
    for (var u = 0; u < o.length; u++) {
      var f = o[u], g = f.event;
      f = f.listeners;
      e: {
        var S = void 0;
        if (i)
          for (var A = f.length - 1; 0 <= A; A--) {
            var T = f[A], Y = T.instance, ne = T.currentTarget;
            if (T = T.listener, Y !== S && g.isPropagationStopped())
              break e;
            S = T, g.currentTarget = ne;
            try {
              S(g);
            } catch (ue) {
              Ql(ue);
            }
            g.currentTarget = null, S = Y;
          }
        else
          for (A = 0; A < f.length; A++) {
            if (T = f[A], Y = T.instance, ne = T.currentTarget, T = T.listener, Y !== S && g.isPropagationStopped())
              break e;
            S = T, g.currentTarget = ne;
            try {
              S(g);
            } catch (ue) {
              Ql(ue);
            }
            g.currentTarget = null, S = Y;
          }
      }
    }
  }
  function Be(o, i) {
    var u = i[Xs];
    u === void 0 && (u = i[Xs] = /* @__PURE__ */ new Set());
    var f = o + "__bubble";
    u.has(f) || (Sb(i, o, 2, !1), u.add(f));
  }
  function yp(o, i, u) {
    var f = 0;
    i && (f |= 4), Sb(
      u,
      o,
      f,
      i
    );
  }
  var Lu = "_reactListening" + Math.random().toString(36).slice(2);
  function bp(o) {
    if (!o[Lu]) {
      o[Lu] = !0, Md.forEach(function(u) {
        u !== "selectionchange" && (iO.has(u) || yp(u, !1, o), yp(u, !0, o));
      });
      var i = o.nodeType === 9 ? o : o.ownerDocument;
      i === null || i[Lu] || (i[Lu] = !0, yp("selectionchange", !1, i));
    }
  }
  function Sb(o, i, u, f) {
    switch (Qb(i)) {
      case 2:
        var g = DO;
        break;
      case 8:
        g = $O;
        break;
      default:
        g = Dp;
    }
    u = g.bind(
      null,
      i,
      u,
      o
    ), g = void 0, !Id || i !== "touchstart" && i !== "touchmove" && i !== "wheel" || (g = !0), f ? g !== void 0 ? o.addEventListener(i, u, {
      capture: !0,
      passive: g
    }) : o.addEventListener(i, u, !0) : g !== void 0 ? o.addEventListener(i, u, {
      passive: g
    }) : o.addEventListener(i, u, !1);
  }
  function wp(o, i, u, f, g) {
    var S = f;
    if ((i & 1) === 0 && (i & 2) === 0 && f !== null)
      e: for (; ; ) {
        if (f === null) return;
        var A = f.tag;
        if (A === 3 || A === 4) {
          var T = f.stateNode.containerInfo;
          if (T === g) break;
          if (A === 4)
            for (A = f.return; A !== null; ) {
              var Y = A.tag;
              if ((Y === 3 || Y === 4) && A.stateNode.containerInfo === g)
                return;
              A = A.return;
            }
          for (; T !== null; ) {
            if (A = Qo(T), A === null) return;
            if (Y = A.tag, Y === 5 || Y === 6 || Y === 26 || Y === 27) {
              f = S = A;
              continue e;
            }
            T = T.parentNode;
          }
        }
        f = f.return;
      }
    Og(function() {
      var ne = S, ue = Td(u), fe = [];
      e: {
        var oe = tv.get(o);
        if (oe !== void 0) {
          var ie = Kl, we = o;
          switch (o) {
            case "keypress":
              if (Wl(u) === 0) break e;
            case "keydown":
            case "keyup":
              ie = ZE;
              break;
            case "focusin":
              we = "focus", ie = Ud;
              break;
            case "focusout":
              we = "blur", ie = Ud;
              break;
            case "beforeblur":
            case "afterblur":
              ie = Ud;
              break;
            case "click":
              if (u.button === 2) break e;
            case "auxclick":
            case "dblclick":
            case "mousedown":
            case "mousemove":
            case "mouseup":
            case "mouseout":
            case "mouseover":
            case "contextmenu":
              ie = Rg;
              break;
            case "drag":
            case "dragend":
            case "dragenter":
            case "dragexit":
            case "dragleave":
            case "dragover":
            case "dragstart":
            case "drop":
              ie = BE;
              break;
            case "touchcancel":
            case "touchend":
            case "touchmove":
            case "touchstart":
              ie = nC;
              break;
            case Qg:
            case Jg:
            case Zg:
              ie = HE;
              break;
            case ev:
              ie = oC;
              break;
            case "scroll":
            case "scrollend":
              ie = zE;
              break;
            case "wheel":
              ie = iC;
              break;
            case "copy":
            case "cut":
            case "paste":
              ie = WE;
              break;
            case "gotpointercapture":
            case "lostpointercapture":
            case "pointercancel":
            case "pointerdown":
            case "pointermove":
            case "pointerout":
            case "pointerover":
            case "pointerup":
              ie = jg;
              break;
            case "toggle":
            case "beforetoggle":
              ie = lC;
          }
          var Ne = (i & 4) !== 0, it = !Ne && (o === "scroll" || o === "scrollend"), ee = Ne ? oe !== null ? oe + "Capture" : null : oe;
          Ne = [];
          for (var J = ne, te; J !== null; ) {
            var ce = J;
            if (te = ce.stateNode, ce = ce.tag, ce !== 5 && ce !== 26 && ce !== 27 || te === null || ee === null || (ce = Ui(J, ee), ce != null && Ne.push(
              xs(J, ce, te)
            )), it) break;
            J = J.return;
          }
          0 < Ne.length && (oe = new ie(
            oe,
            we,
            null,
            u,
            ue
          ), fe.push({ event: oe, listeners: Ne }));
        }
      }
      if ((i & 7) === 0) {
        e: {
          if (oe = o === "mouseover" || o === "pointerover", ie = o === "mouseout" || o === "pointerout", oe && u !== $d && (we = u.relatedTarget || u.fromElement) && (Qo(we) || we[zo]))
            break e;
          if ((ie || oe) && (oe = ue.window === ue ? ue : (oe = ue.ownerDocument) ? oe.defaultView || oe.parentWindow : window, ie ? (we = u.relatedTarget || u.toElement, ie = ne, we = we ? Qo(we) : null, we !== null && (it = s(we), Ne = we.tag, we !== it || Ne !== 5 && Ne !== 27 && Ne !== 6) && (we = null)) : (ie = null, we = ne), ie !== we)) {
            if (Ne = Rg, ce = "onMouseLeave", ee = "onMouseEnter", J = "mouse", (o === "pointerout" || o === "pointerover") && (Ne = jg, ce = "onPointerLeave", ee = "onPointerEnter", J = "pointer"), it = ie == null ? oe : ka(ie), te = we == null ? oe : ka(we), oe = new Ne(
              ce,
              J + "leave",
              ie,
              u,
              ue
            ), oe.target = it, oe.relatedTarget = te, ce = null, Qo(ue) === ne && (Ne = new Ne(
              ee,
              J + "enter",
              we,
              u,
              ue
            ), Ne.target = te, Ne.relatedTarget = it, ce = Ne), it = ce, ie && we)
              t: {
                for (Ne = sO, ee = ie, J = we, te = 0, ce = ee; ce; ce = Ne(ce))
                  te++;
                ce = 0;
                for (var Oe = J; Oe; Oe = Ne(Oe))
                  ce++;
                for (; 0 < te - ce; )
                  ee = Ne(ee), te--;
                for (; 0 < ce - te; )
                  J = Ne(J), ce--;
                for (; te--; ) {
                  if (ee === J || J !== null && ee === J.alternate) {
                    Ne = ee;
                    break t;
                  }
                  ee = Ne(ee), J = Ne(J);
                }
                Ne = null;
              }
            else Ne = null;
            ie !== null && kb(
              fe,
              oe,
              ie,
              Ne,
              !1
            ), we !== null && it !== null && kb(
              fe,
              it,
              we,
              Ne,
              !0
            );
          }
        }
        e: {
          if (oe = ne ? ka(ne) : window, ie = oe.nodeName && oe.nodeName.toLowerCase(), ie === "select" || ie === "input" && oe.type === "file")
            var Ye = Fg;
          else if (Ig(oe))
            if (Bg)
              Ye = yC;
            else {
              Ye = gC;
              var ke = hC;
            }
          else
            ie = oe.nodeName, !ie || ie.toLowerCase() !== "input" || oe.type !== "checkbox" && oe.type !== "radio" ? ne && Dd(ne.elementType) && (Ye = Fg) : Ye = vC;
          if (Ye && (Ye = Ye(o, ne))) {
            zg(
              fe,
              Ye,
              u,
              ue
            );
            break e;
          }
          ke && ke(o, oe, ne), o === "focusout" && ne && oe.type === "number" && ne.memoizedProps.value != null && Vl(oe, "number", oe.value);
        }
        switch (ke = ne ? ka(ne) : window, o) {
          case "focusin":
            (Ig(ke) || ke.contentEditable === "true") && (Ia = ke, Kd = ne, Yi = null);
            break;
          case "focusout":
            Yi = Kd = Ia = null;
            break;
          case "mousedown":
            Xd = !0;
            break;
          case "contextmenu":
          case "mouseup":
          case "dragend":
            Xd = !1, Xg(fe, u, ue);
            break;
          case "selectionchange":
            if (wC) break;
          case "keydown":
          case "keyup":
            Xg(fe, u, ue);
        }
        var Ie;
        if (Hd)
          e: {
            switch (o) {
              case "compositionstart":
                var He = "onCompositionStart";
                break e;
              case "compositionend":
                He = "onCompositionEnd";
                break e;
              case "compositionupdate":
                He = "onCompositionUpdate";
                break e;
            }
            He = void 0;
          }
        else
          La ? Tg(o, u) && (He = "onCompositionEnd") : o === "keydown" && u.keyCode === 229 && (He = "onCompositionStart");
        He && (Pg && u.locale !== "ko" && (La || He !== "onCompositionStart" ? He === "onCompositionEnd" && La && (Ie = Mg()) : (ao = ue, zd = "value" in ao ? ao.value : ao.textContent, La = !0)), ke = Iu(ne, He), 0 < ke.length && (He = new Ag(
          He,
          o,
          null,
          u,
          ue
        ), fe.push({ event: He, listeners: ke }), Ie ? He.data = Ie : (Ie = Lg(u), Ie !== null && (He.data = Ie)))), (Ie = cC ? dC(o, u) : fC(o, u)) && (He = Iu(ne, "onBeforeInput"), 0 < He.length && (ke = new Ag(
          "onBeforeInput",
          "beforeinput",
          null,
          u,
          ue
        ), fe.push({
          event: ke,
          listeners: He
        }), ke.data = Ie)), rO(
          fe,
          o,
          ne,
          u,
          ue
        );
      }
      xb(fe, i);
    });
  }
  function xs(o, i, u) {
    return {
      instance: o,
      listener: i,
      currentTarget: u
    };
  }
  function Iu(o, i) {
    for (var u = i + "Capture", f = []; o !== null; ) {
      var g = o, S = g.stateNode;
      if (g = g.tag, g !== 5 && g !== 26 && g !== 27 || S === null || (g = Ui(o, u), g != null && f.unshift(
        xs(o, g, S)
      ), g = Ui(o, i), g != null && f.push(
        xs(o, g, S)
      )), o.tag === 3) return f;
      o = o.return;
    }
    return [];
  }
  function sO(o) {
    if (o === null) return null;
    do
      o = o.return;
    while (o && o.tag !== 5 && o.tag !== 27);
    return o || null;
  }
  function kb(o, i, u, f, g) {
    for (var S = i._reactName, A = []; u !== null && u !== f; ) {
      var T = u, Y = T.alternate, ne = T.stateNode;
      if (T = T.tag, Y !== null && Y === f) break;
      T !== 5 && T !== 26 && T !== 27 || ne === null || (Y = ne, g ? (ne = Ui(u, S), ne != null && A.unshift(
        xs(u, ne, Y)
      )) : g || (ne = Ui(u, S), ne != null && A.push(
        xs(u, ne, Y)
      ))), u = u.return;
    }
    A.length !== 0 && o.push({ event: i, listeners: A });
  }
  var lO = /\r\n?/g, uO = /\u0000|\uFFFD/g;
  function _b(o) {
    return (typeof o == "string" ? o : "" + o).replace(lO, `
`).replace(uO, "");
  }
  function Eb(o, i) {
    return i = _b(i), _b(o) === i;
  }
  function at(o, i, u, f, g, S) {
    switch (u) {
      case "children":
        typeof f == "string" ? i === "body" || i === "textarea" && f === "" || Da(o, f) : (typeof f == "number" || typeof f == "bigint") && i !== "body" && Da(o, "" + f);
        break;
      case "className":
        Fi(o, "class", f);
        break;
      case "tabIndex":
        Fi(o, "tabindex", f);
        break;
      case "dir":
      case "role":
      case "viewBox":
      case "width":
      case "height":
        Fi(o, u, f);
        break;
      case "style":
        Eg(o, f, S);
        break;
      case "data":
        if (i !== "object") {
          Fi(o, "data", f);
          break;
        }
      case "src":
      case "href":
        if (f === "" && (i !== "a" || u !== "href")) {
          o.removeAttribute(u);
          break;
        }
        if (f == null || typeof f == "function" || typeof f == "symbol" || typeof f == "boolean") {
          o.removeAttribute(u);
          break;
        }
        f = Hl("" + f), o.setAttribute(u, f);
        break;
      case "action":
      case "formAction":
        if (typeof f == "function") {
          o.setAttribute(
            u,
            "javascript:throw new Error('A React form was unexpectedly submitted. If you called form.submit() manually, consider using form.requestSubmit() instead. If you\\'re trying to use event.stopPropagation() in a submit event handler, consider also calling event.preventDefault().')"
          );
          break;
        } else
          typeof S == "function" && (u === "formAction" ? (i !== "input" && at(o, i, "name", g.name, g, null), at(
            o,
            i,
            "formEncType",
            g.formEncType,
            g,
            null
          ), at(
            o,
            i,
            "formMethod",
            g.formMethod,
            g,
            null
          ), at(
            o,
            i,
            "formTarget",
            g.formTarget,
            g,
            null
          )) : (at(o, i, "encType", g.encType, g, null), at(o, i, "method", g.method, g, null), at(o, i, "target", g.target, g, null)));
        if (f == null || typeof f == "symbol" || typeof f == "boolean") {
          o.removeAttribute(u);
          break;
        }
        f = Hl("" + f), o.setAttribute(u, f);
        break;
      case "onClick":
        f != null && (o.onclick = $r);
        break;
      case "onScroll":
        f != null && Be("scroll", o);
        break;
      case "onScrollEnd":
        f != null && Be("scrollend", o);
        break;
      case "dangerouslySetInnerHTML":
        if (f != null) {
          if (typeof f != "object" || !("__html" in f))
            throw Error(r(61));
          if (u = f.__html, u != null) {
            if (g.children != null) throw Error(r(60));
            o.innerHTML = u;
          }
        }
        break;
      case "multiple":
        o.multiple = f && typeof f != "function" && typeof f != "symbol";
        break;
      case "muted":
        o.muted = f && typeof f != "function" && typeof f != "symbol";
        break;
      case "suppressContentEditableWarning":
      case "suppressHydrationWarning":
      case "defaultValue":
      case "defaultChecked":
      case "innerHTML":
      case "ref":
        break;
      case "autoFocus":
        break;
      case "xlinkHref":
        if (f == null || typeof f == "function" || typeof f == "boolean" || typeof f == "symbol") {
          o.removeAttribute("xlink:href");
          break;
        }
        u = Hl("" + f), o.setAttributeNS(
          "http://www.w3.org/1999/xlink",
          "xlink:href",
          u
        );
        break;
      case "contentEditable":
      case "spellCheck":
      case "draggable":
      case "value":
      case "autoReverse":
      case "externalResourcesRequired":
      case "focusable":
      case "preserveAlpha":
        f != null && typeof f != "function" && typeof f != "symbol" ? o.setAttribute(u, "" + f) : o.removeAttribute(u);
        break;
      case "inert":
      case "allowFullScreen":
      case "async":
      case "autoPlay":
      case "controls":
      case "default":
      case "defer":
      case "disabled":
      case "disablePictureInPicture":
      case "disableRemotePlayback":
      case "formNoValidate":
      case "hidden":
      case "loop":
      case "noModule":
      case "noValidate":
      case "open":
      case "playsInline":
      case "readOnly":
      case "required":
      case "reversed":
      case "scoped":
      case "seamless":
      case "itemScope":
        f && typeof f != "function" && typeof f != "symbol" ? o.setAttribute(u, "") : o.removeAttribute(u);
        break;
      case "capture":
      case "download":
        f === !0 ? o.setAttribute(u, "") : f !== !1 && f != null && typeof f != "function" && typeof f != "symbol" ? o.setAttribute(u, f) : o.removeAttribute(u);
        break;
      case "cols":
      case "rows":
      case "size":
      case "span":
        f != null && typeof f != "function" && typeof f != "symbol" && !isNaN(f) && 1 <= f ? o.setAttribute(u, f) : o.removeAttribute(u);
        break;
      case "rowSpan":
      case "start":
        f == null || typeof f == "function" || typeof f == "symbol" || isNaN(f) ? o.removeAttribute(u) : o.setAttribute(u, f);
        break;
      case "popover":
        Be("beforetoggle", o), Be("toggle", o), zi(o, "popover", f);
        break;
      case "xlinkActuate":
        xr(
          o,
          "http://www.w3.org/1999/xlink",
          "xlink:actuate",
          f
        );
        break;
      case "xlinkArcrole":
        xr(
          o,
          "http://www.w3.org/1999/xlink",
          "xlink:arcrole",
          f
        );
        break;
      case "xlinkRole":
        xr(
          o,
          "http://www.w3.org/1999/xlink",
          "xlink:role",
          f
        );
        break;
      case "xlinkShow":
        xr(
          o,
          "http://www.w3.org/1999/xlink",
          "xlink:show",
          f
        );
        break;
      case "xlinkTitle":
        xr(
          o,
          "http://www.w3.org/1999/xlink",
          "xlink:title",
          f
        );
        break;
      case "xlinkType":
        xr(
          o,
          "http://www.w3.org/1999/xlink",
          "xlink:type",
          f
        );
        break;
      case "xmlBase":
        xr(
          o,
          "http://www.w3.org/XML/1998/namespace",
          "xml:base",
          f
        );
        break;
      case "xmlLang":
        xr(
          o,
          "http://www.w3.org/XML/1998/namespace",
          "xml:lang",
          f
        );
        break;
      case "xmlSpace":
        xr(
          o,
          "http://www.w3.org/XML/1998/namespace",
          "xml:space",
          f
        );
        break;
      case "is":
        zi(o, "is", f);
        break;
      case "innerText":
      case "textContent":
        break;
      default:
        (!(2 < u.length) || u[0] !== "o" && u[0] !== "O" || u[1] !== "n" && u[1] !== "N") && (u = LE.get(u) || u, zi(o, u, f));
    }
  }
  function xp(o, i, u, f, g, S) {
    switch (u) {
      case "style":
        Eg(o, f, S);
        break;
      case "dangerouslySetInnerHTML":
        if (f != null) {
          if (typeof f != "object" || !("__html" in f))
            throw Error(r(61));
          if (u = f.__html, u != null) {
            if (g.children != null) throw Error(r(60));
            o.innerHTML = u;
          }
        }
        break;
      case "children":
        typeof f == "string" ? Da(o, f) : (typeof f == "number" || typeof f == "bigint") && Da(o, "" + f);
        break;
      case "onScroll":
        f != null && Be("scroll", o);
        break;
      case "onScrollEnd":
        f != null && Be("scrollend", o);
        break;
      case "onClick":
        f != null && (o.onclick = $r);
        break;
      case "suppressContentEditableWarning":
      case "suppressHydrationWarning":
      case "innerHTML":
      case "ref":
        break;
      case "innerText":
      case "textContent":
        break;
      default:
        if (!Nd.hasOwnProperty(u))
          e: {
            if (u[0] === "o" && u[1] === "n" && (g = u.endsWith("Capture"), i = u.slice(2, g ? u.length - 7 : void 0), S = o[mn] || null, S = S != null ? S[u] : null, typeof S == "function" && o.removeEventListener(i, S, g), typeof f == "function")) {
              typeof S != "function" && S !== null && (u in o ? o[u] = null : o.hasAttribute(u) && o.removeAttribute(u)), o.addEventListener(i, f, g);
              break e;
            }
            u in o ? o[u] = f : f === !0 ? o.setAttribute(u, "") : zi(o, u, f);
          }
    }
  }
  function rn(o, i, u) {
    switch (i) {
      case "div":
      case "span":
      case "svg":
      case "path":
      case "a":
      case "g":
      case "p":
      case "li":
        break;
      case "img":
        Be("error", o), Be("load", o);
        var f = !1, g = !1, S;
        for (S in u)
          if (u.hasOwnProperty(S)) {
            var A = u[S];
            if (A != null)
              switch (S) {
                case "src":
                  f = !0;
                  break;
                case "srcSet":
                  g = !0;
                  break;
                case "children":
                case "dangerouslySetInnerHTML":
                  throw Error(r(137, i));
                default:
                  at(o, i, S, A, u, null);
              }
          }
        g && at(o, i, "srcSet", u.srcSet, u, null), f && at(o, i, "src", u.src, u, null);
        return;
      case "input":
        Be("invalid", o);
        var T = S = A = g = null, Y = null, ne = null;
        for (f in u)
          if (u.hasOwnProperty(f)) {
            var ue = u[f];
            if (ue != null)
              switch (f) {
                case "name":
                  g = ue;
                  break;
                case "type":
                  A = ue;
                  break;
                case "checked":
                  Y = ue;
                  break;
                case "defaultChecked":
                  ne = ue;
                  break;
                case "value":
                  S = ue;
                  break;
                case "defaultValue":
                  T = ue;
                  break;
                case "children":
                case "dangerouslySetInnerHTML":
                  if (ue != null)
                    throw Error(r(137, i));
                  break;
                default:
                  at(o, i, f, ue, u, null);
              }
          }
        Pd(
          o,
          S,
          T,
          Y,
          ne,
          A,
          g,
          !1
        );
        return;
      case "select":
        Be("invalid", o), f = A = S = null;
        for (g in u)
          if (u.hasOwnProperty(g) && (T = u[g], T != null))
            switch (g) {
              case "value":
                S = T;
                break;
              case "defaultValue":
                A = T;
                break;
              case "multiple":
                f = T;
              default:
                at(o, i, g, T, u, null);
            }
        i = S, u = A, o.multiple = !!f, i != null ? Fo(o, !!f, i, !1) : u != null && Fo(o, !!f, u, !0);
        return;
      case "textarea":
        Be("invalid", o), S = g = f = null;
        for (A in u)
          if (u.hasOwnProperty(A) && (T = u[A], T != null))
            switch (A) {
              case "value":
                f = T;
                break;
              case "defaultValue":
                g = T;
                break;
              case "children":
                S = T;
                break;
              case "dangerouslySetInnerHTML":
                if (T != null) throw Error(r(91));
                break;
              default:
                at(o, i, A, T, u, null);
            }
        kg(o, f, g, S);
        return;
      case "option":
        for (Y in u)
          u.hasOwnProperty(Y) && (f = u[Y], f != null) && (Y === "selected" ? o.selected = f && typeof f != "function" && typeof f != "symbol" : at(o, i, Y, f, u, null));
        return;
      case "dialog":
        Be("beforetoggle", o), Be("toggle", o), Be("cancel", o), Be("close", o);
        break;
      case "iframe":
      case "object":
        Be("load", o);
        break;
      case "video":
      case "audio":
        for (f = 0; f < ws.length; f++)
          Be(ws[f], o);
        break;
      case "image":
        Be("error", o), Be("load", o);
        break;
      case "details":
        Be("toggle", o);
        break;
      case "embed":
      case "source":
      case "link":
        Be("error", o), Be("load", o);
      case "area":
      case "base":
      case "br":
      case "col":
      case "hr":
      case "keygen":
      case "meta":
      case "param":
      case "track":
      case "wbr":
      case "menuitem":
        for (ne in u)
          if (u.hasOwnProperty(ne) && (f = u[ne], f != null))
            switch (ne) {
              case "children":
              case "dangerouslySetInnerHTML":
                throw Error(r(137, i));
              default:
                at(o, i, ne, f, u, null);
            }
        return;
      default:
        if (Dd(i)) {
          for (ue in u)
            u.hasOwnProperty(ue) && (f = u[ue], f !== void 0 && xp(
              o,
              i,
              ue,
              f,
              u,
              void 0
            ));
          return;
        }
    }
    for (T in u)
      u.hasOwnProperty(T) && (f = u[T], f != null && at(o, i, T, f, u, null));
  }
  function cO(o, i, u, f) {
    switch (i) {
      case "div":
      case "span":
      case "svg":
      case "path":
      case "a":
      case "g":
      case "p":
      case "li":
        break;
      case "input":
        var g = null, S = null, A = null, T = null, Y = null, ne = null, ue = null;
        for (ie in u) {
          var fe = u[ie];
          if (u.hasOwnProperty(ie) && fe != null)
            switch (ie) {
              case "checked":
                break;
              case "value":
                break;
              case "defaultValue":
                Y = fe;
              default:
                f.hasOwnProperty(ie) || at(o, i, ie, null, f, fe);
            }
        }
        for (var oe in f) {
          var ie = f[oe];
          if (fe = u[oe], f.hasOwnProperty(oe) && (ie != null || fe != null))
            switch (oe) {
              case "type":
                S = ie;
                break;
              case "name":
                g = ie;
                break;
              case "checked":
                ne = ie;
                break;
              case "defaultChecked":
                ue = ie;
                break;
              case "value":
                A = ie;
                break;
              case "defaultValue":
                T = ie;
                break;
              case "children":
              case "dangerouslySetInnerHTML":
                if (ie != null)
                  throw Error(r(137, i));
                break;
              default:
                ie !== fe && at(
                  o,
                  i,
                  oe,
                  ie,
                  f,
                  fe
                );
            }
        }
        Bi(
          o,
          A,
          T,
          Y,
          ne,
          ue,
          S,
          g
        );
        return;
      case "select":
        ie = A = T = oe = null;
        for (S in u)
          if (Y = u[S], u.hasOwnProperty(S) && Y != null)
            switch (S) {
              case "value":
                break;
              case "multiple":
                ie = Y;
              default:
                f.hasOwnProperty(S) || at(
                  o,
                  i,
                  S,
                  null,
                  f,
                  Y
                );
            }
        for (g in f)
          if (S = f[g], Y = u[g], f.hasOwnProperty(g) && (S != null || Y != null))
            switch (g) {
              case "value":
                oe = S;
                break;
              case "defaultValue":
                T = S;
                break;
              case "multiple":
                A = S;
              default:
                S !== Y && at(
                  o,
                  i,
                  g,
                  S,
                  f,
                  Y
                );
            }
        i = T, u = A, f = ie, oe != null ? Fo(o, !!u, oe, !1) : !!f != !!u && (i != null ? Fo(o, !!u, i, !0) : Fo(o, !!u, u ? [] : "", !1));
        return;
      case "textarea":
        ie = oe = null;
        for (T in u)
          if (g = u[T], u.hasOwnProperty(T) && g != null && !f.hasOwnProperty(T))
            switch (T) {
              case "value":
                break;
              case "children":
                break;
              default:
                at(o, i, T, null, f, g);
            }
        for (A in f)
          if (g = f[A], S = u[A], f.hasOwnProperty(A) && (g != null || S != null))
            switch (A) {
              case "value":
                oe = g;
                break;
              case "defaultValue":
                ie = g;
                break;
              case "children":
                break;
              case "dangerouslySetInnerHTML":
                if (g != null) throw Error(r(91));
                break;
              default:
                g !== S && at(o, i, A, g, f, S);
            }
        Sg(o, oe, ie);
        return;
      case "option":
        for (var we in u)
          oe = u[we], u.hasOwnProperty(we) && oe != null && !f.hasOwnProperty(we) && (we === "selected" ? o.selected = !1 : at(
            o,
            i,
            we,
            null,
            f,
            oe
          ));
        for (Y in f)
          oe = f[Y], ie = u[Y], f.hasOwnProperty(Y) && oe !== ie && (oe != null || ie != null) && (Y === "selected" ? o.selected = oe && typeof oe != "function" && typeof oe != "symbol" : at(
            o,
            i,
            Y,
            oe,
            f,
            ie
          ));
        return;
      case "img":
      case "link":
      case "area":
      case "base":
      case "br":
      case "col":
      case "embed":
      case "hr":
      case "keygen":
      case "meta":
      case "param":
      case "source":
      case "track":
      case "wbr":
      case "menuitem":
        for (var Ne in u)
          oe = u[Ne], u.hasOwnProperty(Ne) && oe != null && !f.hasOwnProperty(Ne) && at(o, i, Ne, null, f, oe);
        for (ne in f)
          if (oe = f[ne], ie = u[ne], f.hasOwnProperty(ne) && oe !== ie && (oe != null || ie != null))
            switch (ne) {
              case "children":
              case "dangerouslySetInnerHTML":
                if (oe != null)
                  throw Error(r(137, i));
                break;
              default:
                at(
                  o,
                  i,
                  ne,
                  oe,
                  f,
                  ie
                );
            }
        return;
      default:
        if (Dd(i)) {
          for (var it in u)
            oe = u[it], u.hasOwnProperty(it) && oe !== void 0 && !f.hasOwnProperty(it) && xp(
              o,
              i,
              it,
              void 0,
              f,
              oe
            );
          for (ue in f)
            oe = f[ue], ie = u[ue], !f.hasOwnProperty(ue) || oe === ie || oe === void 0 && ie === void 0 || xp(
              o,
              i,
              ue,
              oe,
              f,
              ie
            );
          return;
        }
    }
    for (var ee in u)
      oe = u[ee], u.hasOwnProperty(ee) && oe != null && !f.hasOwnProperty(ee) && at(o, i, ee, null, f, oe);
    for (fe in f)
      oe = f[fe], ie = u[fe], !f.hasOwnProperty(fe) || oe === ie || oe == null && ie == null || at(o, i, fe, oe, f, ie);
  }
  function Cb(o) {
    switch (o) {
      case "css":
      case "script":
      case "font":
      case "img":
      case "image":
      case "input":
      case "link":
        return !0;
      default:
        return !1;
    }
  }
  function dO() {
    if (typeof performance.getEntriesByType == "function") {
      for (var o = 0, i = 0, u = performance.getEntriesByType("resource"), f = 0; f < u.length; f++) {
        var g = u[f], S = g.transferSize, A = g.initiatorType, T = g.duration;
        if (S && T && Cb(A)) {
          for (A = 0, T = g.responseEnd, f += 1; f < u.length; f++) {
            var Y = u[f], ne = Y.startTime;
            if (ne > T) break;
            var ue = Y.transferSize, fe = Y.initiatorType;
            ue && Cb(fe) && (Y = Y.responseEnd, A += ue * (Y < T ? 1 : (T - ne) / (Y - ne)));
          }
          if (--f, i += 8 * (S + A) / (g.duration / 1e3), o++, 10 < o) break;
        }
      }
      if (0 < o) return i / o / 1e6;
    }
    return navigator.connection && (o = navigator.connection.downlink, typeof o == "number") ? o : 5;
  }
  var Sp = null, kp = null;
  function zu(o) {
    return o.nodeType === 9 ? o : o.ownerDocument;
  }
  function Ob(o) {
    switch (o) {
      case "http://www.w3.org/2000/svg":
        return 1;
      case "http://www.w3.org/1998/Math/MathML":
        return 2;
      default:
        return 0;
    }
  }
  function Mb(o, i) {
    if (o === 0)
      switch (i) {
        case "svg":
          return 1;
        case "math":
          return 2;
        default:
          return 0;
      }
    return o === 1 && i === "foreignObject" ? 0 : o;
  }
  function _p(o, i) {
    return o === "textarea" || o === "noscript" || typeof i.children == "string" || typeof i.children == "number" || typeof i.children == "bigint" || typeof i.dangerouslySetInnerHTML == "object" && i.dangerouslySetInnerHTML !== null && i.dangerouslySetInnerHTML.__html != null;
  }
  var Ep = null;
  function fO() {
    var o = window.event;
    return o && o.type === "popstate" ? o === Ep ? !1 : (Ep = o, !0) : (Ep = null, !1);
  }
  var Nb = typeof setTimeout == "function" ? setTimeout : void 0, pO = typeof clearTimeout == "function" ? clearTimeout : void 0, Rb = typeof Promise == "function" ? Promise : void 0, mO = typeof queueMicrotask == "function" ? queueMicrotask : typeof Rb < "u" ? function(o) {
    return Rb.resolve(null).then(o).catch(hO);
  } : Nb;
  function hO(o) {
    setTimeout(function() {
      throw o;
    });
  }
  function ko(o) {
    return o === "head";
  }
  function Ab(o, i) {
    var u = i, f = 0;
    do {
      var g = u.nextSibling;
      if (o.removeChild(u), g && g.nodeType === 8)
        if (u = g.data, u === "/$" || u === "/&") {
          if (f === 0) {
            o.removeChild(g), di(i);
            return;
          }
          f--;
        } else if (u === "$" || u === "$?" || u === "$~" || u === "$!" || u === "&")
          f++;
        else if (u === "html")
          Ss(o.ownerDocument.documentElement);
        else if (u === "head") {
          u = o.ownerDocument.head, Ss(u);
          for (var S = u.firstChild; S; ) {
            var A = S.nextSibling, T = S.nodeName;
            S[Pa] || T === "SCRIPT" || T === "STYLE" || T === "LINK" && S.rel.toLowerCase() === "stylesheet" || u.removeChild(S), S = A;
          }
        } else
          u === "body" && Ss(o.ownerDocument.body);
      u = g;
    } while (u);
    di(i);
  }
  function jb(o, i) {
    var u = o;
    o = 0;
    do {
      var f = u.nextSibling;
      if (u.nodeType === 1 ? i ? (u._stashedDisplay = u.style.display, u.style.display = "none") : (u.style.display = u._stashedDisplay || "", u.getAttribute("style") === "" && u.removeAttribute("style")) : u.nodeType === 3 && (i ? (u._stashedText = u.nodeValue, u.nodeValue = "") : u.nodeValue = u._stashedText || ""), f && f.nodeType === 8)
        if (u = f.data, u === "/$") {
          if (o === 0) break;
          o--;
        } else
          u !== "$" && u !== "$?" && u !== "$~" && u !== "$!" || o++;
      u = f;
    } while (u);
  }
  function Cp(o) {
    var i = o.firstChild;
    for (i && i.nodeType === 10 && (i = i.nextSibling); i; ) {
      var u = i;
      switch (i = i.nextSibling, u.nodeName) {
        case "HTML":
        case "HEAD":
        case "BODY":
          Cp(u), Ul(u);
          continue;
        case "SCRIPT":
        case "STYLE":
          continue;
        case "LINK":
          if (u.rel.toLowerCase() === "stylesheet") continue;
      }
      o.removeChild(u);
    }
  }
  function gO(o, i, u, f) {
    for (; o.nodeType === 1; ) {
      var g = u;
      if (o.nodeName.toLowerCase() !== i.toLowerCase()) {
        if (!f && (o.nodeName !== "INPUT" || o.type !== "hidden"))
          break;
      } else if (f) {
        if (!o[Pa])
          switch (i) {
            case "meta":
              if (!o.hasAttribute("itemprop")) break;
              return o;
            case "link":
              if (S = o.getAttribute("rel"), S === "stylesheet" && o.hasAttribute("data-precedence") || S !== g.rel || o.getAttribute("href") !== (g.href == null || g.href === "" ? null : g.href) || o.getAttribute("crossorigin") !== (g.crossOrigin == null ? null : g.crossOrigin) || o.getAttribute("title") !== (g.title == null ? null : g.title))
                break;
              return o;
            case "style":
              if (o.hasAttribute("data-precedence")) break;
              return o;
            case "script":
              if (S = o.getAttribute("src"), (S !== (g.src == null ? null : g.src) || o.getAttribute("type") !== (g.type == null ? null : g.type) || o.getAttribute("crossorigin") !== (g.crossOrigin == null ? null : g.crossOrigin)) && S && o.hasAttribute("async") && !o.hasAttribute("itemprop"))
                break;
              return o;
            default:
              return o;
          }
      } else if (i === "input" && o.type === "hidden") {
        var S = g.name == null ? null : "" + g.name;
        if (g.type === "hidden" && o.getAttribute("name") === S)
          return o;
      } else return o;
      if (o = rr(o.nextSibling), o === null) break;
    }
    return null;
  }
  function vO(o, i, u) {
    if (i === "") return null;
    for (; o.nodeType !== 3; )
      if ((o.nodeType !== 1 || o.nodeName !== "INPUT" || o.type !== "hidden") && !u || (o = rr(o.nextSibling), o === null)) return null;
    return o;
  }
  function Pb(o, i) {
    for (; o.nodeType !== 8; )
      if ((o.nodeType !== 1 || o.nodeName !== "INPUT" || o.type !== "hidden") && !i || (o = rr(o.nextSibling), o === null)) return null;
    return o;
  }
  function Op(o) {
    return o.data === "$?" || o.data === "$~";
  }
  function Mp(o) {
    return o.data === "$!" || o.data === "$?" && o.ownerDocument.readyState !== "loading";
  }
  function yO(o, i) {
    var u = o.ownerDocument;
    if (o.data === "$~") o._reactRetry = i;
    else if (o.data !== "$?" || u.readyState !== "loading")
      i();
    else {
      var f = function() {
        i(), u.removeEventListener("DOMContentLoaded", f);
      };
      u.addEventListener("DOMContentLoaded", f), o._reactRetry = f;
    }
  }
  function rr(o) {
    for (; o != null; o = o.nextSibling) {
      var i = o.nodeType;
      if (i === 1 || i === 3) break;
      if (i === 8) {
        if (i = o.data, i === "$" || i === "$!" || i === "$?" || i === "$~" || i === "&" || i === "F!" || i === "F")
          break;
        if (i === "/$" || i === "/&") return null;
      }
    }
    return o;
  }
  var Np = null;
  function Db(o) {
    o = o.nextSibling;
    for (var i = 0; o; ) {
      if (o.nodeType === 8) {
        var u = o.data;
        if (u === "/$" || u === "/&") {
          if (i === 0)
            return rr(o.nextSibling);
          i--;
        } else
          u !== "$" && u !== "$!" && u !== "$?" && u !== "$~" && u !== "&" || i++;
      }
      o = o.nextSibling;
    }
    return null;
  }
  function $b(o) {
    o = o.previousSibling;
    for (var i = 0; o; ) {
      if (o.nodeType === 8) {
        var u = o.data;
        if (u === "$" || u === "$!" || u === "$?" || u === "$~" || u === "&") {
          if (i === 0) return o;
          i--;
        } else u !== "/$" && u !== "/&" || i++;
      }
      o = o.previousSibling;
    }
    return null;
  }
  function Tb(o, i, u) {
    switch (i = zu(u), o) {
      case "html":
        if (o = i.documentElement, !o) throw Error(r(452));
        return o;
      case "head":
        if (o = i.head, !o) throw Error(r(453));
        return o;
      case "body":
        if (o = i.body, !o) throw Error(r(454));
        return o;
      default:
        throw Error(r(451));
    }
  }
  function Ss(o) {
    for (var i = o.attributes; i.length; )
      o.removeAttributeNode(i[0]);
    Ul(o);
  }
  var or = /* @__PURE__ */ new Map(), Lb = /* @__PURE__ */ new Set();
  function Fu(o) {
    return typeof o.getRootNode == "function" ? o.getRootNode() : o.nodeType === 9 ? o : o.ownerDocument;
  }
  var Qr = K.d;
  K.d = {
    f: bO,
    r: wO,
    D: xO,
    C: SO,
    L: kO,
    m: _O,
    X: CO,
    S: EO,
    M: OO
  };
  function bO() {
    var o = Qr.f(), i = Au();
    return o || i;
  }
  function wO(o) {
    var i = Jo(o);
    i !== null && i.tag === 5 && i.type === "form" ? ey(i) : Qr.r(o);
  }
  var li = typeof document > "u" ? null : document;
  function Ib(o, i, u) {
    var f = li;
    if (f && typeof i == "string" && i) {
      var g = Gn(i);
      g = 'link[rel="' + o + '"][href="' + g + '"]', typeof u == "string" && (g += '[crossorigin="' + u + '"]'), Lb.has(g) || (Lb.add(g), o = { rel: o, crossOrigin: u, href: i }, f.querySelector(g) === null && (i = f.createElement("link"), rn(i, "link", o), Bt(i), f.head.appendChild(i)));
    }
  }
  function xO(o) {
    Qr.D(o), Ib("dns-prefetch", o, null);
  }
  function SO(o, i) {
    Qr.C(o, i), Ib("preconnect", o, i);
  }
  function kO(o, i, u) {
    Qr.L(o, i, u);
    var f = li;
    if (f && o && i) {
      var g = 'link[rel="preload"][as="' + Gn(i) + '"]';
      i === "image" && u && u.imageSrcSet ? (g += '[imagesrcset="' + Gn(
        u.imageSrcSet
      ) + '"]', typeof u.imageSizes == "string" && (g += '[imagesizes="' + Gn(
        u.imageSizes
      ) + '"]')) : g += '[href="' + Gn(o) + '"]';
      var S = g;
      switch (i) {
        case "style":
          S = ui(o);
          break;
        case "script":
          S = ci(o);
      }
      or.has(S) || (o = h(
        {
          rel: "preload",
          href: i === "image" && u && u.imageSrcSet ? void 0 : o,
          as: i
        },
        u
      ), or.set(S, o), f.querySelector(g) !== null || i === "style" && f.querySelector(ks(S)) || i === "script" && f.querySelector(_s(S)) || (i = f.createElement("link"), rn(i, "link", o), Bt(i), f.head.appendChild(i)));
    }
  }
  function _O(o, i) {
    Qr.m(o, i);
    var u = li;
    if (u && o) {
      var f = i && typeof i.as == "string" ? i.as : "script", g = 'link[rel="modulepreload"][as="' + Gn(f) + '"][href="' + Gn(o) + '"]', S = g;
      switch (f) {
        case "audioworklet":
        case "paintworklet":
        case "serviceworker":
        case "sharedworker":
        case "worker":
        case "script":
          S = ci(o);
      }
      if (!or.has(S) && (o = h({ rel: "modulepreload", href: o }, i), or.set(S, o), u.querySelector(g) === null)) {
        switch (f) {
          case "audioworklet":
          case "paintworklet":
          case "serviceworker":
          case "sharedworker":
          case "worker":
          case "script":
            if (u.querySelector(_s(S)))
              return;
        }
        f = u.createElement("link"), rn(f, "link", o), Bt(f), u.head.appendChild(f);
      }
    }
  }
  function EO(o, i, u) {
    Qr.S(o, i, u);
    var f = li;
    if (f && o) {
      var g = Zo(f).hoistableStyles, S = ui(o);
      i = i || "default";
      var A = g.get(S);
      if (!A) {
        var T = { loading: 0, preload: null };
        if (A = f.querySelector(
          ks(S)
        ))
          T.loading = 5;
        else {
          o = h(
            { rel: "stylesheet", href: o, "data-precedence": i },
            u
          ), (u = or.get(S)) && Rp(o, u);
          var Y = A = f.createElement("link");
          Bt(Y), rn(Y, "link", o), Y._p = new Promise(function(ne, ue) {
            Y.onload = ne, Y.onerror = ue;
          }), Y.addEventListener("load", function() {
            T.loading |= 1;
          }), Y.addEventListener("error", function() {
            T.loading |= 2;
          }), T.loading |= 4, Bu(A, i, f);
        }
        A = {
          type: "stylesheet",
          instance: A,
          count: 1,
          state: T
        }, g.set(S, A);
      }
    }
  }
  function CO(o, i) {
    Qr.X(o, i);
    var u = li;
    if (u && o) {
      var f = Zo(u).hoistableScripts, g = ci(o), S = f.get(g);
      S || (S = u.querySelector(_s(g)), S || (o = h({ src: o, async: !0 }, i), (i = or.get(g)) && Ap(o, i), S = u.createElement("script"), Bt(S), rn(S, "link", o), u.head.appendChild(S)), S = {
        type: "script",
        instance: S,
        count: 1,
        state: null
      }, f.set(g, S));
    }
  }
  function OO(o, i) {
    Qr.M(o, i);
    var u = li;
    if (u && o) {
      var f = Zo(u).hoistableScripts, g = ci(o), S = f.get(g);
      S || (S = u.querySelector(_s(g)), S || (o = h({ src: o, async: !0, type: "module" }, i), (i = or.get(g)) && Ap(o, i), S = u.createElement("script"), Bt(S), rn(S, "link", o), u.head.appendChild(S)), S = {
        type: "script",
        instance: S,
        count: 1,
        state: null
      }, f.set(g, S));
    }
  }
  function zb(o, i, u, f) {
    var g = (g = re.current) ? Fu(g) : null;
    if (!g) throw Error(r(446));
    switch (o) {
      case "meta":
      case "title":
        return null;
      case "style":
        return typeof u.precedence == "string" && typeof u.href == "string" ? (i = ui(u.href), u = Zo(
          g
        ).hoistableStyles, f = u.get(i), f || (f = {
          type: "style",
          instance: null,
          count: 0,
          state: null
        }, u.set(i, f)), f) : { type: "void", instance: null, count: 0, state: null };
      case "link":
        if (u.rel === "stylesheet" && typeof u.href == "string" && typeof u.precedence == "string") {
          o = ui(u.href);
          var S = Zo(
            g
          ).hoistableStyles, A = S.get(o);
          if (A || (g = g.ownerDocument || g, A = {
            type: "stylesheet",
            instance: null,
            count: 0,
            state: { loading: 0, preload: null }
          }, S.set(o, A), (S = g.querySelector(
            ks(o)
          )) && !S._p && (A.instance = S, A.state.loading = 5), or.has(o) || (u = {
            rel: "preload",
            as: "style",
            href: u.href,
            crossOrigin: u.crossOrigin,
            integrity: u.integrity,
            media: u.media,
            hrefLang: u.hrefLang,
            referrerPolicy: u.referrerPolicy
          }, or.set(o, u), S || MO(
            g,
            o,
            u,
            A.state
          ))), i && f === null)
            throw Error(r(528, ""));
          return A;
        }
        if (i && f !== null)
          throw Error(r(529, ""));
        return null;
      case "script":
        return i = u.async, u = u.src, typeof u == "string" && i && typeof i != "function" && typeof i != "symbol" ? (i = ci(u), u = Zo(
          g
        ).hoistableScripts, f = u.get(i), f || (f = {
          type: "script",
          instance: null,
          count: 0,
          state: null
        }, u.set(i, f)), f) : { type: "void", instance: null, count: 0, state: null };
      default:
        throw Error(r(444, o));
    }
  }
  function ui(o) {
    return 'href="' + Gn(o) + '"';
  }
  function ks(o) {
    return 'link[rel="stylesheet"][' + o + "]";
  }
  function Fb(o) {
    return h({}, o, {
      "data-precedence": o.precedence,
      precedence: null
    });
  }
  function MO(o, i, u, f) {
    o.querySelector('link[rel="preload"][as="style"][' + i + "]") ? f.loading = 1 : (i = o.createElement("link"), f.preload = i, i.addEventListener("load", function() {
      return f.loading |= 1;
    }), i.addEventListener("error", function() {
      return f.loading |= 2;
    }), rn(i, "link", u), Bt(i), o.head.appendChild(i));
  }
  function ci(o) {
    return '[src="' + Gn(o) + '"]';
  }
  function _s(o) {
    return "script[async]" + o;
  }
  function Bb(o, i, u) {
    if (i.count++, i.instance === null)
      switch (i.type) {
        case "style":
          var f = o.querySelector(
            'style[data-href~="' + Gn(u.href) + '"]'
          );
          if (f)
            return i.instance = f, Bt(f), f;
          var g = h({}, u, {
            "data-href": u.href,
            "data-precedence": u.precedence,
            href: null,
            precedence: null
          });
          return f = (o.ownerDocument || o).createElement(
            "style"
          ), Bt(f), rn(f, "style", g), Bu(f, u.precedence, o), i.instance = f;
        case "stylesheet":
          g = ui(u.href);
          var S = o.querySelector(
            ks(g)
          );
          if (S)
            return i.state.loading |= 4, i.instance = S, Bt(S), S;
          f = Fb(u), (g = or.get(g)) && Rp(f, g), S = (o.ownerDocument || o).createElement("link"), Bt(S);
          var A = S;
          return A._p = new Promise(function(T, Y) {
            A.onload = T, A.onerror = Y;
          }), rn(S, "link", f), i.state.loading |= 4, Bu(S, u.precedence, o), i.instance = S;
        case "script":
          return S = ci(u.src), (g = o.querySelector(
            _s(S)
          )) ? (i.instance = g, Bt(g), g) : (f = u, (g = or.get(S)) && (f = h({}, u), Ap(f, g)), o = o.ownerDocument || o, g = o.createElement("script"), Bt(g), rn(g, "link", f), o.head.appendChild(g), i.instance = g);
        case "void":
          return null;
        default:
          throw Error(r(443, i.type));
      }
    else
      i.type === "stylesheet" && (i.state.loading & 4) === 0 && (f = i.instance, i.state.loading |= 4, Bu(f, u.precedence, o));
    return i.instance;
  }
  function Bu(o, i, u) {
    for (var f = u.querySelectorAll(
      'link[rel="stylesheet"][data-precedence],style[data-precedence]'
    ), g = f.length ? f[f.length - 1] : null, S = g, A = 0; A < f.length; A++) {
      var T = f[A];
      if (T.dataset.precedence === i) S = T;
      else if (S !== g) break;
    }
    S ? S.parentNode.insertBefore(o, S.nextSibling) : (i = u.nodeType === 9 ? u.head : u, i.insertBefore(o, i.firstChild));
  }
  function Rp(o, i) {
    o.crossOrigin == null && (o.crossOrigin = i.crossOrigin), o.referrerPolicy == null && (o.referrerPolicy = i.referrerPolicy), o.title == null && (o.title = i.title);
  }
  function Ap(o, i) {
    o.crossOrigin == null && (o.crossOrigin = i.crossOrigin), o.referrerPolicy == null && (o.referrerPolicy = i.referrerPolicy), o.integrity == null && (o.integrity = i.integrity);
  }
  var Uu = null;
  function Ub(o, i, u) {
    if (Uu === null) {
      var f = /* @__PURE__ */ new Map(), g = Uu = /* @__PURE__ */ new Map();
      g.set(u, f);
    } else
      g = Uu, f = g.get(u), f || (f = /* @__PURE__ */ new Map(), g.set(u, f));
    if (f.has(o)) return f;
    for (f.set(o, null), u = u.getElementsByTagName(o), g = 0; g < u.length; g++) {
      var S = u[g];
      if (!(S[Pa] || S[Yt] || o === "link" && S.getAttribute("rel") === "stylesheet") && S.namespaceURI !== "http://www.w3.org/2000/svg") {
        var A = S.getAttribute(i) || "";
        A = o + A;
        var T = f.get(A);
        T ? T.push(S) : f.set(A, [S]);
      }
    }
    return f;
  }
  function Vb(o, i, u) {
    o = o.ownerDocument || o, o.head.insertBefore(
      u,
      i === "title" ? o.querySelector("head > title") : null
    );
  }
  function NO(o, i, u) {
    if (u === 1 || i.itemProp != null) return !1;
    switch (o) {
      case "meta":
      case "title":
        return !0;
      case "style":
        if (typeof i.precedence != "string" || typeof i.href != "string" || i.href === "")
          break;
        return !0;
      case "link":
        if (typeof i.rel != "string" || typeof i.href != "string" || i.href === "" || i.onLoad || i.onError)
          break;
        return i.rel === "stylesheet" ? (o = i.disabled, typeof i.precedence == "string" && o == null) : !0;
      case "script":
        if (i.async && typeof i.async != "function" && typeof i.async != "symbol" && !i.onLoad && !i.onError && i.src && typeof i.src == "string")
          return !0;
    }
    return !1;
  }
  function Hb(o) {
    return !(o.type === "stylesheet" && (o.state.loading & 3) === 0);
  }
  function RO(o, i, u, f) {
    if (u.type === "stylesheet" && (typeof f.media != "string" || matchMedia(f.media).matches !== !1) && (u.state.loading & 4) === 0) {
      if (u.instance === null) {
        var g = ui(f.href), S = i.querySelector(
          ks(g)
        );
        if (S) {
          i = S._p, i !== null && typeof i == "object" && typeof i.then == "function" && (o.count++, o = Vu.bind(o), i.then(o, o)), u.state.loading |= 4, u.instance = S, Bt(S);
          return;
        }
        S = i.ownerDocument || i, f = Fb(f), (g = or.get(g)) && Rp(f, g), S = S.createElement("link"), Bt(S);
        var A = S;
        A._p = new Promise(function(T, Y) {
          A.onload = T, A.onerror = Y;
        }), rn(S, "link", f), u.instance = S;
      }
      o.stylesheets === null && (o.stylesheets = /* @__PURE__ */ new Map()), o.stylesheets.set(u, i), (i = u.state.preload) && (u.state.loading & 3) === 0 && (o.count++, u = Vu.bind(o), i.addEventListener("load", u), i.addEventListener("error", u));
    }
  }
  var jp = 0;
  function AO(o, i) {
    return o.stylesheets && o.count === 0 && qu(o, o.stylesheets), 0 < o.count || 0 < o.imgCount ? function(u) {
      var f = setTimeout(function() {
        if (o.stylesheets && qu(o, o.stylesheets), o.unsuspend) {
          var S = o.unsuspend;
          o.unsuspend = null, S();
        }
      }, 6e4 + i);
      0 < o.imgBytes && jp === 0 && (jp = 62500 * dO());
      var g = setTimeout(
        function() {
          if (o.waitingForImages = !1, o.count === 0 && (o.stylesheets && qu(o, o.stylesheets), o.unsuspend)) {
            var S = o.unsuspend;
            o.unsuspend = null, S();
          }
        },
        (o.imgBytes > jp ? 50 : 800) + i
      );
      return o.unsuspend = u, function() {
        o.unsuspend = null, clearTimeout(f), clearTimeout(g);
      };
    } : null;
  }
  function Vu() {
    if (this.count--, this.count === 0 && (this.imgCount === 0 || !this.waitingForImages)) {
      if (this.stylesheets) qu(this, this.stylesheets);
      else if (this.unsuspend) {
        var o = this.unsuspend;
        this.unsuspend = null, o();
      }
    }
  }
  var Hu = null;
  function qu(o, i) {
    o.stylesheets = null, o.unsuspend !== null && (o.count++, Hu = /* @__PURE__ */ new Map(), i.forEach(jO, o), Hu = null, Vu.call(o));
  }
  function jO(o, i) {
    if (!(i.state.loading & 4)) {
      var u = Hu.get(o);
      if (u) var f = u.get(null);
      else {
        u = /* @__PURE__ */ new Map(), Hu.set(o, u);
        for (var g = o.querySelectorAll(
          "link[data-precedence],style[data-precedence]"
        ), S = 0; S < g.length; S++) {
          var A = g[S];
          (A.nodeName === "LINK" || A.getAttribute("media") !== "not all") && (u.set(A.dataset.precedence, A), f = A);
        }
        f && u.set(null, f);
      }
      g = i.instance, A = g.getAttribute("data-precedence"), S = u.get(A) || f, S === f && u.set(null, g), u.set(A, g), this.count++, f = Vu.bind(this), g.addEventListener("load", f), g.addEventListener("error", f), S ? S.parentNode.insertBefore(g, S.nextSibling) : (o = o.nodeType === 9 ? o.head : o, o.insertBefore(g, o.firstChild)), i.state.loading |= 4;
    }
  }
  var Es = {
    $$typeof: _,
    Provider: null,
    Consumer: null,
    _currentValue: q,
    _currentValue2: q,
    _threadCount: 0
  };
  function PO(o, i, u, f, g, S, A, T, Y) {
    this.tag = 1, this.containerInfo = o, this.pingCache = this.current = this.pendingChildren = null, this.timeoutHandle = -1, this.callbackNode = this.next = this.pendingContext = this.context = this.cancelPendingCommit = null, this.callbackPriority = 0, this.expirationTimes = zl(-1), this.entangledLanes = this.shellSuspendCounter = this.errorRecoveryDisabledLanes = this.expiredLanes = this.warmLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0, this.entanglements = zl(0), this.hiddenUpdates = zl(null), this.identifierPrefix = f, this.onUncaughtError = g, this.onCaughtError = S, this.onRecoverableError = A, this.pooledCache = null, this.pooledCacheLanes = 0, this.formState = Y, this.incompleteTransitions = /* @__PURE__ */ new Map();
  }
  function qb(o, i, u, f, g, S, A, T, Y, ne, ue, fe) {
    return o = new PO(
      o,
      i,
      u,
      A,
      Y,
      ne,
      ue,
      fe,
      T
    ), i = 1, S === !0 && (i |= 24), S = In(3, null, null, i), o.current = S, S.stateNode = o, i = df(), i.refCount++, o.pooledCache = i, i.refCount++, S.memoizedState = {
      element: f,
      isDehydrated: u,
      cache: i
    }, hf(S), o;
  }
  function Wb(o) {
    return o ? (o = Ba, o) : Ba;
  }
  function Gb(o, i, u, f, g, S) {
    g = Wb(g), f.context === null ? f.context = g : f.pendingContext = g, f = fo(i), f.payload = { element: u }, S = S === void 0 ? null : S, S !== null && (f.callback = S), u = po(o, f, i), u !== null && (Nn(u, o, i), rs(u, o, i));
  }
  function Kb(o, i) {
    if (o = o.memoizedState, o !== null && o.dehydrated !== null) {
      var u = o.retryLane;
      o.retryLane = u !== 0 && u < i ? u : i;
    }
  }
  function Pp(o, i) {
    Kb(o, i), (o = o.alternate) && Kb(o, i);
  }
  function Xb(o) {
    if (o.tag === 13 || o.tag === 31) {
      var i = oa(o, 67108864);
      i !== null && Nn(i, o, 67108864), Pp(o, 67108864);
    }
  }
  function Yb(o) {
    if (o.tag === 13 || o.tag === 31) {
      var i = Vn();
      i = Fl(i);
      var u = oa(o, i);
      u !== null && Nn(u, o, i), Pp(o, i);
    }
  }
  var Wu = !0;
  function DO(o, i, u, f) {
    var g = L.T;
    L.T = null;
    var S = K.p;
    try {
      K.p = 2, Dp(o, i, u, f);
    } finally {
      K.p = S, L.T = g;
    }
  }
  function $O(o, i, u, f) {
    var g = L.T;
    L.T = null;
    var S = K.p;
    try {
      K.p = 8, Dp(o, i, u, f);
    } finally {
      K.p = S, L.T = g;
    }
  }
  function Dp(o, i, u, f) {
    if (Wu) {
      var g = $p(f);
      if (g === null)
        wp(
          o,
          i,
          f,
          Gu,
          u
        ), Jb(o, f);
      else if (LO(
        g,
        o,
        i,
        u,
        f
      ))
        f.stopPropagation();
      else if (Jb(o, f), i & 4 && -1 < TO.indexOf(o)) {
        for (; g !== null; ) {
          var S = Jo(g);
          if (S !== null)
            switch (S.tag) {
              case 3:
                if (S = S.stateNode, S.current.memoizedState.isDehydrated) {
                  var A = wr(S.pendingLanes);
                  if (A !== 0) {
                    var T = S;
                    for (T.pendingLanes |= 2, T.entangledLanes |= 2; A; ) {
                      var Y = 1 << 31 - Re(A);
                      T.entanglements[1] |= Y, A &= ~Y;
                    }
                    Er(S), (Je & 6) === 0 && (Nu = Ce() + 500, bs(0));
                  }
                }
                break;
              case 31:
              case 13:
                T = oa(S, 2), T !== null && Nn(T, S, 2), Au(), Pp(S, 2);
            }
          if (S = $p(f), S === null && wp(
            o,
            i,
            f,
            Gu,
            u
          ), S === g) break;
          g = S;
        }
        g !== null && f.stopPropagation();
      } else
        wp(
          o,
          i,
          f,
          null,
          u
        );
    }
  }
  function $p(o) {
    return o = Td(o), Tp(o);
  }
  var Gu = null;
  function Tp(o) {
    if (Gu = null, o = Qo(o), o !== null) {
      var i = s(o);
      if (i === null) o = null;
      else {
        var u = i.tag;
        if (u === 13) {
          if (o = l(i), o !== null) return o;
          o = null;
        } else if (u === 31) {
          if (o = c(i), o !== null) return o;
          o = null;
        } else if (u === 3) {
          if (i.stateNode.current.memoizedState.isDehydrated)
            return i.tag === 3 ? i.stateNode.containerInfo : null;
          o = null;
        } else i !== o && (o = null);
      }
    }
    return Gu = o, null;
  }
  function Qb(o) {
    switch (o) {
      case "beforetoggle":
      case "cancel":
      case "click":
      case "close":
      case "contextmenu":
      case "copy":
      case "cut":
      case "auxclick":
      case "dblclick":
      case "dragend":
      case "dragstart":
      case "drop":
      case "focusin":
      case "focusout":
      case "input":
      case "invalid":
      case "keydown":
      case "keypress":
      case "keyup":
      case "mousedown":
      case "mouseup":
      case "paste":
      case "pause":
      case "play":
      case "pointercancel":
      case "pointerdown":
      case "pointerup":
      case "ratechange":
      case "reset":
      case "resize":
      case "seeked":
      case "submit":
      case "toggle":
      case "touchcancel":
      case "touchend":
      case "touchstart":
      case "volumechange":
      case "change":
      case "selectionchange":
      case "textInput":
      case "compositionstart":
      case "compositionend":
      case "compositionupdate":
      case "beforeblur":
      case "afterblur":
      case "beforeinput":
      case "blur":
      case "fullscreenchange":
      case "focus":
      case "hashchange":
      case "popstate":
      case "select":
      case "selectstart":
        return 2;
      case "drag":
      case "dragenter":
      case "dragexit":
      case "dragleave":
      case "dragover":
      case "mousemove":
      case "mouseout":
      case "mouseover":
      case "pointermove":
      case "pointerout":
      case "pointerover":
      case "scroll":
      case "touchmove":
      case "wheel":
      case "mouseenter":
      case "mouseleave":
      case "pointerenter":
      case "pointerleave":
        return 8;
      case "message":
        switch (Me()) {
          case he:
            return 2;
          case ye:
            return 8;
          case Ee:
          case Le:
            return 32;
          case ze:
            return 268435456;
          default:
            return 32;
        }
      default:
        return 32;
    }
  }
  var Lp = !1, _o = null, Eo = null, Co = null, Cs = /* @__PURE__ */ new Map(), Os = /* @__PURE__ */ new Map(), Oo = [], TO = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset".split(
    " "
  );
  function Jb(o, i) {
    switch (o) {
      case "focusin":
      case "focusout":
        _o = null;
        break;
      case "dragenter":
      case "dragleave":
        Eo = null;
        break;
      case "mouseover":
      case "mouseout":
        Co = null;
        break;
      case "pointerover":
      case "pointerout":
        Cs.delete(i.pointerId);
        break;
      case "gotpointercapture":
      case "lostpointercapture":
        Os.delete(i.pointerId);
    }
  }
  function Ms(o, i, u, f, g, S) {
    return o === null || o.nativeEvent !== S ? (o = {
      blockedOn: i,
      domEventName: u,
      eventSystemFlags: f,
      nativeEvent: S,
      targetContainers: [g]
    }, i !== null && (i = Jo(i), i !== null && Xb(i)), o) : (o.eventSystemFlags |= f, i = o.targetContainers, g !== null && i.indexOf(g) === -1 && i.push(g), o);
  }
  function LO(o, i, u, f, g) {
    switch (i) {
      case "focusin":
        return _o = Ms(
          _o,
          o,
          i,
          u,
          f,
          g
        ), !0;
      case "dragenter":
        return Eo = Ms(
          Eo,
          o,
          i,
          u,
          f,
          g
        ), !0;
      case "mouseover":
        return Co = Ms(
          Co,
          o,
          i,
          u,
          f,
          g
        ), !0;
      case "pointerover":
        var S = g.pointerId;
        return Cs.set(
          S,
          Ms(
            Cs.get(S) || null,
            o,
            i,
            u,
            f,
            g
          )
        ), !0;
      case "gotpointercapture":
        return S = g.pointerId, Os.set(
          S,
          Ms(
            Os.get(S) || null,
            o,
            i,
            u,
            f,
            g
          )
        ), !0;
    }
    return !1;
  }
  function Zb(o) {
    var i = Qo(o.target);
    if (i !== null) {
      var u = s(i);
      if (u !== null) {
        if (i = u.tag, i === 13) {
          if (i = l(u), i !== null) {
            o.blockedOn = i, Cd(o.priority, function() {
              Yb(u);
            });
            return;
          }
        } else if (i === 31) {
          if (i = c(u), i !== null) {
            o.blockedOn = i, Cd(o.priority, function() {
              Yb(u);
            });
            return;
          }
        } else if (i === 3 && u.stateNode.current.memoizedState.isDehydrated) {
          o.blockedOn = u.tag === 3 ? u.stateNode.containerInfo : null;
          return;
        }
      }
    }
    o.blockedOn = null;
  }
  function Ku(o) {
    if (o.blockedOn !== null) return !1;
    for (var i = o.targetContainers; 0 < i.length; ) {
      var u = $p(o.nativeEvent);
      if (u === null) {
        u = o.nativeEvent;
        var f = new u.constructor(
          u.type,
          u
        );
        $d = f, u.target.dispatchEvent(f), $d = null;
      } else
        return i = Jo(u), i !== null && Xb(i), o.blockedOn = u, !1;
      i.shift();
    }
    return !0;
  }
  function ew(o, i, u) {
    Ku(o) && u.delete(i);
  }
  function IO() {
    Lp = !1, _o !== null && Ku(_o) && (_o = null), Eo !== null && Ku(Eo) && (Eo = null), Co !== null && Ku(Co) && (Co = null), Cs.forEach(ew), Os.forEach(ew);
  }
  function Xu(o, i) {
    o.blockedOn === i && (o.blockedOn = null, Lp || (Lp = !0, e.unstable_scheduleCallback(
      e.unstable_NormalPriority,
      IO
    )));
  }
  var Yu = null;
  function tw(o) {
    Yu !== o && (Yu = o, e.unstable_scheduleCallback(
      e.unstable_NormalPriority,
      function() {
        Yu === o && (Yu = null);
        for (var i = 0; i < o.length; i += 3) {
          var u = o[i], f = o[i + 1], g = o[i + 2];
          if (typeof f != "function") {
            if (Tp(f || u) === null)
              continue;
            break;
          }
          var S = Jo(u);
          S !== null && (o.splice(i, 3), i -= 3, $f(
            S,
            {
              pending: !0,
              data: g,
              method: u.method,
              action: f
            },
            f,
            g
          ));
        }
      }
    ));
  }
  function di(o) {
    function i(Y) {
      return Xu(Y, o);
    }
    _o !== null && Xu(_o, o), Eo !== null && Xu(Eo, o), Co !== null && Xu(Co, o), Cs.forEach(i), Os.forEach(i);
    for (var u = 0; u < Oo.length; u++) {
      var f = Oo[u];
      f.blockedOn === o && (f.blockedOn = null);
    }
    for (; 0 < Oo.length && (u = Oo[0], u.blockedOn === null); )
      Zb(u), u.blockedOn === null && Oo.shift();
    if (u = (o.ownerDocument || o).$$reactFormReplay, u != null)
      for (f = 0; f < u.length; f += 3) {
        var g = u[f], S = u[f + 1], A = g[mn] || null;
        if (typeof S == "function")
          A || tw(u);
        else if (A) {
          var T = null;
          if (S && S.hasAttribute("formAction")) {
            if (g = S, A = S[mn] || null)
              T = A.formAction;
            else if (Tp(g) !== null) continue;
          } else T = A.action;
          typeof T == "function" ? u[f + 1] = T : (u.splice(f, 3), f -= 3), tw(u);
        }
      }
  }
  function nw() {
    function o(S) {
      S.canIntercept && S.info === "react-transition" && S.intercept({
        handler: function() {
          return new Promise(function(A) {
            return g = A;
          });
        },
        focusReset: "manual",
        scroll: "manual"
      });
    }
    function i() {
      g !== null && (g(), g = null), f || setTimeout(u, 20);
    }
    function u() {
      if (!f && !navigation.transition) {
        var S = navigation.currentEntry;
        S && S.url != null && navigation.navigate(S.url, {
          state: S.getState(),
          info: "react-transition",
          history: "replace"
        });
      }
    }
    if (typeof navigation == "object") {
      var f = !1, g = null;
      return navigation.addEventListener("navigate", o), navigation.addEventListener("navigatesuccess", i), navigation.addEventListener("navigateerror", i), setTimeout(u, 100), function() {
        f = !0, navigation.removeEventListener("navigate", o), navigation.removeEventListener("navigatesuccess", i), navigation.removeEventListener("navigateerror", i), g !== null && (g(), g = null);
      };
    }
  }
  function Ip(o) {
    this._internalRoot = o;
  }
  Qu.prototype.render = Ip.prototype.render = function(o) {
    var i = this._internalRoot;
    if (i === null) throw Error(r(409));
    var u = i.current, f = Vn();
    Gb(u, f, o, i, null, null);
  }, Qu.prototype.unmount = Ip.prototype.unmount = function() {
    var o = this._internalRoot;
    if (o !== null) {
      this._internalRoot = null;
      var i = o.containerInfo;
      Gb(o.current, 2, null, o, null, null), Au(), i[zo] = null;
    }
  };
  function Qu(o) {
    this._internalRoot = o;
  }
  Qu.prototype.unstable_scheduleHydration = function(o) {
    if (o) {
      var i = Ed();
      o = { blockedOn: null, target: o, priority: i };
      for (var u = 0; u < Oo.length && i !== 0 && i < Oo[u].priority; u++) ;
      Oo.splice(u, 0, o), u === 0 && Zb(o);
    }
  };
  var rw = t.version;
  if (rw !== "19.2.3")
    throw Error(
      r(
        527,
        rw,
        "19.2.3"
      )
    );
  K.findDOMNode = function(o) {
    var i = o._reactInternals;
    if (i === void 0)
      throw typeof o.render == "function" ? Error(r(188)) : (o = Object.keys(o).join(","), Error(r(268, o)));
    return o = p(i), o = o !== null ? m(o) : null, o = o === null ? null : o.stateNode, o;
  };
  var zO = {
    bundleType: 0,
    version: "19.2.3",
    rendererPackageName: "react-dom",
    currentDispatcherRef: L,
    reconcilerVersion: "19.2.3"
  };
  if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u") {
    var Ju = __REACT_DEVTOOLS_GLOBAL_HOOK__;
    if (!Ju.isDisabled && Ju.supportsFiber)
      try {
        Wt = Ju.inject(
          zO
        ), Ot = Ju;
      } catch {
      }
  }
  return iw.createRoot = function(o, i) {
    if (!a(o)) throw Error(r(299));
    var u = !1, f = "", g = cy, S = dy, A = fy;
    return i != null && (i.unstable_strictMode === !0 && (u = !0), i.identifierPrefix !== void 0 && (f = i.identifierPrefix), i.onUncaughtError !== void 0 && (g = i.onUncaughtError), i.onCaughtError !== void 0 && (S = i.onCaughtError), i.onRecoverableError !== void 0 && (A = i.onRecoverableError)), i = qb(
      o,
      1,
      !1,
      null,
      null,
      u,
      f,
      null,
      g,
      S,
      A,
      nw
    ), o[zo] = i.current, bp(o), new Ip(i);
  }, iw.hydrateRoot = function(o, i, u) {
    if (!a(o)) throw Error(r(299));
    var f = !1, g = "", S = cy, A = dy, T = fy, Y = null;
    return u != null && (u.unstable_strictMode === !0 && (f = !0), u.identifierPrefix !== void 0 && (g = u.identifierPrefix), u.onUncaughtError !== void 0 && (S = u.onUncaughtError), u.onCaughtError !== void 0 && (A = u.onCaughtError), u.onRecoverableError !== void 0 && (T = u.onRecoverableError), u.formState !== void 0 && (Y = u.formState)), i = qb(
      o,
      1,
      !0,
      i,
      u ?? null,
      f,
      g,
      Y,
      S,
      A,
      T,
      nw
    ), i.context = Wb(null), u = i.current, f = Vn(), f = Fl(f), g = fo(f), g.callback = null, po(u, g, f), u = f, i.current.lanes = u, ja(i, u), Er(i), o[zo] = i.current, bp(o), new Qu(i);
  }, iw.version = "19.2.3", iw;
}
var Nj;
function CK() {
  if (Nj) return HO.exports;
  Nj = 1;
  function e() {
    if (!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != "function"))
      try {
        __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(e);
      } catch (t) {
        console.error(t);
      }
  }
  return e(), HO.exports = EK(), HO.exports;
}
var OK = CK();
const Zr = {
  /** Debug level - most verbose, for development debugging */
  DEBUG: 0,
  /** Info level - general information about application flow */
  INFO: 10,
  /** Warning level - concerning but non-critical issues */
  WARN: 20,
  /** Error level - critical problems requiring attention */
  ERROR: 30
}, x1 = Zr.DEBUG, S1 = Zr.INFO, MK = Zr.WARN, NK = Zr.ERROR, Rj = (e) => typeof e == "string" ? e : e === Zr.DEBUG ? "DEBUG" : e === Zr.INFO ? "INFO" : e === Zr.WARN ? "WARN" : e === Zr.ERROR ? "ERROR" : "UNKNOWN";
function RK() {
  const e = [];
  return function(t, n) {
    if (typeof n != "object" || n === null)
      return n;
    for (; e.length > 0 && e.at(-1) !== this; )
      e.pop();
    return e.includes(n) ? "[Circular]" : (e.push(n), n);
  };
}
const Aj = (e) => {
  if (typeof e == "number") return e;
  const t = e.toLowerCase();
  if (t === "debug") return Zr.DEBUG;
  if (t === "info") return Zr.INFO;
  if (t === "warn" || t === "warning") return Zr.WARN;
  if (t === "error") return Zr.ERROR;
  throw new Error(`Unknown log level: ${e}`);
};
class D3 {
  /**
   * Create a new BaseLogger instance.
   *
   * @param {string} name - The name/identifier for this logger
   * @param {number | string} [level=LEVELS.INFO] - Initial log level
   * @param {boolean} [with_timestamp=true] - Whether to include timestamps
   * @example
   * ```typescript
   * const logger = new MyLogger("DatabaseService", "DEBUG", true);
   * ```
   */
  constructor(t, n = Zr.INFO, r = !0) {
    this.name = t, this.level = Aj(n), this._level_name = Rj(this.level), this.with_timestamp = r;
  }
  /**
   * Set the logging level for this logger instance.
   *
   * @param {number | string} level - The new log level (numeric or string)
   * @example
   * ```typescript
   * logger.set_level(DEBUG); // Enable debug logging
   * logger.set_level("debug"); // Same as above using string
   * ```
   */
  set_level(t) {
    typeof t == "string" && (t = Aj(t)), this.level = t, this._level_name = Rj(this.level);
  }
  /**
   * Get the string representation of the current log level.
   *
   * @returns {string} The current log level as a string
   * @example
   * ```typescript
   * logger.level_name // "INFO"
   * ```
   */
  get level_name() {
    return this._level_name;
  }
  /**
   * Format a log message with level, timestamp, and arguments.
   *
   * @param {string} levelstring - The log level string (DEBUG, INFO, etc.)
   * @param {string} message - The primary log message
   * @param {...any[]} args - Additional arguments to include
   * @returns {string} The formatted log message
   * @example
   * ```typescript
   * // Returns: "12/25/2023, 10:30:15 AM [MyApp] INFO: User logged in {userId: 123}"
   * logger.format_message("INFO", "User logged in", {userId: 123});
   * ```
   */
  format_message(t, n, ...r) {
    return `${this.with_timestamp ? (/* @__PURE__ */ new Date()).toLocaleString() : ""} [${this.name}] ${t}: ${n} ${r.map((a) => JSON.stringify(a, RK())).join(" ")}`.trim();
  }
  /**
   * Log a debug message if the current level allows it.
   *
   * @param {string} message - The primary log message
   * @param {...any[]} args - Additional context arguments
   */
  debug(t, ...n) {
    this.level <= Zr.DEBUG && this.out_debug(this.format_message("DEBUG", t, ...n));
  }
  /**
   * Log an info message if the current level allows it.
   *
   * @param {string} message - The primary log message
   * @param {...any[]} args - Additional context arguments
   */
  info(t, ...n) {
    this.level <= Zr.INFO && this.out_info(this.format_message("INFO", t, ...n));
  }
  /**
   * Log a warning message if the current level allows it.
   *
   * @param {string} message - The primary log message
   * @param {...any[]} args - Additional context arguments
   */
  warn(t, ...n) {
    this.level <= Zr.WARN && this.out_warn(this.format_message("WARN", t, ...n));
  }
  /**
   * Log an error message if the current level allows it.
   *
   * @param {string} message - The primary log message
   * @param {Error} [error] - Optional Error object for stack trace handling
   */
  error(t, n) {
    this.level <= Zr.ERROR && this.out_error(this.format_message("ERROR", t), n);
  }
}
class $3 extends D3 {
  /**
   * Create a new ConsoleLogger instance.
   *
   * @param {string} name - The name/identifier for this logger
   * @param {number | string} [level=LEVELS.INFO] - Initial log level
   * @example
   * ```typescript
   * const logger = new ConsoleLogger("API", "WARN");
   * ```
   */
  constructor(t, n = Zr.INFO) {
    super(t, n);
  }
  /**
   * Output debug message to console.debug.
   *
   * @protected
   * @param {string} formatted_message - The formatted message to output
   */
  out_debug(t) {
    console.debug(t);
  }
  /**
   * Output info message to console.info.
   *
   * @protected
   * @param {string} formatted_message - The formatted message to output
   */
  out_info(t) {
    console.info(t);
  }
  /**
   * Output warning message to console.warn.
   *
   * @protected
   * @param {string} formatted_message - The formatted message to output
   */
  out_warn(t) {
    console.warn(t);
  }
  /**
   * Output error message to console.error.
   *
   * @protected
   * @param {string} formatted_message - The formatted message to output
   * @param {Error | undefined} error - Optional Error object for stack trace handling
   */
  out_error(t, n) {
    console.error(t), n && console.error(n);
  }
}
function qO(e) {
  return e.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#039;");
}
class AK extends D3 {
  /**
   * Create a new DivLogger instance.
   *
   * @param {HTMLDivElement} div - The HTML div element to append log messages to
   * @param {string} name - The name/identifier for this logger
   * @param {number | string} [level=LEVELS.INFO] - Initial log level
   * @example
   * ```typescript
   * const logContainer = document.createElement('div');
   * const logger = new DivLogger(logContainer, "WebWorker", "DEBUG");
   * ```
   */
  constructor(t, n, r = Zr.INFO) {
    super(n, r), this._div = t;
  }
  /**
   * Format a log message with HTML escaping for safe DOM insertion.
   *
   * Overrides the base implementation to automatically escape HTML content,
   * preventing XSS vulnerabilities when displaying logs in web interfaces.
   *
   * @param {string} levelstring - The log level string (DEBUG, INFO, etc.)
   * @param {string} message - The primary log message
   * @param {...any[]} args - Additional arguments to include
   * @returns {string} The formatted and HTML-escaped log message
   * @example
   * ```typescript
   * // Input: "User input: <script>alert('xss')<\/script>"
   * // Output: "12/25/2023, 10:30:15 AM [UI] INFO: User input: &lt;script&gt;alert('xss')&lt;/script&gt;"
   * ```
   */
  format_message(t, n, ...r) {
    return qO(super.format_message(t, n, ...r));
  }
  /**
   * Output debug message as HTML div with 'debug' class.
   *
   * @protected
   * @param {string} formatted_message - The pre-formatted and HTML-escaped message to output
   */
  out_debug(t) {
    this._div.innerHTML += `<div class="debug">${t}</div>`;
  }
  /**
   * Output info message as HTML div with 'info' class.
   *
   * @protected
   * @param {string} formatted_message - The pre-formatted and HTML-escaped message to output
   */
  out_info(t) {
    this._div.innerHTML += `<div class="info">${t}</div>`;
  }
  /**
   * Output warning message as HTML div with 'warn' class.
   *
   * @protected
   * @param {string} formatted_message - The pre-formatted and HTML-escaped message to output
   */
  out_warn(t) {
    this._div.innerHTML += `<div class="warn">${t}</div>`;
  }
  /**
   * Output error message as HTML div with 'error' class.
   *
   * @protected
   * @param {string} formatted_message - The pre-formatted and HTML-escaped message to output
   * @param {Error | undefined} error - Optional Error object for stack trace handling
   */
  out_error(t, n) {
    let r = t;
    if (n) {
      const a = n.stack ? qO(n.stack) : qO(n.message);
      r += `<br><pre>${a}</pre>`;
    }
    this._div.innerHTML += `<div class="error">${r}</div>`;
  }
}
function jK(e) {
  const t = window.atob(e), n = t.length, r = new Uint8Array(n);
  for (let a = 0; a < n; a++)
    r[a] = t.charCodeAt(a);
  return r;
}
function PK(e, t) {
  return new Blob([e], { type: t });
}
function DK(e, t) {
  return PK(jK(e), t);
}
function $K(e, t, n) {
  const r = DK(e, n), a = URL.createObjectURL(r), s = document.createElement("a");
  s.href = a, s.download = t, s.click(), URL.revokeObjectURL(a), s.remove();
}
function TK(e, t = !0) {
  return new Promise((n, r) => {
    const a = new FileReader();
    a.onload = () => {
      const s = a.result;
      n(t ? s.split(",")[1] : s);
    }, a.onerror = () => r(a.error), a.readAsDataURL(e);
  });
}
function LK(e) {
  return new Promise((t, n) => {
    const r = document.createElement("input");
    r.type = "file", r.accept = e, r.onchange = () => {
      const a = r.files?.[0];
      a ? t(a) : n(new Error("No file selected"));
    }, r.oncancel = () => {
      n(new Error("File selection cancelled"));
    }, r.click();
  });
}
function IK(e) {
  return LK(e).then(TK);
}
async function zK(e, t = !0) {
  try {
    const n = await fetch(e);
    if (!n.ok)
      throw new Error(
        `Failed to fetch from URL: ${n.status} ${n.statusText}`
      );
    const r = await n.blob();
    return await new Promise((a, s) => {
      const l = new FileReader();
      l.onload = () => {
        const c = l.result;
        typeof c != "string" && (s("Failed to convert URL to Base64: No result from FileReader"), s(l.error)), a(t ? c.split(",")[1] : c);
      }, l.onerror = () => s(l.error), l.readAsDataURL(r);
    });
  } catch (n) {
    throw console.error("Error converting URL to Base64:", n), n;
  }
}
function Kc(e) {
  if (Object.prototype.toString.call(e) !== "[object Object]")
    return !1;
  const t = Object.getPrototypeOf(e);
  return t === null || t === Object.prototype;
}
function T3(e, t, n = /* @__PURE__ */ new WeakMap()) {
  if (e === t) return !0;
  if (typeof e != "object" || e === null || typeof t != "object" || t === null)
    return !1;
  if (n.has(e))
    return n.get(e) === t;
  if (n.set(e, t), e.constructor !== t.constructor) return !1;
  if (e.constructor === Object || e.constructor === Array) {
    const r = Object.keys(e), a = Object.keys(t);
    if (r.length !== a.length) return !1;
    for (const s of r)
      if (!a.includes(s) || !T3(e[s], t[s], n)) return !1;
  }
  return e instanceof Date && t instanceof Date ? e.getTime() === t.getTime() : !0;
}
const rd = (e, t) => {
  let n = !1;
  if (!Kc(e))
    throw new Error("Target must be a plain object not" + typeof e);
  if (!Kc(t))
    throw new Error("Source must be a plain object not" + typeof t);
  const r = { ...e };
  return Object.keys(t).forEach((a) => {
    const s = t[a], l = e[a];
    if (Kc(s) && Kc(l)) {
      const { new_obj: c, change: d } = rd(
        l,
        s
      );
      d && (n = !0, r[a] = c);
    } else T3(l, s) || (n = !0, r[a] = s);
  }), { new_obj: r, change: n };
}, L3 = (e, t) => {
  let n = !1;
  if (!Kc(e))
    throw new Error("Target must be a plain object");
  if (!Kc(t))
    throw new Error("Source must be a plain object");
  const r = { ...e };
  return Object.keys(t).forEach((a) => {
    const s = t[a], l = e[a];
    if (!(l === void 0 && s === void 0)) {
      if (l === void 0) {
        n = !0, r[a] = s;
        return;
      }
      if (Kc(s) && Kc(l)) {
        const { new_obj: c, change: d } = L3(
          l,
          s
        );
        d && (n = !0, r[a] = c);
      }
    }
  }), { new_obj: r, change: n };
}, H_ = (e, t = void 0) => {
  const n = JSON.stringify(e);
  return (r) => {
    let a = JSON.parse(n);
    return t !== void 0 && (a = t(a)), r === void 0 ? a : L3(r, a).new_obj;
  };
}, Oi = (e, t) => t === void 0 ? [e, !1] : [t, e !== t];
function k1(e, t) {
  throw new Error("Unhandled case: " + e + " with: " + JSON.stringify(t));
}
const ch = (e, t) => {
  if (t === void 0) return [e, !1];
  if (e === void 0) return [t, t !== void 0];
  const { new_obj: n, change: r } = rd(e, t);
  return [n, r];
}, FK = ({ error: e }) => /* @__PURE__ */ E.jsxs("div", { className: "error-div", children: [
  /* @__PURE__ */ E.jsx("h1", { children: "Error" }),
  /* @__PURE__ */ E.jsx("p", { children: e.message })
] }), q_ = M.createContext(
  void 0
), Xc = M.forwardRef((e, t) => {
  const {
    asChild: n = !1,
    children: r,
    className: a,
    style: s,
    htime: l = 300,
    vtime: c = 300,
    hdelay: d = 0,
    vdelay: p = 200,
    zIndex: m = 9999,
    ...h
  } = e, [v, y] = M.useState(!1), [w, x] = M.useState({}), b = M.useRef(null), k = M.useRef(null);
  M.useImperativeHandle(t, () => b.current, []);
  const C = M.useMemo(
    () => ({
      horizontal: l,
      vertical: c,
      horizontalDelay: d,
      verticalDelay: p
    }),
    [l, c, d, p]
  ), _ = M.useCallback(
    () => Math.max(
      C.horizontal + C.horizontalDelay,
      C.vertical + C.verticalDelay
    ),
    [C]
  ), O = M.useCallback(async () => {
    if (b.current)
      try {
        const B = b.current.getBoundingClientRect();
        k.current = B, x({
          position: "fixed",
          top: `${B.top}px`,
          left: `${B.left}px`,
          width: `${B.width}px`,
          height: `${B.height}px`,
          zIndex: m,
          transition: "none"
        }), y(!0), b.current.offsetHeight, x((P) => ({
          ...P,
          transition: [
            `width ${C.horizontal}ms ease-in-out ${C.horizontalDelay}ms`,
            `left ${C.horizontal}ms ease-in-out ${C.horizontalDelay}ms`,
            `height ${C.vertical}ms ease-in-out ${C.verticalDelay}ms`,
            `top ${C.vertical}ms ease-in-out ${C.verticalDelay}ms`
          ].join(", ")
        })), requestAnimationFrame(() => {
          x((P) => ({
            ...P,
            top: "0",
            left: "0",
            width: "100vw",
            height: "100vh"
          }));
        }), await new Promise((P) => setTimeout(P, _()));
      } catch (B) {
        console.warn("Error during expand animation:", B), y(!0);
      }
  }, [C, m, _]), N = M.useCallback(async () => {
    if (!b.current || !k.current) return;
    const B = k.current;
    x((P) => ({
      ...P,
      transition: [
        `width ${C.horizontal}ms ease-in-out ${C.verticalDelay}ms`,
        `left ${C.horizontal}ms ease-in-out ${C.verticalDelay}ms`,
        `height ${C.vertical}ms ease-in-out ${C.horizontalDelay}ms`,
        `top ${C.vertical}ms ease-in-out ${C.horizontalDelay}ms`
      ].join(", ")
    })), requestAnimationFrame(() => {
      x((P) => ({
        ...P,
        top: `${B.top}px`,
        left: `${B.left}px`,
        width: `${B.width}px`,
        height: `${B.height}px`
      }));
    }), await new Promise((P) => setTimeout(P, _())), x({}), y(!1), k.current = null;
  }, [C, _]), R = M.useCallback(async () => {
    v ? await N() : await O();
  }, [v, O, N]), j = M.useMemo(
    () => ({ isExpanded: v, toggleExpand: R }),
    [v, R]
  ), D = M.useMemo(
    () => ({ ...s, ...w }),
    [s, w]
  );
  let $;
  if (n && M.isValidElement(r)) {
    const B = r;
    $ = M.cloneElement(B, {
      ref: b,
      className: [B.props.className, a].filter(Boolean).join(" "),
      style: { ...B.props.style, ...D },
      ...h
    });
  } else
    $ = /* @__PURE__ */ E.jsx("div", { ref: b, className: a, style: D, ...h, children: r });
  const z = /* @__PURE__ */ E.jsx(q_.Provider, { value: j, children: $ });
  return v ? xm.createPortal(z, document.body) : z;
});
Xc.displayName = "SmoothExpand";
Xc.Trigger = function({
  children: e,
  className: t
}) {
  const n = M.useContext(q_);
  if (!n)
    throw new Error(
      "SmoothExpand.Trigger must be used within a SmoothExpand component"
    );
  return /* @__PURE__ */ E.jsx(
    "div",
    {
      className: t,
      style: { cursor: "pointer" },
      onClick: n.toggleExpand,
      role: "button",
      tabIndex: 0,
      onKeyDown: (r) => {
        (r.key === "Enter" || r.key === " ") && (r.preventDefault(), n.toggleExpand());
      },
      children: e
    }
  );
};
Xc.Expanded = function({
  children: e
}) {
  const t = M.useContext(q_);
  if (!t)
    throw new Error(
      "SmoothExpand.Expanded must be used within a SmoothExpand component"
    );
  return t.isExpanded ? /* @__PURE__ */ E.jsx(E.Fragment, { children: e }) : null;
};
Xc.Collapsed = function({
  children: e
}) {
  const t = M.useContext(q_);
  if (!t)
    throw new Error(
      "SmoothExpand.Collapsed must be used within a SmoothExpand component"
    );
  return t.isExpanded ? null : /* @__PURE__ */ E.jsx(E.Fragment, { children: e });
};
const W_ = M.createContext(
  void 0
), uc = M.forwardRef((e, t) => {
  const { asChild: n = !1, children: r, className: a, style: s, ...l } = e, [c, d] = M.useState(!1), p = M.useRef(null);
  M.useImperativeHandle(t, () => p.current, []);
  const m = M.useCallback(async (b) => {
    const k = b;
    if (b.requestFullscreen)
      await b.requestFullscreen();
    else if (k.mozRequestFullScreen)
      await k.mozRequestFullScreen();
    else if (k.webkitRequestFullscreen)
      await k.webkitRequestFullscreen();
    else if (k.msRequestFullscreen)
      await k.msRequestFullscreen();
    else
      throw new Error("Fullscreen API is not supported in this browser");
  }, []), h = M.useCallback(async () => {
    const b = document;
    if (document.exitFullscreen)
      await document.exitFullscreen();
    else if (b.mozCancelFullScreen)
      await b.mozCancelFullScreen();
    else if (b.webkitExitFullscreen)
      await b.webkitExitFullscreen();
    else if (b.msExitFullscreen)
      await b.msExitFullscreen();
    else
      throw new Error("Exit fullscreen API is not supported in this browser");
  }, []), v = M.useCallback(async () => {
    try {
      const b = p.current;
      if (!b) {
        console.warn("FullScreen: No element reference available");
        return;
      }
      c ? await h() : await m(b);
    } catch (b) {
      console.error("FullScreen: Error toggling fullscreen mode", b);
    }
  }, [c, m, h]), y = M.useCallback(() => {
    const b = !!(document.fullscreenElement || document.webkitFullscreenElement || document.mozFullScreenElement || document.msFullscreenElement);
    d(b);
  }, []);
  M.useEffect(() => {
    const b = [
      "fullscreenchange",
      "webkitfullscreenchange",
      "mozfullscreenchange",
      "MSFullscreenChange"
    ];
    return b.forEach((k) => {
      document.addEventListener(k, y);
    }), () => {
      b.forEach((k) => {
        document.removeEventListener(k, y);
      });
    };
  }, [y]);
  const w = M.useMemo(
    () => ({ isFullScreen: c, toggleFullscreen: v }),
    [c, v]
  );
  let x;
  if (n && M.isValidElement(r)) {
    const b = r;
    x = M.cloneElement(b, {
      ref: p,
      className: [b.props.className, a].filter(Boolean).join(" "),
      style: { ...b.props.style, ...s },
      ...l
    });
  } else
    x = /* @__PURE__ */ E.jsx("div", { ref: p, className: a, style: s, ...l, children: r });
  return /* @__PURE__ */ E.jsx(W_.Provider, { value: w, children: x });
});
uc.displayName = "FullScreen";
uc.Trigger = function({
  children: e,
  className: t
}) {
  const n = M.useContext(W_);
  if (!n)
    throw new Error(
      "FullScreen.Trigger must be used within a FullScreen component"
    );
  return /* @__PURE__ */ E.jsx(
    "div",
    {
      className: t,
      style: { cursor: "pointer" },
      onClick: n.toggleFullscreen,
      role: "button",
      tabIndex: 0,
      onKeyDown: (r) => {
        (r.key === "Enter" || r.key === " ") && (r.preventDefault(), n.toggleFullscreen());
      },
      children: e
    }
  );
};
uc.InFullScreen = function({
  children: e
}) {
  const t = M.useContext(W_);
  if (!t)
    throw new Error(
      "FullScreen.InFullScreen must be used within a FullScreen component"
    );
  return t.isFullScreen ? /* @__PURE__ */ E.jsx(E.Fragment, { children: e }) : null;
};
uc.OutFullScreen = function({
  children: e
}) {
  const t = M.useContext(W_);
  if (!t)
    throw new Error(
      "FullScreen.OutFullScreen must be used within a FullScreen component"
    );
  return t.isFullScreen ? null : /* @__PURE__ */ E.jsx(E.Fragment, { children: e });
};
var WO = { exports: {} }, jj = { exports: {} }, wn = {}, Pj;
function BK() {
  if (Pj) return wn;
  Pj = 1;
  var e = typeof Symbol == "function" && Symbol.for, t = e ? /* @__PURE__ */ Symbol.for("react.element") : 60103, n = e ? /* @__PURE__ */ Symbol.for("react.portal") : 60106, r = e ? /* @__PURE__ */ Symbol.for("react.fragment") : 60107, a = e ? /* @__PURE__ */ Symbol.for("react.strict_mode") : 60108, s = e ? /* @__PURE__ */ Symbol.for("react.profiler") : 60114, l = e ? /* @__PURE__ */ Symbol.for("react.provider") : 60109, c = e ? /* @__PURE__ */ Symbol.for("react.context") : 60110, d = e ? /* @__PURE__ */ Symbol.for("react.async_mode") : 60111, p = e ? /* @__PURE__ */ Symbol.for("react.concurrent_mode") : 60111, m = e ? /* @__PURE__ */ Symbol.for("react.forward_ref") : 60112, h = e ? /* @__PURE__ */ Symbol.for("react.suspense") : 60113, v = e ? /* @__PURE__ */ Symbol.for("react.suspense_list") : 60120, y = e ? /* @__PURE__ */ Symbol.for("react.memo") : 60115, w = e ? /* @__PURE__ */ Symbol.for("react.lazy") : 60116, x = e ? /* @__PURE__ */ Symbol.for("react.block") : 60121, b = e ? /* @__PURE__ */ Symbol.for("react.fundamental") : 60117, k = e ? /* @__PURE__ */ Symbol.for("react.responder") : 60118, C = e ? /* @__PURE__ */ Symbol.for("react.scope") : 60119;
  function _(N) {
    if (typeof N == "object" && N !== null) {
      var R = N.$$typeof;
      switch (R) {
        case t:
          switch (N = N.type, N) {
            case d:
            case p:
            case r:
            case s:
            case a:
            case h:
              return N;
            default:
              switch (N = N && N.$$typeof, N) {
                case c:
                case m:
                case w:
                case y:
                case l:
                  return N;
                default:
                  return R;
              }
          }
        case n:
          return R;
      }
    }
  }
  function O(N) {
    return _(N) === p;
  }
  return wn.AsyncMode = d, wn.ConcurrentMode = p, wn.ContextConsumer = c, wn.ContextProvider = l, wn.Element = t, wn.ForwardRef = m, wn.Fragment = r, wn.Lazy = w, wn.Memo = y, wn.Portal = n, wn.Profiler = s, wn.StrictMode = a, wn.Suspense = h, wn.isAsyncMode = function(N) {
    return O(N) || _(N) === d;
  }, wn.isConcurrentMode = O, wn.isContextConsumer = function(N) {
    return _(N) === c;
  }, wn.isContextProvider = function(N) {
    return _(N) === l;
  }, wn.isElement = function(N) {
    return typeof N == "object" && N !== null && N.$$typeof === t;
  }, wn.isForwardRef = function(N) {
    return _(N) === m;
  }, wn.isFragment = function(N) {
    return _(N) === r;
  }, wn.isLazy = function(N) {
    return _(N) === w;
  }, wn.isMemo = function(N) {
    return _(N) === y;
  }, wn.isPortal = function(N) {
    return _(N) === n;
  }, wn.isProfiler = function(N) {
    return _(N) === s;
  }, wn.isStrictMode = function(N) {
    return _(N) === a;
  }, wn.isSuspense = function(N) {
    return _(N) === h;
  }, wn.isValidElementType = function(N) {
    return typeof N == "string" || typeof N == "function" || N === r || N === p || N === s || N === a || N === h || N === v || typeof N == "object" && N !== null && (N.$$typeof === w || N.$$typeof === y || N.$$typeof === l || N.$$typeof === c || N.$$typeof === m || N.$$typeof === b || N.$$typeof === k || N.$$typeof === C || N.$$typeof === x);
  }, wn.typeOf = _, wn;
}
var Dj;
function UK() {
  return Dj || (Dj = 1, jj.exports = BK()), jj.exports;
}
var GO, $j;
function VK() {
  if ($j) return GO;
  $j = 1;
  var e = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
  return GO = e, GO;
}
var KO, Tj;
function HK() {
  if (Tj) return KO;
  Tj = 1;
  var e = /* @__PURE__ */ VK();
  function t() {
  }
  function n() {
  }
  return n.resetWarningCache = t, KO = function() {
    function r(l, c, d, p, m, h) {
      if (h !== e) {
        var v = new Error(
          "Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types"
        );
        throw v.name = "Invariant Violation", v;
      }
    }
    r.isRequired = r;
    function a() {
      return r;
    }
    var s = {
      array: r,
      bigint: r,
      bool: r,
      func: r,
      number: r,
      object: r,
      string: r,
      symbol: r,
      any: r,
      arrayOf: a,
      element: r,
      elementType: r,
      instanceOf: a,
      node: r,
      objectOf: a,
      oneOf: a,
      oneOfType: a,
      shape: a,
      exact: a,
      checkPropTypes: n,
      resetWarningCache: t
    };
    return s.PropTypes = s, s;
  }, KO;
}
var Lj;
function qK() {
  return Lj || (Lj = 1, WO.exports = /* @__PURE__ */ HK()()), WO.exports;
}
var Nr = /* @__PURE__ */ qK();
const gh = /* @__PURE__ */ Oc(Nr);
function _1(e) {
  var t, n, r = "";
  if (typeof e == "string" || typeof e == "number") r += e;
  else if (typeof e == "object") if (Array.isArray(e)) {
    var a = e.length;
    for (t = 0; t < a; t++) e[t] && (n = _1(e[t])) && (r && (r += " "), r += n);
  } else for (n in e) e[n] && (r && (r += " "), r += n);
  return r;
}
function Ke() {
  for (var e, t, n = 0, r = "", a = arguments.length; n < a; n++) (e = arguments[n]) && (t = _1(e)) && (r && (r += " "), r += t);
  return r;
}
function kt(e, t, n = void 0) {
  const r = {};
  for (const a in e) {
    const s = e[a];
    let l = "", c = !0;
    for (let d = 0; d < s.length; d += 1) {
      const p = s[d];
      p && (l += (c === !0 ? "" : " ") + t(p), c = !1, n && n[p] && (l += " " + n[p]));
    }
    r[a] = l;
  }
  return r;
}
const E1 = /* @__PURE__ */ M.createContext();
function vc(e, ...t) {
  const n = new URL(`https://mui.com/production-error/?code=${e}`);
  return t.forEach((r) => n.searchParams.append("args[]", r)), `Minified MUI error #${e}; visit ${n} for the full message.`;
}
function qe(e) {
  if (typeof e != "string")
    throw new Error(vc(7));
  return e.charAt(0).toUpperCase() + e.slice(1);
}
var Ij = { exports: {} }, Dn = {}, zj;
function WK() {
  if (zj) return Dn;
  zj = 1;
  var e = /* @__PURE__ */ Symbol.for("react.transitional.element"), t = /* @__PURE__ */ Symbol.for("react.portal"), n = /* @__PURE__ */ Symbol.for("react.fragment"), r = /* @__PURE__ */ Symbol.for("react.strict_mode"), a = /* @__PURE__ */ Symbol.for("react.profiler"), s = /* @__PURE__ */ Symbol.for("react.consumer"), l = /* @__PURE__ */ Symbol.for("react.context"), c = /* @__PURE__ */ Symbol.for("react.forward_ref"), d = /* @__PURE__ */ Symbol.for("react.suspense"), p = /* @__PURE__ */ Symbol.for("react.suspense_list"), m = /* @__PURE__ */ Symbol.for("react.memo"), h = /* @__PURE__ */ Symbol.for("react.lazy"), v = /* @__PURE__ */ Symbol.for("react.view_transition"), y = /* @__PURE__ */ Symbol.for("react.client.reference");
  function w(x) {
    if (typeof x == "object" && x !== null) {
      var b = x.$$typeof;
      switch (b) {
        case e:
          switch (x = x.type, x) {
            case n:
            case a:
            case r:
            case d:
            case p:
            case v:
              return x;
            default:
              switch (x = x && x.$$typeof, x) {
                case l:
                case c:
                case h:
                case m:
                  return x;
                case s:
                  return x;
                default:
                  return b;
              }
          }
        case t:
          return b;
      }
    }
  }
  return Dn.ContextConsumer = s, Dn.ContextProvider = l, Dn.Element = e, Dn.ForwardRef = c, Dn.Fragment = n, Dn.Lazy = h, Dn.Memo = m, Dn.Portal = t, Dn.Profiler = a, Dn.StrictMode = r, Dn.Suspense = d, Dn.SuspenseList = p, Dn.isContextConsumer = function(x) {
    return w(x) === s;
  }, Dn.isContextProvider = function(x) {
    return w(x) === l;
  }, Dn.isElement = function(x) {
    return typeof x == "object" && x !== null && x.$$typeof === e;
  }, Dn.isForwardRef = function(x) {
    return w(x) === c;
  }, Dn.isFragment = function(x) {
    return w(x) === n;
  }, Dn.isLazy = function(x) {
    return w(x) === h;
  }, Dn.isMemo = function(x) {
    return w(x) === m;
  }, Dn.isPortal = function(x) {
    return w(x) === t;
  }, Dn.isProfiler = function(x) {
    return w(x) === a;
  }, Dn.isStrictMode = function(x) {
    return w(x) === r;
  }, Dn.isSuspense = function(x) {
    return w(x) === d;
  }, Dn.isSuspenseList = function(x) {
    return w(x) === p;
  }, Dn.isValidElementType = function(x) {
    return typeof x == "string" || typeof x == "function" || x === n || x === a || x === r || x === d || x === p || typeof x == "object" && x !== null && (x.$$typeof === h || x.$$typeof === m || x.$$typeof === l || x.$$typeof === s || x.$$typeof === c || x.$$typeof === y || x.getModuleId !== void 0);
  }, Dn.typeOf = w, Dn;
}
var Fj;
function GK() {
  return Fj || (Fj = 1, Ij.exports = /* @__PURE__ */ WK()), Ij.exports;
}
var C1 = /* @__PURE__ */ GK();
function cl(e) {
  if (typeof e != "object" || e === null)
    return !1;
  const t = Object.getPrototypeOf(e);
  return (t === null || t === Object.prototype || Object.getPrototypeOf(t) === null) && !(Symbol.toStringTag in e) && !(Symbol.iterator in e);
}
function O1(e) {
  if (/* @__PURE__ */ M.isValidElement(e) || C1.isValidElementType(e) || !cl(e))
    return e;
  const t = {};
  return Object.keys(e).forEach((n) => {
    t[n] = O1(e[n]);
  }), t;
}
function Go(e, t, n = {
  clone: !0
}) {
  const r = n.clone ? {
    ...e
  } : e;
  return cl(e) && cl(t) && Object.keys(t).forEach((a) => {
    /* @__PURE__ */ M.isValidElement(t[a]) || C1.isValidElementType(t[a]) ? r[a] = t[a] : cl(t[a]) && // Avoid prototype pollution
    Object.prototype.hasOwnProperty.call(e, a) && cl(e[a]) ? r[a] = Go(e[a], t[a], n) : n.clone ? r[a] = cl(t[a]) ? O1(t[a]) : t[a] : r[a] = t[a];
  }), r;
}
function Vw(e, t) {
  return t ? Go(e, t, {
    clone: !1
    // No need to clone deep, it's way faster.
  }) : e;
}
function Bj(e, t) {
  if (!e.containerQueries)
    return t;
  const n = Object.keys(t).filter((r) => r.startsWith("@container")).sort((r, a) => {
    const s = /min-width:\s*([0-9.]+)/;
    return +(r.match(s)?.[1] || 0) - +(a.match(s)?.[1] || 0);
  });
  return n.length ? n.reduce((r, a) => {
    const s = t[a];
    return delete r[a], r[a] = s, r;
  }, {
    ...t
  }) : t;
}
function KK(e, t) {
  return t === "@" || t.startsWith("@") && (e.some((n) => t.startsWith(`@${n}`)) || !!t.match(/^@\d/));
}
function XK(e, t) {
  const n = t.match(/^@([^/]+)?\/?(.+)?$/);
  if (!n)
    return null;
  const [, r, a] = n, s = Number.isNaN(+r) ? r || 0 : +r;
  return e.containerQueries(a).up(s);
}
function YK(e) {
  const t = (s, l) => s.replace("@media", l ? `@container ${l}` : "@container");
  function n(s, l) {
    s.up = (...c) => t(e.breakpoints.up(...c), l), s.down = (...c) => t(e.breakpoints.down(...c), l), s.between = (...c) => t(e.breakpoints.between(...c), l), s.only = (...c) => t(e.breakpoints.only(...c), l), s.not = (...c) => {
      const d = t(e.breakpoints.not(...c), l);
      return d.includes("not all and") ? d.replace("not all and ", "").replace("min-width:", "width<").replace("max-width:", "width>").replace("and", "or") : d;
    };
  }
  const r = {}, a = (s) => (n(r, s), r);
  return n(a), {
    ...e,
    containerQueries: a
  };
}
const G_ = {
  xs: 0,
  // phone
  sm: 600,
  // tablet
  md: 900,
  // small laptop
  lg: 1200,
  // desktop
  xl: 1536
  // large screen
}, Uj = {
  // Sorted ASC by size. That's important.
  // It can't be configured as it's used statically for propTypes.
  keys: ["xs", "sm", "md", "lg", "xl"],
  up: (e) => `@media (min-width:${G_[e]}px)`
}, QK = {
  containerQueries: (e) => ({
    up: (t) => {
      let n = typeof t == "number" ? t : G_[t] || t;
      return typeof n == "number" && (n = `${n}px`), e ? `@container ${e} (min-width:${n})` : `@container (min-width:${n})`;
    }
  })
};
function yc(e, t, n) {
  const r = e.theme || {};
  if (Array.isArray(t)) {
    const a = r.breakpoints || Uj;
    return t.reduce((s, l, c) => (s[a.up(a.keys[c])] = n(t[c]), s), {});
  }
  if (typeof t == "object") {
    const a = r.breakpoints || Uj;
    return Object.keys(t).reduce((s, l) => {
      if (KK(a.keys, l)) {
        const c = XK(r.containerQueries ? r : QK, l);
        c && (s[c] = n(t[l], l));
      } else if (Object.keys(a.values || G_).includes(l)) {
        const c = a.up(l);
        s[c] = n(t[l], l);
      } else {
        const c = l;
        s[c] = t[c];
      }
      return s;
    }, {});
  }
  return n(t);
}
function JK(e = {}) {
  return e.keys?.reduce((t, n) => {
    const r = e.up(n);
    return t[r] = {}, t;
  }, {}) || {};
}
function Vj(e, t) {
  return e.reduce((n, r) => {
    const a = n[r];
    return (!a || Object.keys(a).length === 0) && delete n[r], n;
  }, t);
}
function K_(e, t, n = !0) {
  if (!t || typeof t != "string")
    return null;
  if (e && e.vars && n) {
    const r = `vars.${t}`.split(".").reduce((a, s) => a && a[s] ? a[s] : null, e);
    if (r != null)
      return r;
  }
  return t.split(".").reduce((r, a) => r && r[a] != null ? r[a] : null, e);
}
function H0(e, t, n, r = n) {
  let a;
  return typeof e == "function" ? a = e(n) : Array.isArray(e) ? a = e[n] || r : a = K_(e, n) || r, t && (a = t(a, r, e)), a;
}
function Or(e) {
  const {
    prop: t,
    cssProperty: n = e.prop,
    themeKey: r,
    transform: a
  } = e, s = (l) => {
    if (l[t] == null)
      return null;
    const c = l[t], d = l.theme, p = K_(d, r) || {};
    return yc(l, c, (m) => {
      let h = H0(p, a, m);
      return m === h && typeof m == "string" && (h = H0(p, a, `${t}${m === "default" ? "" : qe(m)}`, m)), n === !1 ? h : {
        [n]: h
      };
    });
  };
  return s.propTypes = {}, s.filterProps = [t], s;
}
function ZK(e) {
  const t = {};
  return (n) => (t[n] === void 0 && (t[n] = e(n)), t[n]);
}
const eX = {
  m: "margin",
  p: "padding"
}, tX = {
  t: "Top",
  r: "Right",
  b: "Bottom",
  l: "Left",
  x: ["Left", "Right"],
  y: ["Top", "Bottom"]
}, Hj = {
  marginX: "mx",
  marginY: "my",
  paddingX: "px",
  paddingY: "py"
}, nX = ZK((e) => {
  if (e.length > 2)
    if (Hj[e])
      e = Hj[e];
    else
      return [e];
  const [t, n] = e.split(""), r = eX[t], a = tX[n] || "";
  return Array.isArray(a) ? a.map((s) => r + s) : [r + a];
}), I3 = ["m", "mt", "mr", "mb", "ml", "mx", "my", "margin", "marginTop", "marginRight", "marginBottom", "marginLeft", "marginX", "marginY", "marginInline", "marginInlineStart", "marginInlineEnd", "marginBlock", "marginBlockStart", "marginBlockEnd"], z3 = ["p", "pt", "pr", "pb", "pl", "px", "py", "padding", "paddingTop", "paddingRight", "paddingBottom", "paddingLeft", "paddingX", "paddingY", "paddingInline", "paddingInlineStart", "paddingInlineEnd", "paddingBlock", "paddingBlockStart", "paddingBlockEnd"];
[...I3, ...z3];
function Kx(e, t, n, r) {
  const a = K_(e, t, !0) ?? n;
  return typeof a == "number" || typeof a == "string" ? (s) => typeof s == "string" ? s : typeof a == "string" ? a.startsWith("var(") && s === 0 ? 0 : a.startsWith("var(") && s === 1 ? a : `calc(${s} * ${a})` : a * s : Array.isArray(a) ? (s) => {
    if (typeof s == "string")
      return s;
    const l = Math.abs(s), c = a[l];
    return s >= 0 ? c : typeof c == "number" ? -c : typeof c == "string" && c.startsWith("var(") ? `calc(-1 * ${c})` : `-${c}`;
  } : typeof a == "function" ? a : (() => {
  });
}
function F3(e) {
  return Kx(e, "spacing", 8);
}
function Xx(e, t) {
  return typeof t == "string" || t == null ? t : e(t);
}
function rX(e, t) {
  return (n) => e.reduce((r, a) => (r[a] = Xx(t, n), r), {});
}
function oX(e, t, n, r) {
  if (!t.includes(n))
    return null;
  const a = nX(n), s = rX(a, r), l = e[n];
  return yc(e, l, s);
}
function M1(e, t) {
  const n = F3(e.theme);
  return Object.keys(e).map((r) => oX(e, t, r, n)).reduce(Vw, {});
}
function vr(e) {
  return M1(e, I3);
}
vr.propTypes = {};
vr.filterProps = I3;
function yr(e) {
  return M1(e, z3);
}
yr.propTypes = {};
yr.filterProps = z3;
function X_(...e) {
  const t = e.reduce((r, a) => (a.filterProps.forEach((s) => {
    r[s] = a;
  }), r), {}), n = (r) => Object.keys(r).reduce((a, s) => t[s] ? Vw(a, t[s](r)) : a, {});
  return n.propTypes = {}, n.filterProps = e.reduce((r, a) => r.concat(a.filterProps), []), n;
}
function Mi(e) {
  return typeof e != "number" ? e : `${e}px solid`;
}
function Ii(e, t) {
  return Or({
    prop: e,
    themeKey: "borders",
    transform: t
  });
}
const aX = Ii("border", Mi), iX = Ii("borderTop", Mi), sX = Ii("borderRight", Mi), lX = Ii("borderBottom", Mi), uX = Ii("borderLeft", Mi), cX = Ii("borderColor"), dX = Ii("borderTopColor"), fX = Ii("borderRightColor"), pX = Ii("borderBottomColor"), mX = Ii("borderLeftColor"), hX = Ii("outline", Mi), gX = Ii("outlineColor"), Y_ = (e) => {
  if (e.borderRadius !== void 0 && e.borderRadius !== null) {
    const t = Kx(e.theme, "shape.borderRadius", 4), n = (r) => ({
      borderRadius: Xx(t, r)
    });
    return yc(e, e.borderRadius, n);
  }
  return null;
};
Y_.propTypes = {};
Y_.filterProps = ["borderRadius"];
X_(aX, iX, sX, lX, uX, cX, dX, fX, pX, mX, Y_, hX, gX);
const Q_ = (e) => {
  if (e.gap !== void 0 && e.gap !== null) {
    const t = Kx(e.theme, "spacing", 8), n = (r) => ({
      gap: Xx(t, r)
    });
    return yc(e, e.gap, n);
  }
  return null;
};
Q_.propTypes = {};
Q_.filterProps = ["gap"];
const J_ = (e) => {
  if (e.columnGap !== void 0 && e.columnGap !== null) {
    const t = Kx(e.theme, "spacing", 8), n = (r) => ({
      columnGap: Xx(t, r)
    });
    return yc(e, e.columnGap, n);
  }
  return null;
};
J_.propTypes = {};
J_.filterProps = ["columnGap"];
const Z_ = (e) => {
  if (e.rowGap !== void 0 && e.rowGap !== null) {
    const t = Kx(e.theme, "spacing", 8), n = (r) => ({
      rowGap: Xx(t, r)
    });
    return yc(e, e.rowGap, n);
  }
  return null;
};
Z_.propTypes = {};
Z_.filterProps = ["rowGap"];
const vX = Or({
  prop: "gridColumn"
}), yX = Or({
  prop: "gridRow"
}), bX = Or({
  prop: "gridAutoFlow"
}), wX = Or({
  prop: "gridAutoColumns"
}), xX = Or({
  prop: "gridAutoRows"
}), SX = Or({
  prop: "gridTemplateColumns"
}), kX = Or({
  prop: "gridTemplateRows"
}), _X = Or({
  prop: "gridTemplateAreas"
}), EX = Or({
  prop: "gridArea"
});
X_(Q_, J_, Z_, vX, yX, bX, wX, xX, SX, kX, _X, EX);
function vh(e, t) {
  return t === "grey" ? t : e;
}
const CX = Or({
  prop: "color",
  themeKey: "palette",
  transform: vh
}), OX = Or({
  prop: "bgcolor",
  cssProperty: "backgroundColor",
  themeKey: "palette",
  transform: vh
}), MX = Or({
  prop: "backgroundColor",
  themeKey: "palette",
  transform: vh
});
X_(CX, OX, MX);
function hi(e) {
  return e <= 1 && e !== 0 ? `${e * 100}%` : e;
}
const NX = Or({
  prop: "width",
  transform: hi
}), B3 = (e) => {
  if (e.maxWidth !== void 0 && e.maxWidth !== null) {
    const t = (n) => {
      const r = e.theme?.breakpoints?.values?.[n] || G_[n];
      return r ? e.theme?.breakpoints?.unit !== "px" ? {
        maxWidth: `${r}${e.theme.breakpoints.unit}`
      } : {
        maxWidth: r
      } : {
        maxWidth: hi(n)
      };
    };
    return yc(e, e.maxWidth, t);
  }
  return null;
};
B3.filterProps = ["maxWidth"];
const RX = Or({
  prop: "minWidth",
  transform: hi
}), AX = Or({
  prop: "height",
  transform: hi
}), jX = Or({
  prop: "maxHeight",
  transform: hi
}), PX = Or({
  prop: "minHeight",
  transform: hi
});
Or({
  prop: "size",
  cssProperty: "width",
  transform: hi
});
Or({
  prop: "size",
  cssProperty: "height",
  transform: hi
});
const DX = Or({
  prop: "boxSizing"
});
X_(NX, B3, RX, AX, jX, PX, DX);
const Yx = {
  // borders
  border: {
    themeKey: "borders",
    transform: Mi
  },
  borderTop: {
    themeKey: "borders",
    transform: Mi
  },
  borderRight: {
    themeKey: "borders",
    transform: Mi
  },
  borderBottom: {
    themeKey: "borders",
    transform: Mi
  },
  borderLeft: {
    themeKey: "borders",
    transform: Mi
  },
  borderColor: {
    themeKey: "palette"
  },
  borderTopColor: {
    themeKey: "palette"
  },
  borderRightColor: {
    themeKey: "palette"
  },
  borderBottomColor: {
    themeKey: "palette"
  },
  borderLeftColor: {
    themeKey: "palette"
  },
  outline: {
    themeKey: "borders",
    transform: Mi
  },
  outlineColor: {
    themeKey: "palette"
  },
  borderRadius: {
    themeKey: "shape.borderRadius",
    style: Y_
  },
  // palette
  color: {
    themeKey: "palette",
    transform: vh
  },
  bgcolor: {
    themeKey: "palette",
    cssProperty: "backgroundColor",
    transform: vh
  },
  backgroundColor: {
    themeKey: "palette",
    transform: vh
  },
  // spacing
  p: {
    style: yr
  },
  pt: {
    style: yr
  },
  pr: {
    style: yr
  },
  pb: {
    style: yr
  },
  pl: {
    style: yr
  },
  px: {
    style: yr
  },
  py: {
    style: yr
  },
  padding: {
    style: yr
  },
  paddingTop: {
    style: yr
  },
  paddingRight: {
    style: yr
  },
  paddingBottom: {
    style: yr
  },
  paddingLeft: {
    style: yr
  },
  paddingX: {
    style: yr
  },
  paddingY: {
    style: yr
  },
  paddingInline: {
    style: yr
  },
  paddingInlineStart: {
    style: yr
  },
  paddingInlineEnd: {
    style: yr
  },
  paddingBlock: {
    style: yr
  },
  paddingBlockStart: {
    style: yr
  },
  paddingBlockEnd: {
    style: yr
  },
  m: {
    style: vr
  },
  mt: {
    style: vr
  },
  mr: {
    style: vr
  },
  mb: {
    style: vr
  },
  ml: {
    style: vr
  },
  mx: {
    style: vr
  },
  my: {
    style: vr
  },
  margin: {
    style: vr
  },
  marginTop: {
    style: vr
  },
  marginRight: {
    style: vr
  },
  marginBottom: {
    style: vr
  },
  marginLeft: {
    style: vr
  },
  marginX: {
    style: vr
  },
  marginY: {
    style: vr
  },
  marginInline: {
    style: vr
  },
  marginInlineStart: {
    style: vr
  },
  marginInlineEnd: {
    style: vr
  },
  marginBlock: {
    style: vr
  },
  marginBlockStart: {
    style: vr
  },
  marginBlockEnd: {
    style: vr
  },
  // display
  displayPrint: {
    cssProperty: !1,
    transform: (e) => ({
      "@media print": {
        display: e
      }
    })
  },
  display: {},
  overflow: {},
  textOverflow: {},
  visibility: {},
  whiteSpace: {},
  // flexbox
  flexBasis: {},
  flexDirection: {},
  flexWrap: {},
  justifyContent: {},
  alignItems: {},
  alignContent: {},
  order: {},
  flex: {},
  flexGrow: {},
  flexShrink: {},
  alignSelf: {},
  justifyItems: {},
  justifySelf: {},
  // grid
  gap: {
    style: Q_
  },
  rowGap: {
    style: Z_
  },
  columnGap: {
    style: J_
  },
  gridColumn: {},
  gridRow: {},
  gridAutoFlow: {},
  gridAutoColumns: {},
  gridAutoRows: {},
  gridTemplateColumns: {},
  gridTemplateRows: {},
  gridTemplateAreas: {},
  gridArea: {},
  // positions
  position: {},
  zIndex: {
    themeKey: "zIndex"
  },
  top: {},
  right: {},
  bottom: {},
  left: {},
  // shadows
  boxShadow: {
    themeKey: "shadows"
  },
  // sizing
  width: {
    transform: hi
  },
  maxWidth: {
    style: B3
  },
  minWidth: {
    transform: hi
  },
  height: {
    transform: hi
  },
  maxHeight: {
    transform: hi
  },
  minHeight: {
    transform: hi
  },
  boxSizing: {},
  // typography
  font: {
    themeKey: "font"
  },
  fontFamily: {
    themeKey: "typography"
  },
  fontSize: {
    themeKey: "typography"
  },
  fontStyle: {
    themeKey: "typography"
  },
  fontWeight: {
    themeKey: "typography"
  },
  letterSpacing: {},
  textTransform: {},
  lineHeight: {},
  textAlign: {},
  typography: {
    cssProperty: !1,
    themeKey: "typography"
  }
};
function $X(...e) {
  const t = e.reduce((r, a) => r.concat(Object.keys(a)), []), n = new Set(t);
  return e.every((r) => n.size === Object.keys(r).length);
}
function TX(e, t) {
  return typeof e == "function" ? e(t) : e;
}
function LX() {
  function e(n, r, a, s) {
    const l = {
      [n]: r,
      theme: a
    }, c = s[n];
    if (!c)
      return {
        [n]: r
      };
    const {
      cssProperty: d = n,
      themeKey: p,
      transform: m,
      style: h
    } = c;
    if (r == null)
      return null;
    if (p === "typography" && r === "inherit")
      return {
        [n]: r
      };
    const v = K_(a, p) || {};
    return h ? h(l) : yc(l, r, (y) => {
      let w = H0(v, m, y);
      return y === w && typeof y == "string" && (w = H0(v, m, `${n}${y === "default" ? "" : qe(y)}`, y)), d === !1 ? w : {
        [d]: w
      };
    });
  }
  function t(n) {
    const {
      sx: r,
      theme: a = {},
      nested: s
    } = n || {};
    if (!r)
      return null;
    const l = a.unstable_sxConfig ?? Yx;
    function c(d) {
      let p = d;
      if (typeof d == "function")
        p = d(a);
      else if (typeof d != "object")
        return d;
      if (!p)
        return null;
      const m = JK(a.breakpoints), h = Object.keys(m);
      let v = m;
      return Object.keys(p).forEach((y) => {
        const w = TX(p[y], a);
        if (w != null)
          if (typeof w == "object")
            if (l[y])
              v = Vw(v, e(y, w, a, l));
            else {
              const x = yc({
                theme: a
              }, w, (b) => ({
                [y]: b
              }));
              $X(x, w) ? v[y] = t({
                sx: w,
                theme: a,
                nested: !0
              }) : v = Vw(v, x);
            }
          else
            v = Vw(v, e(y, w, a, l));
      }), !s && a.modularCssLayers ? {
        "@layer sx": Bj(a, Vj(h, v))
      } : Bj(a, Vj(h, v));
    }
    return Array.isArray(r) ? r.map(c) : c(r);
  }
  return t;
}
const od = LX();
od.filterProps = ["sx"];
const IX = (e) => {
  const t = {
    systemProps: {},
    otherProps: {}
  }, n = e?.theme?.unstable_sxConfig ?? Yx;
  return Object.keys(e).forEach((r) => {
    n[r] ? t.systemProps[r] = e[r] : t.otherProps[r] = e[r];
  }), t;
};
function U3(e) {
  const {
    sx: t,
    ...n
  } = e, {
    systemProps: r,
    otherProps: a
  } = IX(n);
  let s;
  return Array.isArray(t) ? s = [r, ...t] : typeof t == "function" ? s = (...l) => {
    const c = t(...l);
    return cl(c) ? {
      ...r,
      ...c
    } : r;
  } : s = {
    ...r,
    ...t
  }, {
    ...a,
    sx: s
  };
}
function ft() {
  return ft = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var r in n) ({}).hasOwnProperty.call(n, r) && (e[r] = n[r]);
    }
    return e;
  }, ft.apply(null, arguments);
}
function zX(e) {
  if (e.sheet)
    return e.sheet;
  for (var t = 0; t < document.styleSheets.length; t++)
    if (document.styleSheets[t].ownerNode === e)
      return document.styleSheets[t];
}
function FX(e) {
  var t = document.createElement("style");
  return t.setAttribute("data-emotion", e.key), e.nonce !== void 0 && t.setAttribute("nonce", e.nonce), t.appendChild(document.createTextNode("")), t.setAttribute("data-s", ""), t;
}
var BX = /* @__PURE__ */ (function() {
  function e(n) {
    var r = this;
    this._insertTag = function(a) {
      var s;
      r.tags.length === 0 ? r.insertionPoint ? s = r.insertionPoint.nextSibling : r.prepend ? s = r.container.firstChild : s = r.before : s = r.tags[r.tags.length - 1].nextSibling, r.container.insertBefore(a, s), r.tags.push(a);
    }, this.isSpeedy = n.speedy === void 0 ? !0 : n.speedy, this.tags = [], this.ctr = 0, this.nonce = n.nonce, this.key = n.key, this.container = n.container, this.prepend = n.prepend, this.insertionPoint = n.insertionPoint, this.before = null;
  }
  var t = e.prototype;
  return t.hydrate = function(n) {
    n.forEach(this._insertTag);
  }, t.insert = function(n) {
    this.ctr % (this.isSpeedy ? 65e3 : 1) === 0 && this._insertTag(FX(this));
    var r = this.tags[this.tags.length - 1];
    if (this.isSpeedy) {
      var a = zX(r);
      try {
        a.insertRule(n, a.cssRules.length);
      } catch {
      }
    } else
      r.appendChild(document.createTextNode(n));
    this.ctr++;
  }, t.flush = function() {
    this.tags.forEach(function(n) {
      var r;
      return (r = n.parentNode) == null ? void 0 : r.removeChild(n);
    }), this.tags = [], this.ctr = 0;
  }, e;
})(), Uo = "-ms-", q0 = "-moz-", gn = "-webkit-", N1 = "comm", V3 = "rule", H3 = "decl", UX = "@import", R1 = "@keyframes", VX = "@layer", HX = Math.abs, e2 = String.fromCharCode, qX = Object.assign;
function WX(e, t) {
  return jo(e, 0) ^ 45 ? (((t << 2 ^ jo(e, 0)) << 2 ^ jo(e, 1)) << 2 ^ jo(e, 2)) << 2 ^ jo(e, 3) : 0;
}
function A1(e) {
  return e.trim();
}
function GX(e, t) {
  return (e = t.exec(e)) ? e[0] : e;
}
function vn(e, t, n) {
  return e.replace(t, n);
}
function HN(e, t) {
  return e.indexOf(t);
}
function jo(e, t) {
  return e.charCodeAt(t) | 0;
}
function ux(e, t, n) {
  return e.slice(t, n);
}
function il(e) {
  return e.length;
}
function q3(e) {
  return e.length;
}
function BS(e, t) {
  return t.push(e), e;
}
function KX(e, t) {
  return e.map(t).join("");
}
var t2 = 1, Rh = 1, j1 = 0, Na = 0, Ar = 0, Jh = "";
function n2(e, t, n, r, a, s, l) {
  return { value: e, root: t, parent: n, type: r, props: a, children: s, line: t2, column: Rh, length: l, return: "" };
}
function sw(e, t) {
  return qX(n2("", null, null, "", null, null, 0), e, { length: -e.length }, t);
}
function XX() {
  return Ar;
}
function YX() {
  return Ar = Na > 0 ? jo(Jh, --Na) : 0, Rh--, Ar === 10 && (Rh = 1, t2--), Ar;
}
function vi() {
  return Ar = Na < j1 ? jo(Jh, Na++) : 0, Rh++, Ar === 10 && (Rh = 1, t2++), Ar;
}
function wl() {
  return jo(Jh, Na);
}
function g0() {
  return Na;
}
function Qx(e, t) {
  return ux(Jh, e, t);
}
function cx(e) {
  switch (e) {
    // \0 \t \n \r \s whitespace token
    case 0:
    case 9:
    case 10:
    case 13:
    case 32:
      return 5;
    // ! + , / > @ ~ isolate token
    case 33:
    case 43:
    case 44:
    case 47:
    case 62:
    case 64:
    case 126:
    // ; { } breakpoint token
    case 59:
    case 123:
    case 125:
      return 4;
    // : accompanied token
    case 58:
      return 3;
    // " ' ( [ opening delimit token
    case 34:
    case 39:
    case 40:
    case 91:
      return 2;
    // ) ] closing delimit token
    case 41:
    case 93:
      return 1;
  }
  return 0;
}
function P1(e) {
  return t2 = Rh = 1, j1 = il(Jh = e), Na = 0, [];
}
function D1(e) {
  return Jh = "", e;
}
function v0(e) {
  return A1(Qx(Na - 1, qN(e === 91 ? e + 2 : e === 40 ? e + 1 : e)));
}
function QX(e) {
  for (; (Ar = wl()) && Ar < 33; )
    vi();
  return cx(e) > 2 || cx(Ar) > 3 ? "" : " ";
}
function JX(e, t) {
  for (; --t && vi() && !(Ar < 48 || Ar > 102 || Ar > 57 && Ar < 65 || Ar > 70 && Ar < 97); )
    ;
  return Qx(e, g0() + (t < 6 && wl() == 32 && vi() == 32));
}
function qN(e) {
  for (; vi(); )
    switch (Ar) {
      // ] ) " '
      case e:
        return Na;
      // " '
      case 34:
      case 39:
        e !== 34 && e !== 39 && qN(Ar);
        break;
      // (
      case 40:
        e === 41 && qN(e);
        break;
      // \
      case 92:
        vi();
        break;
    }
  return Na;
}
function ZX(e, t) {
  for (; vi() && e + Ar !== 57 && !(e + Ar === 84 && wl() === 47); )
    ;
  return "/*" + Qx(t, Na - 1) + "*" + e2(e === 47 ? e : vi());
}
function eY(e) {
  for (; !cx(wl()); )
    vi();
  return Qx(e, Na);
}
function tY(e) {
  return D1(y0("", null, null, null, [""], e = P1(e), 0, [0], e));
}
function y0(e, t, n, r, a, s, l, c, d) {
  for (var p = 0, m = 0, h = l, v = 0, y = 0, w = 0, x = 1, b = 1, k = 1, C = 0, _ = "", O = a, N = s, R = r, j = _; b; )
    switch (w = C, C = vi()) {
      // (
      case 40:
        if (w != 108 && jo(j, h - 1) == 58) {
          HN(j += vn(v0(C), "&", "&\f"), "&\f") != -1 && (k = -1);
          break;
        }
      // " ' [
      case 34:
      case 39:
      case 91:
        j += v0(C);
        break;
      // \t \n \r \s
      case 9:
      case 10:
      case 13:
      case 32:
        j += QX(w);
        break;
      // \
      case 92:
        j += JX(g0() - 1, 7);
        continue;
      // /
      case 47:
        switch (wl()) {
          case 42:
          case 47:
            BS(nY(ZX(vi(), g0()), t, n), d);
            break;
          default:
            j += "/";
        }
        break;
      // {
      case 123 * x:
        c[p++] = il(j) * k;
      // } ; \0
      case 125 * x:
      case 59:
      case 0:
        switch (C) {
          // \0 }
          case 0:
          case 125:
            b = 0;
          // ;
          case 59 + m:
            k == -1 && (j = vn(j, /\f/g, "")), y > 0 && il(j) - h && BS(y > 32 ? Wj(j + ";", r, n, h - 1) : Wj(vn(j, " ", "") + ";", r, n, h - 2), d);
            break;
          // @ ;
          case 59:
            j += ";";
          // { rule/at-rule
          default:
            if (BS(R = qj(j, t, n, p, m, a, c, _, O = [], N = [], h), s), C === 123)
              if (m === 0)
                y0(j, t, R, R, O, s, h, c, N);
              else
                switch (v === 99 && jo(j, 3) === 110 ? 100 : v) {
                  // d l m s
                  case 100:
                  case 108:
                  case 109:
                  case 115:
                    y0(e, R, R, r && BS(qj(e, R, R, 0, 0, a, c, _, a, O = [], h), N), a, N, h, c, r ? O : N);
                    break;
                  default:
                    y0(j, R, R, R, [""], N, 0, c, N);
                }
        }
        p = m = y = 0, x = k = 1, _ = j = "", h = l;
        break;
      // :
      case 58:
        h = 1 + il(j), y = w;
      default:
        if (x < 1) {
          if (C == 123)
            --x;
          else if (C == 125 && x++ == 0 && YX() == 125)
            continue;
        }
        switch (j += e2(C), C * x) {
          // &
          case 38:
            k = m > 0 ? 1 : (j += "\f", -1);
            break;
          // ,
          case 44:
            c[p++] = (il(j) - 1) * k, k = 1;
            break;
          // @
          case 64:
            wl() === 45 && (j += v0(vi())), v = wl(), m = h = il(_ = j += eY(g0())), C++;
            break;
          // -
          case 45:
            w === 45 && il(j) == 2 && (x = 0);
        }
    }
  return s;
}
function qj(e, t, n, r, a, s, l, c, d, p, m) {
  for (var h = a - 1, v = a === 0 ? s : [""], y = q3(v), w = 0, x = 0, b = 0; w < r; ++w)
    for (var k = 0, C = ux(e, h + 1, h = HX(x = l[w])), _ = e; k < y; ++k)
      (_ = A1(x > 0 ? v[k] + " " + C : vn(C, /&\f/g, v[k]))) && (d[b++] = _);
  return n2(e, t, n, a === 0 ? V3 : c, d, p, m);
}
function nY(e, t, n) {
  return n2(e, t, n, N1, e2(XX()), ux(e, 2, -2), 0);
}
function Wj(e, t, n, r) {
  return n2(e, t, n, H3, ux(e, 0, r), ux(e, r + 1, -1), r);
}
function yh(e, t) {
  for (var n = "", r = q3(e), a = 0; a < r; a++)
    n += t(e[a], a, e, t) || "";
  return n;
}
function rY(e, t, n, r) {
  switch (e.type) {
    case VX:
      if (e.children.length) break;
    case UX:
    case H3:
      return e.return = e.return || e.value;
    case N1:
      return "";
    case R1:
      return e.return = e.value + "{" + yh(e.children, r) + "}";
    case V3:
      e.value = e.props.join(",");
  }
  return il(n = yh(e.children, r)) ? e.return = e.value + "{" + n + "}" : "";
}
function oY(e) {
  var t = q3(e);
  return function(n, r, a, s) {
    for (var l = "", c = 0; c < t; c++)
      l += e[c](n, r, a, s) || "";
    return l;
  };
}
function aY(e) {
  return function(t) {
    t.root || (t = t.return) && e(t);
  };
}
function $1(e) {
  var t = /* @__PURE__ */ Object.create(null);
  return function(n) {
    return t[n] === void 0 && (t[n] = e(n)), t[n];
  };
}
var iY = function(e, t, n) {
  for (var r = 0, a = 0; r = a, a = wl(), r === 38 && a === 12 && (t[n] = 1), !cx(a); )
    vi();
  return Qx(e, Na);
}, sY = function(e, t) {
  var n = -1, r = 44;
  do
    switch (cx(r)) {
      case 0:
        r === 38 && wl() === 12 && (t[n] = 1), e[n] += iY(Na - 1, t, n);
        break;
      case 2:
        e[n] += v0(r);
        break;
      case 4:
        if (r === 44) {
          e[++n] = wl() === 58 ? "&\f" : "", t[n] = e[n].length;
          break;
        }
      // fallthrough
      default:
        e[n] += e2(r);
    }
  while (r = vi());
  return e;
}, lY = function(e, t) {
  return D1(sY(P1(e), t));
}, Gj = /* @__PURE__ */ new WeakMap(), uY = function(e) {
  if (!(e.type !== "rule" || !e.parent || // positive .length indicates that this rule contains pseudo
  // negative .length indicates that this rule has been already prefixed
  e.length < 1)) {
    for (var t = e.value, n = e.parent, r = e.column === n.column && e.line === n.line; n.type !== "rule"; )
      if (n = n.parent, !n) return;
    if (!(e.props.length === 1 && t.charCodeAt(0) !== 58 && !Gj.get(n)) && !r) {
      Gj.set(e, !0);
      for (var a = [], s = lY(t, a), l = n.props, c = 0, d = 0; c < s.length; c++)
        for (var p = 0; p < l.length; p++, d++)
          e.props[d] = a[c] ? s[c].replace(/&\f/g, l[p]) : l[p] + " " + s[c];
    }
  }
}, cY = function(e) {
  if (e.type === "decl") {
    var t = e.value;
    t.charCodeAt(0) === 108 && // charcode for b
    t.charCodeAt(2) === 98 && (e.return = "", e.value = "");
  }
};
function T1(e, t) {
  switch (WX(e, t)) {
    // color-adjust
    case 5103:
      return gn + "print-" + e + e;
    // animation, animation-(delay|direction|duration|fill-mode|iteration-count|name|play-state|timing-function)
    case 5737:
    case 4201:
    case 3177:
    case 3433:
    case 1641:
    case 4457:
    case 2921:
    // text-decoration, filter, clip-path, backface-visibility, column, box-decoration-break
    case 5572:
    case 6356:
    case 5844:
    case 3191:
    case 6645:
    case 3005:
    // mask, mask-image, mask-(mode|clip|size), mask-(repeat|origin), mask-position, mask-composite,
    case 6391:
    case 5879:
    case 5623:
    case 6135:
    case 4599:
    case 4855:
    // background-clip, columns, column-(count|fill|gap|rule|rule-color|rule-style|rule-width|span|width)
    case 4215:
    case 6389:
    case 5109:
    case 5365:
    case 5621:
    case 3829:
      return gn + e + e;
    // appearance, user-select, transform, hyphens, text-size-adjust
    case 5349:
    case 4246:
    case 4810:
    case 6968:
    case 2756:
      return gn + e + q0 + e + Uo + e + e;
    // flex, flex-direction
    case 6828:
    case 4268:
      return gn + e + Uo + e + e;
    // order
    case 6165:
      return gn + e + Uo + "flex-" + e + e;
    // align-items
    case 5187:
      return gn + e + vn(e, /(\w+).+(:[^]+)/, gn + "box-$1$2" + Uo + "flex-$1$2") + e;
    // align-self
    case 5443:
      return gn + e + Uo + "flex-item-" + vn(e, /flex-|-self/, "") + e;
    // align-content
    case 4675:
      return gn + e + Uo + "flex-line-pack" + vn(e, /align-content|flex-|-self/, "") + e;
    // flex-shrink
    case 5548:
      return gn + e + Uo + vn(e, "shrink", "negative") + e;
    // flex-basis
    case 5292:
      return gn + e + Uo + vn(e, "basis", "preferred-size") + e;
    // flex-grow
    case 6060:
      return gn + "box-" + vn(e, "-grow", "") + gn + e + Uo + vn(e, "grow", "positive") + e;
    // transition
    case 4554:
      return gn + vn(e, /([^-])(transform)/g, "$1" + gn + "$2") + e;
    // cursor
    case 6187:
      return vn(vn(vn(e, /(zoom-|grab)/, gn + "$1"), /(image-set)/, gn + "$1"), e, "") + e;
    // background, background-image
    case 5495:
    case 3959:
      return vn(e, /(image-set\([^]*)/, gn + "$1$`$1");
    // justify-content
    case 4968:
      return vn(vn(e, /(.+:)(flex-)?(.*)/, gn + "box-pack:$3" + Uo + "flex-pack:$3"), /s.+-b[^;]+/, "justify") + gn + e + e;
    // (margin|padding)-inline-(start|end)
    case 4095:
    case 3583:
    case 4068:
    case 2532:
      return vn(e, /(.+)-inline(.+)/, gn + "$1$2") + e;
    // (min|max)?(width|height|inline-size|block-size)
    case 8116:
    case 7059:
    case 5753:
    case 5535:
    case 5445:
    case 5701:
    case 4933:
    case 4677:
    case 5533:
    case 5789:
    case 5021:
    case 4765:
      if (il(e) - 1 - t > 6) switch (jo(e, t + 1)) {
        // (m)ax-content, (m)in-content
        case 109:
          if (jo(e, t + 4) !== 45) break;
        // (f)ill-available, (f)it-content
        case 102:
          return vn(e, /(.+:)(.+)-([^]+)/, "$1" + gn + "$2-$3$1" + q0 + (jo(e, t + 3) == 108 ? "$3" : "$2-$3")) + e;
        // (s)tretch
        case 115:
          return ~HN(e, "stretch") ? T1(vn(e, "stretch", "fill-available"), t) + e : e;
      }
      break;
    // position: sticky
    case 4949:
      if (jo(e, t + 1) !== 115) break;
    // display: (flex|inline-flex)
    case 6444:
      switch (jo(e, il(e) - 3 - (~HN(e, "!important") && 10))) {
        // stic(k)y
        case 107:
          return vn(e, ":", ":" + gn) + e;
        // (inline-)?fl(e)x
        case 101:
          return vn(e, /(.+:)([^;!]+)(;|!.+)?/, "$1" + gn + (jo(e, 14) === 45 ? "inline-" : "") + "box$3$1" + gn + "$2$3$1" + Uo + "$2box$3") + e;
      }
      break;
    // writing-mode
    case 5936:
      switch (jo(e, t + 11)) {
        // vertical-l(r)
        case 114:
          return gn + e + Uo + vn(e, /[svh]\w+-[tblr]{2}/, "tb") + e;
        // vertical-r(l)
        case 108:
          return gn + e + Uo + vn(e, /[svh]\w+-[tblr]{2}/, "tb-rl") + e;
        // horizontal(-)tb
        case 45:
          return gn + e + Uo + vn(e, /[svh]\w+-[tblr]{2}/, "lr") + e;
      }
      return gn + e + Uo + e + e;
  }
  return e;
}
var dY = function(e, t, n, r) {
  if (e.length > -1 && !e.return) switch (e.type) {
    case H3:
      e.return = T1(e.value, e.length);
      break;
    case R1:
      return yh([sw(e, {
        value: vn(e.value, "@", "@" + gn)
      })], r);
    case V3:
      if (e.length) return KX(e.props, function(a) {
        switch (GX(a, /(::plac\w+|:read-\w+)/)) {
          // :read-(only|write)
          case ":read-only":
          case ":read-write":
            return yh([sw(e, {
              props: [vn(a, /:(read-\w+)/, ":" + q0 + "$1")]
            })], r);
          // :placeholder
          case "::placeholder":
            return yh([sw(e, {
              props: [vn(a, /:(plac\w+)/, ":" + gn + "input-$1")]
            }), sw(e, {
              props: [vn(a, /:(plac\w+)/, ":" + q0 + "$1")]
            }), sw(e, {
              props: [vn(a, /:(plac\w+)/, Uo + "input-$1")]
            })], r);
        }
        return "";
      });
  }
}, fY = [dY], pY = function(e) {
  var t = e.key;
  if (t === "css") {
    var n = document.querySelectorAll("style[data-emotion]:not([data-s])");
    Array.prototype.forEach.call(n, function(w) {
      var x = w.getAttribute("data-emotion");
      x.indexOf(" ") !== -1 && (document.head.appendChild(w), w.setAttribute("data-s", ""));
    });
  }
  var r = e.stylisPlugins || fY, a = {}, s, l = [];
  s = e.container || document.head, Array.prototype.forEach.call(
    // this means we will ignore elements which don't have a space in them which
    // means that the style elements we're looking at are only Emotion 11 server-rendered style elements
    document.querySelectorAll('style[data-emotion^="' + t + ' "]'),
    function(w) {
      for (var x = w.getAttribute("data-emotion").split(" "), b = 1; b < x.length; b++)
        a[x[b]] = !0;
      l.push(w);
    }
  );
  var c, d = [uY, cY];
  {
    var p, m = [rY, aY(function(w) {
      p.insert(w);
    })], h = oY(d.concat(r, m)), v = function(w) {
      return yh(tY(w), h);
    };
    c = function(w, x, b, k) {
      p = b, v(w ? w + "{" + x.styles + "}" : x.styles), k && (y.inserted[x.name] = !0);
    };
  }
  var y = {
    key: t,
    sheet: new BX({
      key: t,
      container: s,
      nonce: e.nonce,
      speedy: e.speedy,
      prepend: e.prepend,
      insertionPoint: e.insertionPoint
    }),
    nonce: e.nonce,
    inserted: a,
    registered: {},
    insert: c
  };
  return y.sheet.hydrate(l), y;
}, XO, Kj;
function mY() {
  if (Kj) return XO;
  Kj = 1;
  var e = UK(), t = {
    childContextTypes: !0,
    contextType: !0,
    contextTypes: !0,
    defaultProps: !0,
    displayName: !0,
    getDefaultProps: !0,
    getDerivedStateFromError: !0,
    getDerivedStateFromProps: !0,
    mixins: !0,
    propTypes: !0,
    type: !0
  }, n = {
    name: !0,
    length: !0,
    prototype: !0,
    caller: !0,
    callee: !0,
    arguments: !0,
    arity: !0
  }, r = {
    $$typeof: !0,
    render: !0,
    defaultProps: !0,
    displayName: !0,
    propTypes: !0
  }, a = {
    $$typeof: !0,
    compare: !0,
    defaultProps: !0,
    displayName: !0,
    propTypes: !0,
    type: !0
  }, s = {};
  s[e.ForwardRef] = r, s[e.Memo] = a;
  function l(w) {
    return e.isMemo(w) ? a : s[w.$$typeof] || t;
  }
  var c = Object.defineProperty, d = Object.getOwnPropertyNames, p = Object.getOwnPropertySymbols, m = Object.getOwnPropertyDescriptor, h = Object.getPrototypeOf, v = Object.prototype;
  function y(w, x, b) {
    if (typeof x != "string") {
      if (v) {
        var k = h(x);
        k && k !== v && y(w, k, b);
      }
      var C = d(x);
      p && (C = C.concat(p(x)));
      for (var _ = l(w), O = l(x), N = 0; N < C.length; ++N) {
        var R = C[N];
        if (!n[R] && !(b && b[R]) && !(O && O[R]) && !(_ && _[R])) {
          var j = m(x, R);
          try {
            c(w, R, j);
          } catch {
          }
        }
      }
    }
    return w;
  }
  return XO = y, XO;
}
mY();
var hY = !0;
function L1(e, t, n) {
  var r = "";
  return n.split(" ").forEach(function(a) {
    e[a] !== void 0 ? t.push(e[a] + ";") : a && (r += a + " ");
  }), r;
}
var W3 = function(e, t, n) {
  var r = e.key + "-" + t.name;
  (n === !1 || // we need to always store it if we're in compat mode and
  // in node since emotion-server relies on whether a style is in
  // the registered cache to know whether a style is global or not
  // also, note that this check will be dead code eliminated in the browser
  hY === !1) && e.registered[r] === void 0 && (e.registered[r] = t.styles);
}, G3 = function(e, t, n) {
  W3(e, t, n);
  var r = e.key + "-" + t.name;
  if (e.inserted[t.name] === void 0) {
    var a = t;
    do
      e.insert(t === a ? "." + r : "", a, e.sheet, !0), a = a.next;
    while (a !== void 0);
  }
};
function gY(e) {
  for (var t = 0, n, r = 0, a = e.length; a >= 4; ++r, a -= 4)
    n = e.charCodeAt(r) & 255 | (e.charCodeAt(++r) & 255) << 8 | (e.charCodeAt(++r) & 255) << 16 | (e.charCodeAt(++r) & 255) << 24, n = /* Math.imul(k, m): */
    (n & 65535) * 1540483477 + ((n >>> 16) * 59797 << 16), n ^= /* k >>> r: */
    n >>> 24, t = /* Math.imul(k, m): */
    (n & 65535) * 1540483477 + ((n >>> 16) * 59797 << 16) ^ /* Math.imul(h, m): */
    (t & 65535) * 1540483477 + ((t >>> 16) * 59797 << 16);
  switch (a) {
    case 3:
      t ^= (e.charCodeAt(r + 2) & 255) << 16;
    case 2:
      t ^= (e.charCodeAt(r + 1) & 255) << 8;
    case 1:
      t ^= e.charCodeAt(r) & 255, t = /* Math.imul(h, m): */
      (t & 65535) * 1540483477 + ((t >>> 16) * 59797 << 16);
  }
  return t ^= t >>> 13, t = /* Math.imul(h, m): */
  (t & 65535) * 1540483477 + ((t >>> 16) * 59797 << 16), ((t ^ t >>> 15) >>> 0).toString(36);
}
var vY = {
  animationIterationCount: 1,
  aspectRatio: 1,
  borderImageOutset: 1,
  borderImageSlice: 1,
  borderImageWidth: 1,
  boxFlex: 1,
  boxFlexGroup: 1,
  boxOrdinalGroup: 1,
  columnCount: 1,
  columns: 1,
  flex: 1,
  flexGrow: 1,
  flexPositive: 1,
  flexShrink: 1,
  flexNegative: 1,
  flexOrder: 1,
  gridRow: 1,
  gridRowEnd: 1,
  gridRowSpan: 1,
  gridRowStart: 1,
  gridColumn: 1,
  gridColumnEnd: 1,
  gridColumnSpan: 1,
  gridColumnStart: 1,
  msGridRow: 1,
  msGridRowSpan: 1,
  msGridColumn: 1,
  msGridColumnSpan: 1,
  fontWeight: 1,
  lineHeight: 1,
  opacity: 1,
  order: 1,
  orphans: 1,
  scale: 1,
  tabSize: 1,
  widows: 1,
  zIndex: 1,
  zoom: 1,
  WebkitLineClamp: 1,
  // SVG-related properties
  fillOpacity: 1,
  floodOpacity: 1,
  stopOpacity: 1,
  strokeDasharray: 1,
  strokeDashoffset: 1,
  strokeMiterlimit: 1,
  strokeOpacity: 1,
  strokeWidth: 1
}, yY = /[A-Z]|^ms/g, bY = /_EMO_([^_]+?)_([^]*?)_EMO_/g, I1 = function(e) {
  return e.charCodeAt(1) === 45;
}, Xj = function(e) {
  return e != null && typeof e != "boolean";
}, YO = /* @__PURE__ */ $1(function(e) {
  return I1(e) ? e : e.replace(yY, "-$&").toLowerCase();
}), Yj = function(e, t) {
  switch (e) {
    case "animation":
    case "animationName":
      if (typeof t == "string")
        return t.replace(bY, function(n, r, a) {
          return sl = {
            name: r,
            styles: a,
            next: sl
          }, r;
        });
  }
  return vY[e] !== 1 && !I1(e) && typeof t == "number" && t !== 0 ? t + "px" : t;
};
function dx(e, t, n) {
  if (n == null)
    return "";
  var r = n;
  if (r.__emotion_styles !== void 0)
    return r;
  switch (typeof n) {
    case "boolean":
      return "";
    case "object": {
      var a = n;
      if (a.anim === 1)
        return sl = {
          name: a.name,
          styles: a.styles,
          next: sl
        }, a.name;
      var s = n;
      if (s.styles !== void 0) {
        var l = s.next;
        if (l !== void 0)
          for (; l !== void 0; )
            sl = {
              name: l.name,
              styles: l.styles,
              next: sl
            }, l = l.next;
        var c = s.styles + ";";
        return c;
      }
      return wY(e, t, n);
    }
    case "function": {
      if (e !== void 0) {
        var d = sl, p = n(e);
        return sl = d, dx(e, t, p);
      }
      break;
    }
  }
  var m = n;
  if (t == null)
    return m;
  var h = t[m];
  return h !== void 0 ? h : m;
}
function wY(e, t, n) {
  var r = "";
  if (Array.isArray(n))
    for (var a = 0; a < n.length; a++)
      r += dx(e, t, n[a]) + ";";
  else
    for (var s in n) {
      var l = n[s];
      if (typeof l != "object") {
        var c = l;
        t != null && t[c] !== void 0 ? r += s + "{" + t[c] + "}" : Xj(c) && (r += YO(s) + ":" + Yj(s, c) + ";");
      } else if (Array.isArray(l) && typeof l[0] == "string" && (t == null || t[l[0]] === void 0))
        for (var d = 0; d < l.length; d++)
          Xj(l[d]) && (r += YO(s) + ":" + Yj(s, l[d]) + ";");
      else {
        var p = dx(e, t, l);
        switch (s) {
          case "animation":
          case "animationName": {
            r += YO(s) + ":" + p + ";";
            break;
          }
          default:
            r += s + "{" + p + "}";
        }
      }
    }
  return r;
}
var Qj = /label:\s*([^\s;{]+)\s*(;|$)/g, sl;
function Jx(e, t, n) {
  if (e.length === 1 && typeof e[0] == "object" && e[0] !== null && e[0].styles !== void 0)
    return e[0];
  var r = !0, a = "";
  sl = void 0;
  var s = e[0];
  if (s == null || s.raw === void 0)
    r = !1, a += dx(n, t, s);
  else {
    var l = s;
    a += l[0];
  }
  for (var c = 1; c < e.length; c++)
    if (a += dx(n, t, e[c]), r) {
      var d = s;
      a += d[c];
    }
  Qj.lastIndex = 0;
  for (var p = "", m; (m = Qj.exec(a)) !== null; )
    p += "-" + m[1];
  var h = gY(a) + p;
  return {
    name: h,
    styles: a,
    next: sl
  };
}
var xY = function(e) {
  return e();
}, z1 = M.useInsertionEffect ? M.useInsertionEffect : !1, F1 = z1 || xY, Jj = z1 || M.useLayoutEffect, B1 = /* @__PURE__ */ M.createContext(
  // we're doing this to avoid preconstruct's dead code elimination in this one case
  // because this module is primarily intended for the browser and node
  // but it's also required in react native and similar environments sometimes
  // and we could have a special build just for that
  // but this is much easier and the native packages
  // might use a different theme context in the future anyway
  typeof HTMLElement < "u" ? /* @__PURE__ */ pY({
    key: "css"
  }) : null
);
B1.Provider;
var K3 = function(e) {
  return /* @__PURE__ */ M.forwardRef(function(t, n) {
    var r = M.useContext(B1);
    return e(t, r, n);
  });
}, Zx = /* @__PURE__ */ M.createContext({}), X3 = {}.hasOwnProperty, WN = "__EMOTION_TYPE_PLEASE_DO_NOT_USE__", SY = function(e, t) {
  var n = {};
  for (var r in t)
    X3.call(t, r) && (n[r] = t[r]);
  return n[WN] = e, n;
}, kY = function(e) {
  var t = e.cache, n = e.serialized, r = e.isStringTag;
  return W3(t, n, r), F1(function() {
    return G3(t, n, r);
  }), null;
}, _Y = /* @__PURE__ */ K3(function(e, t, n) {
  var r = e.css;
  typeof r == "string" && t.registered[r] !== void 0 && (r = t.registered[r]);
  var a = e[WN], s = [r], l = "";
  typeof e.className == "string" ? l = L1(t.registered, s, e.className) : e.className != null && (l = e.className + " ");
  var c = Jx(s, void 0, M.useContext(Zx));
  l += t.key + "-" + c.name;
  var d = {};
  for (var p in e)
    X3.call(e, p) && p !== "css" && p !== WN && (d[p] = e[p]);
  return d.className = l, n && (d.ref = n), /* @__PURE__ */ M.createElement(M.Fragment, null, /* @__PURE__ */ M.createElement(kY, {
    cache: t,
    serialized: c,
    isStringTag: typeof a == "string"
  }), /* @__PURE__ */ M.createElement(a, d));
}), EY = _Y, ut = function(e, t) {
  var n = arguments;
  if (t == null || !X3.call(t, "css"))
    return M.createElement.apply(void 0, n);
  var r = n.length, a = new Array(r);
  a[0] = EY, a[1] = SY(e, t);
  for (var s = 2; s < r; s++)
    a[s] = n[s];
  return M.createElement.apply(null, a);
};
(function(e) {
  var t;
  t || (t = e.JSX || (e.JSX = {}));
})(ut || (ut = {}));
var CY = /* @__PURE__ */ K3(function(e, t) {
  var n = e.styles, r = Jx([n], void 0, M.useContext(Zx)), a = M.useRef();
  return Jj(function() {
    var s = t.key + "-global", l = new t.sheet.constructor({
      key: s,
      nonce: t.sheet.nonce,
      container: t.sheet.container,
      speedy: t.sheet.isSpeedy
    }), c = !1, d = document.querySelector('style[data-emotion="' + s + " " + r.name + '"]');
    return t.sheet.tags.length && (l.before = t.sheet.tags[0]), d !== null && (c = !0, d.setAttribute("data-emotion", s), l.hydrate([d])), a.current = [l, c], function() {
      l.flush();
    };
  }, [t]), Jj(function() {
    var s = a.current, l = s[0], c = s[1];
    if (c) {
      s[1] = !1;
      return;
    }
    if (r.next !== void 0 && G3(t, r.next, !0), l.tags.length) {
      var d = l.tags[l.tags.length - 1].nextElementSibling;
      l.before = d, l.flush();
    }
    t.insert("", r, l, !1);
  }, [t, r.name]), null;
});
function eS() {
  for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)
    t[n] = arguments[n];
  return Jx(t);
}
function Zh() {
  var e = eS.apply(void 0, arguments), t = "animation-" + e.name;
  return {
    name: t,
    styles: "@keyframes " + t + "{" + e.styles + "}",
    anim: 1,
    toString: function() {
      return "_EMO_" + this.name + "_" + this.styles + "_EMO_";
    }
  };
}
var OY = /^((children|dangerouslySetInnerHTML|key|ref|autoFocus|defaultValue|defaultChecked|innerHTML|suppressContentEditableWarning|suppressHydrationWarning|valueLink|abbr|accept|acceptCharset|accessKey|action|allow|allowUserMedia|allowPaymentRequest|allowFullScreen|allowTransparency|alt|async|autoComplete|autoPlay|capture|cellPadding|cellSpacing|challenge|charSet|checked|cite|classID|className|cols|colSpan|content|contentEditable|contextMenu|controls|controlsList|coords|crossOrigin|data|dateTime|decoding|default|defer|dir|disabled|disablePictureInPicture|disableRemotePlayback|download|draggable|encType|enterKeyHint|fetchpriority|fetchPriority|form|formAction|formEncType|formMethod|formNoValidate|formTarget|frameBorder|headers|height|hidden|high|href|hrefLang|htmlFor|httpEquiv|id|inputMode|integrity|is|keyParams|keyType|kind|label|lang|list|loading|loop|low|marginHeight|marginWidth|max|maxLength|media|mediaGroup|method|min|minLength|multiple|muted|name|nonce|noValidate|open|optimum|pattern|placeholder|playsInline|poster|preload|profile|radioGroup|readOnly|referrerPolicy|rel|required|reversed|role|rows|rowSpan|sandbox|scope|scoped|scrolling|seamless|selected|shape|size|sizes|slot|span|spellCheck|src|srcDoc|srcLang|srcSet|start|step|style|summary|tabIndex|target|title|translate|type|useMap|value|width|wmode|wrap|about|datatype|inlist|prefix|property|resource|typeof|vocab|autoCapitalize|autoCorrect|autoSave|color|incremental|fallback|inert|itemProp|itemScope|itemType|itemID|itemRef|on|option|results|security|unselectable|accentHeight|accumulate|additive|alignmentBaseline|allowReorder|alphabetic|amplitude|arabicForm|ascent|attributeName|attributeType|autoReverse|azimuth|baseFrequency|baselineShift|baseProfile|bbox|begin|bias|by|calcMode|capHeight|clip|clipPathUnits|clipPath|clipRule|colorInterpolation|colorInterpolationFilters|colorProfile|colorRendering|contentScriptType|contentStyleType|cursor|cx|cy|d|decelerate|descent|diffuseConstant|direction|display|divisor|dominantBaseline|dur|dx|dy|edgeMode|elevation|enableBackground|end|exponent|externalResourcesRequired|fill|fillOpacity|fillRule|filter|filterRes|filterUnits|floodColor|floodOpacity|focusable|fontFamily|fontSize|fontSizeAdjust|fontStretch|fontStyle|fontVariant|fontWeight|format|from|fr|fx|fy|g1|g2|glyphName|glyphOrientationHorizontal|glyphOrientationVertical|glyphRef|gradientTransform|gradientUnits|hanging|horizAdvX|horizOriginX|ideographic|imageRendering|in|in2|intercept|k|k1|k2|k3|k4|kernelMatrix|kernelUnitLength|kerning|keyPoints|keySplines|keyTimes|lengthAdjust|letterSpacing|lightingColor|limitingConeAngle|local|markerEnd|markerMid|markerStart|markerHeight|markerUnits|markerWidth|mask|maskContentUnits|maskUnits|mathematical|mode|numOctaves|offset|opacity|operator|order|orient|orientation|origin|overflow|overlinePosition|overlineThickness|panose1|paintOrder|pathLength|patternContentUnits|patternTransform|patternUnits|pointerEvents|points|pointsAtX|pointsAtY|pointsAtZ|preserveAlpha|preserveAspectRatio|primitiveUnits|r|radius|refX|refY|renderingIntent|repeatCount|repeatDur|requiredExtensions|requiredFeatures|restart|result|rotate|rx|ry|scale|seed|shapeRendering|slope|spacing|specularConstant|specularExponent|speed|spreadMethod|startOffset|stdDeviation|stemh|stemv|stitchTiles|stopColor|stopOpacity|strikethroughPosition|strikethroughThickness|string|stroke|strokeDasharray|strokeDashoffset|strokeLinecap|strokeLinejoin|strokeMiterlimit|strokeOpacity|strokeWidth|surfaceScale|systemLanguage|tableValues|targetX|targetY|textAnchor|textDecoration|textRendering|textLength|to|transform|u1|u2|underlinePosition|underlineThickness|unicode|unicodeBidi|unicodeRange|unitsPerEm|vAlphabetic|vHanging|vIdeographic|vMathematical|values|vectorEffect|version|vertAdvY|vertOriginX|vertOriginY|viewBox|viewTarget|visibility|widths|wordSpacing|writingMode|x|xHeight|x1|x2|xChannelSelector|xlinkActuate|xlinkArcrole|xlinkHref|xlinkRole|xlinkShow|xlinkTitle|xlinkType|xmlBase|xmlns|xmlnsXlink|xmlLang|xmlSpace|y|y1|y2|yChannelSelector|z|zoomAndPan|for|class|autofocus)|(([Dd][Aa][Tt][Aa]|[Aa][Rr][Ii][Aa]|x)-.*))$/, MY = /* @__PURE__ */ $1(
  function(e) {
    return OY.test(e) || e.charCodeAt(0) === 111 && e.charCodeAt(1) === 110 && e.charCodeAt(2) < 91;
  }
  /* Z+1 */
), NY = MY, RY = function(e) {
  return e !== "theme";
}, Zj = function(e) {
  return typeof e == "string" && // 96 is one less than the char code
  // for "a" so this is checking that
  // it's a lowercase character
  e.charCodeAt(0) > 96 ? NY : RY;
}, eP = function(e, t, n) {
  var r;
  if (t) {
    var a = t.shouldForwardProp;
    r = e.__emotion_forwardProp && a ? function(s) {
      return e.__emotion_forwardProp(s) && a(s);
    } : a;
  }
  return typeof r != "function" && n && (r = e.__emotion_forwardProp), r;
}, AY = function(e) {
  var t = e.cache, n = e.serialized, r = e.isStringTag;
  return W3(t, n, r), F1(function() {
    return G3(t, n, r);
  }), null;
}, jY = function e(t, n) {
  var r = t.__emotion_real === t, a = r && t.__emotion_base || t, s, l;
  n !== void 0 && (s = n.label, l = n.target);
  var c = eP(t, n, r), d = c || Zj(a), p = !d("as");
  return function() {
    var m = arguments, h = r && t.__emotion_styles !== void 0 ? t.__emotion_styles.slice(0) : [];
    if (s !== void 0 && h.push("label:" + s + ";"), m[0] == null || m[0].raw === void 0)
      h.push.apply(h, m);
    else {
      var v = m[0];
      h.push(v[0]);
      for (var y = m.length, w = 1; w < y; w++)
        h.push(m[w], v[w]);
    }
    var x = K3(function(b, k, C) {
      var _ = p && b.as || a, O = "", N = [], R = b;
      if (b.theme == null) {
        R = {};
        for (var j in b)
          R[j] = b[j];
        R.theme = M.useContext(Zx);
      }
      typeof b.className == "string" ? O = L1(k.registered, N, b.className) : b.className != null && (O = b.className + " ");
      var D = Jx(h.concat(N), k.registered, R);
      O += k.key + "-" + D.name, l !== void 0 && (O += " " + l);
      var $ = p && c === void 0 ? Zj(_) : d, z = {};
      for (var B in b)
        p && B === "as" || $(B) && (z[B] = b[B]);
      return z.className = O, C && (z.ref = C), /* @__PURE__ */ M.createElement(M.Fragment, null, /* @__PURE__ */ M.createElement(AY, {
        cache: k,
        serialized: D,
        isStringTag: typeof _ == "string"
      }), /* @__PURE__ */ M.createElement(_, z));
    });
    return x.displayName = s !== void 0 ? s : "Styled(" + (typeof a == "string" ? a : a.displayName || a.name || "Component") + ")", x.defaultProps = t.defaultProps, x.__emotion_real = x, x.__emotion_base = a, x.__emotion_styles = h, x.__emotion_forwardProp = c, Object.defineProperty(x, "toString", {
      value: function() {
        return "." + l;
      }
    }), x.withComponent = function(b, k) {
      var C = e(b, ft({}, n, k, {
        shouldForwardProp: eP(x, k, !0)
      }));
      return C.apply(void 0, h);
    }, x;
  };
}, PY = [
  "a",
  "abbr",
  "address",
  "area",
  "article",
  "aside",
  "audio",
  "b",
  "base",
  "bdi",
  "bdo",
  "big",
  "blockquote",
  "body",
  "br",
  "button",
  "canvas",
  "caption",
  "cite",
  "code",
  "col",
  "colgroup",
  "data",
  "datalist",
  "dd",
  "del",
  "details",
  "dfn",
  "dialog",
  "div",
  "dl",
  "dt",
  "em",
  "embed",
  "fieldset",
  "figcaption",
  "figure",
  "footer",
  "form",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "head",
  "header",
  "hgroup",
  "hr",
  "html",
  "i",
  "iframe",
  "img",
  "input",
  "ins",
  "kbd",
  "keygen",
  "label",
  "legend",
  "li",
  "link",
  "main",
  "map",
  "mark",
  "marquee",
  "menu",
  "menuitem",
  "meta",
  "meter",
  "nav",
  "noscript",
  "object",
  "ol",
  "optgroup",
  "option",
  "output",
  "p",
  "param",
  "picture",
  "pre",
  "progress",
  "q",
  "rp",
  "rt",
  "ruby",
  "s",
  "samp",
  "script",
  "section",
  "select",
  "small",
  "source",
  "span",
  "strong",
  "style",
  "sub",
  "summary",
  "sup",
  "table",
  "tbody",
  "td",
  "textarea",
  "tfoot",
  "th",
  "thead",
  "time",
  "title",
  "tr",
  "track",
  "u",
  "ul",
  "var",
  "video",
  "wbr",
  // SVG
  "circle",
  "clipPath",
  "defs",
  "ellipse",
  "foreignObject",
  "g",
  "image",
  "line",
  "linearGradient",
  "mask",
  "path",
  "pattern",
  "polygon",
  "polyline",
  "radialGradient",
  "rect",
  "stop",
  "svg",
  "text",
  "tspan"
], GN = jY.bind(null);
PY.forEach(function(e) {
  GN[e] = GN(e);
});
function DY(e) {
  return e == null || Object.keys(e).length === 0;
}
function U1(e) {
  const {
    styles: t,
    defaultTheme: n = {}
  } = e, r = typeof t == "function" ? (a) => t(DY(a) ? n : a) : t;
  return /* @__PURE__ */ E.jsx(CY, {
    styles: r
  });
}
function V1(e, t) {
  return GN(e, t);
}
function $Y(e, t) {
  Array.isArray(e.__emotion_styles) && (e.__emotion_styles = t(e.__emotion_styles));
}
const tP = [];
function Jc(e) {
  return tP[0] = e, Jx(tP);
}
const TY = (e) => {
  const t = Object.keys(e).map((n) => ({
    key: n,
    val: e[n]
  })) || [];
  return t.sort((n, r) => n.val - r.val), t.reduce((n, r) => ({
    ...n,
    [r.key]: r.val
  }), {});
};
function LY(e) {
  const {
    // The breakpoint **start** at this value.
    // For instance with the first breakpoint xs: [xs, sm).
    values: t = {
      xs: 0,
      // phone
      sm: 600,
      // tablet
      md: 900,
      // small laptop
      lg: 1200,
      // desktop
      xl: 1536
      // large screen
    },
    unit: n = "px",
    step: r = 5,
    ...a
  } = e, s = TY(t), l = Object.keys(s);
  function c(v) {
    return `@media (min-width:${typeof t[v] == "number" ? t[v] : v}${n})`;
  }
  function d(v) {
    return `@media (max-width:${(typeof t[v] == "number" ? t[v] : v) - r / 100}${n})`;
  }
  function p(v, y) {
    const w = l.indexOf(y);
    return `@media (min-width:${typeof t[v] == "number" ? t[v] : v}${n}) and (max-width:${(w !== -1 && typeof t[l[w]] == "number" ? t[l[w]] : y) - r / 100}${n})`;
  }
  function m(v) {
    return l.indexOf(v) + 1 < l.length ? p(v, l[l.indexOf(v) + 1]) : c(v);
  }
  function h(v) {
    const y = l.indexOf(v);
    return y === 0 ? c(l[1]) : y === l.length - 1 ? d(l[y]) : p(v, l[l.indexOf(v) + 1]).replace("@media", "@media not all and");
  }
  return {
    keys: l,
    values: s,
    up: c,
    down: d,
    between: p,
    only: m,
    not: h,
    unit: n,
    ...a
  };
}
const IY = {
  borderRadius: 4
};
function H1(e = 8, t = F3({
  spacing: e
})) {
  if (e.mui)
    return e;
  const n = (...r) => (r.length === 0 ? [1] : r).map((a) => {
    const s = t(a);
    return typeof s == "number" ? `${s}px` : s;
  }).join(" ");
  return n.mui = !0, n;
}
function zY(e, t) {
  const n = this;
  if (n.vars) {
    if (!n.colorSchemes?.[e] || typeof n.getColorSchemeSelector != "function")
      return {};
    let r = n.getColorSchemeSelector(e);
    return r === "&" ? t : ((r.includes("data-") || r.includes(".")) && (r = `*:where(${r.replace(/\s*&$/, "")}) &`), {
      [r]: t
    });
  }
  return n.palette.mode === e ? t : {};
}
function r2(e = {}, ...t) {
  const {
    breakpoints: n = {},
    palette: r = {},
    spacing: a,
    shape: s = {},
    ...l
  } = e, c = LY(n), d = H1(a);
  let p = Go({
    breakpoints: c,
    direction: "ltr",
    components: {},
    // Inject component definitions.
    palette: {
      mode: "light",
      ...r
    },
    spacing: d,
    shape: {
      ...IY,
      ...s
    }
  }, l);
  return p = YK(p), p.applyStyles = zY, p = t.reduce((m, h) => Go(m, h), p), p.unstable_sxConfig = {
    ...Yx,
    ...l?.unstable_sxConfig
  }, p.unstable_sx = function(m) {
    return od({
      sx: m,
      theme: this
    });
  }, p;
}
function FY(e) {
  return Object.keys(e).length === 0;
}
function Y3(e = null) {
  const t = M.useContext(Zx);
  return !t || FY(t) ? e : t;
}
const BY = r2();
function tS(e = BY) {
  return Y3(e);
}
function nP(e) {
  const t = Jc(e);
  return e !== t && t.styles ? (t.styles.match(/^@layer\s+[^{]*$/) || (t.styles = `@layer global{${t.styles}}`), t) : e;
}
function q1({
  styles: e,
  themeId: t,
  defaultTheme: n = {}
}) {
  const r = tS(n), a = t && r[t] || r;
  let s = typeof e == "function" ? e(a) : e;
  return a.modularCssLayers && (Array.isArray(s) ? s = s.map((l) => nP(typeof l == "function" ? l(a) : l)) : s = nP(s)), /* @__PURE__ */ E.jsx(U1, {
    styles: s
  });
}
const rP = (e) => e, UY = () => {
  let e = rP;
  return {
    configure(t) {
      e = t;
    },
    generate(t) {
      return e(t);
    },
    reset() {
      e = rP;
    }
  };
}, W1 = UY();
function VY(e = {}) {
  const {
    themeId: t,
    defaultTheme: n,
    defaultClassName: r = "MuiBox-root",
    generateClassName: a
  } = e, s = V1("div", {
    shouldForwardProp: (l) => l !== "theme" && l !== "sx" && l !== "as"
  })(od);
  return /* @__PURE__ */ M.forwardRef(function(l, c) {
    const d = tS(n), {
      className: p,
      component: m = "div",
      ...h
    } = U3(l);
    return /* @__PURE__ */ E.jsx(s, {
      as: m,
      ref: c,
      className: Ke(p, a ? a(r) : r),
      theme: t && d[t] || d,
      ...h
    });
  });
}
const HY = {
  active: "active",
  checked: "checked",
  completed: "completed",
  disabled: "disabled",
  error: "error",
  expanded: "expanded",
  focused: "focused",
  focusVisible: "focusVisible",
  open: "open",
  readOnly: "readOnly",
  required: "required",
  selected: "selected"
};
function _t(e, t, n = "Mui") {
  const r = HY[t];
  return r ? `${n}-${r}` : `${W1.generate(e)}-${t}`;
}
function wt(e, t, n = "Mui") {
  const r = {};
  return t.forEach((a) => {
    r[a] = _t(e, a, n);
  }), r;
}
function G1(e) {
  const {
    variants: t,
    ...n
  } = e, r = {
    variants: t,
    style: Jc(n),
    isProcessed: !0
  };
  return r.style === n || t && t.forEach((a) => {
    typeof a.style != "function" && (a.style = Jc(a.style));
  }), r;
}
const qY = r2();
function QO(e) {
  return e !== "ownerState" && e !== "theme" && e !== "sx" && e !== "as";
}
function Jp(e, t) {
  return t && e && typeof e == "object" && e.styles && !e.styles.startsWith("@layer") && (e.styles = `@layer ${t}{${String(e.styles)}}`), e;
}
function WY(e) {
  return e ? (t, n) => n[e] : null;
}
function GY(e, t, n) {
  e.theme = XY(e.theme) ? n : e.theme[t] || e.theme;
}
function b0(e, t, n) {
  const r = typeof t == "function" ? t(e) : t;
  if (Array.isArray(r))
    return r.flatMap((a) => b0(e, a, n));
  if (Array.isArray(r?.variants)) {
    let a;
    if (r.isProcessed)
      a = n ? Jp(r.style, n) : r.style;
    else {
      const {
        variants: s,
        ...l
      } = r;
      a = n ? Jp(Jc(l), n) : l;
    }
    return K1(e, r.variants, [a], n);
  }
  return r?.isProcessed ? n ? Jp(Jc(r.style), n) : r.style : n ? Jp(Jc(r), n) : r;
}
function K1(e, t, n = [], r = void 0) {
  let a;
  e: for (let s = 0; s < t.length; s += 1) {
    const l = t[s];
    if (typeof l.props == "function") {
      if (a ?? (a = {
        ...e,
        ...e.ownerState,
        ownerState: e.ownerState
      }), !l.props(a))
        continue;
    } else
      for (const c in l.props)
        if (e[c] !== l.props[c] && e.ownerState?.[c] !== l.props[c])
          continue e;
    typeof l.style == "function" ? (a ?? (a = {
      ...e,
      ...e.ownerState,
      ownerState: e.ownerState
    }), n.push(r ? Jp(Jc(l.style(a)), r) : l.style(a))) : n.push(r ? Jp(Jc(l.style), r) : l.style);
  }
  return n;
}
function X1(e = {}) {
  const {
    themeId: t,
    defaultTheme: n = qY,
    rootShouldForwardProp: r = QO,
    slotShouldForwardProp: a = QO
  } = e;
  function s(l) {
    GY(l, t, n);
  }
  return (l, c = {}) => {
    $Y(l, (N) => N.filter((R) => R !== od));
    const {
      name: d,
      slot: p,
      skipVariantsResolver: m,
      skipSx: h,
      // TODO v6: remove `lowercaseFirstLetter()` in the next major release
      // For more details: https://github.com/mui/material-ui/pull/37908
      overridesResolver: v = WY(QY(p)),
      ...y
    } = c, w = d && d.startsWith("Mui") || p ? "components" : "custom", x = m !== void 0 ? m : (
      // TODO v6: remove `Root` in the next major release
      // For more details: https://github.com/mui/material-ui/pull/37908
      p && p !== "Root" && p !== "root" || !1
    ), b = h || !1;
    let k = QO;
    p === "Root" || p === "root" ? k = r : p ? k = a : YY(l) && (k = void 0);
    const C = V1(l, {
      shouldForwardProp: k,
      label: KY(),
      ...y
    }), _ = (N) => {
      if (N.__emotion_real === N)
        return N;
      if (typeof N == "function")
        return function(R) {
          return b0(R, N, R.theme.modularCssLayers ? w : void 0);
        };
      if (cl(N)) {
        const R = G1(N);
        return function(j) {
          return R.variants ? b0(j, R, j.theme.modularCssLayers ? w : void 0) : j.theme.modularCssLayers ? Jp(R.style, w) : R.style;
        };
      }
      return N;
    }, O = (...N) => {
      const R = [], j = N.map(_), D = [];
      if (R.push(s), d && v && D.push(function(B) {
        const P = B.theme.components?.[d]?.styleOverrides;
        if (!P)
          return null;
        const W = {};
        for (const I in P)
          W[I] = b0(B, P[I], B.theme.modularCssLayers ? "theme" : void 0);
        return v(B, W);
      }), d && !x && D.push(function(B) {
        const P = B.theme?.components?.[d]?.variants;
        return P ? K1(B, P, [], B.theme.modularCssLayers ? "theme" : void 0) : null;
      }), b || D.push(od), Array.isArray(j[0])) {
        const B = j.shift(), P = new Array(R.length).fill(""), W = new Array(D.length).fill("");
        let I;
        I = [...P, ...B, ...W], I.raw = [...P, ...B.raw, ...W], R.unshift(I);
      }
      const $ = [...R, ...j, ...D], z = C(...$);
      return l.muiName && (z.muiName = l.muiName), z;
    };
    return C.withConfig && (O.withConfig = C.withConfig), O;
  };
}
function KY(e, t) {
  return void 0;
}
function XY(e) {
  for (const t in e)
    return !1;
  return !0;
}
function YY(e) {
  return typeof e == "string" && // 96 is one less than the char code
  // for "a" so this is checking that
  // it's a lowercase character
  e.charCodeAt(0) > 96;
}
function QY(e) {
  return e && e.charAt(0).toLowerCase() + e.slice(1);
}
const JY = X1();
function fx(e, t, n = !1) {
  const r = {
    ...t
  };
  for (const a in e)
    if (Object.prototype.hasOwnProperty.call(e, a)) {
      const s = a;
      if (s === "components" || s === "slots")
        r[s] = {
          ...e[s],
          ...r[s]
        };
      else if (s === "componentsProps" || s === "slotProps") {
        const l = e[s], c = t[s];
        if (!c)
          r[s] = l || {};
        else if (!l)
          r[s] = c;
        else {
          r[s] = {
            ...c
          };
          for (const d in l)
            if (Object.prototype.hasOwnProperty.call(l, d)) {
              const p = d;
              r[s][p] = fx(l[p], c[p], n);
            }
        }
      } else s === "className" && n && t.className ? r.className = Ke(e?.className, t?.className) : s === "style" && n && t.style ? r.style = {
        ...e?.style,
        ...t?.style
      } : r[s] === void 0 && (r[s] = e[s]);
    }
  return r;
}
function ZY(e) {
  const {
    theme: t,
    name: n,
    props: r
  } = e;
  return !t || !t.components || !t.components[n] || !t.components[n].defaultProps ? r : fx(t.components[n].defaultProps, r);
}
function eQ({
  props: e,
  name: t,
  defaultTheme: n,
  themeId: r
}) {
  let a = tS(n);
  return r && (a = a[r] || a), ZY({
    theme: a,
    name: t,
    props: e
  });
}
const zs = typeof window < "u" ? M.useLayoutEffect : M.useEffect;
function oh(e, t = Number.MIN_SAFE_INTEGER, n = Number.MAX_SAFE_INTEGER) {
  return Math.max(t, Math.min(e, n));
}
function Q3(e, t = 0, n = 1) {
  return oh(e, t, n);
}
function tQ(e) {
  e = e.slice(1);
  const t = new RegExp(`.{1,${e.length >= 6 ? 2 : 1}}`, "g");
  let n = e.match(t);
  return n && n[0].length === 1 && (n = n.map((r) => r + r)), n ? `rgb${n.length === 4 ? "a" : ""}(${n.map((r, a) => a < 3 ? parseInt(r, 16) : Math.round(parseInt(r, 16) / 255 * 1e3) / 1e3).join(", ")})` : "";
}
function ad(e) {
  if (e.type)
    return e;
  if (e.charAt(0) === "#")
    return ad(tQ(e));
  const t = e.indexOf("("), n = e.substring(0, t);
  if (!["rgb", "rgba", "hsl", "hsla", "color"].includes(n))
    throw new Error(vc(9, e));
  let r = e.substring(t + 1, e.length - 1), a;
  if (n === "color") {
    if (r = r.split(" "), a = r.shift(), r.length === 4 && r[3].charAt(0) === "/" && (r[3] = r[3].slice(1)), !["srgb", "display-p3", "a98-rgb", "prophoto-rgb", "rec-2020"].includes(a))
      throw new Error(vc(10, a));
  } else
    r = r.split(",");
  return r = r.map((s) => parseFloat(s)), {
    type: n,
    values: r,
    colorSpace: a
  };
}
const nQ = (e) => {
  const t = ad(e);
  return t.values.slice(0, 3).map((n, r) => t.type.includes("hsl") && r !== 0 ? `${n}%` : n).join(" ");
}, Rw = (e, t) => {
  try {
    return nQ(e);
  } catch {
    return e;
  }
};
function o2(e) {
  const {
    type: t,
    colorSpace: n
  } = e;
  let {
    values: r
  } = e;
  return t.includes("rgb") ? r = r.map((a, s) => s < 3 ? parseInt(a, 10) : a) : t.includes("hsl") && (r[1] = `${r[1]}%`, r[2] = `${r[2]}%`), t.includes("color") ? r = `${n} ${r.join(" ")}` : r = `${r.join(", ")}`, `${t}(${r})`;
}
function Y1(e) {
  e = ad(e);
  const {
    values: t
  } = e, n = t[0], r = t[1] / 100, a = t[2] / 100, s = r * Math.min(a, 1 - a), l = (p, m = (p + n / 30) % 12) => a - s * Math.max(Math.min(m - 3, 9 - m, 1), -1);
  let c = "rgb";
  const d = [Math.round(l(0) * 255), Math.round(l(8) * 255), Math.round(l(4) * 255)];
  return e.type === "hsla" && (c += "a", d.push(t[3])), o2({
    type: c,
    values: d
  });
}
function KN(e) {
  e = ad(e);
  let t = e.type === "hsl" || e.type === "hsla" ? ad(Y1(e)).values : e.values;
  return t = t.map((n) => (e.type !== "color" && (n /= 255), n <= 0.03928 ? n / 12.92 : ((n + 0.055) / 1.055) ** 2.4)), Number((0.2126 * t[0] + 0.7152 * t[1] + 0.0722 * t[2]).toFixed(3));
}
function rQ(e, t) {
  const n = KN(e), r = KN(t);
  return (Math.max(n, r) + 0.05) / (Math.min(n, r) + 0.05);
}
function W0(e, t) {
  return e = ad(e), t = Q3(t), (e.type === "rgb" || e.type === "hsl") && (e.type += "a"), e.type === "color" ? e.values[3] = `/${t}` : e.values[3] = t, o2(e);
}
function zp(e, t, n) {
  try {
    return W0(e, t);
  } catch {
    return e;
  }
}
function a2(e, t) {
  if (e = ad(e), t = Q3(t), e.type.includes("hsl"))
    e.values[2] *= 1 - t;
  else if (e.type.includes("rgb") || e.type.includes("color"))
    for (let n = 0; n < 3; n += 1)
      e.values[n] *= 1 - t;
  return o2(e);
}
function Rn(e, t, n) {
  try {
    return a2(e, t);
  } catch {
    return e;
  }
}
function i2(e, t) {
  if (e = ad(e), t = Q3(t), e.type.includes("hsl"))
    e.values[2] += (100 - e.values[2]) * t;
  else if (e.type.includes("rgb"))
    for (let n = 0; n < 3; n += 1)
      e.values[n] += (255 - e.values[n]) * t;
  else if (e.type.includes("color"))
    for (let n = 0; n < 3; n += 1)
      e.values[n] += (1 - e.values[n]) * t;
  return o2(e);
}
function An(e, t, n) {
  try {
    return i2(e, t);
  } catch {
    return e;
  }
}
function oQ(e, t = 0.15) {
  return KN(e) > 0.5 ? a2(e, t) : i2(e, t);
}
function US(e, t, n) {
  try {
    return oQ(e, t);
  } catch {
    return e;
  }
}
const Q1 = /* @__PURE__ */ M.createContext(null);
function J3() {
  return M.useContext(Q1);
}
const aQ = typeof Symbol == "function" && Symbol.for, iQ = aQ ? /* @__PURE__ */ Symbol.for("mui.nested") : "__THEME_NESTED__";
function sQ(e, t) {
  return typeof t == "function" ? t(e) : {
    ...e,
    ...t
  };
}
function lQ(e) {
  const {
    children: t,
    theme: n
  } = e, r = J3(), a = M.useMemo(() => {
    const s = r === null ? {
      ...n
    } : sQ(r, n);
    return s != null && (s[iQ] = r !== null), s;
  }, [n, r]);
  return /* @__PURE__ */ E.jsx(Q1.Provider, {
    value: a,
    children: t
  });
}
const J1 = /* @__PURE__ */ M.createContext();
function uQ({
  value: e,
  ...t
}) {
  return /* @__PURE__ */ E.jsx(J1.Provider, {
    value: e ?? !0,
    ...t
  });
}
const Z1 = () => M.useContext(J1) ?? !1, e9 = /* @__PURE__ */ M.createContext(void 0);
function cQ({
  value: e,
  children: t
}) {
  return /* @__PURE__ */ E.jsx(e9.Provider, {
    value: e,
    children: t
  });
}
function dQ(e) {
  const {
    theme: t,
    name: n,
    props: r
  } = e;
  if (!t || !t.components || !t.components[n])
    return r;
  const a = t.components[n];
  return a.defaultProps ? fx(a.defaultProps, r, t.components.mergeClassNameAndStyle) : !a.styleOverrides && !a.variants ? fx(a, r, t.components.mergeClassNameAndStyle) : r;
}
function fQ({
  props: e,
  name: t
}) {
  const n = M.useContext(e9);
  return dQ({
    props: e,
    name: t,
    theme: {
      components: n
    }
  });
}
let oP = 0;
function pQ(e) {
  const [t, n] = M.useState(e), r = e || t;
  return M.useEffect(() => {
    t == null && (oP += 1, n(`mui-${oP}`));
  }, [t]), r;
}
const mQ = {
  ...Gx
}, aP = mQ.useId;
function eg(e) {
  if (aP !== void 0) {
    const t = aP();
    return e ?? t;
  }
  return pQ(e);
}
function hQ(e) {
  const t = Y3(), n = eg() || "", {
    modularCssLayers: r
  } = e;
  let a = "mui.global, mui.components, mui.theme, mui.custom, mui.sx";
  return !r || t !== null ? a = "" : typeof r == "string" ? a = r.replace(/mui(?!\.)/g, a) : a = `@layer ${a};`, zs(() => {
    const s = document.querySelector("head");
    if (!s)
      return;
    const l = s.firstChild;
    if (a) {
      if (l && l.hasAttribute?.("data-mui-layer-order") && l.getAttribute("data-mui-layer-order") === n)
        return;
      const c = document.createElement("style");
      c.setAttribute("data-mui-layer-order", n), c.textContent = a, s.prepend(c);
    } else
      s.querySelector(`style[data-mui-layer-order="${n}"]`)?.remove();
  }, [a, n]), a ? /* @__PURE__ */ E.jsx(q1, {
    styles: a
  }) : null;
}
const iP = {};
function sP(e, t, n, r = !1) {
  return M.useMemo(() => {
    const a = e && t[e] || t;
    if (typeof n == "function") {
      const s = n(a), l = e ? {
        ...t,
        [e]: s
      } : s;
      return r ? () => l : l;
    }
    return e ? {
      ...t,
      [e]: n
    } : {
      ...t,
      ...n
    };
  }, [e, t, n, r]);
}
function t9(e) {
  const {
    children: t,
    theme: n,
    themeId: r
  } = e, a = Y3(iP), s = J3() || iP, l = sP(r, a, n), c = sP(r, s, n, !0), d = (r ? l[r] : l).direction === "rtl", p = hQ(l);
  return /* @__PURE__ */ E.jsx(lQ, {
    theme: c,
    children: /* @__PURE__ */ E.jsx(Zx.Provider, {
      value: l,
      children: /* @__PURE__ */ E.jsx(uQ, {
        value: d,
        children: /* @__PURE__ */ E.jsxs(cQ, {
          value: r ? l[r].components : l.components,
          children: [p, t]
        })
      })
    })
  });
}
const lP = {
  theme: void 0
};
function gQ(e) {
  let t, n;
  return function(r) {
    let a = t;
    return (a === void 0 || r.theme !== n) && (lP.theme = r.theme, a = G1(e(lP)), t = a, n = r.theme), a;
  };
}
const Z3 = "mode", eR = "color-scheme", vQ = "data-color-scheme";
function yQ(e) {
  const {
    defaultMode: t = "system",
    defaultLightColorScheme: n = "light",
    defaultDarkColorScheme: r = "dark",
    modeStorageKey: a = Z3,
    colorSchemeStorageKey: s = eR,
    attribute: l = vQ,
    colorSchemeNode: c = "document.documentElement",
    nonce: d
  } = e || {};
  let p = "", m = l;
  if (l === "class" && (m = ".%s"), l === "data" && (m = "[data-%s]"), m.startsWith(".")) {
    const v = m.substring(1);
    p += `${c}.classList.remove('${v}'.replace('%s', light), '${v}'.replace('%s', dark));
      ${c}.classList.add('${v}'.replace('%s', colorScheme));`;
  }
  const h = m.match(/\[([^[\]]+)\]/);
  if (h) {
    const [v, y] = h[1].split("=");
    y || (p += `${c}.removeAttribute('${v}'.replace('%s', light));
      ${c}.removeAttribute('${v}'.replace('%s', dark));`), p += `
      ${c}.setAttribute('${v}'.replace('%s', colorScheme), ${y ? `${y}.replace('%s', colorScheme)` : '""'});`;
  } else m !== ".%s" && (p += `${c}.setAttribute('${m}', colorScheme);`);
  return /* @__PURE__ */ E.jsx("script", {
    suppressHydrationWarning: !0,
    nonce: typeof window > "u" ? d : "",
    dangerouslySetInnerHTML: {
      __html: `(function() {
try {
  let colorScheme = '';
  const mode = localStorage.getItem('${a}') || '${t}';
  const dark = localStorage.getItem('${s}-dark') || '${r}';
  const light = localStorage.getItem('${s}-light') || '${n}';
  if (mode === 'system') {
    // handle system mode
    const mql = window.matchMedia('(prefers-color-scheme: dark)');
    if (mql.matches) {
      colorScheme = dark
    } else {
      colorScheme = light
    }
  }
  if (mode === 'light') {
    colorScheme = light;
  }
  if (mode === 'dark') {
    colorScheme = dark;
  }
  if (colorScheme) {
    ${p}
  }
} catch(e){}})();`
    }
  }, "mui-color-scheme-init");
}
function bQ() {
}
const wQ = ({
  key: e,
  storageWindow: t
}) => (!t && typeof window < "u" && (t = window), {
  get(n) {
    if (typeof window > "u")
      return;
    if (!t)
      return n;
    let r;
    try {
      r = t.localStorage.getItem(e);
    } catch {
    }
    return r || n;
  },
  set: (n) => {
    if (t)
      try {
        t.localStorage.setItem(e, n);
      } catch {
      }
  },
  subscribe: (n) => {
    if (!t)
      return bQ;
    const r = (a) => {
      const s = a.newValue;
      a.key === e && n(s);
    };
    return t.addEventListener("storage", r), () => {
      t.removeEventListener("storage", r);
    };
  }
});
function JO() {
}
function uP(e) {
  if (typeof window < "u" && typeof window.matchMedia == "function" && e === "system")
    return window.matchMedia("(prefers-color-scheme: dark)").matches ? "dark" : "light";
}
function n9(e, t) {
  if (e.mode === "light" || e.mode === "system" && e.systemMode === "light")
    return t("light");
  if (e.mode === "dark" || e.mode === "system" && e.systemMode === "dark")
    return t("dark");
}
function xQ(e) {
  return n9(e, (t) => {
    if (t === "light")
      return e.lightColorScheme;
    if (t === "dark")
      return e.darkColorScheme;
  });
}
function SQ(e) {
  const {
    defaultMode: t = "light",
    defaultLightColorScheme: n,
    defaultDarkColorScheme: r,
    supportedColorSchemes: a = [],
    modeStorageKey: s = Z3,
    colorSchemeStorageKey: l = eR,
    storageWindow: c = typeof window > "u" ? void 0 : window,
    storageManager: d = wQ,
    noSsr: p = !1
  } = e, m = a.join(","), h = a.length > 1, v = M.useMemo(() => d?.({
    key: s,
    storageWindow: c
  }), [d, s, c]), y = M.useMemo(() => d?.({
    key: `${l}-light`,
    storageWindow: c
  }), [d, l, c]), w = M.useMemo(() => d?.({
    key: `${l}-dark`,
    storageWindow: c
  }), [d, l, c]), [x, b] = M.useState(() => {
    const D = v?.get(t) || t, $ = y?.get(n) || n, z = w?.get(r) || r;
    return {
      mode: D,
      systemMode: uP(D),
      lightColorScheme: $,
      darkColorScheme: z
    };
  }), [k, C] = M.useState(p || !h);
  M.useEffect(() => {
    C(!0);
  }, []);
  const _ = xQ(x), O = M.useCallback((D) => {
    b(($) => {
      if (D === $.mode)
        return $;
      const z = D ?? t;
      return v?.set(z), {
        ...$,
        mode: z,
        systemMode: uP(z)
      };
    });
  }, [v, t]), N = M.useCallback((D) => {
    D ? typeof D == "string" ? D && !m.includes(D) ? console.error(`\`${D}\` does not exist in \`theme.colorSchemes\`.`) : b(($) => {
      const z = {
        ...$
      };
      return n9($, (B) => {
        B === "light" && (y?.set(D), z.lightColorScheme = D), B === "dark" && (w?.set(D), z.darkColorScheme = D);
      }), z;
    }) : b(($) => {
      const z = {
        ...$
      }, B = D.light === null ? n : D.light, P = D.dark === null ? r : D.dark;
      return B && (m.includes(B) ? (z.lightColorScheme = B, y?.set(B)) : console.error(`\`${B}\` does not exist in \`theme.colorSchemes\`.`)), P && (m.includes(P) ? (z.darkColorScheme = P, w?.set(P)) : console.error(`\`${P}\` does not exist in \`theme.colorSchemes\`.`)), z;
    }) : b(($) => (y?.set(n), w?.set(r), {
      ...$,
      lightColorScheme: n,
      darkColorScheme: r
    }));
  }, [m, y, w, n, r]), R = M.useCallback((D) => {
    x.mode === "system" && b(($) => {
      const z = D?.matches ? "dark" : "light";
      return $.systemMode === z ? $ : {
        ...$,
        systemMode: z
      };
    });
  }, [x.mode]), j = M.useRef(R);
  return j.current = R, M.useEffect(() => {
    if (typeof window.matchMedia != "function" || !h)
      return;
    const D = (...z) => j.current(...z), $ = window.matchMedia("(prefers-color-scheme: dark)");
    return $.addListener(D), D($), () => {
      $.removeListener(D);
    };
  }, [h]), M.useEffect(() => {
    if (h) {
      const D = v?.subscribe((B) => {
        (!B || ["light", "dark", "system"].includes(B)) && O(B || t);
      }) || JO, $ = y?.subscribe((B) => {
        (!B || m.match(B)) && N({
          light: B
        });
      }) || JO, z = w?.subscribe((B) => {
        (!B || m.match(B)) && N({
          dark: B
        });
      }) || JO;
      return () => {
        D(), $(), z();
      };
    }
  }, [N, O, m, t, c, h, v, y, w]), {
    ...x,
    mode: k ? x.mode : void 0,
    systemMode: k ? x.systemMode : void 0,
    colorScheme: k ? _ : void 0,
    setMode: O,
    setColorScheme: N
  };
}
const kQ = "*{-webkit-transition:none!important;-moz-transition:none!important;-o-transition:none!important;-ms-transition:none!important;transition:none!important}";
function _Q(e) {
  const {
    themeId: t,
    /**
     * This `theme` object needs to follow a certain structure to
     * be used correctly by the finel `CssVarsProvider`. It should have a
     * `colorSchemes` key with the light and dark (and any other) palette.
     * It should also ideally have a vars object created using `prepareCssVars`.
     */
    theme: n = {},
    modeStorageKey: r = Z3,
    colorSchemeStorageKey: a = eR,
    disableTransitionOnChange: s = !1,
    defaultColorScheme: l,
    resolveTheme: c
  } = e, d = {
    allColorSchemes: [],
    colorScheme: void 0,
    darkColorScheme: void 0,
    lightColorScheme: void 0,
    mode: void 0,
    setColorScheme: () => {
    },
    setMode: () => {
    },
    systemMode: void 0
  }, p = /* @__PURE__ */ M.createContext(void 0), m = () => M.useContext(p) || d, h = {}, v = {};
  function y(b) {
    const {
      children: k,
      theme: C,
      modeStorageKey: _ = r,
      colorSchemeStorageKey: O = a,
      disableTransitionOnChange: N = s,
      storageManager: R,
      storageWindow: j = typeof window > "u" ? void 0 : window,
      documentNode: D = typeof document > "u" ? void 0 : document,
      colorSchemeNode: $ = typeof document > "u" ? void 0 : document.documentElement,
      disableNestedContext: z = !1,
      disableStyleSheetGeneration: B = !1,
      defaultMode: P = "system",
      forceThemeRerender: W = !1,
      noSsr: I
    } = b, G = M.useRef(!1), L = J3(), K = M.useContext(p), q = !!K && !z, Z = M.useMemo(() => C || (typeof n == "function" ? n() : n), [C]), V = Z[t], F = V || Z, {
      colorSchemes: X = h,
      components: U = v,
      cssVarPrefix: H
    } = F, Q = Object.keys(X).filter((Me) => !!X[Me]).join(","), re = M.useMemo(() => Q.split(","), [Q]), de = typeof l == "string" ? l : l.light, le = typeof l == "string" ? l : l.dark, me = X[de] && X[le] ? P : X[F.defaultColorScheme]?.palette?.mode || F.palette?.mode, {
      mode: ve,
      setMode: ae,
      systemMode: se,
      lightColorScheme: pe,
      darkColorScheme: ge,
      colorScheme: xe,
      setColorScheme: _e
    } = SQ({
      supportedColorSchemes: re,
      defaultLightColorScheme: de,
      defaultDarkColorScheme: le,
      modeStorageKey: _,
      colorSchemeStorageKey: O,
      defaultMode: me,
      storageManager: R,
      storageWindow: j,
      noSsr: I
    });
    let We = ve, Xe = xe;
    q && (We = K.mode, Xe = K.colorScheme);
    let et = Xe || F.defaultColorScheme;
    F.vars && !W && (et = F.defaultColorScheme);
    const tt = M.useMemo(() => {
      const Me = F.generateThemeVars?.() || F.vars, he = {
        ...F,
        components: U,
        colorSchemes: X,
        cssVarPrefix: H,
        vars: Me
      };
      if (typeof he.generateSpacing == "function" && (he.spacing = he.generateSpacing()), et) {
        const ye = X[et];
        ye && typeof ye == "object" && Object.keys(ye).forEach((Ee) => {
          ye[Ee] && typeof ye[Ee] == "object" ? he[Ee] = {
            ...he[Ee],
            ...ye[Ee]
          } : he[Ee] = ye[Ee];
        });
      }
      return c ? c(he) : he;
    }, [F, et, U, X, H]), je = F.colorSchemeSelector;
    zs(() => {
      if (Xe && $ && je && je !== "media") {
        const Me = je;
        let he = je;
        if (Me === "class" && (he = ".%s"), Me === "data" && (he = "[data-%s]"), Me?.startsWith("data-") && !Me.includes("%s") && (he = `[${Me}="%s"]`), he.startsWith("."))
          $.classList.remove(...re.map((ye) => he.substring(1).replace("%s", ye))), $.classList.add(he.substring(1).replace("%s", Xe));
        else {
          const ye = he.replace("%s", Xe).match(/\[([^\]]+)\]/);
          if (ye) {
            const [Ee, Le] = ye[1].split("=");
            Le || re.forEach((ze) => {
              $.removeAttribute(Ee.replace(Xe, ze));
            }), $.setAttribute(Ee, Le ? Le.replace(/"|'/g, "") : "");
          } else
            $.setAttribute(he, Xe);
        }
      }
    }, [Xe, je, $, re]), M.useEffect(() => {
      let Me;
      if (N && G.current && D) {
        const he = D.createElement("style");
        he.appendChild(D.createTextNode(kQ)), D.head.appendChild(he), window.getComputedStyle(D.body), Me = setTimeout(() => {
          D.head.removeChild(he);
        }, 1);
      }
      return () => {
        clearTimeout(Me);
      };
    }, [Xe, N, D]), M.useEffect(() => (G.current = !0, () => {
      G.current = !1;
    }), []);
    const an = M.useMemo(() => ({
      allColorSchemes: re,
      colorScheme: Xe,
      darkColorScheme: ge,
      lightColorScheme: pe,
      mode: We,
      setColorScheme: _e,
      setMode: ae,
      systemMode: se
    }), [re, Xe, ge, pe, We, _e, ae, se, tt.colorSchemeSelector]);
    let dt = !0;
    (B || F.cssVariables === !1 || q && L?.cssVarPrefix === H) && (dt = !1);
    const Ce = /* @__PURE__ */ E.jsxs(M.Fragment, {
      children: [/* @__PURE__ */ E.jsx(t9, {
        themeId: V ? t : void 0,
        theme: tt,
        children: k
      }), dt && /* @__PURE__ */ E.jsx(U1, {
        styles: tt.generateStyleSheets?.() || []
      })]
    });
    return q ? Ce : /* @__PURE__ */ E.jsx(p.Provider, {
      value: an,
      children: Ce
    });
  }
  const w = typeof l == "string" ? l : l.light, x = typeof l == "string" ? l : l.dark;
  return {
    CssVarsProvider: y,
    useColorScheme: m,
    getInitColorSchemeScript: (b) => yQ({
      colorSchemeStorageKey: a,
      defaultLightColorScheme: w,
      defaultDarkColorScheme: x,
      modeStorageKey: r,
      ...b
    })
  };
}
function EQ(e = "") {
  function t(...n) {
    if (!n.length)
      return "";
    const r = n[0];
    return typeof r == "string" && !r.match(/(#|\(|\)|(-?(\d*\.)?\d+)(px|em|%|ex|ch|rem|vw|vh|vmin|vmax|cm|mm|in|pt|pc))|^(-?(\d*\.)?\d+)$|(\d+ \d+ \d+)/) ? `, var(--${e ? `${e}-` : ""}${r}${t(...n.slice(1))})` : `, ${r}`;
  }
  return (n, ...r) => `var(--${e ? `${e}-` : ""}${n}${t(...r)})`;
}
const cP = (e, t, n, r = []) => {
  let a = e;
  t.forEach((s, l) => {
    l === t.length - 1 ? Array.isArray(a) ? a[Number(s)] = n : a && typeof a == "object" && (a[s] = n) : a && typeof a == "object" && (a[s] || (a[s] = r.includes(s) ? [] : {}), a = a[s]);
  });
}, CQ = (e, t, n) => {
  function r(a, s = [], l = []) {
    Object.entries(a).forEach(([c, d]) => {
      (!n || n && !n([...s, c])) && d != null && (typeof d == "object" && Object.keys(d).length > 0 ? r(d, [...s, c], Array.isArray(d) ? [...l, c] : l) : t([...s, c], d, l));
    });
  }
  r(e);
}, OQ = (e, t) => typeof t == "number" ? ["lineHeight", "fontWeight", "opacity", "zIndex"].some((n) => e.includes(n)) || e[e.length - 1].toLowerCase().includes("opacity") ? t : `${t}px` : t;
function ZO(e, t) {
  const {
    prefix: n,
    shouldSkipGeneratingVar: r
  } = t || {}, a = {}, s = {}, l = {};
  return CQ(
    e,
    (c, d, p) => {
      if ((typeof d == "string" || typeof d == "number") && (!r || !r(c, d))) {
        const m = `--${n ? `${n}-` : ""}${c.join("-")}`, h = OQ(c, d);
        Object.assign(a, {
          [m]: h
        }), cP(s, c, `var(${m})`, p), cP(l, c, `var(${m}, ${h})`, p);
      }
    },
    (c) => c[0] === "vars"
    // skip 'vars/*' paths
  ), {
    css: a,
    vars: s,
    varsWithDefaults: l
  };
}
function MQ(e, t = {}) {
  const {
    getSelector: n = k,
    disableCssColorScheme: r,
    colorSchemeSelector: a,
    enableContrastVars: s
  } = t, {
    colorSchemes: l = {},
    components: c,
    defaultColorScheme: d = "light",
    ...p
  } = e, {
    vars: m,
    css: h,
    varsWithDefaults: v
  } = ZO(p, t);
  let y = v;
  const w = {}, {
    [d]: x,
    ...b
  } = l;
  if (Object.entries(b || {}).forEach(([C, _]) => {
    const {
      vars: O,
      css: N,
      varsWithDefaults: R
    } = ZO(_, t);
    y = Go(y, R), w[C] = {
      css: N,
      vars: O
    };
  }), x) {
    const {
      css: C,
      vars: _,
      varsWithDefaults: O
    } = ZO(x, t);
    y = Go(y, O), w[d] = {
      css: C,
      vars: _
    };
  }
  function k(C, _) {
    let O = a;
    if (a === "class" && (O = ".%s"), a === "data" && (O = "[data-%s]"), a?.startsWith("data-") && !a.includes("%s") && (O = `[${a}="%s"]`), C) {
      if (O === "media")
        return e.defaultColorScheme === C ? ":root" : {
          [`@media (prefers-color-scheme: ${l[C]?.palette?.mode || C})`]: {
            ":root": _
          }
        };
      if (O)
        return e.defaultColorScheme === C ? `:root, ${O.replace("%s", String(C))}` : O.replace("%s", String(C));
    }
    return ":root";
  }
  return {
    vars: y,
    generateThemeVars: () => {
      let C = {
        ...m
      };
      return Object.entries(w).forEach(([, {
        vars: _
      }]) => {
        C = Go(C, _);
      }), C;
    },
    generateStyleSheets: () => {
      const C = [], _ = e.defaultColorScheme || "light";
      function O(j, D) {
        Object.keys(D).length && C.push(typeof j == "string" ? {
          [j]: {
            ...D
          }
        } : j);
      }
      O(n(void 0, {
        ...h
      }), h);
      const {
        [_]: N,
        ...R
      } = w;
      if (N) {
        const {
          css: j
        } = N, D = l[_]?.palette?.mode, $ = !r && D ? {
          colorScheme: D,
          ...j
        } : {
          ...j
        };
        O(n(_, {
          ...$
        }), $);
      }
      return Object.entries(R).forEach(([j, {
        css: D
      }]) => {
        const $ = l[j]?.palette?.mode, z = !r && $ ? {
          colorScheme: $,
          ...D
        } : {
          ...D
        };
        O(n(j, {
          ...z
        }), z);
      }), s && C.push({
        ":root": {
          // use double underscore to indicate that these are private variables
          "--__l-threshold": "0.7",
          "--__l": "clamp(0, (l / var(--__l-threshold) - 1) * -infinity, 1)",
          "--__a": "clamp(0.87, (l / var(--__l-threshold) - 1) * -infinity, 1)"
          // 0.87 is the default alpha value for black text.
        }
      }), C;
    }
  };
}
function NQ(e) {
  return function(t) {
    return e === "media" ? `@media (prefers-color-scheme: ${t})` : e ? e.startsWith("data-") && !e.includes("%s") ? `[${e}="${t}"] &` : e === "class" ? `.${t} &` : e === "data" ? `[data-${t}] &` : `${e.replace("%s", t)} &` : "&";
  };
}
function Hw(e, t) {
  return /* @__PURE__ */ M.isValidElement(e) && t.indexOf(
    // For server components `muiName` is available in element.type._payload.value.muiName
    // relevant info - https://github.com/facebook/react/blob/2807d781a08db8e9873687fccc25c0f12b4fb3d4/packages/react/src/ReactLazy.js#L45
    // eslint-disable-next-line no-underscore-dangle
    e.type.muiName ?? e.type?._payload?.value?.muiName
  ) !== -1;
}
const RQ = (e, t) => e.filter((n) => t.includes(n)), tg = (e, t, n) => {
  const r = e.keys[0];
  Array.isArray(t) ? t.forEach((a, s) => {
    n((l, c) => {
      s <= e.keys.length - 1 && (s === 0 ? Object.assign(l, c) : l[e.up(e.keys[s])] = c);
    }, a);
  }) : t && typeof t == "object" ? (Object.keys(t).length > e.keys.length ? e.keys : RQ(e.keys, Object.keys(t))).forEach((a) => {
    if (e.keys.includes(a)) {
      const s = t[a];
      s !== void 0 && n((l, c) => {
        r === a ? Object.assign(l, c) : l[e.up(a)] = c;
      }, s);
    }
  }) : (typeof t == "number" || typeof t == "string") && n((a, s) => {
    Object.assign(a, s);
  }, t);
};
function G0(e) {
  return `--Grid-${e}Spacing`;
}
function s2(e) {
  return `--Grid-parent-${e}Spacing`;
}
const dP = "--Grid-columns", bh = "--Grid-parent-columns", AQ = ({
  theme: e,
  ownerState: t
}) => {
  const n = {};
  return tg(e.breakpoints, t.size, (r, a) => {
    let s = {};
    a === "grow" && (s = {
      flexBasis: 0,
      flexGrow: 1,
      maxWidth: "100%"
    }), a === "auto" && (s = {
      flexBasis: "auto",
      flexGrow: 0,
      flexShrink: 0,
      maxWidth: "none",
      width: "auto"
    }), typeof a == "number" && (s = {
      flexGrow: 0,
      flexBasis: "auto",
      width: `calc(100% * ${a} / var(${bh}) - (var(${bh}) - ${a}) * (var(${s2("column")}) / var(${bh})))`
    }), r(n, s);
  }), n;
}, jQ = ({
  theme: e,
  ownerState: t
}) => {
  const n = {};
  return tg(e.breakpoints, t.offset, (r, a) => {
    let s = {};
    a === "auto" && (s = {
      marginLeft: "auto"
    }), typeof a == "number" && (s = {
      marginLeft: a === 0 ? "0px" : `calc(100% * ${a} / var(${bh}) + var(${s2("column")}) * ${a} / var(${bh}))`
    }), r(n, s);
  }), n;
}, PQ = ({
  theme: e,
  ownerState: t
}) => {
  if (!t.container)
    return {};
  const n = {
    [dP]: 12
  };
  return tg(e.breakpoints, t.columns, (r, a) => {
    const s = a ?? 12;
    r(n, {
      [dP]: s,
      "> *": {
        [bh]: s
      }
    });
  }), n;
}, DQ = ({
  theme: e,
  ownerState: t
}) => {
  if (!t.container)
    return {};
  const n = {};
  return tg(e.breakpoints, t.rowSpacing, (r, a) => {
    const s = typeof a == "string" ? a : e.spacing?.(a);
    r(n, {
      [G0("row")]: s,
      "> *": {
        [s2("row")]: s
      }
    });
  }), n;
}, $Q = ({
  theme: e,
  ownerState: t
}) => {
  if (!t.container)
    return {};
  const n = {};
  return tg(e.breakpoints, t.columnSpacing, (r, a) => {
    const s = typeof a == "string" ? a : e.spacing?.(a);
    r(n, {
      [G0("column")]: s,
      "> *": {
        [s2("column")]: s
      }
    });
  }), n;
}, TQ = ({
  theme: e,
  ownerState: t
}) => {
  if (!t.container)
    return {};
  const n = {};
  return tg(e.breakpoints, t.direction, (r, a) => {
    r(n, {
      flexDirection: a
    });
  }), n;
}, LQ = ({
  ownerState: e
}) => ({
  minWidth: 0,
  boxSizing: "border-box",
  ...e.container && {
    display: "flex",
    flexWrap: "wrap",
    ...e.wrap && e.wrap !== "wrap" && {
      flexWrap: e.wrap
    },
    gap: `var(${G0("row")}) var(${G0("column")})`
  }
}), IQ = (e) => {
  const t = [];
  return Object.entries(e).forEach(([n, r]) => {
    r !== !1 && r !== void 0 && t.push(`grid-${n}-${String(r)}`);
  }), t;
}, zQ = (e, t = "xs") => {
  function n(r) {
    return r === void 0 ? !1 : typeof r == "string" && !Number.isNaN(Number(r)) || typeof r == "number" && r > 0;
  }
  if (n(e))
    return [`spacing-${t}-${String(e)}`];
  if (typeof e == "object" && !Array.isArray(e)) {
    const r = [];
    return Object.entries(e).forEach(([a, s]) => {
      n(s) && r.push(`spacing-${a}-${String(s)}`);
    }), r;
  }
  return [];
}, FQ = (e) => e === void 0 ? [] : typeof e == "object" ? Object.entries(e).map(([t, n]) => `direction-${t}-${n}`) : [`direction-xs-${String(e)}`];
function BQ(e, t) {
  const n = [];
  e.item !== void 0 && (delete e.item, n.push("item")), e.zeroMinWidth !== void 0 && (delete e.zeroMinWidth, n.push("zeroMinWidth")), t.keys.forEach((r) => {
    e[r] !== void 0 && (n.push(r), delete e[r]);
  });
}
const UQ = r2(), VQ = JY("div", {
  name: "MuiGrid",
  slot: "Root"
});
function HQ(e) {
  return eQ({
    props: e,
    name: "MuiGrid",
    defaultTheme: UQ
  });
}
function qQ(e = {}) {
  const {
    // This will allow adding custom styled fn (for example for custom sx style function)
    createStyledComponent: t = VQ,
    useThemeProps: n = HQ,
    useTheme: r = tS,
    componentName: a = "MuiGrid"
  } = e, s = (p, m) => {
    const {
      container: h,
      direction: v,
      spacing: y,
      wrap: w,
      size: x
    } = p, b = {
      root: ["root", h && "container", w !== "wrap" && `wrap-xs-${String(w)}`, ...FQ(v), ...IQ(x), ...h ? zQ(y, m.breakpoints.keys[0]) : []]
    };
    return kt(b, (k) => _t(a, k), {});
  };
  function l(p, m, h = () => !0) {
    const v = {};
    return p === null || (Array.isArray(p) ? p.forEach((y, w) => {
      y !== null && h(y) && m.keys[w] && (v[m.keys[w]] = y);
    }) : typeof p == "object" ? Object.keys(p).forEach((y) => {
      const w = p[y];
      w != null && h(w) && (v[y] = w);
    }) : v[m.keys[0]] = p), v;
  }
  const c = t(PQ, $Q, DQ, AQ, TQ, LQ, jQ), d = /* @__PURE__ */ M.forwardRef(function(p, m) {
    const h = r(), v = n(p), y = U3(v);
    BQ(y, h.breakpoints);
    const {
      className: w,
      children: x,
      columns: b = 12,
      container: k = !1,
      component: C = "div",
      direction: _ = "row",
      wrap: O = "wrap",
      size: N = {},
      offset: R = {},
      spacing: j = 0,
      rowSpacing: D = j,
      columnSpacing: $ = j,
      unstable_level: z = 0,
      ...B
    } = y, P = l(N, h.breakpoints, (V) => V !== !1), W = l(R, h.breakpoints), I = p.columns ?? (z ? void 0 : b), G = p.spacing ?? (z ? void 0 : j), L = p.rowSpacing ?? p.spacing ?? (z ? void 0 : D), K = p.columnSpacing ?? p.spacing ?? (z ? void 0 : $), q = {
      ...y,
      level: z,
      columns: I,
      container: k,
      direction: _,
      wrap: O,
      spacing: G,
      rowSpacing: L,
      columnSpacing: K,
      size: P,
      offset: W
    }, Z = s(q, h);
    return /* @__PURE__ */ E.jsx(c, {
      ref: m,
      as: C,
      ownerState: q,
      className: Ke(Z.root, w),
      ...B,
      children: M.Children.map(x, (V) => /* @__PURE__ */ M.isValidElement(V) && Hw(V, ["Grid"]) && k && V.props.container ? /* @__PURE__ */ M.cloneElement(V, {
        unstable_level: V.props?.unstable_level ?? z + 1
      }) : V)
    });
  });
  return d.muiName = "Grid", d;
}
const px = {
  black: "#000",
  white: "#fff"
}, WQ = {
  50: "#fafafa",
  100: "#f5f5f5",
  200: "#eeeeee",
  300: "#e0e0e0",
  400: "#bdbdbd",
  500: "#9e9e9e",
  600: "#757575",
  700: "#616161",
  800: "#424242",
  900: "#212121",
  A100: "#f5f5f5",
  A200: "#eeeeee",
  A400: "#bdbdbd",
  A700: "#616161"
}, Lm = {
  50: "#f3e5f5",
  200: "#ce93d8",
  300: "#ba68c8",
  400: "#ab47bc",
  500: "#9c27b0",
  700: "#7b1fa2"
}, Im = {
  300: "#e57373",
  400: "#ef5350",
  500: "#f44336",
  700: "#d32f2f",
  800: "#c62828"
}, lw = {
  300: "#ffb74d",
  400: "#ffa726",
  500: "#ff9800",
  700: "#f57c00",
  900: "#e65100"
}, zm = {
  50: "#e3f2fd",
  200: "#90caf9",
  400: "#42a5f5",
  700: "#1976d2",
  800: "#1565c0"
}, Fm = {
  300: "#4fc3f7",
  400: "#29b6f6",
  500: "#03a9f4",
  700: "#0288d1",
  900: "#01579b"
}, Bm = {
  300: "#81c784",
  400: "#66bb6a",
  500: "#4caf50",
  700: "#388e3c",
  800: "#2e7d32",
  900: "#1b5e20"
};
function r9() {
  return {
    // The colors used to style the text.
    text: {
      // The most important text.
      primary: "rgba(0, 0, 0, 0.87)",
      // Secondary text.
      secondary: "rgba(0, 0, 0, 0.6)",
      // Disabled text have even lower visual prominence.
      disabled: "rgba(0, 0, 0, 0.38)"
    },
    // The color used to divide different elements.
    divider: "rgba(0, 0, 0, 0.12)",
    // The background colors used to style the surfaces.
    // Consistency between these values is important.
    background: {
      paper: px.white,
      default: px.white
    },
    // The colors used to style the action elements.
    action: {
      // The color of an active action like an icon button.
      active: "rgba(0, 0, 0, 0.54)",
      // The color of an hovered action.
      hover: "rgba(0, 0, 0, 0.04)",
      hoverOpacity: 0.04,
      // The color of a selected action.
      selected: "rgba(0, 0, 0, 0.08)",
      selectedOpacity: 0.08,
      // The color of a disabled action.
      disabled: "rgba(0, 0, 0, 0.26)",
      // The background color of a disabled action.
      disabledBackground: "rgba(0, 0, 0, 0.12)",
      disabledOpacity: 0.38,
      focus: "rgba(0, 0, 0, 0.12)",
      focusOpacity: 0.12,
      activatedOpacity: 0.12
    }
  };
}
const o9 = r9();
function a9() {
  return {
    text: {
      primary: px.white,
      secondary: "rgba(255, 255, 255, 0.7)",
      disabled: "rgba(255, 255, 255, 0.5)",
      icon: "rgba(255, 255, 255, 0.5)"
    },
    divider: "rgba(255, 255, 255, 0.12)",
    background: {
      paper: "#121212",
      default: "#121212"
    },
    action: {
      active: px.white,
      hover: "rgba(255, 255, 255, 0.08)",
      hoverOpacity: 0.08,
      selected: "rgba(255, 255, 255, 0.16)",
      selectedOpacity: 0.16,
      disabled: "rgba(255, 255, 255, 0.3)",
      disabledBackground: "rgba(255, 255, 255, 0.12)",
      disabledOpacity: 0.38,
      focus: "rgba(255, 255, 255, 0.12)",
      focusOpacity: 0.12,
      activatedOpacity: 0.24
    }
  };
}
const XN = a9();
function fP(e, t, n, r) {
  const a = r.light || r, s = r.dark || r * 1.5;
  e[t] || (e.hasOwnProperty(n) ? e[t] = e[n] : t === "light" ? e.light = i2(e.main, a) : t === "dark" && (e.dark = a2(e.main, s)));
}
function pP(e, t, n, r, a) {
  const s = a.light || a, l = a.dark || a * 1.5;
  t[n] || (t.hasOwnProperty(r) ? t[n] = t[r] : n === "light" ? t.light = `color-mix(in ${e}, ${t.main}, #fff ${(s * 100).toFixed(0)}%)` : n === "dark" && (t.dark = `color-mix(in ${e}, ${t.main}, #000 ${(l * 100).toFixed(0)}%)`));
}
function GQ(e = "light") {
  return e === "dark" ? {
    main: zm[200],
    light: zm[50],
    dark: zm[400]
  } : {
    main: zm[700],
    light: zm[400],
    dark: zm[800]
  };
}
function KQ(e = "light") {
  return e === "dark" ? {
    main: Lm[200],
    light: Lm[50],
    dark: Lm[400]
  } : {
    main: Lm[500],
    light: Lm[300],
    dark: Lm[700]
  };
}
function XQ(e = "light") {
  return e === "dark" ? {
    main: Im[500],
    light: Im[300],
    dark: Im[700]
  } : {
    main: Im[700],
    light: Im[400],
    dark: Im[800]
  };
}
function YQ(e = "light") {
  return e === "dark" ? {
    main: Fm[400],
    light: Fm[300],
    dark: Fm[700]
  } : {
    main: Fm[700],
    light: Fm[500],
    dark: Fm[900]
  };
}
function QQ(e = "light") {
  return e === "dark" ? {
    main: Bm[400],
    light: Bm[300],
    dark: Bm[700]
  } : {
    main: Bm[800],
    light: Bm[500],
    dark: Bm[900]
  };
}
function JQ(e = "light") {
  return e === "dark" ? {
    main: lw[400],
    light: lw[300],
    dark: lw[700]
  } : {
    main: "#ed6c02",
    // closest to orange[800] that pass 3:1.
    light: lw[500],
    dark: lw[900]
  };
}
function ZQ(e) {
  return `oklch(from ${e} var(--__l) 0 h / var(--__a))`;
}
function tR(e) {
  const {
    mode: t = "light",
    contrastThreshold: n = 3,
    tonalOffset: r = 0.2,
    colorSpace: a,
    ...s
  } = e, l = e.primary || GQ(t), c = e.secondary || KQ(t), d = e.error || XQ(t), p = e.info || YQ(t), m = e.success || QQ(t), h = e.warning || JQ(t);
  function v(x) {
    return a ? ZQ(x) : rQ(x, XN.text.primary) >= n ? XN.text.primary : o9.text.primary;
  }
  const y = ({
    color: x,
    name: b,
    mainShade: k = 500,
    lightShade: C = 300,
    darkShade: _ = 700
  }) => {
    if (x = {
      ...x
    }, !x.main && x[k] && (x.main = x[k]), !x.hasOwnProperty("main"))
      throw new Error(vc(11, b ? ` (${b})` : "", k));
    if (typeof x.main != "string")
      throw new Error(vc(12, b ? ` (${b})` : "", JSON.stringify(x.main)));
    return a ? (pP(a, x, "light", C, r), pP(a, x, "dark", _, r)) : (fP(x, "light", C, r), fP(x, "dark", _, r)), x.contrastText || (x.contrastText = v(x.main)), x;
  };
  let w;
  return t === "light" ? w = r9() : t === "dark" && (w = a9()), Go({
    // A collection of common colors.
    common: {
      ...px
    },
    // prevent mutable object.
    // The palette mode, can be light or dark.
    mode: t,
    // The colors used to represent primary interface elements for a user.
    primary: y({
      color: l,
      name: "primary"
    }),
    // The colors used to represent secondary interface elements for a user.
    secondary: y({
      color: c,
      name: "secondary",
      mainShade: "A400",
      lightShade: "A200",
      darkShade: "A700"
    }),
    // The colors used to represent interface elements that the user should be made aware of.
    error: y({
      color: d,
      name: "error"
    }),
    // The colors used to represent potentially dangerous actions or important messages.
    warning: y({
      color: h,
      name: "warning"
    }),
    // The colors used to present information to the user that is neutral and not necessarily important.
    info: y({
      color: p,
      name: "info"
    }),
    // The colors used to indicate the successful completion of an action that user triggered.
    success: y({
      color: m,
      name: "success"
    }),
    // The grey colors.
    grey: WQ,
    // Used by `getContrastText()` to maximize the contrast between
    // the background and the text.
    contrastThreshold: n,
    // Takes a background color and returns the text color that maximizes the contrast.
    getContrastText: v,
    // Generate a rich color object.
    augmentColor: y,
    // Used by the functions below to shift a color's luminance by approximately
    // two indexes within its tonal palette.
    // E.g., shift from Red 500 to Red 300 or Red 700.
    tonalOffset: r,
    // The light and dark mode object.
    ...w
  }, s);
}
function eJ(e) {
  const t = {};
  return Object.entries(e).forEach((n) => {
    const [r, a] = n;
    typeof a == "object" && (t[r] = `${a.fontStyle ? `${a.fontStyle} ` : ""}${a.fontVariant ? `${a.fontVariant} ` : ""}${a.fontWeight ? `${a.fontWeight} ` : ""}${a.fontStretch ? `${a.fontStretch} ` : ""}${a.fontSize || ""}${a.lineHeight ? `/${a.lineHeight} ` : ""}${a.fontFamily || ""}`);
  }), t;
}
function tJ(e, t) {
  return {
    toolbar: {
      minHeight: 56,
      [e.up("xs")]: {
        "@media (orientation: landscape)": {
          minHeight: 48
        }
      },
      [e.up("sm")]: {
        minHeight: 64
      }
    },
    ...t
  };
}
function nJ(e) {
  return Math.round(e * 1e5) / 1e5;
}
const mP = {
  textTransform: "uppercase"
}, hP = '"Roboto", "Helvetica", "Arial", sans-serif';
function i9(e, t) {
  const {
    fontFamily: n = hP,
    // The default font size of the Material Specification.
    fontSize: r = 14,
    // px
    fontWeightLight: a = 300,
    fontWeightRegular: s = 400,
    fontWeightMedium: l = 500,
    fontWeightBold: c = 700,
    // Tell MUI what's the font-size on the html element.
    // 16px is the default font-size used by browsers.
    htmlFontSize: d = 16,
    // Apply the CSS properties to all the variants.
    allVariants: p,
    pxToRem: m,
    ...h
  } = typeof t == "function" ? t(e) : t, v = r / 14, y = m || ((b) => `${b / d * v}rem`), w = (b, k, C, _, O) => ({
    fontFamily: n,
    fontWeight: b,
    fontSize: y(k),
    // Unitless following https://meyerweb.com/eric/thoughts/2006/02/08/unitless-line-heights/
    lineHeight: C,
    // The letter spacing was designed for the Roboto font-family. Using the same letter-spacing
    // across font-families can cause issues with the kerning.
    ...n === hP ? {
      letterSpacing: `${nJ(_ / k)}em`
    } : {},
    ...O,
    ...p
  }), x = {
    h1: w(a, 96, 1.167, -1.5),
    h2: w(a, 60, 1.2, -0.5),
    h3: w(s, 48, 1.167, 0),
    h4: w(s, 34, 1.235, 0.25),
    h5: w(s, 24, 1.334, 0),
    h6: w(l, 20, 1.6, 0.15),
    subtitle1: w(s, 16, 1.75, 0.15),
    subtitle2: w(l, 14, 1.57, 0.1),
    body1: w(s, 16, 1.5, 0.15),
    body2: w(s, 14, 1.43, 0.15),
    button: w(l, 14, 1.75, 0.4, mP),
    caption: w(s, 12, 1.66, 0.4),
    overline: w(s, 12, 2.66, 1, mP),
    // TODO v6: Remove handling of 'inherit' variant from the theme as it is already handled in Material UI's Typography component. Also, remember to remove the associated types.
    inherit: {
      fontFamily: "inherit",
      fontWeight: "inherit",
      fontSize: "inherit",
      lineHeight: "inherit",
      letterSpacing: "inherit"
    }
  };
  return Go({
    htmlFontSize: d,
    pxToRem: y,
    fontFamily: n,
    fontSize: r,
    fontWeightLight: a,
    fontWeightRegular: s,
    fontWeightMedium: l,
    fontWeightBold: c,
    ...x
  }, h, {
    clone: !1
    // No need to clone deep
  });
}
const rJ = 0.2, oJ = 0.14, aJ = 0.12;
function ur(...e) {
  return [`${e[0]}px ${e[1]}px ${e[2]}px ${e[3]}px rgba(0,0,0,${rJ})`, `${e[4]}px ${e[5]}px ${e[6]}px ${e[7]}px rgba(0,0,0,${oJ})`, `${e[8]}px ${e[9]}px ${e[10]}px ${e[11]}px rgba(0,0,0,${aJ})`].join(",");
}
const iJ = ["none", ur(0, 2, 1, -1, 0, 1, 1, 0, 0, 1, 3, 0), ur(0, 3, 1, -2, 0, 2, 2, 0, 0, 1, 5, 0), ur(0, 3, 3, -2, 0, 3, 4, 0, 0, 1, 8, 0), ur(0, 2, 4, -1, 0, 4, 5, 0, 0, 1, 10, 0), ur(0, 3, 5, -1, 0, 5, 8, 0, 0, 1, 14, 0), ur(0, 3, 5, -1, 0, 6, 10, 0, 0, 1, 18, 0), ur(0, 4, 5, -2, 0, 7, 10, 1, 0, 2, 16, 1), ur(0, 5, 5, -3, 0, 8, 10, 1, 0, 3, 14, 2), ur(0, 5, 6, -3, 0, 9, 12, 1, 0, 3, 16, 2), ur(0, 6, 6, -3, 0, 10, 14, 1, 0, 4, 18, 3), ur(0, 6, 7, -4, 0, 11, 15, 1, 0, 4, 20, 3), ur(0, 7, 8, -4, 0, 12, 17, 2, 0, 5, 22, 4), ur(0, 7, 8, -4, 0, 13, 19, 2, 0, 5, 24, 4), ur(0, 7, 9, -4, 0, 14, 21, 2, 0, 5, 26, 4), ur(0, 8, 9, -5, 0, 15, 22, 2, 0, 6, 28, 5), ur(0, 8, 10, -5, 0, 16, 24, 2, 0, 6, 30, 5), ur(0, 8, 11, -5, 0, 17, 26, 2, 0, 6, 32, 5), ur(0, 9, 11, -5, 0, 18, 28, 2, 0, 7, 34, 6), ur(0, 9, 12, -6, 0, 19, 29, 2, 0, 7, 36, 6), ur(0, 10, 13, -6, 0, 20, 31, 3, 0, 8, 38, 7), ur(0, 10, 13, -6, 0, 21, 33, 3, 0, 8, 40, 7), ur(0, 10, 14, -6, 0, 22, 35, 3, 0, 8, 42, 7), ur(0, 11, 14, -7, 0, 23, 36, 3, 0, 9, 44, 8), ur(0, 11, 15, -7, 0, 24, 38, 3, 0, 9, 46, 8)], sJ = {
  // This is the most common easing curve.
  easeInOut: "cubic-bezier(0.4, 0, 0.2, 1)",
  // Objects enter the screen at full velocity from off-screen and
  // slowly decelerate to a resting point.
  easeOut: "cubic-bezier(0.0, 0, 0.2, 1)",
  // Objects leave the screen at full velocity. They do not decelerate when off-screen.
  easeIn: "cubic-bezier(0.4, 0, 1, 1)",
  // The sharp curve is used by objects that may return to the screen at any time.
  sharp: "cubic-bezier(0.4, 0, 0.6, 1)"
}, lJ = {
  shortest: 150,
  shorter: 200,
  short: 250,
  // most basic recommended timing
  standard: 300,
  // this is to be used in complex animations
  complex: 375,
  // recommended when something is entering screen
  enteringScreen: 225,
  // recommended when something is leaving screen
  leavingScreen: 195
};
function gP(e) {
  return `${Math.round(e)}ms`;
}
function uJ(e) {
  if (!e)
    return 0;
  const t = e / 36;
  return Math.min(Math.round((4 + 15 * t ** 0.25 + t / 5) * 10), 3e3);
}
function cJ(e) {
  const t = {
    ...sJ,
    ...e.easing
  }, n = {
    ...lJ,
    ...e.duration
  };
  return {
    getAutoHeightDuration: uJ,
    create: (r = ["all"], a = {}) => {
      const {
        duration: s = n.standard,
        easing: l = t.easeInOut,
        delay: c = 0,
        ...d
      } = a;
      return (Array.isArray(r) ? r : [r]).map((p) => `${p} ${typeof s == "string" ? s : gP(s)} ${l} ${typeof c == "string" ? c : gP(c)}`).join(",");
    },
    ...e,
    easing: t,
    duration: n
  };
}
const dJ = {
  mobileStepper: 1e3,
  fab: 1050,
  speedDial: 1050,
  appBar: 1100,
  drawer: 1200,
  modal: 1300,
  snackbar: 1400,
  tooltip: 1500
};
function fJ(e) {
  return cl(e) || typeof e > "u" || typeof e == "string" || typeof e == "boolean" || typeof e == "number" || Array.isArray(e);
}
function s9(e = {}) {
  const t = {
    ...e
  };
  function n(r) {
    const a = Object.entries(r);
    for (let s = 0; s < a.length; s++) {
      const [l, c] = a[s];
      !fJ(c) || l.startsWith("unstable_") ? delete r[l] : cl(c) && (r[l] = {
        ...c
      }, n(r[l]));
    }
  }
  return n(t), `import { unstable_createBreakpoints as createBreakpoints, createTransitions } from '@mui/material/styles';

const theme = ${JSON.stringify(t, null, 2)};

theme.breakpoints = createBreakpoints(theme.breakpoints || {});
theme.transitions = createTransitions(theme.transitions || {});

export default theme;`;
}
function vP(e) {
  return typeof e == "number" ? `${(e * 100).toFixed(0)}%` : `calc((${e}) * 100%)`;
}
const pJ = (e) => {
  if (!Number.isNaN(+e))
    return +e;
  const t = e.match(/\d*\.?\d+/g);
  if (!t)
    return 0;
  let n = 0;
  for (let r = 0; r < t.length; r += 1)
    n += +t[r];
  return n;
};
function mJ(e) {
  Object.assign(e, {
    alpha(t, n) {
      const r = this || e;
      return r.colorSpace ? `oklch(from ${t} l c h / ${typeof n == "string" ? `calc(${n})` : n})` : r.vars ? `rgba(${t.replace(/var\(--([^,\s)]+)(?:,[^)]+)?\)+/g, "var(--$1Channel)")} / ${typeof n == "string" ? `calc(${n})` : n})` : W0(t, pJ(n));
    },
    lighten(t, n) {
      const r = this || e;
      return r.colorSpace ? `color-mix(in ${r.colorSpace}, ${t}, #fff ${vP(n)})` : i2(t, n);
    },
    darken(t, n) {
      const r = this || e;
      return r.colorSpace ? `color-mix(in ${r.colorSpace}, ${t}, #000 ${vP(n)})` : a2(t, n);
    }
  });
}
function YN(e = {}, ...t) {
  const {
    breakpoints: n,
    mixins: r = {},
    spacing: a,
    palette: s = {},
    transitions: l = {},
    typography: c = {},
    shape: d,
    colorSpace: p,
    ...m
  } = e;
  if (e.vars && // The error should throw only for the root theme creation because user is not allowed to use a custom node `vars`.
  // `generateThemeVars` is the closest identifier for checking that the `options` is a result of `createTheme` with CSS variables so that user can create new theme for nested ThemeProvider.
  e.generateThemeVars === void 0)
    throw new Error(vc(20));
  const h = tR({
    ...s,
    colorSpace: p
  }), v = r2(e);
  let y = Go(v, {
    mixins: tJ(v.breakpoints, r),
    palette: h,
    // Don't use [...shadows] until you've verified its transpiled code is not invoking the iterator protocol.
    shadows: iJ.slice(),
    typography: i9(h, c),
    transitions: cJ(l),
    zIndex: {
      ...dJ
    }
  });
  return y = Go(y, m), y = t.reduce((w, x) => Go(w, x), y), y.unstable_sxConfig = {
    ...Yx,
    ...m?.unstable_sxConfig
  }, y.unstable_sx = function(w) {
    return od({
      sx: w,
      theme: this
    });
  }, y.toRuntimeSource = s9, mJ(y), y;
}
function QN(e) {
  let t;
  return e < 1 ? t = 5.11916 * e ** 2 : t = 4.5 * Math.log(e + 1) + 2, Math.round(t * 10) / 1e3;
}
const hJ = [...Array(25)].map((e, t) => {
  if (t === 0)
    return "none";
  const n = QN(t);
  return `linear-gradient(rgba(255 255 255 / ${n}), rgba(255 255 255 / ${n}))`;
});
function l9(e) {
  return {
    inputPlaceholder: e === "dark" ? 0.5 : 0.42,
    inputUnderline: e === "dark" ? 0.7 : 0.42,
    switchTrackDisabled: e === "dark" ? 0.2 : 0.12,
    switchTrack: e === "dark" ? 0.3 : 0.38
  };
}
function u9(e) {
  return e === "dark" ? hJ : [];
}
function gJ(e) {
  const {
    palette: t = {
      mode: "light"
    },
    // need to cast to avoid module augmentation test
    opacity: n,
    overlays: r,
    colorSpace: a,
    ...s
  } = e, l = tR({
    ...t,
    colorSpace: a
  });
  return {
    palette: l,
    opacity: {
      ...l9(l.mode),
      ...n
    },
    overlays: r || u9(l.mode),
    ...s
  };
}
function vJ(e) {
  return !!e[0].match(/(cssVarPrefix|colorSchemeSelector|modularCssLayers|rootSelector|typography|mixins|breakpoints|direction|transitions)/) || !!e[0].match(/sxConfig$/) || // ends with sxConfig
  e[0] === "palette" && !!e[1]?.match(/(mode|contrastThreshold|tonalOffset)/);
}
const yJ = (e) => [...[...Array(25)].map((t, n) => `--${e ? `${e}-` : ""}overlays-${n}`), `--${e ? `${e}-` : ""}palette-AppBar-darkBg`, `--${e ? `${e}-` : ""}palette-AppBar-darkColor`], bJ = (e) => (t, n) => {
  const r = e.rootSelector || ":root", a = e.colorSchemeSelector;
  let s = a;
  if (a === "class" && (s = ".%s"), a === "data" && (s = "[data-%s]"), a?.startsWith("data-") && !a.includes("%s") && (s = `[${a}="%s"]`), e.defaultColorScheme === t) {
    if (t === "dark") {
      const l = {};
      return yJ(e.cssVarPrefix).forEach((c) => {
        l[c] = n[c], delete n[c];
      }), s === "media" ? {
        [r]: n,
        "@media (prefers-color-scheme: dark)": {
          [r]: l
        }
      } : s ? {
        [s.replace("%s", t)]: l,
        [`${r}, ${s.replace("%s", t)}`]: n
      } : {
        [r]: {
          ...n,
          ...l
        }
      };
    }
    if (s && s !== "media")
      return `${r}, ${s.replace("%s", String(t))}`;
  } else if (t) {
    if (s === "media")
      return {
        [`@media (prefers-color-scheme: ${String(t)})`]: {
          [r]: n
        }
      };
    if (s)
      return s.replace("%s", String(t));
  }
  return r;
};
function wJ(e, t) {
  t.forEach((n) => {
    e[n] || (e[n] = {});
  });
}
function Se(e, t, n) {
  !e[t] && n && (e[t] = n);
}
function Aw(e) {
  return typeof e != "string" || !e.startsWith("hsl") ? e : Y1(e);
}
function Zu(e, t) {
  `${t}Channel` in e || (e[`${t}Channel`] = Rw(Aw(e[t])));
}
function xJ(e) {
  return typeof e == "number" ? `${e}px` : typeof e == "string" || typeof e == "function" || Array.isArray(e) ? e : "8px";
}
const Qs = (e) => {
  try {
    return e();
  } catch {
  }
}, SJ = (e = "mui") => EQ(e);
function eM(e, t, n, r, a) {
  if (!n)
    return;
  n = n === !0 ? {} : n;
  const s = a === "dark" ? "dark" : "light";
  if (!r) {
    t[a] = gJ({
      ...n,
      palette: {
        mode: s,
        ...n?.palette
      },
      colorSpace: e
    });
    return;
  }
  const {
    palette: l,
    ...c
  } = YN({
    ...r,
    palette: {
      mode: s,
      ...n?.palette
    },
    colorSpace: e
  });
  return t[a] = {
    ...n,
    palette: l,
    opacity: {
      ...l9(s),
      ...n?.opacity
    },
    overlays: n?.overlays || u9(s)
  }, c;
}
function kJ(e = {}, ...t) {
  const {
    colorSchemes: n = {
      light: !0
    },
    defaultColorScheme: r,
    disableCssColorScheme: a = !1,
    cssVarPrefix: s = "mui",
    nativeColor: l = !1,
    shouldSkipGeneratingVar: c = vJ,
    colorSchemeSelector: d = n.light && n.dark ? "media" : void 0,
    rootSelector: p = ":root",
    ...m
  } = e, h = Object.keys(n)[0], v = r || (n.light && h !== "light" ? "light" : h), y = SJ(s), {
    [v]: w,
    light: x,
    dark: b,
    ...k
  } = n, C = {
    ...k
  };
  let _ = w;
  if ((v === "dark" && !("dark" in n) || v === "light" && !("light" in n)) && (_ = !0), !_)
    throw new Error(vc(21, v));
  let O;
  l && (O = "oklch");
  const N = eM(O, C, _, m, v);
  x && !C.light && eM(O, C, x, void 0, "light"), b && !C.dark && eM(O, C, b, void 0, "dark");
  let R = {
    defaultColorScheme: v,
    ...N,
    cssVarPrefix: s,
    colorSchemeSelector: d,
    rootSelector: p,
    getCssVar: y,
    colorSchemes: C,
    font: {
      ...eJ(N.typography),
      ...N.font
    },
    spacing: xJ(m.spacing)
  };
  Object.keys(R.colorSchemes).forEach((B) => {
    const P = R.colorSchemes[B].palette, W = (G) => {
      const L = G.split("-"), K = L[1], q = L[2];
      return y(G, P[K][q]);
    };
    P.mode === "light" && (Se(P.common, "background", "#fff"), Se(P.common, "onBackground", "#000")), P.mode === "dark" && (Se(P.common, "background", "#000"), Se(P.common, "onBackground", "#fff"));
    function I(G, L, K) {
      if (O) {
        let q;
        return G === zp && (q = `transparent ${((1 - K) * 100).toFixed(0)}%`), G === Rn && (q = `#000 ${(K * 100).toFixed(0)}%`), G === An && (q = `#fff ${(K * 100).toFixed(0)}%`), `color-mix(in ${O}, ${L}, ${q})`;
      }
      return G(L, K);
    }
    if (wJ(P, ["Alert", "AppBar", "Avatar", "Button", "Chip", "FilledInput", "LinearProgress", "Skeleton", "Slider", "SnackbarContent", "SpeedDialAction", "StepConnector", "StepContent", "Switch", "TableCell", "Tooltip"]), P.mode === "light") {
      Se(P.Alert, "errorColor", I(Rn, P.error.light, 0.6)), Se(P.Alert, "infoColor", I(Rn, P.info.light, 0.6)), Se(P.Alert, "successColor", I(Rn, P.success.light, 0.6)), Se(P.Alert, "warningColor", I(Rn, P.warning.light, 0.6)), Se(P.Alert, "errorFilledBg", W("palette-error-main")), Se(P.Alert, "infoFilledBg", W("palette-info-main")), Se(P.Alert, "successFilledBg", W("palette-success-main")), Se(P.Alert, "warningFilledBg", W("palette-warning-main")), Se(P.Alert, "errorFilledColor", Qs(() => P.getContrastText(P.error.main))), Se(P.Alert, "infoFilledColor", Qs(() => P.getContrastText(P.info.main))), Se(P.Alert, "successFilledColor", Qs(() => P.getContrastText(P.success.main))), Se(P.Alert, "warningFilledColor", Qs(() => P.getContrastText(P.warning.main))), Se(P.Alert, "errorStandardBg", I(An, P.error.light, 0.9)), Se(P.Alert, "infoStandardBg", I(An, P.info.light, 0.9)), Se(P.Alert, "successStandardBg", I(An, P.success.light, 0.9)), Se(P.Alert, "warningStandardBg", I(An, P.warning.light, 0.9)), Se(P.Alert, "errorIconColor", W("palette-error-main")), Se(P.Alert, "infoIconColor", W("palette-info-main")), Se(P.Alert, "successIconColor", W("palette-success-main")), Se(P.Alert, "warningIconColor", W("palette-warning-main")), Se(P.AppBar, "defaultBg", W("palette-grey-100")), Se(P.Avatar, "defaultBg", W("palette-grey-400")), Se(P.Button, "inheritContainedBg", W("palette-grey-300")), Se(P.Button, "inheritContainedHoverBg", W("palette-grey-A100")), Se(P.Chip, "defaultBorder", W("palette-grey-400")), Se(P.Chip, "defaultAvatarColor", W("palette-grey-700")), Se(P.Chip, "defaultIconColor", W("palette-grey-700")), Se(P.FilledInput, "bg", "rgba(0, 0, 0, 0.06)"), Se(P.FilledInput, "hoverBg", "rgba(0, 0, 0, 0.09)"), Se(P.FilledInput, "disabledBg", "rgba(0, 0, 0, 0.12)"), Se(P.LinearProgress, "primaryBg", I(An, P.primary.main, 0.62)), Se(P.LinearProgress, "secondaryBg", I(An, P.secondary.main, 0.62)), Se(P.LinearProgress, "errorBg", I(An, P.error.main, 0.62)), Se(P.LinearProgress, "infoBg", I(An, P.info.main, 0.62)), Se(P.LinearProgress, "successBg", I(An, P.success.main, 0.62)), Se(P.LinearProgress, "warningBg", I(An, P.warning.main, 0.62)), Se(P.Skeleton, "bg", O ? I(zp, P.text.primary, 0.11) : `rgba(${W("palette-text-primaryChannel")} / 0.11)`), Se(P.Slider, "primaryTrack", I(An, P.primary.main, 0.62)), Se(P.Slider, "secondaryTrack", I(An, P.secondary.main, 0.62)), Se(P.Slider, "errorTrack", I(An, P.error.main, 0.62)), Se(P.Slider, "infoTrack", I(An, P.info.main, 0.62)), Se(P.Slider, "successTrack", I(An, P.success.main, 0.62)), Se(P.Slider, "warningTrack", I(An, P.warning.main, 0.62));
      const G = O ? I(Rn, P.background.default, 0.6825) : US(P.background.default, 0.8);
      Se(P.SnackbarContent, "bg", G), Se(P.SnackbarContent, "color", Qs(() => O ? XN.text.primary : P.getContrastText(G))), Se(P.SpeedDialAction, "fabHoverBg", US(P.background.paper, 0.15)), Se(P.StepConnector, "border", W("palette-grey-400")), Se(P.StepContent, "border", W("palette-grey-400")), Se(P.Switch, "defaultColor", W("palette-common-white")), Se(P.Switch, "defaultDisabledColor", W("palette-grey-100")), Se(P.Switch, "primaryDisabledColor", I(An, P.primary.main, 0.62)), Se(P.Switch, "secondaryDisabledColor", I(An, P.secondary.main, 0.62)), Se(P.Switch, "errorDisabledColor", I(An, P.error.main, 0.62)), Se(P.Switch, "infoDisabledColor", I(An, P.info.main, 0.62)), Se(P.Switch, "successDisabledColor", I(An, P.success.main, 0.62)), Se(P.Switch, "warningDisabledColor", I(An, P.warning.main, 0.62)), Se(P.TableCell, "border", I(An, I(zp, P.divider, 1), 0.88)), Se(P.Tooltip, "bg", I(zp, P.grey[700], 0.92));
    }
    if (P.mode === "dark") {
      Se(P.Alert, "errorColor", I(An, P.error.light, 0.6)), Se(P.Alert, "infoColor", I(An, P.info.light, 0.6)), Se(P.Alert, "successColor", I(An, P.success.light, 0.6)), Se(P.Alert, "warningColor", I(An, P.warning.light, 0.6)), Se(P.Alert, "errorFilledBg", W("palette-error-dark")), Se(P.Alert, "infoFilledBg", W("palette-info-dark")), Se(P.Alert, "successFilledBg", W("palette-success-dark")), Se(P.Alert, "warningFilledBg", W("palette-warning-dark")), Se(P.Alert, "errorFilledColor", Qs(() => P.getContrastText(P.error.dark))), Se(P.Alert, "infoFilledColor", Qs(() => P.getContrastText(P.info.dark))), Se(P.Alert, "successFilledColor", Qs(() => P.getContrastText(P.success.dark))), Se(P.Alert, "warningFilledColor", Qs(() => P.getContrastText(P.warning.dark))), Se(P.Alert, "errorStandardBg", I(Rn, P.error.light, 0.9)), Se(P.Alert, "infoStandardBg", I(Rn, P.info.light, 0.9)), Se(P.Alert, "successStandardBg", I(Rn, P.success.light, 0.9)), Se(P.Alert, "warningStandardBg", I(Rn, P.warning.light, 0.9)), Se(P.Alert, "errorIconColor", W("palette-error-main")), Se(P.Alert, "infoIconColor", W("palette-info-main")), Se(P.Alert, "successIconColor", W("palette-success-main")), Se(P.Alert, "warningIconColor", W("palette-warning-main")), Se(P.AppBar, "defaultBg", W("palette-grey-900")), Se(P.AppBar, "darkBg", W("palette-background-paper")), Se(P.AppBar, "darkColor", W("palette-text-primary")), Se(P.Avatar, "defaultBg", W("palette-grey-600")), Se(P.Button, "inheritContainedBg", W("palette-grey-800")), Se(P.Button, "inheritContainedHoverBg", W("palette-grey-700")), Se(P.Chip, "defaultBorder", W("palette-grey-700")), Se(P.Chip, "defaultAvatarColor", W("palette-grey-300")), Se(P.Chip, "defaultIconColor", W("palette-grey-300")), Se(P.FilledInput, "bg", "rgba(255, 255, 255, 0.09)"), Se(P.FilledInput, "hoverBg", "rgba(255, 255, 255, 0.13)"), Se(P.FilledInput, "disabledBg", "rgba(255, 255, 255, 0.12)"), Se(P.LinearProgress, "primaryBg", I(Rn, P.primary.main, 0.5)), Se(P.LinearProgress, "secondaryBg", I(Rn, P.secondary.main, 0.5)), Se(P.LinearProgress, "errorBg", I(Rn, P.error.main, 0.5)), Se(P.LinearProgress, "infoBg", I(Rn, P.info.main, 0.5)), Se(P.LinearProgress, "successBg", I(Rn, P.success.main, 0.5)), Se(P.LinearProgress, "warningBg", I(Rn, P.warning.main, 0.5)), Se(P.Skeleton, "bg", O ? I(zp, P.text.primary, 0.13) : `rgba(${W("palette-text-primaryChannel")} / 0.13)`), Se(P.Slider, "primaryTrack", I(Rn, P.primary.main, 0.5)), Se(P.Slider, "secondaryTrack", I(Rn, P.secondary.main, 0.5)), Se(P.Slider, "errorTrack", I(Rn, P.error.main, 0.5)), Se(P.Slider, "infoTrack", I(Rn, P.info.main, 0.5)), Se(P.Slider, "successTrack", I(Rn, P.success.main, 0.5)), Se(P.Slider, "warningTrack", I(Rn, P.warning.main, 0.5));
      const G = O ? I(An, P.background.default, 0.985) : US(P.background.default, 0.98);
      Se(P.SnackbarContent, "bg", G), Se(P.SnackbarContent, "color", Qs(() => O ? o9.text.primary : P.getContrastText(G))), Se(P.SpeedDialAction, "fabHoverBg", US(P.background.paper, 0.15)), Se(P.StepConnector, "border", W("palette-grey-600")), Se(P.StepContent, "border", W("palette-grey-600")), Se(P.Switch, "defaultColor", W("palette-grey-300")), Se(P.Switch, "defaultDisabledColor", W("palette-grey-600")), Se(P.Switch, "primaryDisabledColor", I(Rn, P.primary.main, 0.55)), Se(P.Switch, "secondaryDisabledColor", I(Rn, P.secondary.main, 0.55)), Se(P.Switch, "errorDisabledColor", I(Rn, P.error.main, 0.55)), Se(P.Switch, "infoDisabledColor", I(Rn, P.info.main, 0.55)), Se(P.Switch, "successDisabledColor", I(Rn, P.success.main, 0.55)), Se(P.Switch, "warningDisabledColor", I(Rn, P.warning.main, 0.55)), Se(P.TableCell, "border", I(Rn, I(zp, P.divider, 1), 0.68)), Se(P.Tooltip, "bg", I(zp, P.grey[700], 0.92));
    }
    Zu(P.background, "default"), Zu(P.background, "paper"), Zu(P.common, "background"), Zu(P.common, "onBackground"), Zu(P, "divider"), Object.keys(P).forEach((G) => {
      const L = P[G];
      G !== "tonalOffset" && L && typeof L == "object" && (L.main && Se(P[G], "mainChannel", Rw(Aw(L.main))), L.light && Se(P[G], "lightChannel", Rw(Aw(L.light))), L.dark && Se(P[G], "darkChannel", Rw(Aw(L.dark))), L.contrastText && Se(P[G], "contrastTextChannel", Rw(Aw(L.contrastText))), G === "text" && (Zu(P[G], "primary"), Zu(P[G], "secondary")), G === "action" && (L.active && Zu(P[G], "active"), L.selected && Zu(P[G], "selected")));
    });
  }), R = t.reduce((B, P) => Go(B, P), R);
  const j = {
    prefix: s,
    disableCssColorScheme: a,
    shouldSkipGeneratingVar: c,
    getSelector: bJ(R),
    enableContrastVars: l
  }, {
    vars: D,
    generateThemeVars: $,
    generateStyleSheets: z
  } = MQ(R, j);
  return R.vars = D, Object.entries(R.colorSchemes[R.defaultColorScheme]).forEach(([B, P]) => {
    R[B] = P;
  }), R.generateThemeVars = $, R.generateStyleSheets = z, R.generateSpacing = function() {
    return H1(m.spacing, F3(this));
  }, R.getColorSchemeSelector = NQ(d), R.spacing = R.generateSpacing(), R.shouldSkipGeneratingVar = c, R.unstable_sxConfig = {
    ...Yx,
    ...m?.unstable_sxConfig
  }, R.unstable_sx = function(B) {
    return od({
      sx: B,
      theme: this
    });
  }, R.toRuntimeSource = s9, R;
}
function yP(e, t, n) {
  e.colorSchemes && n && (e.colorSchemes[t] = {
    ...n !== !0 && n,
    palette: tR({
      ...n === !0 ? {} : n.palette,
      mode: t
    })
    // cast type to skip module augmentation test
  });
}
function l2(e = {}, ...t) {
  const {
    palette: n,
    cssVariables: r = !1,
    colorSchemes: a = n ? void 0 : {
      light: !0
    },
    defaultColorScheme: s = n?.mode,
    ...l
  } = e, c = s || "light", d = a?.[c], p = {
    ...a,
    ...n ? {
      [c]: {
        ...typeof d != "boolean" && d,
        palette: n
      }
    } : void 0
  };
  if (r === !1) {
    if (!("colorSchemes" in e))
      return YN(e, ...t);
    let m = n;
    "palette" in e || p[c] && (p[c] !== !0 ? m = p[c].palette : c === "dark" && (m = {
      mode: "dark"
    }));
    const h = YN({
      ...e,
      palette: m
    }, ...t);
    return h.defaultColorScheme = c, h.colorSchemes = p, h.palette.mode === "light" && (h.colorSchemes.light = {
      ...p.light !== !0 && p.light,
      palette: h.palette
    }, yP(h, "dark", p.dark)), h.palette.mode === "dark" && (h.colorSchemes.dark = {
      ...p.dark !== !0 && p.dark,
      palette: h.palette
    }, yP(h, "light", p.light)), h;
  }
  return !n && !("light" in p) && c === "light" && (p.light = !0), kJ({
    ...l,
    colorSchemes: p,
    defaultColorScheme: c,
    ...typeof r != "boolean" && r
  }, ...t);
}
const nR = l2(), xl = "$$material";
function u2() {
  const e = tS(nR);
  return e[xl] || e;
}
function _J(e) {
  return /* @__PURE__ */ E.jsx(q1, {
    ...e,
    defaultTheme: nR,
    themeId: xl
  });
}
function c2(e) {
  return e !== "ownerState" && e !== "theme" && e !== "sx" && e !== "as";
}
const Xo = (e) => c2(e) && e !== "classes", $e = X1({
  themeId: xl,
  defaultTheme: nR,
  rootShouldForwardProp: Xo
});
function EJ(e) {
  return function(t) {
    return (
      // Pigment CSS `globalCss` support callback with theme inside an object but `GlobalStyles` support theme as a callback value.
      /* @__PURE__ */ E.jsx(_J, {
        styles: typeof e == "function" ? (n) => e({
          theme: n,
          ...t
        }) : e
      })
    );
  };
}
function CJ() {
  return U3;
}
const Ct = gQ;
function At(e) {
  return fQ(e);
}
function OJ(e) {
  return _t("MuiTable", e);
}
wt("MuiTable", ["root", "stickyHeader"]);
const MJ = (e) => {
  const {
    classes: t,
    stickyHeader: n
  } = e;
  return kt({
    root: ["root", n && "stickyHeader"]
  }, OJ, t);
}, NJ = $e("table", {
  name: "MuiTable",
  slot: "Root",
  overridesResolver: (e, t) => {
    const {
      ownerState: n
    } = e;
    return [t.root, n.stickyHeader && t.stickyHeader];
  }
})(Ct(({
  theme: e
}) => ({
  display: "table",
  width: "100%",
  borderCollapse: "collapse",
  borderSpacing: 0,
  "& caption": {
    ...e.typography.body2,
    padding: e.spacing(2),
    color: (e.vars || e).palette.text.secondary,
    textAlign: "left",
    captionSide: "bottom"
  },
  variants: [{
    props: ({
      ownerState: t
    }) => t.stickyHeader,
    style: {
      borderCollapse: "separate"
    }
  }]
}))), bP = "table", RJ = /* @__PURE__ */ M.forwardRef(function(e, t) {
  const n = At({
    props: e,
    name: "MuiTable"
  }), {
    className: r,
    component: a = bP,
    padding: s = "normal",
    size: l = "medium",
    stickyHeader: c = !1,
    ...d
  } = n, p = {
    ...n,
    component: a,
    padding: s,
    size: l,
    stickyHeader: c
  }, m = MJ(p), h = M.useMemo(() => ({
    padding: s,
    size: l,
    stickyHeader: c
  }), [s, l, c]);
  return /* @__PURE__ */ E.jsx(E1.Provider, {
    value: h,
    children: /* @__PURE__ */ E.jsx(NJ, {
      as: a,
      role: a === bP ? null : "table",
      ref: t,
      className: Ke(m.root, r),
      ownerState: p,
      ...d
    })
  });
}), d2 = /* @__PURE__ */ M.createContext();
function AJ(e) {
  return _t("MuiTableBody", e);
}
wt("MuiTableBody", ["root"]);
const jJ = (e) => {
  const {
    classes: t
  } = e;
  return kt({
    root: ["root"]
  }, AJ, t);
}, PJ = $e("tbody", {
  name: "MuiTableBody",
  slot: "Root"
})({
  display: "table-row-group"
}), DJ = {
  variant: "body"
}, wP = "tbody", $J = /* @__PURE__ */ M.forwardRef(function(e, t) {
  const n = At({
    props: e,
    name: "MuiTableBody"
  }), {
    className: r,
    component: a = wP,
    ...s
  } = n, l = {
    ...n,
    component: a
  }, c = jJ(l);
  return /* @__PURE__ */ E.jsx(d2.Provider, {
    value: DJ,
    children: /* @__PURE__ */ E.jsx(PJ, {
      className: Ke(c.root, r),
      as: a,
      ref: t,
      role: a === wP ? null : "rowgroup",
      ownerState: l,
      ...s
    })
  });
});
function TJ(e) {
  return _t("MuiTableCell", e);
}
const LJ = wt("MuiTableCell", ["root", "head", "body", "footer", "sizeSmall", "sizeMedium", "paddingCheckbox", "paddingNone", "alignLeft", "alignCenter", "alignRight", "alignJustify", "stickyHeader"]), IJ = (e) => {
  const {
    classes: t,
    variant: n,
    align: r,
    padding: a,
    size: s,
    stickyHeader: l
  } = e, c = {
    root: ["root", n, l && "stickyHeader", r !== "inherit" && `align${qe(r)}`, a !== "normal" && `padding${qe(a)}`, `size${qe(s)}`]
  };
  return kt(c, TJ, t);
}, zJ = $e("td", {
  name: "MuiTableCell",
  slot: "Root",
  overridesResolver: (e, t) => {
    const {
      ownerState: n
    } = e;
    return [t.root, t[n.variant], t[`size${qe(n.size)}`], n.padding !== "normal" && t[`padding${qe(n.padding)}`], n.align !== "inherit" && t[`align${qe(n.align)}`], n.stickyHeader && t.stickyHeader];
  }
})(Ct(({
  theme: e
}) => ({
  ...e.typography.body2,
  display: "table-cell",
  verticalAlign: "inherit",
  // Workaround for a rendering bug with spanned columns in Chrome 62.0.
  // Removes the alpha (sets it to 1), and lightens or darkens the theme color.
  borderBottom: e.vars ? `1px solid ${e.vars.palette.TableCell.border}` : `1px solid
    ${e.palette.mode === "light" ? e.lighten(e.alpha(e.palette.divider, 1), 0.88) : e.darken(e.alpha(e.palette.divider, 1), 0.68)}`,
  textAlign: "left",
  padding: 16,
  variants: [{
    props: {
      variant: "head"
    },
    style: {
      color: (e.vars || e).palette.text.primary,
      lineHeight: e.typography.pxToRem(24),
      fontWeight: e.typography.fontWeightMedium
    }
  }, {
    props: {
      variant: "body"
    },
    style: {
      color: (e.vars || e).palette.text.primary
    }
  }, {
    props: {
      variant: "footer"
    },
    style: {
      color: (e.vars || e).palette.text.secondary,
      lineHeight: e.typography.pxToRem(21),
      fontSize: e.typography.pxToRem(12)
    }
  }, {
    props: {
      size: "small"
    },
    style: {
      padding: "6px 16px",
      [`&.${LJ.paddingCheckbox}`]: {
        width: 24,
        // prevent the checkbox column from growing
        padding: "0 12px 0 16px",
        "& > *": {
          padding: 0
        }
      }
    }
  }, {
    props: {
      padding: "checkbox"
    },
    style: {
      width: 48,
      // prevent the checkbox column from growing
      padding: "0 0 0 4px"
    }
  }, {
    props: {
      padding: "none"
    },
    style: {
      padding: 0
    }
  }, {
    props: {
      align: "left"
    },
    style: {
      textAlign: "left"
    }
  }, {
    props: {
      align: "center"
    },
    style: {
      textAlign: "center"
    }
  }, {
    props: {
      align: "right"
    },
    style: {
      textAlign: "right",
      flexDirection: "row-reverse"
    }
  }, {
    props: {
      align: "justify"
    },
    style: {
      textAlign: "justify"
    }
  }, {
    props: ({
      ownerState: t
    }) => t.stickyHeader,
    style: {
      position: "sticky",
      top: 0,
      zIndex: 2,
      backgroundColor: (e.vars || e).palette.background.default
    }
  }]
}))), VS = /* @__PURE__ */ M.forwardRef(function(e, t) {
  const n = At({
    props: e,
    name: "MuiTableCell"
  }), {
    align: r = "inherit",
    className: a,
    component: s,
    padding: l,
    scope: c,
    size: d,
    sortDirection: p,
    variant: m,
    ...h
  } = n, v = M.useContext(E1), y = M.useContext(d2), w = y && y.variant === "head";
  let x;
  s ? x = s : x = w ? "th" : "td";
  let b = c;
  x === "td" ? b = void 0 : !b && w && (b = "col");
  const k = m || y && y.variant, C = {
    ...n,
    align: r,
    component: x,
    padding: l || (v && v.padding ? v.padding : "normal"),
    size: d || (v && v.size ? v.size : "medium"),
    sortDirection: p,
    stickyHeader: k === "head" && v && v.stickyHeader,
    variant: k
  }, _ = IJ(C);
  let O = null;
  return p && (O = p === "asc" ? "ascending" : "descending"), /* @__PURE__ */ E.jsx(zJ, {
    as: x,
    ref: t,
    className: Ke(_.root, a),
    "aria-sort": O,
    scope: b,
    ownerState: C,
    ...h
  });
});
function FJ(e) {
  return _t("MuiTableContainer", e);
}
wt("MuiTableContainer", ["root"]);
const BJ = (e) => {
  const {
    classes: t
  } = e;
  return kt({
    root: ["root"]
  }, FJ, t);
}, UJ = $e("div", {
  name: "MuiTableContainer",
  slot: "Root"
})({
  width: "100%",
  overflowX: "auto"
}), VJ = /* @__PURE__ */ M.forwardRef(function(e, t) {
  const n = At({
    props: e,
    name: "MuiTableContainer"
  }), {
    className: r,
    component: a = "div",
    ...s
  } = n, l = {
    ...n,
    component: a
  }, c = BJ(l);
  return /* @__PURE__ */ E.jsx(UJ, {
    ref: t,
    as: a,
    className: Ke(c.root, r),
    ownerState: l,
    ...s
  });
});
function HJ(e) {
  return _t("MuiTableHead", e);
}
wt("MuiTableHead", ["root"]);
const qJ = (e) => {
  const {
    classes: t
  } = e;
  return kt({
    root: ["root"]
  }, HJ, t);
}, WJ = $e("thead", {
  name: "MuiTableHead",
  slot: "Root"
})({
  display: "table-header-group"
}), GJ = {
  variant: "head"
}, xP = "thead", KJ = /* @__PURE__ */ M.forwardRef(function(e, t) {
  const n = At({
    props: e,
    name: "MuiTableHead"
  }), {
    className: r,
    component: a = xP,
    ...s
  } = n, l = {
    ...n,
    component: a
  }, c = qJ(l);
  return /* @__PURE__ */ E.jsx(d2.Provider, {
    value: GJ,
    children: /* @__PURE__ */ E.jsx(WJ, {
      as: a,
      className: Ke(c.root, r),
      ref: t,
      role: a === xP ? null : "rowgroup",
      ownerState: l,
      ...s
    })
  });
});
function XJ(e) {
  return _t("MuiTableRow", e);
}
const SP = wt("MuiTableRow", ["root", "selected", "hover", "head", "footer"]), YJ = (e) => {
  const {
    classes: t,
    selected: n,
    hover: r,
    head: a,
    footer: s
  } = e;
  return kt({
    root: ["root", n && "selected", r && "hover", a && "head", s && "footer"]
  }, XJ, t);
}, QJ = $e("tr", {
  name: "MuiTableRow",
  slot: "Root",
  overridesResolver: (e, t) => {
    const {
      ownerState: n
    } = e;
    return [t.root, n.head && t.head, n.footer && t.footer];
  }
})(Ct(({
  theme: e
}) => ({
  color: "inherit",
  display: "table-row",
  verticalAlign: "middle",
  // We disable the focus ring for mouse, touch and keyboard users.
  outline: 0,
  [`&.${SP.hover}:hover`]: {
    backgroundColor: (e.vars || e).palette.action.hover
  },
  [`&.${SP.selected}`]: {
    backgroundColor: e.alpha((e.vars || e).palette.primary.main, (e.vars || e).palette.action.selectedOpacity),
    "&:hover": {
      backgroundColor: e.alpha((e.vars || e).palette.primary.main, `${(e.vars || e).palette.action.selectedOpacity} + ${(e.vars || e).palette.action.hoverOpacity}`)
    }
  }
}))), kP = "tr", HS = /* @__PURE__ */ M.forwardRef(function(e, t) {
  const n = At({
    props: e,
    name: "MuiTableRow"
  }), {
    className: r,
    component: a = kP,
    hover: s = !1,
    selected: l = !1,
    ...c
  } = n, d = M.useContext(d2), p = {
    ...n,
    component: a,
    hover: s,
    selected: l,
    head: d && d.variant === "head",
    footer: d && d.variant === "footer"
  }, m = YJ(p);
  return /* @__PURE__ */ E.jsx(QJ, {
    as: a,
    ref: t,
    className: Ke(m.root, r),
    role: a === kP ? null : "row",
    ownerState: p,
    ...c
  });
});
gh.oneOfType([gh.func, gh.object]);
function rR(e, t) {
  return () => null;
}
rR(gh.elementType);
function K0(e) {
  try {
    return e.matches(":focus-visible");
  } catch {
  }
  return !1;
}
function no(...e) {
  const t = M.useRef(void 0), n = M.useCallback((r) => {
    const a = e.map((s) => {
      if (s == null)
        return null;
      if (typeof s == "function") {
        const l = s, c = l(r);
        return typeof c == "function" ? c : () => {
          l(null);
        };
      }
      return s.current = r, () => {
        s.current = null;
      };
    });
    return () => {
      a.forEach((s) => s?.());
    };
  }, e);
  return M.useMemo(() => e.every((r) => r == null) ? null : (r) => {
    t.current && (t.current(), t.current = void 0), r != null && (t.current = n(r));
  }, e);
}
function Sl(e) {
  const t = M.useRef(e);
  return zs(() => {
    t.current = e;
  }), M.useRef((...n) => (
    // @ts-expect-error hide `this`
    (0, t.current)(...n)
  )).current;
}
const _P = {};
function c9(e, t) {
  const n = M.useRef(_P);
  return n.current === _P && (n.current = e(t)), n;
}
class X0 {
  constructor() {
    Jr(this, "mountEffect", () => {
      this.shouldMount && !this.didMount && this.ref.current !== null && (this.didMount = !0, this.mounted.resolve());
    });
    this.ref = {
      current: null
    }, this.mounted = null, this.didMount = !1, this.shouldMount = !1, this.setShouldMount = null;
  }
  /** React ref to the ripple instance */
  /** If the ripple component should be mounted */
  /** Promise that resolves when the ripple component is mounted */
  /** If the ripple component has been mounted */
  /** React state hook setter */
  static create() {
    return new X0();
  }
  static use() {
    const t = c9(X0.create).current, [n, r] = M.useState(!1);
    return t.shouldMount = n, t.setShouldMount = r, M.useEffect(t.mountEffect, [n]), t;
  }
  mount() {
    return this.mounted || (this.mounted = ZJ(), this.shouldMount = !0, this.setShouldMount(this.shouldMount)), this.mounted;
  }
  /* Ripple API */
  start(...t) {
    this.mount().then(() => this.ref.current?.start(...t));
  }
  stop(...t) {
    this.mount().then(() => this.ref.current?.stop(...t));
  }
  pulsate(...t) {
    this.mount().then(() => this.ref.current?.pulsate(...t));
  }
}
function JJ() {
  return X0.use();
}
function ZJ() {
  let e, t;
  const n = new Promise((r, a) => {
    e = r, t = a;
  });
  return n.resolve = e, n.reject = t, n;
}
function f2(e, t) {
  if (e == null) return {};
  var n = {};
  for (var r in e) if ({}.hasOwnProperty.call(e, r)) {
    if (t.indexOf(r) !== -1) continue;
    n[r] = e[r];
  }
  return n;
}
function Y0(e, t) {
  return Y0 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(n, r) {
    return n.__proto__ = r, n;
  }, Y0(e, t);
}
function oR(e, t) {
  e.prototype = Object.create(t.prototype), e.prototype.constructor = e, Y0(e, t);
}
const EP = {
  disabled: !1
}, Q0 = Qn.createContext(null);
var eZ = function(e) {
  return e.scrollTop;
}, jw = "unmounted", Gp = "exited", Kp = "entering", ah = "entered", JN = "exiting", Al = /* @__PURE__ */ (function(e) {
  oR(t, e);
  function t(r, a) {
    var s;
    s = e.call(this, r, a) || this;
    var l = a, c = l && !l.isMounting ? r.enter : r.appear, d;
    return s.appearStatus = null, r.in ? c ? (d = Gp, s.appearStatus = Kp) : d = ah : r.unmountOnExit || r.mountOnEnter ? d = jw : d = Gp, s.state = {
      status: d
    }, s.nextCallback = null, s;
  }
  t.getDerivedStateFromProps = function(r, a) {
    var s = r.in;
    return s && a.status === jw ? {
      status: Gp
    } : null;
  };
  var n = t.prototype;
  return n.componentDidMount = function() {
    this.updateStatus(!0, this.appearStatus);
  }, n.componentDidUpdate = function(r) {
    var a = null;
    if (r !== this.props) {
      var s = this.state.status;
      this.props.in ? s !== Kp && s !== ah && (a = Kp) : (s === Kp || s === ah) && (a = JN);
    }
    this.updateStatus(!1, a);
  }, n.componentWillUnmount = function() {
    this.cancelNextCallback();
  }, n.getTimeouts = function() {
    var r = this.props.timeout, a, s, l;
    return a = s = l = r, r != null && typeof r != "number" && (a = r.exit, s = r.enter, l = r.appear !== void 0 ? r.appear : s), {
      exit: a,
      enter: s,
      appear: l
    };
  }, n.updateStatus = function(r, a) {
    if (r === void 0 && (r = !1), a !== null)
      if (this.cancelNextCallback(), a === Kp) {
        if (this.props.unmountOnExit || this.props.mountOnEnter) {
          var s = this.props.nodeRef ? this.props.nodeRef.current : uh.findDOMNode(this);
          s && eZ(s);
        }
        this.performEnter(r);
      } else
        this.performExit();
    else this.props.unmountOnExit && this.state.status === Gp && this.setState({
      status: jw
    });
  }, n.performEnter = function(r) {
    var a = this, s = this.props.enter, l = this.context ? this.context.isMounting : r, c = this.props.nodeRef ? [l] : [uh.findDOMNode(this), l], d = c[0], p = c[1], m = this.getTimeouts(), h = l ? m.appear : m.enter;
    if (!r && !s || EP.disabled) {
      this.safeSetState({
        status: ah
      }, function() {
        a.props.onEntered(d);
      });
      return;
    }
    this.props.onEnter(d, p), this.safeSetState({
      status: Kp
    }, function() {
      a.props.onEntering(d, p), a.onTransitionEnd(h, function() {
        a.safeSetState({
          status: ah
        }, function() {
          a.props.onEntered(d, p);
        });
      });
    });
  }, n.performExit = function() {
    var r = this, a = this.props.exit, s = this.getTimeouts(), l = this.props.nodeRef ? void 0 : uh.findDOMNode(this);
    if (!a || EP.disabled) {
      this.safeSetState({
        status: Gp
      }, function() {
        r.props.onExited(l);
      });
      return;
    }
    this.props.onExit(l), this.safeSetState({
      status: JN
    }, function() {
      r.props.onExiting(l), r.onTransitionEnd(s.exit, function() {
        r.safeSetState({
          status: Gp
        }, function() {
          r.props.onExited(l);
        });
      });
    });
  }, n.cancelNextCallback = function() {
    this.nextCallback !== null && (this.nextCallback.cancel(), this.nextCallback = null);
  }, n.safeSetState = function(r, a) {
    a = this.setNextCallback(a), this.setState(r, a);
  }, n.setNextCallback = function(r) {
    var a = this, s = !0;
    return this.nextCallback = function(l) {
      s && (s = !1, a.nextCallback = null, r(l));
    }, this.nextCallback.cancel = function() {
      s = !1;
    }, this.nextCallback;
  }, n.onTransitionEnd = function(r, a) {
    this.setNextCallback(a);
    var s = this.props.nodeRef ? this.props.nodeRef.current : uh.findDOMNode(this), l = r == null && !this.props.addEndListener;
    if (!s || l) {
      setTimeout(this.nextCallback, 0);
      return;
    }
    if (this.props.addEndListener) {
      var c = this.props.nodeRef ? [this.nextCallback] : [s, this.nextCallback], d = c[0], p = c[1];
      this.props.addEndListener(d, p);
    }
    r != null && setTimeout(this.nextCallback, r);
  }, n.render = function() {
    var r = this.state.status;
    if (r === jw)
      return null;
    var a = this.props, s = a.children;
    a.in, a.mountOnEnter, a.unmountOnExit, a.appear, a.enter, a.exit, a.timeout, a.addEndListener, a.onEnter, a.onEntering, a.onEntered, a.onExit, a.onExiting, a.onExited, a.nodeRef;
    var l = f2(a, ["children", "in", "mountOnEnter", "unmountOnExit", "appear", "enter", "exit", "timeout", "addEndListener", "onEnter", "onEntering", "onEntered", "onExit", "onExiting", "onExited", "nodeRef"]);
    return (
      // allows for nested Transitions
      /* @__PURE__ */ Qn.createElement(Q0.Provider, {
        value: null
      }, typeof s == "function" ? s(r, l) : Qn.cloneElement(Qn.Children.only(s), l))
    );
  }, t;
})(Qn.Component);
Al.contextType = Q0;
Al.propTypes = {};
function Um() {
}
Al.defaultProps = {
  in: !1,
  mountOnEnter: !1,
  unmountOnExit: !1,
  appear: !1,
  enter: !0,
  exit: !0,
  onEnter: Um,
  onEntering: Um,
  onEntered: Um,
  onExit: Um,
  onExiting: Um,
  onExited: Um
};
Al.UNMOUNTED = jw;
Al.EXITED = Gp;
Al.ENTERING = Kp;
Al.ENTERED = ah;
Al.EXITING = JN;
function d9(e) {
  if (e === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return e;
}
function aR(e, t) {
  var n = function(a) {
    return t && M.isValidElement(a) ? t(a) : a;
  }, r = /* @__PURE__ */ Object.create(null);
  return e && M.Children.map(e, function(a) {
    return a;
  }).forEach(function(a) {
    r[a.key] = n(a);
  }), r;
}
function tZ(e, t) {
  e = e || {}, t = t || {};
  function n(m) {
    return m in t ? t[m] : e[m];
  }
  var r = /* @__PURE__ */ Object.create(null), a = [];
  for (var s in e)
    s in t ? a.length && (r[s] = a, a = []) : a.push(s);
  var l, c = {};
  for (var d in t) {
    if (r[d])
      for (l = 0; l < r[d].length; l++) {
        var p = r[d][l];
        c[r[d][l]] = n(p);
      }
    c[d] = n(d);
  }
  for (l = 0; l < a.length; l++)
    c[a[l]] = n(a[l]);
  return c;
}
function Zp(e, t, n) {
  return n[t] != null ? n[t] : e.props[t];
}
function nZ(e, t) {
  return aR(e.children, function(n) {
    return M.cloneElement(n, {
      onExited: t.bind(null, n),
      in: !0,
      appear: Zp(n, "appear", e),
      enter: Zp(n, "enter", e),
      exit: Zp(n, "exit", e)
    });
  });
}
function rZ(e, t, n) {
  var r = aR(e.children), a = tZ(t, r);
  return Object.keys(a).forEach(function(s) {
    var l = a[s];
    if (M.isValidElement(l)) {
      var c = s in t, d = s in r, p = t[s], m = M.isValidElement(p) && !p.props.in;
      d && (!c || m) ? a[s] = M.cloneElement(l, {
        onExited: n.bind(null, l),
        in: !0,
        exit: Zp(l, "exit", e),
        enter: Zp(l, "enter", e)
      }) : !d && c && !m ? a[s] = M.cloneElement(l, {
        in: !1
      }) : d && c && M.isValidElement(p) && (a[s] = M.cloneElement(l, {
        onExited: n.bind(null, l),
        in: p.props.in,
        exit: Zp(l, "exit", e),
        enter: Zp(l, "enter", e)
      }));
    }
  }), a;
}
var oZ = Object.values || function(e) {
  return Object.keys(e).map(function(t) {
    return e[t];
  });
}, aZ = {
  component: "div",
  childFactory: function(e) {
    return e;
  }
}, iR = /* @__PURE__ */ (function(e) {
  oR(t, e);
  function t(r, a) {
    var s;
    s = e.call(this, r, a) || this;
    var l = s.handleExited.bind(d9(s));
    return s.state = {
      contextValue: {
        isMounting: !0
      },
      handleExited: l,
      firstRender: !0
    }, s;
  }
  var n = t.prototype;
  return n.componentDidMount = function() {
    this.mounted = !0, this.setState({
      contextValue: {
        isMounting: !1
      }
    });
  }, n.componentWillUnmount = function() {
    this.mounted = !1;
  }, t.getDerivedStateFromProps = function(r, a) {
    var s = a.children, l = a.handleExited, c = a.firstRender;
    return {
      children: c ? nZ(r, l) : rZ(r, s, l),
      firstRender: !1
    };
  }, n.handleExited = function(r, a) {
    var s = aR(this.props.children);
    r.key in s || (r.props.onExited && r.props.onExited(a), this.mounted && this.setState(function(l) {
      var c = ft({}, l.children);
      return delete c[r.key], {
        children: c
      };
    }));
  }, n.render = function() {
    var r = this.props, a = r.component, s = r.childFactory, l = f2(r, ["component", "childFactory"]), c = this.state.contextValue, d = oZ(this.state.children).map(s);
    return delete l.appear, delete l.enter, delete l.exit, a === null ? /* @__PURE__ */ Qn.createElement(Q0.Provider, {
      value: c
    }, d) : /* @__PURE__ */ Qn.createElement(Q0.Provider, {
      value: c
    }, /* @__PURE__ */ Qn.createElement(a, l, d));
  }, t;
})(Qn.Component);
iR.propTypes = {};
iR.defaultProps = aZ;
const iZ = [];
function sZ(e) {
  M.useEffect(e, iZ);
}
class sR {
  constructor() {
    Jr(this, "currentId", null);
    Jr(this, "clear", () => {
      this.currentId !== null && (clearTimeout(this.currentId), this.currentId = null);
    });
    Jr(this, "disposeEffect", () => this.clear);
  }
  static create() {
    return new sR();
  }
  /**
   * Executes `fn` after `delay`, clearing any previously scheduled call.
   */
  start(t, n) {
    this.clear(), this.currentId = setTimeout(() => {
      this.currentId = null, n();
    }, t);
  }
}
function f9() {
  const e = c9(sR.create).current;
  return sZ(e.disposeEffect), e;
}
function lZ(e) {
  const {
    className: t,
    classes: n,
    pulsate: r = !1,
    rippleX: a,
    rippleY: s,
    rippleSize: l,
    in: c,
    onExited: d,
    timeout: p
  } = e, [m, h] = M.useState(!1), v = Ke(t, n.ripple, n.rippleVisible, r && n.ripplePulsate), y = {
    width: l,
    height: l,
    top: -(l / 2) + s,
    left: -(l / 2) + a
  }, w = Ke(n.child, m && n.childLeaving, r && n.childPulsate);
  return !c && !m && h(!0), M.useEffect(() => {
    if (!c && d != null) {
      const x = setTimeout(d, p);
      return () => {
        clearTimeout(x);
      };
    }
  }, [d, c, p]), /* @__PURE__ */ E.jsx("span", {
    className: v,
    style: y,
    children: /* @__PURE__ */ E.jsx("span", {
      className: w
    })
  });
}
const Ci = wt("MuiTouchRipple", ["root", "ripple", "rippleVisible", "ripplePulsate", "child", "childLeaving", "childPulsate"]), ZN = 550, uZ = 80, cZ = Zh`
  0% {
    transform: scale(0);
    opacity: 0.1;
  }

  100% {
    transform: scale(1);
    opacity: 0.3;
  }
`, dZ = Zh`
  0% {
    opacity: 1;
  }

  100% {
    opacity: 0;
  }
`, fZ = Zh`
  0% {
    transform: scale(1);
  }

  50% {
    transform: scale(0.92);
  }

  100% {
    transform: scale(1);
  }
`, pZ = $e("span", {
  name: "MuiTouchRipple",
  slot: "Root"
})({
  overflow: "hidden",
  pointerEvents: "none",
  position: "absolute",
  zIndex: 0,
  top: 0,
  right: 0,
  bottom: 0,
  left: 0,
  borderRadius: "inherit"
}), mZ = $e(lZ, {
  name: "MuiTouchRipple",
  slot: "Ripple"
})`
  opacity: 0;
  position: absolute;

  &.${Ci.rippleVisible} {
    opacity: 0.3;
    transform: scale(1);
    animation-name: ${cZ};
    animation-duration: ${ZN}ms;
    animation-timing-function: ${({
  theme: e
}) => e.transitions.easing.easeInOut};
  }

  &.${Ci.ripplePulsate} {
    animation-duration: ${({
  theme: e
}) => e.transitions.duration.shorter}ms;
  }

  & .${Ci.child} {
    opacity: 1;
    display: block;
    width: 100%;
    height: 100%;
    border-radius: 50%;
    background-color: currentColor;
  }

  & .${Ci.childLeaving} {
    opacity: 0;
    animation-name: ${dZ};
    animation-duration: ${ZN}ms;
    animation-timing-function: ${({
  theme: e
}) => e.transitions.easing.easeInOut};
  }

  & .${Ci.childPulsate} {
    position: absolute;
    /* @noflip */
    left: 0px;
    top: 0;
    animation-name: ${fZ};
    animation-duration: 2500ms;
    animation-timing-function: ${({
  theme: e
}) => e.transitions.easing.easeInOut};
    animation-iteration-count: infinite;
    animation-delay: 200ms;
  }
`, hZ = /* @__PURE__ */ M.forwardRef(function(e, t) {
  const n = At({
    props: e,
    name: "MuiTouchRipple"
  }), {
    center: r = !1,
    classes: a = {},
    className: s,
    ...l
  } = n, [c, d] = M.useState([]), p = M.useRef(0), m = M.useRef(null);
  M.useEffect(() => {
    m.current && (m.current(), m.current = null);
  }, [c]);
  const h = M.useRef(!1), v = f9(), y = M.useRef(null), w = M.useRef(null), x = M.useCallback((_) => {
    const {
      pulsate: O,
      rippleX: N,
      rippleY: R,
      rippleSize: j,
      cb: D
    } = _;
    d(($) => [...$, /* @__PURE__ */ E.jsx(mZ, {
      classes: {
        ripple: Ke(a.ripple, Ci.ripple),
        rippleVisible: Ke(a.rippleVisible, Ci.rippleVisible),
        ripplePulsate: Ke(a.ripplePulsate, Ci.ripplePulsate),
        child: Ke(a.child, Ci.child),
        childLeaving: Ke(a.childLeaving, Ci.childLeaving),
        childPulsate: Ke(a.childPulsate, Ci.childPulsate)
      },
      timeout: ZN,
      pulsate: O,
      rippleX: N,
      rippleY: R,
      rippleSize: j
    }, p.current)]), p.current += 1, m.current = D;
  }, [a]), b = M.useCallback((_ = {}, O = {}, N = () => {
  }) => {
    const {
      pulsate: R = !1,
      center: j = r || O.pulsate,
      fakeElement: D = !1
      // For test purposes
    } = O;
    if (_?.type === "mousedown" && h.current) {
      h.current = !1;
      return;
    }
    _?.type === "touchstart" && (h.current = !0);
    const $ = D ? null : w.current, z = $ ? $.getBoundingClientRect() : {
      width: 0,
      height: 0,
      left: 0,
      top: 0
    };
    let B, P, W;
    if (j || _ === void 0 || _.clientX === 0 && _.clientY === 0 || !_.clientX && !_.touches)
      B = Math.round(z.width / 2), P = Math.round(z.height / 2);
    else {
      const {
        clientX: I,
        clientY: G
      } = _.touches && _.touches.length > 0 ? _.touches[0] : _;
      B = Math.round(I - z.left), P = Math.round(G - z.top);
    }
    if (j)
      W = Math.sqrt((2 * z.width ** 2 + z.height ** 2) / 3), W % 2 === 0 && (W += 1);
    else {
      const I = Math.max(Math.abs(($ ? $.clientWidth : 0) - B), B) * 2 + 2, G = Math.max(Math.abs(($ ? $.clientHeight : 0) - P), P) * 2 + 2;
      W = Math.sqrt(I ** 2 + G ** 2);
    }
    _?.touches ? y.current === null && (y.current = () => {
      x({
        pulsate: R,
        rippleX: B,
        rippleY: P,
        rippleSize: W,
        cb: N
      });
    }, v.start(uZ, () => {
      y.current && (y.current(), y.current = null);
    })) : x({
      pulsate: R,
      rippleX: B,
      rippleY: P,
      rippleSize: W,
      cb: N
    });
  }, [r, x, v]), k = M.useCallback(() => {
    b({}, {
      pulsate: !0
    });
  }, [b]), C = M.useCallback((_, O) => {
    if (v.clear(), _?.type === "touchend" && y.current) {
      y.current(), y.current = null, v.start(0, () => {
        C(_, O);
      });
      return;
    }
    y.current = null, d((N) => N.length > 0 ? N.slice(1) : N), m.current = O;
  }, [v]);
  return M.useImperativeHandle(t, () => ({
    pulsate: k,
    start: b,
    stop: C
  }), [k, b, C]), /* @__PURE__ */ E.jsx(pZ, {
    className: Ke(Ci.root, a.root, s),
    ref: w,
    ...l,
    children: /* @__PURE__ */ E.jsx(iR, {
      component: null,
      exit: !0,
      children: c
    })
  });
});
function gZ(e) {
  return _t("MuiButtonBase", e);
}
const vZ = wt("MuiButtonBase", ["root", "disabled", "focusVisible"]), yZ = (e) => {
  const {
    disabled: t,
    focusVisible: n,
    focusVisibleClassName: r,
    classes: a
  } = e, s = kt({
    root: ["root", t && "disabled", n && "focusVisible"]
  }, gZ, a);
  return n && r && (s.root += ` ${r}`), s;
}, bZ = $e("button", {
  name: "MuiButtonBase",
  slot: "Root"
})({
  display: "inline-flex",
  alignItems: "center",
  justifyContent: "center",
  position: "relative",
  boxSizing: "border-box",
  WebkitTapHighlightColor: "transparent",
  backgroundColor: "transparent",
  // Reset default value
  // We disable the focus ring for mouse, touch and keyboard users.
  outline: 0,
  border: 0,
  margin: 0,
  // Remove the margin in Safari
  borderRadius: 0,
  padding: 0,
  // Remove the padding in Firefox
  cursor: "pointer",
  userSelect: "none",
  verticalAlign: "middle",
  MozAppearance: "none",
  // Reset
  WebkitAppearance: "none",
  // Reset
  textDecoration: "none",
  // So we take precedent over the style of a native <a /> element.
  color: "inherit",
  "&::-moz-focus-inner": {
    borderStyle: "none"
    // Remove Firefox dotted outline.
  },
  [`&.${vZ.disabled}`]: {
    pointerEvents: "none",
    // Disable link interactions
    cursor: "default"
  },
  "@media print": {
    colorAdjust: "exact"
  }
}), nS = /* @__PURE__ */ M.forwardRef(function(e, t) {
  const n = At({
    props: e,
    name: "MuiButtonBase"
  }), {
    action: r,
    centerRipple: a = !1,
    children: s,
    className: l,
    component: c = "button",
    disabled: d = !1,
    disableRipple: p = !1,
    disableTouchRipple: m = !1,
    focusRipple: h = !1,
    focusVisibleClassName: v,
    LinkComponent: y = "a",
    onBlur: w,
    onClick: x,
    onContextMenu: b,
    onDragLeave: k,
    onFocus: C,
    onFocusVisible: _,
    onKeyDown: O,
    onKeyUp: N,
    onMouseDown: R,
    onMouseLeave: j,
    onMouseUp: D,
    onTouchEnd: $,
    onTouchMove: z,
    onTouchStart: B,
    tabIndex: P = 0,
    TouchRippleProps: W,
    touchRippleRef: I,
    type: G,
    ...L
  } = n, K = M.useRef(null), q = JJ(), Z = no(q.ref, I), [V, F] = M.useState(!1);
  d && V && F(!1), M.useImperativeHandle(r, () => ({
    focusVisible: () => {
      F(!0), K.current.focus();
    }
  }), []);
  const X = q.shouldMount && !p && !d;
  M.useEffect(() => {
    V && h && !p && q.pulsate();
  }, [p, h, V, q]);
  const U = ec(q, "start", R, m), H = ec(q, "stop", b, m), Q = ec(q, "stop", k, m), re = ec(q, "stop", D, m), de = ec(q, "stop", (je) => {
    V && je.preventDefault(), j && j(je);
  }, m), le = ec(q, "start", B, m), me = ec(q, "stop", $, m), ve = ec(q, "stop", z, m), ae = ec(q, "stop", (je) => {
    K0(je.target) || F(!1), w && w(je);
  }, !1), se = Sl((je) => {
    K.current || (K.current = je.currentTarget), K0(je.target) && (F(!0), _ && _(je)), C && C(je);
  }), pe = () => {
    const je = K.current;
    return c && c !== "button" && !(je.tagName === "A" && je.href);
  }, ge = Sl((je) => {
    h && !je.repeat && V && je.key === " " && q.stop(je, () => {
      q.start(je);
    }), je.target === je.currentTarget && pe() && je.key === " " && je.preventDefault(), O && O(je), je.target === je.currentTarget && pe() && je.key === "Enter" && !d && (je.preventDefault(), x && x(je));
  }), xe = Sl((je) => {
    h && je.key === " " && V && !je.defaultPrevented && q.stop(je, () => {
      q.pulsate(je);
    }), N && N(je), x && je.target === je.currentTarget && pe() && je.key === " " && !je.defaultPrevented && x(je);
  });
  let _e = c;
  _e === "button" && (L.href || L.to) && (_e = y);
  const We = {};
  if (_e === "button") {
    const je = !!L.formAction;
    We.type = G === void 0 && !je ? "button" : G, We.disabled = d;
  } else
    !L.href && !L.to && (We.role = "button"), d && (We["aria-disabled"] = d);
  const Xe = no(t, K), et = {
    ...n,
    centerRipple: a,
    component: c,
    disabled: d,
    disableRipple: p,
    disableTouchRipple: m,
    focusRipple: h,
    tabIndex: P,
    focusVisible: V
  }, tt = yZ(et);
  return /* @__PURE__ */ E.jsxs(bZ, {
    as: _e,
    className: Ke(tt.root, l),
    ownerState: et,
    onBlur: ae,
    onClick: x,
    onContextMenu: H,
    onFocus: se,
    onKeyDown: ge,
    onKeyUp: xe,
    onMouseDown: U,
    onMouseLeave: de,
    onMouseUp: re,
    onDragLeave: Q,
    onTouchEnd: me,
    onTouchMove: ve,
    onTouchStart: le,
    ref: Xe,
    tabIndex: d ? -1 : P,
    type: G,
    ...We,
    ...L,
    children: [s, X ? /* @__PURE__ */ E.jsx(hZ, {
      ref: Z,
      center: a,
      ...W
    }) : null]
  });
});
function ec(e, t, n, r = !1) {
  return Sl((a) => (n && n(a), r || e[t](a), !0));
}
function wZ(e) {
  return _t("MuiSvgIcon", e);
}
wt("MuiSvgIcon", ["root", "colorPrimary", "colorSecondary", "colorAction", "colorError", "colorDisabled", "fontSizeInherit", "fontSizeSmall", "fontSizeMedium", "fontSizeLarge"]);
const xZ = (e) => {
  const {
    color: t,
    fontSize: n,
    classes: r
  } = e, a = {
    root: ["root", t !== "inherit" && `color${qe(t)}`, `fontSize${qe(n)}`]
  };
  return kt(a, wZ, r);
}, SZ = $e("svg", {
  name: "MuiSvgIcon",
  slot: "Root",
  overridesResolver: (e, t) => {
    const {
      ownerState: n
    } = e;
    return [t.root, n.color !== "inherit" && t[`color${qe(n.color)}`], t[`fontSize${qe(n.fontSize)}`]];
  }
})(Ct(({
  theme: e
}) => ({
  userSelect: "none",
  width: "1em",
  height: "1em",
  display: "inline-block",
  flexShrink: 0,
  transition: e.transitions?.create?.("fill", {
    duration: (e.vars ?? e).transitions?.duration?.shorter
  }),
  variants: [
    {
      props: (t) => !t.hasSvgAsChild,
      style: {
        // the <svg> will define the property that has `currentColor`
        // for example heroicons uses fill="none" and stroke="currentColor"
        fill: "currentColor"
      }
    },
    {
      props: {
        fontSize: "inherit"
      },
      style: {
        fontSize: "inherit"
      }
    },
    {
      props: {
        fontSize: "small"
      },
      style: {
        fontSize: e.typography?.pxToRem?.(20) || "1.25rem"
      }
    },
    {
      props: {
        fontSize: "medium"
      },
      style: {
        fontSize: e.typography?.pxToRem?.(24) || "1.5rem"
      }
    },
    {
      props: {
        fontSize: "large"
      },
      style: {
        fontSize: e.typography?.pxToRem?.(35) || "2.1875rem"
      }
    },
    // TODO v5 deprecate color prop, v6 remove for sx
    ...Object.entries((e.vars ?? e).palette).filter(([, t]) => t && t.main).map(([t]) => ({
      props: {
        color: t
      },
      style: {
        color: (e.vars ?? e).palette?.[t]?.main
      }
    })),
    {
      props: {
        color: "action"
      },
      style: {
        color: (e.vars ?? e).palette?.action?.active
      }
    },
    {
      props: {
        color: "disabled"
      },
      style: {
        color: (e.vars ?? e).palette?.action?.disabled
      }
    },
    {
      props: {
        color: "inherit"
      },
      style: {
        color: void 0
      }
    }
  ]
}))), e5 = /* @__PURE__ */ M.forwardRef(function(e, t) {
  const n = At({
    props: e,
    name: "MuiSvgIcon"
  }), {
    children: r,
    className: a,
    color: s = "inherit",
    component: l = "svg",
    fontSize: c = "medium",
    htmlColor: d,
    inheritViewBox: p = !1,
    titleAccess: m,
    viewBox: h = "0 0 24 24",
    ...v
  } = n, y = /* @__PURE__ */ M.isValidElement(r) && r.type === "svg", w = {
    ...n,
    color: s,
    component: l,
    fontSize: c,
    instanceFontSize: e.fontSize,
    inheritViewBox: p,
    viewBox: h,
    hasSvgAsChild: y
  }, x = {};
  p || (x.viewBox = h);
  const b = xZ(w);
  return /* @__PURE__ */ E.jsxs(SZ, {
    as: l,
    className: Ke(b.root, a),
    focusable: "false",
    color: d,
    "aria-hidden": m ? void 0 : !0,
    role: m ? "img" : void 0,
    ref: t,
    ...x,
    ...v,
    ...y && r.props,
    ownerState: w,
    children: [y ? r.props.children : r, m ? /* @__PURE__ */ E.jsx("title", {
      children: m
    }) : null]
  });
});
e5.muiName = "SvgIcon";
function xi(e, t) {
  function n(r, a) {
    return /* @__PURE__ */ E.jsx(e5, {
      "data-testid": void 0,
      ref: a,
      ...r,
      children: e
    });
  }
  return n.muiName = e5.muiName, /* @__PURE__ */ M.memo(/* @__PURE__ */ M.forwardRef(n));
}
const kZ = xi(/* @__PURE__ */ E.jsx("path", {
  d: "M20 12l-1.41-1.41L13 16.17V4h-2v12.17l-5.58-5.59L4 12l8 8 8-8z"
}));
function _Z(e) {
  return _t("MuiTableSortLabel", e);
}
const tM = wt("MuiTableSortLabel", ["root", "active", "icon", "iconDirectionDesc", "iconDirectionAsc", "directionDesc", "directionAsc"]);
function kl(e) {
  return typeof e == "string";
}
function p9(e, t, n) {
  return e === void 0 || kl(e) ? t : {
    ...t,
    ownerState: {
      ...t.ownerState,
      ...n
    }
  };
}
function m9(e, t, n) {
  return typeof e == "function" ? e(t, n) : e;
}
function qw(e, t = []) {
  if (e === void 0)
    return {};
  const n = {};
  return Object.keys(e).filter((r) => r.match(/^on[A-Z]/) && typeof e[r] == "function" && !t.includes(r)).forEach((r) => {
    n[r] = e[r];
  }), n;
}
function CP(e) {
  if (e === void 0)
    return {};
  const t = {};
  return Object.keys(e).filter((n) => !(n.match(/^on[A-Z]/) && typeof e[n] == "function")).forEach((n) => {
    t[n] = e[n];
  }), t;
}
function h9(e) {
  const {
    getSlotProps: t,
    additionalProps: n,
    externalSlotProps: r,
    externalForwardedProps: a,
    className: s
  } = e;
  if (!t) {
    const y = Ke(n?.className, s, a?.className, r?.className), w = {
      ...n?.style,
      ...a?.style,
      ...r?.style
    }, x = {
      ...n,
      ...a,
      ...r
    };
    return y.length > 0 && (x.className = y), Object.keys(w).length > 0 && (x.style = w), {
      props: x,
      internalRef: void 0
    };
  }
  const l = qw({
    ...a,
    ...r
  }), c = CP(r), d = CP(a), p = t(l), m = Ke(p?.className, n?.className, s, a?.className, r?.className), h = {
    ...p?.style,
    ...n?.style,
    ...a?.style,
    ...r?.style
  }, v = {
    ...p,
    ...n,
    ...d,
    ...c
  };
  return m.length > 0 && (v.className = m), Object.keys(h).length > 0 && (v.style = h), {
    props: v,
    internalRef: p.ref
  };
}
function Hn(e, t) {
  const {
    className: n,
    elementType: r,
    ownerState: a,
    externalForwardedProps: s,
    internalForwardedProps: l,
    shouldForwardComponentProp: c = !1,
    ...d
  } = t, {
    component: p,
    slots: m = {
      [e]: void 0
    },
    slotProps: h = {
      [e]: void 0
    },
    ...v
  } = s, y = m[e] || r, w = m9(h[e], a), {
    props: {
      component: x,
      ...b
    },
    internalRef: k
  } = h9({
    className: n,
    ...d,
    externalForwardedProps: e === "root" ? v : void 0,
    externalSlotProps: w
  }), C = no(k, w?.ref, t.ref), _ = e === "root" ? x || p : x, O = p9(y, {
    ...e === "root" && !p && !m[e] && l,
    ...e !== "root" && !m[e] && l,
    ...b,
    ..._ && !c && {
      as: _
    },
    ..._ && c && {
      component: _
    },
    ref: C
  }, a);
  return [y, O];
}
const EZ = (e) => {
  const {
    classes: t,
    direction: n,
    active: r
  } = e, a = {
    root: ["root", r && "active", `direction${qe(n)}`],
    icon: ["icon", `iconDirection${qe(n)}`]
  };
  return kt(a, _Z, t);
}, CZ = $e(nS, {
  name: "MuiTableSortLabel",
  slot: "Root",
  overridesResolver: (e, t) => {
    const {
      ownerState: n
    } = e;
    return [t.root, n.active && t.active];
  }
})(Ct(({
  theme: e
}) => ({
  cursor: "pointer",
  display: "inline-flex",
  justifyContent: "flex-start",
  flexDirection: "inherit",
  alignItems: "center",
  "&:focus": {
    color: (e.vars || e).palette.text.secondary
  },
  "&:hover": {
    color: (e.vars || e).palette.text.secondary,
    [`& .${tM.icon}`]: {
      opacity: 0.5
    }
  },
  [`&.${tM.active}`]: {
    color: (e.vars || e).palette.text.primary,
    [`& .${tM.icon}`]: {
      opacity: 1,
      color: (e.vars || e).palette.text.secondary
    }
  }
}))), OZ = $e("span", {
  name: "MuiTableSortLabel",
  slot: "Icon",
  overridesResolver: (e, t) => {
    const {
      ownerState: n
    } = e;
    return [t.icon, t[`iconDirection${qe(n.direction)}`]];
  }
})(Ct(({
  theme: e
}) => ({
  fontSize: 18,
  marginRight: 4,
  marginLeft: 4,
  opacity: 0,
  transition: e.transitions.create(["opacity", "transform"], {
    duration: e.transitions.duration.shorter
  }),
  userSelect: "none",
  variants: [{
    props: {
      direction: "desc"
    },
    style: {
      transform: "rotate(0deg)"
    }
  }, {
    props: {
      direction: "asc"
    },
    style: {
      transform: "rotate(180deg)"
    }
  }]
}))), MZ = /* @__PURE__ */ M.forwardRef(function(e, t) {
  const n = At({
    props: e,
    name: "MuiTableSortLabel"
  }), {
    active: r = !1,
    children: a,
    className: s,
    direction: l = "asc",
    hideSortIcon: c = !1,
    IconComponent: d = kZ,
    slots: p = {},
    slotProps: m = {},
    ...h
  } = n, v = {
    ...n,
    active: r,
    direction: l,
    hideSortIcon: c,
    IconComponent: d
  }, y = EZ(v), w = {
    slots: p,
    slotProps: m
  }, [x, b] = Hn("root", {
    elementType: CZ,
    externalForwardedProps: w,
    ownerState: v,
    className: Ke(y.root, s),
    ref: t
  }), [k, C] = Hn("icon", {
    elementType: OZ,
    externalForwardedProps: w,
    ownerState: v,
    className: y.icon
  });
  return /* @__PURE__ */ E.jsxs(x, {
    disableRipple: !0,
    component: "span",
    ...b,
    ...h,
    children: [a, c && !r ? null : /* @__PURE__ */ E.jsx(k, {
      as: d,
      ...C
    })]
  });
}), NZ = (e) => {
  const t = [];
  if (e === void 0)
    return {
      header: [],
      rows: []
    };
  e.data === void 0 && (e.data = []), (e.columns === void 0 || e.columns.length === 0) && (e.data.length === 0 ? e.columns = [] : e.columns = e.data[0].map((r, a) => `col${a}`)), (e.index === void 0 || e.index.length === 0) && (e.index = e.data.map((r, a) => `row${a}`));
  const n = Math.max(e.index.length, e.data.length);
  for (let r = 0; r < n; r++) {
    const a = [r < e.index.length ? e.index[r] : `row${r}`];
    for (let s = 0; s < e.columns.length; s++)
      a.push(e.data[r] ? e.data[r][s] : void 0);
    t.push(a);
  }
  return {
    header: ["index", ...e.columns],
    rows: t
  };
}, RZ = (e, t) => e === "desc" ? (n, r) => r[t] < n[t] ? -1 : r[t] > n[t] ? 1 : 0 : (n, r) => n[t] < r[t] ? -1 : n[t] > r[t] ? 1 : 0, t5 = (e, t) => {
  const n = e.map((r, a) => [
    r,
    a
  ]);
  return n.sort((r, a) => t(r[0], a[0])), n.map((r) => r[0]);
}, AZ = (e, t, n = 1e3) => {
  if (e.length <= n)
    return t5(e, t);
  const r = [];
  for (let s = 0; s < e.length; s += n)
    r.push(e.slice(s, s + n));
  const a = r.map((s) => t5(s, t));
  return jZ(a, t);
}, jZ = (e, t) => {
  if (e.length === 1) return e[0];
  const n = [], r = new Array(e.length).fill(0);
  for (; r.some((a, s) => a < e[s].length); ) {
    let a = -1, s = null;
    for (let l = 0; l < e.length; l++)
      if (r[l] < e[l].length) {
        const c = e[l][r[l]];
        (s === null || t(c, s) < 0) && (s = c, a = l);
      }
    a !== -1 && s !== null && (n.push(s), r[a]++);
  }
  return n;
}, OP = (e, t, n) => {
  const r = Math.ceil(e / n);
  return {
    currentPage: r === 0 ? 1 : Math.min(Math.max(1, t), r),
    pageSize: n,
    totalPages: r,
    totalRows: e
  };
}, PZ = (e, t, n) => {
  const r = (t - 1) * n, a = r + n;
  return e.slice(r, a);
}, DZ = (e, t, n, r, a = 5) => {
  const s = Math.max(0, Math.floor(e / n) - a), l = Math.min(
    r - 1,
    Math.ceil((e + t) / n) + a
  );
  return { startIndex: s, endIndex: l };
}, $Z = (e, t) => {
  let n;
  return (...r) => {
    clearTimeout(n), n = setTimeout(() => e(...r), t);
  };
}, g9 = ({
  tabledata: e,
  className: t = "",
  size: n = "small",
  onSortChange: r,
  enablePagination: a = void 0,
  pageSize: s = 50,
  enableVirtualScrolling: l = void 0,
  virtualScrollingHeight: c = 400,
  enableLazyLoading: d = void 0,
  onLoadMore: p
}) => {
  e || (e = {
    columns: [],
    index: [],
    data: []
  });
  const m = e.index.length;
  m > 1e4 && (d = d === void 0 ? !0 : d), m > 1e3 && (l = l === void 0 ? !0 : l), m > 2 * s && (a = a === void 0 ? !0 : a), d = d === void 0 ? !1 : d, l = l === void 0 ? !1 : l, a = a === void 0 ? !1 : a;
  const h = M.useMemo(
    () => NZ(e),
    [e]
  ), [v, y] = M.useState("asc"), [w, x] = M.useState("index"), [b, k] = M.useState(
    () => OP(h.rows.length, 1, s)
  ), [C, _] = M.useState(0), O = M.useRef(null), N = M.useMemo(() => {
    const q = h.header.indexOf(w);
    return q === -1 ? 0 : q;
  }, [h.header, w]), R = M.useMemo(
    () => $Z((q, Z) => {
      y(Z), x(q), r?.(q, Z);
    }, 150),
    [r]
  ), j = M.useCallback(
    (q) => {
      const Z = w === q && v === "asc" ? "desc" : "asc";
      h.rows.length > 1e3 ? R(q, Z) : (y(Z), x(q), r?.(q, Z));
    },
    [
      w,
      v,
      r,
      h.rows.length,
      R
    ]
  ), D = M.useMemo(
    () => RZ(v, N),
    [v, N]
  ), $ = M.useMemo(() => h.rows.length > 1e3 ? AZ(h.rows, D) : t5(h.rows, D), [h.rows, D]), z = M.useMemo(() => a ? PZ($, b.currentPage, b.pageSize) : $, [
    $,
    a,
    b.currentPage,
    b.pageSize
  ]), B = {
    itemHeight: 48,
    // Approximate row height
    overscan: 5,
    containerHeight: c
  }, P = M.useMemo(() => l ? DZ(
    C,
    B.containerHeight,
    B.itemHeight,
    z.length,
    B.overscan
  ) : { startIndex: 0, endIndex: z.length - 1 }, [
    C,
    l,
    z.length,
    B
  ]), W = M.useCallback(
    (q) => {
      l && _(q.currentTarget.scrollTop);
    },
    [l]
  ), I = M.useCallback((q) => {
    k((Z) => ({
      ...Z,
      currentPage: q
    }));
  }, []), G = M.useCallback(
    (q) => {
      if (!(!a || q.target.closest(".sortable-table-wrapper") !== q.currentTarget))
        switch (q.key) {
          case "ArrowLeft":
            b.currentPage > 1 && (q.preventDefault(), q.stopPropagation(), I(b.currentPage - 1));
            break;
          case "ArrowRight":
            b.currentPage < b.totalPages && (q.preventDefault(), q.stopPropagation(), I(b.currentPage + 1));
            break;
          case "Home":
            b.currentPage > 1 && (q.preventDefault(), q.stopPropagation(), I(1));
            break;
          case "End":
            b.currentPage < b.totalPages && (q.preventDefault(), q.stopPropagation(), I(b.totalPages));
            break;
        }
    },
    [
      a,
      b.currentPage,
      b.totalPages,
      I
    ]
  );
  M.useEffect(() => {
    a && k((q) => OP(
      $.length,
      q.currentPage,
      // Use previous current page instead of hardcoding 1
      s
    ));
  }, [$.length, a, s]), M.useEffect(() => {
    d && p && b.currentPage >= b.totalPages - 1 && p(b.currentPage + 1);
  }, [
    d,
    p,
    b.currentPage,
    b.totalPages
  ]);
  const L = () => a ? /* @__PURE__ */ E.jsxs("div", { className: "sortable-table-pagination", children: [
    /* @__PURE__ */ E.jsx(
      "button",
      {
        onClick: () => I(b.currentPage - 1),
        disabled: b.currentPage <= 1,
        className: "pagination-button",
        children: "Previous"
      }
    ),
    /* @__PURE__ */ E.jsxs("span", { className: "pagination-info", children: [
      "Page ",
      b.currentPage,
      " of ",
      b.totalPages,
      "(",
      b.totalRows,
      " total rows)"
    ] }),
    /* @__PURE__ */ E.jsx(
      "button",
      {
        onClick: () => I(b.currentPage + 1),
        disabled: b.currentPage >= b.totalPages,
        className: "pagination-button",
        children: "Next"
      }
    )
  ] }) : null, K = () => {
    const q = l ? z.slice(
      P.startIndex,
      P.endIndex + 1
    ) : z;
    return /* @__PURE__ */ E.jsxs($J, { children: [
      l && /* @__PURE__ */ E.jsx(
        HS,
        {
          style: {
            height: P.startIndex * B.itemHeight
          },
          children: /* @__PURE__ */ E.jsx(VS, { colSpan: h.header.length })
        }
      ),
      q.map((Z, V) => {
        const F = l ? P.startIndex + V : V;
        return /* @__PURE__ */ E.jsx(HS, { children: Z.map((X, U) => /* @__PURE__ */ E.jsx(
          VS,
          {
            className: U === 0 ? "sortable-table-index-cell" : "sortable-table-data-cell",
            children: X
          },
          `${e.index?.[F] || F}-${U}`
        )) }, e.index?.[F] || F);
      }),
      l && /* @__PURE__ */ E.jsx(
        HS,
        {
          style: {
            height: (z.length - P.endIndex - 1) * B.itemHeight
          },
          children: /* @__PURE__ */ E.jsx(VS, { colSpan: h.header.length })
        }
      )
    ] });
  };
  return /* @__PURE__ */ E.jsxs(
    "div",
    {
      className: "sortable-table-wrapper",
      onKeyDown: G,
      tabIndex: a ? 0 : -1,
      role: a ? "application" : void 0,
      "aria-label": a ? "Sortable table with pagination" : void 0,
      children: [
        /* @__PURE__ */ E.jsx(
          VJ,
          {
            className: `sortable-table-container ${t}`,
            ref: O,
            onScroll: W,
            style: l ? { height: c } : void 0,
            children: /* @__PURE__ */ E.jsxs(RJ, { size: n, children: [
              /* @__PURE__ */ E.jsx(KJ, { className: "sortable-table-head", children: /* @__PURE__ */ E.jsx(HS, { className: "sortable-table-header-row", children: h.header.map((q) => /* @__PURE__ */ E.jsx(
                VS,
                {
                  className: "sortable-table-header-cell",
                  "aria-label": `Sort by ${q}`,
                  children: /* @__PURE__ */ E.jsx(
                    MZ,
                    {
                      active: w === q,
                      direction: w === q ? v : "asc",
                      onClick: () => j(q),
                      className: "sortable-table-sort-label",
                      sx: {
                        "& .MuiTableSortLabel-icon": {
                          color: "inherit !important"
                        }
                      },
                      children: q
                    }
                  )
                },
                q
              )) }) }),
              K()
            ] })
          }
        ),
        L()
      ]
    }
  );
};
g9.displayName = "SortableTable";
function Ze(e, t, { checkForDefaultPrevented: n = !0 } = {}) {
  return function(r) {
    if (e?.(r), n === !1 || !r.defaultPrevented)
      return t?.(r);
  };
}
function MP(e, t) {
  if (typeof e == "function")
    return e(t);
  e != null && (e.current = t);
}
function p2(...e) {
  return (t) => {
    let n = !1;
    const r = e.map((a) => {
      const s = MP(a, t);
      return !n && typeof s == "function" && (n = !0), s;
    });
    if (n)
      return () => {
        for (let a = 0; a < r.length; a++) {
          const s = r[a];
          typeof s == "function" ? s() : MP(e[a], null);
        }
      };
  };
}
function Wn(...e) {
  return M.useCallback(p2(...e), e);
}
function TZ(e, t) {
  const n = M.createContext(t), r = (s) => {
    const { children: l, ...c } = s, d = M.useMemo(() => c, Object.values(c));
    return /* @__PURE__ */ E.jsx(n.Provider, { value: d, children: l });
  };
  r.displayName = e + "Provider";
  function a(s) {
    const l = M.useContext(n);
    if (l) return l;
    if (t !== void 0) return t;
    throw new Error(`\`${s}\` must be used within \`${e}\``);
  }
  return [r, a];
}
function jl(e, t = []) {
  let n = [];
  function r(s, l) {
    const c = M.createContext(l), d = n.length;
    n = [...n, l];
    const p = (h) => {
      const { scope: v, children: y, ...w } = h, x = v?.[e]?.[d] || c, b = M.useMemo(() => w, Object.values(w));
      return /* @__PURE__ */ E.jsx(x.Provider, { value: b, children: y });
    };
    p.displayName = s + "Provider";
    function m(h, v) {
      const y = v?.[e]?.[d] || c, w = M.useContext(y);
      if (w) return w;
      if (l !== void 0) return l;
      throw new Error(`\`${h}\` must be used within \`${s}\``);
    }
    return [p, m];
  }
  const a = () => {
    const s = n.map((l) => M.createContext(l));
    return function(l) {
      const c = l?.[e] || s;
      return M.useMemo(
        () => ({ [`__scope${e}`]: { ...l, [e]: c } }),
        [l, c]
      );
    };
  };
  return a.scopeName = e, [r, LZ(a, ...t)];
}
function LZ(...e) {
  const t = e[0];
  if (e.length === 1) return t;
  const n = () => {
    const r = e.map((a) => ({
      useScope: a(),
      scopeName: a.scopeName
    }));
    return function(a) {
      const s = r.reduce((l, { useScope: c, scopeName: d }) => {
        const p = c(a)[`__scope${d}`];
        return { ...l, ...p };
      }, {});
      return M.useMemo(() => ({ [`__scope${t.scopeName}`]: s }), [s]);
    };
  };
  return n.scopeName = t.scopeName, n;
}
var bc = globalThis?.document ? M.useLayoutEffect : () => {
}, IZ = Gx[" useId ".trim().toString()] || (() => {
}), zZ = 0;
function _l(e) {
  const [t, n] = M.useState(IZ());
  return bc(() => {
    n((r) => r ?? String(zZ++));
  }, [e]), t ? `radix-${t}` : "";
}
var FZ = Gx[" useInsertionEffect ".trim().toString()] || bc;
function gd({
  prop: e,
  defaultProp: t,
  onChange: n = () => {
  },
  caller: r
}) {
  const [a, s, l] = BZ({
    defaultProp: t,
    onChange: n
  }), c = e !== void 0, d = c ? e : a;
  {
    const m = M.useRef(e !== void 0);
    M.useEffect(() => {
      const h = m.current;
      h !== c && console.warn(
        `${r} is changing from ${h ? "controlled" : "uncontrolled"} to ${c ? "controlled" : "uncontrolled"}. Components should not switch from controlled to uncontrolled (or vice versa). Decide between using a controlled or uncontrolled value for the lifetime of the component.`
      ), m.current = c;
    }, [c, r]);
  }
  const p = M.useCallback(
    (m) => {
      if (c) {
        const h = UZ(m) ? m(e) : m;
        h !== e && l.current?.(h);
      } else
        s(m);
    },
    [c, e, s, l]
  );
  return [d, p];
}
function BZ({
  defaultProp: e,
  onChange: t
}) {
  const [n, r] = M.useState(e), a = M.useRef(n), s = M.useRef(t);
  return FZ(() => {
    s.current = t;
  }, [t]), M.useEffect(() => {
    a.current !== n && (s.current?.(n), a.current = n);
  }, [n, a]), [n, r, s];
}
function UZ(e) {
  return typeof e == "function";
}
// @__NO_SIDE_EFFECTS__
function Ah(e) {
  const t = /* @__PURE__ */ VZ(e), n = M.forwardRef((r, a) => {
    const { children: s, ...l } = r, c = M.Children.toArray(s), d = c.find(qZ);
    if (d) {
      const p = d.props.children, m = c.map((h) => h === d ? M.Children.count(p) > 1 ? M.Children.only(null) : M.isValidElement(p) ? p.props.children : null : h);
      return /* @__PURE__ */ E.jsx(t, { ...l, ref: a, children: M.isValidElement(p) ? M.cloneElement(p, void 0, m) : null });
    }
    return /* @__PURE__ */ E.jsx(t, { ...l, ref: a, children: s });
  });
  return n.displayName = `${e}.Slot`, n;
}
// @__NO_SIDE_EFFECTS__
function VZ(e) {
  const t = M.forwardRef((n, r) => {
    const { children: a, ...s } = n;
    if (M.isValidElement(a)) {
      const l = GZ(a), c = WZ(s, a.props);
      return a.type !== M.Fragment && (c.ref = r ? p2(r, l) : l), M.cloneElement(a, c);
    }
    return M.Children.count(a) > 1 ? M.Children.only(null) : null;
  });
  return t.displayName = `${e}.SlotClone`, t;
}
var HZ = /* @__PURE__ */ Symbol("radix.slottable");
function qZ(e) {
  return M.isValidElement(e) && typeof e.type == "function" && "__radixId" in e.type && e.type.__radixId === HZ;
}
function WZ(e, t) {
  const n = { ...t };
  for (const r in t) {
    const a = e[r], s = t[r];
    /^on[A-Z]/.test(r) ? a && s ? n[r] = (...l) => {
      const c = s(...l);
      return a(...l), c;
    } : a && (n[r] = a) : r === "style" ? n[r] = { ...a, ...s } : r === "className" && (n[r] = [a, s].filter(Boolean).join(" "));
  }
  return { ...e, ...n };
}
function GZ(e) {
  let t = Object.getOwnPropertyDescriptor(e.props, "ref")?.get, n = t && "isReactWarning" in t && t.isReactWarning;
  return n ? e.ref : (t = Object.getOwnPropertyDescriptor(e, "ref")?.get, n = t && "isReactWarning" in t && t.isReactWarning, n ? e.props.ref : e.props.ref || e.ref);
}
var KZ = [
  "a",
  "button",
  "div",
  "form",
  "h2",
  "h3",
  "img",
  "input",
  "label",
  "li",
  "nav",
  "ol",
  "p",
  "select",
  "span",
  "svg",
  "ul"
], Kt = KZ.reduce((e, t) => {
  const n = /* @__PURE__ */ Ah(`Primitive.${t}`), r = M.forwardRef((a, s) => {
    const { asChild: l, ...c } = a, d = l ? n : t;
    return typeof window < "u" && (window[/* @__PURE__ */ Symbol.for("radix-ui")] = !0), /* @__PURE__ */ E.jsx(d, { ...c, ref: s });
  });
  return r.displayName = `Primitive.${t}`, { ...e, [t]: r };
}, {});
function lR(e, t) {
  e && xm.flushSync(() => e.dispatchEvent(t));
}
function Ra(e) {
  const t = M.useRef(e);
  return M.useEffect(() => {
    t.current = e;
  }), M.useMemo(() => (...n) => t.current?.(...n), []);
}
function XZ(e, t = globalThis?.document) {
  const n = Ra(e);
  M.useEffect(() => {
    const r = (a) => {
      a.key === "Escape" && n(a);
    };
    return t.addEventListener("keydown", r, { capture: !0 }), () => t.removeEventListener("keydown", r, { capture: !0 });
  }, [n, t]);
}
var YZ = "DismissableLayer", n5 = "dismissableLayer.update", QZ = "dismissableLayer.pointerDownOutside", JZ = "dismissableLayer.focusOutside", NP, v9 = M.createContext({
  layers: /* @__PURE__ */ new Set(),
  layersWithOutsidePointerEventsDisabled: /* @__PURE__ */ new Set(),
  branches: /* @__PURE__ */ new Set()
}), rS = M.forwardRef(
  (e, t) => {
    const {
      disableOutsidePointerEvents: n = !1,
      onEscapeKeyDown: r,
      onPointerDownOutside: a,
      onFocusOutside: s,
      onInteractOutside: l,
      onDismiss: c,
      ...d
    } = e, p = M.useContext(v9), [m, h] = M.useState(null), v = m?.ownerDocument ?? globalThis?.document, [, y] = M.useState({}), w = Wn(t, (j) => h(j)), x = Array.from(p.layers), [b] = [...p.layersWithOutsidePointerEventsDisabled].slice(-1), k = x.indexOf(b), C = m ? x.indexOf(m) : -1, _ = p.layersWithOutsidePointerEventsDisabled.size > 0, O = C >= k, N = eee((j) => {
      const D = j.target, $ = [...p.branches].some((z) => z.contains(D));
      !O || $ || (a?.(j), l?.(j), j.defaultPrevented || c?.());
    }, v), R = tee((j) => {
      const D = j.target;
      [...p.branches].some(($) => $.contains(D)) || (s?.(j), l?.(j), j.defaultPrevented || c?.());
    }, v);
    return XZ((j) => {
      C === p.layers.size - 1 && (r?.(j), !j.defaultPrevented && c && (j.preventDefault(), c()));
    }, v), M.useEffect(() => {
      if (m)
        return n && (p.layersWithOutsidePointerEventsDisabled.size === 0 && (NP = v.body.style.pointerEvents, v.body.style.pointerEvents = "none"), p.layersWithOutsidePointerEventsDisabled.add(m)), p.layers.add(m), RP(), () => {
          n && p.layersWithOutsidePointerEventsDisabled.size === 1 && (v.body.style.pointerEvents = NP);
        };
    }, [m, v, n, p]), M.useEffect(() => () => {
      m && (p.layers.delete(m), p.layersWithOutsidePointerEventsDisabled.delete(m), RP());
    }, [m, p]), M.useEffect(() => {
      const j = () => y({});
      return document.addEventListener(n5, j), () => document.removeEventListener(n5, j);
    }, []), /* @__PURE__ */ E.jsx(
      Kt.div,
      {
        ...d,
        ref: w,
        style: {
          pointerEvents: _ ? O ? "auto" : "none" : void 0,
          ...e.style
        },
        onFocusCapture: Ze(e.onFocusCapture, R.onFocusCapture),
        onBlurCapture: Ze(e.onBlurCapture, R.onBlurCapture),
        onPointerDownCapture: Ze(
          e.onPointerDownCapture,
          N.onPointerDownCapture
        )
      }
    );
  }
);
rS.displayName = YZ;
var ZZ = "DismissableLayerBranch", y9 = M.forwardRef((e, t) => {
  const n = M.useContext(v9), r = M.useRef(null), a = Wn(t, r);
  return M.useEffect(() => {
    const s = r.current;
    if (s)
      return n.branches.add(s), () => {
        n.branches.delete(s);
      };
  }, [n.branches]), /* @__PURE__ */ E.jsx(Kt.div, { ...e, ref: a });
});
y9.displayName = ZZ;
function eee(e, t = globalThis?.document) {
  const n = Ra(e), r = M.useRef(!1), a = M.useRef(() => {
  });
  return M.useEffect(() => {
    const s = (c) => {
      if (c.target && !r.current) {
        let d = function() {
          b9(
            QZ,
            n,
            p,
            { discrete: !0 }
          );
        };
        const p = { originalEvent: c };
        c.pointerType === "touch" ? (t.removeEventListener("click", a.current), a.current = d, t.addEventListener("click", a.current, { once: !0 })) : d();
      } else
        t.removeEventListener("click", a.current);
      r.current = !1;
    }, l = window.setTimeout(() => {
      t.addEventListener("pointerdown", s);
    }, 0);
    return () => {
      window.clearTimeout(l), t.removeEventListener("pointerdown", s), t.removeEventListener("click", a.current);
    };
  }, [t, n]), {
    // ensures we check React component tree (not just DOM tree)
    onPointerDownCapture: () => r.current = !0
  };
}
function tee(e, t = globalThis?.document) {
  const n = Ra(e), r = M.useRef(!1);
  return M.useEffect(() => {
    const a = (s) => {
      s.target && !r.current && b9(JZ, n, { originalEvent: s }, {
        discrete: !1
      });
    };
    return t.addEventListener("focusin", a), () => t.removeEventListener("focusin", a);
  }, [t, n]), {
    onFocusCapture: () => r.current = !0,
    onBlurCapture: () => r.current = !1
  };
}
function RP() {
  const e = new CustomEvent(n5);
  document.dispatchEvent(e);
}
function b9(e, t, n, { discrete: r }) {
  const a = n.originalEvent.target, s = new CustomEvent(e, { bubbles: !1, cancelable: !0, detail: n });
  t && a.addEventListener(e, t, { once: !0 }), r ? lR(a, s) : a.dispatchEvent(s);
}
var nee = rS, ree = y9, nM = "focusScope.autoFocusOnMount", rM = "focusScope.autoFocusOnUnmount", AP = { bubbles: !1, cancelable: !0 }, oee = "FocusScope", m2 = M.forwardRef((e, t) => {
  const {
    loop: n = !1,
    trapped: r = !1,
    onMountAutoFocus: a,
    onUnmountAutoFocus: s,
    ...l
  } = e, [c, d] = M.useState(null), p = Ra(a), m = Ra(s), h = M.useRef(null), v = Wn(t, (x) => d(x)), y = M.useRef({
    paused: !1,
    pause() {
      this.paused = !0;
    },
    resume() {
      this.paused = !1;
    }
  }).current;
  M.useEffect(() => {
    if (r) {
      let x = function(_) {
        if (y.paused || !c) return;
        const O = _.target;
        c.contains(O) ? h.current = O : Vc(h.current, { select: !0 });
      }, b = function(_) {
        if (y.paused || !c) return;
        const O = _.relatedTarget;
        O !== null && (c.contains(O) || Vc(h.current, { select: !0 }));
      }, k = function(_) {
        if (document.activeElement === document.body)
          for (const O of _)
            O.removedNodes.length > 0 && Vc(c);
      };
      document.addEventListener("focusin", x), document.addEventListener("focusout", b);
      const C = new MutationObserver(k);
      return c && C.observe(c, { childList: !0, subtree: !0 }), () => {
        document.removeEventListener("focusin", x), document.removeEventListener("focusout", b), C.disconnect();
      };
    }
  }, [r, c, y.paused]), M.useEffect(() => {
    if (c) {
      PP.add(y);
      const x = document.activeElement;
      if (!c.contains(x)) {
        const b = new CustomEvent(nM, AP);
        c.addEventListener(nM, p), c.dispatchEvent(b), b.defaultPrevented || (aee(cee(w9(c)), { select: !0 }), document.activeElement === x && Vc(c));
      }
      return () => {
        c.removeEventListener(nM, p), setTimeout(() => {
          const b = new CustomEvent(rM, AP);
          c.addEventListener(rM, m), c.dispatchEvent(b), b.defaultPrevented || Vc(x ?? document.body, { select: !0 }), c.removeEventListener(rM, m), PP.remove(y);
        }, 0);
      };
    }
  }, [c, p, m, y]);
  const w = M.useCallback(
    (x) => {
      if (!n && !r || y.paused) return;
      const b = x.key === "Tab" && !x.altKey && !x.ctrlKey && !x.metaKey, k = document.activeElement;
      if (b && k) {
        const C = x.currentTarget, [_, O] = iee(C);
        _ && O ? !x.shiftKey && k === O ? (x.preventDefault(), n && Vc(_, { select: !0 })) : x.shiftKey && k === _ && (x.preventDefault(), n && Vc(O, { select: !0 })) : k === C && x.preventDefault();
      }
    },
    [n, r, y.paused]
  );
  return /* @__PURE__ */ E.jsx(Kt.div, { tabIndex: -1, ...l, ref: v, onKeyDown: w });
});
m2.displayName = oee;
function aee(e, { select: t = !1 } = {}) {
  const n = document.activeElement;
  for (const r of e)
    if (Vc(r, { select: t }), document.activeElement !== n) return;
}
function iee(e) {
  const t = w9(e), n = jP(t, e), r = jP(t.reverse(), e);
  return [n, r];
}
function w9(e) {
  const t = [], n = document.createTreeWalker(e, NodeFilter.SHOW_ELEMENT, {
    acceptNode: (r) => {
      const a = r.tagName === "INPUT" && r.type === "hidden";
      return r.disabled || r.hidden || a ? NodeFilter.FILTER_SKIP : r.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
    }
  });
  for (; n.nextNode(); ) t.push(n.currentNode);
  return t;
}
function jP(e, t) {
  for (const n of e)
    if (!see(n, { upTo: t })) return n;
}
function see(e, { upTo: t }) {
  if (getComputedStyle(e).visibility === "hidden") return !0;
  for (; e; ) {
    if (t !== void 0 && e === t) return !1;
    if (getComputedStyle(e).display === "none") return !0;
    e = e.parentElement;
  }
  return !1;
}
function lee(e) {
  return e instanceof HTMLInputElement && "select" in e;
}
function Vc(e, { select: t = !1 } = {}) {
  if (e && e.focus) {
    const n = document.activeElement;
    e.focus({ preventScroll: !0 }), e !== n && lee(e) && t && e.select();
  }
}
var PP = uee();
function uee() {
  let e = [];
  return {
    add(t) {
      const n = e[0];
      t !== n && n?.pause(), e = DP(e, t), e.unshift(t);
    },
    remove(t) {
      e = DP(e, t), e[0]?.resume();
    }
  };
}
function DP(e, t) {
  const n = [...e], r = n.indexOf(t);
  return r !== -1 && n.splice(r, 1), n;
}
function cee(e) {
  return e.filter((t) => t.tagName !== "A");
}
var dee = "Portal", h2 = M.forwardRef((e, t) => {
  const { container: n, ...r } = e, [a, s] = M.useState(!1);
  bc(() => s(!0), []);
  const l = n || a && globalThis?.document?.body;
  return l ? uh.createPortal(/* @__PURE__ */ E.jsx(Kt.div, { ...r, ref: t }), l) : null;
});
h2.displayName = dee;
function fee(e, t) {
  return M.useReducer((n, r) => t[n][r] ?? n, e);
}
var Hs = (e) => {
  const { present: t, children: n } = e, r = pee(t), a = typeof n == "function" ? n({ present: r.isPresent }) : M.Children.only(n), s = Wn(r.ref, mee(a));
  return typeof n == "function" || r.isPresent ? M.cloneElement(a, { ref: s }) : null;
};
Hs.displayName = "Presence";
function pee(e) {
  const [t, n] = M.useState(), r = M.useRef(null), a = M.useRef(e), s = M.useRef("none"), l = e ? "mounted" : "unmounted", [c, d] = fee(l, {
    mounted: {
      UNMOUNT: "unmounted",
      ANIMATION_OUT: "unmountSuspended"
    },
    unmountSuspended: {
      MOUNT: "mounted",
      ANIMATION_END: "unmounted"
    },
    unmounted: {
      MOUNT: "mounted"
    }
  });
  return M.useEffect(() => {
    const p = qS(r.current);
    s.current = c === "mounted" ? p : "none";
  }, [c]), bc(() => {
    const p = r.current, m = a.current;
    if (m !== e) {
      const h = s.current, v = qS(p);
      e ? d("MOUNT") : v === "none" || p?.display === "none" ? d("UNMOUNT") : d(m && h !== v ? "ANIMATION_OUT" : "UNMOUNT"), a.current = e;
    }
  }, [e, d]), bc(() => {
    if (t) {
      let p;
      const m = t.ownerDocument.defaultView ?? window, h = (y) => {
        const w = qS(r.current).includes(CSS.escape(y.animationName));
        if (y.target === t && w && (d("ANIMATION_END"), !a.current)) {
          const x = t.style.animationFillMode;
          t.style.animationFillMode = "forwards", p = m.setTimeout(() => {
            t.style.animationFillMode === "forwards" && (t.style.animationFillMode = x);
          });
        }
      }, v = (y) => {
        y.target === t && (s.current = qS(r.current));
      };
      return t.addEventListener("animationstart", v), t.addEventListener("animationcancel", h), t.addEventListener("animationend", h), () => {
        m.clearTimeout(p), t.removeEventListener("animationstart", v), t.removeEventListener("animationcancel", h), t.removeEventListener("animationend", h);
      };
    } else
      d("ANIMATION_END");
  }, [t, d]), {
    isPresent: ["mounted", "unmountSuspended"].includes(c),
    ref: M.useCallback((p) => {
      r.current = p ? getComputedStyle(p) : null, n(p);
    }, [])
  };
}
function qS(e) {
  return e?.animationName || "none";
}
function mee(e) {
  let t = Object.getOwnPropertyDescriptor(e.props, "ref")?.get, n = t && "isReactWarning" in t && t.isReactWarning;
  return n ? e.ref : (t = Object.getOwnPropertyDescriptor(e, "ref")?.get, n = t && "isReactWarning" in t && t.isReactWarning, n ? e.props.ref : e.props.ref || e.ref);
}
var oM = 0;
function uR() {
  M.useEffect(() => {
    const e = document.querySelectorAll("[data-radix-focus-guard]");
    return document.body.insertAdjacentElement("afterbegin", e[0] ?? $P()), document.body.insertAdjacentElement("beforeend", e[1] ?? $P()), oM++, () => {
      oM === 1 && document.querySelectorAll("[data-radix-focus-guard]").forEach((t) => t.remove()), oM--;
    };
  }, []);
}
function $P() {
  const e = document.createElement("span");
  return e.setAttribute("data-radix-focus-guard", ""), e.tabIndex = 0, e.style.outline = "none", e.style.opacity = "0", e.style.position = "fixed", e.style.pointerEvents = "none", e;
}
var dl = function() {
  return dl = Object.assign || function(e) {
    for (var t, n = 1, r = arguments.length; n < r; n++) {
      t = arguments[n];
      for (var a in t) Object.prototype.hasOwnProperty.call(t, a) && (e[a] = t[a]);
    }
    return e;
  }, dl.apply(this, arguments);
};
function x9(e, t) {
  var n = {};
  for (var r in e) Object.prototype.hasOwnProperty.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function")
    for (var a = 0, r = Object.getOwnPropertySymbols(e); a < r.length; a++)
      t.indexOf(r[a]) < 0 && Object.prototype.propertyIsEnumerable.call(e, r[a]) && (n[r[a]] = e[r[a]]);
  return n;
}
function w0(e, t, n) {
  if (n || arguments.length === 2) for (var r = 0, a = t.length, s; r < a; r++)
    (s || !(r in t)) && (s || (s = Array.prototype.slice.call(t, 0, r)), s[r] = t[r]);
  return e.concat(s || Array.prototype.slice.call(t));
}
var x0 = "right-scroll-bar-position", S0 = "width-before-scroll-bar", hee = "with-scroll-bars-hidden", gee = "--removed-body-scroll-bar-size";
function aM(e, t) {
  return typeof e == "function" ? e(t) : e && (e.current = t), e;
}
function vee(e, t) {
  var n = M.useState(function() {
    return {
      // value
      value: e,
      // last callback
      callback: t,
      // "memoized" public interface
      facade: {
        get current() {
          return n.value;
        },
        set current(r) {
          var a = n.value;
          a !== r && (n.value = r, n.callback(r, a));
        }
      }
    };
  })[0];
  return n.callback = t, n.facade;
}
var yee = typeof window < "u" ? M.useLayoutEffect : M.useEffect, TP = /* @__PURE__ */ new WeakMap();
function bee(e, t) {
  var n = vee(null, function(r) {
    return e.forEach(function(a) {
      return aM(a, r);
    });
  });
  return yee(function() {
    var r = TP.get(n);
    if (r) {
      var a = new Set(r), s = new Set(e), l = n.current;
      a.forEach(function(c) {
        s.has(c) || aM(c, null);
      }), s.forEach(function(c) {
        a.has(c) || aM(c, l);
      });
    }
    TP.set(n, e);
  }, [e]), n;
}
function wee(e) {
  return e;
}
function xee(e, t) {
  t === void 0 && (t = wee);
  var n = [], r = !1, a = {
    read: function() {
      if (r)
        throw new Error("Sidecar: could not `read` from an `assigned` medium. `read` could be used only with `useMedium`.");
      return n.length ? n[n.length - 1] : e;
    },
    useMedium: function(s) {
      var l = t(s, r);
      return n.push(l), function() {
        n = n.filter(function(c) {
          return c !== l;
        });
      };
    },
    assignSyncMedium: function(s) {
      for (r = !0; n.length; ) {
        var l = n;
        n = [], l.forEach(s);
      }
      n = {
        push: function(c) {
          return s(c);
        },
        filter: function() {
          return n;
        }
      };
    },
    assignMedium: function(s) {
      r = !0;
      var l = [];
      if (n.length) {
        var c = n;
        n = [], c.forEach(s), l = n;
      }
      var d = function() {
        var m = l;
        l = [], m.forEach(s);
      }, p = function() {
        return Promise.resolve().then(d);
      };
      p(), n = {
        push: function(m) {
          l.push(m), p();
        },
        filter: function(m) {
          return l = l.filter(m), n;
        }
      };
    }
  };
  return a;
}
function See(e) {
  e === void 0 && (e = {});
  var t = xee(null);
  return t.options = dl({ async: !0, ssr: !1 }, e), t;
}
var S9 = function(e) {
  var t = e.sideCar, n = x9(e, ["sideCar"]);
  if (!t)
    throw new Error("Sidecar: please provide `sideCar` property to import the right car");
  var r = t.read();
  if (!r)
    throw new Error("Sidecar medium not found");
  return M.createElement(r, dl({}, n));
};
S9.isSideCarExport = !0;
function kee(e, t) {
  return e.useMedium(t), S9;
}
var k9 = See(), iM = function() {
}, g2 = M.forwardRef(function(e, t) {
  var n = M.useRef(null), r = M.useState({
    onScrollCapture: iM,
    onWheelCapture: iM,
    onTouchMoveCapture: iM
  }), a = r[0], s = r[1], l = e.forwardProps, c = e.children, d = e.className, p = e.removeScrollBar, m = e.enabled, h = e.shards, v = e.sideCar, y = e.noRelative, w = e.noIsolation, x = e.inert, b = e.allowPinchZoom, k = e.as, C = k === void 0 ? "div" : k, _ = e.gapMode, O = x9(e, ["forwardProps", "children", "className", "removeScrollBar", "enabled", "shards", "sideCar", "noRelative", "noIsolation", "inert", "allowPinchZoom", "as", "gapMode"]), N = v, R = bee([n, t]), j = dl(dl({}, O), a);
  return M.createElement(
    M.Fragment,
    null,
    m && M.createElement(N, { sideCar: k9, removeScrollBar: p, shards: h, noRelative: y, noIsolation: w, inert: x, setCallbacks: s, allowPinchZoom: !!b, lockRef: n, gapMode: _ }),
    l ? M.cloneElement(M.Children.only(c), dl(dl({}, j), { ref: R })) : M.createElement(C, dl({}, j, { className: d, ref: R }), c)
  );
});
g2.defaultProps = {
  enabled: !0,
  removeScrollBar: !0,
  inert: !1
};
g2.classNames = {
  fullWidth: S0,
  zeroRight: x0
};
var _ee = function() {
  if (typeof __webpack_nonce__ < "u")
    return __webpack_nonce__;
};
function Eee() {
  if (!document)
    return null;
  var e = document.createElement("style");
  e.type = "text/css";
  var t = _ee();
  return t && e.setAttribute("nonce", t), e;
}
function Cee(e, t) {
  e.styleSheet ? e.styleSheet.cssText = t : e.appendChild(document.createTextNode(t));
}
function Oee(e) {
  var t = document.head || document.getElementsByTagName("head")[0];
  t.appendChild(e);
}
var Mee = function() {
  var e = 0, t = null;
  return {
    add: function(n) {
      e == 0 && (t = Eee()) && (Cee(t, n), Oee(t)), e++;
    },
    remove: function() {
      e--, !e && t && (t.parentNode && t.parentNode.removeChild(t), t = null);
    }
  };
}, Nee = function() {
  var e = Mee();
  return function(t, n) {
    M.useEffect(function() {
      return e.add(t), function() {
        e.remove();
      };
    }, [t && n]);
  };
}, _9 = function() {
  var e = Nee(), t = function(n) {
    var r = n.styles, a = n.dynamic;
    return e(r, a), null;
  };
  return t;
}, Ree = {
  left: 0,
  top: 0,
  right: 0,
  gap: 0
}, sM = function(e) {
  return parseInt(e || "", 10) || 0;
}, Aee = function(e) {
  var t = window.getComputedStyle(document.body), n = t[e === "padding" ? "paddingLeft" : "marginLeft"], r = t[e === "padding" ? "paddingTop" : "marginTop"], a = t[e === "padding" ? "paddingRight" : "marginRight"];
  return [sM(n), sM(r), sM(a)];
}, jee = function(e) {
  if (e === void 0 && (e = "margin"), typeof window > "u")
    return Ree;
  var t = Aee(e), n = document.documentElement.clientWidth, r = window.innerWidth;
  return {
    left: t[0],
    top: t[1],
    right: t[2],
    gap: Math.max(0, r - n + t[2] - t[0])
  };
}, Pee = _9(), wh = "data-scroll-locked", Dee = function(e, t, n, r) {
  var a = e.left, s = e.top, l = e.right, c = e.gap;
  return n === void 0 && (n = "margin"), `
  .`.concat(hee, ` {
   overflow: hidden `).concat(r, `;
   padding-right: `).concat(c, "px ").concat(r, `;
  }
  body[`).concat(wh, `] {
    overflow: hidden `).concat(r, `;
    overscroll-behavior: contain;
    `).concat([
    t && "position: relative ".concat(r, ";"),
    n === "margin" && `
    padding-left: `.concat(a, `px;
    padding-top: `).concat(s, `px;
    padding-right: `).concat(l, `px;
    margin-left:0;
    margin-top:0;
    margin-right: `).concat(c, "px ").concat(r, `;
    `),
    n === "padding" && "padding-right: ".concat(c, "px ").concat(r, ";")
  ].filter(Boolean).join(""), `
  }

  .`).concat(x0, ` {
    right: `).concat(c, "px ").concat(r, `;
  }

  .`).concat(S0, ` {
    margin-right: `).concat(c, "px ").concat(r, `;
  }

  .`).concat(x0, " .").concat(x0, ` {
    right: 0 `).concat(r, `;
  }

  .`).concat(S0, " .").concat(S0, ` {
    margin-right: 0 `).concat(r, `;
  }

  body[`).concat(wh, `] {
    `).concat(gee, ": ").concat(c, `px;
  }
`);
}, LP = function() {
  var e = parseInt(document.body.getAttribute(wh) || "0", 10);
  return isFinite(e) ? e : 0;
}, $ee = function() {
  M.useEffect(function() {
    return document.body.setAttribute(wh, (LP() + 1).toString()), function() {
      var e = LP() - 1;
      e <= 0 ? document.body.removeAttribute(wh) : document.body.setAttribute(wh, e.toString());
    };
  }, []);
}, Tee = function(e) {
  var t = e.noRelative, n = e.noImportant, r = e.gapMode, a = r === void 0 ? "margin" : r;
  $ee();
  var s = M.useMemo(function() {
    return jee(a);
  }, [a]);
  return M.createElement(Pee, { styles: Dee(s, !t, a, n ? "" : "!important") });
}, r5 = !1;
if (typeof window < "u")
  try {
    var WS = Object.defineProperty({}, "passive", {
      get: function() {
        return r5 = !0, !0;
      }
    });
    window.addEventListener("test", WS, WS), window.removeEventListener("test", WS, WS);
  } catch {
    r5 = !1;
  }
var Vm = r5 ? { passive: !1 } : !1, Lee = function(e) {
  return e.tagName === "TEXTAREA";
}, E9 = function(e, t) {
  if (!(e instanceof Element))
    return !1;
  var n = window.getComputedStyle(e);
  return (
    // not-not-scrollable
    n[t] !== "hidden" && // contains scroll inside self
    !(n.overflowY === n.overflowX && !Lee(e) && n[t] === "visible")
  );
}, Iee = function(e) {
  return E9(e, "overflowY");
}, zee = function(e) {
  return E9(e, "overflowX");
}, IP = function(e, t) {
  var n = t.ownerDocument, r = t;
  do {
    typeof ShadowRoot < "u" && r instanceof ShadowRoot && (r = r.host);
    var a = C9(e, r);
    if (a) {
      var s = O9(e, r), l = s[1], c = s[2];
      if (l > c)
        return !0;
    }
    r = r.parentNode;
  } while (r && r !== n.body);
  return !1;
}, Fee = function(e) {
  var t = e.scrollTop, n = e.scrollHeight, r = e.clientHeight;
  return [
    t,
    n,
    r
  ];
}, Bee = function(e) {
  var t = e.scrollLeft, n = e.scrollWidth, r = e.clientWidth;
  return [
    t,
    n,
    r
  ];
}, C9 = function(e, t) {
  return e === "v" ? Iee(t) : zee(t);
}, O9 = function(e, t) {
  return e === "v" ? Fee(t) : Bee(t);
}, Uee = function(e, t) {
  return e === "h" && t === "rtl" ? -1 : 1;
}, Vee = function(e, t, n, r, a) {
  var s = Uee(e, window.getComputedStyle(t).direction), l = s * r, c = n.target, d = t.contains(c), p = !1, m = l > 0, h = 0, v = 0;
  do {
    if (!c)
      break;
    var y = O9(e, c), w = y[0], x = y[1], b = y[2], k = x - b - s * w;
    (w || k) && C9(e, c) && (h += k, v += w);
    var C = c.parentNode;
    c = C && C.nodeType === Node.DOCUMENT_FRAGMENT_NODE ? C.host : C;
  } while (
    // portaled content
    !d && c !== document.body || // self content
    d && (t.contains(c) || t === c)
  );
  return (m && Math.abs(h) < 1 || !m && Math.abs(v) < 1) && (p = !0), p;
}, GS = function(e) {
  return "changedTouches" in e ? [e.changedTouches[0].clientX, e.changedTouches[0].clientY] : [0, 0];
}, zP = function(e) {
  return [e.deltaX, e.deltaY];
}, FP = function(e) {
  return e && "current" in e ? e.current : e;
}, Hee = function(e, t) {
  return e[0] === t[0] && e[1] === t[1];
}, qee = function(e) {
  return `
  .block-interactivity-`.concat(e, ` {pointer-events: none;}
  .allow-interactivity-`).concat(e, ` {pointer-events: all;}
`);
}, Wee = 0, Hm = [];
function Gee(e) {
  var t = M.useRef([]), n = M.useRef([0, 0]), r = M.useRef(), a = M.useState(Wee++)[0], s = M.useState(_9)[0], l = M.useRef(e);
  M.useEffect(function() {
    l.current = e;
  }, [e]), M.useEffect(function() {
    if (e.inert) {
      document.body.classList.add("block-interactivity-".concat(a));
      var x = w0([e.lockRef.current], (e.shards || []).map(FP), !0).filter(Boolean);
      return x.forEach(function(b) {
        return b.classList.add("allow-interactivity-".concat(a));
      }), function() {
        document.body.classList.remove("block-interactivity-".concat(a)), x.forEach(function(b) {
          return b.classList.remove("allow-interactivity-".concat(a));
        });
      };
    }
  }, [e.inert, e.lockRef.current, e.shards]);
  var c = M.useCallback(function(x, b) {
    if ("touches" in x && x.touches.length === 2 || x.type === "wheel" && x.ctrlKey)
      return !l.current.allowPinchZoom;
    var k = GS(x), C = n.current, _ = "deltaX" in x ? x.deltaX : C[0] - k[0], O = "deltaY" in x ? x.deltaY : C[1] - k[1], N, R = x.target, j = Math.abs(_) > Math.abs(O) ? "h" : "v";
    if ("touches" in x && j === "h" && R.type === "range")
      return !1;
    var D = IP(j, R);
    if (!D)
      return !0;
    if (D ? N = j : (N = j === "v" ? "h" : "v", D = IP(j, R)), !D)
      return !1;
    if (!r.current && "changedTouches" in x && (_ || O) && (r.current = N), !N)
      return !0;
    var $ = r.current || N;
    return Vee($, b, x, $ === "h" ? _ : O);
  }, []), d = M.useCallback(function(x) {
    var b = x;
    if (!(!Hm.length || Hm[Hm.length - 1] !== s)) {
      var k = "deltaY" in b ? zP(b) : GS(b), C = t.current.filter(function(N) {
        return N.name === b.type && (N.target === b.target || b.target === N.shadowParent) && Hee(N.delta, k);
      })[0];
      if (C && C.should) {
        b.cancelable && b.preventDefault();
        return;
      }
      if (!C) {
        var _ = (l.current.shards || []).map(FP).filter(Boolean).filter(function(N) {
          return N.contains(b.target);
        }), O = _.length > 0 ? c(b, _[0]) : !l.current.noIsolation;
        O && b.cancelable && b.preventDefault();
      }
    }
  }, []), p = M.useCallback(function(x, b, k, C) {
    var _ = { name: x, delta: b, target: k, should: C, shadowParent: Kee(k) };
    t.current.push(_), setTimeout(function() {
      t.current = t.current.filter(function(O) {
        return O !== _;
      });
    }, 1);
  }, []), m = M.useCallback(function(x) {
    n.current = GS(x), r.current = void 0;
  }, []), h = M.useCallback(function(x) {
    p(x.type, zP(x), x.target, c(x, e.lockRef.current));
  }, []), v = M.useCallback(function(x) {
    p(x.type, GS(x), x.target, c(x, e.lockRef.current));
  }, []);
  M.useEffect(function() {
    return Hm.push(s), e.setCallbacks({
      onScrollCapture: h,
      onWheelCapture: h,
      onTouchMoveCapture: v
    }), document.addEventListener("wheel", d, Vm), document.addEventListener("touchmove", d, Vm), document.addEventListener("touchstart", m, Vm), function() {
      Hm = Hm.filter(function(x) {
        return x !== s;
      }), document.removeEventListener("wheel", d, Vm), document.removeEventListener("touchmove", d, Vm), document.removeEventListener("touchstart", m, Vm);
    };
  }, []);
  var y = e.removeScrollBar, w = e.inert;
  return M.createElement(
    M.Fragment,
    null,
    w ? M.createElement(s, { styles: qee(a) }) : null,
    y ? M.createElement(Tee, { noRelative: e.noRelative, gapMode: e.gapMode }) : null
  );
}
function Kee(e) {
  for (var t = null; e !== null; )
    e instanceof ShadowRoot && (t = e.host, e = e.host), e = e.parentNode;
  return t;
}
const Xee = kee(k9, Gee);
var v2 = M.forwardRef(function(e, t) {
  return M.createElement(g2, dl({}, e, { ref: t, sideCar: Xee }));
});
v2.classNames = g2.classNames;
var Yee = function(e) {
  if (typeof document > "u")
    return null;
  var t = Array.isArray(e) ? e[0] : e;
  return t.ownerDocument.body;
}, qm = /* @__PURE__ */ new WeakMap(), KS = /* @__PURE__ */ new WeakMap(), XS = {}, lM = 0, M9 = function(e) {
  return e && (e.host || M9(e.parentNode));
}, Qee = function(e, t) {
  return t.map(function(n) {
    if (e.contains(n))
      return n;
    var r = M9(n);
    return r && e.contains(r) ? r : (console.error("aria-hidden", n, "in not contained inside", e, ". Doing nothing"), null);
  }).filter(function(n) {
    return !!n;
  });
}, Jee = function(e, t, n, r) {
  var a = Qee(t, Array.isArray(e) ? e : [e]);
  XS[n] || (XS[n] = /* @__PURE__ */ new WeakMap());
  var s = XS[n], l = [], c = /* @__PURE__ */ new Set(), d = new Set(a), p = function(h) {
    !h || c.has(h) || (c.add(h), p(h.parentNode));
  };
  a.forEach(p);
  var m = function(h) {
    !h || d.has(h) || Array.prototype.forEach.call(h.children, function(v) {
      if (c.has(v))
        m(v);
      else
        try {
          var y = v.getAttribute(r), w = y !== null && y !== "false", x = (qm.get(v) || 0) + 1, b = (s.get(v) || 0) + 1;
          qm.set(v, x), s.set(v, b), l.push(v), x === 1 && w && KS.set(v, !0), b === 1 && v.setAttribute(n, "true"), w || v.setAttribute(r, "true");
        } catch (k) {
          console.error("aria-hidden: cannot operate on ", v, k);
        }
    });
  };
  return m(t), c.clear(), lM++, function() {
    l.forEach(function(h) {
      var v = qm.get(h) - 1, y = s.get(h) - 1;
      qm.set(h, v), s.set(h, y), v || (KS.has(h) || h.removeAttribute(r), KS.delete(h)), y || h.removeAttribute(n);
    }), lM--, lM || (qm = /* @__PURE__ */ new WeakMap(), qm = /* @__PURE__ */ new WeakMap(), KS = /* @__PURE__ */ new WeakMap(), XS = {});
  };
}, cR = function(e, t, n) {
  n === void 0 && (n = "data-aria-hidden");
  var r = Array.from(Array.isArray(e) ? e : [e]), a = Yee(e);
  return a ? (r.push.apply(r, Array.from(a.querySelectorAll("[aria-live], script"))), Jee(r, a, n, "aria-hidden")) : function() {
    return null;
  };
}, y2 = "Dialog", [N9] = jl(y2), [Zee, qs] = N9(y2), R9 = (e) => {
  const {
    __scopeDialog: t,
    children: n,
    open: r,
    defaultOpen: a,
    onOpenChange: s,
    modal: l = !0
  } = e, c = M.useRef(null), d = M.useRef(null), [p, m] = gd({
    prop: r,
    defaultProp: a ?? !1,
    onChange: s,
    caller: y2
  });
  return /* @__PURE__ */ E.jsx(
    Zee,
    {
      scope: t,
      triggerRef: c,
      contentRef: d,
      contentId: _l(),
      titleId: _l(),
      descriptionId: _l(),
      open: p,
      onOpenChange: m,
      onOpenToggle: M.useCallback(() => m((h) => !h), [m]),
      modal: l,
      children: n
    }
  );
};
R9.displayName = y2;
var A9 = "DialogTrigger", j9 = M.forwardRef(
  (e, t) => {
    const { __scopeDialog: n, ...r } = e, a = qs(A9, n), s = Wn(t, a.triggerRef);
    return /* @__PURE__ */ E.jsx(
      Kt.button,
      {
        type: "button",
        "aria-haspopup": "dialog",
        "aria-expanded": a.open,
        "aria-controls": a.contentId,
        "data-state": pR(a.open),
        ...r,
        ref: s,
        onClick: Ze(e.onClick, a.onOpenToggle)
      }
    );
  }
);
j9.displayName = A9;
var dR = "DialogPortal", [ete, P9] = N9(dR, {
  forceMount: void 0
}), D9 = (e) => {
  const { __scopeDialog: t, forceMount: n, children: r, container: a } = e, s = qs(dR, t);
  return /* @__PURE__ */ E.jsx(ete, { scope: t, forceMount: n, children: M.Children.map(r, (l) => /* @__PURE__ */ E.jsx(Hs, { present: n || s.open, children: /* @__PURE__ */ E.jsx(h2, { asChild: !0, container: a, children: l }) })) });
};
D9.displayName = dR;
var J0 = "DialogOverlay", $9 = M.forwardRef(
  (e, t) => {
    const n = P9(J0, e.__scopeDialog), { forceMount: r = n.forceMount, ...a } = e, s = qs(J0, e.__scopeDialog);
    return s.modal ? /* @__PURE__ */ E.jsx(Hs, { present: r || s.open, children: /* @__PURE__ */ E.jsx(nte, { ...a, ref: t }) }) : null;
  }
);
$9.displayName = J0;
var tte = /* @__PURE__ */ Ah("DialogOverlay.RemoveScroll"), nte = M.forwardRef(
  (e, t) => {
    const { __scopeDialog: n, ...r } = e, a = qs(J0, n);
    return (
      // Make sure `Content` is scrollable even when it doesn't live inside `RemoveScroll`
      // ie. when `Overlay` and `Content` are siblings
      /* @__PURE__ */ E.jsx(v2, { as: tte, allowPinchZoom: !0, shards: [a.contentRef], children: /* @__PURE__ */ E.jsx(
        Kt.div,
        {
          "data-state": pR(a.open),
          ...r,
          ref: t,
          style: { pointerEvents: "auto", ...r.style }
        }
      ) })
    );
  }
), im = "DialogContent", T9 = M.forwardRef(
  (e, t) => {
    const n = P9(im, e.__scopeDialog), { forceMount: r = n.forceMount, ...a } = e, s = qs(im, e.__scopeDialog);
    return /* @__PURE__ */ E.jsx(Hs, { present: r || s.open, children: s.modal ? /* @__PURE__ */ E.jsx(rte, { ...a, ref: t }) : /* @__PURE__ */ E.jsx(ote, { ...a, ref: t }) });
  }
);
T9.displayName = im;
var rte = M.forwardRef(
  (e, t) => {
    const n = qs(im, e.__scopeDialog), r = M.useRef(null), a = Wn(t, n.contentRef, r);
    return M.useEffect(() => {
      const s = r.current;
      if (s) return cR(s);
    }, []), /* @__PURE__ */ E.jsx(
      L9,
      {
        ...e,
        ref: a,
        trapFocus: n.open,
        disableOutsidePointerEvents: !0,
        onCloseAutoFocus: Ze(e.onCloseAutoFocus, (s) => {
          s.preventDefault(), n.triggerRef.current?.focus();
        }),
        onPointerDownOutside: Ze(e.onPointerDownOutside, (s) => {
          const l = s.detail.originalEvent, c = l.button === 0 && l.ctrlKey === !0;
          (l.button === 2 || c) && s.preventDefault();
        }),
        onFocusOutside: Ze(
          e.onFocusOutside,
          (s) => s.preventDefault()
        )
      }
    );
  }
), ote = M.forwardRef(
  (e, t) => {
    const n = qs(im, e.__scopeDialog), r = M.useRef(!1), a = M.useRef(!1);
    return /* @__PURE__ */ E.jsx(
      L9,
      {
        ...e,
        ref: t,
        trapFocus: !1,
        disableOutsidePointerEvents: !1,
        onCloseAutoFocus: (s) => {
          e.onCloseAutoFocus?.(s), s.defaultPrevented || (r.current || n.triggerRef.current?.focus(), s.preventDefault()), r.current = !1, a.current = !1;
        },
        onInteractOutside: (s) => {
          e.onInteractOutside?.(s), s.defaultPrevented || (r.current = !0, s.detail.originalEvent.type === "pointerdown" && (a.current = !0));
          const l = s.target;
          n.triggerRef.current?.contains(l) && s.preventDefault(), s.detail.originalEvent.type === "focusin" && a.current && s.preventDefault();
        }
      }
    );
  }
), L9 = M.forwardRef(
  (e, t) => {
    const { __scopeDialog: n, trapFocus: r, onOpenAutoFocus: a, onCloseAutoFocus: s, ...l } = e, c = qs(im, n), d = M.useRef(null), p = Wn(t, d);
    return uR(), /* @__PURE__ */ E.jsxs(E.Fragment, { children: [
      /* @__PURE__ */ E.jsx(
        m2,
        {
          asChild: !0,
          loop: !0,
          trapped: r,
          onMountAutoFocus: a,
          onUnmountAutoFocus: s,
          children: /* @__PURE__ */ E.jsx(
            rS,
            {
              role: "dialog",
              id: c.contentId,
              "aria-describedby": c.descriptionId,
              "aria-labelledby": c.titleId,
              "data-state": pR(c.open),
              ...l,
              ref: p,
              onDismiss: () => c.onOpenChange(!1)
            }
          )
        }
      ),
      /* @__PURE__ */ E.jsxs(E.Fragment, { children: [
        /* @__PURE__ */ E.jsx(ate, { titleId: c.titleId }),
        /* @__PURE__ */ E.jsx(ste, { contentRef: d, descriptionId: c.descriptionId })
      ] })
    ] });
  }
), fR = "DialogTitle", I9 = M.forwardRef(
  (e, t) => {
    const { __scopeDialog: n, ...r } = e, a = qs(fR, n);
    return /* @__PURE__ */ E.jsx(Kt.h2, { id: a.titleId, ...r, ref: t });
  }
);
I9.displayName = fR;
var z9 = "DialogDescription", F9 = M.forwardRef(
  (e, t) => {
    const { __scopeDialog: n, ...r } = e, a = qs(z9, n);
    return /* @__PURE__ */ E.jsx(Kt.p, { id: a.descriptionId, ...r, ref: t });
  }
);
F9.displayName = z9;
var B9 = "DialogClose", U9 = M.forwardRef(
  (e, t) => {
    const { __scopeDialog: n, ...r } = e, a = qs(B9, n);
    return /* @__PURE__ */ E.jsx(
      Kt.button,
      {
        type: "button",
        ...r,
        ref: t,
        onClick: Ze(e.onClick, () => a.onOpenChange(!1))
      }
    );
  }
);
U9.displayName = B9;
function pR(e) {
  return e ? "open" : "closed";
}
var V9 = "DialogTitleWarning", [h9e, H9] = TZ(V9, {
  contentName: im,
  titleName: fR,
  docsSlug: "dialog"
}), ate = ({ titleId: e }) => {
  const t = H9(V9), n = `\`${t.contentName}\` requires a \`${t.titleName}\` for the component to be accessible for screen reader users.

If you want to hide the \`${t.titleName}\`, you can wrap it with our VisuallyHidden component.

For more information, see https://radix-ui.com/primitives/docs/components/${t.docsSlug}`;
  return M.useEffect(() => {
    e && (document.getElementById(e) || console.error(n));
  }, [n, e]), null;
}, ite = "DialogDescriptionWarning", ste = ({ contentRef: e, descriptionId: t }) => {
  const n = `Warning: Missing \`Description\` or \`aria-describedby={undefined}\` for {${H9(ite).contentName}}.`;
  return M.useEffect(() => {
    const r = e.current?.getAttribute("aria-describedby");
    t && r && (document.getElementById(t) || console.warn(n));
  }, [n, e, t]), null;
}, lte = R9, ute = j9, cte = D9, dte = $9, fte = T9, pte = I9, mte = F9, q9 = U9;
function o5(e, t) {
  (t == null || t > e.length) && (t = e.length);
  for (var n = 0, r = Array(t); n < t; n++) r[n] = e[n];
  return r;
}
function hte(e) {
  if (Array.isArray(e)) return e;
}
function gte(e) {
  if (Array.isArray(e)) return o5(e);
}
function vte(e, t) {
  if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function");
}
function yte(e, t) {
  for (var n = 0; n < t.length; n++) {
    var r = t[n];
    r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, W9(r.key), r);
  }
}
function bte(e, t, n) {
  return t && yte(e.prototype, t), Object.defineProperty(e, "prototype", {
    writable: !1
  }), e;
}
function k0(e, t) {
  var n = typeof Symbol < "u" && e[Symbol.iterator] || e["@@iterator"];
  if (!n) {
    if (Array.isArray(e) || (n = mR(e)) || t) {
      n && (e = n);
      var r = 0, a = function() {
      };
      return {
        s: a,
        n: function() {
          return r >= e.length ? {
            done: !0
          } : {
            done: !1,
            value: e[r++]
          };
        },
        e: function(d) {
          throw d;
        },
        f: a
      };
    }
    throw new TypeError(`Invalid attempt to iterate non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
  }
  var s, l = !0, c = !1;
  return {
    s: function() {
      n = n.call(e);
    },
    n: function() {
      var d = n.next();
      return l = d.done, d;
    },
    e: function(d) {
      c = !0, s = d;
    },
    f: function() {
      try {
        l || n.return == null || n.return();
      } finally {
        if (c) throw s;
      }
    }
  };
}
function Lt(e, t, n) {
  return (t = W9(t)) in e ? Object.defineProperty(e, t, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = n, e;
}
function wte(e) {
  if (typeof Symbol < "u" && e[Symbol.iterator] != null || e["@@iterator"] != null) return Array.from(e);
}
function xte(e, t) {
  var n = e == null ? null : typeof Symbol < "u" && e[Symbol.iterator] || e["@@iterator"];
  if (n != null) {
    var r, a, s, l, c = [], d = !0, p = !1;
    try {
      if (s = (n = n.call(e)).next, t === 0) {
        if (Object(n) !== n) return;
        d = !1;
      } else for (; !(d = (r = s.call(n)).done) && (c.push(r.value), c.length !== t); d = !0) ;
    } catch (m) {
      p = !0, a = m;
    } finally {
      try {
        if (!d && n.return != null && (l = n.return(), Object(l) !== l)) return;
      } finally {
        if (p) throw a;
      }
    }
    return c;
  }
}
function Ste() {
  throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function kte() {
  throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function BP(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(a) {
      return Object.getOwnPropertyDescriptor(e, a).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function De(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? BP(Object(n), !0).forEach(function(r) {
      Lt(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : BP(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function b2(e, t) {
  return hte(e) || xte(e, t) || mR(e, t) || Ste();
}
function Fs(e) {
  return gte(e) || wte(e) || mR(e) || kte();
}
function _te(e, t) {
  if (typeof e != "object" || !e) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t);
    if (typeof r != "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function W9(e) {
  var t = _te(e, "string");
  return typeof t == "symbol" ? t : t + "";
}
function Z0(e) {
  "@babel/helpers - typeof";
  return Z0 = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, Z0(e);
}
function mR(e, t) {
  if (e) {
    if (typeof e == "string") return o5(e, t);
    var n = {}.toString.call(e).slice(8, -1);
    return n === "Object" && e.constructor && (n = e.constructor.name), n === "Map" || n === "Set" ? Array.from(e) : n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n) ? o5(e, t) : void 0;
  }
}
var UP = function() {
}, hR = {}, G9 = {}, K9 = null, X9 = {
  mark: UP,
  measure: UP
};
try {
  typeof window < "u" && (hR = window), typeof document < "u" && (G9 = document), typeof MutationObserver < "u" && (K9 = MutationObserver), typeof performance < "u" && (X9 = performance);
} catch {
}
var Ete = hR.navigator || {}, VP = Ete.userAgent, HP = VP === void 0 ? "" : VP, id = hR, ir = G9, qP = K9, YS = X9;
id.document;
var Mc = !!ir.documentElement && !!ir.head && typeof ir.addEventListener == "function" && typeof ir.createElement == "function", Y9 = ~HP.indexOf("MSIE") || ~HP.indexOf("Trident/"), uM, Cte = /fa(k|kd|s|r|l|t|d|dr|dl|dt|b|slr|slpr|wsb|tl|ns|nds|es|jr|jfr|jdr|usb|ufsb|udsb|cr|ss|sr|sl|st|sds|sdr|sdl|sdt)?[\-\ ]/, Ote = /Font ?Awesome ?([567 ]*)(Solid|Regular|Light|Thin|Duotone|Brands|Free|Pro|Sharp Duotone|Sharp|Kit|Notdog Duo|Notdog|Chisel|Etch|Thumbprint|Jelly Fill|Jelly Duo|Jelly|Utility|Utility Fill|Utility Duo|Slab Press|Slab|Whiteboard)?.*/i, Q9 = {
  classic: {
    fa: "solid",
    fas: "solid",
    "fa-solid": "solid",
    far: "regular",
    "fa-regular": "regular",
    fal: "light",
    "fa-light": "light",
    fat: "thin",
    "fa-thin": "thin",
    fab: "brands",
    "fa-brands": "brands"
  },
  duotone: {
    fa: "solid",
    fad: "solid",
    "fa-solid": "solid",
    "fa-duotone": "solid",
    fadr: "regular",
    "fa-regular": "regular",
    fadl: "light",
    "fa-light": "light",
    fadt: "thin",
    "fa-thin": "thin"
  },
  sharp: {
    fa: "solid",
    fass: "solid",
    "fa-solid": "solid",
    fasr: "regular",
    "fa-regular": "regular",
    fasl: "light",
    "fa-light": "light",
    fast: "thin",
    "fa-thin": "thin"
  },
  "sharp-duotone": {
    fa: "solid",
    fasds: "solid",
    "fa-solid": "solid",
    fasdr: "regular",
    "fa-regular": "regular",
    fasdl: "light",
    "fa-light": "light",
    fasdt: "thin",
    "fa-thin": "thin"
  },
  slab: {
    "fa-regular": "regular",
    faslr: "regular"
  },
  "slab-press": {
    "fa-regular": "regular",
    faslpr: "regular"
  },
  thumbprint: {
    "fa-light": "light",
    fatl: "light"
  },
  whiteboard: {
    "fa-semibold": "semibold",
    fawsb: "semibold"
  },
  notdog: {
    "fa-solid": "solid",
    fans: "solid"
  },
  "notdog-duo": {
    "fa-solid": "solid",
    fands: "solid"
  },
  etch: {
    "fa-solid": "solid",
    faes: "solid"
  },
  jelly: {
    "fa-regular": "regular",
    fajr: "regular"
  },
  "jelly-fill": {
    "fa-regular": "regular",
    fajfr: "regular"
  },
  "jelly-duo": {
    "fa-regular": "regular",
    fajdr: "regular"
  },
  chisel: {
    "fa-regular": "regular",
    facr: "regular"
  },
  utility: {
    "fa-semibold": "semibold",
    fausb: "semibold"
  },
  "utility-duo": {
    "fa-semibold": "semibold",
    faudsb: "semibold"
  },
  "utility-fill": {
    "fa-semibold": "semibold",
    faufsb: "semibold"
  }
}, Mte = {
  GROUP: "duotone-group",
  PRIMARY: "primary",
  SECONDARY: "secondary"
}, J9 = ["fa-classic", "fa-duotone", "fa-sharp", "fa-sharp-duotone", "fa-thumbprint", "fa-whiteboard", "fa-notdog", "fa-notdog-duo", "fa-chisel", "fa-etch", "fa-jelly", "fa-jelly-fill", "fa-jelly-duo", "fa-slab", "fa-slab-press", "fa-utility", "fa-utility-duo", "fa-utility-fill"], $o = "classic", oS = "duotone", Z9 = "sharp", eF = "sharp-duotone", tF = "chisel", nF = "etch", rF = "jelly", oF = "jelly-duo", aF = "jelly-fill", iF = "notdog", sF = "notdog-duo", lF = "slab", uF = "slab-press", cF = "thumbprint", dF = "utility", fF = "utility-duo", pF = "utility-fill", mF = "whiteboard", Nte = "Classic", Rte = "Duotone", Ate = "Sharp", jte = "Sharp Duotone", Pte = "Chisel", Dte = "Etch", $te = "Jelly", Tte = "Jelly Duo", Lte = "Jelly Fill", Ite = "Notdog", zte = "Notdog Duo", Fte = "Slab", Bte = "Slab Press", Ute = "Thumbprint", Vte = "Utility", Hte = "Utility Duo", qte = "Utility Fill", Wte = "Whiteboard", hF = [$o, oS, Z9, eF, tF, nF, rF, oF, aF, iF, sF, lF, uF, cF, dF, fF, pF, mF];
uM = {}, Lt(Lt(Lt(Lt(Lt(Lt(Lt(Lt(Lt(Lt(uM, $o, Nte), oS, Rte), Z9, Ate), eF, jte), tF, Pte), nF, Dte), rF, $te), oF, Tte), aF, Lte), iF, Ite), Lt(Lt(Lt(Lt(Lt(Lt(Lt(Lt(uM, sF, zte), lF, Fte), uF, Bte), cF, Ute), dF, Vte), fF, Hte), pF, qte), mF, Wte);
var Gte = {
  classic: {
    900: "fas",
    400: "far",
    normal: "far",
    300: "fal",
    100: "fat"
  },
  duotone: {
    900: "fad",
    400: "fadr",
    300: "fadl",
    100: "fadt"
  },
  sharp: {
    900: "fass",
    400: "fasr",
    300: "fasl",
    100: "fast"
  },
  "sharp-duotone": {
    900: "fasds",
    400: "fasdr",
    300: "fasdl",
    100: "fasdt"
  },
  slab: {
    400: "faslr"
  },
  "slab-press": {
    400: "faslpr"
  },
  whiteboard: {
    600: "fawsb"
  },
  thumbprint: {
    300: "fatl"
  },
  notdog: {
    900: "fans"
  },
  "notdog-duo": {
    900: "fands"
  },
  etch: {
    900: "faes"
  },
  chisel: {
    400: "facr"
  },
  jelly: {
    400: "fajr"
  },
  "jelly-fill": {
    400: "fajfr"
  },
  "jelly-duo": {
    400: "fajdr"
  },
  utility: {
    600: "fausb"
  },
  "utility-duo": {
    600: "faudsb"
  },
  "utility-fill": {
    600: "faufsb"
  }
}, Kte = {
  "Font Awesome 7 Free": {
    900: "fas",
    400: "far"
  },
  "Font Awesome 7 Pro": {
    900: "fas",
    400: "far",
    normal: "far",
    300: "fal",
    100: "fat"
  },
  "Font Awesome 7 Brands": {
    400: "fab",
    normal: "fab"
  },
  "Font Awesome 7 Duotone": {
    900: "fad",
    400: "fadr",
    normal: "fadr",
    300: "fadl",
    100: "fadt"
  },
  "Font Awesome 7 Sharp": {
    900: "fass",
    400: "fasr",
    normal: "fasr",
    300: "fasl",
    100: "fast"
  },
  "Font Awesome 7 Sharp Duotone": {
    900: "fasds",
    400: "fasdr",
    normal: "fasdr",
    300: "fasdl",
    100: "fasdt"
  },
  "Font Awesome 7 Jelly": {
    400: "fajr",
    normal: "fajr"
  },
  "Font Awesome 7 Jelly Fill": {
    400: "fajfr",
    normal: "fajfr"
  },
  "Font Awesome 7 Jelly Duo": {
    400: "fajdr",
    normal: "fajdr"
  },
  "Font Awesome 7 Slab": {
    400: "faslr",
    normal: "faslr"
  },
  "Font Awesome 7 Slab Press": {
    400: "faslpr",
    normal: "faslpr"
  },
  "Font Awesome 7 Thumbprint": {
    300: "fatl",
    normal: "fatl"
  },
  "Font Awesome 7 Notdog": {
    900: "fans",
    normal: "fans"
  },
  "Font Awesome 7 Notdog Duo": {
    900: "fands",
    normal: "fands"
  },
  "Font Awesome 7 Etch": {
    900: "faes",
    normal: "faes"
  },
  "Font Awesome 7 Chisel": {
    400: "facr",
    normal: "facr"
  },
  "Font Awesome 7 Whiteboard": {
    600: "fawsb",
    normal: "fawsb"
  },
  "Font Awesome 7 Utility": {
    600: "fausb",
    normal: "fausb"
  },
  "Font Awesome 7 Utility Duo": {
    600: "faudsb",
    normal: "faudsb"
  },
  "Font Awesome 7 Utility Fill": {
    600: "faufsb",
    normal: "faufsb"
  }
}, Xte = /* @__PURE__ */ new Map([["classic", {
  defaultShortPrefixId: "fas",
  defaultStyleId: "solid",
  styleIds: ["solid", "regular", "light", "thin", "brands"],
  futureStyleIds: [],
  defaultFontWeight: 900
}], ["duotone", {
  defaultShortPrefixId: "fad",
  defaultStyleId: "solid",
  styleIds: ["solid", "regular", "light", "thin"],
  futureStyleIds: [],
  defaultFontWeight: 900
}], ["sharp", {
  defaultShortPrefixId: "fass",
  defaultStyleId: "solid",
  styleIds: ["solid", "regular", "light", "thin"],
  futureStyleIds: [],
  defaultFontWeight: 900
}], ["sharp-duotone", {
  defaultShortPrefixId: "fasds",
  defaultStyleId: "solid",
  styleIds: ["solid", "regular", "light", "thin"],
  futureStyleIds: [],
  defaultFontWeight: 900
}], ["chisel", {
  defaultShortPrefixId: "facr",
  defaultStyleId: "regular",
  styleIds: ["regular"],
  futureStyleIds: [],
  defaultFontWeight: 400
}], ["etch", {
  defaultShortPrefixId: "faes",
  defaultStyleId: "solid",
  styleIds: ["solid"],
  futureStyleIds: [],
  defaultFontWeight: 900
}], ["jelly", {
  defaultShortPrefixId: "fajr",
  defaultStyleId: "regular",
  styleIds: ["regular"],
  futureStyleIds: [],
  defaultFontWeight: 400
}], ["jelly-duo", {
  defaultShortPrefixId: "fajdr",
  defaultStyleId: "regular",
  styleIds: ["regular"],
  futureStyleIds: [],
  defaultFontWeight: 400
}], ["jelly-fill", {
  defaultShortPrefixId: "fajfr",
  defaultStyleId: "regular",
  styleIds: ["regular"],
  futureStyleIds: [],
  defaultFontWeight: 400
}], ["notdog", {
  defaultShortPrefixId: "fans",
  defaultStyleId: "solid",
  styleIds: ["solid"],
  futureStyleIds: [],
  defaultFontWeight: 900
}], ["notdog-duo", {
  defaultShortPrefixId: "fands",
  defaultStyleId: "solid",
  styleIds: ["solid"],
  futureStyleIds: [],
  defaultFontWeight: 900
}], ["slab", {
  defaultShortPrefixId: "faslr",
  defaultStyleId: "regular",
  styleIds: ["regular"],
  futureStyleIds: [],
  defaultFontWeight: 400
}], ["slab-press", {
  defaultShortPrefixId: "faslpr",
  defaultStyleId: "regular",
  styleIds: ["regular"],
  futureStyleIds: [],
  defaultFontWeight: 400
}], ["thumbprint", {
  defaultShortPrefixId: "fatl",
  defaultStyleId: "light",
  styleIds: ["light"],
  futureStyleIds: [],
  defaultFontWeight: 300
}], ["utility", {
  defaultShortPrefixId: "fausb",
  defaultStyleId: "semibold",
  styleIds: ["semibold"],
  futureStyleIds: [],
  defaultFontWeight: 600
}], ["utility-duo", {
  defaultShortPrefixId: "faudsb",
  defaultStyleId: "semibold",
  styleIds: ["semibold"],
  futureStyleIds: [],
  defaultFontWeight: 600
}], ["utility-fill", {
  defaultShortPrefixId: "faufsb",
  defaultStyleId: "semibold",
  styleIds: ["semibold"],
  futureStyleIds: [],
  defaultFontWeight: 600
}], ["whiteboard", {
  defaultShortPrefixId: "fawsb",
  defaultStyleId: "semibold",
  styleIds: ["semibold"],
  futureStyleIds: [],
  defaultFontWeight: 600
}]]), Yte = {
  chisel: {
    regular: "facr"
  },
  classic: {
    brands: "fab",
    light: "fal",
    regular: "far",
    solid: "fas",
    thin: "fat"
  },
  duotone: {
    light: "fadl",
    regular: "fadr",
    solid: "fad",
    thin: "fadt"
  },
  etch: {
    solid: "faes"
  },
  jelly: {
    regular: "fajr"
  },
  "jelly-duo": {
    regular: "fajdr"
  },
  "jelly-fill": {
    regular: "fajfr"
  },
  notdog: {
    solid: "fans"
  },
  "notdog-duo": {
    solid: "fands"
  },
  sharp: {
    light: "fasl",
    regular: "fasr",
    solid: "fass",
    thin: "fast"
  },
  "sharp-duotone": {
    light: "fasdl",
    regular: "fasdr",
    solid: "fasds",
    thin: "fasdt"
  },
  slab: {
    regular: "faslr"
  },
  "slab-press": {
    regular: "faslpr"
  },
  thumbprint: {
    light: "fatl"
  },
  utility: {
    semibold: "fausb"
  },
  "utility-duo": {
    semibold: "faudsb"
  },
  "utility-fill": {
    semibold: "faufsb"
  },
  whiteboard: {
    semibold: "fawsb"
  }
}, gF = ["fak", "fa-kit", "fakd", "fa-kit-duotone"], WP = {
  kit: {
    fak: "kit",
    "fa-kit": "kit"
  },
  "kit-duotone": {
    fakd: "kit-duotone",
    "fa-kit-duotone": "kit-duotone"
  }
}, Qte = ["kit"], Jte = "kit", Zte = "kit-duotone", ene = "Kit", tne = "Kit Duotone";
Lt(Lt({}, Jte, ene), Zte, tne);
var nne = {
  kit: {
    "fa-kit": "fak"
  }
}, rne = {
  "Font Awesome Kit": {
    400: "fak",
    normal: "fak"
  },
  "Font Awesome Kit Duotone": {
    400: "fakd",
    normal: "fakd"
  }
}, one = {
  kit: {
    fak: "fa-kit"
  }
}, GP = {
  kit: {
    kit: "fak"
  },
  "kit-duotone": {
    "kit-duotone": "fakd"
  }
}, cM, QS = {
  GROUP: "duotone-group",
  SWAP_OPACITY: "swap-opacity",
  PRIMARY: "primary",
  SECONDARY: "secondary"
}, ane = ["fa-classic", "fa-duotone", "fa-sharp", "fa-sharp-duotone", "fa-thumbprint", "fa-whiteboard", "fa-notdog", "fa-notdog-duo", "fa-chisel", "fa-etch", "fa-jelly", "fa-jelly-fill", "fa-jelly-duo", "fa-slab", "fa-slab-press", "fa-utility", "fa-utility-duo", "fa-utility-fill"], ine = "classic", sne = "duotone", lne = "sharp", une = "sharp-duotone", cne = "chisel", dne = "etch", fne = "jelly", pne = "jelly-duo", mne = "jelly-fill", hne = "notdog", gne = "notdog-duo", vne = "slab", yne = "slab-press", bne = "thumbprint", wne = "utility", xne = "utility-duo", Sne = "utility-fill", kne = "whiteboard", _ne = "Classic", Ene = "Duotone", Cne = "Sharp", One = "Sharp Duotone", Mne = "Chisel", Nne = "Etch", Rne = "Jelly", Ane = "Jelly Duo", jne = "Jelly Fill", Pne = "Notdog", Dne = "Notdog Duo", $ne = "Slab", Tne = "Slab Press", Lne = "Thumbprint", Ine = "Utility", zne = "Utility Duo", Fne = "Utility Fill", Bne = "Whiteboard";
cM = {}, Lt(Lt(Lt(Lt(Lt(Lt(Lt(Lt(Lt(Lt(cM, ine, _ne), sne, Ene), lne, Cne), une, One), cne, Mne), dne, Nne), fne, Rne), pne, Ane), mne, jne), hne, Pne), Lt(Lt(Lt(Lt(Lt(Lt(Lt(Lt(cM, gne, Dne), vne, $ne), yne, Tne), bne, Lne), wne, Ine), xne, zne), Sne, Fne), kne, Bne);
var Une = "kit", Vne = "kit-duotone", Hne = "Kit", qne = "Kit Duotone";
Lt(Lt({}, Une, Hne), Vne, qne);
var Wne = {
  classic: {
    "fa-brands": "fab",
    "fa-duotone": "fad",
    "fa-light": "fal",
    "fa-regular": "far",
    "fa-solid": "fas",
    "fa-thin": "fat"
  },
  duotone: {
    "fa-regular": "fadr",
    "fa-light": "fadl",
    "fa-thin": "fadt"
  },
  sharp: {
    "fa-solid": "fass",
    "fa-regular": "fasr",
    "fa-light": "fasl",
    "fa-thin": "fast"
  },
  "sharp-duotone": {
    "fa-solid": "fasds",
    "fa-regular": "fasdr",
    "fa-light": "fasdl",
    "fa-thin": "fasdt"
  },
  slab: {
    "fa-regular": "faslr"
  },
  "slab-press": {
    "fa-regular": "faslpr"
  },
  whiteboard: {
    "fa-semibold": "fawsb"
  },
  thumbprint: {
    "fa-light": "fatl"
  },
  notdog: {
    "fa-solid": "fans"
  },
  "notdog-duo": {
    "fa-solid": "fands"
  },
  etch: {
    "fa-solid": "faes"
  },
  jelly: {
    "fa-regular": "fajr"
  },
  "jelly-fill": {
    "fa-regular": "fajfr"
  },
  "jelly-duo": {
    "fa-regular": "fajdr"
  },
  chisel: {
    "fa-regular": "facr"
  },
  utility: {
    "fa-semibold": "fausb"
  },
  "utility-duo": {
    "fa-semibold": "faudsb"
  },
  "utility-fill": {
    "fa-semibold": "faufsb"
  }
}, Gne = {
  classic: ["fas", "far", "fal", "fat", "fad"],
  duotone: ["fadr", "fadl", "fadt"],
  sharp: ["fass", "fasr", "fasl", "fast"],
  "sharp-duotone": ["fasds", "fasdr", "fasdl", "fasdt"],
  slab: ["faslr"],
  "slab-press": ["faslpr"],
  whiteboard: ["fawsb"],
  thumbprint: ["fatl"],
  notdog: ["fans"],
  "notdog-duo": ["fands"],
  etch: ["faes"],
  jelly: ["fajr"],
  "jelly-fill": ["fajfr"],
  "jelly-duo": ["fajdr"],
  chisel: ["facr"],
  utility: ["fausb"],
  "utility-duo": ["faudsb"],
  "utility-fill": ["faufsb"]
}, a5 = {
  classic: {
    fab: "fa-brands",
    fad: "fa-duotone",
    fal: "fa-light",
    far: "fa-regular",
    fas: "fa-solid",
    fat: "fa-thin"
  },
  duotone: {
    fadr: "fa-regular",
    fadl: "fa-light",
    fadt: "fa-thin"
  },
  sharp: {
    fass: "fa-solid",
    fasr: "fa-regular",
    fasl: "fa-light",
    fast: "fa-thin"
  },
  "sharp-duotone": {
    fasds: "fa-solid",
    fasdr: "fa-regular",
    fasdl: "fa-light",
    fasdt: "fa-thin"
  },
  slab: {
    faslr: "fa-regular"
  },
  "slab-press": {
    faslpr: "fa-regular"
  },
  whiteboard: {
    fawsb: "fa-semibold"
  },
  thumbprint: {
    fatl: "fa-light"
  },
  notdog: {
    fans: "fa-solid"
  },
  "notdog-duo": {
    fands: "fa-solid"
  },
  etch: {
    faes: "fa-solid"
  },
  jelly: {
    fajr: "fa-regular"
  },
  "jelly-fill": {
    fajfr: "fa-regular"
  },
  "jelly-duo": {
    fajdr: "fa-regular"
  },
  chisel: {
    facr: "fa-regular"
  },
  utility: {
    fausb: "fa-semibold"
  },
  "utility-duo": {
    faudsb: "fa-semibold"
  },
  "utility-fill": {
    faufsb: "fa-semibold"
  }
}, Kne = ["fa-solid", "fa-regular", "fa-light", "fa-thin", "fa-duotone", "fa-brands", "fa-semibold"], vF = ["fa", "fas", "far", "fal", "fat", "fad", "fadr", "fadl", "fadt", "fab", "fass", "fasr", "fasl", "fast", "fasds", "fasdr", "fasdl", "fasdt", "faslr", "faslpr", "fawsb", "fatl", "fans", "fands", "faes", "fajr", "fajfr", "fajdr", "facr", "fausb", "faudsb", "faufsb"].concat(ane, Kne), Xne = ["solid", "regular", "light", "thin", "duotone", "brands", "semibold"], yF = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10], Yne = yF.concat([11, 12, 13, 14, 15, 16, 17, 18, 19, 20]), Qne = ["aw", "fw", "pull-left", "pull-right"], Jne = [].concat(Fs(Object.keys(Gne)), Xne, Qne, ["2xs", "xs", "sm", "lg", "xl", "2xl", "beat", "border", "fade", "beat-fade", "bounce", "flip-both", "flip-horizontal", "flip-vertical", "flip", "inverse", "layers", "layers-bottom-left", "layers-bottom-right", "layers-counter", "layers-text", "layers-top-left", "layers-top-right", "li", "pull-end", "pull-start", "pulse", "rotate-180", "rotate-270", "rotate-90", "rotate-by", "shake", "spin-pulse", "spin-reverse", "spin", "stack-1x", "stack-2x", "stack", "ul", "width-auto", "width-fixed", QS.GROUP, QS.SWAP_OPACITY, QS.PRIMARY, QS.SECONDARY]).concat(yF.map(function(e) {
  return "".concat(e, "x");
})).concat(Yne.map(function(e) {
  return "w-".concat(e);
})), Zne = {
  "Font Awesome 5 Free": {
    900: "fas",
    400: "far"
  },
  "Font Awesome 5 Pro": {
    900: "fas",
    400: "far",
    normal: "far",
    300: "fal"
  },
  "Font Awesome 5 Brands": {
    400: "fab",
    normal: "fab"
  },
  "Font Awesome 5 Duotone": {
    900: "fad"
  }
}, wc = "___FONT_AWESOME___", i5 = 16, bF = "fa", wF = "svg-inline--fa", sm = "data-fa-i2svg", s5 = "data-fa-pseudo-element", ere = "data-fa-pseudo-element-pending", gR = "data-prefix", vR = "data-icon", KP = "fontawesome-i2svg", tre = "async", nre = ["HTML", "HEAD", "STYLE", "SCRIPT"], xF = ["::before", "::after", ":before", ":after"], SF = (function() {
  try {
    return !0;
  } catch {
    return !1;
  }
})();
function aS(e) {
  return new Proxy(e, {
    get: function(t, n) {
      return n in t ? t[n] : t[$o];
    }
  });
}
var kF = De({}, Q9);
kF[$o] = De(De(De(De({}, {
  "fa-duotone": "duotone"
}), Q9[$o]), WP.kit), WP["kit-duotone"]);
var rre = aS(kF), l5 = De({}, Yte);
l5[$o] = De(De(De(De({}, {
  duotone: "fad"
}), l5[$o]), GP.kit), GP["kit-duotone"]);
var XP = aS(l5), u5 = De({}, a5);
u5[$o] = De(De({}, u5[$o]), one.kit);
var yR = aS(u5), c5 = De({}, Wne);
c5[$o] = De(De({}, c5[$o]), nne.kit);
aS(c5);
var ore = Cte, _F = "fa-layers-text", are = Ote, ire = De({}, Gte);
aS(ire);
var sre = ["class", "data-prefix", "data-icon", "data-fa-transform", "data-fa-mask"], dM = Mte, lre = [].concat(Fs(Qte), Fs(Jne)), Ww = id.FontAwesomeConfig || {};
function ure(e) {
  var t = ir.querySelector("script[" + e + "]");
  if (t)
    return t.getAttribute(e);
}
function cre(e) {
  return e === "" ? !0 : e === "false" ? !1 : e === "true" ? !0 : e;
}
if (ir && typeof ir.querySelector == "function") {
  var dre = [["data-family-prefix", "familyPrefix"], ["data-css-prefix", "cssPrefix"], ["data-family-default", "familyDefault"], ["data-style-default", "styleDefault"], ["data-replacement-class", "replacementClass"], ["data-auto-replace-svg", "autoReplaceSvg"], ["data-auto-add-css", "autoAddCss"], ["data-search-pseudo-elements", "searchPseudoElements"], ["data-search-pseudo-elements-warnings", "searchPseudoElementsWarnings"], ["data-search-pseudo-elements-full-scan", "searchPseudoElementsFullScan"], ["data-observe-mutations", "observeMutations"], ["data-mutate-approach", "mutateApproach"], ["data-keep-original-source", "keepOriginalSource"], ["data-measure-performance", "measurePerformance"], ["data-show-missing-icons", "showMissingIcons"]];
  dre.forEach(function(e) {
    var t = b2(e, 2), n = t[0], r = t[1], a = cre(ure(n));
    a != null && (Ww[r] = a);
  });
}
var EF = {
  styleDefault: "solid",
  familyDefault: $o,
  cssPrefix: bF,
  replacementClass: wF,
  autoReplaceSvg: !0,
  autoAddCss: !0,
  searchPseudoElements: !1,
  searchPseudoElementsWarnings: !0,
  searchPseudoElementsFullScan: !1,
  observeMutations: !0,
  mutateApproach: "async",
  keepOriginalSource: !0,
  measurePerformance: !1,
  showMissingIcons: !0
};
Ww.familyPrefix && (Ww.cssPrefix = Ww.familyPrefix);
var jh = De(De({}, EF), Ww);
jh.autoReplaceSvg || (jh.observeMutations = !1);
var ct = {};
Object.keys(EF).forEach(function(e) {
  Object.defineProperty(ct, e, {
    enumerable: !0,
    set: function(t) {
      jh[e] = t, Gw.forEach(function(n) {
        return n(ct);
      });
    },
    get: function() {
      return jh[e];
    }
  });
});
Object.defineProperty(ct, "familyPrefix", {
  enumerable: !0,
  set: function(e) {
    jh.cssPrefix = e, Gw.forEach(function(t) {
      return t(ct);
    });
  },
  get: function() {
    return jh.cssPrefix;
  }
});
id.FontAwesomeConfig = ct;
var Gw = [];
function fre(e) {
  return Gw.push(e), function() {
    Gw.splice(Gw.indexOf(e), 1);
  };
}
var Wm = i5, fl = {
  size: 16,
  x: 0,
  y: 0,
  rotate: 0,
  flipX: !1,
  flipY: !1
};
function pre(e) {
  if (!(!e || !Mc)) {
    var t = ir.createElement("style");
    t.setAttribute("type", "text/css"), t.innerHTML = e;
    for (var n = ir.head.childNodes, r = null, a = n.length - 1; a > -1; a--) {
      var s = n[a], l = (s.tagName || "").toUpperCase();
      ["STYLE", "LINK"].indexOf(l) > -1 && (r = s);
    }
    return ir.head.insertBefore(t, r), e;
  }
}
var mre = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ";
function YP() {
  for (var e = 12, t = ""; e-- > 0; )
    t += mre[Math.random() * 62 | 0];
  return t;
}
function ng(e) {
  for (var t = [], n = (e || []).length >>> 0; n--; )
    t[n] = e[n];
  return t;
}
function bR(e) {
  return e.classList ? ng(e.classList) : (e.getAttribute("class") || "").split(" ").filter(function(t) {
    return t;
  });
}
function CF(e) {
  return "".concat(e).replace(/&/g, "&amp;").replace(/"/g, "&quot;").replace(/'/g, "&#39;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
}
function hre(e) {
  return Object.keys(e || {}).reduce(function(t, n) {
    return t + "".concat(n, '="').concat(CF(e[n]), '" ');
  }, "").trim();
}
function w2(e) {
  return Object.keys(e || {}).reduce(function(t, n) {
    return t + "".concat(n, ": ").concat(e[n].trim(), ";");
  }, "");
}
function wR(e) {
  return e.size !== fl.size || e.x !== fl.x || e.y !== fl.y || e.rotate !== fl.rotate || e.flipX || e.flipY;
}
function gre(e) {
  var t = e.transform, n = e.containerWidth, r = e.iconWidth, a = {
    transform: "translate(".concat(n / 2, " 256)")
  }, s = "translate(".concat(t.x * 32, ", ").concat(t.y * 32, ") "), l = "scale(".concat(t.size / 16 * (t.flipX ? -1 : 1), ", ").concat(t.size / 16 * (t.flipY ? -1 : 1), ") "), c = "rotate(".concat(t.rotate, " 0 0)"), d = {
    transform: "".concat(s, " ").concat(l, " ").concat(c)
  }, p = {
    transform: "translate(".concat(r / 2 * -1, " -256)")
  };
  return {
    outer: a,
    inner: d,
    path: p
  };
}
function vre(e) {
  var t = e.transform, n = e.width, r = n === void 0 ? i5 : n, a = e.height, s = a === void 0 ? i5 : a, l = "";
  return Y9 ? l += "translate(".concat(t.x / Wm - r / 2, "em, ").concat(t.y / Wm - s / 2, "em) ") : l += "translate(calc(-50% + ".concat(t.x / Wm, "em), calc(-50% + ").concat(t.y / Wm, "em)) "), l += "scale(".concat(t.size / Wm * (t.flipX ? -1 : 1), ", ").concat(t.size / Wm * (t.flipY ? -1 : 1), ") "), l += "rotate(".concat(t.rotate, "deg) "), l;
}
var yre = `:root, :host {
  --fa-font-solid: normal 900 1em/1 "Font Awesome 7 Free";
  --fa-font-regular: normal 400 1em/1 "Font Awesome 7 Free";
  --fa-font-light: normal 300 1em/1 "Font Awesome 7 Pro";
  --fa-font-thin: normal 100 1em/1 "Font Awesome 7 Pro";
  --fa-font-duotone: normal 900 1em/1 "Font Awesome 7 Duotone";
  --fa-font-duotone-regular: normal 400 1em/1 "Font Awesome 7 Duotone";
  --fa-font-duotone-light: normal 300 1em/1 "Font Awesome 7 Duotone";
  --fa-font-duotone-thin: normal 100 1em/1 "Font Awesome 7 Duotone";
  --fa-font-brands: normal 400 1em/1 "Font Awesome 7 Brands";
  --fa-font-sharp-solid: normal 900 1em/1 "Font Awesome 7 Sharp";
  --fa-font-sharp-regular: normal 400 1em/1 "Font Awesome 7 Sharp";
  --fa-font-sharp-light: normal 300 1em/1 "Font Awesome 7 Sharp";
  --fa-font-sharp-thin: normal 100 1em/1 "Font Awesome 7 Sharp";
  --fa-font-sharp-duotone-solid: normal 900 1em/1 "Font Awesome 7 Sharp Duotone";
  --fa-font-sharp-duotone-regular: normal 400 1em/1 "Font Awesome 7 Sharp Duotone";
  --fa-font-sharp-duotone-light: normal 300 1em/1 "Font Awesome 7 Sharp Duotone";
  --fa-font-sharp-duotone-thin: normal 100 1em/1 "Font Awesome 7 Sharp Duotone";
  --fa-font-slab-regular: normal 400 1em/1 "Font Awesome 7 Slab";
  --fa-font-slab-press-regular: normal 400 1em/1 "Font Awesome 7 Slab Press";
  --fa-font-whiteboard-semibold: normal 600 1em/1 "Font Awesome 7 Whiteboard";
  --fa-font-thumbprint-light: normal 300 1em/1 "Font Awesome 7 Thumbprint";
  --fa-font-notdog-solid: normal 900 1em/1 "Font Awesome 7 Notdog";
  --fa-font-notdog-duo-solid: normal 900 1em/1 "Font Awesome 7 Notdog Duo";
  --fa-font-etch-solid: normal 900 1em/1 "Font Awesome 7 Etch";
  --fa-font-jelly-regular: normal 400 1em/1 "Font Awesome 7 Jelly";
  --fa-font-jelly-fill-regular: normal 400 1em/1 "Font Awesome 7 Jelly Fill";
  --fa-font-jelly-duo-regular: normal 400 1em/1 "Font Awesome 7 Jelly Duo";
  --fa-font-chisel-regular: normal 400 1em/1 "Font Awesome 7 Chisel";
  --fa-font-utility-semibold: normal 600 1em/1 "Font Awesome 7 Utility";
  --fa-font-utility-duo-semibold: normal 600 1em/1 "Font Awesome 7 Utility Duo";
  --fa-font-utility-fill-semibold: normal 600 1em/1 "Font Awesome 7 Utility Fill";
}

.svg-inline--fa {
  box-sizing: content-box;
  display: var(--fa-display, inline-block);
  height: 1em;
  overflow: visible;
  vertical-align: -0.125em;
  width: var(--fa-width, 1.25em);
}
.svg-inline--fa.fa-2xs {
  vertical-align: 0.1em;
}
.svg-inline--fa.fa-xs {
  vertical-align: 0em;
}
.svg-inline--fa.fa-sm {
  vertical-align: -0.0714285714em;
}
.svg-inline--fa.fa-lg {
  vertical-align: -0.2em;
}
.svg-inline--fa.fa-xl {
  vertical-align: -0.25em;
}
.svg-inline--fa.fa-2xl {
  vertical-align: -0.3125em;
}
.svg-inline--fa.fa-pull-left,
.svg-inline--fa .fa-pull-start {
  float: inline-start;
  margin-inline-end: var(--fa-pull-margin, 0.3em);
}
.svg-inline--fa.fa-pull-right,
.svg-inline--fa .fa-pull-end {
  float: inline-end;
  margin-inline-start: var(--fa-pull-margin, 0.3em);
}
.svg-inline--fa.fa-li {
  width: var(--fa-li-width, 2em);
  inset-inline-start: calc(-1 * var(--fa-li-width, 2em));
  inset-block-start: 0.25em; /* syncing vertical alignment with Web Font rendering */
}

.fa-layers-counter, .fa-layers-text {
  display: inline-block;
  position: absolute;
  text-align: center;
}

.fa-layers {
  display: inline-block;
  height: 1em;
  position: relative;
  text-align: center;
  vertical-align: -0.125em;
  width: var(--fa-width, 1.25em);
}
.fa-layers .svg-inline--fa {
  inset: 0;
  margin: auto;
  position: absolute;
  transform-origin: center center;
}

.fa-layers-text {
  left: 50%;
  top: 50%;
  transform: translate(-50%, -50%);
  transform-origin: center center;
}

.fa-layers-counter {
  background-color: var(--fa-counter-background-color, #ff253a);
  border-radius: var(--fa-counter-border-radius, 1em);
  box-sizing: border-box;
  color: var(--fa-inverse, #fff);
  line-height: var(--fa-counter-line-height, 1);
  max-width: var(--fa-counter-max-width, 5em);
  min-width: var(--fa-counter-min-width, 1.5em);
  overflow: hidden;
  padding: var(--fa-counter-padding, 0.25em 0.5em);
  right: var(--fa-right, 0);
  text-overflow: ellipsis;
  top: var(--fa-top, 0);
  transform: scale(var(--fa-counter-scale, 0.25));
  transform-origin: top right;
}

.fa-layers-bottom-right {
  bottom: var(--fa-bottom, 0);
  right: var(--fa-right, 0);
  top: auto;
  transform: scale(var(--fa-layers-scale, 0.25));
  transform-origin: bottom right;
}

.fa-layers-bottom-left {
  bottom: var(--fa-bottom, 0);
  left: var(--fa-left, 0);
  right: auto;
  top: auto;
  transform: scale(var(--fa-layers-scale, 0.25));
  transform-origin: bottom left;
}

.fa-layers-top-right {
  top: var(--fa-top, 0);
  right: var(--fa-right, 0);
  transform: scale(var(--fa-layers-scale, 0.25));
  transform-origin: top right;
}

.fa-layers-top-left {
  left: var(--fa-left, 0);
  right: auto;
  top: var(--fa-top, 0);
  transform: scale(var(--fa-layers-scale, 0.25));
  transform-origin: top left;
}

.fa-1x {
  font-size: 1em;
}

.fa-2x {
  font-size: 2em;
}

.fa-3x {
  font-size: 3em;
}

.fa-4x {
  font-size: 4em;
}

.fa-5x {
  font-size: 5em;
}

.fa-6x {
  font-size: 6em;
}

.fa-7x {
  font-size: 7em;
}

.fa-8x {
  font-size: 8em;
}

.fa-9x {
  font-size: 9em;
}

.fa-10x {
  font-size: 10em;
}

.fa-2xs {
  font-size: calc(10 / 16 * 1em); /* converts a 10px size into an em-based value that's relative to the scale's 16px base */
  line-height: calc(1 / 10 * 1em); /* sets the line-height of the icon back to that of it's parent */
  vertical-align: calc((6 / 10 - 0.375) * 1em); /* vertically centers the icon taking into account the surrounding text's descender */
}

.fa-xs {
  font-size: calc(12 / 16 * 1em); /* converts a 12px size into an em-based value that's relative to the scale's 16px base */
  line-height: calc(1 / 12 * 1em); /* sets the line-height of the icon back to that of it's parent */
  vertical-align: calc((6 / 12 - 0.375) * 1em); /* vertically centers the icon taking into account the surrounding text's descender */
}

.fa-sm {
  font-size: calc(14 / 16 * 1em); /* converts a 14px size into an em-based value that's relative to the scale's 16px base */
  line-height: calc(1 / 14 * 1em); /* sets the line-height of the icon back to that of it's parent */
  vertical-align: calc((6 / 14 - 0.375) * 1em); /* vertically centers the icon taking into account the surrounding text's descender */
}

.fa-lg {
  font-size: calc(20 / 16 * 1em); /* converts a 20px size into an em-based value that's relative to the scale's 16px base */
  line-height: calc(1 / 20 * 1em); /* sets the line-height of the icon back to that of it's parent */
  vertical-align: calc((6 / 20 - 0.375) * 1em); /* vertically centers the icon taking into account the surrounding text's descender */
}

.fa-xl {
  font-size: calc(24 / 16 * 1em); /* converts a 24px size into an em-based value that's relative to the scale's 16px base */
  line-height: calc(1 / 24 * 1em); /* sets the line-height of the icon back to that of it's parent */
  vertical-align: calc((6 / 24 - 0.375) * 1em); /* vertically centers the icon taking into account the surrounding text's descender */
}

.fa-2xl {
  font-size: calc(32 / 16 * 1em); /* converts a 32px size into an em-based value that's relative to the scale's 16px base */
  line-height: calc(1 / 32 * 1em); /* sets the line-height of the icon back to that of it's parent */
  vertical-align: calc((6 / 32 - 0.375) * 1em); /* vertically centers the icon taking into account the surrounding text's descender */
}

.fa-width-auto {
  --fa-width: auto;
}

.fa-fw,
.fa-width-fixed {
  --fa-width: 1.25em;
}

.fa-ul {
  list-style-type: none;
  margin-inline-start: var(--fa-li-margin, 2.5em);
  padding-inline-start: 0;
}
.fa-ul > li {
  position: relative;
}

.fa-li {
  inset-inline-start: calc(-1 * var(--fa-li-width, 2em));
  position: absolute;
  text-align: center;
  width: var(--fa-li-width, 2em);
  line-height: inherit;
}

/* Heads Up: Bordered Icons will not be supported in the future!
  - This feature will be deprecated in the next major release of Font Awesome (v8)!
  - You may continue to use it in this version *v7), but it will not be supported in Font Awesome v8.
*/
/* Notes:
* --@{v.$css-prefix}-border-width = 1/16 by default (to render as ~1px based on a 16px default font-size)
* --@{v.$css-prefix}-border-padding =
  ** 3/16 for vertical padding (to give ~2px of vertical whitespace around an icon considering it's vertical alignment)
  ** 4/16 for horizontal padding (to give ~4px of horizontal whitespace around an icon)
*/
.fa-border {
  border-color: var(--fa-border-color, #eee);
  border-radius: var(--fa-border-radius, 0.1em);
  border-style: var(--fa-border-style, solid);
  border-width: var(--fa-border-width, 0.0625em);
  box-sizing: var(--fa-border-box-sizing, content-box);
  padding: var(--fa-border-padding, 0.1875em 0.25em);
}

.fa-pull-left,
.fa-pull-start {
  float: inline-start;
  margin-inline-end: var(--fa-pull-margin, 0.3em);
}

.fa-pull-right,
.fa-pull-end {
  float: inline-end;
  margin-inline-start: var(--fa-pull-margin, 0.3em);
}

.fa-beat {
  animation-name: fa-beat;
  animation-delay: var(--fa-animation-delay, 0s);
  animation-direction: var(--fa-animation-direction, normal);
  animation-duration: var(--fa-animation-duration, 1s);
  animation-iteration-count: var(--fa-animation-iteration-count, infinite);
  animation-timing-function: var(--fa-animation-timing, ease-in-out);
}

.fa-bounce {
  animation-name: fa-bounce;
  animation-delay: var(--fa-animation-delay, 0s);
  animation-direction: var(--fa-animation-direction, normal);
  animation-duration: var(--fa-animation-duration, 1s);
  animation-iteration-count: var(--fa-animation-iteration-count, infinite);
  animation-timing-function: var(--fa-animation-timing, cubic-bezier(0.28, 0.84, 0.42, 1));
}

.fa-fade {
  animation-name: fa-fade;
  animation-delay: var(--fa-animation-delay, 0s);
  animation-direction: var(--fa-animation-direction, normal);
  animation-duration: var(--fa-animation-duration, 1s);
  animation-iteration-count: var(--fa-animation-iteration-count, infinite);
  animation-timing-function: var(--fa-animation-timing, cubic-bezier(0.4, 0, 0.6, 1));
}

.fa-beat-fade {
  animation-name: fa-beat-fade;
  animation-delay: var(--fa-animation-delay, 0s);
  animation-direction: var(--fa-animation-direction, normal);
  animation-duration: var(--fa-animation-duration, 1s);
  animation-iteration-count: var(--fa-animation-iteration-count, infinite);
  animation-timing-function: var(--fa-animation-timing, cubic-bezier(0.4, 0, 0.6, 1));
}

.fa-flip {
  animation-name: fa-flip;
  animation-delay: var(--fa-animation-delay, 0s);
  animation-direction: var(--fa-animation-direction, normal);
  animation-duration: var(--fa-animation-duration, 1s);
  animation-iteration-count: var(--fa-animation-iteration-count, infinite);
  animation-timing-function: var(--fa-animation-timing, ease-in-out);
}

.fa-shake {
  animation-name: fa-shake;
  animation-delay: var(--fa-animation-delay, 0s);
  animation-direction: var(--fa-animation-direction, normal);
  animation-duration: var(--fa-animation-duration, 1s);
  animation-iteration-count: var(--fa-animation-iteration-count, infinite);
  animation-timing-function: var(--fa-animation-timing, linear);
}

.fa-spin {
  animation-name: fa-spin;
  animation-delay: var(--fa-animation-delay, 0s);
  animation-direction: var(--fa-animation-direction, normal);
  animation-duration: var(--fa-animation-duration, 2s);
  animation-iteration-count: var(--fa-animation-iteration-count, infinite);
  animation-timing-function: var(--fa-animation-timing, linear);
}

.fa-spin-reverse {
  --fa-animation-direction: reverse;
}

.fa-pulse,
.fa-spin-pulse {
  animation-name: fa-spin;
  animation-direction: var(--fa-animation-direction, normal);
  animation-duration: var(--fa-animation-duration, 1s);
  animation-iteration-count: var(--fa-animation-iteration-count, infinite);
  animation-timing-function: var(--fa-animation-timing, steps(8));
}

@media (prefers-reduced-motion: reduce) {
  .fa-beat,
  .fa-bounce,
  .fa-fade,
  .fa-beat-fade,
  .fa-flip,
  .fa-pulse,
  .fa-shake,
  .fa-spin,
  .fa-spin-pulse {
    animation: none !important;
    transition: none !important;
  }
}
@keyframes fa-beat {
  0%, 90% {
    transform: scale(1);
  }
  45% {
    transform: scale(var(--fa-beat-scale, 1.25));
  }
}
@keyframes fa-bounce {
  0% {
    transform: scale(1, 1) translateY(0);
  }
  10% {
    transform: scale(var(--fa-bounce-start-scale-x, 1.1), var(--fa-bounce-start-scale-y, 0.9)) translateY(0);
  }
  30% {
    transform: scale(var(--fa-bounce-jump-scale-x, 0.9), var(--fa-bounce-jump-scale-y, 1.1)) translateY(var(--fa-bounce-height, -0.5em));
  }
  50% {
    transform: scale(var(--fa-bounce-land-scale-x, 1.05), var(--fa-bounce-land-scale-y, 0.95)) translateY(0);
  }
  57% {
    transform: scale(1, 1) translateY(var(--fa-bounce-rebound, -0.125em));
  }
  64% {
    transform: scale(1, 1) translateY(0);
  }
  100% {
    transform: scale(1, 1) translateY(0);
  }
}
@keyframes fa-fade {
  50% {
    opacity: var(--fa-fade-opacity, 0.4);
  }
}
@keyframes fa-beat-fade {
  0%, 100% {
    opacity: var(--fa-beat-fade-opacity, 0.4);
    transform: scale(1);
  }
  50% {
    opacity: 1;
    transform: scale(var(--fa-beat-fade-scale, 1.125));
  }
}
@keyframes fa-flip {
  50% {
    transform: rotate3d(var(--fa-flip-x, 0), var(--fa-flip-y, 1), var(--fa-flip-z, 0), var(--fa-flip-angle, -180deg));
  }
}
@keyframes fa-shake {
  0% {
    transform: rotate(-15deg);
  }
  4% {
    transform: rotate(15deg);
  }
  8%, 24% {
    transform: rotate(-18deg);
  }
  12%, 28% {
    transform: rotate(18deg);
  }
  16% {
    transform: rotate(-22deg);
  }
  20% {
    transform: rotate(22deg);
  }
  32% {
    transform: rotate(-12deg);
  }
  36% {
    transform: rotate(12deg);
  }
  40%, 100% {
    transform: rotate(0deg);
  }
}
@keyframes fa-spin {
  0% {
    transform: rotate(0deg);
  }
  100% {
    transform: rotate(360deg);
  }
}
.fa-rotate-90 {
  transform: rotate(90deg);
}

.fa-rotate-180 {
  transform: rotate(180deg);
}

.fa-rotate-270 {
  transform: rotate(270deg);
}

.fa-flip-horizontal {
  transform: scale(-1, 1);
}

.fa-flip-vertical {
  transform: scale(1, -1);
}

.fa-flip-both,
.fa-flip-horizontal.fa-flip-vertical {
  transform: scale(-1, -1);
}

.fa-rotate-by {
  transform: rotate(var(--fa-rotate-angle, 0));
}

.svg-inline--fa .fa-primary {
  fill: var(--fa-primary-color, currentColor);
  opacity: var(--fa-primary-opacity, 1);
}

.svg-inline--fa .fa-secondary {
  fill: var(--fa-secondary-color, currentColor);
  opacity: var(--fa-secondary-opacity, 0.4);
}

.svg-inline--fa.fa-swap-opacity .fa-primary {
  opacity: var(--fa-secondary-opacity, 0.4);
}

.svg-inline--fa.fa-swap-opacity .fa-secondary {
  opacity: var(--fa-primary-opacity, 1);
}

.svg-inline--fa mask .fa-primary,
.svg-inline--fa mask .fa-secondary {
  fill: black;
}

.svg-inline--fa.fa-inverse {
  fill: var(--fa-inverse, #fff);
}

.fa-stack {
  display: inline-block;
  height: 2em;
  line-height: 2em;
  position: relative;
  vertical-align: middle;
  width: 2.5em;
}

.fa-inverse {
  color: var(--fa-inverse, #fff);
}

.svg-inline--fa.fa-stack-1x {
  --fa-width: 1.25em;
  height: 1em;
  width: var(--fa-width);
}
.svg-inline--fa.fa-stack-2x {
  --fa-width: 2.5em;
  height: 2em;
  width: var(--fa-width);
}

.fa-stack-1x,
.fa-stack-2x {
  inset: 0;
  margin: auto;
  position: absolute;
  z-index: var(--fa-stack-z-index, auto);
}`;
function OF() {
  var e = bF, t = wF, n = ct.cssPrefix, r = ct.replacementClass, a = yre;
  if (n !== e || r !== t) {
    var s = new RegExp("\\.".concat(e, "\\-"), "g"), l = new RegExp("\\--".concat(e, "\\-"), "g"), c = new RegExp("\\.".concat(t), "g");
    a = a.replace(s, ".".concat(n, "-")).replace(l, "--".concat(n, "-")).replace(c, ".".concat(r));
  }
  return a;
}
var QP = !1;
function fM() {
  ct.autoAddCss && !QP && (pre(OF()), QP = !0);
}
var bre = {
  mixout: function() {
    return {
      dom: {
        css: OF,
        insertCss: fM
      }
    };
  },
  hooks: function() {
    return {
      beforeDOMElementCreation: function() {
        fM();
      },
      beforeI2svg: function() {
        fM();
      }
    };
  }
}, xc = id || {};
xc[wc] || (xc[wc] = {});
xc[wc].styles || (xc[wc].styles = {});
xc[wc].hooks || (xc[wc].hooks = {});
xc[wc].shims || (xc[wc].shims = []);
var Ds = xc[wc], MF = [], NF = function() {
  ir.removeEventListener("DOMContentLoaded", NF), e_ = 1, MF.map(function(e) {
    return e();
  });
}, e_ = !1;
Mc && (e_ = (ir.documentElement.doScroll ? /^loaded|^c/ : /^loaded|^i|^c/).test(ir.readyState), e_ || ir.addEventListener("DOMContentLoaded", NF));
function wre(e) {
  Mc && (e_ ? setTimeout(e, 0) : MF.push(e));
}
function iS(e) {
  var t = e.tag, n = e.attributes, r = n === void 0 ? {} : n, a = e.children, s = a === void 0 ? [] : a;
  return typeof e == "string" ? CF(e) : "<".concat(t, " ").concat(hre(r), ">").concat(s.map(iS).join(""), "</").concat(t, ">");
}
function JP(e, t, n) {
  if (e && e[t] && e[t][n])
    return {
      prefix: t,
      iconName: n,
      icon: e[t][n]
    };
}
var pM = function(e, t, n, r) {
  var a = Object.keys(e), s = a.length, l = t, c, d, p;
  for (n === void 0 ? (c = 1, p = e[a[0]]) : (c = 0, p = n); c < s; c++)
    d = a[c], p = l(p, e[d], d, e);
  return p;
};
function RF(e) {
  return Fs(e).length !== 1 ? null : e.codePointAt(0).toString(16);
}
function ZP(e) {
  return Object.keys(e).reduce(function(t, n) {
    var r = e[n], a = !!r.icon;
    return a ? t[r.iconName] = r.icon : t[n] = r, t;
  }, {});
}
function d5(e, t) {
  var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, r = n.skipHooks, a = r === void 0 ? !1 : r, s = ZP(t);
  typeof Ds.hooks.addPack == "function" && !a ? Ds.hooks.addPack(e, ZP(t)) : Ds.styles[e] = De(De({}, Ds.styles[e] || {}), s), e === "fas" && d5("fa", t);
}
var mx = Ds.styles, xre = Ds.shims, AF = Object.keys(yR), Sre = AF.reduce(function(e, t) {
  return e[t] = Object.keys(yR[t]), e;
}, {}), xR = null, jF = {}, PF = {}, DF = {}, $F = {}, TF = {};
function kre(e) {
  return ~lre.indexOf(e);
}
function _re(e, t) {
  var n = t.split("-"), r = n[0], a = n.slice(1).join("-");
  return r === e && a !== "" && !kre(a) ? a : null;
}
var LF = function() {
  var e = function(r) {
    return pM(mx, function(a, s, l) {
      return a[l] = pM(s, r, {}), a;
    }, {});
  };
  jF = e(function(r, a, s) {
    if (a[3] && (r[a[3]] = s), a[2]) {
      var l = a[2].filter(function(c) {
        return typeof c == "number";
      });
      l.forEach(function(c) {
        r[c.toString(16)] = s;
      });
    }
    return r;
  }), PF = e(function(r, a, s) {
    if (r[s] = s, a[2]) {
      var l = a[2].filter(function(c) {
        return typeof c == "string";
      });
      l.forEach(function(c) {
        r[c] = s;
      });
    }
    return r;
  }), TF = e(function(r, a, s) {
    var l = a[2];
    return r[s] = s, l.forEach(function(c) {
      r[c] = s;
    }), r;
  });
  var t = "far" in mx || ct.autoFetchSvg, n = pM(xre, function(r, a) {
    var s = a[0], l = a[1], c = a[2];
    return l === "far" && !t && (l = "fas"), typeof s == "string" && (r.names[s] = {
      prefix: l,
      iconName: c
    }), typeof s == "number" && (r.unicodes[s.toString(16)] = {
      prefix: l,
      iconName: c
    }), r;
  }, {
    names: {},
    unicodes: {}
  });
  DF = n.names, $F = n.unicodes, xR = x2(ct.styleDefault, {
    family: ct.familyDefault
  });
};
fre(function(e) {
  xR = x2(e.styleDefault, {
    family: ct.familyDefault
  });
});
LF();
function SR(e, t) {
  return (jF[e] || {})[t];
}
function Ere(e, t) {
  return (PF[e] || {})[t];
}
function em(e, t) {
  return (TF[e] || {})[t];
}
function IF(e) {
  return DF[e] || {
    prefix: null,
    iconName: null
  };
}
function Cre(e) {
  var t = $F[e], n = SR("fas", e);
  return t || (n ? {
    prefix: "fas",
    iconName: n
  } : null) || {
    prefix: null,
    iconName: null
  };
}
function sd() {
  return xR;
}
var zF = function() {
  return {
    prefix: null,
    iconName: null,
    rest: []
  };
};
function Ore(e) {
  var t = $o, n = AF.reduce(function(r, a) {
    return r[a] = "".concat(ct.cssPrefix, "-").concat(a), r;
  }, {});
  return hF.forEach(function(r) {
    (e.includes(n[r]) || e.some(function(a) {
      return Sre[r].includes(a);
    })) && (t = r);
  }), t;
}
function x2(e) {
  var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, n = t.family, r = n === void 0 ? $o : n, a = rre[r][e];
  if (r === oS && !e)
    return "fad";
  var s = XP[r][e] || XP[r][a], l = e in Ds.styles ? e : null, c = s || l || null;
  return c;
}
function Mre(e) {
  var t = [], n = null;
  return e.forEach(function(r) {
    var a = _re(ct.cssPrefix, r);
    a ? n = a : r && t.push(r);
  }), {
    iconName: n,
    rest: t
  };
}
function eD(e) {
  return e.sort().filter(function(t, n, r) {
    return r.indexOf(t) === n;
  });
}
var tD = vF.concat(gF);
function S2(e) {
  var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, n = t.skipLookups, r = n === void 0 ? !1 : n, a = null, s = eD(e.filter(function(y) {
    return tD.includes(y);
  })), l = eD(e.filter(function(y) {
    return !tD.includes(y);
  })), c = s.filter(function(y) {
    return a = y, !J9.includes(y);
  }), d = b2(c, 1), p = d[0], m = p === void 0 ? null : p, h = Ore(s), v = De(De({}, Mre(l)), {}, {
    prefix: x2(m, {
      family: h
    })
  });
  return De(De(De({}, v), jre({
    values: e,
    family: h,
    styles: mx,
    config: ct,
    canonical: v,
    givenPrefix: a
  })), Nre(r, a, v));
}
function Nre(e, t, n) {
  var r = n.prefix, a = n.iconName;
  if (e || !r || !a)
    return {
      prefix: r,
      iconName: a
    };
  var s = t === "fa" ? IF(a) : {}, l = em(r, a);
  return a = s.iconName || l || a, r = s.prefix || r, r === "far" && !mx.far && mx.fas && !ct.autoFetchSvg && (r = "fas"), {
    prefix: r,
    iconName: a
  };
}
var Rre = hF.filter(function(e) {
  return e !== $o || e !== oS;
}), Are = Object.keys(a5).filter(function(e) {
  return e !== $o;
}).map(function(e) {
  return Object.keys(a5[e]);
}).flat();
function jre(e) {
  var t = e.values, n = e.family, r = e.canonical, a = e.givenPrefix, s = a === void 0 ? "" : a, l = e.styles, c = l === void 0 ? {} : l, d = e.config, p = d === void 0 ? {} : d, m = n === oS, h = t.includes("fa-duotone") || t.includes("fad"), v = p.familyDefault === "duotone", y = r.prefix === "fad" || r.prefix === "fa-duotone";
  if (!m && (h || v || y) && (r.prefix = "fad"), (t.includes("fa-brands") || t.includes("fab")) && (r.prefix = "fab"), !r.prefix && Rre.includes(n)) {
    var w = Object.keys(c).find(function(b) {
      return Are.includes(b);
    });
    if (w || p.autoFetchSvg) {
      var x = Xte.get(n).defaultShortPrefixId;
      r.prefix = x, r.iconName = em(r.prefix, r.iconName) || r.iconName;
    }
  }
  return (r.prefix === "fa" || s === "fa") && (r.prefix = sd() || "fas"), r;
}
var Pre = /* @__PURE__ */ (function() {
  function e() {
    vte(this, e), this.definitions = {};
  }
  return bte(e, [{
    key: "add",
    value: function() {
      for (var t = this, n = arguments.length, r = new Array(n), a = 0; a < n; a++)
        r[a] = arguments[a];
      var s = r.reduce(this._pullDefinitions, {});
      Object.keys(s).forEach(function(l) {
        t.definitions[l] = De(De({}, t.definitions[l] || {}), s[l]), d5(l, s[l]);
        var c = yR[$o][l];
        c && d5(c, s[l]), LF();
      });
    }
  }, {
    key: "reset",
    value: function() {
      this.definitions = {};
    }
  }, {
    key: "_pullDefinitions",
    value: function(t, n) {
      var r = n.prefix && n.iconName && n.icon ? {
        0: n
      } : n;
      return Object.keys(r).map(function(a) {
        var s = r[a], l = s.prefix, c = s.iconName, d = s.icon, p = d[2];
        t[l] || (t[l] = {}), p.length > 0 && p.forEach(function(m) {
          typeof m == "string" && (t[l][m] = d);
        }), t[l][c] = d;
      }), t;
    }
  }]);
})(), nD = [], dh = {}, xh = {}, Dre = Object.keys(xh);
function $re(e, t) {
  var n = t.mixoutsTo;
  return nD = e, dh = {}, Object.keys(xh).forEach(function(r) {
    Dre.indexOf(r) === -1 && delete xh[r];
  }), nD.forEach(function(r) {
    var a = r.mixout ? r.mixout() : {};
    if (Object.keys(a).forEach(function(l) {
      typeof a[l] == "function" && (n[l] = a[l]), Z0(a[l]) === "object" && Object.keys(a[l]).forEach(function(c) {
        n[l] || (n[l] = {}), n[l][c] = a[l][c];
      });
    }), r.hooks) {
      var s = r.hooks();
      Object.keys(s).forEach(function(l) {
        dh[l] || (dh[l] = []), dh[l].push(s[l]);
      });
    }
    r.provides && r.provides(xh);
  }), n;
}
function f5(e, t) {
  for (var n = arguments.length, r = new Array(n > 2 ? n - 2 : 0), a = 2; a < n; a++)
    r[a - 2] = arguments[a];
  var s = dh[e] || [];
  return s.forEach(function(l) {
    t = l.apply(null, [t].concat(r));
  }), t;
}
function lm(e) {
  for (var t = arguments.length, n = new Array(t > 1 ? t - 1 : 0), r = 1; r < t; r++)
    n[r - 1] = arguments[r];
  var a = dh[e] || [];
  a.forEach(function(s) {
    s.apply(null, n);
  });
}
function ld() {
  var e = arguments[0], t = Array.prototype.slice.call(arguments, 1);
  return xh[e] ? xh[e].apply(null, t) : void 0;
}
function p5(e) {
  e.prefix === "fa" && (e.prefix = "fas");
  var t = e.iconName, n = e.prefix || sd();
  if (t)
    return t = em(n, t) || t, JP(FF.definitions, n, t) || JP(Ds.styles, n, t);
}
var FF = new Pre(), Tre = function() {
  ct.autoReplaceSvg = !1, ct.observeMutations = !1, lm("noAuto");
}, Lre = {
  i2svg: function() {
    var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    return Mc ? (lm("beforeI2svg", e), ld("pseudoElements2svg", e), ld("i2svg", e)) : Promise.reject(new Error("Operation requires a DOM of some kind."));
  },
  watch: function() {
    var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, t = e.autoReplaceSvgRoot;
    ct.autoReplaceSvg === !1 && (ct.autoReplaceSvg = !0), ct.observeMutations = !0, wre(function() {
      zre({
        autoReplaceSvgRoot: t
      }), lm("watch", e);
    });
  }
}, Ire = {
  icon: function(e) {
    if (e === null)
      return null;
    if (Z0(e) === "object" && e.prefix && e.iconName)
      return {
        prefix: e.prefix,
        iconName: em(e.prefix, e.iconName) || e.iconName
      };
    if (Array.isArray(e) && e.length === 2) {
      var t = e[1].indexOf("fa-") === 0 ? e[1].slice(3) : e[1], n = x2(e[0]);
      return {
        prefix: n,
        iconName: em(n, t) || t
      };
    }
    if (typeof e == "string" && (e.indexOf("".concat(ct.cssPrefix, "-")) > -1 || e.match(ore))) {
      var r = S2(e.split(" "), {
        skipLookups: !0
      });
      return {
        prefix: r.prefix || sd(),
        iconName: em(r.prefix, r.iconName) || r.iconName
      };
    }
    if (typeof e == "string") {
      var a = sd();
      return {
        prefix: a,
        iconName: em(a, e) || e
      };
    }
  }
}, Si = {
  noAuto: Tre,
  config: ct,
  dom: Lre,
  parse: Ire,
  library: FF,
  findIconDefinition: p5,
  toHtml: iS
}, zre = function() {
  var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, t = e.autoReplaceSvgRoot, n = t === void 0 ? ir : t;
  (Object.keys(Ds.styles).length > 0 || ct.autoFetchSvg) && Mc && ct.autoReplaceSvg && Si.dom.i2svg({
    node: n
  });
};
function k2(e, t) {
  return Object.defineProperty(e, "abstract", {
    get: t
  }), Object.defineProperty(e, "html", {
    get: function() {
      return e.abstract.map(function(n) {
        return iS(n);
      });
    }
  }), Object.defineProperty(e, "node", {
    get: function() {
      if (Mc) {
        var n = ir.createElement("div");
        return n.innerHTML = e.html, n.children;
      }
    }
  }), e;
}
function Fre(e) {
  var t = e.children, n = e.main, r = e.mask, a = e.attributes, s = e.styles, l = e.transform;
  if (wR(l) && n.found && !r.found) {
    var c = n.width, d = n.height, p = {
      x: c / d / 2,
      y: 0.5
    };
    a.style = w2(De(De({}, s), {}, {
      "transform-origin": "".concat(p.x + l.x / 16, "em ").concat(p.y + l.y / 16, "em")
    }));
  }
  return [{
    tag: "svg",
    attributes: a,
    children: t
  }];
}
function Bre(e) {
  var t = e.prefix, n = e.iconName, r = e.children, a = e.attributes, s = e.symbol, l = s === !0 ? "".concat(t, "-").concat(ct.cssPrefix, "-").concat(n) : s;
  return [{
    tag: "svg",
    attributes: {
      style: "display: none;"
    },
    children: [{
      tag: "symbol",
      attributes: De(De({}, a), {}, {
        id: l
      }),
      children: r
    }]
  }];
}
function Ure(e) {
  var t = ["aria-label", "aria-labelledby", "title", "role"];
  return t.some(function(n) {
    return n in e;
  });
}
function kR(e) {
  var t = e.icons, n = t.main, r = t.mask, a = e.prefix, s = e.iconName, l = e.transform, c = e.symbol, d = e.maskId, p = e.extra, m = e.watchable, h = m === void 0 ? !1 : m, v = r.found ? r : n, y = v.width, w = v.height, x = [ct.replacementClass, s ? "".concat(ct.cssPrefix, "-").concat(s) : ""].filter(function(N) {
    return p.classes.indexOf(N) === -1;
  }).filter(function(N) {
    return N !== "" || !!N;
  }).concat(p.classes).join(" "), b = {
    children: [],
    attributes: De(De({}, p.attributes), {}, {
      "data-prefix": a,
      "data-icon": s,
      class: x,
      role: p.attributes.role || "img",
      viewBox: "0 0 ".concat(y, " ").concat(w)
    })
  };
  !Ure(p.attributes) && !p.attributes["aria-hidden"] && (b.attributes["aria-hidden"] = "true"), h && (b.attributes[sm] = "");
  var k = De(De({}, b), {}, {
    prefix: a,
    iconName: s,
    main: n,
    mask: r,
    maskId: d,
    transform: l,
    symbol: c,
    styles: De({}, p.styles)
  }), C = r.found && n.found ? ld("generateAbstractMask", k) || {
    children: [],
    attributes: {}
  } : ld("generateAbstractIcon", k) || {
    children: [],
    attributes: {}
  }, _ = C.children, O = C.attributes;
  return k.children = _, k.attributes = O, c ? Bre(k) : Fre(k);
}
function rD(e) {
  var t = e.content, n = e.width, r = e.height, a = e.transform, s = e.extra, l = e.watchable, c = l === void 0 ? !1 : l, d = De(De({}, s.attributes), {}, {
    class: s.classes.join(" ")
  });
  c && (d[sm] = "");
  var p = De({}, s.styles);
  wR(a) && (p.transform = vre({
    transform: a,
    width: n,
    height: r
  }), p["-webkit-transform"] = p.transform);
  var m = w2(p);
  m.length > 0 && (d.style = m);
  var h = [];
  return h.push({
    tag: "span",
    attributes: d,
    children: [t]
  }), h;
}
function Vre(e) {
  var t = e.content, n = e.extra, r = De(De({}, n.attributes), {}, {
    class: n.classes.join(" ")
  }), a = w2(n.styles);
  a.length > 0 && (r.style = a);
  var s = [];
  return s.push({
    tag: "span",
    attributes: r,
    children: [t]
  }), s;
}
var mM = Ds.styles;
function m5(e) {
  var t = e[0], n = e[1], r = e.slice(4), a = b2(r, 1), s = a[0], l = null;
  return Array.isArray(s) ? l = {
    tag: "g",
    attributes: {
      class: "".concat(ct.cssPrefix, "-").concat(dM.GROUP)
    },
    children: [{
      tag: "path",
      attributes: {
        class: "".concat(ct.cssPrefix, "-").concat(dM.SECONDARY),
        fill: "currentColor",
        d: s[0]
      }
    }, {
      tag: "path",
      attributes: {
        class: "".concat(ct.cssPrefix, "-").concat(dM.PRIMARY),
        fill: "currentColor",
        d: s[1]
      }
    }]
  } : l = {
    tag: "path",
    attributes: {
      fill: "currentColor",
      d: s
    }
  }, {
    found: !0,
    width: t,
    height: n,
    icon: l
  };
}
var Hre = {
  found: !1,
  width: 512,
  height: 512
};
function qre(e, t) {
  !SF && !ct.showMissingIcons && e && console.error('Icon with name "'.concat(e, '" and prefix "').concat(t, '" is missing.'));
}
function h5(e, t) {
  var n = t;
  return t === "fa" && ct.styleDefault !== null && (t = sd()), new Promise(function(r, a) {
    if (n === "fa") {
      var s = IF(e) || {};
      e = s.iconName || e, t = s.prefix || t;
    }
    if (e && t && mM[t] && mM[t][e]) {
      var l = mM[t][e];
      return r(m5(l));
    }
    qre(e, t), r(De(De({}, Hre), {}, {
      icon: ct.showMissingIcons && e ? ld("missingIconAbstract") || {} : {}
    }));
  });
}
var oD = function() {
}, g5 = ct.measurePerformance && YS && YS.mark && YS.measure ? YS : {
  mark: oD,
  measure: oD
}, Pw = 'FA "7.1.0"', Wre = function(e) {
  return g5.mark("".concat(Pw, " ").concat(e, " begins")), function() {
    return BF(e);
  };
}, BF = function(e) {
  g5.mark("".concat(Pw, " ").concat(e, " ends")), g5.measure("".concat(Pw, " ").concat(e), "".concat(Pw, " ").concat(e, " begins"), "".concat(Pw, " ").concat(e, " ends"));
}, _R = {
  begin: Wre,
  end: BF
}, _0 = function() {
};
function aD(e) {
  var t = e.getAttribute ? e.getAttribute(sm) : null;
  return typeof t == "string";
}
function Gre(e) {
  var t = e.getAttribute ? e.getAttribute(gR) : null, n = e.getAttribute ? e.getAttribute(vR) : null;
  return t && n;
}
function Kre(e) {
  return e && e.classList && e.classList.contains && e.classList.contains(ct.replacementClass);
}
function Xre() {
  if (ct.autoReplaceSvg === !0)
    return E0.replace;
  var e = E0[ct.autoReplaceSvg];
  return e || E0.replace;
}
function Yre(e) {
  return ir.createElementNS("http://www.w3.org/2000/svg", e);
}
function Qre(e) {
  return ir.createElement(e);
}
function UF(e) {
  var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, n = t.ceFn, r = n === void 0 ? e.tag === "svg" ? Yre : Qre : n;
  if (typeof e == "string")
    return ir.createTextNode(e);
  var a = r(e.tag);
  Object.keys(e.attributes || []).forEach(function(l) {
    a.setAttribute(l, e.attributes[l]);
  });
  var s = e.children || [];
  return s.forEach(function(l) {
    a.appendChild(UF(l, {
      ceFn: r
    }));
  }), a;
}
function Jre(e) {
  var t = " ".concat(e.outerHTML, " ");
  return t = "".concat(t, "Font Awesome fontawesome.com "), t;
}
var E0 = {
  replace: function(e) {
    var t = e[0];
    if (t.parentNode)
      if (e[1].forEach(function(r) {
        t.parentNode.insertBefore(UF(r), t);
      }), t.getAttribute(sm) === null && ct.keepOriginalSource) {
        var n = ir.createComment(Jre(t));
        t.parentNode.replaceChild(n, t);
      } else
        t.remove();
  },
  nest: function(e) {
    var t = e[0], n = e[1];
    if (~bR(t).indexOf(ct.replacementClass))
      return E0.replace(e);
    var r = new RegExp("".concat(ct.cssPrefix, "-.*"));
    if (delete n[0].attributes.id, n[0].attributes.class) {
      var a = n[0].attributes.class.split(" ").reduce(function(l, c) {
        return c === ct.replacementClass || c.match(r) ? l.toSvg.push(c) : l.toNode.push(c), l;
      }, {
        toNode: [],
        toSvg: []
      });
      n[0].attributes.class = a.toSvg.join(" "), a.toNode.length === 0 ? t.removeAttribute("class") : t.setAttribute("class", a.toNode.join(" "));
    }
    var s = n.map(function(l) {
      return iS(l);
    }).join(`
`);
    t.setAttribute(sm, ""), t.innerHTML = s;
  }
};
function iD(e) {
  e();
}
function VF(e, t) {
  var n = typeof t == "function" ? t : _0;
  if (e.length === 0)
    n();
  else {
    var r = iD;
    ct.mutateApproach === tre && (r = id.requestAnimationFrame || iD), r(function() {
      var a = Xre(), s = _R.begin("mutate");
      e.map(a), s(), n();
    });
  }
}
var ER = !1;
function HF() {
  ER = !0;
}
function v5() {
  ER = !1;
}
var t_ = null;
function sD(e) {
  if (qP && ct.observeMutations) {
    var t = e.treeCallback, n = t === void 0 ? _0 : t, r = e.nodeCallback, a = r === void 0 ? _0 : r, s = e.pseudoElementsCallback, l = s === void 0 ? _0 : s, c = e.observeMutationsRoot, d = c === void 0 ? ir : c;
    t_ = new qP(function(p) {
      if (!ER) {
        var m = sd();
        ng(p).forEach(function(h) {
          if (h.type === "childList" && h.addedNodes.length > 0 && !aD(h.addedNodes[0]) && (ct.searchPseudoElements && l(h.target), n(h.target)), h.type === "attributes" && h.target.parentNode && ct.searchPseudoElements && l([h.target], !0), h.type === "attributes" && aD(h.target) && ~sre.indexOf(h.attributeName))
            if (h.attributeName === "class" && Gre(h.target)) {
              var v = S2(bR(h.target)), y = v.prefix, w = v.iconName;
              h.target.setAttribute(gR, y || m), w && h.target.setAttribute(vR, w);
            } else Kre(h.target) && a(h.target);
        });
      }
    }), Mc && t_.observe(d, {
      childList: !0,
      attributes: !0,
      characterData: !0,
      subtree: !0
    });
  }
}
function Zre() {
  t_ && t_.disconnect();
}
function eoe(e) {
  var t = e.getAttribute("style"), n = [];
  return t && (n = t.split(";").reduce(function(r, a) {
    var s = a.split(":"), l = s[0], c = s.slice(1);
    return l && c.length > 0 && (r[l] = c.join(":").trim()), r;
  }, {})), n;
}
function toe(e) {
  var t = e.getAttribute("data-prefix"), n = e.getAttribute("data-icon"), r = e.innerText !== void 0 ? e.innerText.trim() : "", a = S2(bR(e));
  return a.prefix || (a.prefix = sd()), t && n && (a.prefix = t, a.iconName = n), a.iconName && a.prefix || (a.prefix && r.length > 0 && (a.iconName = Ere(a.prefix, e.innerText) || SR(a.prefix, RF(e.innerText))), !a.iconName && ct.autoFetchSvg && e.firstChild && e.firstChild.nodeType === Node.TEXT_NODE && (a.iconName = e.firstChild.data)), a;
}
function noe(e) {
  var t = ng(e.attributes).reduce(function(n, r) {
    return n.name !== "class" && n.name !== "style" && (n[r.name] = r.value), n;
  }, {});
  return t;
}
function roe() {
  return {
    iconName: null,
    prefix: null,
    transform: fl,
    symbol: !1,
    mask: {
      iconName: null,
      prefix: null,
      rest: []
    },
    maskId: null,
    extra: {
      classes: [],
      styles: {},
      attributes: {}
    }
  };
}
function lD(e) {
  var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
    styleParser: !0
  }, n = toe(e), r = n.iconName, a = n.prefix, s = n.rest, l = noe(e), c = f5("parseNodeAttributes", {}, e), d = t.styleParser ? eoe(e) : [];
  return De({
    iconName: r,
    prefix: a,
    transform: fl,
    mask: {
      iconName: null,
      prefix: null,
      rest: []
    },
    maskId: null,
    symbol: !1,
    extra: {
      classes: s,
      styles: d,
      attributes: l
    }
  }, c);
}
var ooe = Ds.styles;
function qF(e) {
  var t = ct.autoReplaceSvg === "nest" ? lD(e, {
    styleParser: !1
  }) : lD(e);
  return ~t.extra.classes.indexOf(_F) ? ld("generateLayersText", e, t) : ld("generateSvgReplacementMutation", e, t);
}
function aoe() {
  return [].concat(Fs(gF), Fs(vF));
}
function uD(e) {
  var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
  if (!Mc) return Promise.resolve();
  var n = ir.documentElement.classList, r = function(m) {
    return n.add("".concat(KP, "-").concat(m));
  }, a = function(m) {
    return n.remove("".concat(KP, "-").concat(m));
  }, s = ct.autoFetchSvg ? aoe() : J9.concat(Object.keys(ooe));
  s.includes("fa") || s.push("fa");
  var l = [".".concat(_F, ":not([").concat(sm, "])")].concat(s.map(function(m) {
    return ".".concat(m, ":not([").concat(sm, "])");
  })).join(", ");
  if (l.length === 0)
    return Promise.resolve();
  var c = [];
  try {
    c = ng(e.querySelectorAll(l));
  } catch {
  }
  if (c.length > 0)
    r("pending"), a("complete");
  else
    return Promise.resolve();
  var d = _R.begin("onTree"), p = c.reduce(function(m, h) {
    try {
      var v = qF(h);
      v && m.push(v);
    } catch (y) {
      SF || y.name === "MissingIcon" && console.error(y);
    }
    return m;
  }, []);
  return new Promise(function(m, h) {
    Promise.all(p).then(function(v) {
      VF(v, function() {
        r("active"), r("complete"), a("pending"), typeof t == "function" && t(), d(), m();
      });
    }).catch(function(v) {
      d(), h(v);
    });
  });
}
function ioe(e) {
  var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
  qF(e).then(function(n) {
    n && VF([n], t);
  });
}
function soe(e) {
  return function(t) {
    var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, r = (t || {}).icon ? t : p5(t || {}), a = n.mask;
    return a && (a = (a || {}).icon ? a : p5(a || {})), e(r, De(De({}, n), {}, {
      mask: a
    }));
  };
}
var loe = function(e) {
  var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, n = t.transform, r = n === void 0 ? fl : n, a = t.symbol, s = a === void 0 ? !1 : a, l = t.mask, c = l === void 0 ? null : l, d = t.maskId, p = d === void 0 ? null : d, m = t.classes, h = m === void 0 ? [] : m, v = t.attributes, y = v === void 0 ? {} : v, w = t.styles, x = w === void 0 ? {} : w;
  if (e) {
    var b = e.prefix, k = e.iconName, C = e.icon;
    return k2(De({
      type: "icon"
    }, e), function() {
      return lm("beforeDOMElementCreation", {
        iconDefinition: e,
        params: t
      }), kR({
        icons: {
          main: m5(C),
          mask: c ? m5(c.icon) : {
            found: !1,
            width: null,
            height: null,
            icon: {}
          }
        },
        prefix: b,
        iconName: k,
        transform: De(De({}, fl), r),
        symbol: s,
        maskId: p,
        extra: {
          attributes: y,
          styles: x,
          classes: h
        }
      });
    });
  }
}, uoe = {
  mixout: function() {
    return {
      icon: soe(loe)
    };
  },
  hooks: function() {
    return {
      mutationObserverCallbacks: function(e) {
        return e.treeCallback = uD, e.nodeCallback = ioe, e;
      }
    };
  },
  provides: function(e) {
    e.i2svg = function(t) {
      var n = t.node, r = n === void 0 ? ir : n, a = t.callback, s = a === void 0 ? function() {
      } : a;
      return uD(r, s);
    }, e.generateSvgReplacementMutation = function(t, n) {
      var r = n.iconName, a = n.prefix, s = n.transform, l = n.symbol, c = n.mask, d = n.maskId, p = n.extra;
      return new Promise(function(m, h) {
        Promise.all([h5(r, a), c.iconName ? h5(c.iconName, c.prefix) : Promise.resolve({
          found: !1,
          width: 512,
          height: 512,
          icon: {}
        })]).then(function(v) {
          var y = b2(v, 2), w = y[0], x = y[1];
          m([t, kR({
            icons: {
              main: w,
              mask: x
            },
            prefix: a,
            iconName: r,
            transform: s,
            symbol: l,
            maskId: d,
            extra: p,
            watchable: !0
          })]);
        }).catch(h);
      });
    }, e.generateAbstractIcon = function(t) {
      var n = t.children, r = t.attributes, a = t.main, s = t.transform, l = t.styles, c = w2(l);
      c.length > 0 && (r.style = c);
      var d;
      return wR(s) && (d = ld("generateAbstractTransformGrouping", {
        main: a,
        transform: s,
        containerWidth: a.width,
        iconWidth: a.width
      })), n.push(d || a.icon), {
        children: n,
        attributes: r
      };
    };
  }
}, coe = {
  mixout: function() {
    return {
      layer: function(e) {
        var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, n = t.classes, r = n === void 0 ? [] : n;
        return k2({
          type: "layer"
        }, function() {
          lm("beforeDOMElementCreation", {
            assembler: e,
            params: t
          });
          var a = [];
          return e(function(s) {
            Array.isArray(s) ? s.map(function(l) {
              a = a.concat(l.abstract);
            }) : a = a.concat(s.abstract);
          }), [{
            tag: "span",
            attributes: {
              class: ["".concat(ct.cssPrefix, "-layers")].concat(Fs(r)).join(" ")
            },
            children: a
          }];
        });
      }
    };
  }
}, doe = {
  mixout: function() {
    return {
      counter: function(e) {
        var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        t.title;
        var n = t.classes, r = n === void 0 ? [] : n, a = t.attributes, s = a === void 0 ? {} : a, l = t.styles, c = l === void 0 ? {} : l;
        return k2({
          type: "counter",
          content: e
        }, function() {
          return lm("beforeDOMElementCreation", {
            content: e,
            params: t
          }), Vre({
            content: e.toString(),
            extra: {
              attributes: s,
              styles: c,
              classes: ["".concat(ct.cssPrefix, "-layers-counter")].concat(Fs(r))
            }
          });
        });
      }
    };
  }
}, foe = {
  mixout: function() {
    return {
      text: function(e) {
        var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, n = t.transform, r = n === void 0 ? fl : n, a = t.classes, s = a === void 0 ? [] : a, l = t.attributes, c = l === void 0 ? {} : l, d = t.styles, p = d === void 0 ? {} : d;
        return k2({
          type: "text",
          content: e
        }, function() {
          return lm("beforeDOMElementCreation", {
            content: e,
            params: t
          }), rD({
            content: e,
            transform: De(De({}, fl), r),
            extra: {
              attributes: c,
              styles: p,
              classes: ["".concat(ct.cssPrefix, "-layers-text")].concat(Fs(s))
            }
          });
        });
      }
    };
  },
  provides: function(e) {
    e.generateLayersText = function(t, n) {
      var r = n.transform, a = n.extra, s = null, l = null;
      if (Y9) {
        var c = parseInt(getComputedStyle(t).fontSize, 10), d = t.getBoundingClientRect();
        s = d.width / c, l = d.height / c;
      }
      return Promise.resolve([t, rD({
        content: t.innerHTML,
        width: s,
        height: l,
        transform: r,
        extra: a,
        watchable: !0
      })]);
    };
  }
}, WF = new RegExp('"', "ug"), cD = [1105920, 1112319], dD = De(De(De(De({}, {
  FontAwesome: {
    normal: "fas",
    400: "fas"
  }
}), Kte), Zne), rne), y5 = Object.keys(dD).reduce(function(e, t) {
  return e[t.toLowerCase()] = dD[t], e;
}, {}), poe = Object.keys(y5).reduce(function(e, t) {
  var n = y5[t];
  return e[t] = n[900] || Fs(Object.entries(n))[0][1], e;
}, {});
function moe(e) {
  var t = e.replace(WF, "");
  return RF(Fs(t)[0] || "");
}
function hoe(e) {
  var t = e.getPropertyValue("font-feature-settings").includes("ss01"), n = e.getPropertyValue("content"), r = n.replace(WF, ""), a = r.codePointAt(0), s = a >= cD[0] && a <= cD[1], l = r.length === 2 ? r[0] === r[1] : !1;
  return s || l || t;
}
function goe(e, t) {
  var n = e.replace(/^['"]|['"]$/g, "").toLowerCase(), r = parseInt(t), a = isNaN(r) ? "normal" : r;
  return (y5[n] || {})[a] || poe[n];
}
function fD(e, t) {
  var n = "".concat(ere).concat(t.replace(":", "-"));
  return new Promise(function(r, a) {
    if (e.getAttribute(n) !== null)
      return r();
    var s = ng(e.children), l = s.filter(function(R) {
      return R.getAttribute(s5) === t;
    })[0], c = id.getComputedStyle(e, t), d = c.getPropertyValue("font-family"), p = d.match(are), m = c.getPropertyValue("font-weight"), h = c.getPropertyValue("content");
    if (l && !p)
      return e.removeChild(l), r();
    if (p && h !== "none" && h !== "") {
      var v = c.getPropertyValue("content"), y = goe(d, m), w = moe(v), x = p[0].startsWith("FontAwesome"), b = hoe(c), k = SR(y, w), C = k;
      if (x) {
        var _ = Cre(w);
        _.iconName && _.prefix && (k = _.iconName, y = _.prefix);
      }
      if (k && !b && (!l || l.getAttribute(gR) !== y || l.getAttribute(vR) !== C)) {
        e.setAttribute(n, C), l && e.removeChild(l);
        var O = roe(), N = O.extra;
        N.attributes[s5] = t, h5(k, y).then(function(R) {
          var j = kR(De(De({}, O), {}, {
            icons: {
              main: R,
              mask: zF()
            },
            prefix: y,
            iconName: C,
            extra: N,
            watchable: !0
          })), D = ir.createElementNS("http://www.w3.org/2000/svg", "svg");
          t === "::before" ? e.insertBefore(D, e.firstChild) : e.appendChild(D), D.outerHTML = j.map(function($) {
            return iS($);
          }).join(`
`), e.removeAttribute(n), r();
        }).catch(a);
      } else
        r();
    } else
      r();
  });
}
function voe(e) {
  return Promise.all([fD(e, "::before"), fD(e, "::after")]);
}
function yoe(e) {
  return e.parentNode !== document.head && !~nre.indexOf(e.tagName.toUpperCase()) && !e.getAttribute(s5) && (!e.parentNode || e.parentNode.tagName !== "svg");
}
var boe = function(e) {
  return !!e && xF.some(function(t) {
    return e.includes(t);
  });
}, woe = function(e) {
  if (!e) return [];
  var t = /* @__PURE__ */ new Set(), n = e.split(/,(?![^()]*\))/).map(function(c) {
    return c.trim();
  });
  n = n.flatMap(function(c) {
    return c.includes("(") ? c : c.split(",").map(function(d) {
      return d.trim();
    });
  });
  var r = k0(n), a;
  try {
    for (r.s(); !(a = r.n()).done; ) {
      var s = a.value;
      if (boe(s)) {
        var l = xF.reduce(function(c, d) {
          return c.replace(d, "");
        }, s);
        l !== "" && l !== "*" && t.add(l);
      }
    }
  } catch (c) {
    r.e(c);
  } finally {
    r.f();
  }
  return t;
};
function pD(e) {
  var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1;
  if (Mc) {
    var n;
    if (t)
      n = e;
    else if (ct.searchPseudoElementsFullScan)
      n = e.querySelectorAll("*");
    else {
      var r = /* @__PURE__ */ new Set(), a = k0(document.styleSheets), s;
      try {
        for (a.s(); !(s = a.n()).done; ) {
          var l = s.value;
          try {
            var c = k0(l.cssRules), d;
            try {
              for (c.s(); !(d = c.n()).done; ) {
                var p = d.value, m = woe(p.selectorText), h = k0(m), v;
                try {
                  for (h.s(); !(v = h.n()).done; ) {
                    var y = v.value;
                    r.add(y);
                  }
                } catch (x) {
                  h.e(x);
                } finally {
                  h.f();
                }
              }
            } catch (x) {
              c.e(x);
            } finally {
              c.f();
            }
          } catch (x) {
            ct.searchPseudoElementsWarnings && console.warn("Font Awesome: cannot parse stylesheet: ".concat(l.href, " (").concat(x.message, `)
If it declares any Font Awesome CSS pseudo-elements, they will not be rendered as SVG icons. Add crossorigin="anonymous" to the <link>, enable searchPseudoElementsFullScan for slower but more thorough DOM parsing, or suppress this warning by setting searchPseudoElementsWarnings to false.`));
          }
        }
      } catch (x) {
        a.e(x);
      } finally {
        a.f();
      }
      if (!r.size) return;
      var w = Array.from(r).join(", ");
      try {
        n = e.querySelectorAll(w);
      } catch {
      }
    }
    return new Promise(function(x, b) {
      var k = ng(n).filter(yoe).map(voe), C = _R.begin("searchPseudoElements");
      HF(), Promise.all(k).then(function() {
        C(), v5(), x();
      }).catch(function() {
        C(), v5(), b();
      });
    });
  }
}
var xoe = {
  hooks: function() {
    return {
      mutationObserverCallbacks: function(e) {
        return e.pseudoElementsCallback = pD, e;
      }
    };
  },
  provides: function(e) {
    e.pseudoElements2svg = function(t) {
      var n = t.node, r = n === void 0 ? ir : n;
      ct.searchPseudoElements && pD(r);
    };
  }
}, mD = !1, Soe = {
  mixout: function() {
    return {
      dom: {
        unwatch: function() {
          HF(), mD = !0;
        }
      }
    };
  },
  hooks: function() {
    return {
      bootstrap: function() {
        sD(f5("mutationObserverCallbacks", {}));
      },
      noAuto: function() {
        Zre();
      },
      watch: function(e) {
        var t = e.observeMutationsRoot;
        mD ? v5() : sD(f5("mutationObserverCallbacks", {
          observeMutationsRoot: t
        }));
      }
    };
  }
}, hD = function(e) {
  var t = {
    size: 16,
    x: 0,
    y: 0,
    flipX: !1,
    flipY: !1,
    rotate: 0
  };
  return e.toLowerCase().split(" ").reduce(function(n, r) {
    var a = r.toLowerCase().split("-"), s = a[0], l = a.slice(1).join("-");
    if (s && l === "h")
      return n.flipX = !0, n;
    if (s && l === "v")
      return n.flipY = !0, n;
    if (l = parseFloat(l), isNaN(l))
      return n;
    switch (s) {
      case "grow":
        n.size = n.size + l;
        break;
      case "shrink":
        n.size = n.size - l;
        break;
      case "left":
        n.x = n.x - l;
        break;
      case "right":
        n.x = n.x + l;
        break;
      case "up":
        n.y = n.y - l;
        break;
      case "down":
        n.y = n.y + l;
        break;
      case "rotate":
        n.rotate = n.rotate + l;
        break;
    }
    return n;
  }, t);
}, koe = {
  mixout: function() {
    return {
      parse: {
        transform: function(e) {
          return hD(e);
        }
      }
    };
  },
  hooks: function() {
    return {
      parseNodeAttributes: function(e, t) {
        var n = t.getAttribute("data-fa-transform");
        return n && (e.transform = hD(n)), e;
      }
    };
  },
  provides: function(e) {
    e.generateAbstractTransformGrouping = function(t) {
      var n = t.main, r = t.transform, a = t.containerWidth, s = t.iconWidth, l = {
        transform: "translate(".concat(a / 2, " 256)")
      }, c = "translate(".concat(r.x * 32, ", ").concat(r.y * 32, ") "), d = "scale(".concat(r.size / 16 * (r.flipX ? -1 : 1), ", ").concat(r.size / 16 * (r.flipY ? -1 : 1), ") "), p = "rotate(".concat(r.rotate, " 0 0)"), m = {
        transform: "".concat(c, " ").concat(d, " ").concat(p)
      }, h = {
        transform: "translate(".concat(s / 2 * -1, " -256)")
      }, v = {
        outer: l,
        inner: m,
        path: h
      };
      return {
        tag: "g",
        attributes: De({}, v.outer),
        children: [{
          tag: "g",
          attributes: De({}, v.inner),
          children: [{
            tag: n.icon.tag,
            children: n.icon.children,
            attributes: De(De({}, n.icon.attributes), v.path)
          }]
        }]
      };
    };
  }
}, hM = {
  x: 0,
  y: 0,
  width: "100%",
  height: "100%"
};
function gD(e) {
  var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0;
  return e.attributes && (e.attributes.fill || t) && (e.attributes.fill = "black"), e;
}
function _oe(e) {
  return e.tag === "g" ? e.children : [e];
}
var Eoe = {
  hooks: function() {
    return {
      parseNodeAttributes: function(e, t) {
        var n = t.getAttribute("data-fa-mask"), r = n ? S2(n.split(" ").map(function(a) {
          return a.trim();
        })) : zF();
        return r.prefix || (r.prefix = sd()), e.mask = r, e.maskId = t.getAttribute("data-fa-mask-id"), e;
      }
    };
  },
  provides: function(e) {
    e.generateAbstractMask = function(t) {
      var n = t.children, r = t.attributes, a = t.main, s = t.mask, l = t.maskId, c = t.transform, d = a.width, p = a.icon, m = s.width, h = s.icon, v = gre({
        transform: c,
        containerWidth: m,
        iconWidth: d
      }), y = {
        tag: "rect",
        attributes: De(De({}, hM), {}, {
          fill: "white"
        })
      }, w = p.children ? {
        children: p.children.map(gD)
      } : {}, x = {
        tag: "g",
        attributes: De({}, v.inner),
        children: [gD(De({
          tag: p.tag,
          attributes: De(De({}, p.attributes), v.path)
        }, w))]
      }, b = {
        tag: "g",
        attributes: De({}, v.outer),
        children: [x]
      }, k = "mask-".concat(l || YP()), C = "clip-".concat(l || YP()), _ = {
        tag: "mask",
        attributes: De(De({}, hM), {}, {
          id: k,
          maskUnits: "userSpaceOnUse",
          maskContentUnits: "userSpaceOnUse"
        }),
        children: [y, b]
      }, O = {
        tag: "defs",
        children: [{
          tag: "clipPath",
          attributes: {
            id: C
          },
          children: _oe(h)
        }, _]
      };
      return n.push(O, {
        tag: "rect",
        attributes: De({
          fill: "currentColor",
          "clip-path": "url(#".concat(C, ")"),
          mask: "url(#".concat(k, ")")
        }, hM)
      }), {
        children: n,
        attributes: r
      };
    };
  }
}, Coe = {
  provides: function(e) {
    var t = !1;
    id.matchMedia && (t = id.matchMedia("(prefers-reduced-motion: reduce)").matches), e.missingIconAbstract = function() {
      var n = [], r = {
        fill: "currentColor"
      }, a = {
        attributeType: "XML",
        repeatCount: "indefinite",
        dur: "2s"
      };
      n.push({
        tag: "path",
        attributes: De(De({}, r), {}, {
          d: "M156.5,447.7l-12.6,29.5c-18.7-9.5-35.9-21.2-51.5-34.9l22.7-22.7C127.6,430.5,141.5,440,156.5,447.7z M40.6,272H8.5 c1.4,21.2,5.4,41.7,11.7,61.1L50,321.2C45.1,305.5,41.8,289,40.6,272z M40.6,240c1.4-18.8,5.2-37,11.1-54.1l-29.5-12.6 C14.7,194.3,10,216.7,8.5,240H40.6z M64.3,156.5c7.8-14.9,17.2-28.8,28.1-41.5L69.7,92.3c-13.7,15.6-25.5,32.8-34.9,51.5 L64.3,156.5z M397,419.6c-13.9,12-29.4,22.3-46.1,30.4l11.9,29.8c20.7-9.9,39.8-22.6,56.9-37.6L397,419.6z M115,92.4 c13.9-12,29.4-22.3,46.1-30.4l-11.9-29.8c-20.7,9.9-39.8,22.6-56.8,37.6L115,92.4z M447.7,355.5c-7.8,14.9-17.2,28.8-28.1,41.5 l22.7,22.7c13.7-15.6,25.5-32.9,34.9-51.5L447.7,355.5z M471.4,272c-1.4,18.8-5.2,37-11.1,54.1l29.5,12.6 c7.5-21.1,12.2-43.5,13.6-66.8H471.4z M321.2,462c-15.7,5-32.2,8.2-49.2,9.4v32.1c21.2-1.4,41.7-5.4,61.1-11.7L321.2,462z M240,471.4c-18.8-1.4-37-5.2-54.1-11.1l-12.6,29.5c21.1,7.5,43.5,12.2,66.8,13.6V471.4z M462,190.8c5,15.7,8.2,32.2,9.4,49.2h32.1 c-1.4-21.2-5.4-41.7-11.7-61.1L462,190.8z M92.4,397c-12-13.9-22.3-29.4-30.4-46.1l-29.8,11.9c9.9,20.7,22.6,39.8,37.6,56.9 L92.4,397z M272,40.6c18.8,1.4,36.9,5.2,54.1,11.1l12.6-29.5C317.7,14.7,295.3,10,272,8.5V40.6z M190.8,50 c15.7-5,32.2-8.2,49.2-9.4V8.5c-21.2,1.4-41.7,5.4-61.1,11.7L190.8,50z M442.3,92.3L419.6,115c12,13.9,22.3,29.4,30.5,46.1 l29.8-11.9C470,128.5,457.3,109.4,442.3,92.3z M397,92.4l22.7-22.7c-15.6-13.7-32.8-25.5-51.5-34.9l-12.6,29.5 C370.4,72.1,384.4,81.5,397,92.4z"
        })
      });
      var s = De(De({}, a), {}, {
        attributeName: "opacity"
      }), l = {
        tag: "circle",
        attributes: De(De({}, r), {}, {
          cx: "256",
          cy: "364",
          r: "28"
        }),
        children: []
      };
      return t || l.children.push({
        tag: "animate",
        attributes: De(De({}, a), {}, {
          attributeName: "r",
          values: "28;14;28;28;14;28;"
        })
      }, {
        tag: "animate",
        attributes: De(De({}, s), {}, {
          values: "1;0;1;1;0;1;"
        })
      }), n.push(l), n.push({
        tag: "path",
        attributes: De(De({}, r), {}, {
          opacity: "1",
          d: "M263.7,312h-16c-6.6,0-12-5.4-12-12c0-71,77.4-63.9,77.4-107.8c0-20-17.8-40.2-57.4-40.2c-29.1,0-44.3,9.6-59.2,28.7 c-3.9,5-11.1,6-16.2,2.4l-13.1-9.2c-5.6-3.9-6.9-11.8-2.6-17.2c21.2-27.2,46.4-44.7,91.2-44.7c52.3,0,97.4,29.8,97.4,80.2 c0,67.6-77.4,63.5-77.4,107.8C275.7,306.6,270.3,312,263.7,312z"
        }),
        children: t ? [] : [{
          tag: "animate",
          attributes: De(De({}, s), {}, {
            values: "1;0;0;0;0;1;"
          })
        }]
      }), t || n.push({
        tag: "path",
        attributes: De(De({}, r), {}, {
          opacity: "0",
          d: "M232.5,134.5l7,168c0.3,6.4,5.6,11.5,12,11.5h9c6.4,0,11.7-5.1,12-11.5l7-168c0.3-6.8-5.2-12.5-12-12.5h-23 C237.7,122,232.2,127.7,232.5,134.5z"
        }),
        children: [{
          tag: "animate",
          attributes: De(De({}, s), {}, {
            values: "0;0;1;1;0;0;"
          })
        }]
      }), {
        tag: "g",
        attributes: {
          class: "missing"
        },
        children: n
      };
    };
  }
}, Ooe = {
  hooks: function() {
    return {
      parseNodeAttributes: function(e, t) {
        var n = t.getAttribute("data-fa-symbol"), r = n === null ? !1 : n === "" ? !0 : n;
        return e.symbol = r, e;
      }
    };
  }
}, Moe = [bre, uoe, coe, doe, foe, xoe, Soe, koe, Eoe, Coe, Ooe];
$re(Moe, {
  mixoutsTo: Si
});
Si.noAuto;
var Ph = Si.config;
Si.library;
Si.dom;
var GF = Si.parse;
Si.findIconDefinition;
Si.toHtml;
var Noe = Si.icon;
Si.layer;
Si.text;
Si.counter;
function Roe(e) {
  return e = e - 0, e === e;
}
function KF(e) {
  return Roe(e) ? e : (e = e.replace(/[_-]+(.)?/g, (t, n) => n ? n.toUpperCase() : ""), e.charAt(0).toLowerCase() + e.slice(1));
}
function Aoe(e) {
  return e.charAt(0).toUpperCase() + e.slice(1);
}
var Gm = /* @__PURE__ */ new Map(), joe = 1e3;
function Poe(e) {
  if (Gm.has(e))
    return Gm.get(e);
  const t = {};
  let n = 0;
  const r = e.length;
  for (; n < r; ) {
    const a = e.indexOf(";", n), s = a === -1 ? r : a, l = e.slice(n, s).trim();
    if (l) {
      const c = l.indexOf(":");
      if (c > 0) {
        const d = l.slice(0, c).trim(), p = l.slice(c + 1).trim();
        if (d && p) {
          const m = KF(d);
          t[m.startsWith("webkit") ? Aoe(m) : m] = p;
        }
      }
    }
    n = s + 1;
  }
  if (Gm.size === joe) {
    const a = Gm.keys().next().value;
    a && Gm.delete(a);
  }
  return Gm.set(e, t), t;
}
function XF(e, t, n = {}) {
  if (typeof t == "string")
    return t;
  const r = (t.children || []).map((m) => XF(e, m)), a = t.attributes || {}, s = {};
  for (const [m, h] of Object.entries(a))
    switch (!0) {
      case m === "class": {
        s.className = h;
        break;
      }
      case m === "style": {
        s.style = Poe(String(h));
        break;
      }
      case m.startsWith("aria-"):
      case m.startsWith("data-"): {
        s[m.toLowerCase()] = h;
        break;
      }
      default:
        s[KF(m)] = h;
    }
  const {
    style: l,
    role: c,
    "aria-label": d,
    ...p
  } = n;
  return l && (s.style = s.style ? { ...s.style, ...l } : l), c && (s.role = c), d && (s["aria-label"] = d, s["aria-hidden"] = "false"), e(t.tag, { ...p, ...s }, ...r);
}
var Doe = XF.bind(null, Qn.createElement), vD = (e, t) => {
  const n = M.useId();
  return e || (t ? n : void 0);
}, $oe = class {
  constructor(e = "react-fontawesome") {
    this.enabled = !1;
    let t = !1;
    try {
      t = typeof process < "u" && !1;
    } catch {
    }
    this.scope = e, this.enabled = t;
  }
  /**
   * Logs messages to the console if not in production.
   * @param args - The message and/or data to log.
   */
  log(...e) {
    this.enabled && console.log(`[${this.scope}]`, ...e);
  }
  /**
   * Logs warnings to the console if not in production.
   * @param args - The warning message and/or data to log.
   */
  warn(...e) {
    this.enabled && console.warn(`[${this.scope}]`, ...e);
  }
  /**
   * Logs errors to the console if not in production.
   * @param args - The error message and/or data to log.
   */
  error(...e) {
    this.enabled && console.error(`[${this.scope}]`, ...e);
  }
};
typeof process < "u" && process.env.FA_VERSION;
var Toe = (
  // @ts-expect-error TS2872 - Expression is always truthy - This is true when v7 of SVGCore is used, but not when v6 is used.
  // This is the point of this check - if the property exists on config, we have v7, otherwise we have v6.
  // TS is checking this against the dev dependencies which uses v7, so it reports a false error here.
  "searchPseudoElementsFullScan" in Ph ? "7.0.0" : "6.0.0"
), Loe = Number.parseInt(Toe) >= 7, Kw = "fa", tc = {
  beat: "fa-beat",
  fade: "fa-fade",
  beatFade: "fa-beat-fade",
  bounce: "fa-bounce",
  shake: "fa-shake",
  spin: "fa-spin",
  spinPulse: "fa-spin-pulse",
  spinReverse: "fa-spin-reverse",
  pulse: "fa-pulse"
}, Ioe = {
  left: "fa-pull-left",
  right: "fa-pull-right"
}, zoe = {
  90: "fa-rotate-90",
  180: "fa-rotate-180",
  270: "fa-rotate-270"
}, Foe = {
  "2xs": "fa-2xs",
  xs: "fa-xs",
  sm: "fa-sm",
  lg: "fa-lg",
  xl: "fa-xl",
  "2xl": "fa-2xl",
  "1x": "fa-1x",
  "2x": "fa-2x",
  "3x": "fa-3x",
  "4x": "fa-4x",
  "5x": "fa-5x",
  "6x": "fa-6x",
  "7x": "fa-7x",
  "8x": "fa-8x",
  "9x": "fa-9x",
  "10x": "fa-10x"
}, nc = {
  border: "fa-border",
  /** @deprecated */
  fixedWidth: "fa-fw",
  flip: "fa-flip",
  flipHorizontal: "fa-flip-horizontal",
  flipVertical: "fa-flip-vertical",
  inverse: "fa-inverse",
  rotateBy: "fa-rotate-by",
  swapOpacity: "fa-swap-opacity",
  widthAuto: "fa-width-auto"
};
function Boe(e) {
  const t = Ph.cssPrefix || Ph.familyPrefix || Kw;
  return t === Kw ? e : e.replace(
    new RegExp(String.raw`(?<=^|\s)${Kw}-`, "g"),
    `${t}-`
  );
}
function Uoe(e) {
  const {
    beat: t,
    fade: n,
    beatFade: r,
    bounce: a,
    shake: s,
    spin: l,
    spinPulse: c,
    spinReverse: d,
    pulse: p,
    fixedWidth: m,
    inverse: h,
    border: v,
    flip: y,
    size: w,
    rotation: x,
    pull: b,
    swapOpacity: k,
    rotateBy: C,
    widthAuto: _,
    className: O
  } = e, N = [];
  return O && N.push(...O.split(" ")), t && N.push(tc.beat), n && N.push(tc.fade), r && N.push(tc.beatFade), a && N.push(tc.bounce), s && N.push(tc.shake), l && N.push(tc.spin), d && N.push(tc.spinReverse), c && N.push(tc.spinPulse), p && N.push(tc.pulse), m && N.push(nc.fixedWidth), h && N.push(nc.inverse), v && N.push(nc.border), y === !0 && N.push(nc.flip), (y === "horizontal" || y === "both") && N.push(nc.flipHorizontal), (y === "vertical" || y === "both") && N.push(nc.flipVertical), w != null && N.push(Foe[w]), x != null && x !== 0 && N.push(zoe[x]), b != null && N.push(Ioe[b]), k && N.push(nc.swapOpacity), Loe ? (C && N.push(nc.rotateBy), _ && N.push(nc.widthAuto), (Ph.cssPrefix || Ph.familyPrefix || Kw) === Kw ? N : (
    // TODO: see if we can achieve custom prefix support without iterating
    // eslint-disable-next-line unicorn/no-array-callback-reference
    N.map(Boe)
  )) : N;
}
var Voe = (e) => typeof e == "object" && "icon" in e && !!e.icon;
function yD(e) {
  if (e)
    return Voe(e) ? e : GF.icon(e);
}
function Hoe(e) {
  return Object.keys(e);
}
var bD = new $oe("FontAwesomeIcon"), YF = {
  border: !1,
  className: "",
  mask: void 0,
  maskId: void 0,
  fixedWidth: !1,
  inverse: !1,
  flip: !1,
  icon: void 0,
  listItem: !1,
  pull: void 0,
  pulse: !1,
  rotation: void 0,
  rotateBy: !1,
  size: void 0,
  spin: !1,
  spinPulse: !1,
  spinReverse: !1,
  beat: !1,
  fade: !1,
  beatFade: !1,
  bounce: !1,
  shake: !1,
  symbol: !1,
  title: "",
  titleId: void 0,
  transform: void 0,
  swapOpacity: !1,
  widthAuto: !1
}, qoe = new Set(Object.keys(YF)), QF = Qn.forwardRef((e, t) => {
  const n = { ...YF, ...e }, {
    icon: r,
    mask: a,
    symbol: s,
    title: l,
    titleId: c,
    maskId: d,
    transform: p
  } = n, m = vD(d, !!a), h = vD(c, !!l), v = yD(r);
  if (!v)
    return bD.error("Icon lookup is undefined", r), null;
  const y = Uoe(n), w = typeof p == "string" ? GF.transform(p) : p, x = yD(a), b = Noe(v, {
    ...y.length > 0 && { classes: y },
    ...w && { transform: w },
    ...x && { mask: x },
    symbol: s,
    title: l,
    titleId: h,
    maskId: m
  });
  if (!b)
    return bD.error("Could not find icon", v), null;
  const { abstract: k } = b, C = { ref: t };
  for (const _ of Hoe(n))
    qoe.has(_) || (C[_] = n[_]);
  return Doe(k[0], C);
});
QF.displayName = "FontAwesomeIcon";
var Woe = {
  prefix: "fas",
  iconName: "magnifying-glass",
  icon: [512, 512, [128269, "search"], "f002", "M416 208c0 45.9-14.9 88.3-40 122.7L502.6 457.4c12.5 12.5 12.5 32.8 0 45.3s-32.8 12.5-45.3 0L330.7 376C296.3 401.1 253.9 416 208 416 93.1 416 0 322.9 0 208S93.1 0 208 0 416 93.1 416 208zM208 352a144 144 0 1 0 0-288 144 144 0 1 0 0 288z"]
}, Goe = {
  prefix: "fas",
  iconName: "chevron-up",
  icon: [448, 512, [], "f077", "M201.4 105.4c12.5-12.5 32.8-12.5 45.3 0l192 192c12.5 12.5 12.5 32.8 0 45.3s-32.8 12.5-45.3 0L224 173.3 54.6 342.6c-12.5 12.5-32.8 12.5-45.3 0s-12.5-32.8 0-45.3l192-192z"]
}, Koe = {
  prefix: "fas",
  iconName: "expand",
  icon: [448, 512, [], "f065", "M32 32C14.3 32 0 46.3 0 64l0 96c0 17.7 14.3 32 32 32s32-14.3 32-32l0-64 64 0c17.7 0 32-14.3 32-32s-14.3-32-32-32L32 32zM64 352c0-17.7-14.3-32-32-32S0 334.3 0 352l0 96c0 17.7 14.3 32 32 32l96 0c17.7 0 32-14.3 32-32s-14.3-32-32-32l-64 0 0-64zM320 32c-17.7 0-32 14.3-32 32s14.3 32 32 32l64 0 0 64c0 17.7 14.3 32 32 32s32-14.3 32-32l0-96c0-17.7-14.3-32-32-32l-96 0zM448 352c0-17.7-14.3-32-32-32s-32 14.3-32 32l0 64-64 0c-17.7 0-32 14.3-32 32s14.3 32 32 32l96 0c17.7 0 32-14.3 32-32l0-96z"]
}, Xoe = {
  prefix: "fas",
  iconName: "chevron-right",
  icon: [320, 512, [9002], "f054", "M311.1 233.4c12.5 12.5 12.5 32.8 0 45.3l-192 192c-12.5 12.5-32.8 12.5-45.3 0s-12.5-32.8 0-45.3L243.2 256 73.9 86.6c-12.5-12.5-12.5-32.8 0-45.3s32.8-12.5 45.3 0l192 192z"]
}, Yoe = {
  prefix: "fas",
  iconName: "circle-xmark",
  icon: [512, 512, [61532, "times-circle", "xmark-circle"], "f057", "M256 512a256 256 0 1 0 0-512 256 256 0 1 0 0 512zM167 167c9.4-9.4 24.6-9.4 33.9 0l55 55 55-55c9.4-9.4 24.6-9.4 33.9 0s9.4 24.6 0 33.9l-55 55 55 55c9.4 9.4 9.4 24.6 0 33.9s-24.6 9.4-33.9 0l-55-55-55 55c-9.4 9.4-24.6 9.4-33.9 0s-9.4-24.6 0-33.9l55-55-55-55c-9.4-9.4-9.4-24.6 0-33.9z"]
}, Qoe = {
  prefix: "fas",
  iconName: "network-wired",
  icon: [576, 512, [], "f6ff", "M248 88l80 0 0 48-80 0 0-48zm-8-56c-26.5 0-48 21.5-48 48l0 64c0 26.5 21.5 48 48 48l16 0 0 32-224 0c-17.7 0-32 14.3-32 32s14.3 32 32 32l96 0 0 32-16 0c-26.5 0-48 21.5-48 48l0 64c0 26.5 21.5 48 48 48l96 0c26.5 0 48-21.5 48-48l0-64c0-26.5-21.5-48-48-48l-16 0 0-32 192 0 0 32-16 0c-26.5 0-48 21.5-48 48l0 64c0 26.5 21.5 48 48 48l96 0c26.5 0 48-21.5 48-48l0-64c0-26.5-21.5-48-48-48l-16 0 0-32 96 0c17.7 0 32-14.3 32-32s-14.3-32-32-32l-224 0 0-32 16 0c26.5 0 48-21.5 48-48l0-64c0-26.5-21.5-48-48-48l-96 0zM448 376l8 0 0 48-80 0 0-48 72 0zm-256 0l8 0 0 48-80 0 0-48 72 0z"]
}, Joe = {
  prefix: "fas",
  iconName: "gear",
  icon: [512, 512, [9881, "cog"], "f013", "M195.1 9.5C198.1-5.3 211.2-16 226.4-16l59.8 0c15.2 0 28.3 10.7 31.3 25.5L332 79.5c14.1 6 27.3 13.7 39.3 22.8l67.8-22.5c14.4-4.8 30.2 1.2 37.8 14.4l29.9 51.8c7.6 13.2 4.9 29.8-6.5 39.9L447 233.3c.9 7.4 1.3 15 1.3 22.7s-.5 15.3-1.3 22.7l53.4 47.5c11.4 10.1 14 26.8 6.5 39.9l-29.9 51.8c-7.6 13.1-23.4 19.2-37.8 14.4l-67.8-22.5c-12.1 9.1-25.3 16.7-39.3 22.8l-14.4 69.9c-3.1 14.9-16.2 25.5-31.3 25.5l-59.8 0c-15.2 0-28.3-10.7-31.3-25.5l-14.4-69.9c-14.1-6-27.2-13.7-39.3-22.8L73.5 432.3c-14.4 4.8-30.2-1.2-37.8-14.4L5.8 366.1c-7.6-13.2-4.9-29.8 6.5-39.9l53.4-47.5c-.9-7.4-1.3-15-1.3-22.7s.5-15.3 1.3-22.7L12.3 185.8c-11.4-10.1-14-26.8-6.5-39.9L35.7 94.1c7.6-13.2 23.4-19.2 37.8-14.4l67.8 22.5c12.1-9.1 25.3-16.7 39.3-22.8L195.1 9.5zM256.3 336a80 80 0 1 0 -.6-160 80 80 0 1 0 .6 160z"]
}, Zoe = {
  prefix: "fas",
  iconName: "up-right-and-down-left-from-center",
  icon: [512, 512, ["expand-alt"], "f424", "M344 0L488 0c13.3 0 24 10.7 24 24l0 144c0 9.7-5.8 18.5-14.8 22.2s-19.3 1.7-26.2-5.2l-39-39-87 87c-9.4 9.4-24.6 9.4-33.9 0l-32-32c-9.4-9.4-9.4-24.6 0-33.9l87-87-39-39c-6.9-6.9-8.9-17.2-5.2-26.2S334.3 0 344 0zM168 512L24 512c-13.3 0-24-10.7-24-24L0 344c0-9.7 5.8-18.5 14.8-22.2S34.1 320.2 41 327l39 39 87-87c9.4-9.4 24.6-9.4 33.9 0l32 32c9.4 9.4 9.4 24.6 0 33.9l-87 87 39 39c6.9 6.9 8.9 17.2 5.2 26.2S177.7 512 168 512z"]
}, eae = {
  prefix: "fas",
  iconName: "xmark",
  icon: [384, 512, [128473, 10005, 10006, 10060, 215, "close", "multiply", "remove", "times"], "f00d", "M55.1 73.4c-12.5-12.5-32.8-12.5-45.3 0s-12.5 32.8 0 45.3L147.2 256 9.9 393.4c-12.5 12.5-12.5 32.8 0 45.3s32.8 12.5 45.3 0L192.5 301.3 329.9 438.6c12.5 12.5 32.8 12.5 45.3 0s12.5-32.8 0-45.3L237.8 256 375.1 118.6c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0L192.5 210.7 55.1 73.4z"]
}, tae = {
  prefix: "fas",
  iconName: "lock-open",
  icon: [576, 512, [], "f3c1", "M384 96c0-35.3 28.7-64 64-64s64 28.7 64 64l0 32c0 17.7 14.3 32 32 32s32-14.3 32-32l0-32c0-70.7-57.3-128-128-128S320 25.3 320 96l0 64-160 0c-35.3 0-64 28.7-64 64l0 224c0 35.3 28.7 64 64 64l256 0c35.3 0 64-28.7 64-64l0-224c0-35.3-28.7-64-64-64l-32 0 0-64z"]
}, nae = {
  prefix: "fas",
  iconName: "circle-check",
  icon: [512, 512, [61533, "check-circle"], "f058", "M256 512a256 256 0 1 1 0-512 256 256 0 1 1 0 512zM374 145.7c-10.7-7.8-25.7-5.4-33.5 5.3L221.1 315.2 169 263.1c-9.4-9.4-24.6-9.4-33.9 0s-9.4 24.6 0 33.9l72 72c5 5 11.8 7.5 18.8 7s13.4-4.1 17.5-9.8L379.3 179.2c7.8-10.7 5.4-25.7-5.3-33.5z"]
}, rae = {
  prefix: "fas",
  iconName: "circle-play",
  icon: [512, 512, [61469, "play-circle"], "f144", "M0 256a256 256 0 1 1 512 0 256 256 0 1 1 -512 0zM188.3 147.1c-7.6 4.2-12.3 12.3-12.3 20.9l0 176c0 8.7 4.7 16.7 12.3 20.9s16.8 4.1 24.3-.5l144-88c7.1-4.4 11.5-12.1 11.5-20.5s-4.4-16.1-11.5-20.5l-144-88c-7.4-4.5-16.7-4.7-24.3-.5z"]
}, oae = {
  prefix: "fas",
  iconName: "chevron-down",
  icon: [448, 512, [], "f078", "M201.4 406.6c12.5 12.5 32.8 12.5 45.3 0l192-192c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0L224 338.7 54.6 169.4c-12.5-12.5-32.8-12.5-45.3 0s-12.5 32.8 0 45.3l192 192z"]
}, aae = {
  prefix: "fas",
  iconName: "chevron-left",
  icon: [320, 512, [9001], "f053", "M9.4 233.4c-12.5 12.5-12.5 32.8 0 45.3l192 192c12.5 12.5 32.8 12.5 45.3 0s12.5-32.8 0-45.3L77.3 256 246.6 86.6c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0l-192 192z"]
}, iae = {
  prefix: "fas",
  iconName: "lock",
  icon: [384, 512, [128274], "f023", "M128 96l0 64 128 0 0-64c0-35.3-28.7-64-64-64s-64 28.7-64 64zM64 160l0-64C64 25.3 121.3-32 192-32S320 25.3 320 96l0 64c35.3 0 64 28.7 64 64l0 224c0 35.3-28.7 64-64 64L64 512c-35.3 0-64-28.7-64-64L0 224c0-35.3 28.7-64 64-64z"]
}, sae = {
  prefix: "fas",
  iconName: "down-left-and-up-right-to-center",
  icon: [512, 512, ["compress-alt"], "f422", "M439.5 7c9.4-9.4 24.6-9.4 33.9 0l32 32c9.4 9.4 9.4 24.6 0 33.9l-87 87 39 39c6.9 6.9 8.9 17.2 5.2 26.2S450.2 240 440.5 240l-144 0c-13.3 0-24-10.7-24-24l0-144c0-9.7 5.8-18.5 14.8-22.2s19.3-1.7 26.2 5.2l39 39 87-87zM72.5 272l144 0c13.3 0 24 10.7 24 24l0 144c0 9.7-5.8 18.5-14.8 22.2s-19.3 1.7-26.2-5.2l-39-39-87 87c-9.4 9.4-24.6 9.4-33.9 0l-32-32c-9.4-9.4-9.4-24.6 0-33.9l87-87-39-39c-6.9-6.9-8.9-17.2-5.2-26.2S62.8 272 72.5 272z"]
}, lae = {
  prefix: "fas",
  iconName: "compress",
  icon: [448, 512, [], "f066", "M160 64c0-17.7-14.3-32-32-32S96 46.3 96 64l0 64-64 0c-17.7 0-32 14.3-32 32s14.3 32 32 32l96 0c17.7 0 32-14.3 32-32l0-96zM32 320c-17.7 0-32 14.3-32 32s14.3 32 32 32l64 0 0 64c0 17.7 14.3 32 32 32s32-14.3 32-32l0-96c0-17.7-14.3-32-32-32l-96 0zM352 64c0-17.7-14.3-32-32-32s-32 14.3-32 32l0 96c0 17.7 14.3 32 32 32l96 0c17.7 0 32-14.3 32-32s-14.3-32-32-32l-64 0 0-64zM320 320c-17.7 0-32 14.3-32 32l0 96c0 17.7 14.3 32 32 32s32-14.3 32-32l0-64 64 0c17.7 0 32-14.3 32-32s-14.3-32-32-32l-96 0z"]
}, uae = {
  prefix: "fas",
  iconName: "bars",
  icon: [448, 512, ["navicon"], "f0c9", "M0 96C0 78.3 14.3 64 32 64l384 0c17.7 0 32 14.3 32 32s-14.3 32-32 32L32 128C14.3 128 0 113.7 0 96zM0 256c0-17.7 14.3-32 32-32l384 0c17.7 0 32 14.3 32 32s-14.3 32-32 32L32 288c-17.7 0-32-14.3-32-32zM448 416c0 17.7-14.3 32-32 32L32 448c-17.7 0-32-14.3-32-32s14.3-32 32-32l384 0c17.7 0 32 14.3 32 32z"]
};
Ph.autoAddCss = !1;
const ro = (e) => {
  const { style: t, ...n } = e;
  return /* @__PURE__ */ E.jsx("span", { style: t, children: /* @__PURE__ */ E.jsx(QF, { ...n }) });
}, CR = (e) => /* @__PURE__ */ E.jsx(ro, { ...e, icon: uae }), hx = (e) => /* @__PURE__ */ E.jsx(ro, { ...e, icon: Xoe }), n_ = (e) => /* @__PURE__ */ E.jsx(ro, { ...e, icon: aae }), JF = (e) => /* @__PURE__ */ E.jsx(ro, { ...e, icon: Koe }), cae = (e) => /* @__PURE__ */ E.jsx(ro, { ...e, icon: lae }), dae = (e) => /* @__PURE__ */ E.jsx(ro, { ...e, icon: sae }), fae = (e) => /* @__PURE__ */ E.jsx(ro, { ...e, icon: Zoe }), r_ = (e) => /* @__PURE__ */ E.jsx(ro, { ...e, icon: oae }), gx = (e) => /* @__PURE__ */ E.jsx(ro, { ...e, icon: Goe }), sS = gx, _2 = (e) => /* @__PURE__ */ E.jsx(ro, { ...e, icon: eae }), pae = (e) => /* @__PURE__ */ E.jsx(ro, { ...e, icon: tae }), mae = (e) => /* @__PURE__ */ E.jsx(ro, { ...e, icon: iae }), hae = (e) => /* @__PURE__ */ E.jsx(ro, { ...e, icon: Qoe }), gae = (e) => /* @__PURE__ */ E.jsx(ro, { ...e, icon: rae }), vae = (e) => /* @__PURE__ */ E.jsx(ro, { ...e, icon: Woe }), yae = (e) => /* @__PURE__ */ E.jsx(ro, { ...e, icon: Joe }), bae = (e) => /* @__PURE__ */ E.jsx(ro, { ...e, icon: nae }), wae = (e) => /* @__PURE__ */ E.jsx(ro, { ...e, icon: Yoe }), ZF = M.createContext(null), yn = () => {
  const e = M.useContext(ZF);
  if (!e)
    throw new Error(
      "useFuncNodesContext must be used within a FuncNodesContext.Provider"
    );
  return e;
}, e8 = M.createContext(
  void 0
), OR = () => {
  const e = M.useContext(e8);
  if (!e)
    throw new Error("useKeyPress must be used within a KeyPressProvider");
  return e;
}, xae = ({
  children: e,
  preventDefault: t = !1,
  ignoredKeys: n = [],
  debug: r = !1,
  target: a
}) => {
  const [s, l] = M.useState(/* @__PURE__ */ new Set()), c = M.useMemo(
    () => new Set(n),
    [n]
  ), d = M.useRef(s);
  d.current = s;
  const p = M.useMemo(
    () => ({
      keys: s,
      isKeyPressed: (m) => s.has(m),
      areKeysPressed: (...m) => m.every((h) => s.has(h)),
      isAnyKeyPressed: (...m) => m.some((h) => s.has(h))
    }),
    [s]
  );
  return M.useEffect(() => {
    const m = a ?? window;
    if (!m) return;
    const h = (x) => {
      const b = x.key;
      c.has(b) || (t && x.preventDefault(), d.current.has(b) || (r && console.log(`[KeyPress] Key down: ${b}`), l((k) => {
        const C = new Set(k);
        return C.add(b), C;
      })));
    }, v = (x) => {
      const b = x.key;
      d.current.has(b) && (r && console.log(`[KeyPress] Key up: ${b}`), l((k) => {
        const C = new Set(k);
        return C.delete(b), C;
      }));
    }, y = () => {
      d.current.size > 0 && (r && console.log("[KeyPress] Window blur - clearing all keys"), l(/* @__PURE__ */ new Set()));
    }, w = () => {
      document.hidden && d.current.size > 0 && (r && console.log("[KeyPress] Tab hidden - clearing all keys"), l(/* @__PURE__ */ new Set()));
    };
    return m.addEventListener("keydown", h), m.addEventListener("keyup", v), m.addEventListener("blur", y), document.addEventListener("visibilitychange", w), () => {
      m.removeEventListener("keydown", h), m.removeEventListener("keyup", v), m.removeEventListener("blur", y), document.removeEventListener("visibilitychange", w);
    };
  }, [t, c, r, a]), /* @__PURE__ */ E.jsx(e8.Provider, { value: p, children: e });
}, t8 = M.createContext({
  colorTheme: "classic",
  setColorTheme: () => {
  },
  previewColorTheme: () => {
  }
}), Sae = ({
  available_themes: e,
  children: t,
  default_theme: n
}) => {
  const r = M.useMemo(
    () => new Set(e),
    [e]
  ), [a, s] = M.useState(
    n ?? e[0]
  ), l = M.useCallback(
    (p) => {
      if (!r.has(p))
        throw new Error(
          `Theme "${p}" is not in available_themes: [${Array.from(
            r
          ).join(", ")}]`
        );
      s(p);
      const m = {
        colorTheme: p
      };
      try {
        localStorage.setItem("theme", JSON.stringify(m));
      } catch (h) {
        console.warn("Failed to save theme to localStorage:", h);
      }
    },
    [r]
  ), c = M.useCallback(
    (p) => {
      if (!r.has(p))
        throw new Error(
          `Theme "${p}" is not in available_themes: [${Array.from(
            r
          ).join(", ")}]`
        );
      s(p);
    },
    [r]
  );
  M.useEffect(() => {
    document.documentElement.setAttribute("fn-data-color-theme", a);
  }, [a]), M.useEffect(() => {
    try {
      const p = localStorage.getItem("theme");
      if (!p) return;
      const m = JSON.parse(p);
      m.colorTheme && r.has(m.colorTheme) && s(m.colorTheme);
    } catch (p) {
      console.warn("Failed to load theme from localStorage:", p);
    }
  }, [r]), M.useEffect(() => {
    if (n && !r.has(n)) {
      const p = Array.from(r)[0];
      p && l(p);
    }
  }, [r, n, l]), M.useEffect(() => {
    if (!r.has(a)) {
      const p = Array.from(r)[0];
      p && l(p);
    }
  }, [a, r, l]);
  const d = M.useMemo(
    () => ({
      colorTheme: a,
      setColorTheme: l,
      previewColorTheme: c
    }),
    [a, l, c]
  );
  return /* @__PURE__ */ E.jsx(t8.Provider, { value: d, children: t });
}, n8 = () => {
  const e = M.useContext(t8);
  if (!e)
    throw new Error("useTheme must be used within a ThemeProvider");
  return e;
}, r8 = M.memo(({ button: e, index: t }) => {
  const n = M.useCallback(
    (a) => {
      a.preventDefault(), e.onClick(a);
    },
    [e]
  ), r = /* @__PURE__ */ E.jsx(
    "button",
    {
      className: `dialog-send-button ${e.className || ""}`,
      onClick: n,
      disabled: e.disabled,
      "aria-label": e.ariaLabel,
      type: "button",
      children: e.text
    }
  );
  return e.close !== !1 ? /* @__PURE__ */ E.jsx(q9, { asChild: !0, children: r }, t) : /* @__PURE__ */ E.jsx(M.Fragment, { children: r }, t);
});
r8.displayName = "DialogButton";
const Pl = M.memo(
  ({
    trigger: e,
    title: t,
    description: n,
    children: r,
    closebutton: a = !0,
    onOpenChange: s,
    buttons: l = [],
    open: c,
    setOpen: d,
    modal: p = !0,
    dialogClassName: m = "default-dialog-content",
    ariaLabel: h,
    ariaDescription: v
  }) => {
    const y = yn().local_state((k) => k.funcnodescontainerRef), w = M.useMemo(
      () => `dialog-content funcnodescontainer ${m}`,
      [m]
    ), x = M.useCallback(
      (k) => {
        try {
          d?.(k), s?.(k);
        } catch (C) {
          console.error("Error in dialog open change handler:", C);
        }
      },
      [d, s]
    ), b = M.useMemo(
      () => l.map((k, C) => /* @__PURE__ */ E.jsx(
        r8,
        {
          button: k,
          index: C
        },
        `${k.text}-${C}`
      )),
      [l]
    );
    return /* @__PURE__ */ E.jsxs(lte, { open: c, onOpenChange: x, modal: p, children: [
      e && /* @__PURE__ */ E.jsx(ute, { asChild: !0, children: e }),
      /* @__PURE__ */ E.jsxs(cte, { container: y, children: [
        /* @__PURE__ */ E.jsx(dte, { className: "dialog-overlay funcnodescontainer" }),
        /* @__PURE__ */ E.jsx(fte, { asChild: !0, ...n ? {} : { "aria-describedby": void 0 }, children: /* @__PURE__ */ E.jsxs(
          "div",
          {
            className: w,
            role: "dialog",
            "aria-label": h || t,
            "aria-description": v || (typeof n == "string" ? n : void 0),
            children: [
              /* @__PURE__ */ E.jsx(
                pte,
                {
                  className: `dialog-title${t ? "" : " dialog-title--visually-hidden"}`,
                  children: t || h || "Dialog"
                }
              ),
              n && /* @__PURE__ */ E.jsx(
                mte,
                {
                  className: "dialog-description",
                  children: n
                }
              ),
              /* @__PURE__ */ E.jsx("div", { className: "dialog-children", role: "main", children: r }),
              l.length > 0 && /* @__PURE__ */ E.jsx(
                "div",
                {
                  className: "dialog-buttons",
                  role: "group",
                  "aria-label": "Dialog actions",
                  children: b
                }
              ),
              a && /* @__PURE__ */ E.jsx(q9, { asChild: !0, children: /* @__PURE__ */ E.jsx(
                "button",
                {
                  className: "dialog-close-button",
                  "aria-label": "Close dialog",
                  type: "button",
                  children: /* @__PURE__ */ E.jsx(_2, {})
                }
              ) })
            ]
          }
        ) })
      ] })
    ] });
  }
);
Pl.displayName = "CustomDialog";
const kae = ["top", "right", "bottom", "left"], ud = Math.min, mi = Math.max, o_ = Math.round, JS = Math.floor, El = (e) => ({
  x: e,
  y: e
}), _ae = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
}, Eae = {
  start: "end",
  end: "start"
};
function b5(e, t, n) {
  return mi(e, ud(t, n));
}
function Sc(e, t) {
  return typeof e == "function" ? e(t) : e;
}
function kc(e) {
  return e.split("-")[0];
}
function rg(e) {
  return e.split("-")[1];
}
function MR(e) {
  return e === "x" ? "y" : "x";
}
function NR(e) {
  return e === "y" ? "height" : "width";
}
const Cae = /* @__PURE__ */ new Set(["top", "bottom"]);
function pl(e) {
  return Cae.has(kc(e)) ? "y" : "x";
}
function RR(e) {
  return MR(pl(e));
}
function Oae(e, t, n) {
  n === void 0 && (n = !1);
  const r = rg(e), a = RR(e), s = NR(a);
  let l = a === "x" ? r === (n ? "end" : "start") ? "right" : "left" : r === "start" ? "bottom" : "top";
  return t.reference[s] > t.floating[s] && (l = a_(l)), [l, a_(l)];
}
function Mae(e) {
  const t = a_(e);
  return [w5(e), t, w5(t)];
}
function w5(e) {
  return e.replace(/start|end/g, (t) => Eae[t]);
}
const wD = ["left", "right"], xD = ["right", "left"], Nae = ["top", "bottom"], Rae = ["bottom", "top"];
function Aae(e, t, n) {
  switch (e) {
    case "top":
    case "bottom":
      return n ? t ? xD : wD : t ? wD : xD;
    case "left":
    case "right":
      return t ? Nae : Rae;
    default:
      return [];
  }
}
function jae(e, t, n, r) {
  const a = rg(e);
  let s = Aae(kc(e), n === "start", r);
  return a && (s = s.map((l) => l + "-" + a), t && (s = s.concat(s.map(w5)))), s;
}
function a_(e) {
  return e.replace(/left|right|bottom|top/g, (t) => _ae[t]);
}
function Pae(e) {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    ...e
  };
}
function o8(e) {
  return typeof e != "number" ? Pae(e) : {
    top: e,
    right: e,
    bottom: e,
    left: e
  };
}
function i_(e) {
  const {
    x: t,
    y: n,
    width: r,
    height: a
  } = e;
  return {
    width: r,
    height: a,
    top: n,
    left: t,
    right: t + r,
    bottom: n + a,
    x: t,
    y: n
  };
}
function SD(e, t, n) {
  let {
    reference: r,
    floating: a
  } = e;
  const s = pl(t), l = RR(t), c = NR(l), d = kc(t), p = s === "y", m = r.x + r.width / 2 - a.width / 2, h = r.y + r.height / 2 - a.height / 2, v = r[c] / 2 - a[c] / 2;
  let y;
  switch (d) {
    case "top":
      y = {
        x: m,
        y: r.y - a.height
      };
      break;
    case "bottom":
      y = {
        x: m,
        y: r.y + r.height
      };
      break;
    case "right":
      y = {
        x: r.x + r.width,
        y: h
      };
      break;
    case "left":
      y = {
        x: r.x - a.width,
        y: h
      };
      break;
    default:
      y = {
        x: r.x,
        y: r.y
      };
  }
  switch (rg(t)) {
    case "start":
      y[l] -= v * (n && p ? -1 : 1);
      break;
    case "end":
      y[l] += v * (n && p ? -1 : 1);
      break;
  }
  return y;
}
const Dae = async (e, t, n) => {
  const {
    placement: r = "bottom",
    strategy: a = "absolute",
    middleware: s = [],
    platform: l
  } = n, c = s.filter(Boolean), d = await (l.isRTL == null ? void 0 : l.isRTL(t));
  let p = await l.getElementRects({
    reference: e,
    floating: t,
    strategy: a
  }), {
    x: m,
    y: h
  } = SD(p, r, d), v = r, y = {}, w = 0;
  for (let x = 0; x < c.length; x++) {
    const {
      name: b,
      fn: k
    } = c[x], {
      x: C,
      y: _,
      data: O,
      reset: N
    } = await k({
      x: m,
      y: h,
      initialPlacement: r,
      placement: v,
      strategy: a,
      middlewareData: y,
      rects: p,
      platform: l,
      elements: {
        reference: e,
        floating: t
      }
    });
    m = C ?? m, h = _ ?? h, y = {
      ...y,
      [b]: {
        ...y[b],
        ...O
      }
    }, N && w <= 50 && (w++, typeof N == "object" && (N.placement && (v = N.placement), N.rects && (p = N.rects === !0 ? await l.getElementRects({
      reference: e,
      floating: t,
      strategy: a
    }) : N.rects), {
      x: m,
      y: h
    } = SD(p, v, d)), x = -1);
  }
  return {
    x: m,
    y: h,
    placement: v,
    strategy: a,
    middlewareData: y
  };
};
async function vx(e, t) {
  var n;
  t === void 0 && (t = {});
  const {
    x: r,
    y: a,
    platform: s,
    rects: l,
    elements: c,
    strategy: d
  } = e, {
    boundary: p = "clippingAncestors",
    rootBoundary: m = "viewport",
    elementContext: h = "floating",
    altBoundary: v = !1,
    padding: y = 0
  } = Sc(t, e), w = o8(y), x = c[v ? h === "floating" ? "reference" : "floating" : h], b = i_(await s.getClippingRect({
    element: (n = await (s.isElement == null ? void 0 : s.isElement(x))) == null || n ? x : x.contextElement || await (s.getDocumentElement == null ? void 0 : s.getDocumentElement(c.floating)),
    boundary: p,
    rootBoundary: m,
    strategy: d
  })), k = h === "floating" ? {
    x: r,
    y: a,
    width: l.floating.width,
    height: l.floating.height
  } : l.reference, C = await (s.getOffsetParent == null ? void 0 : s.getOffsetParent(c.floating)), _ = await (s.isElement == null ? void 0 : s.isElement(C)) ? await (s.getScale == null ? void 0 : s.getScale(C)) || {
    x: 1,
    y: 1
  } : {
    x: 1,
    y: 1
  }, O = i_(s.convertOffsetParentRelativeRectToViewportRelativeRect ? await s.convertOffsetParentRelativeRectToViewportRelativeRect({
    elements: c,
    rect: k,
    offsetParent: C,
    strategy: d
  }) : k);
  return {
    top: (b.top - O.top + w.top) / _.y,
    bottom: (O.bottom - b.bottom + w.bottom) / _.y,
    left: (b.left - O.left + w.left) / _.x,
    right: (O.right - b.right + w.right) / _.x
  };
}
const $ae = (e) => ({
  name: "arrow",
  options: e,
  async fn(t) {
    const {
      x: n,
      y: r,
      placement: a,
      rects: s,
      platform: l,
      elements: c,
      middlewareData: d
    } = t, {
      element: p,
      padding: m = 0
    } = Sc(e, t) || {};
    if (p == null)
      return {};
    const h = o8(m), v = {
      x: n,
      y: r
    }, y = RR(a), w = NR(y), x = await l.getDimensions(p), b = y === "y", k = b ? "top" : "left", C = b ? "bottom" : "right", _ = b ? "clientHeight" : "clientWidth", O = s.reference[w] + s.reference[y] - v[y] - s.floating[w], N = v[y] - s.reference[y], R = await (l.getOffsetParent == null ? void 0 : l.getOffsetParent(p));
    let j = R ? R[_] : 0;
    (!j || !await (l.isElement == null ? void 0 : l.isElement(R))) && (j = c.floating[_] || s.floating[w]);
    const D = O / 2 - N / 2, $ = j / 2 - x[w] / 2 - 1, z = ud(h[k], $), B = ud(h[C], $), P = z, W = j - x[w] - B, I = j / 2 - x[w] / 2 + D, G = b5(P, I, W), L = !d.arrow && rg(a) != null && I !== G && s.reference[w] / 2 - (I < P ? z : B) - x[w] / 2 < 0, K = L ? I < P ? I - P : I - W : 0;
    return {
      [y]: v[y] + K,
      data: {
        [y]: G,
        centerOffset: I - G - K,
        ...L && {
          alignmentOffset: K
        }
      },
      reset: L
    };
  }
}), Tae = function(e) {
  return e === void 0 && (e = {}), {
    name: "flip",
    options: e,
    async fn(t) {
      var n, r;
      const {
        placement: a,
        middlewareData: s,
        rects: l,
        initialPlacement: c,
        platform: d,
        elements: p
      } = t, {
        mainAxis: m = !0,
        crossAxis: h = !0,
        fallbackPlacements: v,
        fallbackStrategy: y = "bestFit",
        fallbackAxisSideDirection: w = "none",
        flipAlignment: x = !0,
        ...b
      } = Sc(e, t);
      if ((n = s.arrow) != null && n.alignmentOffset)
        return {};
      const k = kc(a), C = pl(c), _ = kc(c) === c, O = await (d.isRTL == null ? void 0 : d.isRTL(p.floating)), N = v || (_ || !x ? [a_(c)] : Mae(c)), R = w !== "none";
      !v && R && N.push(...jae(c, x, w, O));
      const j = [c, ...N], D = await vx(t, b), $ = [];
      let z = ((r = s.flip) == null ? void 0 : r.overflows) || [];
      if (m && $.push(D[k]), h) {
        const I = Oae(a, l, O);
        $.push(D[I[0]], D[I[1]]);
      }
      if (z = [...z, {
        placement: a,
        overflows: $
      }], !$.every((I) => I <= 0)) {
        var B, P;
        const I = (((B = s.flip) == null ? void 0 : B.index) || 0) + 1, G = j[I];
        if (G && (!(h === "alignment" && C !== pl(G)) || // We leave the current main axis only if every placement on that axis
        // overflows the main axis.
        z.every((K) => K.overflows[0] > 0 && pl(K.placement) === C)))
          return {
            data: {
              index: I,
              overflows: z
            },
            reset: {
              placement: G
            }
          };
        let L = (P = z.filter((K) => K.overflows[0] <= 0).sort((K, q) => K.overflows[1] - q.overflows[1])[0]) == null ? void 0 : P.placement;
        if (!L)
          switch (y) {
            case "bestFit": {
              var W;
              const K = (W = z.filter((q) => {
                if (R) {
                  const Z = pl(q.placement);
                  return Z === C || // Create a bias to the `y` side axis due to horizontal
                  // reading directions favoring greater width.
                  Z === "y";
                }
                return !0;
              }).map((q) => [q.placement, q.overflows.filter((Z) => Z > 0).reduce((Z, V) => Z + V, 0)]).sort((q, Z) => q[1] - Z[1])[0]) == null ? void 0 : W[0];
              K && (L = K);
              break;
            }
            case "initialPlacement":
              L = c;
              break;
          }
        if (a !== L)
          return {
            reset: {
              placement: L
            }
          };
      }
      return {};
    }
  };
};
function kD(e, t) {
  return {
    top: e.top - t.height,
    right: e.right - t.width,
    bottom: e.bottom - t.height,
    left: e.left - t.width
  };
}
function _D(e) {
  return kae.some((t) => e[t] >= 0);
}
const Lae = function(e) {
  return e === void 0 && (e = {}), {
    name: "hide",
    options: e,
    async fn(t) {
      const {
        rects: n
      } = t, {
        strategy: r = "referenceHidden",
        ...a
      } = Sc(e, t);
      switch (r) {
        case "referenceHidden": {
          const s = await vx(t, {
            ...a,
            elementContext: "reference"
          }), l = kD(s, n.reference);
          return {
            data: {
              referenceHiddenOffsets: l,
              referenceHidden: _D(l)
            }
          };
        }
        case "escaped": {
          const s = await vx(t, {
            ...a,
            altBoundary: !0
          }), l = kD(s, n.floating);
          return {
            data: {
              escapedOffsets: l,
              escaped: _D(l)
            }
          };
        }
        default:
          return {};
      }
    }
  };
}, a8 = /* @__PURE__ */ new Set(["left", "top"]);
async function Iae(e, t) {
  const {
    placement: n,
    platform: r,
    elements: a
  } = e, s = await (r.isRTL == null ? void 0 : r.isRTL(a.floating)), l = kc(n), c = rg(n), d = pl(n) === "y", p = a8.has(l) ? -1 : 1, m = s && d ? -1 : 1, h = Sc(t, e);
  let {
    mainAxis: v,
    crossAxis: y,
    alignmentAxis: w
  } = typeof h == "number" ? {
    mainAxis: h,
    crossAxis: 0,
    alignmentAxis: null
  } : {
    mainAxis: h.mainAxis || 0,
    crossAxis: h.crossAxis || 0,
    alignmentAxis: h.alignmentAxis
  };
  return c && typeof w == "number" && (y = c === "end" ? w * -1 : w), d ? {
    x: y * m,
    y: v * p
  } : {
    x: v * p,
    y: y * m
  };
}
const zae = function(e) {
  return e === void 0 && (e = 0), {
    name: "offset",
    options: e,
    async fn(t) {
      var n, r;
      const {
        x: a,
        y: s,
        placement: l,
        middlewareData: c
      } = t, d = await Iae(t, e);
      return l === ((n = c.offset) == null ? void 0 : n.placement) && (r = c.arrow) != null && r.alignmentOffset ? {} : {
        x: a + d.x,
        y: s + d.y,
        data: {
          ...d,
          placement: l
        }
      };
    }
  };
}, Fae = function(e) {
  return e === void 0 && (e = {}), {
    name: "shift",
    options: e,
    async fn(t) {
      const {
        x: n,
        y: r,
        placement: a
      } = t, {
        mainAxis: s = !0,
        crossAxis: l = !1,
        limiter: c = {
          fn: (b) => {
            let {
              x: k,
              y: C
            } = b;
            return {
              x: k,
              y: C
            };
          }
        },
        ...d
      } = Sc(e, t), p = {
        x: n,
        y: r
      }, m = await vx(t, d), h = pl(kc(a)), v = MR(h);
      let y = p[v], w = p[h];
      if (s) {
        const b = v === "y" ? "top" : "left", k = v === "y" ? "bottom" : "right", C = y + m[b], _ = y - m[k];
        y = b5(C, y, _);
      }
      if (l) {
        const b = h === "y" ? "top" : "left", k = h === "y" ? "bottom" : "right", C = w + m[b], _ = w - m[k];
        w = b5(C, w, _);
      }
      const x = c.fn({
        ...t,
        [v]: y,
        [h]: w
      });
      return {
        ...x,
        data: {
          x: x.x - n,
          y: x.y - r,
          enabled: {
            [v]: s,
            [h]: l
          }
        }
      };
    }
  };
}, Bae = function(e) {
  return e === void 0 && (e = {}), {
    options: e,
    fn(t) {
      const {
        x: n,
        y: r,
        placement: a,
        rects: s,
        middlewareData: l
      } = t, {
        offset: c = 0,
        mainAxis: d = !0,
        crossAxis: p = !0
      } = Sc(e, t), m = {
        x: n,
        y: r
      }, h = pl(a), v = MR(h);
      let y = m[v], w = m[h];
      const x = Sc(c, t), b = typeof x == "number" ? {
        mainAxis: x,
        crossAxis: 0
      } : {
        mainAxis: 0,
        crossAxis: 0,
        ...x
      };
      if (d) {
        const _ = v === "y" ? "height" : "width", O = s.reference[v] - s.floating[_] + b.mainAxis, N = s.reference[v] + s.reference[_] - b.mainAxis;
        y < O ? y = O : y > N && (y = N);
      }
      if (p) {
        var k, C;
        const _ = v === "y" ? "width" : "height", O = a8.has(kc(a)), N = s.reference[h] - s.floating[_] + (O && ((k = l.offset) == null ? void 0 : k[h]) || 0) + (O ? 0 : b.crossAxis), R = s.reference[h] + s.reference[_] + (O ? 0 : ((C = l.offset) == null ? void 0 : C[h]) || 0) - (O ? b.crossAxis : 0);
        w < N ? w = N : w > R && (w = R);
      }
      return {
        [v]: y,
        [h]: w
      };
    }
  };
}, Uae = function(e) {
  return e === void 0 && (e = {}), {
    name: "size",
    options: e,
    async fn(t) {
      var n, r;
      const {
        placement: a,
        rects: s,
        platform: l,
        elements: c
      } = t, {
        apply: d = () => {
        },
        ...p
      } = Sc(e, t), m = await vx(t, p), h = kc(a), v = rg(a), y = pl(a) === "y", {
        width: w,
        height: x
      } = s.floating;
      let b, k;
      h === "top" || h === "bottom" ? (b = h, k = v === (await (l.isRTL == null ? void 0 : l.isRTL(c.floating)) ? "start" : "end") ? "left" : "right") : (k = h, b = v === "end" ? "top" : "bottom");
      const C = x - m.top - m.bottom, _ = w - m.left - m.right, O = ud(x - m[b], C), N = ud(w - m[k], _), R = !t.middlewareData.shift;
      let j = O, D = N;
      if ((n = t.middlewareData.shift) != null && n.enabled.x && (D = _), (r = t.middlewareData.shift) != null && r.enabled.y && (j = C), R && !v) {
        const z = mi(m.left, 0), B = mi(m.right, 0), P = mi(m.top, 0), W = mi(m.bottom, 0);
        y ? D = w - 2 * (z !== 0 || B !== 0 ? z + B : mi(m.left, m.right)) : j = x - 2 * (P !== 0 || W !== 0 ? P + W : mi(m.top, m.bottom));
      }
      await d({
        ...t,
        availableWidth: D,
        availableHeight: j
      });
      const $ = await l.getDimensions(c.floating);
      return w !== $.width || x !== $.height ? {
        reset: {
          rects: !0
        }
      } : {};
    }
  };
};
function E2() {
  return typeof window < "u";
}
function og(e) {
  return i8(e) ? (e.nodeName || "").toLowerCase() : "#document";
}
function yi(e) {
  var t;
  return (e == null || (t = e.ownerDocument) == null ? void 0 : t.defaultView) || window;
}
function Dl(e) {
  var t;
  return (t = (i8(e) ? e.ownerDocument : e.document) || window.document) == null ? void 0 : t.documentElement;
}
function i8(e) {
  return E2() ? e instanceof Node || e instanceof yi(e).Node : !1;
}
function Bs(e) {
  return E2() ? e instanceof Element || e instanceof yi(e).Element : !1;
}
function Ol(e) {
  return E2() ? e instanceof HTMLElement || e instanceof yi(e).HTMLElement : !1;
}
function ED(e) {
  return !E2() || typeof ShadowRoot > "u" ? !1 : e instanceof ShadowRoot || e instanceof yi(e).ShadowRoot;
}
const Vae = /* @__PURE__ */ new Set(["inline", "contents"]);
function lS(e) {
  const {
    overflow: t,
    overflowX: n,
    overflowY: r,
    display: a
  } = Us(e);
  return /auto|scroll|overlay|hidden|clip/.test(t + r + n) && !Vae.has(a);
}
const Hae = /* @__PURE__ */ new Set(["table", "td", "th"]);
function qae(e) {
  return Hae.has(og(e));
}
const Wae = [":popover-open", ":modal"];
function C2(e) {
  return Wae.some((t) => {
    try {
      return e.matches(t);
    } catch {
      return !1;
    }
  });
}
const Gae = ["transform", "translate", "scale", "rotate", "perspective"], Kae = ["transform", "translate", "scale", "rotate", "perspective", "filter"], Xae = ["paint", "layout", "strict", "content"];
function AR(e) {
  const t = jR(), n = Bs(e) ? Us(e) : e;
  return Gae.some((r) => n[r] ? n[r] !== "none" : !1) || (n.containerType ? n.containerType !== "normal" : !1) || !t && (n.backdropFilter ? n.backdropFilter !== "none" : !1) || !t && (n.filter ? n.filter !== "none" : !1) || Kae.some((r) => (n.willChange || "").includes(r)) || Xae.some((r) => (n.contain || "").includes(r));
}
function Yae(e) {
  let t = cd(e);
  for (; Ol(t) && !Dh(t); ) {
    if (AR(t))
      return t;
    if (C2(t))
      return null;
    t = cd(t);
  }
  return null;
}
function jR() {
  return typeof CSS > "u" || !CSS.supports ? !1 : CSS.supports("-webkit-backdrop-filter", "none");
}
const Qae = /* @__PURE__ */ new Set(["html", "body", "#document"]);
function Dh(e) {
  return Qae.has(og(e));
}
function Us(e) {
  return yi(e).getComputedStyle(e);
}
function O2(e) {
  return Bs(e) ? {
    scrollLeft: e.scrollLeft,
    scrollTop: e.scrollTop
  } : {
    scrollLeft: e.scrollX,
    scrollTop: e.scrollY
  };
}
function cd(e) {
  if (og(e) === "html")
    return e;
  const t = (
    // Step into the shadow DOM of the parent of a slotted node.
    e.assignedSlot || // DOM Element detected.
    e.parentNode || // ShadowRoot detected.
    ED(e) && e.host || // Fallback.
    Dl(e)
  );
  return ED(t) ? t.host : t;
}
function s8(e) {
  const t = cd(e);
  return Dh(t) ? e.ownerDocument ? e.ownerDocument.body : e.body : Ol(t) && lS(t) ? t : s8(t);
}
function yx(e, t, n) {
  var r;
  t === void 0 && (t = []), n === void 0 && (n = !0);
  const a = s8(e), s = a === ((r = e.ownerDocument) == null ? void 0 : r.body), l = yi(a);
  if (s) {
    const c = x5(l);
    return t.concat(l, l.visualViewport || [], lS(a) ? a : [], c && n ? yx(c) : []);
  }
  return t.concat(a, yx(a, [], n));
}
function x5(e) {
  return e.parent && Object.getPrototypeOf(e.parent) ? e.frameElement : null;
}
function l8(e) {
  const t = Us(e);
  let n = parseFloat(t.width) || 0, r = parseFloat(t.height) || 0;
  const a = Ol(e), s = a ? e.offsetWidth : n, l = a ? e.offsetHeight : r, c = o_(n) !== s || o_(r) !== l;
  return c && (n = s, r = l), {
    width: n,
    height: r,
    $: c
  };
}
function PR(e) {
  return Bs(e) ? e : e.contextElement;
}
function Sh(e) {
  const t = PR(e);
  if (!Ol(t))
    return El(1);
  const n = t.getBoundingClientRect(), {
    width: r,
    height: a,
    $: s
  } = l8(t);
  let l = (s ? o_(n.width) : n.width) / r, c = (s ? o_(n.height) : n.height) / a;
  return (!l || !Number.isFinite(l)) && (l = 1), (!c || !Number.isFinite(c)) && (c = 1), {
    x: l,
    y: c
  };
}
const Jae = /* @__PURE__ */ El(0);
function u8(e) {
  const t = yi(e);
  return !jR() || !t.visualViewport ? Jae : {
    x: t.visualViewport.offsetLeft,
    y: t.visualViewport.offsetTop
  };
}
function Zae(e, t, n) {
  return t === void 0 && (t = !1), !n || t && n !== yi(e) ? !1 : t;
}
function um(e, t, n, r) {
  t === void 0 && (t = !1), n === void 0 && (n = !1);
  const a = e.getBoundingClientRect(), s = PR(e);
  let l = El(1);
  t && (r ? Bs(r) && (l = Sh(r)) : l = Sh(e));
  const c = Zae(s, n, r) ? u8(s) : El(0);
  let d = (a.left + c.x) / l.x, p = (a.top + c.y) / l.y, m = a.width / l.x, h = a.height / l.y;
  if (s) {
    const v = yi(s), y = r && Bs(r) ? yi(r) : r;
    let w = v, x = x5(w);
    for (; x && r && y !== w; ) {
      const b = Sh(x), k = x.getBoundingClientRect(), C = Us(x), _ = k.left + (x.clientLeft + parseFloat(C.paddingLeft)) * b.x, O = k.top + (x.clientTop + parseFloat(C.paddingTop)) * b.y;
      d *= b.x, p *= b.y, m *= b.x, h *= b.y, d += _, p += O, w = yi(x), x = x5(w);
    }
  }
  return i_({
    width: m,
    height: h,
    x: d,
    y: p
  });
}
function DR(e, t) {
  const n = O2(e).scrollLeft;
  return t ? t.left + n : um(Dl(e)).left + n;
}
function c8(e, t, n) {
  n === void 0 && (n = !1);
  const r = e.getBoundingClientRect(), a = r.left + t.scrollLeft - (n ? 0 : (
    // RTL <body> scrollbar.
    DR(e, r)
  )), s = r.top + t.scrollTop;
  return {
    x: a,
    y: s
  };
}
function eie(e) {
  let {
    elements: t,
    rect: n,
    offsetParent: r,
    strategy: a
  } = e;
  const s = a === "fixed", l = Dl(r), c = t ? C2(t.floating) : !1;
  if (r === l || c && s)
    return n;
  let d = {
    scrollLeft: 0,
    scrollTop: 0
  }, p = El(1);
  const m = El(0), h = Ol(r);
  if ((h || !h && !s) && ((og(r) !== "body" || lS(l)) && (d = O2(r)), Ol(r))) {
    const y = um(r);
    p = Sh(r), m.x = y.x + r.clientLeft, m.y = y.y + r.clientTop;
  }
  const v = l && !h && !s ? c8(l, d, !0) : El(0);
  return {
    width: n.width * p.x,
    height: n.height * p.y,
    x: n.x * p.x - d.scrollLeft * p.x + m.x + v.x,
    y: n.y * p.y - d.scrollTop * p.y + m.y + v.y
  };
}
function tie(e) {
  return Array.from(e.getClientRects());
}
function nie(e) {
  const t = Dl(e), n = O2(e), r = e.ownerDocument.body, a = mi(t.scrollWidth, t.clientWidth, r.scrollWidth, r.clientWidth), s = mi(t.scrollHeight, t.clientHeight, r.scrollHeight, r.clientHeight);
  let l = -n.scrollLeft + DR(e);
  const c = -n.scrollTop;
  return Us(r).direction === "rtl" && (l += mi(t.clientWidth, r.clientWidth) - a), {
    width: a,
    height: s,
    x: l,
    y: c
  };
}
function rie(e, t) {
  const n = yi(e), r = Dl(e), a = n.visualViewport;
  let s = r.clientWidth, l = r.clientHeight, c = 0, d = 0;
  if (a) {
    s = a.width, l = a.height;
    const p = jR();
    (!p || p && t === "fixed") && (c = a.offsetLeft, d = a.offsetTop);
  }
  return {
    width: s,
    height: l,
    x: c,
    y: d
  };
}
const oie = /* @__PURE__ */ new Set(["absolute", "fixed"]);
function aie(e, t) {
  const n = um(e, !0, t === "fixed"), r = n.top + e.clientTop, a = n.left + e.clientLeft, s = Ol(e) ? Sh(e) : El(1), l = e.clientWidth * s.x, c = e.clientHeight * s.y, d = a * s.x, p = r * s.y;
  return {
    width: l,
    height: c,
    x: d,
    y: p
  };
}
function CD(e, t, n) {
  let r;
  if (t === "viewport")
    r = rie(e, n);
  else if (t === "document")
    r = nie(Dl(e));
  else if (Bs(t))
    r = aie(t, n);
  else {
    const a = u8(e);
    r = {
      x: t.x - a.x,
      y: t.y - a.y,
      width: t.width,
      height: t.height
    };
  }
  return i_(r);
}
function d8(e, t) {
  const n = cd(e);
  return n === t || !Bs(n) || Dh(n) ? !1 : Us(n).position === "fixed" || d8(n, t);
}
function iie(e, t) {
  const n = t.get(e);
  if (n)
    return n;
  let r = yx(e, [], !1).filter((c) => Bs(c) && og(c) !== "body"), a = null;
  const s = Us(e).position === "fixed";
  let l = s ? cd(e) : e;
  for (; Bs(l) && !Dh(l); ) {
    const c = Us(l), d = AR(l);
    !d && c.position === "fixed" && (a = null), (s ? !d && !a : !d && c.position === "static" && a && oie.has(a.position) || lS(l) && !d && d8(e, l)) ? r = r.filter((p) => p !== l) : a = c, l = cd(l);
  }
  return t.set(e, r), r;
}
function sie(e) {
  let {
    element: t,
    boundary: n,
    rootBoundary: r,
    strategy: a
  } = e;
  const s = [...n === "clippingAncestors" ? C2(t) ? [] : iie(t, this._c) : [].concat(n), r], l = s[0], c = s.reduce((d, p) => {
    const m = CD(t, p, a);
    return d.top = mi(m.top, d.top), d.right = ud(m.right, d.right), d.bottom = ud(m.bottom, d.bottom), d.left = mi(m.left, d.left), d;
  }, CD(t, l, a));
  return {
    width: c.right - c.left,
    height: c.bottom - c.top,
    x: c.left,
    y: c.top
  };
}
function lie(e) {
  const {
    width: t,
    height: n
  } = l8(e);
  return {
    width: t,
    height: n
  };
}
function uie(e, t, n) {
  const r = Ol(t), a = Dl(t), s = n === "fixed", l = um(e, !0, s, t);
  let c = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const d = El(0);
  function p() {
    d.x = DR(a);
  }
  if (r || !r && !s)
    if ((og(t) !== "body" || lS(a)) && (c = O2(t)), r) {
      const y = um(t, !0, s, t);
      d.x = y.x + t.clientLeft, d.y = y.y + t.clientTop;
    } else a && p();
  s && !r && a && p();
  const m = a && !r && !s ? c8(a, c) : El(0), h = l.left + c.scrollLeft - d.x - m.x, v = l.top + c.scrollTop - d.y - m.y;
  return {
    x: h,
    y: v,
    width: l.width,
    height: l.height
  };
}
function gM(e) {
  return Us(e).position === "static";
}
function OD(e, t) {
  if (!Ol(e) || Us(e).position === "fixed")
    return null;
  if (t)
    return t(e);
  let n = e.offsetParent;
  return Dl(e) === n && (n = n.ownerDocument.body), n;
}
function f8(e, t) {
  const n = yi(e);
  if (C2(e))
    return n;
  if (!Ol(e)) {
    let a = cd(e);
    for (; a && !Dh(a); ) {
      if (Bs(a) && !gM(a))
        return a;
      a = cd(a);
    }
    return n;
  }
  let r = OD(e, t);
  for (; r && qae(r) && gM(r); )
    r = OD(r, t);
  return r && Dh(r) && gM(r) && !AR(r) ? n : r || Yae(e) || n;
}
const cie = async function(e) {
  const t = this.getOffsetParent || f8, n = this.getDimensions, r = await n(e.floating);
  return {
    reference: uie(e.reference, await t(e.floating), e.strategy),
    floating: {
      x: 0,
      y: 0,
      width: r.width,
      height: r.height
    }
  };
};
function die(e) {
  return Us(e).direction === "rtl";
}
const fie = {
  convertOffsetParentRelativeRectToViewportRelativeRect: eie,
  getDocumentElement: Dl,
  getClippingRect: sie,
  getOffsetParent: f8,
  getElementRects: cie,
  getClientRects: tie,
  getDimensions: lie,
  getScale: Sh,
  isElement: Bs,
  isRTL: die
};
function p8(e, t) {
  return e.x === t.x && e.y === t.y && e.width === t.width && e.height === t.height;
}
function pie(e, t) {
  let n = null, r;
  const a = Dl(e);
  function s() {
    var c;
    clearTimeout(r), (c = n) == null || c.disconnect(), n = null;
  }
  function l(c, d) {
    c === void 0 && (c = !1), d === void 0 && (d = 1), s();
    const p = e.getBoundingClientRect(), {
      left: m,
      top: h,
      width: v,
      height: y
    } = p;
    if (c || t(), !v || !y)
      return;
    const w = JS(h), x = JS(a.clientWidth - (m + v)), b = JS(a.clientHeight - (h + y)), k = JS(m), C = {
      rootMargin: -w + "px " + -x + "px " + -b + "px " + -k + "px",
      threshold: mi(0, ud(1, d)) || 1
    };
    let _ = !0;
    function O(N) {
      const R = N[0].intersectionRatio;
      if (R !== d) {
        if (!_)
          return l();
        R ? l(!1, R) : r = setTimeout(() => {
          l(!1, 1e-7);
        }, 1e3);
      }
      R === 1 && !p8(p, e.getBoundingClientRect()) && l(), _ = !1;
    }
    try {
      n = new IntersectionObserver(O, {
        ...C,
        // Handle <iframe>s
        root: a.ownerDocument
      });
    } catch {
      n = new IntersectionObserver(O, C);
    }
    n.observe(e);
  }
  return l(!0), s;
}
function m8(e, t, n, r) {
  r === void 0 && (r = {});
  const {
    ancestorScroll: a = !0,
    ancestorResize: s = !0,
    elementResize: l = typeof ResizeObserver == "function",
    layoutShift: c = typeof IntersectionObserver == "function",
    animationFrame: d = !1
  } = r, p = PR(e), m = a || s ? [...p ? yx(p) : [], ...yx(t)] : [];
  m.forEach((k) => {
    a && k.addEventListener("scroll", n, {
      passive: !0
    }), s && k.addEventListener("resize", n);
  });
  const h = p && c ? pie(p, n) : null;
  let v = -1, y = null;
  l && (y = new ResizeObserver((k) => {
    let [C] = k;
    C && C.target === p && y && (y.unobserve(t), cancelAnimationFrame(v), v = requestAnimationFrame(() => {
      var _;
      (_ = y) == null || _.observe(t);
    })), n();
  }), p && !d && y.observe(p), y.observe(t));
  let w, x = d ? um(e) : null;
  d && b();
  function b() {
    const k = um(e);
    x && !p8(x, k) && n(), x = k, w = requestAnimationFrame(b);
  }
  return n(), () => {
    var k;
    m.forEach((C) => {
      a && C.removeEventListener("scroll", n), s && C.removeEventListener("resize", n);
    }), h?.(), (k = y) == null || k.disconnect(), y = null, d && cancelAnimationFrame(w);
  };
}
const mie = zae, hie = Fae, gie = Tae, vie = Uae, yie = Lae, MD = $ae, bie = Bae, wie = (e, t, n) => {
  const r = /* @__PURE__ */ new Map(), a = {
    platform: fie,
    ...n
  }, s = {
    ...a.platform,
    _c: r
  };
  return Dae(e, t, {
    ...a,
    platform: s
  });
};
var xie = typeof document < "u", Sie = function() {
}, C0 = xie ? M.useLayoutEffect : Sie;
function s_(e, t) {
  if (e === t)
    return !0;
  if (typeof e != typeof t)
    return !1;
  if (typeof e == "function" && e.toString() === t.toString())
    return !0;
  let n, r, a;
  if (e && t && typeof e == "object") {
    if (Array.isArray(e)) {
      if (n = e.length, n !== t.length) return !1;
      for (r = n; r-- !== 0; )
        if (!s_(e[r], t[r]))
          return !1;
      return !0;
    }
    if (a = Object.keys(e), n = a.length, n !== Object.keys(t).length)
      return !1;
    for (r = n; r-- !== 0; )
      if (!{}.hasOwnProperty.call(t, a[r]))
        return !1;
    for (r = n; r-- !== 0; ) {
      const s = a[r];
      if (!(s === "_owner" && e.$$typeof) && !s_(e[s], t[s]))
        return !1;
    }
    return !0;
  }
  return e !== e && t !== t;
}
function h8(e) {
  return typeof window > "u" ? 1 : (e.ownerDocument.defaultView || window).devicePixelRatio || 1;
}
function ND(e, t) {
  const n = h8(e);
  return Math.round(t * n) / n;
}
function vM(e) {
  const t = M.useRef(e);
  return C0(() => {
    t.current = e;
  }), t;
}
function kie(e) {
  e === void 0 && (e = {});
  const {
    placement: t = "bottom",
    strategy: n = "absolute",
    middleware: r = [],
    platform: a,
    elements: {
      reference: s,
      floating: l
    } = {},
    transform: c = !0,
    whileElementsMounted: d,
    open: p
  } = e, [m, h] = M.useState({
    x: 0,
    y: 0,
    strategy: n,
    placement: t,
    middlewareData: {},
    isPositioned: !1
  }), [v, y] = M.useState(r);
  s_(v, r) || y(r);
  const [w, x] = M.useState(null), [b, k] = M.useState(null), C = M.useCallback((q) => {
    q !== R.current && (R.current = q, x(q));
  }, []), _ = M.useCallback((q) => {
    q !== j.current && (j.current = q, k(q));
  }, []), O = s || w, N = l || b, R = M.useRef(null), j = M.useRef(null), D = M.useRef(m), $ = d != null, z = vM(d), B = vM(a), P = vM(p), W = M.useCallback(() => {
    if (!R.current || !j.current)
      return;
    const q = {
      placement: t,
      strategy: n,
      middleware: v
    };
    B.current && (q.platform = B.current), wie(R.current, j.current, q).then((Z) => {
      const V = {
        ...Z,
        // The floating element's position may be recomputed while it's closed
        // but still mounted (such as when transitioning out). To ensure
        // `isPositioned` will be `false` initially on the next open, avoid
        // setting it to `true` when `open === false` (must be specified).
        isPositioned: P.current !== !1
      };
      I.current && !s_(D.current, V) && (D.current = V, xm.flushSync(() => {
        h(V);
      }));
    });
  }, [v, t, n, B, P]);
  C0(() => {
    p === !1 && D.current.isPositioned && (D.current.isPositioned = !1, h((q) => ({
      ...q,
      isPositioned: !1
    })));
  }, [p]);
  const I = M.useRef(!1);
  C0(() => (I.current = !0, () => {
    I.current = !1;
  }), []), C0(() => {
    if (O && (R.current = O), N && (j.current = N), O && N) {
      if (z.current)
        return z.current(O, N, W);
      W();
    }
  }, [O, N, W, z, $]);
  const G = M.useMemo(() => ({
    reference: R,
    floating: j,
    setReference: C,
    setFloating: _
  }), [C, _]), L = M.useMemo(() => ({
    reference: O,
    floating: N
  }), [O, N]), K = M.useMemo(() => {
    const q = {
      position: n,
      left: 0,
      top: 0
    };
    if (!L.floating)
      return q;
    const Z = ND(L.floating, m.x), V = ND(L.floating, m.y);
    return c ? {
      ...q,
      transform: "translate(" + Z + "px, " + V + "px)",
      ...h8(L.floating) >= 1.5 && {
        willChange: "transform"
      }
    } : {
      position: n,
      left: Z,
      top: V
    };
  }, [n, c, L.floating, m.x, m.y]);
  return M.useMemo(() => ({
    ...m,
    update: W,
    refs: G,
    elements: L,
    floatingStyles: K
  }), [m, W, G, L, K]);
}
const _ie = (e) => {
  function t(n) {
    return {}.hasOwnProperty.call(n, "current");
  }
  return {
    name: "arrow",
    options: e,
    fn(n) {
      const {
        element: r,
        padding: a
      } = typeof e == "function" ? e(n) : e;
      return r && t(r) ? r.current != null ? MD({
        element: r.current,
        padding: a
      }).fn(n) : {} : r ? MD({
        element: r,
        padding: a
      }).fn(n) : {};
    }
  };
}, Eie = (e, t) => ({
  ...mie(e),
  options: [e, t]
}), Cie = (e, t) => ({
  ...hie(e),
  options: [e, t]
}), Oie = (e, t) => ({
  ...bie(e),
  options: [e, t]
}), Mie = (e, t) => ({
  ...gie(e),
  options: [e, t]
}), Nie = (e, t) => ({
  ...vie(e),
  options: [e, t]
}), Rie = (e, t) => ({
  ...yie(e),
  options: [e, t]
}), Aie = (e, t) => ({
  ..._ie(e),
  options: [e, t]
});
var jie = "Arrow", g8 = M.forwardRef((e, t) => {
  const { children: n, width: r = 10, height: a = 5, ...s } = e;
  return /* @__PURE__ */ E.jsx(
    Kt.svg,
    {
      ...s,
      ref: t,
      width: r,
      height: a,
      viewBox: "0 0 30 10",
      preserveAspectRatio: "none",
      children: e.asChild ? n : /* @__PURE__ */ E.jsx("polygon", { points: "0,0 30,0 15,10" })
    }
  );
});
g8.displayName = jie;
var Pie = g8;
function v8(e) {
  const [t, n] = M.useState(void 0);
  return bc(() => {
    if (e) {
      n({ width: e.offsetWidth, height: e.offsetHeight });
      const r = new ResizeObserver((a) => {
        if (!Array.isArray(a) || !a.length)
          return;
        const s = a[0];
        let l, c;
        if ("borderBoxSize" in s) {
          const d = s.borderBoxSize, p = Array.isArray(d) ? d[0] : d;
          l = p.inlineSize, c = p.blockSize;
        } else
          l = e.offsetWidth, c = e.offsetHeight;
        n({ width: l, height: c });
      });
      return r.observe(e, { box: "border-box" }), () => r.unobserve(e);
    } else
      n(void 0);
  }, [e]), t;
}
var $R = "Popper", [y8, M2] = jl($R), [Die, b8] = y8($R), w8 = (e) => {
  const { __scopePopper: t, children: n } = e, [r, a] = M.useState(null);
  return /* @__PURE__ */ E.jsx(Die, { scope: t, anchor: r, onAnchorChange: a, children: n });
};
w8.displayName = $R;
var x8 = "PopperAnchor", S8 = M.forwardRef(
  (e, t) => {
    const { __scopePopper: n, virtualRef: r, ...a } = e, s = b8(x8, n), l = M.useRef(null), c = Wn(t, l), d = M.useRef(null);
    return M.useEffect(() => {
      const p = d.current;
      d.current = r?.current || l.current, p !== d.current && s.onAnchorChange(d.current);
    }), r ? null : /* @__PURE__ */ E.jsx(Kt.div, { ...a, ref: c });
  }
);
S8.displayName = x8;
var TR = "PopperContent", [$ie, Tie] = y8(TR), k8 = M.forwardRef(
  (e, t) => {
    const {
      __scopePopper: n,
      side: r = "bottom",
      sideOffset: a = 0,
      align: s = "center",
      alignOffset: l = 0,
      arrowPadding: c = 0,
      avoidCollisions: d = !0,
      collisionBoundary: p = [],
      collisionPadding: m = 0,
      sticky: h = "partial",
      hideWhenDetached: v = !1,
      updatePositionStrategy: y = "optimized",
      onPlaced: w,
      ...x
    } = e, b = b8(TR, n), [k, C] = M.useState(null), _ = Wn(t, (de) => C(de)), [O, N] = M.useState(null), R = v8(O), j = R?.width ?? 0, D = R?.height ?? 0, $ = r + (s !== "center" ? "-" + s : ""), z = typeof m == "number" ? m : { top: 0, right: 0, bottom: 0, left: 0, ...m }, B = Array.isArray(p) ? p : [p], P = B.length > 0, W = {
      padding: z,
      boundary: B.filter(Iie),
      // with `strategy: 'fixed'`, this is the only way to get it to respect boundaries
      altBoundary: P
    }, { refs: I, floatingStyles: G, placement: L, isPositioned: K, middlewareData: q } = kie({
      // default to `fixed` strategy so users don't have to pick and we also avoid focus scroll issues
      strategy: "fixed",
      placement: $,
      whileElementsMounted: (...de) => m8(...de, {
        animationFrame: y === "always"
      }),
      elements: {
        reference: b.anchor
      },
      middleware: [
        Eie({ mainAxis: a + D, alignmentAxis: l }),
        d && Cie({
          mainAxis: !0,
          crossAxis: !1,
          limiter: h === "partial" ? Oie() : void 0,
          ...W
        }),
        d && Mie({ ...W }),
        Nie({
          ...W,
          apply: ({ elements: de, rects: le, availableWidth: me, availableHeight: ve }) => {
            const { width: ae, height: se } = le.reference, pe = de.floating.style;
            pe.setProperty("--radix-popper-available-width", `${me}px`), pe.setProperty("--radix-popper-available-height", `${ve}px`), pe.setProperty("--radix-popper-anchor-width", `${ae}px`), pe.setProperty("--radix-popper-anchor-height", `${se}px`);
          }
        }),
        O && Aie({ element: O, padding: c }),
        zie({ arrowWidth: j, arrowHeight: D }),
        v && Rie({ strategy: "referenceHidden", ...W })
      ]
    }), [Z, V] = C8(L), F = Ra(w);
    bc(() => {
      K && F?.();
    }, [K, F]);
    const X = q.arrow?.x, U = q.arrow?.y, H = q.arrow?.centerOffset !== 0, [Q, re] = M.useState();
    return bc(() => {
      k && re(window.getComputedStyle(k).zIndex);
    }, [k]), /* @__PURE__ */ E.jsx(
      "div",
      {
        ref: I.setFloating,
        "data-radix-popper-content-wrapper": "",
        style: {
          ...G,
          transform: K ? G.transform : "translate(0, -200%)",
          // keep off the page when measuring
          minWidth: "max-content",
          zIndex: Q,
          "--radix-popper-transform-origin": [
            q.transformOrigin?.x,
            q.transformOrigin?.y
          ].join(" "),
          // hide the content if using the hide middleware and should be hidden
          // set visibility to hidden and disable pointer events so the UI behaves
          // as if the PopperContent isn't there at all
          ...q.hide?.referenceHidden && {
            visibility: "hidden",
            pointerEvents: "none"
          }
        },
        dir: e.dir,
        children: /* @__PURE__ */ E.jsx(
          $ie,
          {
            scope: n,
            placedSide: Z,
            onArrowChange: N,
            arrowX: X,
            arrowY: U,
            shouldHideArrow: H,
            children: /* @__PURE__ */ E.jsx(
              Kt.div,
              {
                "data-side": Z,
                "data-align": V,
                ...x,
                ref: _,
                style: {
                  ...x.style,
                  // if the PopperContent hasn't been placed yet (not all measurements done)
                  // we prevent animations so that users's animation don't kick in too early referring wrong sides
                  animation: K ? void 0 : "none"
                }
              }
            )
          }
        )
      }
    );
  }
);
k8.displayName = TR;
var _8 = "PopperArrow", Lie = {
  top: "bottom",
  right: "left",
  bottom: "top",
  left: "right"
}, E8 = M.forwardRef(function(e, t) {
  const { __scopePopper: n, ...r } = e, a = Tie(_8, n), s = Lie[a.placedSide];
  return (
    // we have to use an extra wrapper because `ResizeObserver` (used by `useSize`)
    // doesn't report size as we'd expect on SVG elements.
    // it reports their bounding box which is effectively the largest path inside the SVG.
    /* @__PURE__ */ E.jsx(
      "span",
      {
        ref: a.onArrowChange,
        style: {
          position: "absolute",
          left: a.arrowX,
          top: a.arrowY,
          [s]: 0,
          transformOrigin: {
            top: "",
            right: "0 0",
            bottom: "center 0",
            left: "100% 0"
          }[a.placedSide],
          transform: {
            top: "translateY(100%)",
            right: "translateY(50%) rotate(90deg) translateX(-50%)",
            bottom: "rotate(180deg)",
            left: "translateY(50%) rotate(-90deg) translateX(50%)"
          }[a.placedSide],
          visibility: a.shouldHideArrow ? "hidden" : void 0
        },
        children: /* @__PURE__ */ E.jsx(
          Pie,
          {
            ...r,
            ref: t,
            style: {
              ...r.style,
              // ensures the element can be measured correctly (mostly for if SVG)
              display: "block"
            }
          }
        )
      }
    )
  );
});
E8.displayName = _8;
function Iie(e) {
  return e !== null;
}
var zie = (e) => ({
  name: "transformOrigin",
  options: e,
  fn(t) {
    const { placement: n, rects: r, middlewareData: a } = t, s = a.arrow?.centerOffset !== 0, l = s ? 0 : e.arrowWidth, c = s ? 0 : e.arrowHeight, [d, p] = C8(n), m = { start: "0%", center: "50%", end: "100%" }[p], h = (a.arrow?.x ?? 0) + l / 2, v = (a.arrow?.y ?? 0) + c / 2;
    let y = "", w = "";
    return d === "bottom" ? (y = s ? m : `${h}px`, w = `${-c}px`) : d === "top" ? (y = s ? m : `${h}px`, w = `${r.floating.height + c}px`) : d === "right" ? (y = `${-c}px`, w = s ? m : `${v}px`) : d === "left" && (y = `${r.floating.width + c}px`, w = s ? m : `${v}px`), { data: { x: y, y: w } };
  }
});
function C8(e) {
  const [t, n = "center"] = e.split("-");
  return [t, n];
}
var LR = w8, IR = S8, O8 = k8, M8 = E8, N2 = "Popover", [N8] = jl(N2, [
  M2
]), uS = M2(), [Fie, vd] = N8(N2), R8 = (e) => {
  const {
    __scopePopover: t,
    children: n,
    open: r,
    defaultOpen: a,
    onOpenChange: s,
    modal: l = !1
  } = e, c = uS(t), d = M.useRef(null), [p, m] = M.useState(!1), [h, v] = gd({
    prop: r,
    defaultProp: a ?? !1,
    onChange: s,
    caller: N2
  });
  return /* @__PURE__ */ E.jsx(LR, { ...c, children: /* @__PURE__ */ E.jsx(
    Fie,
    {
      scope: t,
      contentId: _l(),
      triggerRef: d,
      open: h,
      onOpenChange: v,
      onOpenToggle: M.useCallback(() => v((y) => !y), [v]),
      hasCustomAnchor: p,
      onCustomAnchorAdd: M.useCallback(() => m(!0), []),
      onCustomAnchorRemove: M.useCallback(() => m(!1), []),
      modal: l,
      children: n
    }
  ) });
};
R8.displayName = N2;
var A8 = "PopoverAnchor", Bie = M.forwardRef(
  (e, t) => {
    const { __scopePopover: n, ...r } = e, a = vd(A8, n), s = uS(n), { onCustomAnchorAdd: l, onCustomAnchorRemove: c } = a;
    return M.useEffect(() => (l(), () => c()), [l, c]), /* @__PURE__ */ E.jsx(IR, { ...s, ...r, ref: t });
  }
);
Bie.displayName = A8;
var j8 = "PopoverTrigger", P8 = M.forwardRef(
  (e, t) => {
    const { __scopePopover: n, ...r } = e, a = vd(j8, n), s = uS(n), l = Wn(t, a.triggerRef), c = /* @__PURE__ */ E.jsx(
      Kt.button,
      {
        type: "button",
        "aria-haspopup": "dialog",
        "aria-expanded": a.open,
        "aria-controls": a.contentId,
        "data-state": z8(a.open),
        ...r,
        ref: l,
        onClick: Ze(e.onClick, a.onOpenToggle)
      }
    );
    return a.hasCustomAnchor ? c : /* @__PURE__ */ E.jsx(IR, { asChild: !0, ...s, children: c });
  }
);
P8.displayName = j8;
var zR = "PopoverPortal", [Uie, Vie] = N8(zR, {
  forceMount: void 0
}), D8 = (e) => {
  const { __scopePopover: t, forceMount: n, children: r, container: a } = e, s = vd(zR, t);
  return /* @__PURE__ */ E.jsx(Uie, { scope: t, forceMount: n, children: /* @__PURE__ */ E.jsx(Hs, { present: n || s.open, children: /* @__PURE__ */ E.jsx(h2, { asChild: !0, container: a, children: r }) }) });
};
D8.displayName = zR;
var $h = "PopoverContent", $8 = M.forwardRef(
  (e, t) => {
    const n = Vie($h, e.__scopePopover), { forceMount: r = n.forceMount, ...a } = e, s = vd($h, e.__scopePopover);
    return /* @__PURE__ */ E.jsx(Hs, { present: r || s.open, children: s.modal ? /* @__PURE__ */ E.jsx(qie, { ...a, ref: t }) : /* @__PURE__ */ E.jsx(Wie, { ...a, ref: t }) });
  }
);
$8.displayName = $h;
var Hie = /* @__PURE__ */ Ah("PopoverContent.RemoveScroll"), qie = M.forwardRef(
  (e, t) => {
    const n = vd($h, e.__scopePopover), r = M.useRef(null), a = Wn(t, r), s = M.useRef(!1);
    return M.useEffect(() => {
      const l = r.current;
      if (l) return cR(l);
    }, []), /* @__PURE__ */ E.jsx(v2, { as: Hie, allowPinchZoom: !0, children: /* @__PURE__ */ E.jsx(
      T8,
      {
        ...e,
        ref: a,
        trapFocus: n.open,
        disableOutsidePointerEvents: !0,
        onCloseAutoFocus: Ze(e.onCloseAutoFocus, (l) => {
          l.preventDefault(), s.current || n.triggerRef.current?.focus();
        }),
        onPointerDownOutside: Ze(
          e.onPointerDownOutside,
          (l) => {
            const c = l.detail.originalEvent, d = c.button === 0 && c.ctrlKey === !0, p = c.button === 2 || d;
            s.current = p;
          },
          { checkForDefaultPrevented: !1 }
        ),
        onFocusOutside: Ze(
          e.onFocusOutside,
          (l) => l.preventDefault(),
          { checkForDefaultPrevented: !1 }
        )
      }
    ) });
  }
), Wie = M.forwardRef(
  (e, t) => {
    const n = vd($h, e.__scopePopover), r = M.useRef(!1), a = M.useRef(!1);
    return /* @__PURE__ */ E.jsx(
      T8,
      {
        ...e,
        ref: t,
        trapFocus: !1,
        disableOutsidePointerEvents: !1,
        onCloseAutoFocus: (s) => {
          e.onCloseAutoFocus?.(s), s.defaultPrevented || (r.current || n.triggerRef.current?.focus(), s.preventDefault()), r.current = !1, a.current = !1;
        },
        onInteractOutside: (s) => {
          e.onInteractOutside?.(s), s.defaultPrevented || (r.current = !0, s.detail.originalEvent.type === "pointerdown" && (a.current = !0));
          const l = s.target;
          n.triggerRef.current?.contains(l) && s.preventDefault(), s.detail.originalEvent.type === "focusin" && a.current && s.preventDefault();
        }
      }
    );
  }
), T8 = M.forwardRef(
  (e, t) => {
    const {
      __scopePopover: n,
      trapFocus: r,
      onOpenAutoFocus: a,
      onCloseAutoFocus: s,
      disableOutsidePointerEvents: l,
      onEscapeKeyDown: c,
      onPointerDownOutside: d,
      onFocusOutside: p,
      onInteractOutside: m,
      ...h
    } = e, v = vd($h, n), y = uS(n);
    return uR(), /* @__PURE__ */ E.jsx(
      m2,
      {
        asChild: !0,
        loop: !0,
        trapped: r,
        onMountAutoFocus: a,
        onUnmountAutoFocus: s,
        children: /* @__PURE__ */ E.jsx(
          rS,
          {
            asChild: !0,
            disableOutsidePointerEvents: l,
            onInteractOutside: m,
            onEscapeKeyDown: c,
            onPointerDownOutside: d,
            onFocusOutside: p,
            onDismiss: () => v.onOpenChange(!1),
            children: /* @__PURE__ */ E.jsx(
              O8,
              {
                "data-state": z8(v.open),
                role: "dialog",
                id: v.contentId,
                ...y,
                ...h,
                ref: t,
                style: {
                  ...h.style,
                  "--radix-popover-content-transform-origin": "var(--radix-popper-transform-origin)",
                  "--radix-popover-content-available-width": "var(--radix-popper-available-width)",
                  "--radix-popover-content-available-height": "var(--radix-popper-available-height)",
                  "--radix-popover-trigger-width": "var(--radix-popper-anchor-width)",
                  "--radix-popover-trigger-height": "var(--radix-popper-anchor-height)"
                }
              }
            )
          }
        )
      }
    );
  }
), L8 = "PopoverClose", Gie = M.forwardRef(
  (e, t) => {
    const { __scopePopover: n, ...r } = e, a = vd(L8, n);
    return /* @__PURE__ */ E.jsx(
      Kt.button,
      {
        type: "button",
        ...r,
        ref: t,
        onClick: Ze(e.onClick, () => a.onOpenChange(!1))
      }
    );
  }
);
Gie.displayName = L8;
var Kie = "PopoverArrow", I8 = M.forwardRef(
  (e, t) => {
    const { __scopePopover: n, ...r } = e, a = uS(n);
    return /* @__PURE__ */ E.jsx(M8, { ...a, ...r, ref: t });
  }
);
I8.displayName = Kie;
function z8(e) {
  return e ? "open" : "closed";
}
var F8 = R8, B8 = P8, U8 = D8, V8 = $8, Xie = I8;
const bx = {
  aliceblue: [240, 248, 255],
  antiquewhite: [250, 235, 215],
  aqua: [0, 255, 255],
  aquamarine: [127, 255, 212],
  azure: [240, 255, 255],
  beige: [245, 245, 220],
  bisque: [255, 228, 196],
  black: [0, 0, 0],
  blanchedalmond: [255, 235, 205],
  blue: [0, 0, 255],
  blueviolet: [138, 43, 226],
  brown: [165, 42, 42],
  burlywood: [222, 184, 135],
  cadetblue: [95, 158, 160],
  chartreuse: [127, 255, 0],
  chocolate: [210, 105, 30],
  coral: [255, 127, 80],
  cornflowerblue: [100, 149, 237],
  cornsilk: [255, 248, 220],
  crimson: [220, 20, 60],
  cyan: [0, 255, 255],
  darkblue: [0, 0, 139],
  darkcyan: [0, 139, 139],
  darkgoldenrod: [184, 134, 11],
  darkgray: [169, 169, 169],
  darkgreen: [0, 100, 0],
  darkgrey: [169, 169, 169],
  darkkhaki: [189, 183, 107],
  darkmagenta: [139, 0, 139],
  darkolivegreen: [85, 107, 47],
  darkorange: [255, 140, 0],
  darkorchid: [153, 50, 204],
  darkred: [139, 0, 0],
  darksalmon: [233, 150, 122],
  darkseagreen: [143, 188, 143],
  darkslateblue: [72, 61, 139],
  darkslategray: [47, 79, 79],
  darkslategrey: [47, 79, 79],
  darkturquoise: [0, 206, 209],
  darkviolet: [148, 0, 211],
  deeppink: [255, 20, 147],
  deepskyblue: [0, 191, 255],
  dimgray: [105, 105, 105],
  dimgrey: [105, 105, 105],
  dodgerblue: [30, 144, 255],
  firebrick: [178, 34, 34],
  floralwhite: [255, 250, 240],
  forestgreen: [34, 139, 34],
  fuchsia: [255, 0, 255],
  gainsboro: [220, 220, 220],
  ghostwhite: [248, 248, 255],
  gold: [255, 215, 0],
  goldenrod: [218, 165, 32],
  gray: [128, 128, 128],
  green: [0, 128, 0],
  greenyellow: [173, 255, 47],
  grey: [128, 128, 128],
  honeydew: [240, 255, 240],
  hotpink: [255, 105, 180],
  indianred: [205, 92, 92],
  indigo: [75, 0, 130],
  ivory: [255, 255, 240],
  khaki: [240, 230, 140],
  lavender: [230, 230, 250],
  lavenderblush: [255, 240, 245],
  lawngreen: [124, 252, 0],
  lemonchiffon: [255, 250, 205],
  lightblue: [173, 216, 230],
  lightcoral: [240, 128, 128],
  lightcyan: [224, 255, 255],
  lightgoldenrodyellow: [250, 250, 210],
  lightgray: [211, 211, 211],
  lightgreen: [144, 238, 144],
  lightgrey: [211, 211, 211],
  lightpink: [255, 182, 193],
  lightsalmon: [255, 160, 122],
  lightseagreen: [32, 178, 170],
  lightskyblue: [135, 206, 250],
  lightslategray: [119, 136, 153],
  lightslategrey: [119, 136, 153],
  lightsteelblue: [176, 196, 222],
  lightyellow: [255, 255, 224],
  lime: [0, 255, 0],
  limegreen: [50, 205, 50],
  linen: [250, 240, 230],
  magenta: [255, 0, 255],
  maroon: [128, 0, 0],
  mediumaquamarine: [102, 205, 170],
  mediumblue: [0, 0, 205],
  mediumorchid: [186, 85, 211],
  mediumpurple: [147, 112, 219],
  mediumseagreen: [60, 179, 113],
  mediumslateblue: [123, 104, 238],
  mediumspringgreen: [0, 250, 154],
  mediumturquoise: [72, 209, 204],
  mediumvioletred: [199, 21, 133],
  midnightblue: [25, 25, 112],
  mintcream: [245, 255, 250],
  mistyrose: [255, 228, 225],
  moccasin: [255, 228, 181],
  navajowhite: [255, 222, 173],
  navy: [0, 0, 128],
  oldlace: [253, 245, 230],
  olive: [128, 128, 0],
  olivedrab: [107, 142, 35],
  orange: [255, 165, 0],
  orangered: [255, 69, 0],
  orchid: [218, 112, 214],
  palegoldenrod: [238, 232, 170],
  palegreen: [152, 251, 152],
  paleturquoise: [175, 238, 238],
  palevioletred: [219, 112, 147],
  papayawhip: [255, 239, 213],
  peachpuff: [255, 218, 185],
  peru: [205, 133, 63],
  pink: [255, 192, 203],
  plum: [221, 160, 221],
  powderblue: [176, 224, 230],
  purple: [128, 0, 128],
  rebeccapurple: [102, 51, 153],
  red: [255, 0, 0],
  rosybrown: [188, 143, 143],
  royalblue: [65, 105, 225],
  saddlebrown: [139, 69, 19],
  salmon: [250, 128, 114],
  sandybrown: [244, 164, 96],
  seagreen: [46, 139, 87],
  seashell: [255, 245, 238],
  sienna: [160, 82, 45],
  silver: [192, 192, 192],
  skyblue: [135, 206, 235],
  slateblue: [106, 90, 205],
  slategray: [112, 128, 144],
  slategrey: [112, 128, 144],
  snow: [255, 250, 250],
  springgreen: [0, 255, 127],
  steelblue: [70, 130, 180],
  tan: [210, 180, 140],
  teal: [0, 128, 128],
  thistle: [216, 191, 216],
  tomato: [255, 99, 71],
  turquoise: [64, 224, 208],
  violet: [238, 130, 238],
  wheat: [245, 222, 179],
  white: [255, 255, 255],
  whitesmoke: [245, 245, 245],
  yellow: [255, 255, 0],
  yellowgreen: [154, 205, 50]
}, H8 = {};
for (const e of Object.keys(bx))
  H8[bx[e]] = e;
const Ue = {
  rgb: { channels: 3, labels: "rgb" },
  hsl: { channels: 3, labels: "hsl" },
  hsv: { channels: 3, labels: "hsv" },
  hwb: { channels: 3, labels: "hwb" },
  cmyk: { channels: 4, labels: "cmyk" },
  xyz: { channels: 3, labels: "xyz" },
  lab: { channels: 3, labels: "lab" },
  oklab: { channels: 3, labels: ["okl", "oka", "okb"] },
  lch: { channels: 3, labels: "lch" },
  oklch: { channels: 3, labels: ["okl", "okc", "okh"] },
  hex: { channels: 1, labels: ["hex"] },
  keyword: { channels: 1, labels: ["keyword"] },
  ansi16: { channels: 1, labels: ["ansi16"] },
  ansi256: { channels: 1, labels: ["ansi256"] },
  hcg: { channels: 3, labels: ["h", "c", "g"] },
  apple: { channels: 3, labels: ["r16", "g16", "b16"] },
  gray: { channels: 1, labels: ["gray"] }
}, pc = (6 / 29) ** 3;
function kh(e) {
  const t = e > 31308e-7 ? 1.055 * e ** 0.4166666666666667 - 0.055 : e * 12.92;
  return Math.min(Math.max(0, t), 1);
}
function _h(e) {
  return e > 0.04045 ? ((e + 0.055) / 1.055) ** 2.4 : e / 12.92;
}
for (const e of Object.keys(Ue)) {
  if (!("channels" in Ue[e]))
    throw new Error("missing channels property: " + e);
  if (!("labels" in Ue[e]))
    throw new Error("missing channel labels property: " + e);
  if (Ue[e].labels.length !== Ue[e].channels)
    throw new Error("channel and label counts mismatch: " + e);
  const { channels: t, labels: n } = Ue[e];
  delete Ue[e].channels, delete Ue[e].labels, Object.defineProperty(Ue[e], "channels", { value: t }), Object.defineProperty(Ue[e], "labels", { value: n });
}
Ue.rgb.hsl = function(e) {
  const t = e[0] / 255, n = e[1] / 255, r = e[2] / 255, a = Math.min(t, n, r), s = Math.max(t, n, r), l = s - a;
  let c, d;
  switch (s) {
    case a: {
      c = 0;
      break;
    }
    case t: {
      c = (n - r) / l;
      break;
    }
    case n: {
      c = 2 + (r - t) / l;
      break;
    }
    case r: {
      c = 4 + (t - n) / l;
      break;
    }
  }
  c = Math.min(c * 60, 360), c < 0 && (c += 360);
  const p = (a + s) / 2;
  return s === a ? d = 0 : p <= 0.5 ? d = l / (s + a) : d = l / (2 - s - a), [c, d * 100, p * 100];
};
Ue.rgb.hsv = function(e) {
  let t, n, r, a, s;
  const l = e[0] / 255, c = e[1] / 255, d = e[2] / 255, p = Math.max(l, c, d), m = p - Math.min(l, c, d), h = function(v) {
    return (p - v) / 6 / m + 1 / 2;
  };
  if (m === 0)
    a = 0, s = 0;
  else {
    switch (s = m / p, t = h(l), n = h(c), r = h(d), p) {
      case l: {
        a = r - n;
        break;
      }
      case c: {
        a = 1 / 3 + t - r;
        break;
      }
      case d: {
        a = 2 / 3 + n - t;
        break;
      }
    }
    a < 0 ? a += 1 : a > 1 && (a -= 1);
  }
  return [
    a * 360,
    s * 100,
    p * 100
  ];
};
Ue.rgb.hwb = function(e) {
  const t = e[0], n = e[1];
  let r = e[2];
  const a = Ue.rgb.hsl(e)[0], s = 1 / 255 * Math.min(t, Math.min(n, r));
  return r = 1 - 1 / 255 * Math.max(t, Math.max(n, r)), [a, s * 100, r * 100];
};
Ue.rgb.oklab = function(e) {
  const t = _h(e[0] / 255), n = _h(e[1] / 255), r = _h(e[2] / 255), a = Math.cbrt(0.4122214708 * t + 0.5363325363 * n + 0.0514459929 * r), s = Math.cbrt(0.2119034982 * t + 0.6806995451 * n + 0.1073969566 * r), l = Math.cbrt(0.0883024619 * t + 0.2817188376 * n + 0.6299787005 * r), c = 0.2104542553 * a + 0.793617785 * s - 0.0040720468 * l, d = 1.9779984951 * a - 2.428592205 * s + 0.4505937099 * l, p = 0.0259040371 * a + 0.7827717662 * s - 0.808675766 * l;
  return [c * 100, d * 100, p * 100];
};
Ue.rgb.cmyk = function(e) {
  const t = e[0] / 255, n = e[1] / 255, r = e[2] / 255, a = Math.min(1 - t, 1 - n, 1 - r), s = (1 - t - a) / (1 - a) || 0, l = (1 - n - a) / (1 - a) || 0, c = (1 - r - a) / (1 - a) || 0;
  return [s * 100, l * 100, c * 100, a * 100];
};
function Yie(e, t) {
  return (e[0] - t[0]) ** 2 + (e[1] - t[1]) ** 2 + (e[2] - t[2]) ** 2;
}
Ue.rgb.keyword = function(e) {
  const t = H8[e];
  if (t)
    return t;
  let n = Number.POSITIVE_INFINITY, r;
  for (const a of Object.keys(bx)) {
    const s = bx[a], l = Yie(e, s);
    l < n && (n = l, r = a);
  }
  return r;
};
Ue.keyword.rgb = function(e) {
  return [...bx[e]];
};
Ue.rgb.xyz = function(e) {
  const t = _h(e[0] / 255), n = _h(e[1] / 255), r = _h(e[2] / 255), a = t * 0.4124564 + n * 0.3575761 + r * 0.1804375, s = t * 0.2126729 + n * 0.7151522 + r * 0.072175, l = t * 0.0193339 + n * 0.119192 + r * 0.9503041;
  return [a * 100, s * 100, l * 100];
};
Ue.rgb.lab = function(e) {
  const t = Ue.rgb.xyz(e);
  let n = t[0], r = t[1], a = t[2];
  n /= 95.047, r /= 100, a /= 108.883, n = n > pc ? n ** (1 / 3) : 7.787 * n + 16 / 116, r = r > pc ? r ** (1 / 3) : 7.787 * r + 16 / 116, a = a > pc ? a ** (1 / 3) : 7.787 * a + 16 / 116;
  const s = 116 * r - 16, l = 500 * (n - r), c = 200 * (r - a);
  return [s, l, c];
};
Ue.hsl.rgb = function(e) {
  const t = e[0] / 360, n = e[1] / 100, r = e[2] / 100;
  let a, s;
  if (n === 0)
    return s = r * 255, [s, s, s];
  const l = r < 0.5 ? r * (1 + n) : r + n - r * n, c = 2 * r - l, d = [0, 0, 0];
  for (let p = 0; p < 3; p++)
    a = t + 1 / 3 * -(p - 1), a < 0 && a++, a > 1 && a--, 6 * a < 1 ? s = c + (l - c) * 6 * a : 2 * a < 1 ? s = l : 3 * a < 2 ? s = c + (l - c) * (2 / 3 - a) * 6 : s = c, d[p] = s * 255;
  return d;
};
Ue.hsl.hsv = function(e) {
  const t = e[0];
  let n = e[1] / 100, r = e[2] / 100, a = n;
  const s = Math.max(r, 0.01);
  r *= 2, n *= r <= 1 ? r : 2 - r, a *= s <= 1 ? s : 2 - s;
  const l = (r + n) / 2, c = r === 0 ? 2 * a / (s + a) : 2 * n / (r + n);
  return [t, c * 100, l * 100];
};
Ue.hsv.rgb = function(e) {
  const t = e[0] / 60, n = e[1] / 100;
  let r = e[2] / 100;
  const a = Math.floor(t) % 6, s = t - Math.floor(t), l = 255 * r * (1 - n), c = 255 * r * (1 - n * s), d = 255 * r * (1 - n * (1 - s));
  switch (r *= 255, a) {
    case 0:
      return [r, d, l];
    case 1:
      return [c, r, l];
    case 2:
      return [l, r, d];
    case 3:
      return [l, c, r];
    case 4:
      return [d, l, r];
    case 5:
      return [r, l, c];
  }
};
Ue.hsv.hsl = function(e) {
  const t = e[0], n = e[1] / 100, r = e[2] / 100, a = Math.max(r, 0.01);
  let s, l;
  l = (2 - n) * r;
  const c = (2 - n) * a;
  return s = n * a, s /= c <= 1 ? c : 2 - c, s = s || 0, l /= 2, [t, s * 100, l * 100];
};
Ue.hwb.rgb = function(e) {
  const t = e[0] / 360;
  let n = e[1] / 100, r = e[2] / 100;
  const a = n + r;
  let s;
  a > 1 && (n /= a, r /= a);
  const l = Math.floor(6 * t), c = 1 - r;
  s = 6 * t - l, (l & 1) !== 0 && (s = 1 - s);
  const d = n + s * (c - n);
  let p, m, h;
  switch (l) {
    default:
    case 6:
    case 0: {
      p = c, m = d, h = n;
      break;
    }
    case 1: {
      p = d, m = c, h = n;
      break;
    }
    case 2: {
      p = n, m = c, h = d;
      break;
    }
    case 3: {
      p = n, m = d, h = c;
      break;
    }
    case 4: {
      p = d, m = n, h = c;
      break;
    }
    case 5: {
      p = c, m = n, h = d;
      break;
    }
  }
  return [p * 255, m * 255, h * 255];
};
Ue.cmyk.rgb = function(e) {
  const t = e[0] / 100, n = e[1] / 100, r = e[2] / 100, a = e[3] / 100, s = 1 - Math.min(1, t * (1 - a) + a), l = 1 - Math.min(1, n * (1 - a) + a), c = 1 - Math.min(1, r * (1 - a) + a);
  return [s * 255, l * 255, c * 255];
};
Ue.xyz.rgb = function(e) {
  const t = e[0] / 100, n = e[1] / 100, r = e[2] / 100;
  let a, s, l;
  return a = t * 3.2404542 + n * -1.5371385 + r * -0.4985314, s = t * -0.969266 + n * 1.8760108 + r * 0.041556, l = t * 0.0556434 + n * -0.2040259 + r * 1.0572252, a = kh(a), s = kh(s), l = kh(l), [a * 255, s * 255, l * 255];
};
Ue.xyz.lab = function(e) {
  let t = e[0], n = e[1], r = e[2];
  t /= 95.047, n /= 100, r /= 108.883, t = t > pc ? t ** (1 / 3) : 7.787 * t + 16 / 116, n = n > pc ? n ** (1 / 3) : 7.787 * n + 16 / 116, r = r > pc ? r ** (1 / 3) : 7.787 * r + 16 / 116;
  const a = 116 * n - 16, s = 500 * (t - n), l = 200 * (n - r);
  return [a, s, l];
};
Ue.xyz.oklab = function(e) {
  const t = e[0] / 100, n = e[1] / 100, r = e[2] / 100, a = Math.cbrt(0.8189330101 * t + 0.3618667424 * n - 0.1288597137 * r), s = Math.cbrt(0.0329845436 * t + 0.9293118715 * n + 0.0361456387 * r), l = Math.cbrt(0.0482003018 * t + 0.2643662691 * n + 0.633851707 * r), c = 0.2104542553 * a + 0.793617785 * s - 0.0040720468 * l, d = 1.9779984951 * a - 2.428592205 * s + 0.4505937099 * l, p = 0.0259040371 * a + 0.7827717662 * s - 0.808675766 * l;
  return [c * 100, d * 100, p * 100];
};
Ue.oklab.oklch = function(e) {
  return Ue.lab.lch(e);
};
Ue.oklab.xyz = function(e) {
  const t = e[0] / 100, n = e[1] / 100, r = e[2] / 100, a = (0.999999998 * t + 0.396337792 * n + 0.215803758 * r) ** 3, s = (1.000000008 * t - 0.105561342 * n - 0.063854175 * r) ** 3, l = (1.000000055 * t - 0.089484182 * n - 1.291485538 * r) ** 3, c = 1.227013851 * a - 0.55779998 * s + 0.281256149 * l, d = -0.040580178 * a + 1.11225687 * s - 0.071676679 * l, p = -0.076381285 * a - 0.421481978 * s + 1.58616322 * l;
  return [c * 100, d * 100, p * 100];
};
Ue.oklab.rgb = function(e) {
  const t = e[0] / 100, n = e[1] / 100, r = e[2] / 100, a = (t + 0.3963377774 * n + 0.2158037573 * r) ** 3, s = (t - 0.1055613458 * n - 0.0638541728 * r) ** 3, l = (t - 0.0894841775 * n - 1.291485548 * r) ** 3, c = kh(4.0767416621 * a - 3.3077115913 * s + 0.2309699292 * l), d = kh(-1.2684380046 * a + 2.6097574011 * s - 0.3413193965 * l), p = kh(-0.0041960863 * a - 0.7034186147 * s + 1.707614701 * l);
  return [c * 255, d * 255, p * 255];
};
Ue.oklch.oklab = function(e) {
  return Ue.lch.lab(e);
};
Ue.lab.xyz = function(e) {
  const t = e[0], n = e[1], r = e[2];
  let a, s, l;
  s = (t + 16) / 116, a = n / 500 + s, l = s - r / 200;
  const c = s ** 3, d = a ** 3, p = l ** 3;
  return s = c > pc ? c : (s - 16 / 116) / 7.787, a = d > pc ? d : (a - 16 / 116) / 7.787, l = p > pc ? p : (l - 16 / 116) / 7.787, a *= 95.047, s *= 100, l *= 108.883, [a, s, l];
};
Ue.lab.lch = function(e) {
  const t = e[0], n = e[1], r = e[2];
  let a;
  a = Math.atan2(r, n) * 360 / 2 / Math.PI, a < 0 && (a += 360);
  const s = Math.sqrt(n * n + r * r);
  return [t, s, a];
};
Ue.lch.lab = function(e) {
  const t = e[0], n = e[1], r = e[2] / 360 * 2 * Math.PI, a = n * Math.cos(r), s = n * Math.sin(r);
  return [t, a, s];
};
Ue.rgb.ansi16 = function(e, t = null) {
  const [n, r, a] = e;
  let s = t === null ? Ue.rgb.hsv(e)[2] : t;
  if (s = Math.round(s / 50), s === 0)
    return 30;
  let l = 30 + (Math.round(a / 255) << 2 | Math.round(r / 255) << 1 | Math.round(n / 255));
  return s === 2 && (l += 60), l;
};
Ue.hsv.ansi16 = function(e) {
  return Ue.rgb.ansi16(Ue.hsv.rgb(e), e[2]);
};
Ue.rgb.ansi256 = function(e) {
  const t = e[0], n = e[1], r = e[2];
  return t >> 4 === n >> 4 && n >> 4 === r >> 4 ? t < 8 ? 16 : t > 248 ? 231 : Math.round((t - 8) / 247 * 24) + 232 : 16 + 36 * Math.round(t / 255 * 5) + 6 * Math.round(n / 255 * 5) + Math.round(r / 255 * 5);
};
Ue.ansi16.rgb = function(e) {
  e = e[0];
  let t = e % 10;
  if (t === 0 || t === 7)
    return e > 50 && (t += 3.5), t = t / 10.5 * 255, [t, t, t];
  const n = (Math.trunc(e > 50) + 1) * 0.5, r = (t & 1) * n * 255, a = (t >> 1 & 1) * n * 255, s = (t >> 2 & 1) * n * 255;
  return [r, a, s];
};
Ue.ansi256.rgb = function(e) {
  if (e = e[0], e >= 232) {
    const s = (e - 232) * 10 + 8;
    return [s, s, s];
  }
  e -= 16;
  let t;
  const n = Math.floor(e / 36) / 5 * 255, r = Math.floor((t = e % 36) / 6) / 5 * 255, a = t % 6 / 5 * 255;
  return [n, r, a];
};
Ue.rgb.hex = function(e) {
  const t = (((Math.round(e[0]) & 255) << 16) + ((Math.round(e[1]) & 255) << 8) + (Math.round(e[2]) & 255)).toString(16).toUpperCase();
  return "000000".slice(t.length) + t;
};
Ue.hex.rgb = function(e) {
  const t = e.toString(16).match(/[a-f\d]{6}|[a-f\d]{3}/i);
  if (!t)
    return [0, 0, 0];
  let n = t[0];
  t[0].length === 3 && (n = [...n].map((c) => c + c).join(""));
  const r = Number.parseInt(n, 16), a = r >> 16 & 255, s = r >> 8 & 255, l = r & 255;
  return [a, s, l];
};
Ue.rgb.hcg = function(e) {
  const t = e[0] / 255, n = e[1] / 255, r = e[2] / 255, a = Math.max(Math.max(t, n), r), s = Math.min(Math.min(t, n), r), l = a - s;
  let c;
  const d = l < 1 ? s / (1 - l) : 0;
  return l <= 0 ? c = 0 : a === t ? c = (n - r) / l % 6 : a === n ? c = 2 + (r - t) / l : c = 4 + (t - n) / l, c /= 6, c %= 1, [c * 360, l * 100, d * 100];
};
Ue.hsl.hcg = function(e) {
  const t = e[1] / 100, n = e[2] / 100, r = n < 0.5 ? 2 * t * n : 2 * t * (1 - n);
  let a = 0;
  return r < 1 && (a = (n - 0.5 * r) / (1 - r)), [e[0], r * 100, a * 100];
};
Ue.hsv.hcg = function(e) {
  const t = e[1] / 100, n = e[2] / 100, r = t * n;
  let a = 0;
  return r < 1 && (a = (n - r) / (1 - r)), [e[0], r * 100, a * 100];
};
Ue.hcg.rgb = function(e) {
  const t = e[0] / 360, n = e[1] / 100, r = e[2] / 100;
  if (n === 0)
    return [r * 255, r * 255, r * 255];
  const a = [0, 0, 0], s = t % 1 * 6, l = s % 1, c = 1 - l;
  let d = 0;
  switch (Math.floor(s)) {
    case 0: {
      a[0] = 1, a[1] = l, a[2] = 0;
      break;
    }
    case 1: {
      a[0] = c, a[1] = 1, a[2] = 0;
      break;
    }
    case 2: {
      a[0] = 0, a[1] = 1, a[2] = l;
      break;
    }
    case 3: {
      a[0] = 0, a[1] = c, a[2] = 1;
      break;
    }
    case 4: {
      a[0] = l, a[1] = 0, a[2] = 1;
      break;
    }
    default:
      a[0] = 1, a[1] = 0, a[2] = c;
  }
  return d = (1 - n) * r, [
    (n * a[0] + d) * 255,
    (n * a[1] + d) * 255,
    (n * a[2] + d) * 255
  ];
};
Ue.hcg.hsv = function(e) {
  const t = e[1] / 100, n = e[2] / 100, r = t + n * (1 - t);
  let a = 0;
  return r > 0 && (a = t / r), [e[0], a * 100, r * 100];
};
Ue.hcg.hsl = function(e) {
  const t = e[1] / 100, n = e[2] / 100 * (1 - t) + 0.5 * t;
  let r = 0;
  return n > 0 && n < 0.5 ? r = t / (2 * n) : n >= 0.5 && n < 1 && (r = t / (2 * (1 - n))), [e[0], r * 100, n * 100];
};
Ue.hcg.hwb = function(e) {
  const t = e[1] / 100, n = e[2] / 100, r = t + n * (1 - t);
  return [e[0], (r - t) * 100, (1 - r) * 100];
};
Ue.hwb.hcg = function(e) {
  const t = e[1] / 100, n = 1 - e[2] / 100, r = n - t;
  let a = 0;
  return r < 1 && (a = (n - r) / (1 - r)), [e[0], r * 100, a * 100];
};
Ue.apple.rgb = function(e) {
  return [e[0] / 65535 * 255, e[1] / 65535 * 255, e[2] / 65535 * 255];
};
Ue.rgb.apple = function(e) {
  return [e[0] / 255 * 65535, e[1] / 255 * 65535, e[2] / 255 * 65535];
};
Ue.gray.rgb = function(e) {
  return [e[0] / 100 * 255, e[0] / 100 * 255, e[0] / 100 * 255];
};
Ue.gray.hsl = function(e) {
  return [0, 0, e[0]];
};
Ue.gray.hsv = Ue.gray.hsl;
Ue.gray.hwb = function(e) {
  return [0, 100, e[0]];
};
Ue.gray.cmyk = function(e) {
  return [0, 0, 0, e[0]];
};
Ue.gray.lab = function(e) {
  return [e[0], 0, 0];
};
Ue.gray.hex = function(e) {
  const t = Math.round(e[0] / 100 * 255) & 255, n = ((t << 16) + (t << 8) + t).toString(16).toUpperCase();
  return "000000".slice(n.length) + n;
};
Ue.rgb.gray = function(e) {
  return [(e[0] + e[1] + e[2]) / 3 / 255 * 100];
};
function Qie() {
  const e = {}, t = Object.keys(Ue);
  for (let { length: n } = t, r = 0; r < n; r++)
    e[t[r]] = {
      // http://jsperf.com/1-vs-infinity
      // micro-opt, but this is simple.
      distance: -1,
      parent: null
    };
  return e;
}
function Jie(e) {
  const t = Qie(), n = [e];
  for (t[e].distance = 0; n.length > 0; ) {
    const r = n.pop(), a = Object.keys(Ue[r]);
    for (let { length: s } = a, l = 0; l < s; l++) {
      const c = a[l], d = t[c];
      d.distance === -1 && (d.distance = t[r].distance + 1, d.parent = r, n.unshift(c));
    }
  }
  return t;
}
function Zie(e, t) {
  return function(n) {
    return t(e(n));
  };
}
function ese(e, t) {
  const n = [t[e].parent, e];
  let r = Ue[t[e].parent][e], a = t[e].parent;
  for (; t[a].parent; )
    n.unshift(t[a].parent), r = Zie(Ue[t[a].parent][a], r), a = t[a].parent;
  return r.conversion = n, r;
}
function tse(e) {
  const t = Jie(e), n = {}, r = Object.keys(t);
  for (let { length: a } = r, s = 0; s < a; s++) {
    const l = r[s];
    t[l].parent !== null && (n[l] = ese(l, t));
  }
  return n;
}
const Qp = {}, nse = Object.keys(Ue);
function rse(e) {
  const t = function(...n) {
    const r = n[0];
    return r == null ? r : (r.length > 1 && (n = r), e(n));
  };
  return "conversion" in e && (t.conversion = e.conversion), t;
}
function ose(e) {
  const t = function(...n) {
    const r = n[0];
    if (r == null)
      return r;
    r.length > 1 && (n = r);
    const a = e(n);
    if (typeof a == "object")
      for (let { length: s } = a, l = 0; l < s; l++)
        a[l] = Math.round(a[l]);
    return a;
  };
  return "conversion" in e && (t.conversion = e.conversion), t;
}
for (const e of nse) {
  Qp[e] = {}, Object.defineProperty(Qp[e], "channels", { value: Ue[e].channels }), Object.defineProperty(Qp[e], "labels", { value: Ue[e].labels });
  const t = tse(e), n = Object.keys(t);
  for (const r of n) {
    const a = t[r];
    Qp[e][r] = ose(a), Qp[e][r].raw = rse(a);
  }
}
const ase = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: Qp
}, Symbol.toStringTag, { value: "Module" })), Vo = (e, t) => {
  const n = Array.isArray(t) ? t : [t];
  if (n[0] === void 0 || n[0] === null)
    return Vo("rgb", [0, 0, 0]);
  const r = Qp[e];
  if (!r)
    throw new Error(
      `Unsupported color type: ${e} allowed are ${Object.keys(ase).join(
        ", "
      )}`
    );
  r[e] = () => n;
  const a = (l) => {
    const c = l(...n);
    return Array.isArray(c) ? c[0] != null : c;
  };
  if (!a(r.rgb) || !a(r.hsl))
    return Vo("rgb", [0, 0, 0]);
  const s = {};
  return Object.keys(r).forEach((l) => {
    const c = r[l];
    typeof c == "function" && (s[l] = () => l === e ? n : c(...n));
  }), s;
}, ise = ({
  onChange: e,
  colorconverter: t,
  allow_null: n = !1
}) => {
  if (t === null && !n)
    throw new Error("Color converter is null");
  const [r, a] = M.useState(t), [s, l] = M.useState([0, 0, 0]), [c, d] = M.useState([0, 0, 0]), [p, m] = M.useState([0, 0, 0]), [h, v] = M.useState("000");
  M.useEffect(() => {
    if (!r) {
      if (!n) throw new Error("Color converter is null");
      d([0, 0, 0]), l([0, 0, 0]), m([0, 0, 0]), v("");
      return;
    }
    l(r.hsl()), d(r.rgb()), m(r.hsv()), v(r.hex());
  }, [r]);
  const y = {
    backgroundColor: `hsl(${s[0]}, ${s[1]}%, ${s[2]}%)`,
    padding: "10px",
    margin: "10px 0"
  };
  return /* @__PURE__ */ E.jsxs("div", { style: { backgroundColor: "white" }, children: [
    /* @__PURE__ */ E.jsx("div", { style: y, children: "Color Preview" }),
    /* @__PURE__ */ E.jsxs("div", { className: "colorspace", children: [
      /* @__PURE__ */ E.jsx("div", { className: "colorspace_title", children: "RGB" }),
      /* @__PURE__ */ E.jsx("div", {}),
      /* @__PURE__ */ E.jsx("label", { children: "Red" }),
      /* @__PURE__ */ E.jsx(
        "input",
        {
          type: "range",
          min: "0",
          max: "255",
          value: c[0],
          onChange: (w) => {
            const x = [parseInt(w.target.value), c[1], c[2]], b = Vo("rgb", x);
            a(b), e(b);
          },
          style: { background: "linear-gradient(to right, #000, #f00)" }
        }
      ),
      /* @__PURE__ */ E.jsx("label", { children: "Green" }),
      /* @__PURE__ */ E.jsx(
        "input",
        {
          type: "range",
          min: "0",
          max: "255",
          value: c[1],
          onChange: (w) => {
            const x = [c[0], parseInt(w.target.value), c[2]], b = Vo("rgb", x);
            a(b), e(b);
          },
          style: { background: "linear-gradient(to right, #000, #0f0)" }
        }
      ),
      /* @__PURE__ */ E.jsx("label", { children: "Blue" }),
      /* @__PURE__ */ E.jsx(
        "input",
        {
          type: "range",
          min: "0",
          max: "255",
          value: c[2],
          onChange: (w) => {
            const x = [c[0], c[1], parseInt(w.target.value)], b = Vo("rgb", x);
            a(b), e(b);
          },
          style: { background: "linear-gradient(to right, #000, #00f)" }
        }
      )
    ] }),
    /* @__PURE__ */ E.jsxs("div", { className: "colorspace", children: [
      /* @__PURE__ */ E.jsx("div", { className: "colorspace_title", children: "HSL" }),
      /* @__PURE__ */ E.jsx("div", {}),
      /* @__PURE__ */ E.jsx("label", { children: "Hue" }),
      /* @__PURE__ */ E.jsx(
        "input",
        {
          type: "range",
          min: "0",
          max: "360",
          value: s[0],
          onChange: (w) => {
            const x = [parseInt(w.target.value), s[1], s[2]], b = Vo("hsl", x);
            a(b), e(b);
          },
          style: {
            background: "linear-gradient(to right, #f00, #ff0, #0f0, #0ff, #00f, #f0f, #f00)"
          }
        }
      ),
      /* @__PURE__ */ E.jsx("label", { children: "Saturation" }),
      /* @__PURE__ */ E.jsx(
        "input",
        {
          type: "range",
          min: "0",
          max: "100",
          value: s[1],
          onChange: (w) => {
            const x = [s[0], parseInt(w.target.value), s[2]], b = Vo("hsl", x);
            a(b), e(b);
          },
          style: {
            background: `linear-gradient(to right, #fff, hsl(${s[0]}, 100%, 50%))`
          }
        }
      ),
      /* @__PURE__ */ E.jsx("label", { children: "Lightness" }),
      /* @__PURE__ */ E.jsx(
        "input",
        {
          type: "range",
          min: "0",
          max: "100",
          value: s[2],
          onChange: (w) => {
            const x = [s[0], s[1], parseInt(w.target.value)], b = Vo("hsl", x);
            a(b), e(b);
          },
          style: {
            background: `linear-gradient(to right, #000, hsl(${s[0]}, 100%, 50%), #fff)`
          }
        }
      )
    ] }),
    /* @__PURE__ */ E.jsxs("div", { className: "colorspace", children: [
      /* @__PURE__ */ E.jsx("div", { className: "colorspace_title", children: "HSV" }),
      /* @__PURE__ */ E.jsx("div", {}),
      /* @__PURE__ */ E.jsx("label", { children: "Hue" }),
      /* @__PURE__ */ E.jsx(
        "input",
        {
          type: "range",
          min: "0",
          max: "360",
          value: p[0],
          onChange: (w) => {
            const x = [parseInt(w.target.value), p[1], p[2]], b = Vo("hsv", x);
            a(b), e(b);
          },
          style: {
            background: "linear-gradient(to right, #f00, #ff0, #0f0, #0ff, #00f, #f0f, #f00)"
          }
        }
      ),
      /* @__PURE__ */ E.jsx("label", { children: "Saturation" }),
      /* @__PURE__ */ E.jsx(
        "input",
        {
          type: "range",
          min: "0",
          max: "100",
          value: p[1],
          onChange: (w) => {
            const x = [p[0], parseInt(w.target.value), p[2]], b = Vo("hsv", x);
            a(b), e(b);
          },
          style: {
            background: `linear-gradient(to right, #fff, hsl(${s[0]}, 100%, 50%))`
          }
        }
      ),
      /* @__PURE__ */ E.jsx("label", { children: "Value" }),
      /* @__PURE__ */ E.jsx(
        "input",
        {
          type: "range",
          min: "0",
          max: "100",
          value: p[2],
          onChange: (w) => {
            const x = [p[0], p[1], parseInt(w.target.value)], b = Vo("hsv", x);
            a(b), e(b);
          },
          style: {
            background: `linear-gradient(to right, #000, hsl(${s[0]}, 100%, 50%))`
          }
        }
      )
    ] }),
    /* @__PURE__ */ E.jsxs("div", { className: "colorspace", children: [
      /* @__PURE__ */ E.jsx("div", { className: "colorspace_title", children: "HEX" }),
      /* @__PURE__ */ E.jsx("div", {}),
      /* @__PURE__ */ E.jsx(
        "input",
        {
          type: "text",
          value: h,
          onChange: (w) => {
            const x = w.target.value === "" ? null : Vo("hex", [w.target.value]);
            a(x), e(x);
          }
        }
      )
    ] })
  ] });
}, sse = ({
  inicolordata: e,
  inicolorspace: t,
  allow_null: n = !1,
  delay: r = 1e3,
  onChange: a,
  portalContainer: s
}) => {
  const l = e !== void 0 ? e : [0, 0, 0], c = e === void 0 ? "rgb" : t || "hex", d = Array.isArray(l) ? l : [l], p = M.useMemo(() => {
    let x = Vo(c, d);
    return x.rgb() === void 0 && (x = Vo("rgb", [0, 0, 0])), x;
  }, [c, d]), [m, h] = M.useState(p);
  M.useEffect(() => {
    const x = e !== void 0 ? e : [0, 0, 0], b = e === void 0 ? "rgb" : t || "hex", k = Array.isArray(x) ? x : [x];
    let C = Vo(b, k);
    C.rgb() === void 0 && (C = Vo("rgb", [0, 0, 0])), h(C);
  }, [JSON.stringify(e), t]);
  const v = M.useRef(null), y = M.useCallback(
    (x) => {
      if (x === null && !n)
        throw new Error("Color is null");
      x !== null && h(x), v.current && clearTimeout(v.current), a && (v.current = setTimeout(() => {
        a(x), v.current = null;
      }, r));
    },
    [n, a, r]
  );
  M.useEffect(() => () => {
    v.current && clearTimeout(v.current);
  }, []);
  const w = M.useMemo(
    () => ({
      background: "#" + m.hex(),
      borderRadius: "0.3rem",
      width: "2rem",
      height: "1rem"
    }),
    [m]
  );
  return /* @__PURE__ */ E.jsxs(F8, { children: [
    /* @__PURE__ */ E.jsx(B8, { asChild: !0, children: /* @__PURE__ */ E.jsx("button", { style: w }) }),
    /* @__PURE__ */ E.jsx(U8, { container: s, children: /* @__PURE__ */ E.jsx(V8, { side: "left", className: "iotooltipcontent", children: /* @__PURE__ */ E.jsx(
      ise,
      {
        onChange: y,
        colorconverter: m,
        allow_null: n
      }
    ) }) })
  ] });
};
function cm(e) {
  "@babel/helpers - typeof";
  return cm = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, cm(e);
}
function lse(e, t) {
  if (cm(e) != "object" || !e) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t);
    if (cm(r) != "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function q8(e) {
  var t = lse(e, "string");
  return cm(t) == "symbol" ? t : t + "";
}
function Dw(e, t, n) {
  return (t = q8(t)) in e ? Object.defineProperty(e, t, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = n, e;
}
function RD(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(a) {
      return Object.getOwnPropertyDescriptor(e, a).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function pt(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? RD(Object(n), !0).forEach(function(r) {
      Dw(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : RD(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function use(e) {
  if (Array.isArray(e)) return e;
}
function cse(e, t) {
  var n = e == null ? null : typeof Symbol < "u" && e[Symbol.iterator] || e["@@iterator"];
  if (n != null) {
    var r, a, s, l, c = [], d = !0, p = !1;
    try {
      if (s = (n = n.call(e)).next, t === 0) {
        if (Object(n) !== n) return;
        d = !1;
      } else for (; !(d = (r = s.call(n)).done) && (c.push(r.value), c.length !== t); d = !0) ;
    } catch (m) {
      p = !0, a = m;
    } finally {
      try {
        if (!d && n.return != null && (l = n.return(), Object(l) !== l)) return;
      } finally {
        if (p) throw a;
      }
    }
    return c;
  }
}
function S5(e, t) {
  (t == null || t > e.length) && (t = e.length);
  for (var n = 0, r = Array(t); n < t; n++) r[n] = e[n];
  return r;
}
function W8(e, t) {
  if (e) {
    if (typeof e == "string") return S5(e, t);
    var n = {}.toString.call(e).slice(8, -1);
    return n === "Object" && e.constructor && (n = e.constructor.name), n === "Map" || n === "Set" ? Array.from(e) : n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n) ? S5(e, t) : void 0;
  }
}
function dse() {
  throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function mc(e, t) {
  return use(e) || cse(e, t) || W8(e, t) || dse();
}
function Nc(e, t) {
  if (e == null) return {};
  var n, r, a = f2(e, t);
  if (Object.getOwnPropertySymbols) {
    var s = Object.getOwnPropertySymbols(e);
    for (r = 0; r < s.length; r++) n = s[r], t.indexOf(n) === -1 && {}.propertyIsEnumerable.call(e, n) && (a[n] = e[n]);
  }
  return a;
}
var fse = ["defaultInputValue", "defaultMenuIsOpen", "defaultValue", "inputValue", "menuIsOpen", "onChange", "onInputChange", "onMenuClose", "onMenuOpen", "value"];
function pse(e) {
  var t = e.defaultInputValue, n = t === void 0 ? "" : t, r = e.defaultMenuIsOpen, a = r === void 0 ? !1 : r, s = e.defaultValue, l = s === void 0 ? null : s, c = e.inputValue, d = e.menuIsOpen, p = e.onChange, m = e.onInputChange, h = e.onMenuClose, v = e.onMenuOpen, y = e.value, w = Nc(e, fse), x = M.useState(c !== void 0 ? c : n), b = mc(x, 2), k = b[0], C = b[1], _ = M.useState(d !== void 0 ? d : a), O = mc(_, 2), N = O[0], R = O[1], j = M.useState(y !== void 0 ? y : l), D = mc(j, 2), $ = D[0], z = D[1], B = M.useCallback(function(q, Z) {
    typeof p == "function" && p(q, Z), z(q);
  }, [p]), P = M.useCallback(function(q, Z) {
    var V;
    typeof m == "function" && (V = m(q, Z)), C(V !== void 0 ? V : q);
  }, [m]), W = M.useCallback(function() {
    typeof v == "function" && v(), R(!0);
  }, [v]), I = M.useCallback(function() {
    typeof h == "function" && h(), R(!1);
  }, [h]), G = c !== void 0 ? c : k, L = d !== void 0 ? d : N, K = y !== void 0 ? y : $;
  return pt(pt({}, w), {}, {
    inputValue: G,
    menuIsOpen: L,
    onChange: B,
    onInputChange: P,
    onMenuClose: I,
    onMenuOpen: W,
    value: K
  });
}
function mse(e, t) {
  if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function");
}
function AD(e, t) {
  for (var n = 0; n < t.length; n++) {
    var r = t[n];
    r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, q8(r.key), r);
  }
}
function hse(e, t, n) {
  return t && AD(e.prototype, t), n && AD(e, n), Object.defineProperty(e, "prototype", {
    writable: !1
  }), e;
}
function gse(e, t) {
  if (typeof t != "function" && t !== null) throw new TypeError("Super expression must either be null or a function");
  e.prototype = Object.create(t && t.prototype, {
    constructor: {
      value: e,
      writable: !0,
      configurable: !0
    }
  }), Object.defineProperty(e, "prototype", {
    writable: !1
  }), t && Y0(e, t);
}
function l_(e) {
  return l_ = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t) {
    return t.__proto__ || Object.getPrototypeOf(t);
  }, l_(e);
}
function G8() {
  try {
    var e = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
  } catch {
  }
  return (G8 = function() {
    return !!e;
  })();
}
function vse(e, t) {
  if (t && (cm(t) == "object" || typeof t == "function")) return t;
  if (t !== void 0) throw new TypeError("Derived constructors may only return object or undefined");
  return d9(e);
}
function yse(e) {
  var t = G8();
  return function() {
    var n, r = l_(e);
    if (t) {
      var a = l_(this).constructor;
      n = Reflect.construct(r, arguments, a);
    } else n = r.apply(this, arguments);
    return vse(this, n);
  };
}
function bse(e) {
  if (Array.isArray(e)) return S5(e);
}
function wse(e) {
  if (typeof Symbol < "u" && e[Symbol.iterator] != null || e["@@iterator"] != null) return Array.from(e);
}
function xse() {
  throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function FR(e) {
  return bse(e) || wse(e) || W8(e) || xse();
}
function Sse(e, t) {
  return t || (t = e.slice(0)), Object.freeze(Object.defineProperties(e, {
    raw: {
      value: Object.freeze(t)
    }
  }));
}
var k5 = M.useLayoutEffect, kse = ["className", "clearValue", "cx", "getStyles", "getClassNames", "getValue", "hasValue", "isMulti", "isRtl", "options", "selectOption", "selectProps", "setValue", "theme"], u_ = function() {
};
function _se(e, t) {
  return t ? t[0] === "-" ? e + t : e + "__" + t : e;
}
function Ese(e, t) {
  for (var n = arguments.length, r = new Array(n > 2 ? n - 2 : 0), a = 2; a < n; a++)
    r[a - 2] = arguments[a];
  var s = [].concat(r);
  if (t && e)
    for (var l in t)
      t.hasOwnProperty(l) && t[l] && s.push("".concat(_se(e, l)));
  return s.filter(function(c) {
    return c;
  }).map(function(c) {
    return String(c).trim();
  }).join(" ");
}
var jD = function(e) {
  return Dse(e) ? e.filter(Boolean) : cm(e) === "object" && e !== null ? [e] : [];
}, K8 = function(e) {
  e.className, e.clearValue, e.cx, e.getStyles, e.getClassNames, e.getValue, e.hasValue, e.isMulti, e.isRtl, e.options, e.selectOption, e.selectProps, e.setValue, e.theme;
  var t = Nc(e, kse);
  return pt({}, t);
}, br = function(e, t, n) {
  var r = e.cx, a = e.getStyles, s = e.getClassNames, l = e.className;
  return {
    css: a(t, e),
    className: r(n ?? {}, s(t, e), l)
  };
};
function R2(e) {
  return [document.documentElement, document.body, window].indexOf(e) > -1;
}
function Cse(e) {
  return R2(e) ? window.innerHeight : e.clientHeight;
}
function X8(e) {
  return R2(e) ? window.pageYOffset : e.scrollTop;
}
function c_(e, t) {
  if (R2(e)) {
    window.scrollTo(0, t);
    return;
  }
  e.scrollTop = t;
}
function Ose(e) {
  var t = getComputedStyle(e), n = t.position === "absolute", r = /(auto|scroll)/;
  if (t.position === "fixed") return document.documentElement;
  for (var a = e; a = a.parentElement; )
    if (t = getComputedStyle(a), !(n && t.position === "static") && r.test(t.overflow + t.overflowY + t.overflowX))
      return a;
  return document.documentElement;
}
function Mse(e, t, n, r) {
  return n * ((e = e / r - 1) * e * e + 1) + t;
}
function ZS(e, t) {
  var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 200, r = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : u_, a = X8(e), s = t - a, l = 10, c = 0;
  function d() {
    c += l;
    var p = Mse(c, a, s, n);
    c_(e, p), c < n ? window.requestAnimationFrame(d) : r(e);
  }
  d();
}
function PD(e, t) {
  var n = e.getBoundingClientRect(), r = t.getBoundingClientRect(), a = t.offsetHeight / 3;
  r.bottom + a > n.bottom ? c_(e, Math.min(t.offsetTop + t.clientHeight - e.offsetHeight + a, e.scrollHeight)) : r.top - a < n.top && c_(e, Math.max(t.offsetTop - a, 0));
}
function Nse(e) {
  var t = e.getBoundingClientRect();
  return {
    bottom: t.bottom,
    height: t.height,
    left: t.left,
    right: t.right,
    top: t.top,
    width: t.width
  };
}
function DD() {
  try {
    return document.createEvent("TouchEvent"), !0;
  } catch {
    return !1;
  }
}
function Rse() {
  try {
    return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
  } catch {
    return !1;
  }
}
var Y8 = !1, Ase = {
  get passive() {
    return Y8 = !0;
  }
}, ek = typeof window < "u" ? window : {};
ek.addEventListener && ek.removeEventListener && (ek.addEventListener("p", u_, Ase), ek.removeEventListener("p", u_, !1));
var jse = Y8;
function Pse(e) {
  return e != null;
}
function Dse(e) {
  return Array.isArray(e);
}
function tk(e, t, n) {
  return e ? t : n;
}
var $se = function(e) {
  for (var t = arguments.length, n = new Array(t > 1 ? t - 1 : 0), r = 1; r < t; r++)
    n[r - 1] = arguments[r];
  var a = Object.entries(e).filter(function(s) {
    var l = mc(s, 1), c = l[0];
    return !n.includes(c);
  });
  return a.reduce(function(s, l) {
    var c = mc(l, 2), d = c[0], p = c[1];
    return s[d] = p, s;
  }, {});
}, Tse = ["children", "innerProps"], Lse = ["children", "innerProps"];
function Ise(e) {
  var t = e.maxHeight, n = e.menuEl, r = e.minHeight, a = e.placement, s = e.shouldScroll, l = e.isFixedPosition, c = e.controlHeight, d = Ose(n), p = {
    placement: "bottom",
    maxHeight: t
  };
  if (!n || !n.offsetParent) return p;
  var m = d.getBoundingClientRect(), h = m.height, v = n.getBoundingClientRect(), y = v.bottom, w = v.height, x = v.top, b = n.offsetParent.getBoundingClientRect(), k = b.top, C = l ? window.innerHeight : Cse(d), _ = X8(d), O = parseInt(getComputedStyle(n).marginBottom, 10), N = parseInt(getComputedStyle(n).marginTop, 10), R = k - N, j = C - x, D = R + _, $ = h - _ - x, z = y - C + _ + O, B = _ + x - N, P = 160;
  switch (a) {
    case "auto":
    case "bottom":
      if (j >= w)
        return {
          placement: "bottom",
          maxHeight: t
        };
      if ($ >= w && !l)
        return s && ZS(d, z, P), {
          placement: "bottom",
          maxHeight: t
        };
      if (!l && $ >= r || l && j >= r) {
        s && ZS(d, z, P);
        var W = l ? j - O : $ - O;
        return {
          placement: "bottom",
          maxHeight: W
        };
      }
      if (a === "auto" || l) {
        var I = t, G = l ? R : D;
        return G >= r && (I = Math.min(G - O - c, t)), {
          placement: "top",
          maxHeight: I
        };
      }
      if (a === "bottom")
        return s && c_(d, z), {
          placement: "bottom",
          maxHeight: t
        };
      break;
    case "top":
      if (R >= w)
        return {
          placement: "top",
          maxHeight: t
        };
      if (D >= w && !l)
        return s && ZS(d, B, P), {
          placement: "top",
          maxHeight: t
        };
      if (!l && D >= r || l && R >= r) {
        var L = t;
        return (!l && D >= r || l && R >= r) && (L = l ? R - N : D - N), s && ZS(d, B, P), {
          placement: "top",
          maxHeight: L
        };
      }
      return {
        placement: "bottom",
        maxHeight: t
      };
    default:
      throw new Error('Invalid placement provided "'.concat(a, '".'));
  }
  return p;
}
function zse(e) {
  var t = {
    bottom: "top",
    top: "bottom"
  };
  return e ? t[e] : "bottom";
}
var Q8 = function(e) {
  return e === "auto" ? "bottom" : e;
}, Fse = function(e, t) {
  var n, r = e.placement, a = e.theme, s = a.borderRadius, l = a.spacing, c = a.colors;
  return pt((n = {
    label: "menu"
  }, Dw(n, zse(r), "100%"), Dw(n, "position", "absolute"), Dw(n, "width", "100%"), Dw(n, "zIndex", 1), n), t ? {} : {
    backgroundColor: c.neutral0,
    borderRadius: s,
    boxShadow: "0 0 0 1px hsla(0, 0%, 0%, 0.1), 0 4px 11px hsla(0, 0%, 0%, 0.1)",
    marginBottom: l.menuGutter,
    marginTop: l.menuGutter
  });
}, J8 = /* @__PURE__ */ M.createContext(null), Bse = function(e) {
  var t = e.children, n = e.minMenuHeight, r = e.maxMenuHeight, a = e.menuPlacement, s = e.menuPosition, l = e.menuShouldScrollIntoView, c = e.theme, d = M.useContext(J8) || {}, p = d.setPortalPlacement, m = M.useRef(null), h = M.useState(r), v = mc(h, 2), y = v[0], w = v[1], x = M.useState(null), b = mc(x, 2), k = b[0], C = b[1], _ = c.spacing.controlHeight;
  return k5(function() {
    var O = m.current;
    if (O) {
      var N = s === "fixed", R = l && !N, j = Ise({
        maxHeight: r,
        menuEl: O,
        minHeight: n,
        placement: a,
        shouldScroll: R,
        isFixedPosition: N,
        controlHeight: _
      });
      w(j.maxHeight), C(j.placement), p?.(j.placement);
    }
  }, [r, a, s, l, n, p, _]), t({
    ref: m,
    placerProps: pt(pt({}, e), {}, {
      placement: k || Q8(a),
      maxHeight: y
    })
  });
}, Use = function(e) {
  var t = e.children, n = e.innerRef, r = e.innerProps;
  return ut("div", ft({}, br(e, "menu", {
    menu: !0
  }), {
    ref: n
  }, r), t);
}, Vse = Use, Hse = function(e, t) {
  var n = e.maxHeight, r = e.theme.spacing.baseUnit;
  return pt({
    maxHeight: n,
    overflowY: "auto",
    position: "relative",
    // required for offset[Height, Top] > keyboard scroll
    WebkitOverflowScrolling: "touch"
  }, t ? {} : {
    paddingBottom: r,
    paddingTop: r
  });
}, qse = function(e) {
  var t = e.children, n = e.innerProps, r = e.innerRef, a = e.isMulti;
  return ut("div", ft({}, br(e, "menuList", {
    "menu-list": !0,
    "menu-list--is-multi": a
  }), {
    ref: r
  }, n), t);
}, Z8 = function(e, t) {
  var n = e.theme, r = n.spacing.baseUnit, a = n.colors;
  return pt({
    textAlign: "center"
  }, t ? {} : {
    color: a.neutral40,
    padding: "".concat(r * 2, "px ").concat(r * 3, "px")
  });
}, Wse = Z8, Gse = Z8, Kse = function(e) {
  var t = e.children, n = t === void 0 ? "No options" : t, r = e.innerProps, a = Nc(e, Tse);
  return ut("div", ft({}, br(pt(pt({}, a), {}, {
    children: n,
    innerProps: r
  }), "noOptionsMessage", {
    "menu-notice": !0,
    "menu-notice--no-options": !0
  }), r), n);
}, Xse = function(e) {
  var t = e.children, n = t === void 0 ? "Loading..." : t, r = e.innerProps, a = Nc(e, Lse);
  return ut("div", ft({}, br(pt(pt({}, a), {}, {
    children: n,
    innerProps: r
  }), "loadingMessage", {
    "menu-notice": !0,
    "menu-notice--loading": !0
  }), r), n);
}, Yse = function(e) {
  var t = e.rect, n = e.offset, r = e.position;
  return {
    left: t.left,
    position: r,
    top: n,
    width: t.width,
    zIndex: 1
  };
}, Qse = function(e) {
  var t = e.appendTo, n = e.children, r = e.controlElement, a = e.innerProps, s = e.menuPlacement, l = e.menuPosition, c = M.useRef(null), d = M.useRef(null), p = M.useState(Q8(s)), m = mc(p, 2), h = m[0], v = m[1], y = M.useMemo(function() {
    return {
      setPortalPlacement: v
    };
  }, []), w = M.useState(null), x = mc(w, 2), b = x[0], k = x[1], C = M.useCallback(function() {
    if (r) {
      var R = Nse(r), j = l === "fixed" ? 0 : window.pageYOffset, D = R[h] + j;
      (D !== b?.offset || R.left !== b?.rect.left || R.width !== b?.rect.width) && k({
        offset: D,
        rect: R
      });
    }
  }, [r, l, h, b?.offset, b?.rect.left, b?.rect.width]);
  k5(function() {
    C();
  }, [C]);
  var _ = M.useCallback(function() {
    typeof d.current == "function" && (d.current(), d.current = null), r && c.current && (d.current = m8(r, c.current, C, {
      elementResize: "ResizeObserver" in window
    }));
  }, [r, C]);
  k5(function() {
    _();
  }, [_]);
  var O = M.useCallback(function(R) {
    c.current = R, _();
  }, [_]);
  if (!t && l !== "fixed" || !b) return null;
  var N = ut("div", ft({
    ref: O
  }, br(pt(pt({}, e), {}, {
    offset: b.offset,
    position: l,
    rect: b.rect
  }), "menuPortal", {
    "menu-portal": !0
  }), a), n);
  return ut(J8.Provider, {
    value: y
  }, t ? /* @__PURE__ */ xm.createPortal(N, t) : N);
}, Jse = function(e) {
  var t = e.isDisabled, n = e.isRtl;
  return {
    label: "container",
    direction: n ? "rtl" : void 0,
    pointerEvents: t ? "none" : void 0,
    // cancel mouse events when disabled
    position: "relative"
  };
}, Zse = function(e) {
  var t = e.children, n = e.innerProps, r = e.isDisabled, a = e.isRtl;
  return ut("div", ft({}, br(e, "container", {
    "--is-disabled": r,
    "--is-rtl": a
  }), n), t);
}, ele = function(e, t) {
  var n = e.theme.spacing, r = e.isMulti, a = e.hasValue, s = e.selectProps.controlShouldRenderValue;
  return pt({
    alignItems: "center",
    display: r && a && s ? "flex" : "grid",
    flex: 1,
    flexWrap: "wrap",
    WebkitOverflowScrolling: "touch",
    position: "relative",
    overflow: "hidden"
  }, t ? {} : {
    padding: "".concat(n.baseUnit / 2, "px ").concat(n.baseUnit * 2, "px")
  });
}, tle = function(e) {
  var t = e.children, n = e.innerProps, r = e.isMulti, a = e.hasValue;
  return ut("div", ft({}, br(e, "valueContainer", {
    "value-container": !0,
    "value-container--is-multi": r,
    "value-container--has-value": a
  }), n), t);
}, nle = function() {
  return {
    alignItems: "center",
    alignSelf: "stretch",
    display: "flex",
    flexShrink: 0
  };
}, rle = function(e) {
  var t = e.children, n = e.innerProps;
  return ut("div", ft({}, br(e, "indicatorsContainer", {
    indicators: !0
  }), n), t);
}, $D, ole = ["size"], ale = ["innerProps", "isRtl", "size"], ile = {
  name: "8mmkcg",
  styles: "display:inline-block;fill:currentColor;line-height:1;stroke:currentColor;stroke-width:0"
}, e7 = function(e) {
  var t = e.size, n = Nc(e, ole);
  return ut("svg", ft({
    height: t,
    width: t,
    viewBox: "0 0 20 20",
    "aria-hidden": "true",
    focusable: "false",
    css: ile
  }, n));
}, BR = function(e) {
  return ut(e7, ft({
    size: 20
  }, e), ut("path", {
    d: "M14.348 14.849c-0.469 0.469-1.229 0.469-1.697 0l-2.651-3.030-2.651 3.029c-0.469 0.469-1.229 0.469-1.697 0-0.469-0.469-0.469-1.229 0-1.697l2.758-3.15-2.759-3.152c-0.469-0.469-0.469-1.228 0-1.697s1.228-0.469 1.697 0l2.652 3.031 2.651-3.031c0.469-0.469 1.228-0.469 1.697 0s0.469 1.229 0 1.697l-2.758 3.152 2.758 3.15c0.469 0.469 0.469 1.229 0 1.698z"
  }));
}, t7 = function(e) {
  return ut(e7, ft({
    size: 20
  }, e), ut("path", {
    d: "M4.516 7.548c0.436-0.446 1.043-0.481 1.576 0l3.908 3.747 3.908-3.747c0.533-0.481 1.141-0.446 1.574 0 0.436 0.445 0.408 1.197 0 1.615-0.406 0.418-4.695 4.502-4.695 4.502-0.217 0.223-0.502 0.335-0.787 0.335s-0.57-0.112-0.789-0.335c0 0-4.287-4.084-4.695-4.502s-0.436-1.17 0-1.615z"
  }));
}, n7 = function(e, t) {
  var n = e.isFocused, r = e.theme, a = r.spacing.baseUnit, s = r.colors;
  return pt({
    label: "indicatorContainer",
    display: "flex",
    transition: "color 150ms"
  }, t ? {} : {
    color: n ? s.neutral60 : s.neutral20,
    padding: a * 2,
    ":hover": {
      color: n ? s.neutral80 : s.neutral40
    }
  });
}, sle = n7, lle = function(e) {
  var t = e.children, n = e.innerProps;
  return ut("div", ft({}, br(e, "dropdownIndicator", {
    indicator: !0,
    "dropdown-indicator": !0
  }), n), t || ut(t7, null));
}, ule = n7, cle = function(e) {
  var t = e.children, n = e.innerProps;
  return ut("div", ft({}, br(e, "clearIndicator", {
    indicator: !0,
    "clear-indicator": !0
  }), n), t || ut(BR, null));
}, dle = function(e, t) {
  var n = e.isDisabled, r = e.theme, a = r.spacing.baseUnit, s = r.colors;
  return pt({
    label: "indicatorSeparator",
    alignSelf: "stretch",
    width: 1
  }, t ? {} : {
    backgroundColor: n ? s.neutral10 : s.neutral20,
    marginBottom: a * 2,
    marginTop: a * 2
  });
}, fle = function(e) {
  var t = e.innerProps;
  return ut("span", ft({}, t, br(e, "indicatorSeparator", {
    "indicator-separator": !0
  })));
}, ple = Zh($D || ($D = Sse([`
  0%, 80%, 100% { opacity: 0; }
  40% { opacity: 1; }
`]))), mle = function(e, t) {
  var n = e.isFocused, r = e.size, a = e.theme, s = a.colors, l = a.spacing.baseUnit;
  return pt({
    label: "loadingIndicator",
    display: "flex",
    transition: "color 150ms",
    alignSelf: "center",
    fontSize: r,
    lineHeight: 1,
    marginRight: r,
    textAlign: "center",
    verticalAlign: "middle"
  }, t ? {} : {
    color: n ? s.neutral60 : s.neutral20,
    padding: l * 2
  });
}, yM = function(e) {
  var t = e.delay, n = e.offset;
  return ut("span", {
    css: /* @__PURE__ */ eS({
      animation: "".concat(ple, " 1s ease-in-out ").concat(t, "ms infinite;"),
      backgroundColor: "currentColor",
      borderRadius: "1em",
      display: "inline-block",
      marginLeft: n ? "1em" : void 0,
      height: "1em",
      verticalAlign: "top",
      width: "1em"
    }, "", "")
  });
}, hle = function(e) {
  var t = e.innerProps, n = e.isRtl, r = e.size, a = r === void 0 ? 4 : r, s = Nc(e, ale);
  return ut("div", ft({}, br(pt(pt({}, s), {}, {
    innerProps: t,
    isRtl: n,
    size: a
  }), "loadingIndicator", {
    indicator: !0,
    "loading-indicator": !0
  }), t), ut(yM, {
    delay: 0,
    offset: n
  }), ut(yM, {
    delay: 160,
    offset: !0
  }), ut(yM, {
    delay: 320,
    offset: !n
  }));
}, gle = function(e, t) {
  var n = e.isDisabled, r = e.isFocused, a = e.theme, s = a.colors, l = a.borderRadius, c = a.spacing;
  return pt({
    label: "control",
    alignItems: "center",
    cursor: "default",
    display: "flex",
    flexWrap: "wrap",
    justifyContent: "space-between",
    minHeight: c.controlHeight,
    outline: "0 !important",
    position: "relative",
    transition: "all 100ms"
  }, t ? {} : {
    backgroundColor: n ? s.neutral5 : s.neutral0,
    borderColor: n ? s.neutral10 : r ? s.primary : s.neutral20,
    borderRadius: l,
    borderStyle: "solid",
    borderWidth: 1,
    boxShadow: r ? "0 0 0 1px ".concat(s.primary) : void 0,
    "&:hover": {
      borderColor: r ? s.primary : s.neutral30
    }
  });
}, vle = function(e) {
  var t = e.children, n = e.isDisabled, r = e.isFocused, a = e.innerRef, s = e.innerProps, l = e.menuIsOpen;
  return ut("div", ft({
    ref: a
  }, br(e, "control", {
    control: !0,
    "control--is-disabled": n,
    "control--is-focused": r,
    "control--menu-is-open": l
  }), s, {
    "aria-disabled": n || void 0
  }), t);
}, yle = vle, ble = ["data"], wle = function(e, t) {
  var n = e.theme.spacing;
  return t ? {} : {
    paddingBottom: n.baseUnit * 2,
    paddingTop: n.baseUnit * 2
  };
}, xle = function(e) {
  var t = e.children, n = e.cx, r = e.getStyles, a = e.getClassNames, s = e.Heading, l = e.headingProps, c = e.innerProps, d = e.label, p = e.theme, m = e.selectProps;
  return ut("div", ft({}, br(e, "group", {
    group: !0
  }), c), ut(s, ft({}, l, {
    selectProps: m,
    theme: p,
    getStyles: r,
    getClassNames: a,
    cx: n
  }), d), ut("div", null, t));
}, Sle = function(e, t) {
  var n = e.theme, r = n.colors, a = n.spacing;
  return pt({
    label: "group",
    cursor: "default",
    display: "block"
  }, t ? {} : {
    color: r.neutral40,
    fontSize: "75%",
    fontWeight: 500,
    marginBottom: "0.25em",
    paddingLeft: a.baseUnit * 3,
    paddingRight: a.baseUnit * 3,
    textTransform: "uppercase"
  });
}, kle = function(e) {
  var t = K8(e);
  t.data;
  var n = Nc(t, ble);
  return ut("div", ft({}, br(e, "groupHeading", {
    "group-heading": !0
  }), n));
}, _le = xle, Ele = ["innerRef", "isDisabled", "isHidden", "inputClassName"], Cle = function(e, t) {
  var n = e.isDisabled, r = e.value, a = e.theme, s = a.spacing, l = a.colors;
  return pt(pt({
    visibility: n ? "hidden" : "visible",
    // force css to recompute when value change due to @emotion bug.
    // We can remove it whenever the bug is fixed.
    transform: r ? "translateZ(0)" : ""
  }, Ole), t ? {} : {
    margin: s.baseUnit / 2,
    paddingBottom: s.baseUnit / 2,
    paddingTop: s.baseUnit / 2,
    color: l.neutral80
  });
}, r7 = {
  gridArea: "1 / 2",
  font: "inherit",
  minWidth: "2px",
  border: 0,
  margin: 0,
  outline: 0,
  padding: 0
}, Ole = {
  flex: "1 1 auto",
  display: "inline-grid",
  gridArea: "1 / 1 / 2 / 3",
  gridTemplateColumns: "0 min-content",
  "&:after": pt({
    content: 'attr(data-value) " "',
    visibility: "hidden",
    whiteSpace: "pre"
  }, r7)
}, Mle = function(e) {
  return pt({
    label: "input",
    color: "inherit",
    background: 0,
    opacity: e ? 0 : 1,
    width: "100%"
  }, r7);
}, Nle = function(e) {
  var t = e.cx, n = e.value, r = K8(e), a = r.innerRef, s = r.isDisabled, l = r.isHidden, c = r.inputClassName, d = Nc(r, Ele);
  return ut("div", ft({}, br(e, "input", {
    "input-container": !0
  }), {
    "data-value": n || ""
  }), ut("input", ft({
    className: t({
      input: !0
    }, c),
    ref: a,
    style: Mle(l),
    disabled: s
  }, d)));
}, Rle = Nle, Ale = function(e, t) {
  var n = e.theme, r = n.spacing, a = n.borderRadius, s = n.colors;
  return pt({
    label: "multiValue",
    display: "flex",
    minWidth: 0
  }, t ? {} : {
    backgroundColor: s.neutral10,
    borderRadius: a / 2,
    margin: r.baseUnit / 2
  });
}, jle = function(e, t) {
  var n = e.theme, r = n.borderRadius, a = n.colors, s = e.cropWithEllipsis;
  return pt({
    overflow: "hidden",
    textOverflow: s || s === void 0 ? "ellipsis" : void 0,
    whiteSpace: "nowrap"
  }, t ? {} : {
    borderRadius: r / 2,
    color: a.neutral80,
    fontSize: "85%",
    padding: 3,
    paddingLeft: 6
  });
}, Ple = function(e, t) {
  var n = e.theme, r = n.spacing, a = n.borderRadius, s = n.colors, l = e.isFocused;
  return pt({
    alignItems: "center",
    display: "flex"
  }, t ? {} : {
    borderRadius: a / 2,
    backgroundColor: l ? s.dangerLight : void 0,
    paddingLeft: r.baseUnit,
    paddingRight: r.baseUnit,
    ":hover": {
      backgroundColor: s.dangerLight,
      color: s.danger
    }
  });
}, o7 = function(e) {
  var t = e.children, n = e.innerProps;
  return ut("div", n, t);
}, Dle = o7, $le = o7;
function Tle(e) {
  var t = e.children, n = e.innerProps;
  return ut("div", ft({
    role: "button"
  }, n), t || ut(BR, {
    size: 14
  }));
}
var Lle = function(e) {
  var t = e.children, n = e.components, r = e.data, a = e.innerProps, s = e.isDisabled, l = e.removeProps, c = e.selectProps, d = n.Container, p = n.Label, m = n.Remove;
  return ut(d, {
    data: r,
    innerProps: pt(pt({}, br(e, "multiValue", {
      "multi-value": !0,
      "multi-value--is-disabled": s
    })), a),
    selectProps: c
  }, ut(p, {
    data: r,
    innerProps: pt({}, br(e, "multiValueLabel", {
      "multi-value__label": !0
    })),
    selectProps: c
  }, t), ut(m, {
    data: r,
    innerProps: pt(pt({}, br(e, "multiValueRemove", {
      "multi-value__remove": !0
    })), {}, {
      "aria-label": "Remove ".concat(t || "option")
    }, l),
    selectProps: c
  }));
}, Ile = Lle, zle = function(e, t) {
  var n = e.isDisabled, r = e.isFocused, a = e.isSelected, s = e.theme, l = s.spacing, c = s.colors;
  return pt({
    label: "option",
    cursor: "default",
    display: "block",
    fontSize: "inherit",
    width: "100%",
    userSelect: "none",
    WebkitTapHighlightColor: "rgba(0, 0, 0, 0)"
  }, t ? {} : {
    backgroundColor: a ? c.primary : r ? c.primary25 : "transparent",
    color: n ? c.neutral20 : a ? c.neutral0 : "inherit",
    padding: "".concat(l.baseUnit * 2, "px ").concat(l.baseUnit * 3, "px"),
    // provide some affordance on touch devices
    ":active": {
      backgroundColor: n ? void 0 : a ? c.primary : c.primary50
    }
  });
}, Fle = function(e) {
  var t = e.children, n = e.isDisabled, r = e.isFocused, a = e.isSelected, s = e.innerRef, l = e.innerProps;
  return ut("div", ft({}, br(e, "option", {
    option: !0,
    "option--is-disabled": n,
    "option--is-focused": r,
    "option--is-selected": a
  }), {
    ref: s,
    "aria-disabled": n
  }, l), t);
}, Ble = Fle, Ule = function(e, t) {
  var n = e.theme, r = n.spacing, a = n.colors;
  return pt({
    label: "placeholder",
    gridArea: "1 / 1 / 2 / 3"
  }, t ? {} : {
    color: a.neutral50,
    marginLeft: r.baseUnit / 2,
    marginRight: r.baseUnit / 2
  });
}, Vle = function(e) {
  var t = e.children, n = e.innerProps;
  return ut("div", ft({}, br(e, "placeholder", {
    placeholder: !0
  }), n), t);
}, Hle = Vle, qle = function(e, t) {
  var n = e.isDisabled, r = e.theme, a = r.spacing, s = r.colors;
  return pt({
    label: "singleValue",
    gridArea: "1 / 1 / 2 / 3",
    maxWidth: "100%",
    overflow: "hidden",
    textOverflow: "ellipsis",
    whiteSpace: "nowrap"
  }, t ? {} : {
    color: n ? s.neutral40 : s.neutral80,
    marginLeft: a.baseUnit / 2,
    marginRight: a.baseUnit / 2
  });
}, Wle = function(e) {
  var t = e.children, n = e.isDisabled, r = e.innerProps;
  return ut("div", ft({}, br(e, "singleValue", {
    "single-value": !0,
    "single-value--is-disabled": n
  }), r), t);
}, Gle = Wle, Kle = {
  ClearIndicator: cle,
  Control: yle,
  DropdownIndicator: lle,
  DownChevron: t7,
  CrossIcon: BR,
  Group: _le,
  GroupHeading: kle,
  IndicatorsContainer: rle,
  IndicatorSeparator: fle,
  Input: Rle,
  LoadingIndicator: hle,
  Menu: Vse,
  MenuList: qse,
  MenuPortal: Qse,
  LoadingMessage: Xse,
  NoOptionsMessage: Kse,
  MultiValue: Ile,
  MultiValueContainer: Dle,
  MultiValueLabel: $le,
  MultiValueRemove: Tle,
  Option: Ble,
  Placeholder: Hle,
  SelectContainer: Zse,
  SingleValue: Gle,
  ValueContainer: tle
}, Xle = function(e) {
  return pt(pt({}, Kle), e.components);
}, TD = Number.isNaN || function(e) {
  return typeof e == "number" && e !== e;
};
function Yle(e, t) {
  return !!(e === t || TD(e) && TD(t));
}
function Qle(e, t) {
  if (e.length !== t.length)
    return !1;
  for (var n = 0; n < e.length; n++)
    if (!Yle(e[n], t[n]))
      return !1;
  return !0;
}
function Jle(e, t) {
  t === void 0 && (t = Qle);
  var n = null;
  function r() {
    for (var a = [], s = 0; s < arguments.length; s++)
      a[s] = arguments[s];
    if (n && n.lastThis === this && t(a, n.lastArgs))
      return n.lastResult;
    var l = e.apply(this, a);
    return n = {
      lastResult: l,
      lastArgs: a,
      lastThis: this
    }, l;
  }
  return r.clear = function() {
    n = null;
  }, r;
}
var Zle = {
  name: "7pg0cj-a11yText",
  styles: "label:a11yText;z-index:9999;border:0;clip:rect(1px, 1px, 1px, 1px);height:1px;width:1px;position:absolute;overflow:hidden;padding:0;white-space:nowrap"
}, eue = function(e) {
  return ut("span", ft({
    css: Zle
  }, e));
}, LD = eue, tue = {
  guidance: function(e) {
    var t = e.isSearchable, n = e.isMulti, r = e.tabSelectsValue, a = e.context, s = e.isInitialFocus;
    switch (a) {
      case "menu":
        return "Use Up and Down to choose options, press Enter to select the currently focused option, press Escape to exit the menu".concat(r ? ", press Tab to select the option and exit the menu" : "", ".");
      case "input":
        return s ? "".concat(e["aria-label"] || "Select", " is focused ").concat(t ? ",type to refine list" : "", ", press Down to open the menu, ").concat(n ? " press left to focus selected values" : "") : "";
      case "value":
        return "Use left and right to toggle between focused values, press Backspace to remove the currently focused value";
      default:
        return "";
    }
  },
  onChange: function(e) {
    var t = e.action, n = e.label, r = n === void 0 ? "" : n, a = e.labels, s = e.isDisabled;
    switch (t) {
      case "deselect-option":
      case "pop-value":
      case "remove-value":
        return "option ".concat(r, ", deselected.");
      case "clear":
        return "All selected options have been cleared.";
      case "initial-input-focus":
        return "option".concat(a.length > 1 ? "s" : "", " ").concat(a.join(","), ", selected.");
      case "select-option":
        return s ? "option ".concat(r, " is disabled. Select another option.") : "option ".concat(r, ", selected.");
      default:
        return "";
    }
  },
  onFocus: function(e) {
    var t = e.context, n = e.focused, r = e.options, a = e.label, s = a === void 0 ? "" : a, l = e.selectValue, c = e.isDisabled, d = e.isSelected, p = e.isAppleDevice, m = function(y, w) {
      return y && y.length ? "".concat(y.indexOf(w) + 1, " of ").concat(y.length) : "";
    };
    if (t === "value" && l)
      return "value ".concat(s, " focused, ").concat(m(l, n), ".");
    if (t === "menu" && p) {
      var h = c ? " disabled" : "", v = "".concat(d ? " selected" : "").concat(h);
      return "".concat(s).concat(v, ", ").concat(m(r, n), ".");
    }
    return "";
  },
  onFilter: function(e) {
    var t = e.inputValue, n = e.resultsMessage;
    return "".concat(n).concat(t ? " for search term " + t : "", ".");
  }
}, nue = function(e) {
  var t = e.ariaSelection, n = e.focusedOption, r = e.focusedValue, a = e.focusableOptions, s = e.isFocused, l = e.selectValue, c = e.selectProps, d = e.id, p = e.isAppleDevice, m = c.ariaLiveMessages, h = c.getOptionLabel, v = c.inputValue, y = c.isMulti, w = c.isOptionDisabled, x = c.isSearchable, b = c.menuIsOpen, k = c.options, C = c.screenReaderStatus, _ = c.tabSelectsValue, O = c.isLoading, N = c["aria-label"], R = c["aria-live"], j = M.useMemo(function() {
    return pt(pt({}, tue), m || {});
  }, [m]), D = M.useMemo(function() {
    var I = "";
    if (t && j.onChange) {
      var G = t.option, L = t.options, K = t.removedValue, q = t.removedValues, Z = t.value, V = function(re) {
        return Array.isArray(re) ? null : re;
      }, F = K || G || V(Z), X = F ? h(F) : "", U = L || q || void 0, H = U ? U.map(h) : [], Q = pt({
        // multiSelected items are usually items that have already been selected
        // or set by the user as a default value so we assume they are not disabled
        isDisabled: F && w(F, l),
        label: X,
        labels: H
      }, t);
      I = j.onChange(Q);
    }
    return I;
  }, [t, j, w, l, h]), $ = M.useMemo(function() {
    var I = "", G = n || r, L = !!(n && l && l.includes(n));
    if (G && j.onFocus) {
      var K = {
        focused: G,
        label: h(G),
        isDisabled: w(G, l),
        isSelected: L,
        options: a,
        context: G === n ? "menu" : "value",
        selectValue: l,
        isAppleDevice: p
      };
      I = j.onFocus(K);
    }
    return I;
  }, [n, r, h, w, j, a, l, p]), z = M.useMemo(function() {
    var I = "";
    if (b && k.length && !O && j.onFilter) {
      var G = C({
        count: a.length
      });
      I = j.onFilter({
        inputValue: v,
        resultsMessage: G
      });
    }
    return I;
  }, [a, v, b, j, k, C, O]), B = t?.action === "initial-input-focus", P = M.useMemo(function() {
    var I = "";
    if (j.guidance) {
      var G = r ? "value" : b ? "menu" : "input";
      I = j.guidance({
        "aria-label": N,
        context: G,
        isDisabled: n && w(n, l),
        isMulti: y,
        isSearchable: x,
        tabSelectsValue: _,
        isInitialFocus: B
      });
    }
    return I;
  }, [N, n, r, y, w, x, b, j, l, _, B]), W = ut(M.Fragment, null, ut("span", {
    id: "aria-selection"
  }, D), ut("span", {
    id: "aria-focused"
  }, $), ut("span", {
    id: "aria-results"
  }, z), ut("span", {
    id: "aria-guidance"
  }, P));
  return ut(M.Fragment, null, ut(LD, {
    id: d
  }, B && W), ut(LD, {
    "aria-live": R,
    "aria-atomic": "false",
    "aria-relevant": "additions text",
    role: "log"
  }, s && !B && W));
}, rue = nue, _5 = [{
  base: "A",
  letters: "A"
}, {
  base: "AA",
  letters: ""
}, {
  base: "AE",
  letters: ""
}, {
  base: "AO",
  letters: ""
}, {
  base: "AU",
  letters: ""
}, {
  base: "AV",
  letters: ""
}, {
  base: "AY",
  letters: ""
}, {
  base: "B",
  letters: "B"
}, {
  base: "C",
  letters: "C"
}, {
  base: "D",
  letters: "D"
}, {
  base: "DZ",
  letters: ""
}, {
  base: "Dz",
  letters: ""
}, {
  base: "E",
  letters: "E"
}, {
  base: "F",
  letters: "F"
}, {
  base: "G",
  letters: "G"
}, {
  base: "H",
  letters: "H"
}, {
  base: "I",
  letters: "I"
}, {
  base: "J",
  letters: "J"
}, {
  base: "K",
  letters: "K"
}, {
  base: "L",
  letters: "L"
}, {
  base: "LJ",
  letters: ""
}, {
  base: "Lj",
  letters: ""
}, {
  base: "M",
  letters: "M"
}, {
  base: "N",
  letters: "N"
}, {
  base: "NJ",
  letters: ""
}, {
  base: "Nj",
  letters: ""
}, {
  base: "O",
  letters: "O"
}, {
  base: "OI",
  letters: ""
}, {
  base: "OO",
  letters: ""
}, {
  base: "OU",
  letters: ""
}, {
  base: "P",
  letters: "P"
}, {
  base: "Q",
  letters: "Q"
}, {
  base: "R",
  letters: "R"
}, {
  base: "S",
  letters: "S"
}, {
  base: "T",
  letters: "T"
}, {
  base: "TZ",
  letters: ""
}, {
  base: "U",
  letters: "U"
}, {
  base: "V",
  letters: "V"
}, {
  base: "VY",
  letters: ""
}, {
  base: "W",
  letters: "W"
}, {
  base: "X",
  letters: "X"
}, {
  base: "Y",
  letters: "Y"
}, {
  base: "Z",
  letters: "Z"
}, {
  base: "a",
  letters: "a"
}, {
  base: "aa",
  letters: ""
}, {
  base: "ae",
  letters: ""
}, {
  base: "ao",
  letters: ""
}, {
  base: "au",
  letters: ""
}, {
  base: "av",
  letters: ""
}, {
  base: "ay",
  letters: ""
}, {
  base: "b",
  letters: "b"
}, {
  base: "c",
  letters: "c"
}, {
  base: "d",
  letters: "d"
}, {
  base: "dz",
  letters: ""
}, {
  base: "e",
  letters: "e"
}, {
  base: "f",
  letters: "f"
}, {
  base: "g",
  letters: "g"
}, {
  base: "h",
  letters: "h"
}, {
  base: "hv",
  letters: ""
}, {
  base: "i",
  letters: "i"
}, {
  base: "j",
  letters: "j"
}, {
  base: "k",
  letters: "k"
}, {
  base: "l",
  letters: "l"
}, {
  base: "lj",
  letters: ""
}, {
  base: "m",
  letters: "m"
}, {
  base: "n",
  letters: "n"
}, {
  base: "nj",
  letters: ""
}, {
  base: "o",
  letters: "o"
}, {
  base: "oi",
  letters: ""
}, {
  base: "ou",
  letters: ""
}, {
  base: "oo",
  letters: ""
}, {
  base: "p",
  letters: "p"
}, {
  base: "q",
  letters: "q"
}, {
  base: "r",
  letters: "r"
}, {
  base: "s",
  letters: "s"
}, {
  base: "t",
  letters: "t"
}, {
  base: "tz",
  letters: ""
}, {
  base: "u",
  letters: "u"
}, {
  base: "v",
  letters: "v"
}, {
  base: "vy",
  letters: ""
}, {
  base: "w",
  letters: "w"
}, {
  base: "x",
  letters: "x"
}, {
  base: "y",
  letters: "y"
}, {
  base: "z",
  letters: "z"
}], oue = new RegExp("[" + _5.map(function(e) {
  return e.letters;
}).join("") + "]", "g"), a7 = {};
for (var bM = 0; bM < _5.length; bM++)
  for (var wM = _5[bM], xM = 0; xM < wM.letters.length; xM++)
    a7[wM.letters[xM]] = wM.base;
var i7 = function(e) {
  return e.replace(oue, function(t) {
    return a7[t];
  });
}, aue = Jle(i7), ID = function(e) {
  return e.replace(/^\s+|\s+$/g, "");
}, iue = function(e) {
  return "".concat(e.label, " ").concat(e.value);
}, sue = function(e) {
  return function(t, n) {
    if (t.data.__isNew__) return !0;
    var r = pt({
      ignoreCase: !0,
      ignoreAccents: !0,
      stringify: iue,
      trim: !0,
      matchFrom: "any"
    }, e), a = r.ignoreCase, s = r.ignoreAccents, l = r.stringify, c = r.trim, d = r.matchFrom, p = c ? ID(n) : n, m = c ? ID(l(t)) : l(t);
    return a && (p = p.toLowerCase(), m = m.toLowerCase()), s && (p = aue(p), m = i7(m)), d === "start" ? m.substr(0, p.length) === p : m.indexOf(p) > -1;
  };
}, lue = ["innerRef"];
function uue(e) {
  var t = e.innerRef, n = Nc(e, lue), r = $se(n, "onExited", "in", "enter", "exit", "appear");
  return ut("input", ft({
    ref: t
  }, r, {
    css: /* @__PURE__ */ eS({
      label: "dummyInput",
      // get rid of any default styles
      background: 0,
      border: 0,
      // important! this hides the flashing cursor
      caretColor: "transparent",
      fontSize: "inherit",
      gridArea: "1 / 1 / 2 / 3",
      outline: 0,
      padding: 0,
      // important! without `width` browsers won't allow focus
      width: 1,
      // remove cursor on desktop
      color: "transparent",
      // remove cursor on mobile whilst maintaining "scroll into view" behaviour
      left: -100,
      opacity: 0,
      position: "relative",
      transform: "scale(.01)"
    }, "", "")
  }));
}
var cue = function(e) {
  e.cancelable && e.preventDefault(), e.stopPropagation();
};
function due(e) {
  var t = e.isEnabled, n = e.onBottomArrive, r = e.onBottomLeave, a = e.onTopArrive, s = e.onTopLeave, l = M.useRef(!1), c = M.useRef(!1), d = M.useRef(0), p = M.useRef(null), m = M.useCallback(function(b, k) {
    if (p.current !== null) {
      var C = p.current, _ = C.scrollTop, O = C.scrollHeight, N = C.clientHeight, R = p.current, j = k > 0, D = O - N - _, $ = !1;
      D > k && l.current && (r && r(b), l.current = !1), j && c.current && (s && s(b), c.current = !1), j && k > D ? (n && !l.current && n(b), R.scrollTop = O, $ = !0, l.current = !0) : !j && -k > _ && (a && !c.current && a(b), R.scrollTop = 0, $ = !0, c.current = !0), $ && cue(b);
    }
  }, [n, r, a, s]), h = M.useCallback(function(b) {
    m(b, b.deltaY);
  }, [m]), v = M.useCallback(function(b) {
    d.current = b.changedTouches[0].clientY;
  }, []), y = M.useCallback(function(b) {
    var k = d.current - b.changedTouches[0].clientY;
    m(b, k);
  }, [m]), w = M.useCallback(function(b) {
    if (b) {
      var k = jse ? {
        passive: !1
      } : !1;
      b.addEventListener("wheel", h, k), b.addEventListener("touchstart", v, k), b.addEventListener("touchmove", y, k);
    }
  }, [y, v, h]), x = M.useCallback(function(b) {
    b && (b.removeEventListener("wheel", h, !1), b.removeEventListener("touchstart", v, !1), b.removeEventListener("touchmove", y, !1));
  }, [y, v, h]);
  return M.useEffect(function() {
    if (t) {
      var b = p.current;
      return w(b), function() {
        x(b);
      };
    }
  }, [t, w, x]), function(b) {
    p.current = b;
  };
}
var zD = ["boxSizing", "height", "overflow", "paddingRight", "position"], FD = {
  boxSizing: "border-box",
  // account for possible declaration `width: 100%;` on body
  overflow: "hidden",
  position: "relative",
  height: "100%"
};
function BD(e) {
  e.cancelable && e.preventDefault();
}
function UD(e) {
  e.stopPropagation();
}
function VD() {
  var e = this.scrollTop, t = this.scrollHeight, n = e + this.offsetHeight;
  e === 0 ? this.scrollTop = 1 : n === t && (this.scrollTop = e - 1);
}
function HD() {
  return "ontouchstart" in window || navigator.maxTouchPoints;
}
var qD = !!(typeof window < "u" && window.document && window.document.createElement), uw = 0, Km = {
  capture: !1,
  passive: !1
};
function fue(e) {
  var t = e.isEnabled, n = e.accountForScrollbars, r = n === void 0 ? !0 : n, a = M.useRef({}), s = M.useRef(null), l = M.useCallback(function(d) {
    if (qD) {
      var p = document.body, m = p && p.style;
      if (r && zD.forEach(function(w) {
        var x = m && m[w];
        a.current[w] = x;
      }), r && uw < 1) {
        var h = parseInt(a.current.paddingRight, 10) || 0, v = document.body ? document.body.clientWidth : 0, y = window.innerWidth - v + h || 0;
        Object.keys(FD).forEach(function(w) {
          var x = FD[w];
          m && (m[w] = x);
        }), m && (m.paddingRight = "".concat(y, "px"));
      }
      p && HD() && (p.addEventListener("touchmove", BD, Km), d && (d.addEventListener("touchstart", VD, Km), d.addEventListener("touchmove", UD, Km))), uw += 1;
    }
  }, [r]), c = M.useCallback(function(d) {
    if (qD) {
      var p = document.body, m = p && p.style;
      uw = Math.max(uw - 1, 0), r && uw < 1 && zD.forEach(function(h) {
        var v = a.current[h];
        m && (m[h] = v);
      }), p && HD() && (p.removeEventListener("touchmove", BD, Km), d && (d.removeEventListener("touchstart", VD, Km), d.removeEventListener("touchmove", UD, Km)));
    }
  }, [r]);
  return M.useEffect(function() {
    if (t) {
      var d = s.current;
      return l(d), function() {
        c(d);
      };
    }
  }, [t, l, c]), function(d) {
    s.current = d;
  };
}
var pue = function(e) {
  var t = e.target;
  return t.ownerDocument.activeElement && t.ownerDocument.activeElement.blur();
}, mue = {
  name: "1kfdb0e",
  styles: "position:fixed;left:0;bottom:0;right:0;top:0"
};
function hue(e) {
  var t = e.children, n = e.lockEnabled, r = e.captureEnabled, a = r === void 0 ? !0 : r, s = e.onBottomArrive, l = e.onBottomLeave, c = e.onTopArrive, d = e.onTopLeave, p = due({
    isEnabled: a,
    onBottomArrive: s,
    onBottomLeave: l,
    onTopArrive: c,
    onTopLeave: d
  }), m = fue({
    isEnabled: n
  }), h = function(v) {
    p(v), m(v);
  };
  return ut(M.Fragment, null, n && ut("div", {
    onClick: pue,
    css: mue
  }), t(h));
}
var gue = {
  name: "1a0ro4n-requiredInput",
  styles: "label:requiredInput;opacity:0;pointer-events:none;position:absolute;bottom:0;left:0;right:0;width:100%"
}, vue = function(e) {
  var t = e.name, n = e.onFocus;
  return ut("input", {
    required: !0,
    name: t,
    tabIndex: -1,
    "aria-hidden": "true",
    onFocus: n,
    css: gue,
    value: "",
    onChange: function() {
    }
  });
}, yue = vue;
function UR(e) {
  var t;
  return typeof window < "u" && window.navigator != null ? e.test(((t = window.navigator.userAgentData) === null || t === void 0 ? void 0 : t.platform) || window.navigator.platform) : !1;
}
function bue() {
  return UR(/^iPhone/i);
}
function s7() {
  return UR(/^Mac/i);
}
function wue() {
  return UR(/^iPad/i) || // iPadOS 13 lies and says it's a Mac, but we can distinguish by detecting touch support.
  s7() && navigator.maxTouchPoints > 1;
}
function xue() {
  return bue() || wue();
}
function Sue() {
  return s7() || xue();
}
var kue = function(e) {
  return e.label;
}, _ue = function(e) {
  return e.label;
}, Eue = function(e) {
  return e.value;
}, Cue = function(e) {
  return !!e.isDisabled;
}, Oue = {
  clearIndicator: ule,
  container: Jse,
  control: gle,
  dropdownIndicator: sle,
  group: wle,
  groupHeading: Sle,
  indicatorsContainer: nle,
  indicatorSeparator: dle,
  input: Cle,
  loadingIndicator: mle,
  loadingMessage: Gse,
  menu: Fse,
  menuList: Hse,
  menuPortal: Yse,
  multiValue: Ale,
  multiValueLabel: jle,
  multiValueRemove: Ple,
  noOptionsMessage: Wse,
  option: zle,
  placeholder: Ule,
  singleValue: qle,
  valueContainer: ele
}, Mue = {
  primary: "#2684FF",
  primary75: "#4C9AFF",
  primary50: "#B2D4FF",
  primary25: "#DEEBFF",
  danger: "#DE350B",
  dangerLight: "#FFBDAD",
  neutral0: "hsl(0, 0%, 100%)",
  neutral5: "hsl(0, 0%, 95%)",
  neutral10: "hsl(0, 0%, 90%)",
  neutral20: "hsl(0, 0%, 80%)",
  neutral30: "hsl(0, 0%, 70%)",
  neutral40: "hsl(0, 0%, 60%)",
  neutral50: "hsl(0, 0%, 50%)",
  neutral60: "hsl(0, 0%, 40%)",
  neutral70: "hsl(0, 0%, 30%)",
  neutral80: "hsl(0, 0%, 20%)",
  neutral90: "hsl(0, 0%, 10%)"
}, Nue = 4, l7 = 4, Rue = 38, Aue = l7 * 2, jue = {
  baseUnit: l7,
  controlHeight: Rue,
  menuGutter: Aue
}, SM = {
  borderRadius: Nue,
  colors: Mue,
  spacing: jue
}, Pue = {
  "aria-live": "polite",
  backspaceRemovesValue: !0,
  blurInputOnSelect: DD(),
  captureMenuScroll: !DD(),
  classNames: {},
  closeMenuOnSelect: !0,
  closeMenuOnScroll: !1,
  components: {},
  controlShouldRenderValue: !0,
  escapeClearsValue: !1,
  filterOption: sue(),
  formatGroupLabel: kue,
  getOptionLabel: _ue,
  getOptionValue: Eue,
  isDisabled: !1,
  isLoading: !1,
  isMulti: !1,
  isRtl: !1,
  isSearchable: !0,
  isOptionDisabled: Cue,
  loadingMessage: function() {
    return "Loading...";
  },
  maxMenuHeight: 300,
  minMenuHeight: 140,
  menuIsOpen: !1,
  menuPlacement: "bottom",
  menuPosition: "absolute",
  menuShouldBlockScroll: !1,
  menuShouldScrollIntoView: !Rse(),
  noOptionsMessage: function() {
    return "No options";
  },
  openMenuOnFocus: !1,
  openMenuOnClick: !0,
  options: [],
  pageSize: 5,
  placeholder: "Select...",
  screenReaderStatus: function(e) {
    var t = e.count;
    return "".concat(t, " result").concat(t !== 1 ? "s" : "", " available");
  },
  styles: {},
  tabIndex: 0,
  tabSelectsValue: !0,
  unstyled: !1
};
function WD(e, t, n, r) {
  var a = d7(e, t, n), s = f7(e, t, n), l = c7(e, t), c = d_(e, t);
  return {
    type: "option",
    data: t,
    isDisabled: a,
    isSelected: s,
    label: l,
    value: c,
    index: r
  };
}
function O0(e, t) {
  return e.options.map(function(n, r) {
    if ("options" in n) {
      var a = n.options.map(function(l, c) {
        return WD(e, l, t, c);
      }).filter(function(l) {
        return KD(e, l);
      });
      return a.length > 0 ? {
        type: "group",
        data: n,
        options: a,
        index: r
      } : void 0;
    }
    var s = WD(e, n, t, r);
    return KD(e, s) ? s : void 0;
  }).filter(Pse);
}
function u7(e) {
  return e.reduce(function(t, n) {
    return n.type === "group" ? t.push.apply(t, FR(n.options.map(function(r) {
      return r.data;
    }))) : t.push(n.data), t;
  }, []);
}
function GD(e, t) {
  return e.reduce(function(n, r) {
    return r.type === "group" ? n.push.apply(n, FR(r.options.map(function(a) {
      return {
        data: a.data,
        id: "".concat(t, "-").concat(r.index, "-").concat(a.index)
      };
    }))) : n.push({
      data: r.data,
      id: "".concat(t, "-").concat(r.index)
    }), n;
  }, []);
}
function Due(e, t) {
  return u7(O0(e, t));
}
function KD(e, t) {
  var n = e.inputValue, r = n === void 0 ? "" : n, a = t.data, s = t.isSelected, l = t.label, c = t.value;
  return (!m7(e) || !s) && p7(e, {
    label: l,
    value: c,
    data: a
  }, r);
}
function $ue(e, t) {
  var n = e.focusedValue, r = e.selectValue, a = r.indexOf(n);
  if (a > -1) {
    var s = t.indexOf(n);
    if (s > -1)
      return n;
    if (a < t.length)
      return t[a];
  }
  return null;
}
function Tue(e, t) {
  var n = e.focusedOption;
  return n && t.indexOf(n) > -1 ? n : t[0];
}
var kM = function(e, t) {
  var n, r = (n = e.find(function(a) {
    return a.data === t;
  })) === null || n === void 0 ? void 0 : n.id;
  return r || null;
}, c7 = function(e, t) {
  return e.getOptionLabel(t);
}, d_ = function(e, t) {
  return e.getOptionValue(t);
};
function d7(e, t, n) {
  return typeof e.isOptionDisabled == "function" ? e.isOptionDisabled(t, n) : !1;
}
function f7(e, t, n) {
  if (n.indexOf(t) > -1) return !0;
  if (typeof e.isOptionSelected == "function")
    return e.isOptionSelected(t, n);
  var r = d_(e, t);
  return n.some(function(a) {
    return d_(e, a) === r;
  });
}
function p7(e, t, n) {
  return e.filterOption ? e.filterOption(t, n) : !0;
}
var m7 = function(e) {
  var t = e.hideSelectedOptions, n = e.isMulti;
  return t === void 0 ? n : t;
}, Lue = 1, h7 = /* @__PURE__ */ (function(e) {
  gse(n, e);
  var t = yse(n);
  function n(r) {
    var a;
    if (mse(this, n), a = t.call(this, r), a.state = {
      ariaSelection: null,
      focusedOption: null,
      focusedOptionId: null,
      focusableOptionsWithIds: [],
      focusedValue: null,
      inputIsHidden: !1,
      isFocused: !1,
      selectValue: [],
      clearFocusValueOnUpdate: !1,
      prevWasFocused: !1,
      inputIsHiddenAfterUpdate: void 0,
      prevProps: void 0,
      instancePrefix: "",
      isAppleDevice: !1
    }, a.blockOptionHover = !1, a.isComposing = !1, a.commonProps = void 0, a.initialTouchX = 0, a.initialTouchY = 0, a.openAfterFocus = !1, a.scrollToFocusedOptionOnUpdate = !1, a.userIsDragging = void 0, a.controlRef = null, a.getControlRef = function(d) {
      a.controlRef = d;
    }, a.focusedOptionRef = null, a.getFocusedOptionRef = function(d) {
      a.focusedOptionRef = d;
    }, a.menuListRef = null, a.getMenuListRef = function(d) {
      a.menuListRef = d;
    }, a.inputRef = null, a.getInputRef = function(d) {
      a.inputRef = d;
    }, a.focus = a.focusInput, a.blur = a.blurInput, a.onChange = function(d, p) {
      var m = a.props, h = m.onChange, v = m.name;
      p.name = v, a.ariaOnChange(d, p), h(d, p);
    }, a.setValue = function(d, p, m) {
      var h = a.props, v = h.closeMenuOnSelect, y = h.isMulti, w = h.inputValue;
      a.onInputChange("", {
        action: "set-value",
        prevInputValue: w
      }), v && (a.setState({
        inputIsHiddenAfterUpdate: !y
      }), a.onMenuClose()), a.setState({
        clearFocusValueOnUpdate: !0
      }), a.onChange(d, {
        action: p,
        option: m
      });
    }, a.selectOption = function(d) {
      var p = a.props, m = p.blurInputOnSelect, h = p.isMulti, v = p.name, y = a.state.selectValue, w = h && a.isOptionSelected(d, y), x = a.isOptionDisabled(d, y);
      if (w) {
        var b = a.getOptionValue(d);
        a.setValue(y.filter(function(k) {
          return a.getOptionValue(k) !== b;
        }), "deselect-option", d);
      } else if (!x)
        h ? a.setValue([].concat(FR(y), [d]), "select-option", d) : a.setValue(d, "select-option");
      else {
        a.ariaOnChange(d, {
          action: "select-option",
          option: d,
          name: v
        });
        return;
      }
      m && a.blurInput();
    }, a.removeValue = function(d) {
      var p = a.props.isMulti, m = a.state.selectValue, h = a.getOptionValue(d), v = m.filter(function(w) {
        return a.getOptionValue(w) !== h;
      }), y = tk(p, v, v[0] || null);
      a.onChange(y, {
        action: "remove-value",
        removedValue: d
      }), a.focusInput();
    }, a.clearValue = function() {
      var d = a.state.selectValue;
      a.onChange(tk(a.props.isMulti, [], null), {
        action: "clear",
        removedValues: d
      });
    }, a.popValue = function() {
      var d = a.props.isMulti, p = a.state.selectValue, m = p[p.length - 1], h = p.slice(0, p.length - 1), v = tk(d, h, h[0] || null);
      m && a.onChange(v, {
        action: "pop-value",
        removedValue: m
      });
    }, a.getFocusedOptionId = function(d) {
      return kM(a.state.focusableOptionsWithIds, d);
    }, a.getFocusableOptionsWithIds = function() {
      return GD(O0(a.props, a.state.selectValue), a.getElementId("option"));
    }, a.getValue = function() {
      return a.state.selectValue;
    }, a.cx = function() {
      for (var d = arguments.length, p = new Array(d), m = 0; m < d; m++)
        p[m] = arguments[m];
      return Ese.apply(void 0, [a.props.classNamePrefix].concat(p));
    }, a.getOptionLabel = function(d) {
      return c7(a.props, d);
    }, a.getOptionValue = function(d) {
      return d_(a.props, d);
    }, a.getStyles = function(d, p) {
      var m = a.props.unstyled, h = Oue[d](p, m);
      h.boxSizing = "border-box";
      var v = a.props.styles[d];
      return v ? v(h, p) : h;
    }, a.getClassNames = function(d, p) {
      var m, h;
      return (m = (h = a.props.classNames)[d]) === null || m === void 0 ? void 0 : m.call(h, p);
    }, a.getElementId = function(d) {
      return "".concat(a.state.instancePrefix, "-").concat(d);
    }, a.getComponents = function() {
      return Xle(a.props);
    }, a.buildCategorizedOptions = function() {
      return O0(a.props, a.state.selectValue);
    }, a.getCategorizedOptions = function() {
      return a.props.menuIsOpen ? a.buildCategorizedOptions() : [];
    }, a.buildFocusableOptions = function() {
      return u7(a.buildCategorizedOptions());
    }, a.getFocusableOptions = function() {
      return a.props.menuIsOpen ? a.buildFocusableOptions() : [];
    }, a.ariaOnChange = function(d, p) {
      a.setState({
        ariaSelection: pt({
          value: d
        }, p)
      });
    }, a.onMenuMouseDown = function(d) {
      d.button === 0 && (d.stopPropagation(), d.preventDefault(), a.focusInput());
    }, a.onMenuMouseMove = function(d) {
      a.blockOptionHover = !1;
    }, a.onControlMouseDown = function(d) {
      if (!d.defaultPrevented) {
        var p = a.props.openMenuOnClick;
        a.state.isFocused ? a.props.menuIsOpen ? d.target.tagName !== "INPUT" && d.target.tagName !== "TEXTAREA" && a.onMenuClose() : p && a.openMenu("first") : (p && (a.openAfterFocus = !0), a.focusInput()), d.target.tagName !== "INPUT" && d.target.tagName !== "TEXTAREA" && d.preventDefault();
      }
    }, a.onDropdownIndicatorMouseDown = function(d) {
      if (!(d && d.type === "mousedown" && d.button !== 0) && !a.props.isDisabled) {
        var p = a.props, m = p.isMulti, h = p.menuIsOpen;
        a.focusInput(), h ? (a.setState({
          inputIsHiddenAfterUpdate: !m
        }), a.onMenuClose()) : a.openMenu("first"), d.preventDefault();
      }
    }, a.onClearIndicatorMouseDown = function(d) {
      d && d.type === "mousedown" && d.button !== 0 || (a.clearValue(), d.preventDefault(), a.openAfterFocus = !1, d.type === "touchend" ? a.focusInput() : setTimeout(function() {
        return a.focusInput();
      }));
    }, a.onScroll = function(d) {
      typeof a.props.closeMenuOnScroll == "boolean" ? d.target instanceof HTMLElement && R2(d.target) && a.props.onMenuClose() : typeof a.props.closeMenuOnScroll == "function" && a.props.closeMenuOnScroll(d) && a.props.onMenuClose();
    }, a.onCompositionStart = function() {
      a.isComposing = !0;
    }, a.onCompositionEnd = function() {
      a.isComposing = !1;
    }, a.onTouchStart = function(d) {
      var p = d.touches, m = p && p.item(0);
      m && (a.initialTouchX = m.clientX, a.initialTouchY = m.clientY, a.userIsDragging = !1);
    }, a.onTouchMove = function(d) {
      var p = d.touches, m = p && p.item(0);
      if (m) {
        var h = Math.abs(m.clientX - a.initialTouchX), v = Math.abs(m.clientY - a.initialTouchY), y = 5;
        a.userIsDragging = h > y || v > y;
      }
    }, a.onTouchEnd = function(d) {
      a.userIsDragging || (a.controlRef && !a.controlRef.contains(d.target) && a.menuListRef && !a.menuListRef.contains(d.target) && a.blurInput(), a.initialTouchX = 0, a.initialTouchY = 0);
    }, a.onControlTouchEnd = function(d) {
      a.userIsDragging || a.onControlMouseDown(d);
    }, a.onClearIndicatorTouchEnd = function(d) {
      a.userIsDragging || a.onClearIndicatorMouseDown(d);
    }, a.onDropdownIndicatorTouchEnd = function(d) {
      a.userIsDragging || a.onDropdownIndicatorMouseDown(d);
    }, a.handleInputChange = function(d) {
      var p = a.props.inputValue, m = d.currentTarget.value;
      a.setState({
        inputIsHiddenAfterUpdate: !1
      }), a.onInputChange(m, {
        action: "input-change",
        prevInputValue: p
      }), a.props.menuIsOpen || a.onMenuOpen();
    }, a.onInputFocus = function(d) {
      a.props.onFocus && a.props.onFocus(d), a.setState({
        inputIsHiddenAfterUpdate: !1,
        isFocused: !0
      }), (a.openAfterFocus || a.props.openMenuOnFocus) && a.openMenu("first"), a.openAfterFocus = !1;
    }, a.onInputBlur = function(d) {
      var p = a.props.inputValue;
      if (a.menuListRef && a.menuListRef.contains(document.activeElement)) {
        a.inputRef.focus();
        return;
      }
      a.props.onBlur && a.props.onBlur(d), a.onInputChange("", {
        action: "input-blur",
        prevInputValue: p
      }), a.onMenuClose(), a.setState({
        focusedValue: null,
        isFocused: !1
      });
    }, a.onOptionHover = function(d) {
      if (!(a.blockOptionHover || a.state.focusedOption === d)) {
        var p = a.getFocusableOptions(), m = p.indexOf(d);
        a.setState({
          focusedOption: d,
          focusedOptionId: m > -1 ? a.getFocusedOptionId(d) : null
        });
      }
    }, a.shouldHideSelectedOptions = function() {
      return m7(a.props);
    }, a.onValueInputFocus = function(d) {
      d.preventDefault(), d.stopPropagation(), a.focus();
    }, a.onKeyDown = function(d) {
      var p = a.props, m = p.isMulti, h = p.backspaceRemovesValue, v = p.escapeClearsValue, y = p.inputValue, w = p.isClearable, x = p.isDisabled, b = p.menuIsOpen, k = p.onKeyDown, C = p.tabSelectsValue, _ = p.openMenuOnFocus, O = a.state, N = O.focusedOption, R = O.focusedValue, j = O.selectValue;
      if (!x && !(typeof k == "function" && (k(d), d.defaultPrevented))) {
        switch (a.blockOptionHover = !0, d.key) {
          case "ArrowLeft":
            if (!m || y) return;
            a.focusValue("previous");
            break;
          case "ArrowRight":
            if (!m || y) return;
            a.focusValue("next");
            break;
          case "Delete":
          case "Backspace":
            if (y) return;
            if (R)
              a.removeValue(R);
            else {
              if (!h) return;
              m ? a.popValue() : w && a.clearValue();
            }
            break;
          case "Tab":
            if (a.isComposing || d.shiftKey || !b || !C || !N || // don't capture the event if the menu opens on focus and the focused
            // option is already selected; it breaks the flow of navigation
            _ && a.isOptionSelected(N, j))
              return;
            a.selectOption(N);
            break;
          case "Enter":
            if (d.keyCode === 229)
              break;
            if (b) {
              if (!N || a.isComposing) return;
              a.selectOption(N);
              break;
            }
            return;
          case "Escape":
            b ? (a.setState({
              inputIsHiddenAfterUpdate: !1
            }), a.onInputChange("", {
              action: "menu-close",
              prevInputValue: y
            }), a.onMenuClose()) : w && v && a.clearValue();
            break;
          case " ":
            if (y)
              return;
            if (!b) {
              a.openMenu("first");
              break;
            }
            if (!N) return;
            a.selectOption(N);
            break;
          case "ArrowUp":
            b ? a.focusOption("up") : a.openMenu("last");
            break;
          case "ArrowDown":
            b ? a.focusOption("down") : a.openMenu("first");
            break;
          case "PageUp":
            if (!b) return;
            a.focusOption("pageup");
            break;
          case "PageDown":
            if (!b) return;
            a.focusOption("pagedown");
            break;
          case "Home":
            if (!b) return;
            a.focusOption("first");
            break;
          case "End":
            if (!b) return;
            a.focusOption("last");
            break;
          default:
            return;
        }
        d.preventDefault();
      }
    }, a.state.instancePrefix = "react-select-" + (a.props.instanceId || ++Lue), a.state.selectValue = jD(r.value), r.menuIsOpen && a.state.selectValue.length) {
      var s = a.getFocusableOptionsWithIds(), l = a.buildFocusableOptions(), c = l.indexOf(a.state.selectValue[0]);
      a.state.focusableOptionsWithIds = s, a.state.focusedOption = l[c], a.state.focusedOptionId = kM(s, l[c]);
    }
    return a;
  }
  return hse(n, [{
    key: "componentDidMount",
    value: function() {
      this.startListeningComposition(), this.startListeningToTouch(), this.props.closeMenuOnScroll && document && document.addEventListener && document.addEventListener("scroll", this.onScroll, !0), this.props.autoFocus && this.focusInput(), this.props.menuIsOpen && this.state.focusedOption && this.menuListRef && this.focusedOptionRef && PD(this.menuListRef, this.focusedOptionRef), Sue() && this.setState({
        isAppleDevice: !0
      });
    }
  }, {
    key: "componentDidUpdate",
    value: function(r) {
      var a = this.props, s = a.isDisabled, l = a.menuIsOpen, c = this.state.isFocused;
      (c && !s && r.isDisabled || // ensure focus is on the Input when the menu opens
      c && l && !r.menuIsOpen) && this.focusInput(), c && s && !r.isDisabled ? this.setState({
        isFocused: !1
      }, this.onMenuClose) : !c && !s && r.isDisabled && this.inputRef === document.activeElement && this.setState({
        isFocused: !0
      }), this.menuListRef && this.focusedOptionRef && this.scrollToFocusedOptionOnUpdate && (PD(this.menuListRef, this.focusedOptionRef), this.scrollToFocusedOptionOnUpdate = !1);
    }
  }, {
    key: "componentWillUnmount",
    value: function() {
      this.stopListeningComposition(), this.stopListeningToTouch(), document.removeEventListener("scroll", this.onScroll, !0);
    }
    // ==============================
    // Consumer Handlers
    // ==============================
  }, {
    key: "onMenuOpen",
    value: function() {
      this.props.onMenuOpen();
    }
  }, {
    key: "onMenuClose",
    value: function() {
      this.onInputChange("", {
        action: "menu-close",
        prevInputValue: this.props.inputValue
      }), this.props.onMenuClose();
    }
  }, {
    key: "onInputChange",
    value: function(r, a) {
      this.props.onInputChange(r, a);
    }
    // ==============================
    // Methods
    // ==============================
  }, {
    key: "focusInput",
    value: function() {
      this.inputRef && this.inputRef.focus();
    }
  }, {
    key: "blurInput",
    value: function() {
      this.inputRef && this.inputRef.blur();
    }
    // aliased for consumers
  }, {
    key: "openMenu",
    value: function(r) {
      var a = this, s = this.state, l = s.selectValue, c = s.isFocused, d = this.buildFocusableOptions(), p = r === "first" ? 0 : d.length - 1;
      if (!this.props.isMulti) {
        var m = d.indexOf(l[0]);
        m > -1 && (p = m);
      }
      this.scrollToFocusedOptionOnUpdate = !(c && this.menuListRef), this.setState({
        inputIsHiddenAfterUpdate: !1,
        focusedValue: null,
        focusedOption: d[p],
        focusedOptionId: this.getFocusedOptionId(d[p])
      }, function() {
        return a.onMenuOpen();
      });
    }
  }, {
    key: "focusValue",
    value: function(r) {
      var a = this.state, s = a.selectValue, l = a.focusedValue;
      if (this.props.isMulti) {
        this.setState({
          focusedOption: null
        });
        var c = s.indexOf(l);
        l || (c = -1);
        var d = s.length - 1, p = -1;
        if (s.length) {
          switch (r) {
            case "previous":
              c === 0 ? p = 0 : c === -1 ? p = d : p = c - 1;
              break;
            case "next":
              c > -1 && c < d && (p = c + 1);
              break;
          }
          this.setState({
            inputIsHidden: p !== -1,
            focusedValue: s[p]
          });
        }
      }
    }
  }, {
    key: "focusOption",
    value: function() {
      var r = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "first", a = this.props.pageSize, s = this.state.focusedOption, l = this.getFocusableOptions();
      if (l.length) {
        var c = 0, d = l.indexOf(s);
        s || (d = -1), r === "up" ? c = d > 0 ? d - 1 : l.length - 1 : r === "down" ? c = (d + 1) % l.length : r === "pageup" ? (c = d - a, c < 0 && (c = 0)) : r === "pagedown" ? (c = d + a, c > l.length - 1 && (c = l.length - 1)) : r === "last" && (c = l.length - 1), this.scrollToFocusedOptionOnUpdate = !0, this.setState({
          focusedOption: l[c],
          focusedValue: null,
          focusedOptionId: this.getFocusedOptionId(l[c])
        });
      }
    }
  }, {
    key: "getTheme",
    value: (
      // ==============================
      // Getters
      // ==============================
      (function() {
        return this.props.theme ? typeof this.props.theme == "function" ? this.props.theme(SM) : pt(pt({}, SM), this.props.theme) : SM;
      })
    )
  }, {
    key: "getCommonProps",
    value: function() {
      var r = this.clearValue, a = this.cx, s = this.getStyles, l = this.getClassNames, c = this.getValue, d = this.selectOption, p = this.setValue, m = this.props, h = m.isMulti, v = m.isRtl, y = m.options, w = this.hasValue();
      return {
        clearValue: r,
        cx: a,
        getStyles: s,
        getClassNames: l,
        getValue: c,
        hasValue: w,
        isMulti: h,
        isRtl: v,
        options: y,
        selectOption: d,
        selectProps: m,
        setValue: p,
        theme: this.getTheme()
      };
    }
  }, {
    key: "hasValue",
    value: function() {
      var r = this.state.selectValue;
      return r.length > 0;
    }
  }, {
    key: "hasOptions",
    value: function() {
      return !!this.getFocusableOptions().length;
    }
  }, {
    key: "isClearable",
    value: function() {
      var r = this.props, a = r.isClearable, s = r.isMulti;
      return a === void 0 ? s : a;
    }
  }, {
    key: "isOptionDisabled",
    value: function(r, a) {
      return d7(this.props, r, a);
    }
  }, {
    key: "isOptionSelected",
    value: function(r, a) {
      return f7(this.props, r, a);
    }
  }, {
    key: "filterOption",
    value: function(r, a) {
      return p7(this.props, r, a);
    }
  }, {
    key: "formatOptionLabel",
    value: function(r, a) {
      if (typeof this.props.formatOptionLabel == "function") {
        var s = this.props.inputValue, l = this.state.selectValue;
        return this.props.formatOptionLabel(r, {
          context: a,
          inputValue: s,
          selectValue: l
        });
      } else
        return this.getOptionLabel(r);
    }
  }, {
    key: "formatGroupLabel",
    value: function(r) {
      return this.props.formatGroupLabel(r);
    }
    // ==============================
    // Mouse Handlers
    // ==============================
  }, {
    key: "startListeningComposition",
    value: (
      // ==============================
      // Composition Handlers
      // ==============================
      (function() {
        document && document.addEventListener && (document.addEventListener("compositionstart", this.onCompositionStart, !1), document.addEventListener("compositionend", this.onCompositionEnd, !1));
      })
    )
  }, {
    key: "stopListeningComposition",
    value: function() {
      document && document.removeEventListener && (document.removeEventListener("compositionstart", this.onCompositionStart), document.removeEventListener("compositionend", this.onCompositionEnd));
    }
  }, {
    key: "startListeningToTouch",
    value: (
      // ==============================
      // Touch Handlers
      // ==============================
      (function() {
        document && document.addEventListener && (document.addEventListener("touchstart", this.onTouchStart, !1), document.addEventListener("touchmove", this.onTouchMove, !1), document.addEventListener("touchend", this.onTouchEnd, !1));
      })
    )
  }, {
    key: "stopListeningToTouch",
    value: function() {
      document && document.removeEventListener && (document.removeEventListener("touchstart", this.onTouchStart), document.removeEventListener("touchmove", this.onTouchMove), document.removeEventListener("touchend", this.onTouchEnd));
    }
  }, {
    key: "renderInput",
    value: (
      // ==============================
      // Renderers
      // ==============================
      (function() {
        var r = this.props, a = r.isDisabled, s = r.isSearchable, l = r.inputId, c = r.inputValue, d = r.tabIndex, p = r.form, m = r.menuIsOpen, h = r.required, v = this.getComponents(), y = v.Input, w = this.state, x = w.inputIsHidden, b = w.ariaSelection, k = this.commonProps, C = l || this.getElementId("input"), _ = pt(pt(pt({
          "aria-autocomplete": "list",
          "aria-expanded": m,
          "aria-haspopup": !0,
          "aria-errormessage": this.props["aria-errormessage"],
          "aria-invalid": this.props["aria-invalid"],
          "aria-label": this.props["aria-label"],
          "aria-labelledby": this.props["aria-labelledby"],
          "aria-required": h,
          role: "combobox",
          "aria-activedescendant": this.state.isAppleDevice ? void 0 : this.state.focusedOptionId || ""
        }, m && {
          "aria-controls": this.getElementId("listbox")
        }), !s && {
          "aria-readonly": !0
        }), this.hasValue() ? b?.action === "initial-input-focus" && {
          "aria-describedby": this.getElementId("live-region")
        } : {
          "aria-describedby": this.getElementId("placeholder")
        });
        return s ? /* @__PURE__ */ M.createElement(y, ft({}, k, {
          autoCapitalize: "none",
          autoComplete: "off",
          autoCorrect: "off",
          id: C,
          innerRef: this.getInputRef,
          isDisabled: a,
          isHidden: x,
          onBlur: this.onInputBlur,
          onChange: this.handleInputChange,
          onFocus: this.onInputFocus,
          spellCheck: "false",
          tabIndex: d,
          form: p,
          type: "text",
          value: c
        }, _)) : /* @__PURE__ */ M.createElement(uue, ft({
          id: C,
          innerRef: this.getInputRef,
          onBlur: this.onInputBlur,
          onChange: u_,
          onFocus: this.onInputFocus,
          disabled: a,
          tabIndex: d,
          inputMode: "none",
          form: p,
          value: ""
        }, _));
      })
    )
  }, {
    key: "renderPlaceholderOrValue",
    value: function() {
      var r = this, a = this.getComponents(), s = a.MultiValue, l = a.MultiValueContainer, c = a.MultiValueLabel, d = a.MultiValueRemove, p = a.SingleValue, m = a.Placeholder, h = this.commonProps, v = this.props, y = v.controlShouldRenderValue, w = v.isDisabled, x = v.isMulti, b = v.inputValue, k = v.placeholder, C = this.state, _ = C.selectValue, O = C.focusedValue, N = C.isFocused;
      if (!this.hasValue() || !y)
        return b ? null : /* @__PURE__ */ M.createElement(m, ft({}, h, {
          key: "placeholder",
          isDisabled: w,
          isFocused: N,
          innerProps: {
            id: this.getElementId("placeholder")
          }
        }), k);
      if (x)
        return _.map(function(j, D) {
          var $ = j === O, z = "".concat(r.getOptionLabel(j), "-").concat(r.getOptionValue(j));
          return /* @__PURE__ */ M.createElement(s, ft({}, h, {
            components: {
              Container: l,
              Label: c,
              Remove: d
            },
            isFocused: $,
            isDisabled: w,
            key: z,
            index: D,
            removeProps: {
              onClick: function() {
                return r.removeValue(j);
              },
              onTouchEnd: function() {
                return r.removeValue(j);
              },
              onMouseDown: function(B) {
                B.preventDefault();
              }
            },
            data: j
          }), r.formatOptionLabel(j, "value"));
        });
      if (b)
        return null;
      var R = _[0];
      return /* @__PURE__ */ M.createElement(p, ft({}, h, {
        data: R,
        isDisabled: w
      }), this.formatOptionLabel(R, "value"));
    }
  }, {
    key: "renderClearIndicator",
    value: function() {
      var r = this.getComponents(), a = r.ClearIndicator, s = this.commonProps, l = this.props, c = l.isDisabled, d = l.isLoading, p = this.state.isFocused;
      if (!this.isClearable() || !a || c || !this.hasValue() || d)
        return null;
      var m = {
        onMouseDown: this.onClearIndicatorMouseDown,
        onTouchEnd: this.onClearIndicatorTouchEnd,
        "aria-hidden": "true"
      };
      return /* @__PURE__ */ M.createElement(a, ft({}, s, {
        innerProps: m,
        isFocused: p
      }));
    }
  }, {
    key: "renderLoadingIndicator",
    value: function() {
      var r = this.getComponents(), a = r.LoadingIndicator, s = this.commonProps, l = this.props, c = l.isDisabled, d = l.isLoading, p = this.state.isFocused;
      if (!a || !d) return null;
      var m = {
        "aria-hidden": "true"
      };
      return /* @__PURE__ */ M.createElement(a, ft({}, s, {
        innerProps: m,
        isDisabled: c,
        isFocused: p
      }));
    }
  }, {
    key: "renderIndicatorSeparator",
    value: function() {
      var r = this.getComponents(), a = r.DropdownIndicator, s = r.IndicatorSeparator;
      if (!a || !s) return null;
      var l = this.commonProps, c = this.props.isDisabled, d = this.state.isFocused;
      return /* @__PURE__ */ M.createElement(s, ft({}, l, {
        isDisabled: c,
        isFocused: d
      }));
    }
  }, {
    key: "renderDropdownIndicator",
    value: function() {
      var r = this.getComponents(), a = r.DropdownIndicator;
      if (!a) return null;
      var s = this.commonProps, l = this.props.isDisabled, c = this.state.isFocused, d = {
        onMouseDown: this.onDropdownIndicatorMouseDown,
        onTouchEnd: this.onDropdownIndicatorTouchEnd,
        "aria-hidden": "true"
      };
      return /* @__PURE__ */ M.createElement(a, ft({}, s, {
        innerProps: d,
        isDisabled: l,
        isFocused: c
      }));
    }
  }, {
    key: "renderMenu",
    value: function() {
      var r = this, a = this.getComponents(), s = a.Group, l = a.GroupHeading, c = a.Menu, d = a.MenuList, p = a.MenuPortal, m = a.LoadingMessage, h = a.NoOptionsMessage, v = a.Option, y = this.commonProps, w = this.state.focusedOption, x = this.props, b = x.captureMenuScroll, k = x.inputValue, C = x.isLoading, _ = x.loadingMessage, O = x.minMenuHeight, N = x.maxMenuHeight, R = x.menuIsOpen, j = x.menuPlacement, D = x.menuPosition, $ = x.menuPortalTarget, z = x.menuShouldBlockScroll, B = x.menuShouldScrollIntoView, P = x.noOptionsMessage, W = x.onMenuScrollToTop, I = x.onMenuScrollToBottom;
      if (!R) return null;
      var G = function(F, X) {
        var U = F.type, H = F.data, Q = F.isDisabled, re = F.isSelected, de = F.label, le = F.value, me = w === H, ve = Q ? void 0 : function() {
          return r.onOptionHover(H);
        }, ae = Q ? void 0 : function() {
          return r.selectOption(H);
        }, se = "".concat(r.getElementId("option"), "-").concat(X), pe = {
          id: se,
          onClick: ae,
          onMouseMove: ve,
          onMouseOver: ve,
          tabIndex: -1,
          role: "option",
          "aria-selected": r.state.isAppleDevice ? void 0 : re
          // is not supported on Apple devices
        };
        return /* @__PURE__ */ M.createElement(v, ft({}, y, {
          innerProps: pe,
          data: H,
          isDisabled: Q,
          isSelected: re,
          key: se,
          label: de,
          type: U,
          value: le,
          isFocused: me,
          innerRef: me ? r.getFocusedOptionRef : void 0
        }), r.formatOptionLabel(F.data, "menu"));
      }, L;
      if (this.hasOptions())
        L = this.getCategorizedOptions().map(function(F) {
          if (F.type === "group") {
            var X = F.data, U = F.options, H = F.index, Q = "".concat(r.getElementId("group"), "-").concat(H), re = "".concat(Q, "-heading");
            return /* @__PURE__ */ M.createElement(s, ft({}, y, {
              key: Q,
              data: X,
              options: U,
              Heading: l,
              headingProps: {
                id: re,
                data: F.data
              },
              label: r.formatGroupLabel(F.data)
            }), F.options.map(function(de) {
              return G(de, "".concat(H, "-").concat(de.index));
            }));
          } else if (F.type === "option")
            return G(F, "".concat(F.index));
        });
      else if (C) {
        var K = _({
          inputValue: k
        });
        if (K === null) return null;
        L = /* @__PURE__ */ M.createElement(m, y, K);
      } else {
        var q = P({
          inputValue: k
        });
        if (q === null) return null;
        L = /* @__PURE__ */ M.createElement(h, y, q);
      }
      var Z = {
        minMenuHeight: O,
        maxMenuHeight: N,
        menuPlacement: j,
        menuPosition: D,
        menuShouldScrollIntoView: B
      }, V = /* @__PURE__ */ M.createElement(Bse, ft({}, y, Z), function(F) {
        var X = F.ref, U = F.placerProps, H = U.placement, Q = U.maxHeight;
        return /* @__PURE__ */ M.createElement(c, ft({}, y, Z, {
          innerRef: X,
          innerProps: {
            onMouseDown: r.onMenuMouseDown,
            onMouseMove: r.onMenuMouseMove
          },
          isLoading: C,
          placement: H
        }), /* @__PURE__ */ M.createElement(hue, {
          captureEnabled: b,
          onTopArrive: W,
          onBottomArrive: I,
          lockEnabled: z
        }, function(re) {
          return /* @__PURE__ */ M.createElement(d, ft({}, y, {
            innerRef: function(de) {
              r.getMenuListRef(de), re(de);
            },
            innerProps: {
              role: "listbox",
              "aria-multiselectable": y.isMulti,
              id: r.getElementId("listbox")
            },
            isLoading: C,
            maxHeight: Q,
            focusedOption: w
          }), L);
        }));
      });
      return $ || D === "fixed" ? /* @__PURE__ */ M.createElement(p, ft({}, y, {
        appendTo: $,
        controlElement: this.controlRef,
        menuPlacement: j,
        menuPosition: D
      }), V) : V;
    }
  }, {
    key: "renderFormField",
    value: function() {
      var r = this, a = this.props, s = a.delimiter, l = a.isDisabled, c = a.isMulti, d = a.name, p = a.required, m = this.state.selectValue;
      if (p && !this.hasValue() && !l)
        return /* @__PURE__ */ M.createElement(yue, {
          name: d,
          onFocus: this.onValueInputFocus
        });
      if (!(!d || l))
        if (c)
          if (s) {
            var h = m.map(function(w) {
              return r.getOptionValue(w);
            }).join(s);
            return /* @__PURE__ */ M.createElement("input", {
              name: d,
              type: "hidden",
              value: h
            });
          } else {
            var v = m.length > 0 ? m.map(function(w, x) {
              return /* @__PURE__ */ M.createElement("input", {
                key: "i-".concat(x),
                name: d,
                type: "hidden",
                value: r.getOptionValue(w)
              });
            }) : /* @__PURE__ */ M.createElement("input", {
              name: d,
              type: "hidden",
              value: ""
            });
            return /* @__PURE__ */ M.createElement("div", null, v);
          }
        else {
          var y = m[0] ? this.getOptionValue(m[0]) : "";
          return /* @__PURE__ */ M.createElement("input", {
            name: d,
            type: "hidden",
            value: y
          });
        }
    }
  }, {
    key: "renderLiveRegion",
    value: function() {
      var r = this.commonProps, a = this.state, s = a.ariaSelection, l = a.focusedOption, c = a.focusedValue, d = a.isFocused, p = a.selectValue, m = this.getFocusableOptions();
      return /* @__PURE__ */ M.createElement(rue, ft({}, r, {
        id: this.getElementId("live-region"),
        ariaSelection: s,
        focusedOption: l,
        focusedValue: c,
        isFocused: d,
        selectValue: p,
        focusableOptions: m,
        isAppleDevice: this.state.isAppleDevice
      }));
    }
  }, {
    key: "render",
    value: function() {
      var r = this.getComponents(), a = r.Control, s = r.IndicatorsContainer, l = r.SelectContainer, c = r.ValueContainer, d = this.props, p = d.className, m = d.id, h = d.isDisabled, v = d.menuIsOpen, y = this.state.isFocused, w = this.commonProps = this.getCommonProps();
      return /* @__PURE__ */ M.createElement(l, ft({}, w, {
        className: p,
        innerProps: {
          id: m,
          onKeyDown: this.onKeyDown
        },
        isDisabled: h,
        isFocused: y
      }), this.renderLiveRegion(), /* @__PURE__ */ M.createElement(a, ft({}, w, {
        innerRef: this.getControlRef,
        innerProps: {
          onMouseDown: this.onControlMouseDown,
          onTouchEnd: this.onControlTouchEnd
        },
        isDisabled: h,
        isFocused: y,
        menuIsOpen: v
      }), /* @__PURE__ */ M.createElement(c, ft({}, w, {
        isDisabled: h
      }), this.renderPlaceholderOrValue(), this.renderInput()), /* @__PURE__ */ M.createElement(s, ft({}, w, {
        isDisabled: h
      }), this.renderClearIndicator(), this.renderLoadingIndicator(), this.renderIndicatorSeparator(), this.renderDropdownIndicator())), this.renderMenu(), this.renderFormField());
    }
  }], [{
    key: "getDerivedStateFromProps",
    value: function(r, a) {
      var s = a.prevProps, l = a.clearFocusValueOnUpdate, c = a.inputIsHiddenAfterUpdate, d = a.ariaSelection, p = a.isFocused, m = a.prevWasFocused, h = a.instancePrefix, v = r.options, y = r.value, w = r.menuIsOpen, x = r.inputValue, b = r.isMulti, k = jD(y), C = {};
      if (s && (y !== s.value || v !== s.options || w !== s.menuIsOpen || x !== s.inputValue)) {
        var _ = w ? Due(r, k) : [], O = w ? GD(O0(r, k), "".concat(h, "-option")) : [], N = l ? $ue(a, k) : null, R = Tue(a, _), j = kM(O, R);
        C = {
          selectValue: k,
          focusedOption: R,
          focusedOptionId: j,
          focusableOptionsWithIds: O,
          focusedValue: N,
          clearFocusValueOnUpdate: !1
        };
      }
      var D = c != null && r !== s ? {
        inputIsHidden: c,
        inputIsHiddenAfterUpdate: void 0
      } : {}, $ = d, z = p && m;
      return p && !z && ($ = {
        value: tk(b, k, k[0] || null),
        options: k,
        action: "initial-input-focus"
      }, z = !m), d?.action === "initial-input-focus" && ($ = null), pt(pt(pt({}, C), D), {}, {
        prevProps: r,
        ariaSelection: $,
        prevWasFocused: z
      });
    }
  }]), n;
})(M.Component);
h7.defaultProps = Pue;
var Iue = /* @__PURE__ */ M.forwardRef(function(e, t) {
  var n = pse(e);
  return /* @__PURE__ */ M.createElement(h7, ft({
    ref: t
  }, n));
}), zue = Iue;
const Fue = ({
  options: e,
  items_per_page: t,
  className: n,
  defaultValue: r,
  onChange: a
}) => {
  const [s, l] = M.useState(""), [c, d] = M.useState(0), p = (y) => {
    l(y.toLowerCase()), d(0);
  }, m = e.filter((y) => y.label.toLowerCase().includes(s) || y.value.toLowerCase().includes(s));
  var h;
  t !== void 0 ? h = m.slice(
    c * t,
    (c + 1) * t
  ) : h = m;
  const v = {
    control: (y) => ({
      ...y,
      minHeight: void 0
    })
  };
  return /* @__PURE__ */ E.jsx(
    zue,
    {
      options: h,
      onInputChange: p,
      onChange: a,
      inputValue: s,
      isSearchable: !0,
      placeholder: "Select an option...",
      className: n,
      unstyled: !0,
      styles: v,
      classNamePrefix: "styled-select",
      defaultValue: r,
      value: r
    }
  );
}, Bue = (e) => typeof e == "boolean" || e instanceof Boolean, Uue = (e) => typeof e == "number" || e instanceof Number, Vue = (e) => typeof e == "bigint" || e instanceof BigInt, g7 = (e) => !!e && e instanceof Date, Hue = (e) => typeof e == "string" || e instanceof String, que = (e) => Array.isArray(e), v7 = (e) => typeof e == "object" && e !== null, y7 = (e) => !!e && e instanceof Object && typeof e == "function";
function f_(e, t) {
  return t === void 0 && (t = !1), !e || t ? `"${e}"` : e;
}
function Wue(e, t, n) {
  return n ? JSON.stringify(e) : t ? `"${e}"` : e;
}
function b7(e) {
  let {
    field: t,
    value: n,
    data: r,
    lastElement: a,
    openBracket: s,
    closeBracket: l,
    level: c,
    style: d,
    shouldExpandNode: p,
    clickToExpandNode: m,
    outerRef: h,
    beforeExpandChange: v
  } = e;
  const y = M.useRef(!1), [w, x] = M.useState(() => p(c, n, t)), b = M.useRef(null);
  M.useEffect(() => {
    y.current ? x(p(c, n, t)) : y.current = !0;
  }, [p]);
  const k = M.useId();
  if (r.length === 0)
    return Gue({
      field: t,
      openBracket: s,
      closeBracket: l,
      lastElement: a,
      style: d
    });
  const C = w ? d.collapseIcon : d.expandIcon, _ = w ? d.ariaLables.collapseJson : d.ariaLables.expandJson, O = c + 1, N = r.length - 1, R = ($) => {
    w !== $ && (!v || v({
      level: c,
      value: n,
      field: t,
      newExpandValue: $
    })) && x($);
  }, j = ($) => {
    if ($.key === "ArrowRight" || $.key === "ArrowLeft")
      $.preventDefault(), R($.key === "ArrowRight");
    else if ($.key === "ArrowUp" || $.key === "ArrowDown") {
      $.preventDefault();
      const z = $.key === "ArrowUp" ? -1 : 1;
      if (!h.current) return;
      const B = h.current.querySelectorAll("[role=button]");
      let P = -1;
      for (let I = 0; I < B.length; I++)
        if (B[I].tabIndex === 0) {
          P = I;
          break;
        }
      if (P < 0)
        return;
      const W = (P + z + B.length) % B.length;
      B[P].tabIndex = -1, B[W].tabIndex = 0, B[W].focus();
    }
  }, D = () => {
    var $;
    R(!w);
    const z = b.current;
    if (!z) return;
    const B = ($ = h.current) === null || $ === void 0 ? void 0 : $.querySelector('[role=button][tabindex="0"]');
    B && (B.tabIndex = -1), z.tabIndex = 0, z.focus();
  };
  return /* @__PURE__ */ M.createElement("div", {
    className: d.basicChildStyle,
    role: "treeitem",
    "aria-expanded": w,
    "aria-selected": void 0
  }, /* @__PURE__ */ M.createElement("span", {
    className: C,
    onClick: D,
    onKeyDown: j,
    role: "button",
    "aria-label": _,
    "aria-expanded": w,
    "aria-controls": w ? k : void 0,
    ref: b,
    tabIndex: c === 0 ? 0 : -1
  }), (t || t === "") && (m ? /* @__PURE__ */ M.createElement("span", {
    className: d.clickableLabel,
    onClick: D,
    onKeyDown: j
  }, f_(t, d.quotesForFieldNames), ":") : /* @__PURE__ */ M.createElement("span", {
    className: d.label
  }, f_(t, d.quotesForFieldNames), ":")), /* @__PURE__ */ M.createElement("span", {
    className: d.punctuation
  }, s), w ? /* @__PURE__ */ M.createElement("ul", {
    id: k,
    role: "group",
    className: d.childFieldsContainer
  }, r.map(($, z) => /* @__PURE__ */ M.createElement(E5, {
    key: $[0] || z,
    field: $[0],
    value: $[1],
    style: d,
    lastElement: z === N,
    level: O,
    shouldExpandNode: p,
    clickToExpandNode: m,
    beforeExpandChange: v,
    outerRef: h
  }))) : /* @__PURE__ */ M.createElement("span", {
    className: d.collapsedContent,
    onClick: D,
    onKeyDown: j
  }), /* @__PURE__ */ M.createElement("span", {
    className: d.punctuation
  }, l), !a && /* @__PURE__ */ M.createElement("span", {
    className: d.punctuation
  }, ","));
}
function Gue(e) {
  let {
    field: t,
    openBracket: n,
    closeBracket: r,
    lastElement: a,
    style: s
  } = e;
  return /* @__PURE__ */ M.createElement("div", {
    className: s.basicChildStyle,
    role: "treeitem",
    "aria-selected": void 0
  }, (t || t === "") && /* @__PURE__ */ M.createElement("span", {
    className: s.label
  }, f_(t, s.quotesForFieldNames), ":"), /* @__PURE__ */ M.createElement("span", {
    className: s.punctuation
  }, n), /* @__PURE__ */ M.createElement("span", {
    className: s.punctuation
  }, r), !a && /* @__PURE__ */ M.createElement("span", {
    className: s.punctuation
  }, ","));
}
function Kue(e) {
  let {
    field: t,
    value: n,
    style: r,
    lastElement: a,
    shouldExpandNode: s,
    clickToExpandNode: l,
    level: c,
    outerRef: d,
    beforeExpandChange: p
  } = e;
  return b7({
    field: t,
    value: n,
    lastElement: a || !1,
    level: c,
    openBracket: "{",
    closeBracket: "}",
    style: r,
    shouldExpandNode: s,
    clickToExpandNode: l,
    data: Object.keys(n).map((m) => [m, n[m]]),
    outerRef: d,
    beforeExpandChange: p
  });
}
function Xue(e) {
  let {
    field: t,
    value: n,
    style: r,
    lastElement: a,
    level: s,
    shouldExpandNode: l,
    clickToExpandNode: c,
    outerRef: d,
    beforeExpandChange: p
  } = e;
  return b7({
    field: t,
    value: n,
    lastElement: a || !1,
    level: s,
    openBracket: "[",
    closeBracket: "]",
    style: r,
    shouldExpandNode: l,
    clickToExpandNode: c,
    data: n.map((m) => [void 0, m]),
    outerRef: d,
    beforeExpandChange: p
  });
}
function Yue(e) {
  let {
    field: t,
    value: n,
    style: r,
    lastElement: a
  } = e, s, l = r.otherValue;
  return n === null ? (s = "null", l = r.nullValue) : n === void 0 ? (s = "undefined", l = r.undefinedValue) : Hue(n) ? (s = Wue(n, !r.noQuotesForStringValues, r.stringifyStringValues), l = r.stringValue) : Bue(n) ? (s = n ? "true" : "false", l = r.booleanValue) : Uue(n) ? (s = n.toString(), l = r.numberValue) : Vue(n) ? (s = `${n.toString()}n`, l = r.numberValue) : g7(n) ? s = n.toISOString() : y7(n) ? s = "function() { }" : s = n.toString(), /* @__PURE__ */ M.createElement("div", {
    className: r.basicChildStyle,
    role: "treeitem",
    "aria-selected": void 0
  }, (t || t === "") && /* @__PURE__ */ M.createElement("span", {
    className: r.label
  }, f_(t, r.quotesForFieldNames), ":"), /* @__PURE__ */ M.createElement("span", {
    className: l
  }, s), !a && /* @__PURE__ */ M.createElement("span", {
    className: r.punctuation
  }, ","));
}
function E5(e) {
  const t = e.value;
  return que(t) ? /* @__PURE__ */ M.createElement(Xue, Object.assign({}, e)) : v7(t) && !g7(t) && !y7(t) ? /* @__PURE__ */ M.createElement(Kue, Object.assign({}, e)) : /* @__PURE__ */ M.createElement(Yue, Object.assign({}, e));
}
var Sn = { "container-light": "_2IvMF _GzYRV", "basic-element-style": "_2bkNM", "child-fields-container": "_1BXBN", "label-light": "_1MGIk", "clickable-label-light": "_2YKJg _1MGIk _1MFti", "punctuation-light": "_3uHL6 _3eOF8", "value-null-light": "_2T6PJ", "value-undefined-light": "_1Gho6", "value-string-light": "_vGjyY", "value-number-light": "_1bQdo", "value-boolean-light": "_3zQKs", "value-other-light": "_1xvuR", "collapse-icon-light": "_oLqym _f10Tu _1MFti _1LId0", "expand-icon-light": "_2AXVT _f10Tu _1MFti _1UmXx", "collapsed-content-light": "_2KJWg _1pNG9 _1MFti", "container-dark": "_11RoI _GzYRV", "expand-icon-dark": "_17H2C _f10Tu _1MFti _1UmXx", "collapse-icon-dark": "_3QHg2 _f10Tu _1MFti _1LId0", "collapsed-content-dark": "_3fDAz _1pNG9 _1MFti", "label-dark": "_2bSDX", "clickable-label-dark": "_1RQEj _2bSDX _1MFti", "punctuation-dark": "_gsbQL _3eOF8", "value-null-dark": "_LaAZe", "value-undefined-dark": "_GTKgm", "value-string-dark": "_Chy1W", "value-number-dark": "_2bveF", "value-boolean-dark": "_2vRm-", "value-other-dark": "_1prJR" };
const w7 = {
  collapseJson: "collapse JSON",
  expandJson: "expand JSON"
}, _M = {
  container: Sn["container-light"],
  basicChildStyle: Sn["basic-element-style"],
  childFieldsContainer: Sn["child-fields-container"],
  label: Sn["label-light"],
  clickableLabel: Sn["clickable-label-light"],
  nullValue: Sn["value-null-light"],
  undefinedValue: Sn["value-undefined-light"],
  stringValue: Sn["value-string-light"],
  booleanValue: Sn["value-boolean-light"],
  numberValue: Sn["value-number-light"],
  otherValue: Sn["value-other-light"],
  punctuation: Sn["punctuation-light"],
  collapseIcon: Sn["collapse-icon-light"],
  expandIcon: Sn["expand-icon-light"],
  collapsedContent: Sn["collapsed-content-light"],
  noQuotesForStringValues: !1,
  quotesForFieldNames: !1,
  ariaLables: w7,
  stringifyStringValues: !1
}, Que = {
  container: Sn["container-dark"],
  basicChildStyle: Sn["basic-element-style"],
  childFieldsContainer: Sn["child-fields-container"],
  label: Sn["label-dark"],
  clickableLabel: Sn["clickable-label-dark"],
  nullValue: Sn["value-null-dark"],
  undefinedValue: Sn["value-undefined-dark"],
  stringValue: Sn["value-string-dark"],
  booleanValue: Sn["value-boolean-dark"],
  numberValue: Sn["value-number-dark"],
  otherValue: Sn["value-other-dark"],
  punctuation: Sn["punctuation-dark"],
  collapseIcon: Sn["collapse-icon-dark"],
  expandIcon: Sn["expand-icon-dark"],
  collapsedContent: Sn["collapsed-content-dark"],
  noQuotesForStringValues: !1,
  quotesForFieldNames: !1,
  ariaLables: w7,
  stringifyStringValues: !1
}, Jue = () => !0, Zue = (e) => e < 1, ece = (e) => {
  let {
    data: t,
    style: n = _M,
    shouldExpandNode: r = Jue,
    clickToExpandNode: a = !1,
    beforeExpandChange: s,
    compactTopLevel: l,
    ...c
  } = e;
  const d = M.useRef(null);
  return /* @__PURE__ */ M.createElement("div", Object.assign({
    "aria-label": "JSON view"
  }, c, {
    className: n.container,
    ref: d,
    role: "tree"
  }), l && v7(t) ? Object.entries(t).map((p) => {
    let [m, h] = p;
    return /* @__PURE__ */ M.createElement(E5, {
      key: m,
      field: m,
      value: h,
      style: {
        ..._M,
        ...n
      },
      lastElement: !0,
      level: 1,
      shouldExpandNode: r,
      clickToExpandNode: a,
      beforeExpandChange: s,
      outerRef: d
    });
  }) : /* @__PURE__ */ M.createElement(E5, {
    value: t,
    style: {
      ..._M,
      ...n
    },
    lastElement: !0,
    level: 0,
    shouldExpandNode: r,
    clickToExpandNode: a,
    outerRef: d,
    beforeExpandChange: s
  }));
};
function tce(e) {
  for (const t in e)
    if (Object.hasOwn(e, t))
      return !1;
  return !0;
}
function nce(e) {
  if (e == null || typeof e != "object")
    return !1;
  const t = Object.getPrototypeOf(e);
  return t !== null && t !== Object.prototype ? !1 : tce(e);
}
const rce = ({
  data: e,
  className: t = "json-display"
}) => /* @__PURE__ */ E.jsx("div", { className: t, children: /* @__PURE__ */ E.jsx(
  ece,
  {
    data: nce(e) ? "" : e,
    style: Que,
    shouldExpandNode: Zue
  }
) });
function oce(e, t, n = {}) {
  const {
    maxFontSize: r = 100,
    // default maximum font size
    minFontSize: a = 6,
    // default minimum font size
    decrementFactor: s = 0.9
    // font size decrement step
  } = n;
  if (!e || !t)
    return;
  if (s >= 1 || s <= 0)
    throw new Error("decrementFactor must be between 0 and 1");
  const l = e.getBoundingClientRect(), c = l.width, d = l.height;
  let p = r;
  t.style.whiteSpace = "nowrap", t.style.display = "inline-block", t.style.fontSize = p + "px";
  let m = t.getBoundingClientRect();
  for (; (m.width > c || m.height > d) && p > a; )
    p *= s, t.style.fontSize = p + "px", m = t.getBoundingClientRect();
}
function ace(e = {
  n: 0,
  elapsed: 0,
  ascii: !1,
  unit: "it",
  unit_scale: !1,
  unit_divisor: 1e3
}) {
  let t = e.total ?? null;
  const {
    n = 0,
    unit_scale: r = !1,
    elapsed: a = 0,
    // ascii,
    unit: s = "it",
    unit_divisor: l = 1e3,
    // ncols = undefined,
    prefix: c = "",
    rate: d = void 0,
    // bar_format = undefined,
    postfix: p = null,
    initial: m = 0
    // colour = undefined,
  } = e;
  t !== null && n >= t + 0.5 && (t = null);
  let h = n, v = t, y = d;
  r && r !== !0 && r !== 1 && (t !== null && (v = t * r), h = n * r, d !== void 0 && (y = d * r));
  const w = XD(a);
  y === void 0 && a > 0 && (y = (h - m) / a);
  const x = y ? 1 / y : void 0, [b, k] = y ? nk(y, l) : [void 0, ""], [C, _] = x ? nk(x, 1e3) : [void 0, ""], O = (b || "?") + `${k}${s}/s`, N = C ? `${C}${_}s/` + s : "?", R = x && x > 1 ? N : O, j = r ? nk(h, l).join("") : h.toString(), D = r && v !== null ? nk(v, l).join("") : v?.toString() ?? "?", $ = y && v !== null ? (v - h) / y : 0, z = y ? XD($) : "?", B = c ? `${c}: ` : "";
  if (t !== null) {
    const P = h / t * 100, W = ` ${j}/${D} [${w} < ${z}, ${R}${p ?? ""}]`;
    return `${B}${P.toFixed(0)}%${W}`;
  }
  return `${B}${j}${s} [${w}, ${R}${p ?? ""}]`;
}
function XD(e) {
  const t = Math.floor(e / 60), n = Math.floor(e % 60);
  return `${t}:${n.toString().padStart(2, "0")}`;
}
function nk(e, t) {
  const n = ["", "K", "M", "G", "T"];
  let r = 0;
  for (; e >= t && r < n.length - 1; )
    e /= t, r++;
  return [e.toFixed(2), n[r]];
}
const ice = ({ state: e, className: t = "reacttqdm", ...n }) => {
  const r = M.useRef(null), a = M.useRef(null);
  M.useEffect(() => {
    const l = () => {
      !r.current || !a.current || oce(r.current, a.current, {
        maxFontSize: 12,
        decrementFactor: 0.9
      });
    };
    return l(), window.addEventListener("resize", l), () => {
      window.removeEventListener("resize", l);
    };
  }, [e]);
  const s = e.total ? (e.n ?? 0) / e.total * 100 : 0;
  return /* @__PURE__ */ E.jsx("div", { ref: r, className: t, ...n, children: /* @__PURE__ */ E.jsxs(
    "div",
    {
      style: {
        position: "relative",
        display: "flex",
        flexDirection: "column",
        justifyContent: "center",
        alignItems: "center"
      },
      children: [
        /* @__PURE__ */ E.jsx(
          "div",
          {
            className: t + "-bar",
            style: {
              position: "absolute",
              width: "100%",
              height: "100%",
              // Adjust height if needed
              overflow: "hidden"
            },
            children: /* @__PURE__ */ E.jsx(
              "div",
              {
                className: t + "-progress",
                style: {
                  width: `${s}%`,
                  height: "100%"
                }
              }
            )
          }
        ),
        /* @__PURE__ */ E.jsx("div", { className: t + "-text", ref: a, children: ace(e) })
      ]
    }
  ) });
};
var rk = {}, YD;
function sce() {
  if (YD) return rk;
  YD = 1;
  var e = /; *([!#$%&'*+.^_`|~0-9A-Za-z-]+) *= *("(?:[\u000b\u0020\u0021\u0023-\u005b\u005d-\u007e\u0080-\u00ff]|\\[\u000b\u0020-\u00ff])*"|[!#$%&'*+.^_`|~0-9A-Za-z-]+) */g, t = /^[\u000b\u0020-\u007e\u0080-\u00ff]+$/, n = /^[!#$%&'*+.^_`|~0-9A-Za-z-]+$/, r = /\\([\u000b\u0020-\u00ff])/g, a = /([\\"])/g, s = /^[!#$%&'*+.^_`|~0-9A-Za-z-]+\/[!#$%&'*+.^_`|~0-9A-Za-z-]+$/;
  rk.format = l, rk.parse = c;
  function l(h) {
    if (!h || typeof h != "object")
      throw new TypeError("argument obj is required");
    var v = h.parameters, y = h.type;
    if (!y || !s.test(y))
      throw new TypeError("invalid type");
    var w = y;
    if (v && typeof v == "object")
      for (var x, b = Object.keys(v).sort(), k = 0; k < b.length; k++) {
        if (x = b[k], !n.test(x))
          throw new TypeError("invalid parameter name");
        w += "; " + x + "=" + p(v[x]);
      }
    return w;
  }
  function c(h) {
    if (!h)
      throw new TypeError("argument string is required");
    var v = typeof h == "object" ? d(h) : h;
    if (typeof v != "string")
      throw new TypeError("argument string is required to be a string");
    var y = v.indexOf(";"), w = y !== -1 ? v.slice(0, y).trim() : v.trim();
    if (!s.test(w))
      throw new TypeError("invalid media type");
    var x = new m(w.toLowerCase());
    if (y !== -1) {
      var b, k, C;
      for (e.lastIndex = y; k = e.exec(v); ) {
        if (k.index !== y)
          throw new TypeError("invalid parameter format");
        y += k[0].length, b = k[1].toLowerCase(), C = k[2], C.charCodeAt(0) === 34 && (C = C.slice(1, -1), C.indexOf("\\") !== -1 && (C = C.replace(r, "$1"))), x.parameters[b] = C;
      }
      if (y !== v.length)
        throw new TypeError("invalid parameter format");
    }
    return x;
  }
  function d(h) {
    var v;
    if (typeof h.getHeader == "function" ? v = h.getHeader("content-type") : typeof h.headers == "object" && (v = h.headers && h.headers["content-type"]), typeof v != "string")
      throw new TypeError("content-type header is missing from object");
    return v;
  }
  function p(h) {
    var v = String(h);
    if (n.test(v))
      return v;
    if (v.length > 0 && !t.test(v))
      throw new TypeError("invalid parameter value");
    return '"' + v.replace(a, "\\$1") + '"';
  }
  function m(h) {
    this.parameters = /* @__PURE__ */ Object.create(null), this.type = h;
  }
  return rk;
}
var lce = sce(), ih = /* @__PURE__ */ new Map(), x7 = function(e) {
  return e.cloneNode(!0);
}, QD = function() {
  return window.location.protocol === "file:";
}, S7 = function(e, t, n) {
  var r = new XMLHttpRequest();
  r.onreadystatechange = function() {
    try {
      if (!/\.svg/i.test(e) && r.readyState === 2) {
        var a = r.getResponseHeader("Content-Type");
        if (!a)
          throw new Error("Content type not found");
        var s = lce.parse(a).type;
        if (!(s === "image/svg+xml" || s === "text/plain"))
          throw new Error("Invalid content type: ".concat(s));
      }
      if (r.readyState === 4) {
        if (r.status === 404 || r.responseXML === null)
          throw new Error(QD() ? "Note: SVG injection ajax calls do not work locally without adjusting security settings in your browser. Or consider using a local webserver." : "Unable to load SVG file: " + e);
        if (r.status === 200 || QD() && r.status === 0)
          n(null, r);
        else
          throw new Error("There was a problem injecting the SVG: " + r.status + " " + r.statusText);
      }
    } catch (l) {
      if (r.abort(), l instanceof Error)
        n(l, r);
      else
        throw l;
    }
  }, r.open("GET", e), r.withCredentials = t, r.overrideMimeType && r.overrideMimeType("text/xml"), r.send();
}, Wc = {}, JD = function(e, t) {
  Wc[e] = Wc[e] || [], Wc[e].push(t);
}, uce = function(e) {
  for (var t = function(a, s) {
    setTimeout(function() {
      if (Array.isArray(Wc[e])) {
        var l = ih.get(e), c = Wc[e][a];
        l instanceof SVGSVGElement && c(null, x7(l)), l instanceof Error && c(l), a === Wc[e].length - 1 && delete Wc[e];
      }
    }, 0);
  }, n = 0, r = Wc[e].length; n < r; n++)
    t(n);
}, cce = function(e, t, n) {
  if (ih.has(e)) {
    var r = ih.get(e);
    if (r === void 0) {
      JD(e, n);
      return;
    }
    if (r instanceof SVGSVGElement) {
      n(null, x7(r));
      return;
    }
  }
  ih.set(e, void 0), JD(e, n), S7(e, t, function(a, s) {
    var l;
    a ? ih.set(e, a) : ((l = s.responseXML) === null || l === void 0 ? void 0 : l.documentElement) instanceof SVGSVGElement && ih.set(e, s.responseXML.documentElement), uce(e);
  });
}, dce = function(e, t, n) {
  S7(e, t, function(r, a) {
    var s;
    r ? n(r) : ((s = a.responseXML) === null || s === void 0 ? void 0 : s.documentElement) instanceof SVGSVGElement && n(null, a.responseXML.documentElement);
  });
}, fce = 0, pce = function() {
  return ++fce;
}, Js = [], ZD = {}, mce = "http://www.w3.org/2000/svg", EM = "http://www.w3.org/1999/xlink", e6 = function(e, t, n, r, a, s, l) {
  var c = e.getAttribute("data-src") || e.getAttribute("src");
  if (!c) {
    l(new Error("Invalid data-src or src attribute"));
    return;
  }
  if (Js.indexOf(e) !== -1) {
    Js.splice(Js.indexOf(e), 1), e = null;
    return;
  }
  Js.push(e), e.setAttribute("src", "");
  var d = r ? cce : dce;
  d(c, a, function(p, m) {
    if (!m) {
      Js.splice(Js.indexOf(e), 1), e = null, l(p);
      return;
    }
    var h = e.getAttribute("id");
    h && m.setAttribute("id", h);
    var v = e.getAttribute("title");
    v && m.setAttribute("title", v);
    var y = e.getAttribute("width");
    y && m.setAttribute("width", y);
    var w = e.getAttribute("height");
    w && m.setAttribute("height", w);
    var x = Array.from(new Set(w0(w0(w0([], (m.getAttribute("class") || "").split(" "), !0), ["injected-svg"], !1), (e.getAttribute("class") || "").split(" "), !0))).join(" ").trim();
    m.setAttribute("class", x);
    var b = e.getAttribute("style");
    b && m.setAttribute("style", b), m.setAttribute("data-src", c);
    var k = [].filter.call(e.attributes, function(K) {
      return /^data-\w[\w-]*$/.test(K.name);
    });
    if (Array.prototype.forEach.call(k, function(K) {
      K.name && K.value && m.setAttribute(K.name, K.value);
    }), n) {
      var C = {
        clipPath: ["clip-path"],
        "color-profile": ["color-profile"],
        cursor: ["cursor"],
        filter: ["filter"],
        linearGradient: ["fill", "stroke"],
        marker: ["marker", "marker-start", "marker-mid", "marker-end"],
        mask: ["mask"],
        path: [],
        pattern: ["fill", "stroke"],
        radialGradient: ["fill", "stroke"]
      }, _, O, N, R, j;
      Object.keys(C).forEach(function(K) {
        _ = K, N = C[K], O = m.querySelectorAll(_ + "[id]");
        for (var q = function(F, X) {
          R = O[F].id, j = R + "-" + pce();
          var U;
          Array.prototype.forEach.call(N, function(ae) {
            U = m.querySelectorAll("[" + ae + '*="' + R + '"]');
            for (var se = 0, pe = U.length; se < pe; se++) {
              var ge = U[se].getAttribute(ae);
              ge && !ge.match(new RegExp('url\\("?#' + R + '"?\\)')) || U[se].setAttribute(ae, "url(#" + j + ")");
            }
          });
          for (var H = m.querySelectorAll("[*|href]"), Q = [], re = 0, de = H.length; re < de; re++) {
            var le = H[re].getAttributeNS(EM, "href");
            le && le.toString() === "#" + O[F].id && Q.push(H[re]);
          }
          for (var me = 0, ve = Q.length; me < ve; me++)
            Q[me].setAttributeNS(EM, "href", "#" + j);
          O[F].id = j;
        }, Z = 0, V = O.length; Z < V; Z++)
          q(Z);
      });
    }
    m.removeAttribute("xmlns:a");
    for (var D = m.querySelectorAll("script"), $ = [], z, B, P = 0, W = D.length; P < W; P++)
      B = D[P].getAttribute("type"), (!B || B === "application/ecmascript" || B === "application/javascript" || B === "text/javascript") && (z = D[P].innerText || D[P].textContent, z && $.push(z), m.removeChild(D[P]));
    if ($.length > 0 && (t === "always" || t === "once" && !ZD[c])) {
      for (var I = 0, G = $.length; I < G; I++)
        new Function($[I])(window);
      ZD[c] = !0;
    }
    var L = m.querySelectorAll("style");
    if (Array.prototype.forEach.call(L, function(K) {
      K.textContent += "";
    }), m.setAttribute("xmlns", mce), m.setAttribute("xmlns:xlink", EM), s(m), !e.parentNode) {
      Js.splice(Js.indexOf(e), 1), e = null, l(new Error("Parent node is null"));
      return;
    }
    e.parentNode.replaceChild(m, e), Js.splice(Js.indexOf(e), 1), e = null, l(null, m);
  });
}, hce = function(e, t) {
  var n = t === void 0 ? {} : t, r = n.afterAll, a = r === void 0 ? function() {
  } : r, s = n.afterEach, l = s === void 0 ? function() {
  } : s, c = n.beforeEach, d = c === void 0 ? function() {
  } : c, p = n.cacheRequests, m = p === void 0 ? !0 : p, h = n.evalScripts, v = h === void 0 ? "never" : h, y = n.httpRequestWithCredentials, w = y === void 0 ? !1 : y, x = n.renumerateIRIElements, b = x === void 0 ? !0 : x;
  if (e && "length" in e)
    for (var k = 0, C = 0, _ = e.length; C < _; C++)
      e6(e[C], v, b, m, w, d, function(O, N) {
        l(O, N), e && "length" in e && e.length === ++k && a(k);
      });
  else e ? e6(e, v, b, m, w, d, function(O, N) {
    l(O, N), a(1), e = null;
  }) : a(0);
}, gce = function(e) {
  var t = e?.ownerDocument || document;
  return t.defaultView || window;
}, vce = function(e, t) {
  for (var n in e)
    if (!(n in t))
      return !0;
  for (var r in t)
    if (e[r] !== t[r])
      return !0;
  return !1;
}, yce = ["afterInjection", "beforeInjection", "desc", "evalScripts", "fallback", "httpRequestWithCredentials", "loading", "renumerateIRIElements", "src", "title", "useRequestCache", "wrapper"], ok = "http://www.w3.org/2000/svg", t6 = "http://www.w3.org/1999/xlink", VR = /* @__PURE__ */ (function(e) {
  function t() {
    for (var r, a = arguments.length, s = new Array(a), l = 0; l < a; l++)
      s[l] = arguments[l];
    return r = e.call.apply(e, [this].concat(s)) || this, r.initialState = {
      hasError: !1,
      isLoading: !0
    }, r.state = r.initialState, r._isMounted = !1, r.reactWrapper = void 0, r.nonReactWrapper = void 0, r.refCallback = function(c) {
      r.reactWrapper = c;
    }, r;
  }
  oR(t, e);
  var n = t.prototype;
  return n.renderSVG = function() {
    var r = this;
    if (this.reactWrapper instanceof gce(this.reactWrapper).Node) {
      var a = this.props, s = a.desc, l = a.evalScripts, c = a.httpRequestWithCredentials, d = a.renumerateIRIElements, p = a.src, m = a.title, h = a.useRequestCache, v = this.props.onError, y = this.props.beforeInjection, w = this.props.afterInjection, x = this.props.wrapper, b, k;
      x === "svg" ? (b = document.createElementNS(ok, x), b.setAttribute("xmlns", ok), b.setAttribute("xmlns:xlink", t6), k = document.createElementNS(ok, x)) : (b = document.createElement(x), k = document.createElement(x)), b.appendChild(k), k.dataset.src = p, this.nonReactWrapper = this.reactWrapper.appendChild(b);
      var C = function(N) {
        if (r.removeSVG(), !r._isMounted) {
          v(N);
          return;
        }
        r.setState(function() {
          return {
            hasError: !0,
            isLoading: !1
          };
        }, function() {
          v(N);
        });
      }, _ = function(N, R) {
        if (N) {
          C(N);
          return;
        }
        r._isMounted && r.setState(function() {
          return {
            isLoading: !1
          };
        }, function() {
          try {
            w(R);
          } catch (j) {
            C(j);
          }
        });
      }, O = function(N) {
        if (N.setAttribute("role", "img"), s) {
          var R = N.querySelector(":scope > desc");
          R && N.removeChild(R);
          var j = document.createElement("desc");
          j.innerHTML = s, N.prepend(j);
        }
        if (m) {
          var D = N.querySelector(":scope > title");
          D && N.removeChild(D);
          var $ = document.createElement("title");
          $.innerHTML = m, N.prepend($);
        }
        try {
          y(N);
        } catch (z) {
          C(z);
        }
      };
      hce(k, {
        afterEach: _,
        beforeEach: O,
        cacheRequests: h,
        evalScripts: l,
        httpRequestWithCredentials: c,
        renumerateIRIElements: d
      });
    }
  }, n.removeSVG = function() {
    var r;
    (r = this.nonReactWrapper) != null && r.parentNode && (this.nonReactWrapper.parentNode.removeChild(this.nonReactWrapper), this.nonReactWrapper = null);
  }, n.componentDidMount = function() {
    this._isMounted = !0, this.renderSVG();
  }, n.componentDidUpdate = function(r) {
    var a = this;
    vce(ft({}, r), this.props) && this.setState(function() {
      return a.initialState;
    }, function() {
      a.removeSVG(), a.renderSVG();
    });
  }, n.componentWillUnmount = function() {
    this._isMounted = !1, this.removeSVG();
  }, n.render = function() {
    var r = this.props;
    r.afterInjection, r.beforeInjection, r.desc, r.evalScripts;
    var a = r.fallback;
    r.httpRequestWithCredentials;
    var s = r.loading;
    r.renumerateIRIElements, r.src, r.title, r.useRequestCache;
    var l = r.wrapper, c = f2(r, yce), d = l;
    return /* @__PURE__ */ M.createElement(d, ft({}, c, {
      ref: this.refCallback
    }, l === "svg" ? {
      xmlns: ok,
      xmlnsXlink: t6
    } : {}), this.state.isLoading && s && /* @__PURE__ */ M.createElement(s, null), this.state.hasError && a && /* @__PURE__ */ M.createElement(a, null));
  }, t;
})(M.Component);
VR.defaultProps = {
  afterInjection: function() {
  },
  beforeInjection: function() {
  },
  desc: "",
  evalScripts: "never",
  fallback: null,
  httpRequestWithCredentials: !1,
  loading: null,
  onError: function() {
  },
  renumerateIRIElements: !0,
  title: "",
  useRequestCache: !0,
  wrapper: "div"
};
VR.propTypes = {
  afterInjection: Nr.func,
  beforeInjection: Nr.func,
  desc: Nr.string,
  evalScripts: Nr.oneOf(["always", "once", "never"]),
  fallback: Nr.oneOfType([Nr.func, Nr.object, Nr.string]),
  httpRequestWithCredentials: Nr.bool,
  loading: Nr.oneOfType([Nr.func, Nr.object, Nr.string]),
  onError: Nr.func,
  renumerateIRIElements: Nr.bool,
  src: Nr.string.isRequired,
  title: Nr.string,
  useRequestCache: Nr.bool,
  wrapper: Nr.oneOf(["div", "span", "svg"])
};
const HR = ({
  text: e = "No image data provided"
}) => /* @__PURE__ */ E.jsx(
  "div",
  {
    style: {
      display: "flex",
      alignItems: "center",
      justifyContent: "center",
      minHeight: "100px",
      border: "1px dashed #ccc",
      color: "#666"
    },
    children: e
  }
), bce = M.memo(
  ({
    value: e,
    format: t = "jpeg",
    alt: n = "Base64 image",
    onError: r,
    onLoad: a,
    ...s
  }) => {
    const [l, c] = M.useState(!1), [d, p] = M.useState(!0), m = M.useRef(null), h = M.useMemo(() => {
      if (typeof e == "string")
        return e;
      if (e && typeof e == "object" && "data" in e) {
        const x = e.data;
        if (x instanceof ArrayBuffer) {
          const b = new Uint8Array(x);
          let k = "";
          for (let C = 0; C < b.byteLength; C++)
            k += String.fromCharCode(b[C]);
          return btoa(k);
        }
      }
      return "";
    }, [e]), v = M.useMemo(() => h ? `data:image/${t};base64,${h}` : "", [h, t]), y = M.useCallback(
      (x) => {
        c(!0), p(!1), r?.(x);
      },
      [r]
    ), w = M.useCallback(() => {
      p(!1), c(!1), a?.();
    }, [a]);
    return M.useEffect(() => {
      const x = m.current;
      if (x)
        return x.addEventListener("error", y), x.addEventListener("load", w), () => {
          x.removeEventListener("error", y), x.removeEventListener("load", w);
        };
    }, [y, w, e]), M.useEffect(() => {
      c(!1), p(!0);
    }, [e]), h ? l ? /* @__PURE__ */ E.jsx(
      "div",
      {
        style: {
          display: "flex",
          alignItems: "center",
          justifyContent: "center",
          minHeight: "100px",
          border: "1px dashed #ccc",
          color: "#666"
        },
        children: "Failed to load base64 image"
      }
    ) : /* @__PURE__ */ E.jsx(
      "img",
      {
        ref: m,
        src: v,
        alt: n,
        className: `base64-image-renderer image-renderer ${s.className || ""} ${d ? " loading" : ""}`,
        ...s
      }
    ) : /* @__PURE__ */ E.jsx(HR, {});
  }
), wce = M.memo(
  ({
    value: e,
    alt: t = "SVG image",
    onError: n,
    onLoad: r,
    ...a
  }) => {
    const [s, l] = M.useState(!1), c = M.useMemo(() => {
      if (!e) return "";
      try {
        return `data:image/svg+xml;base64,${btoa(e)}`;
      } catch (p) {
        return console.error("Failed to encode SVG to base64:", p), "";
      }
    }, [e]);
    M.useEffect(() => {
      l(!1);
    }, [e]);
    const d = M.useCallback(
      (p) => {
        l(!0), n?.(p);
      },
      [n]
    );
    return e ? s || !c ? /* @__PURE__ */ E.jsx(
      "div",
      {
        style: {
          display: "flex",
          alignItems: "center",
          justifyContent: "center",
          minHeight: "100px",
          border: "1px dashed #ccc",
          color: "#666"
        },
        children: "Failed to load SVG"
      }
    ) : /* @__PURE__ */ E.jsx(
      VR,
      {
        src: c,
        className: `svg-renderer ${a.className || ""}`,
        style: {
          maxWidth: "100%",
          maxHeight: "100%",
          ...a.style
        },
        beforeInjection: (p) => {
          p.classList.add("svg-renderer"), p.setAttribute("style", "max-width: 100%; max-height: 100%;"), p.setAttribute("width", "100%"), p.setAttribute("height", "100%"), p.setAttribute("aria-label", t);
          const m = () => {
            l(!1), r?.();
          }, h = (v) => {
            l(!0), n?.(v);
          };
          try {
            p.addEventListener("load", m), p.addEventListener("error", h);
          } catch {
            m();
          }
        },
        onError: d
      }
    ) : /* @__PURE__ */ E.jsx(HR, {});
  }
), xce = M.memo(
  ({
    src: e,
    alt: t = "Streaming image",
    onError: n,
    onLoad: r,
    ...a
  }) => {
    const s = M.useRef(null), [l, c] = M.useState(!1), [d, p] = M.useState(!0);
    M.useEffect(() => {
      s.current && e && (p(!0), c(!1), s.current.src = e);
    }, [e]);
    const m = M.useCallback(
      (v) => {
        c(!0), p(!1), n?.(v);
      },
      [n]
    ), h = M.useCallback(() => {
      p(!1), c(!1), r?.();
    }, [r]);
    return M.useEffect(() => {
      const v = s.current;
      if (v)
        return v.addEventListener("error", m), v.addEventListener("load", h), () => {
          v.removeEventListener("error", m), v.removeEventListener("load", h);
        };
    }, [m, h]), l ? /* @__PURE__ */ E.jsx(HR, { text: "Failed to load image" }) : /* @__PURE__ */ E.jsx(
      "img",
      {
        ref: s,
        className: `streaming-image image-renderer ${a.className || ""} ${d ? " loading" : ""}`,
        alt: t,
        ...a
      }
    );
  }
);
function A2(e) {
  const t = e + "CollectionProvider", [n, r] = jl(t), [a, s] = n(
    t,
    { collectionRef: { current: null }, itemMap: /* @__PURE__ */ new Map() }
  ), l = (x) => {
    const { scope: b, children: k } = x, C = Qn.useRef(null), _ = Qn.useRef(/* @__PURE__ */ new Map()).current;
    return /* @__PURE__ */ E.jsx(a, { scope: b, itemMap: _, collectionRef: C, children: k });
  };
  l.displayName = t;
  const c = e + "CollectionSlot", d = /* @__PURE__ */ Ah(c), p = Qn.forwardRef(
    (x, b) => {
      const { scope: k, children: C } = x, _ = s(c, k), O = Wn(b, _.collectionRef);
      return /* @__PURE__ */ E.jsx(d, { ref: O, children: C });
    }
  );
  p.displayName = c;
  const m = e + "CollectionItemSlot", h = "data-radix-collection-item", v = /* @__PURE__ */ Ah(m), y = Qn.forwardRef(
    (x, b) => {
      const { scope: k, children: C, ..._ } = x, O = Qn.useRef(null), N = Wn(b, O), R = s(m, k);
      return Qn.useEffect(() => (R.itemMap.set(O, { ref: O, ..._ }), () => {
        R.itemMap.delete(O);
      })), /* @__PURE__ */ E.jsx(v, { [h]: "", ref: N, children: C });
    }
  );
  y.displayName = m;
  function w(x) {
    const b = s(e + "CollectionConsumer", x);
    return Qn.useCallback(() => {
      const k = b.collectionRef.current;
      if (!k) return [];
      const C = Array.from(k.querySelectorAll(`[${h}]`));
      return Array.from(b.itemMap.values()).sort(
        (_, O) => C.indexOf(_.ref.current) - C.indexOf(O.ref.current)
      );
    }, [b.collectionRef, b.itemMap]);
  }
  return [
    { Provider: l, Slot: p, ItemSlot: y },
    w,
    r
  ];
}
var Sce = Object.freeze({
  // See: https://github.com/twbs/bootstrap/blob/main/scss/mixins/_visually-hidden.scss
  position: "absolute",
  border: 0,
  width: 1,
  height: 1,
  padding: 0,
  margin: -1,
  overflow: "hidden",
  clip: "rect(0, 0, 0, 0)",
  whiteSpace: "nowrap",
  wordWrap: "normal"
}), kce = "VisuallyHidden", qR = M.forwardRef(
  (e, t) => /* @__PURE__ */ E.jsx(
    Kt.span,
    {
      ...e,
      ref: t,
      style: { ...Sce, ...e.style }
    }
  )
);
qR.displayName = kce;
var WR = "ToastProvider", [GR, _ce, Ece] = A2("Toast"), [k7] = jl("Toast", [Ece]), [Cce, j2] = k7(WR), _7 = (e) => {
  const {
    __scopeToast: t,
    label: n = "Notification",
    duration: r = 5e3,
    swipeDirection: a = "right",
    swipeThreshold: s = 50,
    children: l
  } = e, [c, d] = M.useState(null), [p, m] = M.useState(0), h = M.useRef(!1), v = M.useRef(!1);
  return n.trim() || console.error(
    `Invalid prop \`label\` supplied to \`${WR}\`. Expected non-empty \`string\`.`
  ), /* @__PURE__ */ E.jsx(GR.Provider, { scope: t, children: /* @__PURE__ */ E.jsx(
    Cce,
    {
      scope: t,
      label: n,
      duration: r,
      swipeDirection: a,
      swipeThreshold: s,
      toastCount: p,
      viewport: c,
      onViewportChange: d,
      onToastAdd: M.useCallback(() => m((y) => y + 1), []),
      onToastRemove: M.useCallback(() => m((y) => y - 1), []),
      isFocusedToastEscapeKeyDownRef: h,
      isClosePausedRef: v,
      children: l
    }
  ) });
};
_7.displayName = WR;
var E7 = "ToastViewport", Oce = ["F8"], C5 = "toast.viewportPause", O5 = "toast.viewportResume", C7 = M.forwardRef(
  (e, t) => {
    const {
      __scopeToast: n,
      hotkey: r = Oce,
      label: a = "Notifications ({hotkey})",
      ...s
    } = e, l = j2(E7, n), c = _ce(n), d = M.useRef(null), p = M.useRef(null), m = M.useRef(null), h = M.useRef(null), v = Wn(t, h, l.onViewportChange), y = r.join("+").replace(/Key/g, "").replace(/Digit/g, ""), w = l.toastCount > 0;
    M.useEffect(() => {
      const b = (k) => {
        r.length !== 0 && r.every((C) => k[C] || k.code === C) && h.current?.focus();
      };
      return document.addEventListener("keydown", b), () => document.removeEventListener("keydown", b);
    }, [r]), M.useEffect(() => {
      const b = d.current, k = h.current;
      if (w && b && k) {
        const C = () => {
          if (!l.isClosePausedRef.current) {
            const R = new CustomEvent(C5);
            k.dispatchEvent(R), l.isClosePausedRef.current = !0;
          }
        }, _ = () => {
          if (l.isClosePausedRef.current) {
            const R = new CustomEvent(O5);
            k.dispatchEvent(R), l.isClosePausedRef.current = !1;
          }
        }, O = (R) => {
          !b.contains(R.relatedTarget) && _();
        }, N = () => {
          b.contains(document.activeElement) || _();
        };
        return b.addEventListener("focusin", C), b.addEventListener("focusout", O), b.addEventListener("pointermove", C), b.addEventListener("pointerleave", N), window.addEventListener("blur", C), window.addEventListener("focus", _), () => {
          b.removeEventListener("focusin", C), b.removeEventListener("focusout", O), b.removeEventListener("pointermove", C), b.removeEventListener("pointerleave", N), window.removeEventListener("blur", C), window.removeEventListener("focus", _);
        };
      }
    }, [w, l.isClosePausedRef]);
    const x = M.useCallback(
      ({ tabbingDirection: b }) => {
        const k = c().map((C) => {
          const _ = C.ref.current, O = [_, ...Fce(_)];
          return b === "forwards" ? O : O.reverse();
        });
        return (b === "forwards" ? k.reverse() : k).flat();
      },
      [c]
    );
    return M.useEffect(() => {
      const b = h.current;
      if (b) {
        const k = (C) => {
          const _ = C.altKey || C.ctrlKey || C.metaKey;
          if (C.key === "Tab" && !_) {
            const O = document.activeElement, N = C.shiftKey;
            if (C.target === b && N) {
              p.current?.focus();
              return;
            }
            const R = x({ tabbingDirection: N ? "backwards" : "forwards" }), j = R.findIndex((D) => D === O);
            CM(R.slice(j + 1)) ? C.preventDefault() : N ? p.current?.focus() : m.current?.focus();
          }
        };
        return b.addEventListener("keydown", k), () => b.removeEventListener("keydown", k);
      }
    }, [c, x]), /* @__PURE__ */ E.jsxs(
      ree,
      {
        ref: d,
        role: "region",
        "aria-label": a.replace("{hotkey}", y),
        tabIndex: -1,
        style: { pointerEvents: w ? void 0 : "none" },
        children: [
          w && /* @__PURE__ */ E.jsx(
            M5,
            {
              ref: p,
              onFocusFromOutsideViewport: () => {
                const b = x({
                  tabbingDirection: "forwards"
                });
                CM(b);
              }
            }
          ),
          /* @__PURE__ */ E.jsx(GR.Slot, { scope: n, children: /* @__PURE__ */ E.jsx(Kt.ol, { tabIndex: -1, ...s, ref: v }) }),
          w && /* @__PURE__ */ E.jsx(
            M5,
            {
              ref: m,
              onFocusFromOutsideViewport: () => {
                const b = x({
                  tabbingDirection: "backwards"
                });
                CM(b);
              }
            }
          )
        ]
      }
    );
  }
);
C7.displayName = E7;
var O7 = "ToastFocusProxy", M5 = M.forwardRef(
  (e, t) => {
    const { __scopeToast: n, onFocusFromOutsideViewport: r, ...a } = e, s = j2(O7, n);
    return /* @__PURE__ */ E.jsx(
      qR,
      {
        tabIndex: 0,
        ...a,
        ref: t,
        style: { position: "fixed" },
        onFocus: (l) => {
          const c = l.relatedTarget;
          !s.viewport?.contains(c) && r();
        }
      }
    );
  }
);
M5.displayName = O7;
var cS = "Toast", Mce = "toast.swipeStart", Nce = "toast.swipeMove", Rce = "toast.swipeCancel", Ace = "toast.swipeEnd", M7 = M.forwardRef(
  (e, t) => {
    const { forceMount: n, open: r, defaultOpen: a, onOpenChange: s, ...l } = e, [c, d] = gd({
      prop: r,
      defaultProp: a ?? !0,
      onChange: s,
      caller: cS
    });
    return /* @__PURE__ */ E.jsx(Hs, { present: n || c, children: /* @__PURE__ */ E.jsx(
      Dce,
      {
        open: c,
        ...l,
        ref: t,
        onClose: () => d(!1),
        onPause: Ra(e.onPause),
        onResume: Ra(e.onResume),
        onSwipeStart: Ze(e.onSwipeStart, (p) => {
          p.currentTarget.setAttribute("data-swipe", "start");
        }),
        onSwipeMove: Ze(e.onSwipeMove, (p) => {
          const { x: m, y: h } = p.detail.delta;
          p.currentTarget.setAttribute("data-swipe", "move"), p.currentTarget.style.setProperty("--radix-toast-swipe-move-x", `${m}px`), p.currentTarget.style.setProperty("--radix-toast-swipe-move-y", `${h}px`);
        }),
        onSwipeCancel: Ze(e.onSwipeCancel, (p) => {
          p.currentTarget.setAttribute("data-swipe", "cancel"), p.currentTarget.style.removeProperty("--radix-toast-swipe-move-x"), p.currentTarget.style.removeProperty("--radix-toast-swipe-move-y"), p.currentTarget.style.removeProperty("--radix-toast-swipe-end-x"), p.currentTarget.style.removeProperty("--radix-toast-swipe-end-y");
        }),
        onSwipeEnd: Ze(e.onSwipeEnd, (p) => {
          const { x: m, y: h } = p.detail.delta;
          p.currentTarget.setAttribute("data-swipe", "end"), p.currentTarget.style.removeProperty("--radix-toast-swipe-move-x"), p.currentTarget.style.removeProperty("--radix-toast-swipe-move-y"), p.currentTarget.style.setProperty("--radix-toast-swipe-end-x", `${m}px`), p.currentTarget.style.setProperty("--radix-toast-swipe-end-y", `${h}px`), d(!1);
        })
      }
    ) });
  }
);
M7.displayName = cS;
var [jce, Pce] = k7(cS, {
  onClose() {
  }
}), Dce = M.forwardRef(
  (e, t) => {
    const {
      __scopeToast: n,
      type: r = "foreground",
      duration: a,
      open: s,
      onClose: l,
      onEscapeKeyDown: c,
      onPause: d,
      onResume: p,
      onSwipeStart: m,
      onSwipeMove: h,
      onSwipeCancel: v,
      onSwipeEnd: y,
      ...w
    } = e, x = j2(cS, n), [b, k] = M.useState(null), C = Wn(t, (I) => k(I)), _ = M.useRef(null), O = M.useRef(null), N = a || x.duration, R = M.useRef(0), j = M.useRef(N), D = M.useRef(0), { onToastAdd: $, onToastRemove: z } = x, B = Ra(() => {
      b?.contains(document.activeElement) && x.viewport?.focus(), l();
    }), P = M.useCallback(
      (I) => {
        !I || I === 1 / 0 || (window.clearTimeout(D.current), R.current = (/* @__PURE__ */ new Date()).getTime(), D.current = window.setTimeout(B, I));
      },
      [B]
    );
    M.useEffect(() => {
      const I = x.viewport;
      if (I) {
        const G = () => {
          P(j.current), p?.();
        }, L = () => {
          const K = (/* @__PURE__ */ new Date()).getTime() - R.current;
          j.current = j.current - K, window.clearTimeout(D.current), d?.();
        };
        return I.addEventListener(C5, L), I.addEventListener(O5, G), () => {
          I.removeEventListener(C5, L), I.removeEventListener(O5, G);
        };
      }
    }, [x.viewport, N, d, p, P]), M.useEffect(() => {
      s && !x.isClosePausedRef.current && P(N);
    }, [s, N, x.isClosePausedRef, P]), M.useEffect(() => ($(), () => z()), [$, z]);
    const W = M.useMemo(() => b ? $7(b) : null, [b]);
    return x.viewport ? /* @__PURE__ */ E.jsxs(E.Fragment, { children: [
      W && /* @__PURE__ */ E.jsx(
        $ce,
        {
          __scopeToast: n,
          role: "status",
          "aria-live": r === "foreground" ? "assertive" : "polite",
          children: W
        }
      ),
      /* @__PURE__ */ E.jsx(jce, { scope: n, onClose: B, children: xm.createPortal(
        /* @__PURE__ */ E.jsx(GR.ItemSlot, { scope: n, children: /* @__PURE__ */ E.jsx(
          nee,
          {
            asChild: !0,
            onEscapeKeyDown: Ze(c, () => {
              x.isFocusedToastEscapeKeyDownRef.current || B(), x.isFocusedToastEscapeKeyDownRef.current = !1;
            }),
            children: /* @__PURE__ */ E.jsx(
              Kt.li,
              {
                tabIndex: 0,
                "data-state": s ? "open" : "closed",
                "data-swipe-direction": x.swipeDirection,
                ...w,
                ref: C,
                style: { userSelect: "none", touchAction: "none", ...e.style },
                onKeyDown: Ze(e.onKeyDown, (I) => {
                  I.key === "Escape" && (c?.(I.nativeEvent), I.nativeEvent.defaultPrevented || (x.isFocusedToastEscapeKeyDownRef.current = !0, B()));
                }),
                onPointerDown: Ze(e.onPointerDown, (I) => {
                  I.button === 0 && (_.current = { x: I.clientX, y: I.clientY });
                }),
                onPointerMove: Ze(e.onPointerMove, (I) => {
                  if (!_.current) return;
                  const G = I.clientX - _.current.x, L = I.clientY - _.current.y, K = !!O.current, q = ["left", "right"].includes(x.swipeDirection), Z = ["left", "up"].includes(x.swipeDirection) ? Math.min : Math.max, V = q ? Z(0, G) : 0, F = q ? 0 : Z(0, L), X = I.pointerType === "touch" ? 10 : 2, U = { x: V, y: F }, H = { originalEvent: I, delta: U };
                  K ? (O.current = U, ak(Nce, h, H, {
                    discrete: !1
                  })) : n6(U, x.swipeDirection, X) ? (O.current = U, ak(Mce, m, H, {
                    discrete: !1
                  }), I.target.setPointerCapture(I.pointerId)) : (Math.abs(G) > X || Math.abs(L) > X) && (_.current = null);
                }),
                onPointerUp: Ze(e.onPointerUp, (I) => {
                  const G = O.current, L = I.target;
                  if (L.hasPointerCapture(I.pointerId) && L.releasePointerCapture(I.pointerId), O.current = null, _.current = null, G) {
                    const K = I.currentTarget, q = { originalEvent: I, delta: G };
                    n6(G, x.swipeDirection, x.swipeThreshold) ? ak(Ace, y, q, {
                      discrete: !0
                    }) : ak(
                      Rce,
                      v,
                      q,
                      {
                        discrete: !0
                      }
                    ), K.addEventListener("click", (Z) => Z.preventDefault(), {
                      once: !0
                    });
                  }
                })
              }
            )
          }
        ) }),
        x.viewport
      ) })
    ] }) : null;
  }
), $ce = (e) => {
  const { __scopeToast: t, children: n, ...r } = e, a = j2(cS, t), [s, l] = M.useState(!1), [c, d] = M.useState(!1);
  return Ice(() => l(!0)), M.useEffect(() => {
    const p = window.setTimeout(() => d(!0), 1e3);
    return () => window.clearTimeout(p);
  }, []), c ? null : /* @__PURE__ */ E.jsx(h2, { asChild: !0, children: /* @__PURE__ */ E.jsx(qR, { ...r, children: s && /* @__PURE__ */ E.jsxs(E.Fragment, { children: [
    a.label,
    " ",
    n
  ] }) }) });
}, Tce = "ToastTitle", N7 = M.forwardRef(
  (e, t) => {
    const { __scopeToast: n, ...r } = e;
    return /* @__PURE__ */ E.jsx(Kt.div, { ...r, ref: t });
  }
);
N7.displayName = Tce;
var Lce = "ToastDescription", R7 = M.forwardRef(
  (e, t) => {
    const { __scopeToast: n, ...r } = e;
    return /* @__PURE__ */ E.jsx(Kt.div, { ...r, ref: t });
  }
);
R7.displayName = Lce;
var A7 = "ToastAction", j7 = M.forwardRef(
  (e, t) => {
    const { altText: n, ...r } = e;
    return n.trim() ? /* @__PURE__ */ E.jsx(D7, { altText: n, asChild: !0, children: /* @__PURE__ */ E.jsx(KR, { ...r, ref: t }) }) : (console.error(
      `Invalid prop \`altText\` supplied to \`${A7}\`. Expected non-empty \`string\`.`
    ), null);
  }
);
j7.displayName = A7;
var P7 = "ToastClose", KR = M.forwardRef(
  (e, t) => {
    const { __scopeToast: n, ...r } = e, a = Pce(P7, n);
    return /* @__PURE__ */ E.jsx(D7, { asChild: !0, children: /* @__PURE__ */ E.jsx(
      Kt.button,
      {
        type: "button",
        ...r,
        ref: t,
        onClick: Ze(e.onClick, a.onClose)
      }
    ) });
  }
);
KR.displayName = P7;
var D7 = M.forwardRef((e, t) => {
  const { __scopeToast: n, altText: r, ...a } = e;
  return /* @__PURE__ */ E.jsx(
    Kt.div,
    {
      "data-radix-toast-announce-exclude": "",
      "data-radix-toast-announce-alt": r || void 0,
      ...a,
      ref: t
    }
  );
});
function $7(e) {
  const t = [];
  return Array.from(e.childNodes).forEach((n) => {
    if (n.nodeType === n.TEXT_NODE && n.textContent && t.push(n.textContent), zce(n)) {
      const r = n.ariaHidden || n.hidden || n.style.display === "none", a = n.dataset.radixToastAnnounceExclude === "";
      if (!r)
        if (a) {
          const s = n.dataset.radixToastAnnounceAlt;
          s && t.push(s);
        } else
          t.push(...$7(n));
    }
  }), t;
}
function ak(e, t, n, { discrete: r }) {
  const a = n.originalEvent.currentTarget, s = new CustomEvent(e, { bubbles: !0, cancelable: !0, detail: n });
  t && a.addEventListener(e, t, { once: !0 }), r ? lR(a, s) : a.dispatchEvent(s);
}
var n6 = (e, t, n = 0) => {
  const r = Math.abs(e.x), a = Math.abs(e.y), s = r > a;
  return t === "left" || t === "right" ? s && r > n : !s && a > n;
};
function Ice(e = () => {
}) {
  const t = Ra(e);
  bc(() => {
    let n = 0, r = 0;
    return n = window.requestAnimationFrame(() => r = window.requestAnimationFrame(t)), () => {
      window.cancelAnimationFrame(n), window.cancelAnimationFrame(r);
    };
  }, [t]);
}
function zce(e) {
  return e.nodeType === e.ELEMENT_NODE;
}
function Fce(e) {
  const t = [], n = document.createTreeWalker(e, NodeFilter.SHOW_ELEMENT, {
    acceptNode: (r) => {
      const a = r.tagName === "INPUT" && r.type === "hidden";
      return r.disabled || r.hidden || a ? NodeFilter.FILTER_SKIP : r.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
    }
  });
  for (; n.nextNode(); ) t.push(n.currentNode);
  return t;
}
function CM(e) {
  const t = document.activeElement;
  return e.some((n) => n === t ? !0 : (n.focus(), document.activeElement !== t));
}
var Bce = _7, Uce = C7, Vce = M7, Hce = N7, qce = R7, Wce = j7, Gce = KR;
const Ro = [];
for (let e = 0; e < 256; ++e)
  Ro.push((e + 256).toString(16).slice(1));
function Kce(e, t = 0) {
  return (Ro[e[t + 0]] + Ro[e[t + 1]] + Ro[e[t + 2]] + Ro[e[t + 3]] + "-" + Ro[e[t + 4]] + Ro[e[t + 5]] + "-" + Ro[e[t + 6]] + Ro[e[t + 7]] + "-" + Ro[e[t + 8]] + Ro[e[t + 9]] + "-" + Ro[e[t + 10]] + Ro[e[t + 11]] + Ro[e[t + 12]] + Ro[e[t + 13]] + Ro[e[t + 14]] + Ro[e[t + 15]]).toLowerCase();
}
let OM;
const Xce = new Uint8Array(16);
function Yce() {
  if (!OM) {
    if (typeof crypto > "u" || !crypto.getRandomValues)
      throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
    OM = crypto.getRandomValues.bind(crypto);
  }
  return OM(Xce);
}
const Qce = typeof crypto < "u" && crypto.randomUUID && crypto.randomUUID.bind(crypto), r6 = { randomUUID: Qce };
function Jce(e, t, n) {
  e = e || {};
  const r = e.random ?? e.rng?.() ?? Yce();
  if (r.length < 16)
    throw new Error("Random bytes length must be >= 16");
  return r[6] = r[6] & 15 | 64, r[8] = r[8] & 63 | 128, Kce(r);
}
function XR(e, t, n) {
  return r6.randomUUID && !e ? r6.randomUUID() : Jce(e);
}
const T7 = M.createContext(
  void 0
), L7 = M.createContext(
  void 0
), Zce = 350, ede = ({ children: e, fixedHeight: t, duration: n = 5e3, maxVisible: r = 3, ...a }) => {
  const [s, l] = M.useState(/* @__PURE__ */ new Map()), c = M.useRef(/* @__PURE__ */ new Map()), d = M.useRef(null), p = M.useRef(!0), m = M.useCallback(() => {
    const k = Array.from(c.current).reverse();
    if (t) {
      const C = t;
      k.forEach(([, _], O) => {
        if (!_) return;
        _.setAttribute("data-front", String(O === 0)), _.setAttribute("data-hidden", String(O >= r)), _.style.setProperty("--index", String(O)), _.style.setProperty("--height", `${t}px`), _.style.setProperty("--front-height", `${C}px`);
        const N = t * O;
        _.style.setProperty("--hover-offset-y", `-${N}px`);
      });
    } else {
      const C = k.map(([, O]) => {
        if (!O) return 0;
        const N = O.querySelector(
          ".ToastInner"
        );
        if (!N) return O.clientHeight;
        const R = N.style.height;
        N.style.height = "auto";
        const j = O.clientHeight;
        return N.style.height = R, j;
      }), _ = C[0] || 0;
      k.forEach(([, O], N) => {
        if (!O) return;
        const R = C[N];
        O.setAttribute("data-front", String(N === 0)), O.setAttribute("data-hidden", String(N >= r)), O.style.setProperty("--index", String(N)), O.style.setProperty("--height", `${R}px`), O.style.setProperty("--front-height", `${_}px`);
        const j = C.slice(0, N).reduce((D, $) => D + $, 0);
        O.style.setProperty("--hover-offset-y", `-${j}px`);
      });
    }
  }, [t, r]), h = M.useCallback(
    (k) => {
      l((C) => {
        const _ = new Map(C);
        return _.set(XR(), {
          ...k,
          duration: k.duration || n,
          open: !0
        }), _;
      });
    },
    [n]
  ), v = M.useCallback((k) => {
    p.current && l((C) => {
      const _ = new Map(C);
      return _.delete(k), _;
    });
  }, []), y = M.useCallback(
    (k) => h({ ...k, status: k.status || "default" }),
    [h]
  ), w = M.useCallback(
    (k) => h({ ...k, status: "success" }),
    [h]
  ), x = M.useCallback(
    (k) => h({ ...k, status: "error" }),
    [h]
  );
  M.useEffect(() => (p.current = !0, () => {
    p.current = !1;
  }), []), M.useEffect(() => {
    const k = d.current;
    if (k) {
      const C = () => {
        c.current.forEach((N) => {
          N.setAttribute("data-hovering", "true");
        });
      }, _ = (N) => {
        (!k.contains(N.target) || k === N.target) && c.current.forEach((R) => {
          R.setAttribute("data-hovering", "false");
        });
      }, O = () => {
        c.current.forEach((N) => {
          N.setAttribute("data-hovering", "false");
        });
      };
      return k.addEventListener("pointermove", C), k.addEventListener("pointerleave", O), k.addEventListener("focusin", C), k.addEventListener("focusout", _), () => {
        k.removeEventListener("pointermove", C), k.removeEventListener("pointerleave", O), k.removeEventListener("focusin", C), k.removeEventListener("focusout", _);
      };
    }
  }, []);
  const b = M.useMemo(
    () => Object.assign(y, {
      success: w,
      error: x
    }),
    [y, w, x]
  );
  return /* @__PURE__ */ E.jsx(T7.Provider, { value: b, children: /* @__PURE__ */ E.jsx(
    L7.Provider,
    {
      value: M.useMemo(
        () => ({
          toastElementsMapRef: c,
          sortToasts: m
        }),
        [m]
      ),
      children: /* @__PURE__ */ E.jsxs(Bce, { ...a, children: [
        e,
        Array.from(s).map(([k, C]) => /* @__PURE__ */ E.jsx(
          rde,
          {
            id: k,
            toast: C,
            onOpenChange: (_) => {
              _ || (c.current.delete(k), m(), l((O) => {
                const N = new Map(O), R = N.get(k);
                return R && N.set(k, { ...R, open: !1 }), N;
              }), setTimeout(() => {
                v(k);
              }, Zce));
            }
          },
          k
        )),
        /* @__PURE__ */ E.jsx(
          Uce,
          {
            ref: d,
            className: "ToastViewport",
            style: t ? {
              "--fixed-toast-height": `${t}px`
            } : void 0
          }
        )
      ] })
    }
  ) });
}, tde = () => {
  const e = M.useContext(T7);
  if (e) return e;
  throw new Error("useToast must be used within Toasts");
}, nde = () => {
  const e = M.useContext(L7);
  if (e) return e;
  throw new Error("useToastContext must be used within Toasts");
}, rde = ({
  onOpenChange: e,
  toast: t,
  id: n,
  ...r
}) => {
  const a = M.useRef(null), s = nde(), { sortToasts: l, toastElementsMapRef: c } = s, d = c.current;
  return M.useLayoutEffect(() => (a.current && (d.set(n, a.current), l()), () => {
    d.delete(n), l();
  }), [n, l, d]), /* @__PURE__ */ E.jsx(
    Vce,
    {
      ...r,
      ref: a,
      type: t.type,
      duration: t.duration,
      className: "ToastRoot",
      onOpenChange: e,
      open: t.open,
      children: /* @__PURE__ */ E.jsxs("div", { className: "ToastInner", "data-status": t.status, children: [
        /* @__PURE__ */ E.jsx(ode, { status: t.status }),
        t.title && /* @__PURE__ */ E.jsx(Hce, { className: "ToastTitle", children: t.title }),
        /* @__PURE__ */ E.jsx(qce, { className: "ToastDescription", children: t.description }),
        t.action && /* @__PURE__ */ E.jsx(
          Wce,
          {
            className: "ToastAction Button small green",
            altText: t.action.altText,
            onClick: t.action.onClick,
            asChild: !0,
            children: /* @__PURE__ */ E.jsx("button", { children: t.action.label })
          }
        ),
        /* @__PURE__ */ E.jsx(Gce, { "aria-label": "Close", className: "ToastClose", children: /* @__PURE__ */ E.jsx(_2, { style: { fontSize: "12px" } }) })
      ] })
    }
  );
}, ode = ({ status: e }) => e !== "default" && e ? /* @__PURE__ */ E.jsxs("div", { style: { gridArea: "icon", alignSelf: "start" }, children: [
  e === "success" && /* @__PURE__ */ E.jsx(bae, { style: { color: "#61d345", fontSize: "20px" } }),
  e === "error" && /* @__PURE__ */ E.jsx(wae, { style: { color: "#ff4b4b", fontSize: "20px" } })
] }) : null, ade = {}, o6 = (e) => {
  let t;
  const n = /* @__PURE__ */ new Set(), r = (c, d) => {
    const p = typeof c == "function" ? c(t) : c;
    if (!Object.is(p, t)) {
      const m = t;
      t = d ?? (typeof p != "object" || p === null) ? p : Object.assign({}, t, p), n.forEach((h) => h(t, m));
    }
  }, a = () => t, s = { setState: r, getState: a, getInitialState: () => l, subscribe: (c) => (n.add(c), () => n.delete(c)), destroy: () => {
    (ade ? "production" : void 0) !== "production" && console.warn(
      "[DEPRECATED] The `destroy` method will be unsupported in a future version. Instead use unsubscribe function returned by subscribe. Everything will be garbage-collected if store is garbage-collected."
    ), n.clear();
  } }, l = t = e(r, a, s);
  return s;
}, I7 = (e) => e ? o6(e) : o6;
var a6 = { exports: {} }, MM = {}, i6 = { exports: {} }, NM = {}, s6;
function ide() {
  if (s6) return NM;
  s6 = 1;
  var e = Qn;
  function t(h, v) {
    return h === v && (h !== 0 || 1 / h === 1 / v) || h !== h && v !== v;
  }
  var n = typeof Object.is == "function" ? Object.is : t, r = e.useState, a = e.useEffect, s = e.useLayoutEffect, l = e.useDebugValue;
  function c(h, v) {
    var y = v(), w = r({ inst: { value: y, getSnapshot: v } }), x = w[0].inst, b = w[1];
    return s(
      function() {
        x.value = y, x.getSnapshot = v, d(x) && b({ inst: x });
      },
      [h, y, v]
    ), a(
      function() {
        return d(x) && b({ inst: x }), h(function() {
          d(x) && b({ inst: x });
        });
      },
      [h]
    ), l(y), y;
  }
  function d(h) {
    var v = h.getSnapshot;
    h = h.value;
    try {
      var y = v();
      return !n(h, y);
    } catch {
      return !0;
    }
  }
  function p(h, v) {
    return v();
  }
  var m = typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u" ? p : c;
  return NM.useSyncExternalStore = e.useSyncExternalStore !== void 0 ? e.useSyncExternalStore : m, NM;
}
var l6;
function sde() {
  return l6 || (l6 = 1, i6.exports = ide()), i6.exports;
}
var u6;
function lde() {
  if (u6) return MM;
  u6 = 1;
  var e = Qn, t = sde();
  function n(p, m) {
    return p === m && (p !== 0 || 1 / p === 1 / m) || p !== p && m !== m;
  }
  var r = typeof Object.is == "function" ? Object.is : n, a = t.useSyncExternalStore, s = e.useRef, l = e.useEffect, c = e.useMemo, d = e.useDebugValue;
  return MM.useSyncExternalStoreWithSelector = function(p, m, h, v, y) {
    var w = s(null);
    if (w.current === null) {
      var x = { hasValue: !1, value: null };
      w.current = x;
    } else x = w.current;
    w = c(
      function() {
        function k(R) {
          if (!C) {
            if (C = !0, _ = R, R = v(R), y !== void 0 && x.hasValue) {
              var j = x.value;
              if (y(j, R))
                return O = j;
            }
            return O = R;
          }
          if (j = O, r(_, R)) return j;
          var D = v(R);
          return y !== void 0 && y(j, D) ? (_ = R, j) : (_ = R, O = D);
        }
        var C = !1, _, O, N = h === void 0 ? null : h;
        return [
          function() {
            return k(m());
          },
          N === null ? void 0 : function() {
            return k(N());
          }
        ];
      },
      [m, h, v, y]
    );
    var b = a(p, w[0], w[1]);
    return l(
      function() {
        x.hasValue = !0, x.value = b;
      },
      [b]
    ), d(b), b;
  }, MM;
}
var c6;
function ude() {
  return c6 || (c6 = 1, a6.exports = lde()), a6.exports;
}
var cde = ude();
const z7 = /* @__PURE__ */ Oc(cde), F7 = {}, { useDebugValue: dde } = Qn, { useSyncExternalStoreWithSelector: fde } = z7;
let d6 = !1;
const pde = (e) => e;
function mde(e, t = pde, n) {
  (F7 ? "production" : void 0) !== "production" && n && !d6 && (console.warn(
    "[DEPRECATED] Use `createWithEqualityFn` instead of `create` or use `useStoreWithEqualityFn` instead of `useStore`. They can be imported from 'zustand/traditional'. https://github.com/pmndrs/zustand/discussions/1937"
  ), d6 = !0);
  const r = fde(
    e.subscribe,
    e.getState,
    e.getServerState || e.getInitialState,
    t,
    n
  );
  return dde(r), r;
}
const f6 = (e) => {
  (F7 ? "production" : void 0) !== "production" && typeof e != "function" && console.warn(
    "[DEPRECATED] Passing a vanilla store will be unsupported in a future version. Instead use `import { useStore } from 'zustand'`."
  );
  const t = typeof e == "function" ? I7(e) : e, n = (r, a) => mde(t, r, a);
  return Object.assign(n, t), n;
}, ji = (e) => e ? f6(e) : f6;
class Rc {
  constructor(t) {
    this.context = t;
  }
  get communicationManager() {
    return this.context.worker.getCommunicationManager();
  }
  get eventManager() {
    return this.context.worker.getEventManager();
  }
  get hookManager() {
    return this.context.worker.getHookManager();
  }
  get nodeManager() {
    return this.context.worker.getNodeManager();
  }
  get syncManager() {
    return this.context.worker.getSyncManager();
  }
  get connectionHealthManager() {
    return this.context.worker.getConnectionHealthManager();
  }
  get edgeManager() {
    return this.context.worker.getEdgeManager();
  }
  get groupManager() {
    return this.context.worker.getGroupManager();
  }
  get libraryManager() {
    return this.context.worker.getLibraryManager();
  }
}
const ik = 2e3;
class hde extends Rc {
  constructor(t) {
    super(t), this._responsive = !1, this._last_pong = 0, this._last_pong = Date.now() - ik * 100;
  }
  start() {
    this.stop(), this.pingInterval = setInterval(() => {
      this.context.worker.is_open && this.context.worker.send({ type: "ping" });
    }, ik), this.responsivenessCheckInterval = setInterval(() => {
      this._responsive = Date.now() - this._last_pong <= ik * 3;
    }, ik * 2);
  }
  stop() {
    this.pingInterval && clearInterval(this.pingInterval), this.responsivenessCheckInterval && clearInterval(this.responsivenessCheckInterval);
  }
  receivePong() {
    this._last_pong = Date.now(), this._responsive = !0;
  }
  isResponsive() {
    return this._responsive;
  }
}
const p6 = (e, t) => {
  e.properties = e.properties || {}, t.pos && (e.properties["frontend:pos"] = t.pos), t.size && (e.properties["frontend:size"] = t.size), t.collapsed !== void 0 && (e.properties["frontend:collapsed"] = !!t.collapsed);
}, m6 = 2e3, h6 = 2e3;
class gde extends Rc {
  constructor(t) {
    super(t), this._local_nodeupdates = /* @__PURE__ */ new Map(), this._local_groupupdates = /* @__PURE__ */ new Map(), this._after_next_sync = [], this.on_sync_complete = t.on_sync_complete || (async () => {
    });
  }
  start() {
    this._nodeupdatetimer = setTimeout(() => {
      this.sync_local_node_updates();
    }, m6), this._groupupdatetimer = setTimeout(() => {
      this.sync_local_group_updates();
    }, h6);
  }
  stop() {
    this._nodeupdatetimer && clearTimeout(this._nodeupdatetimer), this._groupupdatetimer && clearTimeout(this._groupupdatetimer);
  }
  async stepwise_fullsync() {
    if (!this.context.worker._zustand || !this.context.worker.is_open) return;
    await this.sync_lib(), await this.sync_external_worker(), await this.sync_funcnodes_plugins(), await this.sync_nodespace(), await this.sync_view_state(), await this.on_sync_complete(this.context.worker);
    const t = this._after_next_sync.splice(0);
    for (const n of t)
      await n(this.context.worker), this._after_next_sync.includes(n) && this._after_next_sync.splice(this._after_next_sync.indexOf(n), 1);
  }
  add_after_next_sync(t) {
    this._after_next_sync.push(t);
  }
  remove_after_next_sync(t) {
    this._after_next_sync = this._after_next_sync.filter(
      (n) => n !== t
    );
  }
  async sync_lib() {
    if (!this.context.worker._zustand || !this.context.worker.is_open) return;
    const t = await this.communicationManager._send_cmd({
      cmd: "get_library",
      wait_for_response: !0,
      retries: 2,
      unique: !0
    });
    this.context.worker._zustand.lib.libstate.getState().set({
      lib: t
    });
  }
  async sync_external_worker() {
    if (!this.context.worker._zustand || !this.context.worker.is_open) return;
    const t = await this.communicationManager._send_cmd({
      cmd: "get_worker_dependencies",
      wait_for_response: !0,
      unique: !0
    });
    this.context.worker._zustand.lib.libstate.getState().set({
      external_worker: t
    });
  }
  async sync_funcnodes_plugins() {
    if (!this.context.worker._zustand || !this.context.worker.is_open) return;
    const t = await this.context.worker.getCommunicationManager()._send_cmd({
      cmd: "get_plugin_keys",
      wait_for_response: !0,
      unique: !0,
      kwargs: { type: "react" }
    });
    for (const n of t) {
      const r = await this.context.worker.getCommunicationManager()._send_cmd({
        cmd: "get_plugin",
        wait_for_response: !0,
        kwargs: { key: n, type: "react" },
        unique: !0
      });
      this.context.worker._zustand.add_packed_plugin(n, r);
    }
  }
  async sync_view_state() {
    if (!this.context.worker._zustand || !this.context.worker.is_open) return;
    const t = await this.context.worker.getCommunicationManager()._send_cmd({
      cmd: "view_state",
      wait_for_response: !0,
      unique: !0
    });
    t.renderoptions && this.context.worker._zustand.update_render_options(t.renderoptions);
    const n = t.nodes;
    if (n)
      for (const r in n) {
        const a = {};
        p6(a, n[r]), this.context.worker._zustand.on_node_action({
          type: "update",
          node: a,
          id: r,
          from_remote: !0
        });
      }
  }
  async sync_nodespace() {
    if (!this.context.worker._zustand || !this.context.worker.is_open) return;
    const t = await this.context.worker.getCommunicationManager()._send_cmd({
      cmd: "get_nodes",
      kwargs: { with_frontend: !0 },
      wait_for_response: !0,
      unique: !0
    });
    for (const a of t)
      this.eventManager._receive_node_added(a);
    const n = await this.context.worker.getCommunicationManager()._send_cmd({
      cmd: "get_edges",
      wait_for_response: !0,
      unique: !0
    });
    for (const a of n)
      this.eventManager._receive_edge_added(...a);
    const r = await this.context.worker.getCommunicationManager()._send_cmd({
      cmd: "get_groups",
      kwargs: {},
      wait_for_response: !0,
      unique: !0
    });
    this.eventManager._receive_groups(r);
  }
  async fullsync() {
    if (!this.context.worker._zustand || !this.context.worker.is_open) return;
    let t;
    for (; ; )
      try {
        t = await this.communicationManager._send_cmd({
          cmd: "full_state",
          unique: !0
        });
        break;
      } catch (a) {
        a instanceof Error ? this.context.worker._zustand.logger.error("Error in fullsync", a) : this.context.worker._zustand.logger.error(
          "Error in fullsync",
          new Error(JSON.stringify(a))
        );
      }
    this.context.worker._zustand.logger.debug("Full state", t), this.context.worker._zustand.lib.libstate.getState().set({
      lib: t.backend.lib,
      external_worker: t.worker_dependencies
    }), t.view.renderoptions && this.context.worker._zustand.update_render_options(
      t.view.renderoptions
    );
    const n = t.view.nodes;
    for (const a of t.backend.nodes) {
      const s = n[a.id];
      s !== void 0 && p6(a, s), this.eventManager._receive_node_added(a);
    }
    for (const a of t.backend.edges)
      this.eventManager._receive_edge_added(...a);
    const r = t.backend.groups;
    r && this.eventManager._receive_groups(r);
  }
  sync_local_node_updates() {
    clearTimeout(this._nodeupdatetimer), this._local_nodeupdates.forEach(async (t, n) => {
      const r = await this.context.worker.getCommunicationManager()._send_cmd({
        cmd: "update_node",
        kwargs: { nid: n, data: t },
        wait_for_response: !0
      });
      this.context.worker._zustand && Object.keys(r).length > 0 && this.context.worker._zustand.on_node_action({
        type: "update",
        node: r,
        id: n,
        from_remote: !0
      });
    }), this._local_nodeupdates.clear(), this._nodeupdatetimer = setTimeout(() => {
      this.sync_local_node_updates();
    }, m6);
  }
  sync_local_group_updates() {
    clearTimeout(this._groupupdatetimer), this._local_groupupdates.forEach(async (t, n) => {
      const r = await this.communicationManager._send_cmd({
        cmd: "update_group",
        kwargs: { gid: n, data: t },
        wait_for_response: !0
      });
      this.context.worker._zustand && this.context.worker._zustand.on_group_action({
        type: "update",
        group: r,
        id: n,
        from_remote: !0
      });
    }), this._local_groupupdates.clear(), this._groupupdatetimer = setTimeout(() => {
      this.sync_local_group_updates();
    }, h6);
  }
  locally_update_node(t) {
    const n = this._local_nodeupdates.get(t.id);
    if (n) {
      const { new_obj: r, change: a } = rd(n, t.node);
      a && this._local_nodeupdates.set(t.id, r);
    } else
      this._local_nodeupdates.set(t.id, t.node);
    t.immediate && this.sync_local_node_updates();
  }
  locally_update_group(t) {
    const n = this._local_groupupdates.get(t.id);
    if (n) {
      const { new_obj: r, change: a } = rd(n, t.group);
      a && this._local_groupupdates.set(t.id, r);
    } else
      this._local_groupupdates.set(t.id, t.group);
    t.immediate && this.sync_local_group_updates();
  }
}
class ml {
  /**
   * Creates a new DataStructure instance.
   *
   * @param props - Configuration object containing data and MIME type
   */
  constructor({ data: t, mime: n }) {
    this._data = t, this._mime = n;
  }
  /**
   * Gets the raw wrapped data.
   *
   * @returns The original data in its native type
   */
  get data() {
    return this._data;
  }
  /**
   * Gets the data cast to the expected return type.
   * This is a type assertion and should be overridden in subclasses for proper type conversion.
   *
   * @returns The data cast to type R
   */
  get value() {
    return this._data;
  }
  /**
   * Gets the MIME type of the wrapped data.
   *
   * @returns The MIME type string
   */
  get mime() {
    return this._mime;
  }
  /**
   * Returns a string representation of the DataStructure.
   * The format varies based on the data type:
   * - ArrayBuffer: shows byte length
   * - Blob: shows size
   * - String/Array: shows length
   * - Object: shows number of keys
   * - Other types: shows only MIME type
   *
   * @returns String representation in format "DataStructure(size,mime)" or "DataStructure(mime)"
   */
  toString() {
    return this._data instanceof ArrayBuffer ? `DataStructure(${this._data.byteLength},${this._mime})` : this._data instanceof Blob ? `DataStructure(${this._data.size},${this._mime})` : this._data instanceof String ? `DataStructure(${this._data.length},${this._mime})` : this._data instanceof Array ? `DataStructure(${this._data.length},${this._mime})` : this._data instanceof Object ? `DataStructure(${Object.keys(this._data).length},${this._mime})` : `DataStructure(${this._mime})`;
  }
  /**
   * Returns the JSON representation of this DataStructure.
   * Currently delegates to toString() method.
   *
   * @returns JSON string representation
   */
  toJSON() {
    return this.toString();
  }
  /**
   * Cleans up resources associated with this DataStructure.
   * Base implementation does nothing, but subclasses may override to release resources.
   */
  dispose() {
  }
}
class B7 extends ml {
  constructor({ data: t, mime: n }) {
    super({ data: P2(t), mime: n });
  }
  get objectUrl() {
    if (this._objectUrl)
      return this._objectUrl;
    const t = this.data instanceof Blob ? this.data : new Blob([this.data], { type: this.mime });
    return this._objectUrl = URL.createObjectURL(t), this._objectUrl;
  }
  dispose() {
    this._objectUrl && URL.revokeObjectURL(this._objectUrl), super.dispose();
  }
  get value() {
    return this.objectUrl;
  }
}
const P2 = (e) => {
  if (e instanceof ArrayBuffer)
    return e;
  const t = ArrayBuffer.isView(e) ? new Uint8Array(e.buffer, e.byteOffset, e.byteLength) : new Uint8Array(e), n = new ArrayBuffer(t.byteLength);
  return new Uint8Array(n).set(t), n;
}, vde = {
  x: (e, t) => null,
  //  pad byte 	no value 	(7 )
  c: (e, t) => new DataView(e).getInt8(0),
  //  char 	bytes of length 1 	1 	b 	signed char 	integer 	1 	(1 ), (2 )
  B: (e, t) => new DataView(e).getUint8(0),
  //  unsigned char 	integer 	1 	(2 )
  "?": (e, t) => new DataView(e).getInt8(0) === 1,
  //  _Bool 	bool 	1 	(1 )
  h: (e, t) => new DataView(e).getInt16(0, t),
  //  short 	integer 	2 	(2 )
  H: (e, t) => new DataView(e).getUint16(0, t),
  //  unsigned short 	integer 	2 	(2 )
  i: (e, t) => new DataView(e).getInt32(0, t),
  //  int 	integer 	4 	(2 )
  I: (e, t) => new DataView(e).getUint32(0, t),
  //  unsigned int 	integer 	4 	(2 )
  l: (e, t) => new DataView(e).getInt32(0, t),
  //  long 	integer 	4 	(2 )
  L: (e, t) => new DataView(e).getUint32(0, t),
  //  unsigned long 	integer 	4 	(2 )
  q: (e, t) => Number(
    new DataView(e).getBigInt64(0, t)
  ),
  //  long long 	integer 	8 	(2 )
  Q: (e, t) => Number(
    new DataView(e).getBigUint64(0, t)
  ),
  //  unsigned long long 	integer 	8 	(2 )
  n: (e, t) => Number(
    new DataView(e).getBigInt64(0, t)
  ),
  //  ssize_t 	integer 	(3 )
  N: (e, t) => Number(
    new DataView(e).getBigUint64(0, t)
  ),
  //  size_t 	integer 	(3 )
  // "e":(data:ArrayBufferLike)=>{return new DataView(to_arraybuffer(data)).getFloat16(0)}, //  (6 ) float 	2 	(4 )
  f: (e, t) => new DataView(e).getFloat32(0, t),
  //  float 	float 	4 	(4 )
  d: (e, t) => new DataView(e).getFloat64(0, t),
  //  double 	float 	8 	(4 )
  s: (e, t) => new TextDecoder().decode(e),
  //  char[] 	bytes 	(9 )
  p: (e, t) => new TextDecoder().decode(e),
  //  char[] 	bytes 	(8 )
  P: (e, t) => Number(
    new DataView(e).getBigUint64(0, t)
  )
  //  void* 	int
};
class U7 extends ml {
  constructor({ data: t, mime: n }) {
    super({ data: P2(t), mime: n }), this._cType = n.split("application/fn.struct.")[1], this._value = null, this.parse_value();
  }
  parse_value() {
    let t = !0, n = this._cType;
    return n.startsWith("<") && (t = !0, n = n.slice(1)), n.startsWith(">") && (t = !1, n = n.slice(1)), n.startsWith("!") && (t = !1, n = n.slice(1)), n.startsWith("@") && (t = !1, n = n.slice(1)), n.startsWith("=") && (t = !1, n = n.slice(1)), this._value = vde[n](this.data, t), this._value;
  }
  get value() {
    return this._value;
  }
  toString() {
    return this._value === null ? "null" : this._value.toString();
  }
}
class Yc extends ml {
  constructor({ data: t, mime: n }) {
    const r = P2(t);
    super({ data: r, mime: n }), r.byteLength === 0 ? this._json = void 0 : (this._json = JSON.parse(new TextDecoder().decode(r)), this._json === "<NoValue>" && (this._json = void 0));
  }
  get value() {
    return this._json;
  }
  static fromObject(t) {
    const n = t === "<NoValue>" ? new Uint8Array(0) : new TextEncoder().encode(JSON.stringify(t));
    return new Yc({ data: n, mime: "application/json" });
  }
  toString() {
    return typeof this._json == "string" ? this._json : JSON.stringify(this._json);
  }
}
class V7 extends ml {
  constructor({ data: t, mime: n }) {
    const r = P2(t);
    super({ data: r, mime: n }), this._value = new TextDecoder().decode(r);
  }
  get value() {
    return this._value;
  }
  toString() {
    return this._value;
  }
}
const H7 = ({
  data: e,
  mime: t
}) => {
  const n = typeof SharedArrayBuffer < "u" && e instanceof SharedArrayBuffer;
  return e instanceof ArrayBuffer || ArrayBuffer.isView(e) || n ? t.startsWith("application/fn.struct.") ? new U7({ data: e, mime: t }) : t.startsWith("application/json") ? new Yc({ data: e, mime: t }) : t === "text" || t.startsWith("text/") ? new V7({ data: e, mime: t }) : new B7({ data: e, mime: t }) : new ml({ data: e, mime: t });
};
class yde extends Rc {
  constructor(t) {
    super(t), this.CHUNK_TIMEOUT = 1e4, this._unique_cmd_outs = {}, this.blobChunks = {}, this.cleanupChunks = () => {
      const n = Date.now();
      for (const r in this.blobChunks)
        n - this.blobChunks[r].timestamp > this.CHUNK_TIMEOUT && delete this.blobChunks[r];
    }, this.messagePromises = /* @__PURE__ */ new Map();
  }
  start() {
    this._chunk_cleanup_timer = setInterval(
      this.cleanupChunks.bind(this),
      this.CHUNK_TIMEOUT / 2
    );
  }
  stop() {
    this._chunk_cleanup_timer && clearInterval(this._chunk_cleanup_timer);
  }
  send(t) {
    this.context.worker.send(t);
  }
  async _send_cmd({
    cmd: t,
    kwargs: n,
    as_bytes: r = !1,
    wait_for_response: a = !0,
    response_timeout: s = 5e3,
    retries: l = 2,
    unique: c = !1
  }) {
    const d = {
      type: "cmd",
      as_bytes: r,
      cmd: t,
      kwargs: n || {}
    };
    if (await new Promise(async (p) => {
      if (this.context.worker.is_responsive) return p();
      const m = setInterval(() => {
        this.context.worker.is_responsive && (clearInterval(m), p());
      }, 100);
    }), a) {
      if (c && this._unique_cmd_outs[d.cmd] !== void 0)
        return this._unique_cmd_outs[d.cmd];
      l < 0 && (l = 0);
      const p = (async () => {
        let m;
        for (; l >= 0; ) {
          const h = d.id || XR();
          d.id = h;
          const v = new Promise((y, w) => {
            const x = setTimeout(() => {
              w("Timeout@wait_for_response for " + t);
            }, s);
            this.messagePromises.set(h, {
              resolve: (b) => {
                clearTimeout(x), y(b), this.messagePromises.delete(h);
              },
              reject: (b) => {
                clearTimeout(x), w(b), this.messagePromises.delete(h);
              }
            });
          });
          await this.send(d);
          try {
            m = await v;
            break;
          } catch (y) {
            if (l === 0)
              throw delete this._unique_cmd_outs[d.cmd], y;
            l -= 1;
            continue;
          }
        }
        return delete this._unique_cmd_outs[d.cmd], m;
      })();
      return c && (this._unique_cmd_outs[d.cmd] = p), p;
    }
    return this.send(d);
  }
  async receive(t) {
    let n;
    switch (this.connectionHealthManager.receivePong(), t.type) {
      case "pong":
        return this.connectionHealthManager.receivePong();
      case "nsevent":
        return await this.context.worker.getEventManager().receive_nodespace_event(t);
      case "result":
        if (n = t.id && this.messagePromises.get(t.id), n)
          return n.resolve(t.result);
        break;
      case "error":
        if (this.context.worker.on_error(t.tb + `
` + t.error), n = t.id && this.messagePromises.get(t.id), n)
          return n.reject(t.error);
        break;
      case "progress":
        if (!this.context.worker._zustand) return;
        this.context.worker._zustand.set_progress(t);
        break;
      case "workerevent":
        return await this.context.worker.getEventManager().receive_workerevent(t);
      case "large_message":
        return await this.context.worker.handle_large_message_hint(t);
      default:
        console.warn("Unhandled message", t);
        break;
    }
  }
  async receive_bytes(t, n) {
    const { type: r } = t;
    if (r === "io_value") {
      if (!this.context.worker._zustand) return;
      const { node: a, io: s, preview: l, mime: c } = t, d = l ? "value" : "fullvalue";
      (!a || !s) && console.error("Invalid io_value message", t);
      const p = H7({
        data: n,
        mime: c || "application/octet-stream"
      });
      this.context.worker._zustand.on_node_action({
        type: "update",
        node: {
          id: a,
          io: {
            [s]: {
              [d]: p
            }
          }
        },
        id: a,
        from_remote: !0
      });
    } else if (r == "result") {
      const a = t.id && this.messagePromises.get(t.id);
      a && a.resolve({ bytes: n, header: t });
    } else
      console.warn("Unhandled bytes message", t);
  }
  async onbytes(t) {
    try {
      const n = new TextDecoder("utf-8").decode(t), r = n.indexOf(`\r
\r
`);
      if (r === -1) {
        console.error(`Header terminator not found for:
`, n);
        return;
      }
      const a = n.substring(0, r + 4), s = t.slice(r + 4), l = a.split(";"), c = {};
      if (l.forEach((h) => {
        const [v, y] = h.split("=");
        c[v.trim()] = y.trim();
      }), !c.chunk || !c.msgid) {
        console.error(
          "Header missing required fields chunk or msgid",
          c
        );
        return;
      }
      const [d, p] = c.chunk.split("/"), m = c.msgid;
      if (d === "1" && p === "1")
        return this.receive_bytes(c, s);
      if (this.blobChunks[m] || (this.blobChunks[m] = {
        chunks: Array.from({ length: parseInt(p) }, () => null),
        timestamp: Date.now()
      }), this.blobChunks[m].chunks.length !== parseInt(p)) {
        console.error("Total chunks mismatch");
        return;
      }
      if (this.blobChunks[m].chunks[parseInt(d) - 1] = t, this.blobChunks[m].chunks.every((h) => h !== null)) {
        const h = new Uint8Array(
          this.blobChunks[m].chunks.reduce((v, y) => v.concat(Array.from(y)), [])
        );
        this.receive_bytes(c, h), delete this.blobChunks[m];
      }
    } catch (n) {
      console.error("Websocketworker: onbytes error", n, t);
      return;
    }
  }
}
class bde extends Rc {
  constructor() {
    super(...arguments), this._ns_event_intercepts = /* @__PURE__ */ new Map();
  }
  start() {
  }
  stop() {
  }
  async _receive_edge_added(t, n, r, a) {
    this.context.worker._zustand && this.context.worker._zustand.on_edge_action({
      type: "add",
      from_remote: !0,
      src_nid: t,
      src_ioid: n,
      trg_nid: r,
      trg_ioid: a
    });
  }
  async _receive_groups(t) {
    this.context.worker._zustand && this.context.worker._zustand.on_group_action({
      type: "set",
      groups: t
    });
  }
  async _receive_node_added(t) {
    if (this.context.worker._zustand)
      return this.context.worker._zustand.on_node_action({
        type: "add",
        node: t,
        id: t.id,
        from_remote: !0
      });
  }
  async receive_workerevent({ event: t, data: n }) {
    switch (t) {
      case "worker_error":
        return this.context.worker._zustand ? this.context.worker._zustand.logger.error(n.error) : void 0;
      case "update_worker_dependencies":
        return this.context.worker._zustand ? this.context.worker._zustand.lib.libstate.getState().set({
          external_worker: n.worker_dependencies
        }) : void 0;
      case "lib_update":
        await this.context.worker.getSyncManager().sync_lib();
        return;
      case "fullsync":
        await this.context.worker.getSyncManager().stepwise_fullsync();
        return;
      case "external_worker_update":
        await this.context.worker.getSyncManager().sync_lib(), await this.context.worker.getSyncManager().sync_external_worker();
        return;
      case "repos_update":
        await this.hookManager.call_hooks(
          "repos_update",
          n.repos ?? n
        );
        return;
      case "starting":
        this.hookManager.call_hooks("starting");
        return;
      case "stopping":
        this.hookManager.call_hooks("stopping");
        return;
      default:
        console.warn("Unhandled worker event", t, n);
        break;
    }
  }
  async intercept_ns_event(t) {
    let n = t;
    for (const r of this._ns_event_intercepts.get(t.event) || [])
      n = await r(n);
    return n;
  }
  async receive_nodespace_event(t) {
    const { event: n, data: r } = await this.intercept_ns_event(t);
    switch (n) {
      case "after_set_value":
        return this.context.worker._zustand ? this.context.worker._zustand.on_node_action({
          type: "update",
          node: {
            id: r.node,
            io: {
              [r.io]: {
                value: r.result
              }
            }
          },
          id: r.node,
          from_remote: !0
        }) : void 0;
      case "after_update_value_options":
        return this.context.worker._zustand ? this.context.worker._zustand.on_node_action({
          type: "update",
          node: {
            id: r.node,
            io: {
              [r.io]: {
                value_options: r.result
              }
            }
          },
          id: r.node,
          from_remote: !0
        }) : void 0;
      case "triggerstart":
        return this.context.worker._zustand ? this.context.worker._zustand.on_node_action({
          type: "update",
          node: {
            id: r.node,
            in_trigger: !0
          },
          id: r.node,
          from_remote: !0
        }) : void 0;
      case "triggerdone":
        return this.context.worker._zustand ? this.context.worker._zustand.on_node_action({
          type: "update",
          node: {
            id: r.node,
            in_trigger: !1
          },
          id: r.node,
          from_remote: !0
        }) : void 0;
      case "triggerfast":
        if (!this.context.worker._zustand) return;
        this.context.worker._zustand.on_node_action({
          type: "update",
          node: {
            id: r.node,
            in_trigger: !0
          },
          id: r.node,
          from_remote: !0
        }), setTimeout(() => {
          this.context.worker._zustand && this.context.worker._zustand.on_node_action({
            type: "update",
            node: {
              id: r.node,
              in_trigger: !1
            },
            id: r.node,
            from_remote: !0
          });
        }, 50);
        return;
      case "node_trigger_error":
        return this.context.worker._zustand ? this.context.worker._zustand.on_node_action({
          type: "error",
          errortype: "trigger",
          error: r.error,
          id: r.node,
          tb: r.tb,
          from_remote: !0
        }) : void 0;
      case "node_removed":
        if (!this.context.worker._zustand) return;
        this.context.worker._zustand.on_node_action({
          type: "delete",
          id: r.node,
          from_remote: !0
        }), this.hookManager.call_hooks("node_removed", {
          node: r.node
        });
        return;
      case "node_added":
        this._receive_node_added(r.node);
        return;
      case "after_disconnect":
        return !r.result || !Array.isArray(r.result) || r.result.length !== 4 || !this.context.worker._zustand ? void 0 : this.context.worker._zustand.on_edge_action({
          type: "delete",
          from_remote: !0,
          src_nid: r.result[0],
          src_ioid: r.result[1],
          trg_nid: r.result[2],
          trg_ioid: r.result[3]
        });
      case "after_unforward":
        return !r.result || !Array.isArray(r.result) || r.result.length !== 4 || !this.context.worker._zustand ? void 0 : this.context.worker._zustand.on_edge_action({
          type: "delete",
          from_remote: !0,
          src_nid: r.result[0],
          src_ioid: r.result[1],
          trg_nid: r.result[2],
          trg_ioid: r.result[3]
        });
      case "after_connect":
        return !r.result || !Array.isArray(r.result) || r.result.length !== 4 ? void 0 : this._receive_edge_added(
          ...r.result
        );
      case "after_forward":
        return !r.result || !Array.isArray(r.result) || r.result.length !== 4 ? void 0 : this._receive_edge_added(
          ...r.result
        );
      case "after_add_shelf":
        return !r.result || !this.context.worker._zustand ? void 0 : this.context.worker._zustand.lib.libstate.getState().set({
          lib: r.result
        });
      case "after_remove_shelf":
        return !r.result || !this.context.worker._zustand ? void 0 : this.context.worker._zustand.lib.libstate.getState().set({
          lib: r.result
        });
      case "progress":
        if (!this.context.worker._zustand) return;
        if (r.node)
          return this.context.worker._zustand.on_node_action({
            type: "update",
            node: {
              id: r.node,
              progress: r.info
            },
            id: r.node,
            from_remote: !0
          });
        console.warn("Unhandled nodepsace event", n, r);
        break;
      default:
        if (["after_set_nodespace"].includes(n)) return;
        console.warn("Unhandled nodepsace event", n, r);
        break;
    }
  }
  add_ns_event_intercept(t, n) {
    const r = this._ns_event_intercepts.get(t) || [];
    return r.push(n), this._ns_event_intercepts.set(t, r), () => {
      const a = this._ns_event_intercepts.get(t) || [], s = a.indexOf(n);
      s >= 0 && a.splice(s, 1);
    };
  }
}
class wde extends Rc {
  constructor() {
    super(...arguments), this._hooks = /* @__PURE__ */ new Map();
  }
  start() {
  }
  stop() {
  }
  add_hook(t, n) {
    const r = this._hooks.get(t) || [];
    return r.push(n), this._hooks.set(t, r), () => {
      const a = this._hooks.get(t) || [], s = a.indexOf(n);
      s >= 0 && a.splice(s, 1);
    };
  }
  async call_hooks(t, n) {
    const r = [];
    for (const a of this._hooks.get(t) || []) {
      const s = a({ worker: this.context.worker, data: n });
      s instanceof Promise && r.push(s);
    }
    await Promise.all(r);
  }
}
class xde extends Rc {
  start() {
  }
  stop() {
  }
  async trigger_node(t) {
    await this.communicationManager._send_cmd({
      cmd: "trigger_node",
      kwargs: { nid: t },
      wait_for_response: !1
    });
  }
  async add_node(t) {
    const n = await this.communicationManager._send_cmd({
      cmd: "add_node",
      kwargs: { id: t }
    });
    return this.eventManager._receive_node_added(n);
  }
  async remove_node(t) {
    await this.communicationManager._send_cmd({
      cmd: "remove_node",
      kwargs: { id: t }
    });
  }
  locally_update_node(t) {
    this.syncManager.locally_update_node(t);
  }
  set_io_value({
    nid: t,
    ioid: n,
    value: r,
    set_default: a = !1
  }) {
    return this.communicationManager._send_cmd({
      cmd: "set_io_value",
      kwargs: { nid: t, ioid: n, value: r, set_default: a },
      wait_for_response: !0
    });
  }
  set_io_value_options({
    nid: t,
    ioid: n,
    values: r,
    keys: a,
    nullable: s
  }) {
    return this.communicationManager._send_cmd({
      cmd: "update_io_value_options",
      kwargs: {
        nid: t,
        ioid: n,
        options: {
          options: {
            type: "enum",
            values: r,
            keys: a,
            nullable: s
          }
        }
      }
    });
  }
  async get_io_value({ nid: t, ioid: n }) {
    const r = await this.communicationManager._send_cmd({
      cmd: "get_io_value",
      kwargs: { nid: t, ioid: n },
      wait_for_response: !0
    });
    return this.context.worker._zustand && this.context.worker._zustand.on_node_action({
      type: "update",
      node: {
        io: {
          [n]: {
            value: r
          }
        }
      },
      id: t,
      from_remote: !0
    }), r;
  }
  async get_ios_values({ nid: t }) {
    const n = await this.communicationManager._send_cmd({
      cmd: "get_ios_values",
      kwargs: { nid: t },
      wait_for_response: !0
    });
    if (!this.context.worker._zustand) return n;
    const r = {};
    for (const a in n)
      r[a] = { value: n[a] };
    return this.context.worker._zustand.on_node_action({
      type: "update",
      node: {
        io: r
      },
      id: t,
      from_remote: !0
    }), n;
  }
  async get_io_full_value({ nid: t, ioid: n }) {
    const r = await this.communicationManager._send_cmd({
      cmd: "get_io_full_value",
      kwargs: { nid: t, ioid: n },
      wait_for_response: !0,
      as_bytes: !0
    }), { header: a, bytes: s } = r, { mime: l } = a, c = H7({
      data: s,
      mime: l || "application/octet-stream"
    });
    return this.context.worker._zustand?.on_node_action?.({
      type: "update",
      node: {
        id: t,
        io: {
          [n]: {
            fullvalue: c
          }
        }
      },
      id: t,
      from_remote: !0
    }), c;
  }
  async update_io_options({
    nid: t,
    ioid: n,
    options: r
  }) {
    const a = await this.communicationManager._send_cmd({
      cmd: "update_io_options",
      kwargs: { nid: t, ioid: n, ...r },
      wait_for_response: !0
    });
    if (!this.context.worker._zustand) return a;
    this.context.worker._zustand.on_node_action({
      type: "update",
      node: {
        io: {
          [n]: {
            ...r
          }
        }
      },
      id: t,
      from_remote: !0
    });
  }
  async get_node_status(t) {
    return await this.communicationManager._send_cmd({
      cmd: "get_node_state",
      kwargs: { nid: t },
      wait_for_response: !0
    });
  }
  async get_remote_node_state(t) {
    const n = await this.communicationManager._send_cmd({
      cmd: "get_node_state",
      kwargs: { nid: t },
      wait_for_response: !0
    });
    this.context.worker._zustand && this.context.worker._zustand.on_node_action({
      type: "update",
      node: n,
      id: n.id,
      from_remote: !0
    });
  }
}
class Sde extends Rc {
  start() {
  }
  stop() {
  }
  add_edge({
    src_nid: t,
    src_ioid: n,
    trg_nid: r,
    trg_ioid: a,
    replace: s = !1
  }) {
    return this.communicationManager._send_cmd({
      cmd: "add_edge",
      kwargs: { src_nid: t, src_ioid: n, trg_nid: r, trg_ioid: a, replace: s }
    });
  }
  remove_edge({
    src_nid: t,
    src_ioid: n,
    trg_nid: r,
    trg_ioid: a
  }) {
    return this.communicationManager._send_cmd({
      cmd: "remove_edge",
      kwargs: { src_nid: t, src_ioid: n, trg_nid: r, trg_ioid: a }
    });
  }
}
class kde extends Rc {
  start() {
  }
  stop() {
  }
  async group_nodes(t, n) {
    const r = await this.communicationManager._send_cmd({
      cmd: "group_nodes",
      kwargs: { node_ids: t, group_ids: n },
      wait_for_response: !0
    });
    return this.eventManager._receive_groups(r), r;
  }
  async remove_group(t) {
    await this.communicationManager._send_cmd({
      cmd: "remove_group",
      kwargs: { gid: t },
      wait_for_response: !0
    }), await this.syncManager.sync_nodespace();
  }
  locally_update_group(t) {
    this.syncManager.locally_update_group(t);
  }
}
class _de extends Rc {
  constructor() {
    super(...arguments), this._available_modules_cache = {
      installed: [],
      available: [],
      active: []
    };
  }
  start() {
  }
  stop() {
  }
  async add_external_worker({
    module: t,
    cls_module: n,
    cls_name: r
  }) {
    return await this.communicationManager._send_cmd({
      cmd: "add_external_worker",
      kwargs: { module: t, cls_module: n, cls_name: r }
    });
  }
  async add_lib(t, n) {
    return await this.communicationManager._send_cmd({
      cmd: "add_package_dependency",
      kwargs: { name: t, version: n },
      wait_for_response: !1
    });
  }
  async remove_lib(t) {
    return await this.communicationManager._send_cmd({
      cmd: "remove_package_dependency",
      kwargs: { name: t },
      wait_for_response: !1
    });
  }
  async get_available_modules({
    wait_for_response: t = !1,
    on_load: n
  }) {
    const r = this.communicationManager._send_cmd({
      cmd: "get_available_modules",
      wait_for_response: !0,
      unique: !0
    }).then((a) => {
      this._available_modules_cache = a, n && n(this._available_modules_cache);
    });
    return t && await r, this._available_modules_cache;
  }
  async remove_external_worker(t, n) {
    return await this.communicationManager._send_cmd({
      cmd: "remove_external_worker",
      kwargs: { worker_id: t, class_id: n },
      wait_for_response: !0
    });
  }
  async get_external_worker_config(t, n) {
    return await this.communicationManager._send_cmd({
      cmd: "get_external_worker_config",
      kwargs: { worker_id: t, class_id: n },
      wait_for_response: !0
    });
  }
}
class YR {
  // Public getter for handlers to access eventManager
  getEventManager() {
    return this._eventManager;
  }
  getSyncManager() {
    return this._syncManager;
  }
  getCommunicationManager() {
    return this._communicationManager;
  }
  getConnectionHealthManager() {
    return this._connectionhealthManager;
  }
  getHookManager() {
    return this._hookManager;
  }
  getNodeManager() {
    return this._nodeManager;
  }
  getEdgeManager() {
    return this._edgeManager;
  }
  getGroupManager() {
    return this._groupManager;
  }
  getLibraryManager() {
    return this._libraryManager;
  }
  constructor(t) {
    this.uuid = t.uuid, this.on_error = t.on_error || ((r) => {
      this._zustand?.logger.error(r);
    }), this.state = ji((r, a) => ({
      is_open: !1
    }));
    const n = { worker: this };
    this._connectionhealthManager = new hde(
      n
    ), this._communicationManager = new yde(n), this._eventManager = new bde({
      ...n
    }), this._syncManager = new gde({
      ...n,
      on_sync_complete: t.on_sync_complete
    }), this._hookManager = new wde(n), this._nodeManager = new xde(n), this._edgeManager = new Sde(n), this._groupManager = new kde(n), this._libraryManager = new _de(n), this._communicationManager.start(), this._connectionhealthManager.start(), this._syncManager.start(), this._eventManager.start(), this._hookManager.start(), this._nodeManager.start(), this._edgeManager.start(), this._groupManager.start(), this._libraryManager.start(), t.zustand && this.set_zustand(t.zustand), this.api = {
      node: this._nodeManager,
      group: this._groupManager,
      edge: this._edgeManager,
      hooks: this._hookManager,
      lib: this._libraryManager
    };
  }
  set_zustand(t) {
    t !== this._zustand && (t.logger.debug("Setting zustand for worker"), this._zustand = t, t.set_worker(this), this._zustand.auto_progress(), this._syncManager.stepwise_fullsync());
  }
  get is_open() {
    return this.state.getState().is_open;
  }
  set is_open(t) {
    this.state.setState({ is_open: t });
  }
  get is_responsive() {
    return this._connectionhealthManager.isResponsive();
  }
  clear() {
    return this._communicationManager._send_cmd({ cmd: "clear", unique: !0 });
  }
  save() {
    return this._communicationManager._send_cmd({
      cmd: "save",
      wait_for_response: !0,
      unique: !0
    });
  }
  load(t) {
    return this._communicationManager._send_cmd({
      cmd: "load_data",
      kwargs: { data: t },
      wait_for_response: !0
    }).then(() => {
      this._syncManager.stepwise_fullsync();
    });
  }
  async get_runstate() {
    return await this._communicationManager._send_cmd({
      cmd: "get_runstate",
      wait_for_response: !0,
      unique: !0
    });
  }
  async send(t) {
    throw new Error("async send(data: any)  not implemented");
  }
  async upload_file(t) {
    throw new Error("upload_file not implemented ");
  }
  async handle_large_message_hint({}) {
    throw new Error(
      "async handle_large_message_hint({}: LargeMessageHint) not implemented "
    );
  }
  disconnect() {
  }
  onclose() {
    this.is_open = !1, this._zustand && this._zustand.auto_progress();
  }
  async reconnect() {
  }
  async stop() {
    window.localStorage.getItem("funcnodes__active_worker") == this.uuid && window.localStorage.removeItem("funcnodes__active_worker"), await this._communicationManager._send_cmd({
      cmd: "stop_worker",
      wait_for_response: !1
    });
    const t = this.onclose.bind(this);
    this.onclose = () => {
      t(), this._zustand && (this._zustand.worker === this && this._zustand.clear_all(), this.onclose = t);
    };
  }
  async update_external_worker(t, n, r) {
    return await this._communicationManager._send_cmd({
      cmd: "update_external_worker",
      kwargs: { worker_id: t, class_id: n, ...r },
      wait_for_response: !0
    });
  }
  async export({ withFiles: t = !1 }) {
    return await this._communicationManager._send_cmd({
      cmd: "export_worker",
      wait_for_response: !0,
      kwargs: { with_files: t }
    });
  }
  async update_from_export(t) {
    const n = this._hookManager.add_hook("node_added", async ({}) => {
      this._zustand?.center_all();
    });
    try {
      const r = await this._communicationManager._send_cmd({
        cmd: "update_from_export",
        kwargs: { data: t },
        wait_for_response: !0,
        response_timeout: 6e5,
        // 10 minutes
        unique: !0
      });
      return await new Promise((a) => {
        setTimeout(() => {
          a();
        }, 1e3);
      }), await this._syncManager.stepwise_fullsync(), r;
    } finally {
      n();
    }
  }
  /**
   * @deprecated This method is deprecated. Use the API or getCommunicationManager()._send_cmd directly instead.
   */
  _send_cmd(t) {
    return this._communicationManager._send_cmd(t);
  }
  /**
   * @deprecated This method is deprecated. Use the API or getNodeManager().set_io_value directly instead.
   */
  set_io_value(t) {
    return this._nodeManager.set_io_value(t);
  }
  /**
   * @deprecated This method is deprecated. Use the API or getNodeManager().get_io_value directly instead.
   */
  get_io_value(t) {
    return this._nodeManager.get_io_value(t);
  }
}
function q7(e, t) {
  return function() {
    return e.apply(t, arguments);
  };
}
const { toString: Ede } = Object.prototype, { getPrototypeOf: QR } = Object, { iterator: D2, toStringTag: W7 } = Symbol, $2 = /* @__PURE__ */ ((e) => (t) => {
  const n = Ede.call(t);
  return e[n] || (e[n] = n.slice(8, -1).toLowerCase());
})(/* @__PURE__ */ Object.create(null)), Ws = (e) => (e = e.toLowerCase(), (t) => $2(t) === e), T2 = (e) => (t) => typeof t === e, { isArray: ag } = Array, Th = T2("undefined");
function dS(e) {
  return e !== null && !Th(e) && e.constructor !== null && !Th(e.constructor) && Oa(e.constructor.isBuffer) && e.constructor.isBuffer(e);
}
const G7 = Ws("ArrayBuffer");
function Cde(e) {
  let t;
  return typeof ArrayBuffer < "u" && ArrayBuffer.isView ? t = ArrayBuffer.isView(e) : t = e && e.buffer && G7(e.buffer), t;
}
const Ode = T2("string"), Oa = T2("function"), K7 = T2("number"), fS = (e) => e !== null && typeof e == "object", Mde = (e) => e === !0 || e === !1, M0 = (e) => {
  if ($2(e) !== "object")
    return !1;
  const t = QR(e);
  return (t === null || t === Object.prototype || Object.getPrototypeOf(t) === null) && !(W7 in e) && !(D2 in e);
}, Nde = (e) => {
  if (!fS(e) || dS(e))
    return !1;
  try {
    return Object.keys(e).length === 0 && Object.getPrototypeOf(e) === Object.prototype;
  } catch {
    return !1;
  }
}, Rde = Ws("Date"), Ade = Ws("File"), jde = Ws("Blob"), Pde = Ws("FileList"), Dde = (e) => fS(e) && Oa(e.pipe), $de = (e) => {
  let t;
  return e && (typeof FormData == "function" && e instanceof FormData || Oa(e.append) && ((t = $2(e)) === "formdata" || // detect form-data instance
  t === "object" && Oa(e.toString) && e.toString() === "[object FormData]"));
}, Tde = Ws("URLSearchParams"), [Lde, Ide, zde, Fde] = ["ReadableStream", "Request", "Response", "Headers"].map(Ws), Bde = (e) => e.trim ? e.trim() : e.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
function pS(e, t, { allOwnKeys: n = !1 } = {}) {
  if (e === null || typeof e > "u")
    return;
  let r, a;
  if (typeof e != "object" && (e = [e]), ag(e))
    for (r = 0, a = e.length; r < a; r++)
      t.call(null, e[r], r, e);
  else {
    if (dS(e))
      return;
    const s = n ? Object.getOwnPropertyNames(e) : Object.keys(e), l = s.length;
    let c;
    for (r = 0; r < l; r++)
      c = s[r], t.call(null, e[c], c, e);
  }
}
function X7(e, t) {
  if (dS(e))
    return null;
  t = t.toLowerCase();
  const n = Object.keys(e);
  let r = n.length, a;
  for (; r-- > 0; )
    if (a = n[r], t === a.toLowerCase())
      return a;
  return null;
}
const tm = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : Nw, Y7 = (e) => !Th(e) && e !== tm;
function N5() {
  const { caseless: e, skipUndefined: t } = Y7(this) && this || {}, n = {}, r = (a, s) => {
    const l = e && X7(n, s) || s;
    M0(n[l]) && M0(a) ? n[l] = N5(n[l], a) : M0(a) ? n[l] = N5({}, a) : ag(a) ? n[l] = a.slice() : (!t || !Th(a)) && (n[l] = a);
  };
  for (let a = 0, s = arguments.length; a < s; a++)
    arguments[a] && pS(arguments[a], r);
  return n;
}
const Ude = (e, t, n, { allOwnKeys: r } = {}) => (pS(t, (a, s) => {
  n && Oa(a) ? e[s] = q7(a, n) : e[s] = a;
}, { allOwnKeys: r }), e), Vde = (e) => (e.charCodeAt(0) === 65279 && (e = e.slice(1)), e), Hde = (e, t, n, r) => {
  e.prototype = Object.create(t.prototype, r), e.prototype.constructor = e, Object.defineProperty(e, "super", {
    value: t.prototype
  }), n && Object.assign(e.prototype, n);
}, qde = (e, t, n, r) => {
  let a, s, l;
  const c = {};
  if (t = t || {}, e == null) return t;
  do {
    for (a = Object.getOwnPropertyNames(e), s = a.length; s-- > 0; )
      l = a[s], (!r || r(l, e, t)) && !c[l] && (t[l] = e[l], c[l] = !0);
    e = n !== !1 && QR(e);
  } while (e && (!n || n(e, t)) && e !== Object.prototype);
  return t;
}, Wde = (e, t, n) => {
  e = String(e), (n === void 0 || n > e.length) && (n = e.length), n -= t.length;
  const r = e.indexOf(t, n);
  return r !== -1 && r === n;
}, Gde = (e) => {
  if (!e) return null;
  if (ag(e)) return e;
  let t = e.length;
  if (!K7(t)) return null;
  const n = new Array(t);
  for (; t-- > 0; )
    n[t] = e[t];
  return n;
}, Kde = /* @__PURE__ */ ((e) => (t) => e && t instanceof e)(typeof Uint8Array < "u" && QR(Uint8Array)), Xde = (e, t) => {
  const n = (e && e[D2]).call(e);
  let r;
  for (; (r = n.next()) && !r.done; ) {
    const a = r.value;
    t.call(e, a[0], a[1]);
  }
}, Yde = (e, t) => {
  let n;
  const r = [];
  for (; (n = e.exec(t)) !== null; )
    r.push(n);
  return r;
}, Qde = Ws("HTMLFormElement"), Jde = (e) => e.toLowerCase().replace(
  /[-_\s]([a-z\d])(\w*)/g,
  function(t, n, r) {
    return n.toUpperCase() + r;
  }
), g6 = (({ hasOwnProperty: e }) => (t, n) => e.call(t, n))(Object.prototype), Zde = Ws("RegExp"), Q7 = (e, t) => {
  const n = Object.getOwnPropertyDescriptors(e), r = {};
  pS(n, (a, s) => {
    let l;
    (l = t(a, s, e)) !== !1 && (r[s] = l || a);
  }), Object.defineProperties(e, r);
}, efe = (e) => {
  Q7(e, (t, n) => {
    if (Oa(e) && ["arguments", "caller", "callee"].indexOf(n) !== -1)
      return !1;
    const r = e[n];
    if (Oa(r)) {
      if (t.enumerable = !1, "writable" in t) {
        t.writable = !1;
        return;
      }
      t.set || (t.set = () => {
        throw Error("Can not rewrite read-only method '" + n + "'");
      });
    }
  });
}, tfe = (e, t) => {
  const n = {}, r = (a) => {
    a.forEach((s) => {
      n[s] = !0;
    });
  };
  return ag(e) ? r(e) : r(String(e).split(t)), n;
}, nfe = () => {
}, rfe = (e, t) => e != null && Number.isFinite(e = +e) ? e : t;
function ofe(e) {
  return !!(e && Oa(e.append) && e[W7] === "FormData" && e[D2]);
}
const afe = (e) => {
  const t = new Array(10), n = (r, a) => {
    if (fS(r)) {
      if (t.indexOf(r) >= 0)
        return;
      if (dS(r))
        return r;
      if (!("toJSON" in r)) {
        t[a] = r;
        const s = ag(r) ? [] : {};
        return pS(r, (l, c) => {
          const d = n(l, a + 1);
          !Th(d) && (s[c] = d);
        }), t[a] = void 0, s;
      }
    }
    return r;
  };
  return n(e, 0);
}, ife = Ws("AsyncFunction"), sfe = (e) => e && (fS(e) || Oa(e)) && Oa(e.then) && Oa(e.catch), J7 = ((e, t) => e ? setImmediate : t ? ((n, r) => (tm.addEventListener("message", ({ source: a, data: s }) => {
  a === tm && s === n && r.length && r.shift()();
}, !1), (a) => {
  r.push(a), tm.postMessage(n, "*");
}))(`axios@${Math.random()}`, []) : (n) => setTimeout(n))(
  typeof setImmediate == "function",
  Oa(tm.postMessage)
), lfe = typeof queueMicrotask < "u" ? queueMicrotask.bind(tm) : typeof process < "u" && process.nextTick || J7, ufe = (e) => e != null && Oa(e[D2]), be = {
  isArray: ag,
  isArrayBuffer: G7,
  isBuffer: dS,
  isFormData: $de,
  isArrayBufferView: Cde,
  isString: Ode,
  isNumber: K7,
  isBoolean: Mde,
  isObject: fS,
  isPlainObject: M0,
  isEmptyObject: Nde,
  isReadableStream: Lde,
  isRequest: Ide,
  isResponse: zde,
  isHeaders: Fde,
  isUndefined: Th,
  isDate: Rde,
  isFile: Ade,
  isBlob: jde,
  isRegExp: Zde,
  isFunction: Oa,
  isStream: Dde,
  isURLSearchParams: Tde,
  isTypedArray: Kde,
  isFileList: Pde,
  forEach: pS,
  merge: N5,
  extend: Ude,
  trim: Bde,
  stripBOM: Vde,
  inherits: Hde,
  toFlatObject: qde,
  kindOf: $2,
  kindOfTest: Ws,
  endsWith: Wde,
  toArray: Gde,
  forEachEntry: Xde,
  matchAll: Yde,
  isHTMLForm: Qde,
  hasOwnProperty: g6,
  hasOwnProp: g6,
  // an alias to avoid ESLint no-prototype-builtins detection
  reduceDescriptors: Q7,
  freezeMethods: efe,
  toObjectSet: tfe,
  toCamelCase: Jde,
  noop: nfe,
  toFiniteNumber: rfe,
  findKey: X7,
  global: tm,
  isContextDefined: Y7,
  isSpecCompliantForm: ofe,
  toJSONObject: afe,
  isAsyncFn: ife,
  isThenable: sfe,
  setImmediate: J7,
  asap: lfe,
  isIterable: ufe
};
function Rt(e, t, n, r, a) {
  Error.call(this), Error.captureStackTrace ? Error.captureStackTrace(this, this.constructor) : this.stack = new Error().stack, this.message = e, this.name = "AxiosError", t && (this.code = t), n && (this.config = n), r && (this.request = r), a && (this.response = a, this.status = a.status ? a.status : null);
}
be.inherits(Rt, Error, {
  toJSON: function() {
    return {
      // Standard
      message: this.message,
      name: this.name,
      // Microsoft
      description: this.description,
      number: this.number,
      // Mozilla
      fileName: this.fileName,
      lineNumber: this.lineNumber,
      columnNumber: this.columnNumber,
      stack: this.stack,
      // Axios
      config: be.toJSONObject(this.config),
      code: this.code,
      status: this.status
    };
  }
});
const Z7 = Rt.prototype, eB = {};
[
  "ERR_BAD_OPTION_VALUE",
  "ERR_BAD_OPTION",
  "ECONNABORTED",
  "ETIMEDOUT",
  "ERR_NETWORK",
  "ERR_FR_TOO_MANY_REDIRECTS",
  "ERR_DEPRECATED",
  "ERR_BAD_RESPONSE",
  "ERR_BAD_REQUEST",
  "ERR_CANCELED",
  "ERR_NOT_SUPPORT",
  "ERR_INVALID_URL"
  // eslint-disable-next-line func-names
].forEach((e) => {
  eB[e] = { value: e };
});
Object.defineProperties(Rt, eB);
Object.defineProperty(Z7, "isAxiosError", { value: !0 });
Rt.from = (e, t, n, r, a, s) => {
  const l = Object.create(Z7);
  be.toFlatObject(e, l, function(p) {
    return p !== Error.prototype;
  }, (p) => p !== "isAxiosError");
  const c = e && e.message ? e.message : "Error", d = t == null && e ? e.code : t;
  return Rt.call(l, c, d, n, r, a), e && l.cause == null && Object.defineProperty(l, "cause", { value: e, configurable: !0 }), l.name = e && e.name || "Error", s && Object.assign(l, s), l;
};
const cfe = null;
function R5(e) {
  return be.isPlainObject(e) || be.isArray(e);
}
function tB(e) {
  return be.endsWith(e, "[]") ? e.slice(0, -2) : e;
}
function v6(e, t, n) {
  return e ? e.concat(t).map(function(r, a) {
    return r = tB(r), !n && a ? "[" + r + "]" : r;
  }).join(n ? "." : "") : t;
}
function dfe(e) {
  return be.isArray(e) && !e.some(R5);
}
const ffe = be.toFlatObject(be, {}, null, function(e) {
  return /^is[A-Z]/.test(e);
});
function L2(e, t, n) {
  if (!be.isObject(e))
    throw new TypeError("target must be an object");
  t = t || new FormData(), n = be.toFlatObject(n, {
    metaTokens: !0,
    dots: !1,
    indexes: !1
  }, !1, function(y, w) {
    return !be.isUndefined(w[y]);
  });
  const r = n.metaTokens, a = n.visitor || p, s = n.dots, l = n.indexes, c = (n.Blob || typeof Blob < "u" && Blob) && be.isSpecCompliantForm(t);
  if (!be.isFunction(a))
    throw new TypeError("visitor must be a function");
  function d(y) {
    if (y === null) return "";
    if (be.isDate(y))
      return y.toISOString();
    if (be.isBoolean(y))
      return y.toString();
    if (!c && be.isBlob(y))
      throw new Rt("Blob is not supported. Use a Buffer instead.");
    return be.isArrayBuffer(y) || be.isTypedArray(y) ? c && typeof Blob == "function" ? new Blob([y]) : Buffer.from(y) : y;
  }
  function p(y, w, x) {
    let b = y;
    if (y && !x && typeof y == "object") {
      if (be.endsWith(w, "{}"))
        w = r ? w : w.slice(0, -2), y = JSON.stringify(y);
      else if (be.isArray(y) && dfe(y) || (be.isFileList(y) || be.endsWith(w, "[]")) && (b = be.toArray(y)))
        return w = tB(w), b.forEach(function(k, C) {
          !(be.isUndefined(k) || k === null) && t.append(
            // eslint-disable-next-line no-nested-ternary
            l === !0 ? v6([w], C, s) : l === null ? w : w + "[]",
            d(k)
          );
        }), !1;
    }
    return R5(y) ? !0 : (t.append(v6(x, w, s), d(y)), !1);
  }
  const m = [], h = Object.assign(ffe, {
    defaultVisitor: p,
    convertValue: d,
    isVisitable: R5
  });
  function v(y, w) {
    if (!be.isUndefined(y)) {
      if (m.indexOf(y) !== -1)
        throw Error("Circular reference detected in " + w.join("."));
      m.push(y), be.forEach(y, function(x, b) {
        (!(be.isUndefined(x) || x === null) && a.call(
          t,
          x,
          be.isString(b) ? b.trim() : b,
          w,
          h
        )) === !0 && v(x, w ? w.concat(b) : [b]);
      }), m.pop();
    }
  }
  if (!be.isObject(e))
    throw new TypeError("data must be an object");
  return v(e), t;
}
function y6(e) {
  const t = {
    "!": "%21",
    "'": "%27",
    "(": "%28",
    ")": "%29",
    "~": "%7E",
    "%20": "+",
    "%00": "\0"
  };
  return encodeURIComponent(e).replace(/[!'()~]|%20|%00/g, function(n) {
    return t[n];
  });
}
function JR(e, t) {
  this._pairs = [], e && L2(e, this, t);
}
const nB = JR.prototype;
nB.append = function(e, t) {
  this._pairs.push([e, t]);
};
nB.toString = function(e) {
  const t = e ? function(n) {
    return e.call(this, n, y6);
  } : y6;
  return this._pairs.map(function(n) {
    return t(n[0]) + "=" + t(n[1]);
  }, "").join("&");
};
function pfe(e) {
  return encodeURIComponent(e).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+");
}
function rB(e, t, n) {
  if (!t)
    return e;
  const r = n && n.encode || pfe;
  be.isFunction(n) && (n = {
    serialize: n
  });
  const a = n && n.serialize;
  let s;
  if (a ? s = a(t, n) : s = be.isURLSearchParams(t) ? t.toString() : new JR(t, n).toString(r), s) {
    const l = e.indexOf("#");
    l !== -1 && (e = e.slice(0, l)), e += (e.indexOf("?") === -1 ? "?" : "&") + s;
  }
  return e;
}
class b6 {
  constructor() {
    this.handlers = [];
  }
  /**
   * Add a new interceptor to the stack
   *
   * @param {Function} fulfilled The function to handle `then` for a `Promise`
   * @param {Function} rejected The function to handle `reject` for a `Promise`
   *
   * @return {Number} An ID used to remove interceptor later
   */
  use(t, n, r) {
    return this.handlers.push({
      fulfilled: t,
      rejected: n,
      synchronous: r ? r.synchronous : !1,
      runWhen: r ? r.runWhen : null
    }), this.handlers.length - 1;
  }
  /**
   * Remove an interceptor from the stack
   *
   * @param {Number} id The ID that was returned by `use`
   *
   * @returns {void}
   */
  eject(t) {
    this.handlers[t] && (this.handlers[t] = null);
  }
  /**
   * Clear all interceptors from the stack
   *
   * @returns {void}
   */
  clear() {
    this.handlers && (this.handlers = []);
  }
  /**
   * Iterate over all the registered interceptors
   *
   * This method is particularly useful for skipping over any
   * interceptors that may have become `null` calling `eject`.
   *
   * @param {Function} fn The function to call for each interceptor
   *
   * @returns {void}
   */
  forEach(t) {
    be.forEach(this.handlers, function(n) {
      n !== null && t(n);
    });
  }
}
const oB = {
  silentJSONParsing: !0,
  forcedJSONParsing: !0,
  clarifyTimeoutError: !1
}, mfe = typeof URLSearchParams < "u" ? URLSearchParams : JR, hfe = typeof FormData < "u" ? FormData : null, gfe = typeof Blob < "u" ? Blob : null, vfe = {
  isBrowser: !0,
  classes: {
    URLSearchParams: mfe,
    FormData: hfe,
    Blob: gfe
  },
  protocols: ["http", "https", "file", "blob", "url", "data"]
}, ZR = typeof window < "u" && typeof document < "u", A5 = typeof navigator == "object" && navigator || void 0, yfe = ZR && (!A5 || ["ReactNative", "NativeScript", "NS"].indexOf(A5.product) < 0), bfe = typeof WorkerGlobalScope < "u" && // eslint-disable-next-line no-undef
self instanceof WorkerGlobalScope && typeof self.importScripts == "function", wfe = ZR && window.location.href || "http://localhost", xfe = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  hasBrowserEnv: ZR,
  hasStandardBrowserEnv: yfe,
  hasStandardBrowserWebWorkerEnv: bfe,
  navigator: A5,
  origin: wfe
}, Symbol.toStringTag, { value: "Module" })), Ho = {
  ...xfe,
  ...vfe
};
function Sfe(e, t) {
  return L2(e, new Ho.classes.URLSearchParams(), {
    visitor: function(n, r, a, s) {
      return Ho.isNode && be.isBuffer(n) ? (this.append(r, n.toString("base64")), !1) : s.defaultVisitor.apply(this, arguments);
    },
    ...t
  });
}
function kfe(e) {
  return be.matchAll(/\w+|\[(\w*)]/g, e).map((t) => t[0] === "[]" ? "" : t[1] || t[0]);
}
function _fe(e) {
  const t = {}, n = Object.keys(e);
  let r;
  const a = n.length;
  let s;
  for (r = 0; r < a; r++)
    s = n[r], t[s] = e[s];
  return t;
}
function aB(e) {
  function t(n, r, a, s) {
    let l = n[s++];
    if (l === "__proto__") return !0;
    const c = Number.isFinite(+l), d = s >= n.length;
    return l = !l && be.isArray(a) ? a.length : l, d ? (be.hasOwnProp(a, l) ? a[l] = [a[l], r] : a[l] = r, !c) : ((!a[l] || !be.isObject(a[l])) && (a[l] = []), t(n, r, a[l], s) && be.isArray(a[l]) && (a[l] = _fe(a[l])), !c);
  }
  if (be.isFormData(e) && be.isFunction(e.entries)) {
    const n = {};
    return be.forEachEntry(e, (r, a) => {
      t(kfe(r), a, n, 0);
    }), n;
  }
  return null;
}
function Efe(e, t, n) {
  if (be.isString(e))
    try {
      return (t || JSON.parse)(e), be.trim(e);
    } catch (r) {
      if (r.name !== "SyntaxError")
        throw r;
    }
  return (n || JSON.stringify)(e);
}
const mS = {
  transitional: oB,
  adapter: ["xhr", "http", "fetch"],
  transformRequest: [function(e, t) {
    const n = t.getContentType() || "", r = n.indexOf("application/json") > -1, a = be.isObject(e);
    if (a && be.isHTMLForm(e) && (e = new FormData(e)), be.isFormData(e))
      return r ? JSON.stringify(aB(e)) : e;
    if (be.isArrayBuffer(e) || be.isBuffer(e) || be.isStream(e) || be.isFile(e) || be.isBlob(e) || be.isReadableStream(e))
      return e;
    if (be.isArrayBufferView(e))
      return e.buffer;
    if (be.isURLSearchParams(e))
      return t.setContentType("application/x-www-form-urlencoded;charset=utf-8", !1), e.toString();
    let s;
    if (a) {
      if (n.indexOf("application/x-www-form-urlencoded") > -1)
        return Sfe(e, this.formSerializer).toString();
      if ((s = be.isFileList(e)) || n.indexOf("multipart/form-data") > -1) {
        const l = this.env && this.env.FormData;
        return L2(
          s ? { "files[]": e } : e,
          l && new l(),
          this.formSerializer
        );
      }
    }
    return a || r ? (t.setContentType("application/json", !1), Efe(e)) : e;
  }],
  transformResponse: [function(e) {
    const t = this.transitional || mS.transitional, n = t && t.forcedJSONParsing, r = this.responseType === "json";
    if (be.isResponse(e) || be.isReadableStream(e))
      return e;
    if (e && be.isString(e) && (n && !this.responseType || r)) {
      const a = !(t && t.silentJSONParsing) && r;
      try {
        return JSON.parse(e, this.parseReviver);
      } catch (s) {
        if (a)
          throw s.name === "SyntaxError" ? Rt.from(s, Rt.ERR_BAD_RESPONSE, this, null, this.response) : s;
      }
    }
    return e;
  }],
  /**
   * A timeout in milliseconds to abort a request. If set to 0 (default) a
   * timeout is not created.
   */
  timeout: 0,
  xsrfCookieName: "XSRF-TOKEN",
  xsrfHeaderName: "X-XSRF-TOKEN",
  maxContentLength: -1,
  maxBodyLength: -1,
  env: {
    FormData: Ho.classes.FormData,
    Blob: Ho.classes.Blob
  },
  validateStatus: function(e) {
    return e >= 200 && e < 300;
  },
  headers: {
    common: {
      Accept: "application/json, text/plain, */*",
      "Content-Type": void 0
    }
  }
};
be.forEach(["delete", "get", "head", "post", "put", "patch"], (e) => {
  mS.headers[e] = {};
});
const Cfe = be.toObjectSet([
  "age",
  "authorization",
  "content-length",
  "content-type",
  "etag",
  "expires",
  "from",
  "host",
  "if-modified-since",
  "if-unmodified-since",
  "last-modified",
  "location",
  "max-forwards",
  "proxy-authorization",
  "referer",
  "retry-after",
  "user-agent"
]), Ofe = (e) => {
  const t = {};
  let n, r, a;
  return e && e.split(`
`).forEach(function(s) {
    a = s.indexOf(":"), n = s.substring(0, a).trim().toLowerCase(), r = s.substring(a + 1).trim(), !(!n || t[n] && Cfe[n]) && (n === "set-cookie" ? t[n] ? t[n].push(r) : t[n] = [r] : t[n] = t[n] ? t[n] + ", " + r : r);
  }), t;
}, w6 = /* @__PURE__ */ Symbol("internals");
function cw(e) {
  return e && String(e).trim().toLowerCase();
}
function N0(e) {
  return e === !1 || e == null ? e : be.isArray(e) ? e.map(N0) : String(e);
}
function Mfe(e) {
  const t = /* @__PURE__ */ Object.create(null), n = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
  let r;
  for (; r = n.exec(e); )
    t[r[1]] = r[2];
  return t;
}
const Nfe = (e) => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(e.trim());
function RM(e, t, n, r, a) {
  if (be.isFunction(r))
    return r.call(this, t, n);
  if (a && (t = n), !!be.isString(t)) {
    if (be.isString(r))
      return t.indexOf(r) !== -1;
    if (be.isRegExp(r))
      return r.test(t);
  }
}
function Rfe(e) {
  return e.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (t, n, r) => n.toUpperCase() + r);
}
function Afe(e, t) {
  const n = be.toCamelCase(" " + t);
  ["get", "set", "has"].forEach((r) => {
    Object.defineProperty(e, r + n, {
      value: function(a, s, l) {
        return this[r].call(this, t, a, s, l);
      },
      configurable: !0
    });
  });
}
let Ma = class {
  constructor(e) {
    e && this.set(e);
  }
  set(e, t, n) {
    const r = this;
    function a(l, c, d) {
      const p = cw(c);
      if (!p)
        throw new Error("header name must be a non-empty string");
      const m = be.findKey(r, p);
      (!m || r[m] === void 0 || d === !0 || d === void 0 && r[m] !== !1) && (r[m || c] = N0(l));
    }
    const s = (l, c) => be.forEach(l, (d, p) => a(d, p, c));
    if (be.isPlainObject(e) || e instanceof this.constructor)
      s(e, t);
    else if (be.isString(e) && (e = e.trim()) && !Nfe(e))
      s(Ofe(e), t);
    else if (be.isObject(e) && be.isIterable(e)) {
      let l = {}, c, d;
      for (const p of e) {
        if (!be.isArray(p))
          throw TypeError("Object iterator must return a key-value pair");
        l[d = p[0]] = (c = l[d]) ? be.isArray(c) ? [...c, p[1]] : [c, p[1]] : p[1];
      }
      s(l, t);
    } else
      e != null && a(t, e, n);
    return this;
  }
  get(e, t) {
    if (e = cw(e), e) {
      const n = be.findKey(this, e);
      if (n) {
        const r = this[n];
        if (!t)
          return r;
        if (t === !0)
          return Mfe(r);
        if (be.isFunction(t))
          return t.call(this, r, n);
        if (be.isRegExp(t))
          return t.exec(r);
        throw new TypeError("parser must be boolean|regexp|function");
      }
    }
  }
  has(e, t) {
    if (e = cw(e), e) {
      const n = be.findKey(this, e);
      return !!(n && this[n] !== void 0 && (!t || RM(this, this[n], n, t)));
    }
    return !1;
  }
  delete(e, t) {
    const n = this;
    let r = !1;
    function a(s) {
      if (s = cw(s), s) {
        const l = be.findKey(n, s);
        l && (!t || RM(n, n[l], l, t)) && (delete n[l], r = !0);
      }
    }
    return be.isArray(e) ? e.forEach(a) : a(e), r;
  }
  clear(e) {
    const t = Object.keys(this);
    let n = t.length, r = !1;
    for (; n--; ) {
      const a = t[n];
      (!e || RM(this, this[a], a, e, !0)) && (delete this[a], r = !0);
    }
    return r;
  }
  normalize(e) {
    const t = this, n = {};
    return be.forEach(this, (r, a) => {
      const s = be.findKey(n, a);
      if (s) {
        t[s] = N0(r), delete t[a];
        return;
      }
      const l = e ? Rfe(a) : String(a).trim();
      l !== a && delete t[a], t[l] = N0(r), n[l] = !0;
    }), this;
  }
  concat(...e) {
    return this.constructor.concat(this, ...e);
  }
  toJSON(e) {
    const t = /* @__PURE__ */ Object.create(null);
    return be.forEach(this, (n, r) => {
      n != null && n !== !1 && (t[r] = e && be.isArray(n) ? n.join(", ") : n);
    }), t;
  }
  [Symbol.iterator]() {
    return Object.entries(this.toJSON())[Symbol.iterator]();
  }
  toString() {
    return Object.entries(this.toJSON()).map(([e, t]) => e + ": " + t).join(`
`);
  }
  getSetCookie() {
    return this.get("set-cookie") || [];
  }
  get [Symbol.toStringTag]() {
    return "AxiosHeaders";
  }
  static from(e) {
    return e instanceof this ? e : new this(e);
  }
  static concat(e, ...t) {
    const n = new this(e);
    return t.forEach((r) => n.set(r)), n;
  }
  static accessor(e) {
    const t = (this[w6] = this[w6] = {
      accessors: {}
    }).accessors, n = this.prototype;
    function r(a) {
      const s = cw(a);
      t[s] || (Afe(n, a), t[s] = !0);
    }
    return be.isArray(e) ? e.forEach(r) : r(e), this;
  }
};
Ma.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent", "Authorization"]);
be.reduceDescriptors(Ma.prototype, ({ value: e }, t) => {
  let n = t[0].toUpperCase() + t.slice(1);
  return {
    get: () => e,
    set(r) {
      this[n] = r;
    }
  };
});
be.freezeMethods(Ma);
function AM(e, t) {
  const n = this || mS, r = t || n, a = Ma.from(r.headers);
  let s = r.data;
  return be.forEach(e, function(l) {
    s = l.call(n, s, a.normalize(), t ? t.status : void 0);
  }), a.normalize(), s;
}
function iB(e) {
  return !!(e && e.__CANCEL__);
}
function ig(e, t, n) {
  Rt.call(this, e ?? "canceled", Rt.ERR_CANCELED, t, n), this.name = "CanceledError";
}
be.inherits(ig, Rt, {
  __CANCEL__: !0
});
function sB(e, t, n) {
  const r = n.config.validateStatus;
  !n.status || !r || r(n.status) ? e(n) : t(new Rt(
    "Request failed with status code " + n.status,
    [Rt.ERR_BAD_REQUEST, Rt.ERR_BAD_RESPONSE][Math.floor(n.status / 100) - 4],
    n.config,
    n.request,
    n
  ));
}
function jfe(e) {
  const t = /^([-+\w]{1,25})(:?\/\/|:)/.exec(e);
  return t && t[1] || "";
}
function Pfe(e, t) {
  e = e || 10;
  const n = new Array(e), r = new Array(e);
  let a = 0, s = 0, l;
  return t = t !== void 0 ? t : 1e3, function(c) {
    const d = Date.now(), p = r[s];
    l || (l = d), n[a] = c, r[a] = d;
    let m = s, h = 0;
    for (; m !== a; )
      h += n[m++], m = m % e;
    if (a = (a + 1) % e, a === s && (s = (s + 1) % e), d - l < t)
      return;
    const v = p && d - p;
    return v ? Math.round(h * 1e3 / v) : void 0;
  };
}
function Dfe(e, t) {
  let n = 0, r = 1e3 / t, a, s;
  const l = (c, d = Date.now()) => {
    n = d, a = null, s && (clearTimeout(s), s = null), e(...c);
  };
  return [(...c) => {
    const d = Date.now(), p = d - n;
    p >= r ? l(c, d) : (a = c, s || (s = setTimeout(() => {
      s = null, l(a);
    }, r - p)));
  }, () => a && l(a)];
}
const p_ = (e, t, n = 3) => {
  let r = 0;
  const a = Pfe(50, 250);
  return Dfe((s) => {
    const l = s.loaded, c = s.lengthComputable ? s.total : void 0, d = l - r, p = a(d), m = l <= c;
    r = l;
    const h = {
      loaded: l,
      total: c,
      progress: c ? l / c : void 0,
      bytes: d,
      rate: p || void 0,
      estimated: p && c && m ? (c - l) / p : void 0,
      event: s,
      lengthComputable: c != null,
      [t ? "download" : "upload"]: !0
    };
    e(h);
  }, n);
}, x6 = (e, t) => {
  const n = e != null;
  return [(r) => t[0]({
    lengthComputable: n,
    total: e,
    loaded: r
  }), t[1]];
}, S6 = (e) => (...t) => be.asap(() => e(...t)), $fe = Ho.hasStandardBrowserEnv ? /* @__PURE__ */ ((e, t) => (n) => (n = new URL(n, Ho.origin), e.protocol === n.protocol && e.host === n.host && (t || e.port === n.port)))(
  new URL(Ho.origin),
  Ho.navigator && /(msie|trident)/i.test(Ho.navigator.userAgent)
) : () => !0, Tfe = Ho.hasStandardBrowserEnv ? (
  // Standard browser envs support document.cookie
  {
    write(e, t, n, r, a, s, l) {
      if (typeof document > "u") return;
      const c = [`${e}=${encodeURIComponent(t)}`];
      be.isNumber(n) && c.push(`expires=${new Date(n).toUTCString()}`), be.isString(r) && c.push(`path=${r}`), be.isString(a) && c.push(`domain=${a}`), s === !0 && c.push("secure"), be.isString(l) && c.push(`SameSite=${l}`), document.cookie = c.join("; ");
    },
    read(e) {
      if (typeof document > "u") return null;
      const t = document.cookie.match(new RegExp("(?:^|; )" + e + "=([^;]*)"));
      return t ? decodeURIComponent(t[1]) : null;
    },
    remove(e) {
      this.write(e, "", Date.now() - 864e5, "/");
    }
  }
) : (
  // Non-standard browser env (web workers, react-native) lack needed support.
  {
    write() {
    },
    read() {
      return null;
    },
    remove() {
    }
  }
);
function Lfe(e) {
  return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(e);
}
function Ife(e, t) {
  return t ? e.replace(/\/?\/$/, "") + "/" + t.replace(/^\/+/, "") : e;
}
function lB(e, t, n) {
  let r = !Lfe(t);
  return e && (r || n == !1) ? Ife(e, t) : t;
}
const k6 = (e) => e instanceof Ma ? { ...e } : e;
function dm(e, t) {
  t = t || {};
  const n = {};
  function r(p, m, h, v) {
    return be.isPlainObject(p) && be.isPlainObject(m) ? be.merge.call({ caseless: v }, p, m) : be.isPlainObject(m) ? be.merge({}, m) : be.isArray(m) ? m.slice() : m;
  }
  function a(p, m, h, v) {
    if (be.isUndefined(m)) {
      if (!be.isUndefined(p))
        return r(void 0, p, h, v);
    } else return r(p, m, h, v);
  }
  function s(p, m) {
    if (!be.isUndefined(m))
      return r(void 0, m);
  }
  function l(p, m) {
    if (be.isUndefined(m)) {
      if (!be.isUndefined(p))
        return r(void 0, p);
    } else return r(void 0, m);
  }
  function c(p, m, h) {
    if (h in t)
      return r(p, m);
    if (h in e)
      return r(void 0, p);
  }
  const d = {
    url: s,
    method: s,
    data: s,
    baseURL: l,
    transformRequest: l,
    transformResponse: l,
    paramsSerializer: l,
    timeout: l,
    timeoutMessage: l,
    withCredentials: l,
    withXSRFToken: l,
    adapter: l,
    responseType: l,
    xsrfCookieName: l,
    xsrfHeaderName: l,
    onUploadProgress: l,
    onDownloadProgress: l,
    decompress: l,
    maxContentLength: l,
    maxBodyLength: l,
    beforeRedirect: l,
    transport: l,
    httpAgent: l,
    httpsAgent: l,
    cancelToken: l,
    socketPath: l,
    responseEncoding: l,
    validateStatus: c,
    headers: (p, m, h) => a(k6(p), k6(m), h, !0)
  };
  return be.forEach(Object.keys({ ...e, ...t }), function(p) {
    const m = d[p] || a, h = m(e[p], t[p], p);
    be.isUndefined(h) && m !== c || (n[p] = h);
  }), n;
}
const uB = (e) => {
  const t = dm({}, e);
  let { data: n, withXSRFToken: r, xsrfHeaderName: a, xsrfCookieName: s, headers: l, auth: c } = t;
  if (t.headers = l = Ma.from(l), t.url = rB(lB(t.baseURL, t.url, t.allowAbsoluteUrls), e.params, e.paramsSerializer), c && l.set(
    "Authorization",
    "Basic " + btoa((c.username || "") + ":" + (c.password ? unescape(encodeURIComponent(c.password)) : ""))
  ), be.isFormData(n)) {
    if (Ho.hasStandardBrowserEnv || Ho.hasStandardBrowserWebWorkerEnv)
      l.setContentType(void 0);
    else if (be.isFunction(n.getHeaders)) {
      const d = n.getHeaders(), p = ["content-type", "content-length"];
      Object.entries(d).forEach(([m, h]) => {
        p.includes(m.toLowerCase()) && l.set(m, h);
      });
    }
  }
  if (Ho.hasStandardBrowserEnv && (r && be.isFunction(r) && (r = r(t)), r || r !== !1 && $fe(t.url))) {
    const d = a && s && Tfe.read(s);
    d && l.set(a, d);
  }
  return t;
}, zfe = typeof XMLHttpRequest < "u", Ffe = zfe && function(e) {
  return new Promise(function(t, n) {
    const r = uB(e);
    let a = r.data;
    const s = Ma.from(r.headers).normalize();
    let { responseType: l, onUploadProgress: c, onDownloadProgress: d } = r, p, m, h, v, y;
    function w() {
      v && v(), y && y(), r.cancelToken && r.cancelToken.unsubscribe(p), r.signal && r.signal.removeEventListener("abort", p);
    }
    let x = new XMLHttpRequest();
    x.open(r.method.toUpperCase(), r.url, !0), x.timeout = r.timeout;
    function b() {
      if (!x)
        return;
      const C = Ma.from(
        "getAllResponseHeaders" in x && x.getAllResponseHeaders()
      ), _ = {
        data: !l || l === "text" || l === "json" ? x.responseText : x.response,
        status: x.status,
        statusText: x.statusText,
        headers: C,
        config: e,
        request: x
      };
      sB(function(O) {
        t(O), w();
      }, function(O) {
        n(O), w();
      }, _), x = null;
    }
    "onloadend" in x ? x.onloadend = b : x.onreadystatechange = function() {
      !x || x.readyState !== 4 || x.status === 0 && !(x.responseURL && x.responseURL.indexOf("file:") === 0) || setTimeout(b);
    }, x.onabort = function() {
      x && (n(new Rt("Request aborted", Rt.ECONNABORTED, e, x)), x = null);
    }, x.onerror = function(C) {
      const _ = C && C.message ? C.message : "Network Error", O = new Rt(_, Rt.ERR_NETWORK, e, x);
      O.event = C || null, n(O), x = null;
    }, x.ontimeout = function() {
      let C = r.timeout ? "timeout of " + r.timeout + "ms exceeded" : "timeout exceeded";
      const _ = r.transitional || oB;
      r.timeoutErrorMessage && (C = r.timeoutErrorMessage), n(new Rt(
        C,
        _.clarifyTimeoutError ? Rt.ETIMEDOUT : Rt.ECONNABORTED,
        e,
        x
      )), x = null;
    }, a === void 0 && s.setContentType(null), "setRequestHeader" in x && be.forEach(s.toJSON(), function(C, _) {
      x.setRequestHeader(_, C);
    }), be.isUndefined(r.withCredentials) || (x.withCredentials = !!r.withCredentials), l && l !== "json" && (x.responseType = r.responseType), d && ([h, y] = p_(d, !0), x.addEventListener("progress", h)), c && x.upload && ([m, v] = p_(c), x.upload.addEventListener("progress", m), x.upload.addEventListener("loadend", v)), (r.cancelToken || r.signal) && (p = (C) => {
      x && (n(!C || C.type ? new ig(null, e, x) : C), x.abort(), x = null);
    }, r.cancelToken && r.cancelToken.subscribe(p), r.signal && (r.signal.aborted ? p() : r.signal.addEventListener("abort", p)));
    const k = jfe(r.url);
    if (k && Ho.protocols.indexOf(k) === -1) {
      n(new Rt("Unsupported protocol " + k + ":", Rt.ERR_BAD_REQUEST, e));
      return;
    }
    x.send(a || null);
  });
}, Bfe = (e, t) => {
  const { length: n } = e = e ? e.filter(Boolean) : [];
  if (t || n) {
    let r = new AbortController(), a;
    const s = function(p) {
      if (!a) {
        a = !0, c();
        const m = p instanceof Error ? p : this.reason;
        r.abort(m instanceof Rt ? m : new ig(m instanceof Error ? m.message : m));
      }
    };
    let l = t && setTimeout(() => {
      l = null, s(new Rt(`timeout ${t} of ms exceeded`, Rt.ETIMEDOUT));
    }, t);
    const c = () => {
      e && (l && clearTimeout(l), l = null, e.forEach((p) => {
        p.unsubscribe ? p.unsubscribe(s) : p.removeEventListener("abort", s);
      }), e = null);
    };
    e.forEach((p) => p.addEventListener("abort", s));
    const { signal: d } = r;
    return d.unsubscribe = () => be.asap(c), d;
  }
}, Ufe = function* (e, t) {
  let n = e.byteLength;
  if (n < t) {
    yield e;
    return;
  }
  let r = 0, a;
  for (; r < n; )
    a = r + t, yield e.slice(r, a), r = a;
}, Vfe = async function* (e, t) {
  for await (const n of Hfe(e))
    yield* Ufe(n, t);
}, Hfe = async function* (e) {
  if (e[Symbol.asyncIterator]) {
    yield* e;
    return;
  }
  const t = e.getReader();
  try {
    for (; ; ) {
      const { done: n, value: r } = await t.read();
      if (n)
        break;
      yield r;
    }
  } finally {
    await t.cancel();
  }
}, _6 = (e, t, n, r) => {
  const a = Vfe(e, t);
  let s = 0, l, c = (d) => {
    l || (l = !0, r && r(d));
  };
  return new ReadableStream({
    async pull(d) {
      try {
        const { done: p, value: m } = await a.next();
        if (p) {
          c(), d.close();
          return;
        }
        let h = m.byteLength;
        if (n) {
          let v = s += h;
          n(v);
        }
        d.enqueue(new Uint8Array(m));
      } catch (p) {
        throw c(p), p;
      }
    },
    cancel(d) {
      return c(d), a.return();
    }
  }, {
    highWaterMark: 2
  });
}, E6 = 64 * 1024, { isFunction: sk } = be, qfe = (({ Request: e, Response: t }) => ({
  Request: e,
  Response: t
}))(be.global), {
  ReadableStream: C6,
  TextEncoder: O6
} = be.global, M6 = (e, ...t) => {
  try {
    return !!e(...t);
  } catch {
    return !1;
  }
}, Wfe = (e) => {
  e = be.merge.call({
    skipUndefined: !0
  }, qfe, e);
  const { fetch: t, Request: n, Response: r } = e, a = t ? sk(t) : typeof fetch == "function", s = sk(n), l = sk(r);
  if (!a)
    return !1;
  const c = a && sk(C6), d = a && (typeof O6 == "function" ? /* @__PURE__ */ ((w) => (x) => w.encode(x))(new O6()) : async (w) => new Uint8Array(await new n(w).arrayBuffer())), p = s && c && M6(() => {
    let w = !1;
    const x = new n(Ho.origin, {
      body: new C6(),
      method: "POST",
      get duplex() {
        return w = !0, "half";
      }
    }).headers.has("Content-Type");
    return w && !x;
  }), m = l && c && M6(() => be.isReadableStream(new r("").body)), h = {
    stream: m && ((w) => w.body)
  };
  a && ["text", "arrayBuffer", "blob", "formData", "stream"].forEach((w) => {
    !h[w] && (h[w] = (x, b) => {
      let k = x && x[w];
      if (k)
        return k.call(x);
      throw new Rt(`Response type '${w}' is not supported`, Rt.ERR_NOT_SUPPORT, b);
    });
  });
  const v = async (w) => {
    if (w == null)
      return 0;
    if (be.isBlob(w))
      return w.size;
    if (be.isSpecCompliantForm(w))
      return (await new n(Ho.origin, {
        method: "POST",
        body: w
      }).arrayBuffer()).byteLength;
    if (be.isArrayBufferView(w) || be.isArrayBuffer(w))
      return w.byteLength;
    if (be.isURLSearchParams(w) && (w = w + ""), be.isString(w))
      return (await d(w)).byteLength;
  }, y = async (w, x) => be.toFiniteNumber(w.getContentLength()) ?? v(x);
  return async (w) => {
    let {
      url: x,
      method: b,
      data: k,
      signal: C,
      cancelToken: _,
      timeout: O,
      onDownloadProgress: N,
      onUploadProgress: R,
      responseType: j,
      headers: D,
      withCredentials: $ = "same-origin",
      fetchOptions: z
    } = uB(w), B = t || fetch;
    j = j ? (j + "").toLowerCase() : "text";
    let P = Bfe([C, _ && _.toAbortSignal()], O), W = null;
    const I = P && P.unsubscribe && (() => {
      P.unsubscribe();
    });
    let G;
    try {
      if (R && p && b !== "get" && b !== "head" && (G = await y(D, k)) !== 0) {
        let F = new n(x, {
          method: "POST",
          body: k,
          duplex: "half"
        }), X;
        if (be.isFormData(k) && (X = F.headers.get("content-type")) && D.setContentType(X), F.body) {
          const [U, H] = x6(
            G,
            p_(S6(R))
          );
          k = _6(F.body, E6, U, H);
        }
      }
      be.isString($) || ($ = $ ? "include" : "omit");
      const L = s && "credentials" in n.prototype, K = {
        ...z,
        signal: P,
        method: b.toUpperCase(),
        headers: D.normalize().toJSON(),
        body: k,
        duplex: "half",
        credentials: L ? $ : void 0
      };
      W = s && new n(x, K);
      let q = await (s ? B(W, z) : B(x, K));
      const Z = m && (j === "stream" || j === "response");
      if (m && (N || Z && I)) {
        const F = {};
        ["status", "statusText", "headers"].forEach((Q) => {
          F[Q] = q[Q];
        });
        const X = be.toFiniteNumber(q.headers.get("content-length")), [U, H] = N && x6(
          X,
          p_(S6(N), !0)
        ) || [];
        q = new r(
          _6(q.body, E6, U, () => {
            H && H(), I && I();
          }),
          F
        );
      }
      j = j || "text";
      let V = await h[be.findKey(h, j) || "text"](q, w);
      return !Z && I && I(), await new Promise((F, X) => {
        sB(F, X, {
          data: V,
          headers: Ma.from(q.headers),
          status: q.status,
          statusText: q.statusText,
          config: w,
          request: W
        });
      });
    } catch (L) {
      throw I && I(), L && L.name === "TypeError" && /Load failed|fetch/i.test(L.message) ? Object.assign(
        new Rt("Network Error", Rt.ERR_NETWORK, w, W),
        {
          cause: L.cause || L
        }
      ) : Rt.from(L, L && L.code, w, W);
    }
  };
}, Gfe = /* @__PURE__ */ new Map(), cB = (e) => {
  let t = e && e.env || {};
  const { fetch: n, Request: r, Response: a } = t, s = [
    r,
    a,
    n
  ];
  let l = s.length, c = l, d, p, m = Gfe;
  for (; c--; )
    d = s[c], p = m.get(d), p === void 0 && m.set(d, p = c ? /* @__PURE__ */ new Map() : Wfe(t)), m = p;
  return p;
};
cB();
const eA = {
  http: cfe,
  xhr: Ffe,
  fetch: {
    get: cB
  }
};
be.forEach(eA, (e, t) => {
  if (e) {
    try {
      Object.defineProperty(e, "name", { value: t });
    } catch {
    }
    Object.defineProperty(e, "adapterName", { value: t });
  }
});
const N6 = (e) => `- ${e}`, Kfe = (e) => be.isFunction(e) || e === null || e === !1;
function Xfe(e, t) {
  e = be.isArray(e) ? e : [e];
  const { length: n } = e;
  let r, a;
  const s = {};
  for (let l = 0; l < n; l++) {
    r = e[l];
    let c;
    if (a = r, !Kfe(r) && (a = eA[(c = String(r)).toLowerCase()], a === void 0))
      throw new Rt(`Unknown adapter '${c}'`);
    if (a && (be.isFunction(a) || (a = a.get(t))))
      break;
    s[c || "#" + l] = a;
  }
  if (!a) {
    const l = Object.entries(s).map(
      ([d, p]) => `adapter ${d} ` + (p === !1 ? "is not supported by the environment" : "is not available in the build")
    );
    let c = n ? l.length > 1 ? `since :
` + l.map(N6).join(`
`) : " " + N6(l[0]) : "as no adapter specified";
    throw new Rt(
      "There is no suitable adapter to dispatch the request " + c,
      "ERR_NOT_SUPPORT"
    );
  }
  return a;
}
const dB = {
  /**
   * Resolve an adapter from a list of adapter names or functions.
   * @type {Function}
   */
  getAdapter: Xfe,
  /**
   * Exposes all known adapters
   * @type {Object<string, Function|Object>}
   */
  adapters: eA
};
function jM(e) {
  if (e.cancelToken && e.cancelToken.throwIfRequested(), e.signal && e.signal.aborted)
    throw new ig(null, e);
}
function R6(e) {
  return jM(e), e.headers = Ma.from(e.headers), e.data = AM.call(
    e,
    e.transformRequest
  ), ["post", "put", "patch"].indexOf(e.method) !== -1 && e.headers.setContentType("application/x-www-form-urlencoded", !1), dB.getAdapter(e.adapter || mS.adapter, e)(e).then(function(t) {
    return jM(e), t.data = AM.call(
      e,
      e.transformResponse,
      t
    ), t.headers = Ma.from(t.headers), t;
  }, function(t) {
    return iB(t) || (jM(e), t && t.response && (t.response.data = AM.call(
      e,
      e.transformResponse,
      t.response
    ), t.response.headers = Ma.from(t.response.headers))), Promise.reject(t);
  });
}
const fB = "1.13.2", I2 = {};
["object", "boolean", "number", "function", "string", "symbol"].forEach((e, t) => {
  I2[e] = function(n) {
    return typeof n === e || "a" + (t < 1 ? "n " : " ") + e;
  };
});
const A6 = {};
I2.transitional = function(e, t, n) {
  function r(a, s) {
    return "[Axios v" + fB + "] Transitional option '" + a + "'" + s + (n ? ". " + n : "");
  }
  return (a, s, l) => {
    if (e === !1)
      throw new Rt(
        r(s, " has been removed" + (t ? " in " + t : "")),
        Rt.ERR_DEPRECATED
      );
    return t && !A6[s] && (A6[s] = !0, console.warn(
      r(
        s,
        " has been deprecated since v" + t + " and will be removed in the near future"
      )
    )), e ? e(a, s, l) : !0;
  };
};
I2.spelling = function(e) {
  return (t, n) => (console.warn(`${n} is likely a misspelling of ${e}`), !0);
};
function Yfe(e, t, n) {
  if (typeof e != "object")
    throw new Rt("options must be an object", Rt.ERR_BAD_OPTION_VALUE);
  const r = Object.keys(e);
  let a = r.length;
  for (; a-- > 0; ) {
    const s = r[a], l = t[s];
    if (l) {
      const c = e[s], d = c === void 0 || l(c, s, e);
      if (d !== !0)
        throw new Rt("option " + s + " must be " + d, Rt.ERR_BAD_OPTION_VALUE);
      continue;
    }
    if (n !== !0)
      throw new Rt("Unknown option " + s, Rt.ERR_BAD_OPTION);
  }
}
const R0 = {
  assertOptions: Yfe,
  validators: I2
}, Zs = R0.validators;
let rm = class {
  constructor(e) {
    this.defaults = e || {}, this.interceptors = {
      request: new b6(),
      response: new b6()
    };
  }
  /**
   * Dispatch a request
   *
   * @param {String|Object} configOrUrl The config specific for this request (merged with this.defaults)
   * @param {?Object} config
   *
   * @returns {Promise} The Promise to be fulfilled
   */
  async request(e, t) {
    try {
      return await this._request(e, t);
    } catch (n) {
      if (n instanceof Error) {
        let r = {};
        Error.captureStackTrace ? Error.captureStackTrace(r) : r = new Error();
        const a = r.stack ? r.stack.replace(/^.+\n/, "") : "";
        try {
          n.stack ? a && !String(n.stack).endsWith(a.replace(/^.+\n.+\n/, "")) && (n.stack += `
` + a) : n.stack = a;
        } catch {
        }
      }
      throw n;
    }
  }
  _request(e, t) {
    typeof e == "string" ? (t = t || {}, t.url = e) : t = e || {}, t = dm(this.defaults, t);
    const { transitional: n, paramsSerializer: r, headers: a } = t;
    n !== void 0 && R0.assertOptions(n, {
      silentJSONParsing: Zs.transitional(Zs.boolean),
      forcedJSONParsing: Zs.transitional(Zs.boolean),
      clarifyTimeoutError: Zs.transitional(Zs.boolean)
    }, !1), r != null && (be.isFunction(r) ? t.paramsSerializer = {
      serialize: r
    } : R0.assertOptions(r, {
      encode: Zs.function,
      serialize: Zs.function
    }, !0)), t.allowAbsoluteUrls !== void 0 || (this.defaults.allowAbsoluteUrls !== void 0 ? t.allowAbsoluteUrls = this.defaults.allowAbsoluteUrls : t.allowAbsoluteUrls = !0), R0.assertOptions(t, {
      baseUrl: Zs.spelling("baseURL"),
      withXsrfToken: Zs.spelling("withXSRFToken")
    }, !0), t.method = (t.method || this.defaults.method || "get").toLowerCase();
    let s = a && be.merge(
      a.common,
      a[t.method]
    );
    a && be.forEach(
      ["delete", "get", "head", "post", "put", "patch", "common"],
      (y) => {
        delete a[y];
      }
    ), t.headers = Ma.concat(s, a);
    const l = [];
    let c = !0;
    this.interceptors.request.forEach(function(y) {
      typeof y.runWhen == "function" && y.runWhen(t) === !1 || (c = c && y.synchronous, l.unshift(y.fulfilled, y.rejected));
    });
    const d = [];
    this.interceptors.response.forEach(function(y) {
      d.push(y.fulfilled, y.rejected);
    });
    let p, m = 0, h;
    if (!c) {
      const y = [R6.bind(this), void 0];
      for (y.unshift(...l), y.push(...d), h = y.length, p = Promise.resolve(t); m < h; )
        p = p.then(y[m++], y[m++]);
      return p;
    }
    h = l.length;
    let v = t;
    for (; m < h; ) {
      const y = l[m++], w = l[m++];
      try {
        v = y(v);
      } catch (x) {
        w.call(this, x);
        break;
      }
    }
    try {
      p = R6.call(this, v);
    } catch (y) {
      return Promise.reject(y);
    }
    for (m = 0, h = d.length; m < h; )
      p = p.then(d[m++], d[m++]);
    return p;
  }
  getUri(e) {
    e = dm(this.defaults, e);
    const t = lB(e.baseURL, e.url, e.allowAbsoluteUrls);
    return rB(t, e.params, e.paramsSerializer);
  }
};
be.forEach(["delete", "get", "head", "options"], function(e) {
  rm.prototype[e] = function(t, n) {
    return this.request(dm(n || {}, {
      method: e,
      url: t,
      data: (n || {}).data
    }));
  };
});
be.forEach(["post", "put", "patch"], function(e) {
  function t(n) {
    return function(r, a, s) {
      return this.request(dm(s || {}, {
        method: e,
        headers: n ? {
          "Content-Type": "multipart/form-data"
        } : {},
        url: r,
        data: a
      }));
    };
  }
  rm.prototype[e] = t(), rm.prototype[e + "Form"] = t(!0);
});
let Qfe = class pB {
  constructor(t) {
    if (typeof t != "function")
      throw new TypeError("executor must be a function.");
    let n;
    this.promise = new Promise(function(a) {
      n = a;
    });
    const r = this;
    this.promise.then((a) => {
      if (!r._listeners) return;
      let s = r._listeners.length;
      for (; s-- > 0; )
        r._listeners[s](a);
      r._listeners = null;
    }), this.promise.then = (a) => {
      let s;
      const l = new Promise((c) => {
        r.subscribe(c), s = c;
      }).then(a);
      return l.cancel = function() {
        r.unsubscribe(s);
      }, l;
    }, t(function(a, s, l) {
      r.reason || (r.reason = new ig(a, s, l), n(r.reason));
    });
  }
  /**
   * Throws a `CanceledError` if cancellation has been requested.
   */
  throwIfRequested() {
    if (this.reason)
      throw this.reason;
  }
  /**
   * Subscribe to the cancel signal
   */
  subscribe(t) {
    if (this.reason) {
      t(this.reason);
      return;
    }
    this._listeners ? this._listeners.push(t) : this._listeners = [t];
  }
  /**
   * Unsubscribe from the cancel signal
   */
  unsubscribe(t) {
    if (!this._listeners)
      return;
    const n = this._listeners.indexOf(t);
    n !== -1 && this._listeners.splice(n, 1);
  }
  toAbortSignal() {
    const t = new AbortController(), n = (r) => {
      t.abort(r);
    };
    return this.subscribe(n), t.signal.unsubscribe = () => this.unsubscribe(n), t.signal;
  }
  /**
   * Returns an object that contains a new `CancelToken` and a function that, when called,
   * cancels the `CancelToken`.
   */
  static source() {
    let t;
    return {
      token: new pB(function(n) {
        t = n;
      }),
      cancel: t
    };
  }
};
function Jfe(e) {
  return function(t) {
    return e.apply(null, t);
  };
}
function Zfe(e) {
  return be.isObject(e) && e.isAxiosError === !0;
}
const j5 = {
  Continue: 100,
  SwitchingProtocols: 101,
  Processing: 102,
  EarlyHints: 103,
  Ok: 200,
  Created: 201,
  Accepted: 202,
  NonAuthoritativeInformation: 203,
  NoContent: 204,
  ResetContent: 205,
  PartialContent: 206,
  MultiStatus: 207,
  AlreadyReported: 208,
  ImUsed: 226,
  MultipleChoices: 300,
  MovedPermanently: 301,
  Found: 302,
  SeeOther: 303,
  NotModified: 304,
  UseProxy: 305,
  Unused: 306,
  TemporaryRedirect: 307,
  PermanentRedirect: 308,
  BadRequest: 400,
  Unauthorized: 401,
  PaymentRequired: 402,
  Forbidden: 403,
  NotFound: 404,
  MethodNotAllowed: 405,
  NotAcceptable: 406,
  ProxyAuthenticationRequired: 407,
  RequestTimeout: 408,
  Conflict: 409,
  Gone: 410,
  LengthRequired: 411,
  PreconditionFailed: 412,
  PayloadTooLarge: 413,
  UriTooLong: 414,
  UnsupportedMediaType: 415,
  RangeNotSatisfiable: 416,
  ExpectationFailed: 417,
  ImATeapot: 418,
  MisdirectedRequest: 421,
  UnprocessableEntity: 422,
  Locked: 423,
  FailedDependency: 424,
  TooEarly: 425,
  UpgradeRequired: 426,
  PreconditionRequired: 428,
  TooManyRequests: 429,
  RequestHeaderFieldsTooLarge: 431,
  UnavailableForLegalReasons: 451,
  InternalServerError: 500,
  NotImplemented: 501,
  BadGateway: 502,
  ServiceUnavailable: 503,
  GatewayTimeout: 504,
  HttpVersionNotSupported: 505,
  VariantAlsoNegotiates: 506,
  InsufficientStorage: 507,
  LoopDetected: 508,
  NotExtended: 510,
  NetworkAuthenticationRequired: 511,
  WebServerIsDown: 521,
  ConnectionTimedOut: 522,
  OriginIsUnreachable: 523,
  TimeoutOccurred: 524,
  SslHandshakeFailed: 525,
  InvalidSslCertificate: 526
};
Object.entries(j5).forEach(([e, t]) => {
  j5[t] = e;
});
function mB(e) {
  const t = new rm(e), n = q7(rm.prototype.request, t);
  return be.extend(n, rm.prototype, t, { allOwnKeys: !0 }), be.extend(n, t, null, { allOwnKeys: !0 }), n.create = function(r) {
    return mB(dm(e, r));
  }, n;
}
const Cr = mB(mS);
Cr.Axios = rm;
Cr.CanceledError = ig;
Cr.CancelToken = Qfe;
Cr.isCancel = iB;
Cr.VERSION = fB;
Cr.toFormData = L2;
Cr.AxiosError = Rt;
Cr.Cancel = Cr.CanceledError;
Cr.all = function(e) {
  return Promise.all(e);
};
Cr.spread = Jfe;
Cr.isAxiosError = Zfe;
Cr.mergeConfig = dm;
Cr.AxiosHeaders = Ma;
Cr.formToJSON = (e) => aB(be.isHTMLForm(e) ? new FormData(e) : e);
Cr.getAdapter = dB.getAdapter;
Cr.HttpStatusCode = j5;
Cr.default = Cr;
const {
  Axios: g9e,
  AxiosError: v9e,
  CanceledError: y9e,
  isCancel: b9e,
  CancelToken: w9e,
  VERSION: x9e,
  all: S9e,
  Cancel: k9e,
  isAxiosError: _9e,
  spread: E9e,
  toFormData: C9e,
  AxiosHeaders: O9e,
  HttpStatusCode: M9e,
  formToJSON: N9e,
  getAdapter: R9e,
  mergeConfig: A9e
} = Cr;
class hB extends YR {
  constructor(t) {
    super(t), this._websocket = null, this.reconnectAttempts = 0, this.maxReconnectAttempts = 999, this.initialTimeout = 200, this.maxTimeout = 5e3, this._reconnect = !0, this._reconnect_timeout = void 0, this._url = t.url, this._reconnect_timeout = setTimeout(() => {
      this.connect();
    }, 200), this._zustand && this._zustand.auto_progress();
  }
  connect() {
    this._zustand?.logger.info("Connecting to websocket"), this.is_open = !1, this._websocket = new WebSocket(this._url), this._websocket.onopen = () => {
      this.onopen();
    }, this._websocket.onclose = () => {
      this.onclose();
    }, this._websocket.onerror = () => {
      this.on_ws_error();
    }, this._websocket.onmessage = (t) => {
      typeof t.data == "string" ? this.onmessage(t.data) : t.data instanceof Blob && t.data.arrayBuffer().then((n) => {
        const r = new Uint8Array(n);
        this.getCommunicationManager().onbytes(r);
      });
    };
  }
  calculateReconnectTimeout() {
    return Math.min(
      this.initialTimeout * Math.pow(2, this.reconnectAttempts),
      this.maxTimeout
    );
  }
  auto_reconnect() {
    if (this.reconnectAttempts < this.maxReconnectAttempts) {
      let t = this.calculateReconnectTimeout();
      this._zustand?.logger.info(`Attempting to reconnect in ${t} ms`), this._reconnect_timeout = setTimeout(() => {
        this._websocket && this._websocket.readyState === WebSocket.OPEN || (this.reconnectAttempts++, this.connect());
      }, t);
    } else
      this._zustand?.logger.warn(
        "Maximum reconnect attempts reached. Giving up."
      );
  }
  async onmessage(t) {
    try {
      const n = JSON.parse(t);
      this._zustand?.logger.debug(
        `Recieved data of length: ${t.length} and data"`,
        n
      ), await this.getCommunicationManager().receive(n);
    } catch (n) {
      console.error("Websocketworker: onmessage JSON.parse error", n, t);
      return;
    }
  }
  get http_protocol() {
    return this.secure_url ? "https" : "http";
  }
  get secure_url() {
    return this._url.startsWith("wss");
  }
  get url_wo_protocol() {
    return this._url.substring(this.secure_url ? 6 : 5);
  }
  get http_url() {
    var t = this.http_protocol + "://" + this.url_wo_protocol;
    return t[t.length - 1] !== "/" && (t += "/"), t;
  }
  get_io_subscription_url({
    node_id: t,
    io_id: n,
    stream: r
  }) {
    let a = this.http_url + `node/${t}/io/${n}/value`;
    return r && (a += "/stream"), a;
  }
  async upload_file({
    files: t,
    onProgressCallback: n,
    root: r
  }) {
    const a = `${this.http_url}upload/`, s = new FormData(), l = Array.isArray(t) ? t : Array.from(t);
    for (const c of l) {
      const d = c.webkitRelativePath || c.name, p = r ? `${r}/${d}` : d;
      s.append("file", c, p);
    }
    try {
      return (await Cr.post(a, s, {
        headers: {
          "Content-Type": "multipart/form-data"
        },
        onUploadProgress: (c) => {
          n && n(c.loaded, c.total);
        }
      })).data.file;
    } catch {
      throw new Error("Failed to upload file");
    }
  }
  async handle_large_message_hint({ msg_id: t }) {
    const n = this.http_url + "message/" + t, r = await (await fetch(n, {
      method: "GET",
      headers: {
        "Content-Type": "application/json",
        "Access-Control-Allow-Origin": "*"
      }
    })).json();
    this.getCommunicationManager().receive(r);
  }
  onopen() {
    this._zustand?.logger.info("Websocket opened"), this.is_open = !0, this._zustand && this._zustand.auto_progress(), this.reconnectAttempts = 0, this.getSyncManager().stepwise_fullsync();
  }
  onclose() {
    this._zustand?.logger.info("Websocket closed"), super.onclose(), this._reconnect && (this._zustand?.logger.info("Websocket closed,reconnecting"), this.auto_reconnect());
  }
  on_ws_error() {
    this._zustand?.logger.warn("Websocket error"), this._websocket ? this._websocket.close() : this.auto_reconnect();
  }
  async send_large_message(t) {
    const n = `${this.http_url}message/`;
    await fetch(n, {
      method: "POST",
      headers: {
        "Content-Type": "application/json"
      },
      body: t
    });
  }
  async send(t) {
    if (!this._websocket || this._websocket.readyState !== WebSocket.OPEN) {
      this._zustand?.logger.warn("Websocket not connected");
      return;
    }
    const n = JSON.stringify(t);
    if (new Blob([n]).size > 1e6)
      return this._zustand?.logger.info("Data too large, sending via http"), await this.send_large_message(n);
    this._zustand?.logger.debug("Sending data", t), this._websocket.send(n);
  }
  async stop() {
    await super.stop(), this._reconnect = !1;
  }
  close() {
    this._websocket && this._websocket.close();
  }
  disconnect() {
    super.disconnect(), this._reconnect = !1, this._reconnect_timeout && (clearTimeout(this._reconnect_timeout), this._reconnect_timeout = void 0), this.close();
  }
  async reconnect() {
    if (await super.reconnect(), this._reconnect = !0, this._websocket && (this._zustand?.logger.info("Reconnecting"), (this._websocket.readyState === WebSocket.OPEN || this._websocket.readyState === WebSocket.CONNECTING) && (this._websocket.readyState === WebSocket.CONNECTING && await new Promise((t, n) => {
      if (this._websocket === null) return;
      let r = setTimeout(() => {
        n("Timeout@reconnect");
      }, 2e3);
      this._websocket.addEventListener(
        "open",
        () => {
          clearTimeout(r), t(null);
        },
        { once: !0 }
      ), this._websocket.readyState === WebSocket.OPEN && (clearTimeout(r), t(null));
    }), this._websocket.readyState === WebSocket.OPEN))) {
      this.getSyncManager().stepwise_fullsync();
      return;
    }
    this.connect();
  }
}
class epe {
  constructor(t, n) {
    this.ws = null, this.reconnectAttempts = 0, this.maxReconnectAttempts = 999, this.initialTimeout = 200, this.maxTimeout = 2e3, n.logger.debug("Initializing worker manager"), this._wsuri = t, this.zustand = n, this.workers = {}, this.on_setWorker = (r) => {
      this.zustand.set_worker(r);
    }, this.connectionTimeout = setTimeout(() => {
      this.connect();
    }, 200);
  }
  get wsuri() {
    return this._wsuri;
  }
  get open() {
    return this.ws?.readyState === WebSocket.OPEN;
  }
  connect() {
    this.zustand.set_progress({
      progress: 0,
      message: "connecting to worker manager",
      status: "info",
      blocking: !0
    }), this.zustand.logger.info("Connecting to websocket:", this._wsuri), this.ws = new WebSocket(this._wsuri), this.ws.onopen = () => {
      this.onopen();
    }, this.ws.onclose = () => {
      this.onclose();
    }, this.ws.onerror = () => {
      this.on_ws_error();
    }, this.ws.onmessage = (t) => {
      typeof t.data == "string" ? this.onmessage(t.data) : console.error(
        "WorkerManager: onmessage event.data is not a string",
        typeof t.data
      );
    }, this.connectionTimeout = setTimeout(() => {
      this.ws?.readyState !== WebSocket.OPEN && this.on_ws_error();
    }, 5e3);
  }
  on_ws_error() {
    console.warn("Websocket error"), this.ws ? this.ws.close() : this.reconnect();
  }
  onopen() {
    this.connectionTimeout && (clearTimeout(this.connectionTimeout), this.connectionTimeout = void 0), this.zustand.auto_progress(), this.ws && this.ws.send("worker_status");
  }
  onmessage(t) {
    try {
      let n = JSON.parse(t);
      if (n.type === "worker_status") {
        const r = {};
        for (let a of n.active)
          a.active = !0, r[a.uuid] = a;
        for (let a of n.inactive)
          a.active = !1, r[a.uuid] = a;
        if (this.zustand.workers.setState(r), !this.zustand.worker) {
          const a = window.localStorage.getItem(
            "funcnodes__active_worker"
          );
          a && r[a] && r[a].active && this.set_active(a);
        }
        return;
      } else if (n.type === "set_worker") {
        if (n.data.type === "WSWorker") {
          let r = "ws" + (n.data.ssl ? "s" : "") + "://" + n.data.host + ":" + n.data.port;
          this.setWorker(
            this.workers[n.data.uuid] || new hB({
              url: r,
              zustand: this.zustand,
              uuid: n.data.uuid,
              on_sync_complete: this.zustand.options.on_sync_complete
            })
          );
        } else
          this.zustand.logger.error("WorkerManager: unknown worker type", n);
        return;
      } else if (n.type === "progress") {
        this.zustand.set_progress(n);
        return;
      }
      this.zustand.logger.error("WorkerManager: unknown message", n);
    } catch (n) {
      console.error("WorkerManager: onmessage JSON.parse error", n, t);
      return;
    }
  }
  setWorker(t) {
    for (let n in this.workers)
      n !== t?.uuid && this.workers[n].disconnect();
    t !== void 0 && (this.workers[t.uuid] = t, t.reconnect()), t?.uuid && window.localStorage.setItem("funcnodes__active_worker", t?.uuid), this.zustand.worker !== void 0 && this.zustand.clear_all(), this.zustand.set_worker(t), this.on_setWorker(t);
  }
  async restart_worker(t) {
    this.ws?.send(JSON.stringify({ type: "restart_worker", workerid: t }));
  }
  calculateReconnectTimeout() {
    return Math.min(
      this.initialTimeout * Math.pow(2, this.reconnectAttempts),
      this.maxTimeout
    );
  }
  reconnect() {
    if (this.reconnectAttempts < this.maxReconnectAttempts) {
      let t = this.calculateReconnectTimeout();
      this.zustand.logger.info(`Attempting to reconnect in ${t} ms`), setTimeout(() => {
        this.ws && this.ws.readyState === WebSocket.OPEN || (this.reconnectAttempts++, this.connect());
      }, t);
    } else
      this.zustand.logger.warn(
        "Maximum reconnect attempts reached. Giving up."
      );
  }
  onclose() {
    this.zustand.logger.warn("WorkerManager: onclose"), this.reconnect();
  }
  set_active(t) {
    this.ws && this.ws.send(JSON.stringify({ type: "set_active", workerid: t }));
  }
  new_worker({
    name: t,
    reference: n,
    copyLib: r,
    copyNS: a,
    in_venv: s
  }) {
    t || (t = void 0), r || (r = !1), a || (a = !1), n || (n = void 0, r = !1, a = !1), this.ws && this.ws.send(
      JSON.stringify({
        type: "new_worker",
        kwargs: {
          name: t,
          reference: n,
          copyLib: r,
          copyNS: a,
          in_venv: s
        }
      })
    );
  }
  remove() {
    for (let t in this.workers)
      this.workers[t].disconnect();
    this.connectionTimeout && (clearTimeout(this.connectionTimeout), this.connectionTimeout = void 0), this.ws && (this.ws.onclose = () => {
    }, this.ws.onerror = () => {
    }, this.ws.onmessage = () => {
    }, this.ws.onopen = () => {
    }, this.ws.close());
  }
}
const xa = () => {
  const e = yn();
  return e.worker ? {
    ...e.worker.api,
    worker: e.worker
  } : {
    node: void 0,
    group: void 0,
    edge: void 0,
    hooks: void 0,
    lib: void 0,
    worker: e.worker
  };
}, tpe = {
  show: !0
}, npe = {
  show: !0,
  showmenu: !0
}, rpe = {
  minimap: !0,
  static: !1,
  minZoom: 0.1,
  maxZoom: 5,
  allowFullScreen: !0,
  allowExpand: !0,
  showNodeSettings: !0
}, ope = {
  id: "",
  // required
  debug: !1,
  useWorkerManager: !0,
  show_library: !0,
  header: npe,
  flow: rpe,
  library: tpe
}, gB = [
  "classic",
  "metal",
  "light",
  "solarized",
  "midnight",
  "forest",
  "scientific",
  "neon",
  "ocean",
  "sunset"
];
function Pr(e) {
  if (typeof e == "string" || typeof e == "number") return "" + e;
  let t = "";
  if (Array.isArray(e))
    for (let n = 0, r; n < e.length; n++)
      (r = Pr(e[n])) !== "" && (t += (t && " ") + r);
  else
    for (let n in e)
      e[n] && (t += (t && " ") + n);
  return t;
}
var ape = { value: () => {
} };
function z2() {
  for (var e = 0, t = arguments.length, n = {}, r; e < t; ++e) {
    if (!(r = arguments[e] + "") || r in n || /[\s.]/.test(r)) throw new Error("illegal type: " + r);
    n[r] = [];
  }
  return new A0(n);
}
function A0(e) {
  this._ = e;
}
function ipe(e, t) {
  return e.trim().split(/^|\s+/).map(function(n) {
    var r = "", a = n.indexOf(".");
    if (a >= 0 && (r = n.slice(a + 1), n = n.slice(0, a)), n && !t.hasOwnProperty(n)) throw new Error("unknown type: " + n);
    return { type: n, name: r };
  });
}
A0.prototype = z2.prototype = {
  constructor: A0,
  on: function(e, t) {
    var n = this._, r = ipe(e + "", n), a, s = -1, l = r.length;
    if (arguments.length < 2) {
      for (; ++s < l; ) if ((a = (e = r[s]).type) && (a = spe(n[a], e.name))) return a;
      return;
    }
    if (t != null && typeof t != "function") throw new Error("invalid callback: " + t);
    for (; ++s < l; )
      if (a = (e = r[s]).type) n[a] = j6(n[a], e.name, t);
      else if (t == null) for (a in n) n[a] = j6(n[a], e.name, null);
    return this;
  },
  copy: function() {
    var e = {}, t = this._;
    for (var n in t) e[n] = t[n].slice();
    return new A0(e);
  },
  call: function(e, t) {
    if ((a = arguments.length - 2) > 0) for (var n = new Array(a), r = 0, a, s; r < a; ++r) n[r] = arguments[r + 2];
    if (!this._.hasOwnProperty(e)) throw new Error("unknown type: " + e);
    for (s = this._[e], r = 0, a = s.length; r < a; ++r) s[r].value.apply(t, n);
  },
  apply: function(e, t, n) {
    if (!this._.hasOwnProperty(e)) throw new Error("unknown type: " + e);
    for (var r = this._[e], a = 0, s = r.length; a < s; ++a) r[a].value.apply(t, n);
  }
};
function spe(e, t) {
  for (var n = 0, r = e.length, a; n < r; ++n)
    if ((a = e[n]).name === t)
      return a.value;
}
function j6(e, t, n) {
  for (var r = 0, a = e.length; r < a; ++r)
    if (e[r].name === t) {
      e[r] = ape, e = e.slice(0, r).concat(e.slice(r + 1));
      break;
    }
  return n != null && e.push({ name: t, value: n }), e;
}
var P5 = "http://www.w3.org/1999/xhtml";
const P6 = {
  svg: "http://www.w3.org/2000/svg",
  xhtml: P5,
  xlink: "http://www.w3.org/1999/xlink",
  xml: "http://www.w3.org/XML/1998/namespace",
  xmlns: "http://www.w3.org/2000/xmlns/"
};
function F2(e) {
  var t = e += "", n = t.indexOf(":");
  return n >= 0 && (t = e.slice(0, n)) !== "xmlns" && (e = e.slice(n + 1)), P6.hasOwnProperty(t) ? { space: P6[t], local: e } : e;
}
function lpe(e) {
  return function() {
    var t = this.ownerDocument, n = this.namespaceURI;
    return n === P5 && t.documentElement.namespaceURI === P5 ? t.createElement(e) : t.createElementNS(n, e);
  };
}
function upe(e) {
  return function() {
    return this.ownerDocument.createElementNS(e.space, e.local);
  };
}
function vB(e) {
  var t = F2(e);
  return (t.local ? upe : lpe)(t);
}
function cpe() {
}
function tA(e) {
  return e == null ? cpe : function() {
    return this.querySelector(e);
  };
}
function dpe(e) {
  typeof e != "function" && (e = tA(e));
  for (var t = this._groups, n = t.length, r = new Array(n), a = 0; a < n; ++a)
    for (var s = t[a], l = s.length, c = r[a] = new Array(l), d, p, m = 0; m < l; ++m)
      (d = s[m]) && (p = e.call(d, d.__data__, m, s)) && ("__data__" in d && (p.__data__ = d.__data__), c[m] = p);
  return new wi(r, this._parents);
}
function fpe(e) {
  return e == null ? [] : Array.isArray(e) ? e : Array.from(e);
}
function ppe() {
  return [];
}
function yB(e) {
  return e == null ? ppe : function() {
    return this.querySelectorAll(e);
  };
}
function mpe(e) {
  return function() {
    return fpe(e.apply(this, arguments));
  };
}
function hpe(e) {
  typeof e == "function" ? e = mpe(e) : e = yB(e);
  for (var t = this._groups, n = t.length, r = [], a = [], s = 0; s < n; ++s)
    for (var l = t[s], c = l.length, d, p = 0; p < c; ++p)
      (d = l[p]) && (r.push(e.call(d, d.__data__, p, l)), a.push(d));
  return new wi(r, a);
}
function bB(e) {
  return function() {
    return this.matches(e);
  };
}
function wB(e) {
  return function(t) {
    return t.matches(e);
  };
}
var gpe = Array.prototype.find;
function vpe(e) {
  return function() {
    return gpe.call(this.children, e);
  };
}
function ype() {
  return this.firstElementChild;
}
function bpe(e) {
  return this.select(e == null ? ype : vpe(typeof e == "function" ? e : wB(e)));
}
var wpe = Array.prototype.filter;
function xpe() {
  return Array.from(this.children);
}
function Spe(e) {
  return function() {
    return wpe.call(this.children, e);
  };
}
function kpe(e) {
  return this.selectAll(e == null ? xpe : Spe(typeof e == "function" ? e : wB(e)));
}
function _pe(e) {
  typeof e != "function" && (e = bB(e));
  for (var t = this._groups, n = t.length, r = new Array(n), a = 0; a < n; ++a)
    for (var s = t[a], l = s.length, c = r[a] = [], d, p = 0; p < l; ++p)
      (d = s[p]) && e.call(d, d.__data__, p, s) && c.push(d);
  return new wi(r, this._parents);
}
function xB(e) {
  return new Array(e.length);
}
function Epe() {
  return new wi(this._enter || this._groups.map(xB), this._parents);
}
function m_(e, t) {
  this.ownerDocument = e.ownerDocument, this.namespaceURI = e.namespaceURI, this._next = null, this._parent = e, this.__data__ = t;
}
m_.prototype = {
  constructor: m_,
  appendChild: function(e) {
    return this._parent.insertBefore(e, this._next);
  },
  insertBefore: function(e, t) {
    return this._parent.insertBefore(e, t);
  },
  querySelector: function(e) {
    return this._parent.querySelector(e);
  },
  querySelectorAll: function(e) {
    return this._parent.querySelectorAll(e);
  }
};
function Cpe(e) {
  return function() {
    return e;
  };
}
function Ope(e, t, n, r, a, s) {
  for (var l = 0, c, d = t.length, p = s.length; l < p; ++l)
    (c = t[l]) ? (c.__data__ = s[l], r[l] = c) : n[l] = new m_(e, s[l]);
  for (; l < d; ++l)
    (c = t[l]) && (a[l] = c);
}
function Mpe(e, t, n, r, a, s, l) {
  var c, d, p = /* @__PURE__ */ new Map(), m = t.length, h = s.length, v = new Array(m), y;
  for (c = 0; c < m; ++c)
    (d = t[c]) && (v[c] = y = l.call(d, d.__data__, c, t) + "", p.has(y) ? a[c] = d : p.set(y, d));
  for (c = 0; c < h; ++c)
    y = l.call(e, s[c], c, s) + "", (d = p.get(y)) ? (r[c] = d, d.__data__ = s[c], p.delete(y)) : n[c] = new m_(e, s[c]);
  for (c = 0; c < m; ++c)
    (d = t[c]) && p.get(v[c]) === d && (a[c] = d);
}
function Npe(e) {
  return e.__data__;
}
function Rpe(e, t) {
  if (!arguments.length) return Array.from(this, Npe);
  var n = t ? Mpe : Ope, r = this._parents, a = this._groups;
  typeof e != "function" && (e = Cpe(e));
  for (var s = a.length, l = new Array(s), c = new Array(s), d = new Array(s), p = 0; p < s; ++p) {
    var m = r[p], h = a[p], v = h.length, y = Ape(e.call(m, m && m.__data__, p, r)), w = y.length, x = c[p] = new Array(w), b = l[p] = new Array(w), k = d[p] = new Array(v);
    n(m, h, x, b, k, y, t);
    for (var C = 0, _ = 0, O, N; C < w; ++C)
      if (O = x[C]) {
        for (C >= _ && (_ = C + 1); !(N = b[_]) && ++_ < w; ) ;
        O._next = N || null;
      }
  }
  return l = new wi(l, r), l._enter = c, l._exit = d, l;
}
function Ape(e) {
  return typeof e == "object" && "length" in e ? e : Array.from(e);
}
function jpe() {
  return new wi(this._exit || this._groups.map(xB), this._parents);
}
function Ppe(e, t, n) {
  var r = this.enter(), a = this, s = this.exit();
  return typeof e == "function" ? (r = e(r), r && (r = r.selection())) : r = r.append(e + ""), t != null && (a = t(a), a && (a = a.selection())), n == null ? s.remove() : n(s), r && a ? r.merge(a).order() : a;
}
function Dpe(e) {
  for (var t = e.selection ? e.selection() : e, n = this._groups, r = t._groups, a = n.length, s = r.length, l = Math.min(a, s), c = new Array(a), d = 0; d < l; ++d)
    for (var p = n[d], m = r[d], h = p.length, v = c[d] = new Array(h), y, w = 0; w < h; ++w)
      (y = p[w] || m[w]) && (v[w] = y);
  for (; d < a; ++d)
    c[d] = n[d];
  return new wi(c, this._parents);
}
function $pe() {
  for (var e = this._groups, t = -1, n = e.length; ++t < n; )
    for (var r = e[t], a = r.length - 1, s = r[a], l; --a >= 0; )
      (l = r[a]) && (s && l.compareDocumentPosition(s) ^ 4 && s.parentNode.insertBefore(l, s), s = l);
  return this;
}
function Tpe(e) {
  e || (e = Lpe);
  function t(h, v) {
    return h && v ? e(h.__data__, v.__data__) : !h - !v;
  }
  for (var n = this._groups, r = n.length, a = new Array(r), s = 0; s < r; ++s) {
    for (var l = n[s], c = l.length, d = a[s] = new Array(c), p, m = 0; m < c; ++m)
      (p = l[m]) && (d[m] = p);
    d.sort(t);
  }
  return new wi(a, this._parents).order();
}
function Lpe(e, t) {
  return e < t ? -1 : e > t ? 1 : e >= t ? 0 : NaN;
}
function Ipe() {
  var e = arguments[0];
  return arguments[0] = this, e.apply(null, arguments), this;
}
function zpe() {
  return Array.from(this);
}
function Fpe() {
  for (var e = this._groups, t = 0, n = e.length; t < n; ++t)
    for (var r = e[t], a = 0, s = r.length; a < s; ++a) {
      var l = r[a];
      if (l) return l;
    }
  return null;
}
function Bpe() {
  let e = 0;
  for (const t of this) ++e;
  return e;
}
function Upe() {
  return !this.node();
}
function Vpe(e) {
  for (var t = this._groups, n = 0, r = t.length; n < r; ++n)
    for (var a = t[n], s = 0, l = a.length, c; s < l; ++s)
      (c = a[s]) && e.call(c, c.__data__, s, a);
  return this;
}
function Hpe(e) {
  return function() {
    this.removeAttribute(e);
  };
}
function qpe(e) {
  return function() {
    this.removeAttributeNS(e.space, e.local);
  };
}
function Wpe(e, t) {
  return function() {
    this.setAttribute(e, t);
  };
}
function Gpe(e, t) {
  return function() {
    this.setAttributeNS(e.space, e.local, t);
  };
}
function Kpe(e, t) {
  return function() {
    var n = t.apply(this, arguments);
    n == null ? this.removeAttribute(e) : this.setAttribute(e, n);
  };
}
function Xpe(e, t) {
  return function() {
    var n = t.apply(this, arguments);
    n == null ? this.removeAttributeNS(e.space, e.local) : this.setAttributeNS(e.space, e.local, n);
  };
}
function Ype(e, t) {
  var n = F2(e);
  if (arguments.length < 2) {
    var r = this.node();
    return n.local ? r.getAttributeNS(n.space, n.local) : r.getAttribute(n);
  }
  return this.each((t == null ? n.local ? qpe : Hpe : typeof t == "function" ? n.local ? Xpe : Kpe : n.local ? Gpe : Wpe)(n, t));
}
function SB(e) {
  return e.ownerDocument && e.ownerDocument.defaultView || e.document && e || e.defaultView;
}
function Qpe(e) {
  return function() {
    this.style.removeProperty(e);
  };
}
function Jpe(e, t, n) {
  return function() {
    this.style.setProperty(e, t, n);
  };
}
function Zpe(e, t, n) {
  return function() {
    var r = t.apply(this, arguments);
    r == null ? this.style.removeProperty(e) : this.style.setProperty(e, r, n);
  };
}
function eme(e, t, n) {
  return arguments.length > 1 ? this.each((t == null ? Qpe : typeof t == "function" ? Zpe : Jpe)(e, t, n ?? "")) : Lh(this.node(), e);
}
function Lh(e, t) {
  return e.style.getPropertyValue(t) || SB(e).getComputedStyle(e, null).getPropertyValue(t);
}
function tme(e) {
  return function() {
    delete this[e];
  };
}
function nme(e, t) {
  return function() {
    this[e] = t;
  };
}
function rme(e, t) {
  return function() {
    var n = t.apply(this, arguments);
    n == null ? delete this[e] : this[e] = n;
  };
}
function ome(e, t) {
  return arguments.length > 1 ? this.each((t == null ? tme : typeof t == "function" ? rme : nme)(e, t)) : this.node()[e];
}
function kB(e) {
  return e.trim().split(/^|\s+/);
}
function nA(e) {
  return e.classList || new _B(e);
}
function _B(e) {
  this._node = e, this._names = kB(e.getAttribute("class") || "");
}
_B.prototype = {
  add: function(e) {
    var t = this._names.indexOf(e);
    t < 0 && (this._names.push(e), this._node.setAttribute("class", this._names.join(" ")));
  },
  remove: function(e) {
    var t = this._names.indexOf(e);
    t >= 0 && (this._names.splice(t, 1), this._node.setAttribute("class", this._names.join(" ")));
  },
  contains: function(e) {
    return this._names.indexOf(e) >= 0;
  }
};
function EB(e, t) {
  for (var n = nA(e), r = -1, a = t.length; ++r < a; ) n.add(t[r]);
}
function CB(e, t) {
  for (var n = nA(e), r = -1, a = t.length; ++r < a; ) n.remove(t[r]);
}
function ame(e) {
  return function() {
    EB(this, e);
  };
}
function ime(e) {
  return function() {
    CB(this, e);
  };
}
function sme(e, t) {
  return function() {
    (t.apply(this, arguments) ? EB : CB)(this, e);
  };
}
function lme(e, t) {
  var n = kB(e + "");
  if (arguments.length < 2) {
    for (var r = nA(this.node()), a = -1, s = n.length; ++a < s; ) if (!r.contains(n[a])) return !1;
    return !0;
  }
  return this.each((typeof t == "function" ? sme : t ? ame : ime)(n, t));
}
function ume() {
  this.textContent = "";
}
function cme(e) {
  return function() {
    this.textContent = e;
  };
}
function dme(e) {
  return function() {
    var t = e.apply(this, arguments);
    this.textContent = t ?? "";
  };
}
function fme(e) {
  return arguments.length ? this.each(e == null ? ume : (typeof e == "function" ? dme : cme)(e)) : this.node().textContent;
}
function pme() {
  this.innerHTML = "";
}
function mme(e) {
  return function() {
    this.innerHTML = e;
  };
}
function hme(e) {
  return function() {
    var t = e.apply(this, arguments);
    this.innerHTML = t ?? "";
  };
}
function gme(e) {
  return arguments.length ? this.each(e == null ? pme : (typeof e == "function" ? hme : mme)(e)) : this.node().innerHTML;
}
function vme() {
  this.nextSibling && this.parentNode.appendChild(this);
}
function yme() {
  return this.each(vme);
}
function bme() {
  this.previousSibling && this.parentNode.insertBefore(this, this.parentNode.firstChild);
}
function wme() {
  return this.each(bme);
}
function xme(e) {
  var t = typeof e == "function" ? e : vB(e);
  return this.select(function() {
    return this.appendChild(t.apply(this, arguments));
  });
}
function Sme() {
  return null;
}
function kme(e, t) {
  var n = typeof e == "function" ? e : vB(e), r = t == null ? Sme : typeof t == "function" ? t : tA(t);
  return this.select(function() {
    return this.insertBefore(n.apply(this, arguments), r.apply(this, arguments) || null);
  });
}
function _me() {
  var e = this.parentNode;
  e && e.removeChild(this);
}
function Eme() {
  return this.each(_me);
}
function Cme() {
  var e = this.cloneNode(!1), t = this.parentNode;
  return t ? t.insertBefore(e, this.nextSibling) : e;
}
function Ome() {
  var e = this.cloneNode(!0), t = this.parentNode;
  return t ? t.insertBefore(e, this.nextSibling) : e;
}
function Mme(e) {
  return this.select(e ? Ome : Cme);
}
function Nme(e) {
  return arguments.length ? this.property("__data__", e) : this.node().__data__;
}
function Rme(e) {
  return function(t) {
    e.call(this, t, this.__data__);
  };
}
function Ame(e) {
  return e.trim().split(/^|\s+/).map(function(t) {
    var n = "", r = t.indexOf(".");
    return r >= 0 && (n = t.slice(r + 1), t = t.slice(0, r)), { type: t, name: n };
  });
}
function jme(e) {
  return function() {
    var t = this.__on;
    if (t) {
      for (var n = 0, r = -1, a = t.length, s; n < a; ++n)
        s = t[n], (!e.type || s.type === e.type) && s.name === e.name ? this.removeEventListener(s.type, s.listener, s.options) : t[++r] = s;
      ++r ? t.length = r : delete this.__on;
    }
  };
}
function Pme(e, t, n) {
  return function() {
    var r = this.__on, a, s = Rme(t);
    if (r) {
      for (var l = 0, c = r.length; l < c; ++l)
        if ((a = r[l]).type === e.type && a.name === e.name) {
          this.removeEventListener(a.type, a.listener, a.options), this.addEventListener(a.type, a.listener = s, a.options = n), a.value = t;
          return;
        }
    }
    this.addEventListener(e.type, s, n), a = { type: e.type, name: e.name, value: t, listener: s, options: n }, r ? r.push(a) : this.__on = [a];
  };
}
function Dme(e, t, n) {
  var r = Ame(e + ""), a, s = r.length, l;
  if (arguments.length < 2) {
    var c = this.node().__on;
    if (c) {
      for (var d = 0, p = c.length, m; d < p; ++d)
        for (a = 0, m = c[d]; a < s; ++a)
          if ((l = r[a]).type === m.type && l.name === m.name)
            return m.value;
    }
    return;
  }
  for (c = t ? Pme : jme, a = 0; a < s; ++a) this.each(c(r[a], t, n));
  return this;
}
function OB(e, t, n) {
  var r = SB(e), a = r.CustomEvent;
  typeof a == "function" ? a = new a(t, n) : (a = r.document.createEvent("Event"), n ? (a.initEvent(t, n.bubbles, n.cancelable), a.detail = n.detail) : a.initEvent(t, !1, !1)), e.dispatchEvent(a);
}
function $me(e, t) {
  return function() {
    return OB(this, e, t);
  };
}
function Tme(e, t) {
  return function() {
    return OB(this, e, t.apply(this, arguments));
  };
}
function Lme(e, t) {
  return this.each((typeof t == "function" ? Tme : $me)(e, t));
}
function* Ime() {
  for (var e = this._groups, t = 0, n = e.length; t < n; ++t)
    for (var r = e[t], a = 0, s = r.length, l; a < s; ++a)
      (l = r[a]) && (yield l);
}
var MB = [null];
function wi(e, t) {
  this._groups = e, this._parents = t;
}
function hS() {
  return new wi([[document.documentElement]], MB);
}
function zme() {
  return this;
}
wi.prototype = hS.prototype = {
  constructor: wi,
  select: dpe,
  selectAll: hpe,
  selectChild: bpe,
  selectChildren: kpe,
  filter: _pe,
  data: Rpe,
  enter: Epe,
  exit: jpe,
  join: Ppe,
  merge: Dpe,
  selection: zme,
  order: $pe,
  sort: Tpe,
  call: Ipe,
  nodes: zpe,
  node: Fpe,
  size: Bpe,
  empty: Upe,
  each: Vpe,
  attr: Ype,
  style: eme,
  property: ome,
  classed: lme,
  text: fme,
  html: gme,
  raise: yme,
  lower: wme,
  append: xme,
  insert: kme,
  remove: Eme,
  clone: Mme,
  datum: Nme,
  on: Dme,
  dispatch: Lme,
  [Symbol.iterator]: Ime
};
function gi(e) {
  return typeof e == "string" ? new wi([[document.querySelector(e)]], [document.documentElement]) : new wi([[e]], MB);
}
function Fme(e) {
  let t;
  for (; t = e.sourceEvent; ) e = t;
  return e;
}
function As(e, t) {
  if (e = Fme(e), t === void 0 && (t = e.currentTarget), t) {
    var n = t.ownerSVGElement || t;
    if (n.createSVGPoint) {
      var r = n.createSVGPoint();
      return r.x = e.clientX, r.y = e.clientY, r = r.matrixTransform(t.getScreenCTM().inverse()), [r.x, r.y];
    }
    if (t.getBoundingClientRect) {
      var a = t.getBoundingClientRect();
      return [e.clientX - a.left - t.clientLeft, e.clientY - a.top - t.clientTop];
    }
  }
  return [e.pageX, e.pageY];
}
const Bme = { passive: !1 }, wx = { capture: !0, passive: !1 };
function PM(e) {
  e.stopImmediatePropagation();
}
function Eh(e) {
  e.preventDefault(), e.stopImmediatePropagation();
}
function NB(e) {
  var t = e.document.documentElement, n = gi(e).on("dragstart.drag", Eh, wx);
  "onselectstart" in t ? n.on("selectstart.drag", Eh, wx) : (t.__noselect = t.style.MozUserSelect, t.style.MozUserSelect = "none");
}
function RB(e, t) {
  var n = e.document.documentElement, r = gi(e).on("dragstart.drag", null);
  t && (r.on("click.drag", Eh, wx), setTimeout(function() {
    r.on("click.drag", null);
  }, 0)), "onselectstart" in n ? r.on("selectstart.drag", null) : (n.style.MozUserSelect = n.__noselect, delete n.__noselect);
}
const lk = (e) => () => e;
function D5(e, {
  sourceEvent: t,
  subject: n,
  target: r,
  identifier: a,
  active: s,
  x: l,
  y: c,
  dx: d,
  dy: p,
  dispatch: m
}) {
  Object.defineProperties(this, {
    type: { value: e, enumerable: !0, configurable: !0 },
    sourceEvent: { value: t, enumerable: !0, configurable: !0 },
    subject: { value: n, enumerable: !0, configurable: !0 },
    target: { value: r, enumerable: !0, configurable: !0 },
    identifier: { value: a, enumerable: !0, configurable: !0 },
    active: { value: s, enumerable: !0, configurable: !0 },
    x: { value: l, enumerable: !0, configurable: !0 },
    y: { value: c, enumerable: !0, configurable: !0 },
    dx: { value: d, enumerable: !0, configurable: !0 },
    dy: { value: p, enumerable: !0, configurable: !0 },
    _: { value: m }
  });
}
D5.prototype.on = function() {
  var e = this._.on.apply(this._, arguments);
  return e === this._ ? this : e;
};
function Ume(e) {
  return !e.ctrlKey && !e.button;
}
function Vme() {
  return this.parentNode;
}
function Hme(e, t) {
  return t ?? { x: e.x, y: e.y };
}
function qme() {
  return navigator.maxTouchPoints || "ontouchstart" in this;
}
function AB() {
  var e = Ume, t = Vme, n = Hme, r = qme, a = {}, s = z2("start", "drag", "end"), l = 0, c, d, p, m, h = 0;
  function v(O) {
    O.on("mousedown.drag", y).filter(r).on("touchstart.drag", b).on("touchmove.drag", k, Bme).on("touchend.drag touchcancel.drag", C).style("touch-action", "none").style("-webkit-tap-highlight-color", "rgba(0,0,0,0)");
  }
  function y(O, N) {
    if (!(m || !e.call(this, O, N))) {
      var R = _(this, t.call(this, O, N), O, N, "mouse");
      R && (gi(O.view).on("mousemove.drag", w, wx).on("mouseup.drag", x, wx), NB(O.view), PM(O), p = !1, c = O.clientX, d = O.clientY, R("start", O));
    }
  }
  function w(O) {
    if (Eh(O), !p) {
      var N = O.clientX - c, R = O.clientY - d;
      p = N * N + R * R > h;
    }
    a.mouse("drag", O);
  }
  function x(O) {
    gi(O.view).on("mousemove.drag mouseup.drag", null), RB(O.view, p), Eh(O), a.mouse("end", O);
  }
  function b(O, N) {
    if (e.call(this, O, N)) {
      var R = O.changedTouches, j = t.call(this, O, N), D = R.length, $, z;
      for ($ = 0; $ < D; ++$)
        (z = _(this, j, O, N, R[$].identifier, R[$])) && (PM(O), z("start", O, R[$]));
    }
  }
  function k(O) {
    var N = O.changedTouches, R = N.length, j, D;
    for (j = 0; j < R; ++j)
      (D = a[N[j].identifier]) && (Eh(O), D("drag", O, N[j]));
  }
  function C(O) {
    var N = O.changedTouches, R = N.length, j, D;
    for (m && clearTimeout(m), m = setTimeout(function() {
      m = null;
    }, 500), j = 0; j < R; ++j)
      (D = a[N[j].identifier]) && (PM(O), D("end", O, N[j]));
  }
  function _(O, N, R, j, D, $) {
    var z = s.copy(), B = As($ || R, N), P, W, I;
    if ((I = n.call(O, new D5("beforestart", {
      sourceEvent: R,
      target: v,
      identifier: D,
      active: l,
      x: B[0],
      y: B[1],
      dx: 0,
      dy: 0,
      dispatch: z
    }), j)) != null)
      return P = I.x - B[0] || 0, W = I.y - B[1] || 0, function G(L, K, q) {
        var Z = B, V;
        switch (L) {
          case "start":
            a[D] = G, V = l++;
            break;
          case "end":
            delete a[D], --l;
          // falls through
          case "drag":
            B = As(q || K, N), V = l;
            break;
        }
        z.call(
          L,
          O,
          new D5(L, {
            sourceEvent: K,
            subject: I,
            target: v,
            identifier: D,
            active: V,
            x: B[0] + P,
            y: B[1] + W,
            dx: B[0] - Z[0],
            dy: B[1] - Z[1],
            dispatch: z
          }),
          j
        );
      };
  }
  return v.filter = function(O) {
    return arguments.length ? (e = typeof O == "function" ? O : lk(!!O), v) : e;
  }, v.container = function(O) {
    return arguments.length ? (t = typeof O == "function" ? O : lk(O), v) : t;
  }, v.subject = function(O) {
    return arguments.length ? (n = typeof O == "function" ? O : lk(O), v) : n;
  }, v.touchable = function(O) {
    return arguments.length ? (r = typeof O == "function" ? O : lk(!!O), v) : r;
  }, v.on = function() {
    var O = s.on.apply(s, arguments);
    return O === s ? v : O;
  }, v.clickDistance = function(O) {
    return arguments.length ? (h = (O = +O) * O, v) : Math.sqrt(h);
  }, v;
}
function rA(e, t, n) {
  e.prototype = t.prototype = n, n.constructor = e;
}
function jB(e, t) {
  var n = Object.create(e.prototype);
  for (var r in t) n[r] = t[r];
  return n;
}
function gS() {
}
var xx = 0.7, h_ = 1 / xx, Ch = "\\s*([+-]?\\d+)\\s*", Sx = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)\\s*", Cl = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)%\\s*", Wme = /^#([0-9a-f]{3,8})$/, Gme = new RegExp(`^rgb\\(${Ch},${Ch},${Ch}\\)$`), Kme = new RegExp(`^rgb\\(${Cl},${Cl},${Cl}\\)$`), Xme = new RegExp(`^rgba\\(${Ch},${Ch},${Ch},${Sx}\\)$`), Yme = new RegExp(`^rgba\\(${Cl},${Cl},${Cl},${Sx}\\)$`), Qme = new RegExp(`^hsl\\(${Sx},${Cl},${Cl}\\)$`), Jme = new RegExp(`^hsla\\(${Sx},${Cl},${Cl},${Sx}\\)$`), D6 = {
  aliceblue: 15792383,
  antiquewhite: 16444375,
  aqua: 65535,
  aquamarine: 8388564,
  azure: 15794175,
  beige: 16119260,
  bisque: 16770244,
  black: 0,
  blanchedalmond: 16772045,
  blue: 255,
  blueviolet: 9055202,
  brown: 10824234,
  burlywood: 14596231,
  cadetblue: 6266528,
  chartreuse: 8388352,
  chocolate: 13789470,
  coral: 16744272,
  cornflowerblue: 6591981,
  cornsilk: 16775388,
  crimson: 14423100,
  cyan: 65535,
  darkblue: 139,
  darkcyan: 35723,
  darkgoldenrod: 12092939,
  darkgray: 11119017,
  darkgreen: 25600,
  darkgrey: 11119017,
  darkkhaki: 12433259,
  darkmagenta: 9109643,
  darkolivegreen: 5597999,
  darkorange: 16747520,
  darkorchid: 10040012,
  darkred: 9109504,
  darksalmon: 15308410,
  darkseagreen: 9419919,
  darkslateblue: 4734347,
  darkslategray: 3100495,
  darkslategrey: 3100495,
  darkturquoise: 52945,
  darkviolet: 9699539,
  deeppink: 16716947,
  deepskyblue: 49151,
  dimgray: 6908265,
  dimgrey: 6908265,
  dodgerblue: 2003199,
  firebrick: 11674146,
  floralwhite: 16775920,
  forestgreen: 2263842,
  fuchsia: 16711935,
  gainsboro: 14474460,
  ghostwhite: 16316671,
  gold: 16766720,
  goldenrod: 14329120,
  gray: 8421504,
  green: 32768,
  greenyellow: 11403055,
  grey: 8421504,
  honeydew: 15794160,
  hotpink: 16738740,
  indianred: 13458524,
  indigo: 4915330,
  ivory: 16777200,
  khaki: 15787660,
  lavender: 15132410,
  lavenderblush: 16773365,
  lawngreen: 8190976,
  lemonchiffon: 16775885,
  lightblue: 11393254,
  lightcoral: 15761536,
  lightcyan: 14745599,
  lightgoldenrodyellow: 16448210,
  lightgray: 13882323,
  lightgreen: 9498256,
  lightgrey: 13882323,
  lightpink: 16758465,
  lightsalmon: 16752762,
  lightseagreen: 2142890,
  lightskyblue: 8900346,
  lightslategray: 7833753,
  lightslategrey: 7833753,
  lightsteelblue: 11584734,
  lightyellow: 16777184,
  lime: 65280,
  limegreen: 3329330,
  linen: 16445670,
  magenta: 16711935,
  maroon: 8388608,
  mediumaquamarine: 6737322,
  mediumblue: 205,
  mediumorchid: 12211667,
  mediumpurple: 9662683,
  mediumseagreen: 3978097,
  mediumslateblue: 8087790,
  mediumspringgreen: 64154,
  mediumturquoise: 4772300,
  mediumvioletred: 13047173,
  midnightblue: 1644912,
  mintcream: 16121850,
  mistyrose: 16770273,
  moccasin: 16770229,
  navajowhite: 16768685,
  navy: 128,
  oldlace: 16643558,
  olive: 8421376,
  olivedrab: 7048739,
  orange: 16753920,
  orangered: 16729344,
  orchid: 14315734,
  palegoldenrod: 15657130,
  palegreen: 10025880,
  paleturquoise: 11529966,
  palevioletred: 14381203,
  papayawhip: 16773077,
  peachpuff: 16767673,
  peru: 13468991,
  pink: 16761035,
  plum: 14524637,
  powderblue: 11591910,
  purple: 8388736,
  rebeccapurple: 6697881,
  red: 16711680,
  rosybrown: 12357519,
  royalblue: 4286945,
  saddlebrown: 9127187,
  salmon: 16416882,
  sandybrown: 16032864,
  seagreen: 3050327,
  seashell: 16774638,
  sienna: 10506797,
  silver: 12632256,
  skyblue: 8900331,
  slateblue: 6970061,
  slategray: 7372944,
  slategrey: 7372944,
  snow: 16775930,
  springgreen: 65407,
  steelblue: 4620980,
  tan: 13808780,
  teal: 32896,
  thistle: 14204888,
  tomato: 16737095,
  turquoise: 4251856,
  violet: 15631086,
  wheat: 16113331,
  white: 16777215,
  whitesmoke: 16119285,
  yellow: 16776960,
  yellowgreen: 10145074
};
rA(gS, fm, {
  copy(e) {
    return Object.assign(new this.constructor(), this, e);
  },
  displayable() {
    return this.rgb().displayable();
  },
  hex: $6,
  // Deprecated! Use color.formatHex.
  formatHex: $6,
  formatHex8: Zme,
  formatHsl: ehe,
  formatRgb: T6,
  toString: T6
});
function $6() {
  return this.rgb().formatHex();
}
function Zme() {
  return this.rgb().formatHex8();
}
function ehe() {
  return PB(this).formatHsl();
}
function T6() {
  return this.rgb().formatRgb();
}
function fm(e) {
  var t, n;
  return e = (e + "").trim().toLowerCase(), (t = Wme.exec(e)) ? (n = t[1].length, t = parseInt(t[1], 16), n === 6 ? L6(t) : n === 3 ? new Ca(t >> 8 & 15 | t >> 4 & 240, t >> 4 & 15 | t & 240, (t & 15) << 4 | t & 15, 1) : n === 8 ? uk(t >> 24 & 255, t >> 16 & 255, t >> 8 & 255, (t & 255) / 255) : n === 4 ? uk(t >> 12 & 15 | t >> 8 & 240, t >> 8 & 15 | t >> 4 & 240, t >> 4 & 15 | t & 240, ((t & 15) << 4 | t & 15) / 255) : null) : (t = Gme.exec(e)) ? new Ca(t[1], t[2], t[3], 1) : (t = Kme.exec(e)) ? new Ca(t[1] * 255 / 100, t[2] * 255 / 100, t[3] * 255 / 100, 1) : (t = Xme.exec(e)) ? uk(t[1], t[2], t[3], t[4]) : (t = Yme.exec(e)) ? uk(t[1] * 255 / 100, t[2] * 255 / 100, t[3] * 255 / 100, t[4]) : (t = Qme.exec(e)) ? F6(t[1], t[2] / 100, t[3] / 100, 1) : (t = Jme.exec(e)) ? F6(t[1], t[2] / 100, t[3] / 100, t[4]) : D6.hasOwnProperty(e) ? L6(D6[e]) : e === "transparent" ? new Ca(NaN, NaN, NaN, 0) : null;
}
function L6(e) {
  return new Ca(e >> 16 & 255, e >> 8 & 255, e & 255, 1);
}
function uk(e, t, n, r) {
  return r <= 0 && (e = t = n = NaN), new Ca(e, t, n, r);
}
function the(e) {
  return e instanceof gS || (e = fm(e)), e ? (e = e.rgb(), new Ca(e.r, e.g, e.b, e.opacity)) : new Ca();
}
function $5(e, t, n, r) {
  return arguments.length === 1 ? the(e) : new Ca(e, t, n, r ?? 1);
}
function Ca(e, t, n, r) {
  this.r = +e, this.g = +t, this.b = +n, this.opacity = +r;
}
rA(Ca, $5, jB(gS, {
  brighter(e) {
    return e = e == null ? h_ : Math.pow(h_, e), new Ca(this.r * e, this.g * e, this.b * e, this.opacity);
  },
  darker(e) {
    return e = e == null ? xx : Math.pow(xx, e), new Ca(this.r * e, this.g * e, this.b * e, this.opacity);
  },
  rgb() {
    return this;
  },
  clamp() {
    return new Ca(om(this.r), om(this.g), om(this.b), g_(this.opacity));
  },
  displayable() {
    return -0.5 <= this.r && this.r < 255.5 && -0.5 <= this.g && this.g < 255.5 && -0.5 <= this.b && this.b < 255.5 && 0 <= this.opacity && this.opacity <= 1;
  },
  hex: I6,
  // Deprecated! Use color.formatHex.
  formatHex: I6,
  formatHex8: nhe,
  formatRgb: z6,
  toString: z6
}));
function I6() {
  return `#${nm(this.r)}${nm(this.g)}${nm(this.b)}`;
}
function nhe() {
  return `#${nm(this.r)}${nm(this.g)}${nm(this.b)}${nm((isNaN(this.opacity) ? 1 : this.opacity) * 255)}`;
}
function z6() {
  const e = g_(this.opacity);
  return `${e === 1 ? "rgb(" : "rgba("}${om(this.r)}, ${om(this.g)}, ${om(this.b)}${e === 1 ? ")" : `, ${e})`}`;
}
function g_(e) {
  return isNaN(e) ? 1 : Math.max(0, Math.min(1, e));
}
function om(e) {
  return Math.max(0, Math.min(255, Math.round(e) || 0));
}
function nm(e) {
  return e = om(e), (e < 16 ? "0" : "") + e.toString(16);
}
function F6(e, t, n, r) {
  return r <= 0 ? e = t = n = NaN : n <= 0 || n >= 1 ? e = t = NaN : t <= 0 && (e = NaN), new js(e, t, n, r);
}
function PB(e) {
  if (e instanceof js) return new js(e.h, e.s, e.l, e.opacity);
  if (e instanceof gS || (e = fm(e)), !e) return new js();
  if (e instanceof js) return e;
  e = e.rgb();
  var t = e.r / 255, n = e.g / 255, r = e.b / 255, a = Math.min(t, n, r), s = Math.max(t, n, r), l = NaN, c = s - a, d = (s + a) / 2;
  return c ? (t === s ? l = (n - r) / c + (n < r) * 6 : n === s ? l = (r - t) / c + 2 : l = (t - n) / c + 4, c /= d < 0.5 ? s + a : 2 - s - a, l *= 60) : c = d > 0 && d < 1 ? 0 : l, new js(l, c, d, e.opacity);
}
function rhe(e, t, n, r) {
  return arguments.length === 1 ? PB(e) : new js(e, t, n, r ?? 1);
}
function js(e, t, n, r) {
  this.h = +e, this.s = +t, this.l = +n, this.opacity = +r;
}
rA(js, rhe, jB(gS, {
  brighter(e) {
    return e = e == null ? h_ : Math.pow(h_, e), new js(this.h, this.s, this.l * e, this.opacity);
  },
  darker(e) {
    return e = e == null ? xx : Math.pow(xx, e), new js(this.h, this.s, this.l * e, this.opacity);
  },
  rgb() {
    var e = this.h % 360 + (this.h < 0) * 360, t = isNaN(e) || isNaN(this.s) ? 0 : this.s, n = this.l, r = n + (n < 0.5 ? n : 1 - n) * t, a = 2 * n - r;
    return new Ca(
      DM(e >= 240 ? e - 240 : e + 120, a, r),
      DM(e, a, r),
      DM(e < 120 ? e + 240 : e - 120, a, r),
      this.opacity
    );
  },
  clamp() {
    return new js(B6(this.h), ck(this.s), ck(this.l), g_(this.opacity));
  },
  displayable() {
    return (0 <= this.s && this.s <= 1 || isNaN(this.s)) && 0 <= this.l && this.l <= 1 && 0 <= this.opacity && this.opacity <= 1;
  },
  formatHsl() {
    const e = g_(this.opacity);
    return `${e === 1 ? "hsl(" : "hsla("}${B6(this.h)}, ${ck(this.s) * 100}%, ${ck(this.l) * 100}%${e === 1 ? ")" : `, ${e})`}`;
  }
}));
function B6(e) {
  return e = (e || 0) % 360, e < 0 ? e + 360 : e;
}
function ck(e) {
  return Math.max(0, Math.min(1, e || 0));
}
function DM(e, t, n) {
  return (e < 60 ? t + (n - t) * e / 60 : e < 180 ? n : e < 240 ? t + (n - t) * (240 - e) / 60 : t) * 255;
}
const oA = (e) => () => e;
function ohe(e, t) {
  return function(n) {
    return e + n * t;
  };
}
function ahe(e, t, n) {
  return e = Math.pow(e, n), t = Math.pow(t, n) - e, n = 1 / n, function(r) {
    return Math.pow(e + r * t, n);
  };
}
function ihe(e) {
  return (e = +e) == 1 ? DB : function(t, n) {
    return n - t ? ahe(t, n, e) : oA(isNaN(t) ? n : t);
  };
}
function DB(e, t) {
  var n = t - e;
  return n ? ohe(e, n) : oA(isNaN(e) ? t : e);
}
const v_ = (function e(t) {
  var n = ihe(t);
  function r(a, s) {
    var l = n((a = $5(a)).r, (s = $5(s)).r), c = n(a.g, s.g), d = n(a.b, s.b), p = DB(a.opacity, s.opacity);
    return function(m) {
      return a.r = l(m), a.g = c(m), a.b = d(m), a.opacity = p(m), a + "";
    };
  }
  return r.gamma = e, r;
})(1);
function she(e, t) {
  t || (t = []);
  var n = e ? Math.min(t.length, e.length) : 0, r = t.slice(), a;
  return function(s) {
    for (a = 0; a < n; ++a) r[a] = e[a] * (1 - s) + t[a] * s;
    return r;
  };
}
function lhe(e) {
  return ArrayBuffer.isView(e) && !(e instanceof DataView);
}
function uhe(e, t) {
  var n = t ? t.length : 0, r = e ? Math.min(n, e.length) : 0, a = new Array(r), s = new Array(n), l;
  for (l = 0; l < r; ++l) a[l] = Xw(e[l], t[l]);
  for (; l < n; ++l) s[l] = t[l];
  return function(c) {
    for (l = 0; l < r; ++l) s[l] = a[l](c);
    return s;
  };
}
function che(e, t) {
  var n = /* @__PURE__ */ new Date();
  return e = +e, t = +t, function(r) {
    return n.setTime(e * (1 - r) + t * r), n;
  };
}
function ll(e, t) {
  return e = +e, t = +t, function(n) {
    return e * (1 - n) + t * n;
  };
}
function dhe(e, t) {
  var n = {}, r = {}, a;
  (e === null || typeof e != "object") && (e = {}), (t === null || typeof t != "object") && (t = {});
  for (a in t)
    a in e ? n[a] = Xw(e[a], t[a]) : r[a] = t[a];
  return function(s) {
    for (a in n) r[a] = n[a](s);
    return r;
  };
}
var T5 = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g, $M = new RegExp(T5.source, "g");
function fhe(e) {
  return function() {
    return e;
  };
}
function phe(e) {
  return function(t) {
    return e(t) + "";
  };
}
function $B(e, t) {
  var n = T5.lastIndex = $M.lastIndex = 0, r, a, s, l = -1, c = [], d = [];
  for (e = e + "", t = t + ""; (r = T5.exec(e)) && (a = $M.exec(t)); )
    (s = a.index) > n && (s = t.slice(n, s), c[l] ? c[l] += s : c[++l] = s), (r = r[0]) === (a = a[0]) ? c[l] ? c[l] += a : c[++l] = a : (c[++l] = null, d.push({ i: l, x: ll(r, a) })), n = $M.lastIndex;
  return n < t.length && (s = t.slice(n), c[l] ? c[l] += s : c[++l] = s), c.length < 2 ? d[0] ? phe(d[0].x) : fhe(t) : (t = d.length, function(p) {
    for (var m = 0, h; m < t; ++m) c[(h = d[m]).i] = h.x(p);
    return c.join("");
  });
}
function Xw(e, t) {
  var n = typeof t, r;
  return t == null || n === "boolean" ? oA(t) : (n === "number" ? ll : n === "string" ? (r = fm(t)) ? (t = r, v_) : $B : t instanceof fm ? v_ : t instanceof Date ? che : lhe(t) ? she : Array.isArray(t) ? uhe : typeof t.valueOf != "function" && typeof t.toString != "function" || isNaN(t) ? dhe : ll)(e, t);
}
var U6 = 180 / Math.PI, TB = {
  translateX: 0,
  translateY: 0,
  rotate: 0,
  skewX: 0,
  scaleX: 1,
  scaleY: 1
};
function LB(e, t, n, r, a, s) {
  var l, c, d;
  return (l = Math.sqrt(e * e + t * t)) && (e /= l, t /= l), (d = e * n + t * r) && (n -= e * d, r -= t * d), (c = Math.sqrt(n * n + r * r)) && (n /= c, r /= c, d /= c), e * r < t * n && (e = -e, t = -t, d = -d, l = -l), {
    translateX: a,
    translateY: s,
    rotate: Math.atan2(t, e) * U6,
    skewX: Math.atan(d) * U6,
    scaleX: l,
    scaleY: c
  };
}
var dk;
function mhe(e) {
  const t = new (typeof DOMMatrix == "function" ? DOMMatrix : WebKitCSSMatrix)(e + "");
  return t.isIdentity ? TB : LB(t.a, t.b, t.c, t.d, t.e, t.f);
}
function hhe(e) {
  return e == null || (dk || (dk = document.createElementNS("http://www.w3.org/2000/svg", "g")), dk.setAttribute("transform", e), !(e = dk.transform.baseVal.consolidate())) ? TB : (e = e.matrix, LB(e.a, e.b, e.c, e.d, e.e, e.f));
}
function IB(e, t, n, r) {
  function a(p) {
    return p.length ? p.pop() + " " : "";
  }
  function s(p, m, h, v, y, w) {
    if (p !== h || m !== v) {
      var x = y.push("translate(", null, t, null, n);
      w.push({ i: x - 4, x: ll(p, h) }, { i: x - 2, x: ll(m, v) });
    } else (h || v) && y.push("translate(" + h + t + v + n);
  }
  function l(p, m, h, v) {
    p !== m ? (p - m > 180 ? m += 360 : m - p > 180 && (p += 360), v.push({ i: h.push(a(h) + "rotate(", null, r) - 2, x: ll(p, m) })) : m && h.push(a(h) + "rotate(" + m + r);
  }
  function c(p, m, h, v) {
    p !== m ? v.push({ i: h.push(a(h) + "skewX(", null, r) - 2, x: ll(p, m) }) : m && h.push(a(h) + "skewX(" + m + r);
  }
  function d(p, m, h, v, y, w) {
    if (p !== h || m !== v) {
      var x = y.push(a(y) + "scale(", null, ",", null, ")");
      w.push({ i: x - 4, x: ll(p, h) }, { i: x - 2, x: ll(m, v) });
    } else (h !== 1 || v !== 1) && y.push(a(y) + "scale(" + h + "," + v + ")");
  }
  return function(p, m) {
    var h = [], v = [];
    return p = e(p), m = e(m), s(p.translateX, p.translateY, m.translateX, m.translateY, h, v), l(p.rotate, m.rotate, h, v), c(p.skewX, m.skewX, h, v), d(p.scaleX, p.scaleY, m.scaleX, m.scaleY, h, v), p = m = null, function(y) {
      for (var w = -1, x = v.length, b; ++w < x; ) h[(b = v[w]).i] = b.x(y);
      return h.join("");
    };
  };
}
var ghe = IB(mhe, "px, ", "px)", "deg)"), vhe = IB(hhe, ", ", ")", ")"), yhe = 1e-12;
function V6(e) {
  return ((e = Math.exp(e)) + 1 / e) / 2;
}
function bhe(e) {
  return ((e = Math.exp(e)) - 1 / e) / 2;
}
function whe(e) {
  return ((e = Math.exp(2 * e)) - 1) / (e + 1);
}
const j0 = (function e(t, n, r) {
  function a(s, l) {
    var c = s[0], d = s[1], p = s[2], m = l[0], h = l[1], v = l[2], y = m - c, w = h - d, x = y * y + w * w, b, k;
    if (x < yhe)
      k = Math.log(v / p) / t, b = function(j) {
        return [
          c + j * y,
          d + j * w,
          p * Math.exp(t * j * k)
        ];
      };
    else {
      var C = Math.sqrt(x), _ = (v * v - p * p + r * x) / (2 * p * n * C), O = (v * v - p * p - r * x) / (2 * v * n * C), N = Math.log(Math.sqrt(_ * _ + 1) - _), R = Math.log(Math.sqrt(O * O + 1) - O);
      k = (R - N) / t, b = function(j) {
        var D = j * k, $ = V6(N), z = p / (n * C) * ($ * whe(t * D + N) - bhe(N));
        return [
          c + z * y,
          d + z * w,
          p * $ / V6(t * D + N)
        ];
      };
    }
    return b.duration = k * 1e3 * t / Math.SQRT2, b;
  }
  return a.rho = function(s) {
    var l = Math.max(1e-3, +s), c = l * l, d = c * c;
    return e(l, c, d);
  }, a;
})(Math.SQRT2, 2, 4);
var Ih = 0, $w = 0, dw = 0, zB = 1e3, y_, Tw, b_ = 0, pm = 0, B2 = 0, kx = typeof performance == "object" && performance.now ? performance : Date, FB = typeof window == "object" && window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : function(e) {
  setTimeout(e, 17);
};
function aA() {
  return pm || (FB(xhe), pm = kx.now() + B2);
}
function xhe() {
  pm = 0;
}
function w_() {
  this._call = this._time = this._next = null;
}
w_.prototype = BB.prototype = {
  constructor: w_,
  restart: function(e, t, n) {
    if (typeof e != "function") throw new TypeError("callback is not a function");
    n = (n == null ? aA() : +n) + (t == null ? 0 : +t), !this._next && Tw !== this && (Tw ? Tw._next = this : y_ = this, Tw = this), this._call = e, this._time = n, L5();
  },
  stop: function() {
    this._call && (this._call = null, this._time = 1 / 0, L5());
  }
};
function BB(e, t, n) {
  var r = new w_();
  return r.restart(e, t, n), r;
}
function She() {
  aA(), ++Ih;
  for (var e = y_, t; e; )
    (t = pm - e._time) >= 0 && e._call.call(void 0, t), e = e._next;
  --Ih;
}
function H6() {
  pm = (b_ = kx.now()) + B2, Ih = $w = 0;
  try {
    She();
  } finally {
    Ih = 0, _he(), pm = 0;
  }
}
function khe() {
  var e = kx.now(), t = e - b_;
  t > zB && (B2 -= t, b_ = e);
}
function _he() {
  for (var e, t = y_, n, r = 1 / 0; t; )
    t._call ? (r > t._time && (r = t._time), e = t, t = t._next) : (n = t._next, t._next = null, t = e ? e._next = n : y_ = n);
  Tw = e, L5(r);
}
function L5(e) {
  if (!Ih) {
    $w && ($w = clearTimeout($w));
    var t = e - pm;
    t > 24 ? (e < 1 / 0 && ($w = setTimeout(H6, e - kx.now() - B2)), dw && (dw = clearInterval(dw))) : (dw || (b_ = kx.now(), dw = setInterval(khe, zB)), Ih = 1, FB(H6));
  }
}
function q6(e, t, n) {
  var r = new w_();
  return t = t == null ? 0 : +t, r.restart((a) => {
    r.stop(), e(a + t);
  }, t, n), r;
}
var Ehe = z2("start", "end", "cancel", "interrupt"), Che = [], UB = 0, W6 = 1, I5 = 2, P0 = 3, G6 = 4, z5 = 5, D0 = 6;
function U2(e, t, n, r, a, s) {
  var l = e.__transition;
  if (!l) e.__transition = {};
  else if (n in l) return;
  Ohe(e, n, {
    name: t,
    index: r,
    // For context during callback.
    group: a,
    // For context during callback.
    on: Ehe,
    tween: Che,
    time: s.time,
    delay: s.delay,
    duration: s.duration,
    ease: s.ease,
    timer: null,
    state: UB
  });
}
function iA(e, t) {
  var n = Gs(e, t);
  if (n.state > UB) throw new Error("too late; already scheduled");
  return n;
}
function $l(e, t) {
  var n = Gs(e, t);
  if (n.state > P0) throw new Error("too late; already running");
  return n;
}
function Gs(e, t) {
  var n = e.__transition;
  if (!n || !(n = n[t])) throw new Error("transition not found");
  return n;
}
function Ohe(e, t, n) {
  var r = e.__transition, a;
  r[t] = n, n.timer = BB(s, 0, n.time);
  function s(p) {
    n.state = W6, n.timer.restart(l, n.delay, n.time), n.delay <= p && l(p - n.delay);
  }
  function l(p) {
    var m, h, v, y;
    if (n.state !== W6) return d();
    for (m in r)
      if (y = r[m], y.name === n.name) {
        if (y.state === P0) return q6(l);
        y.state === G6 ? (y.state = D0, y.timer.stop(), y.on.call("interrupt", e, e.__data__, y.index, y.group), delete r[m]) : +m < t && (y.state = D0, y.timer.stop(), y.on.call("cancel", e, e.__data__, y.index, y.group), delete r[m]);
      }
    if (q6(function() {
      n.state === P0 && (n.state = G6, n.timer.restart(c, n.delay, n.time), c(p));
    }), n.state = I5, n.on.call("start", e, e.__data__, n.index, n.group), n.state === I5) {
      for (n.state = P0, a = new Array(v = n.tween.length), m = 0, h = -1; m < v; ++m)
        (y = n.tween[m].value.call(e, e.__data__, n.index, n.group)) && (a[++h] = y);
      a.length = h + 1;
    }
  }
  function c(p) {
    for (var m = p < n.duration ? n.ease.call(null, p / n.duration) : (n.timer.restart(d), n.state = z5, 1), h = -1, v = a.length; ++h < v; )
      a[h].call(e, m);
    n.state === z5 && (n.on.call("end", e, e.__data__, n.index, n.group), d());
  }
  function d() {
    n.state = D0, n.timer.stop(), delete r[t];
    for (var p in r) return;
    delete e.__transition;
  }
}
function $0(e, t) {
  var n = e.__transition, r, a, s = !0, l;
  if (n) {
    t = t == null ? null : t + "";
    for (l in n) {
      if ((r = n[l]).name !== t) {
        s = !1;
        continue;
      }
      a = r.state > I5 && r.state < z5, r.state = D0, r.timer.stop(), r.on.call(a ? "interrupt" : "cancel", e, e.__data__, r.index, r.group), delete n[l];
    }
    s && delete e.__transition;
  }
}
function Mhe(e) {
  return this.each(function() {
    $0(this, e);
  });
}
function Nhe(e, t) {
  var n, r;
  return function() {
    var a = $l(this, e), s = a.tween;
    if (s !== n) {
      r = n = s;
      for (var l = 0, c = r.length; l < c; ++l)
        if (r[l].name === t) {
          r = r.slice(), r.splice(l, 1);
          break;
        }
    }
    a.tween = r;
  };
}
function Rhe(e, t, n) {
  var r, a;
  if (typeof n != "function") throw new Error();
  return function() {
    var s = $l(this, e), l = s.tween;
    if (l !== r) {
      a = (r = l).slice();
      for (var c = { name: t, value: n }, d = 0, p = a.length; d < p; ++d)
        if (a[d].name === t) {
          a[d] = c;
          break;
        }
      d === p && a.push(c);
    }
    s.tween = a;
  };
}
function Ahe(e, t) {
  var n = this._id;
  if (e += "", arguments.length < 2) {
    for (var r = Gs(this.node(), n).tween, a = 0, s = r.length, l; a < s; ++a)
      if ((l = r[a]).name === e)
        return l.value;
    return null;
  }
  return this.each((t == null ? Nhe : Rhe)(n, e, t));
}
function sA(e, t, n) {
  var r = e._id;
  return e.each(function() {
    var a = $l(this, r);
    (a.value || (a.value = {}))[t] = n.apply(this, arguments);
  }), function(a) {
    return Gs(a, r).value[t];
  };
}
function VB(e, t) {
  var n;
  return (typeof t == "number" ? ll : t instanceof fm ? v_ : (n = fm(t)) ? (t = n, v_) : $B)(e, t);
}
function jhe(e) {
  return function() {
    this.removeAttribute(e);
  };
}
function Phe(e) {
  return function() {
    this.removeAttributeNS(e.space, e.local);
  };
}
function Dhe(e, t, n) {
  var r, a = n + "", s;
  return function() {
    var l = this.getAttribute(e);
    return l === a ? null : l === r ? s : s = t(r = l, n);
  };
}
function $he(e, t, n) {
  var r, a = n + "", s;
  return function() {
    var l = this.getAttributeNS(e.space, e.local);
    return l === a ? null : l === r ? s : s = t(r = l, n);
  };
}
function The(e, t, n) {
  var r, a, s;
  return function() {
    var l, c = n(this), d;
    return c == null ? void this.removeAttribute(e) : (l = this.getAttribute(e), d = c + "", l === d ? null : l === r && d === a ? s : (a = d, s = t(r = l, c)));
  };
}
function Lhe(e, t, n) {
  var r, a, s;
  return function() {
    var l, c = n(this), d;
    return c == null ? void this.removeAttributeNS(e.space, e.local) : (l = this.getAttributeNS(e.space, e.local), d = c + "", l === d ? null : l === r && d === a ? s : (a = d, s = t(r = l, c)));
  };
}
function Ihe(e, t) {
  var n = F2(e), r = n === "transform" ? vhe : VB;
  return this.attrTween(e, typeof t == "function" ? (n.local ? Lhe : The)(n, r, sA(this, "attr." + e, t)) : t == null ? (n.local ? Phe : jhe)(n) : (n.local ? $he : Dhe)(n, r, t));
}
function zhe(e, t) {
  return function(n) {
    this.setAttribute(e, t.call(this, n));
  };
}
function Fhe(e, t) {
  return function(n) {
    this.setAttributeNS(e.space, e.local, t.call(this, n));
  };
}
function Bhe(e, t) {
  var n, r;
  function a() {
    var s = t.apply(this, arguments);
    return s !== r && (n = (r = s) && Fhe(e, s)), n;
  }
  return a._value = t, a;
}
function Uhe(e, t) {
  var n, r;
  function a() {
    var s = t.apply(this, arguments);
    return s !== r && (n = (r = s) && zhe(e, s)), n;
  }
  return a._value = t, a;
}
function Vhe(e, t) {
  var n = "attr." + e;
  if (arguments.length < 2) return (n = this.tween(n)) && n._value;
  if (t == null) return this.tween(n, null);
  if (typeof t != "function") throw new Error();
  var r = F2(e);
  return this.tween(n, (r.local ? Bhe : Uhe)(r, t));
}
function Hhe(e, t) {
  return function() {
    iA(this, e).delay = +t.apply(this, arguments);
  };
}
function qhe(e, t) {
  return t = +t, function() {
    iA(this, e).delay = t;
  };
}
function Whe(e) {
  var t = this._id;
  return arguments.length ? this.each((typeof e == "function" ? Hhe : qhe)(t, e)) : Gs(this.node(), t).delay;
}
function Ghe(e, t) {
  return function() {
    $l(this, e).duration = +t.apply(this, arguments);
  };
}
function Khe(e, t) {
  return t = +t, function() {
    $l(this, e).duration = t;
  };
}
function Xhe(e) {
  var t = this._id;
  return arguments.length ? this.each((typeof e == "function" ? Ghe : Khe)(t, e)) : Gs(this.node(), t).duration;
}
function Yhe(e, t) {
  if (typeof t != "function") throw new Error();
  return function() {
    $l(this, e).ease = t;
  };
}
function Qhe(e) {
  var t = this._id;
  return arguments.length ? this.each(Yhe(t, e)) : Gs(this.node(), t).ease;
}
function Jhe(e, t) {
  return function() {
    var n = t.apply(this, arguments);
    if (typeof n != "function") throw new Error();
    $l(this, e).ease = n;
  };
}
function Zhe(e) {
  if (typeof e != "function") throw new Error();
  return this.each(Jhe(this._id, e));
}
function ege(e) {
  typeof e != "function" && (e = bB(e));
  for (var t = this._groups, n = t.length, r = new Array(n), a = 0; a < n; ++a)
    for (var s = t[a], l = s.length, c = r[a] = [], d, p = 0; p < l; ++p)
      (d = s[p]) && e.call(d, d.__data__, p, s) && c.push(d);
  return new _c(r, this._parents, this._name, this._id);
}
function tge(e) {
  if (e._id !== this._id) throw new Error();
  for (var t = this._groups, n = e._groups, r = t.length, a = n.length, s = Math.min(r, a), l = new Array(r), c = 0; c < s; ++c)
    for (var d = t[c], p = n[c], m = d.length, h = l[c] = new Array(m), v, y = 0; y < m; ++y)
      (v = d[y] || p[y]) && (h[y] = v);
  for (; c < r; ++c)
    l[c] = t[c];
  return new _c(l, this._parents, this._name, this._id);
}
function nge(e) {
  return (e + "").trim().split(/^|\s+/).every(function(t) {
    var n = t.indexOf(".");
    return n >= 0 && (t = t.slice(0, n)), !t || t === "start";
  });
}
function rge(e, t, n) {
  var r, a, s = nge(t) ? iA : $l;
  return function() {
    var l = s(this, e), c = l.on;
    c !== r && (a = (r = c).copy()).on(t, n), l.on = a;
  };
}
function oge(e, t) {
  var n = this._id;
  return arguments.length < 2 ? Gs(this.node(), n).on.on(e) : this.each(rge(n, e, t));
}
function age(e) {
  return function() {
    var t = this.parentNode;
    for (var n in this.__transition) if (+n !== e) return;
    t && t.removeChild(this);
  };
}
function ige() {
  return this.on("end.remove", age(this._id));
}
function sge(e) {
  var t = this._name, n = this._id;
  typeof e != "function" && (e = tA(e));
  for (var r = this._groups, a = r.length, s = new Array(a), l = 0; l < a; ++l)
    for (var c = r[l], d = c.length, p = s[l] = new Array(d), m, h, v = 0; v < d; ++v)
      (m = c[v]) && (h = e.call(m, m.__data__, v, c)) && ("__data__" in m && (h.__data__ = m.__data__), p[v] = h, U2(p[v], t, n, v, p, Gs(m, n)));
  return new _c(s, this._parents, t, n);
}
function lge(e) {
  var t = this._name, n = this._id;
  typeof e != "function" && (e = yB(e));
  for (var r = this._groups, a = r.length, s = [], l = [], c = 0; c < a; ++c)
    for (var d = r[c], p = d.length, m, h = 0; h < p; ++h)
      if (m = d[h]) {
        for (var v = e.call(m, m.__data__, h, d), y, w = Gs(m, n), x = 0, b = v.length; x < b; ++x)
          (y = v[x]) && U2(y, t, n, x, v, w);
        s.push(v), l.push(m);
      }
  return new _c(s, l, t, n);
}
var uge = hS.prototype.constructor;
function cge() {
  return new uge(this._groups, this._parents);
}
function dge(e, t) {
  var n, r, a;
  return function() {
    var s = Lh(this, e), l = (this.style.removeProperty(e), Lh(this, e));
    return s === l ? null : s === n && l === r ? a : a = t(n = s, r = l);
  };
}
function HB(e) {
  return function() {
    this.style.removeProperty(e);
  };
}
function fge(e, t, n) {
  var r, a = n + "", s;
  return function() {
    var l = Lh(this, e);
    return l === a ? null : l === r ? s : s = t(r = l, n);
  };
}
function pge(e, t, n) {
  var r, a, s;
  return function() {
    var l = Lh(this, e), c = n(this), d = c + "";
    return c == null && (d = c = (this.style.removeProperty(e), Lh(this, e))), l === d ? null : l === r && d === a ? s : (a = d, s = t(r = l, c));
  };
}
function mge(e, t) {
  var n, r, a, s = "style." + t, l = "end." + s, c;
  return function() {
    var d = $l(this, e), p = d.on, m = d.value[s] == null ? c || (c = HB(t)) : void 0;
    (p !== n || a !== m) && (r = (n = p).copy()).on(l, a = m), d.on = r;
  };
}
function hge(e, t, n) {
  var r = (e += "") == "transform" ? ghe : VB;
  return t == null ? this.styleTween(e, dge(e, r)).on("end.style." + e, HB(e)) : typeof t == "function" ? this.styleTween(e, pge(e, r, sA(this, "style." + e, t))).each(mge(this._id, e)) : this.styleTween(e, fge(e, r, t), n).on("end.style." + e, null);
}
function gge(e, t, n) {
  return function(r) {
    this.style.setProperty(e, t.call(this, r), n);
  };
}
function vge(e, t, n) {
  var r, a;
  function s() {
    var l = t.apply(this, arguments);
    return l !== a && (r = (a = l) && gge(e, l, n)), r;
  }
  return s._value = t, s;
}
function yge(e, t, n) {
  var r = "style." + (e += "");
  if (arguments.length < 2) return (r = this.tween(r)) && r._value;
  if (t == null) return this.tween(r, null);
  if (typeof t != "function") throw new Error();
  return this.tween(r, vge(e, t, n ?? ""));
}
function bge(e) {
  return function() {
    this.textContent = e;
  };
}
function wge(e) {
  return function() {
    var t = e(this);
    this.textContent = t ?? "";
  };
}
function xge(e) {
  return this.tween("text", typeof e == "function" ? wge(sA(this, "text", e)) : bge(e == null ? "" : e + ""));
}
function Sge(e) {
  return function(t) {
    this.textContent = e.call(this, t);
  };
}
function kge(e) {
  var t, n;
  function r() {
    var a = e.apply(this, arguments);
    return a !== n && (t = (n = a) && Sge(a)), t;
  }
  return r._value = e, r;
}
function _ge(e) {
  var t = "text";
  if (arguments.length < 1) return (t = this.tween(t)) && t._value;
  if (e == null) return this.tween(t, null);
  if (typeof e != "function") throw new Error();
  return this.tween(t, kge(e));
}
function Ege() {
  for (var e = this._name, t = this._id, n = qB(), r = this._groups, a = r.length, s = 0; s < a; ++s)
    for (var l = r[s], c = l.length, d, p = 0; p < c; ++p)
      if (d = l[p]) {
        var m = Gs(d, t);
        U2(d, e, n, p, l, {
          time: m.time + m.delay + m.duration,
          delay: 0,
          duration: m.duration,
          ease: m.ease
        });
      }
  return new _c(r, this._parents, e, n);
}
function Cge() {
  var e, t, n = this, r = n._id, a = n.size();
  return new Promise(function(s, l) {
    var c = { value: l }, d = { value: function() {
      --a === 0 && s();
    } };
    n.each(function() {
      var p = $l(this, r), m = p.on;
      m !== e && (t = (e = m).copy(), t._.cancel.push(c), t._.interrupt.push(c), t._.end.push(d)), p.on = t;
    }), a === 0 && s();
  });
}
var Oge = 0;
function _c(e, t, n, r) {
  this._groups = e, this._parents = t, this._name = n, this._id = r;
}
function qB() {
  return ++Oge;
}
var rc = hS.prototype;
_c.prototype = {
  constructor: _c,
  select: sge,
  selectAll: lge,
  selectChild: rc.selectChild,
  selectChildren: rc.selectChildren,
  filter: ege,
  merge: tge,
  selection: cge,
  transition: Ege,
  call: rc.call,
  nodes: rc.nodes,
  node: rc.node,
  size: rc.size,
  empty: rc.empty,
  each: rc.each,
  on: oge,
  attr: Ihe,
  attrTween: Vhe,
  style: hge,
  styleTween: yge,
  text: xge,
  textTween: _ge,
  remove: ige,
  tween: Ahe,
  delay: Whe,
  duration: Xhe,
  ease: Qhe,
  easeVarying: Zhe,
  end: Cge,
  [Symbol.iterator]: rc[Symbol.iterator]
};
function Mge(e) {
  return ((e *= 2) <= 1 ? e * e * e : (e -= 2) * e * e + 2) / 2;
}
var Nge = {
  time: null,
  // Set on use.
  delay: 0,
  duration: 250,
  ease: Mge
};
function Rge(e, t) {
  for (var n; !(n = e.__transition) || !(n = n[t]); )
    if (!(e = e.parentNode))
      throw new Error(`transition ${t} not found`);
  return n;
}
function Age(e) {
  var t, n;
  e instanceof _c ? (t = e._id, e = e._name) : (t = qB(), (n = Nge).time = aA(), e = e == null ? null : e + "");
  for (var r = this._groups, a = r.length, s = 0; s < a; ++s)
    for (var l = r[s], c = l.length, d, p = 0; p < c; ++p)
      (d = l[p]) && U2(d, e, t, p, l, n || Rge(d, t));
  return new _c(r, this._parents, e, t);
}
hS.prototype.interrupt = Mhe;
hS.prototype.transition = Age;
const fk = (e) => () => e;
function jge(e, {
  sourceEvent: t,
  target: n,
  transform: r,
  dispatch: a
}) {
  Object.defineProperties(this, {
    type: { value: e, enumerable: !0, configurable: !0 },
    sourceEvent: { value: t, enumerable: !0, configurable: !0 },
    target: { value: n, enumerable: !0, configurable: !0 },
    transform: { value: r, enumerable: !0, configurable: !0 },
    _: { value: a }
  });
}
function dc(e, t, n) {
  this.k = e, this.x = t, this.y = n;
}
dc.prototype = {
  constructor: dc,
  scale: function(e) {
    return e === 1 ? this : new dc(this.k * e, this.x, this.y);
  },
  translate: function(e, t) {
    return e === 0 & t === 0 ? this : new dc(this.k, this.x + this.k * e, this.y + this.k * t);
  },
  apply: function(e) {
    return [e[0] * this.k + this.x, e[1] * this.k + this.y];
  },
  applyX: function(e) {
    return e * this.k + this.x;
  },
  applyY: function(e) {
    return e * this.k + this.y;
  },
  invert: function(e) {
    return [(e[0] - this.x) / this.k, (e[1] - this.y) / this.k];
  },
  invertX: function(e) {
    return (e - this.x) / this.k;
  },
  invertY: function(e) {
    return (e - this.y) / this.k;
  },
  rescaleX: function(e) {
    return e.copy().domain(e.range().map(this.invertX, this).map(e.invert, e));
  },
  rescaleY: function(e) {
    return e.copy().domain(e.range().map(this.invertY, this).map(e.invert, e));
  },
  toString: function() {
    return "translate(" + this.x + "," + this.y + ") scale(" + this.k + ")";
  }
};
var V2 = new dc(1, 0, 0);
WB.prototype = dc.prototype;
function WB(e) {
  for (; !e.__zoom; ) if (!(e = e.parentNode)) return V2;
  return e.__zoom;
}
function TM(e) {
  e.stopImmediatePropagation();
}
function fw(e) {
  e.preventDefault(), e.stopImmediatePropagation();
}
function Pge(e) {
  return (!e.ctrlKey || e.type === "wheel") && !e.button;
}
function Dge() {
  var e = this;
  return e instanceof SVGElement ? (e = e.ownerSVGElement || e, e.hasAttribute("viewBox") ? (e = e.viewBox.baseVal, [[e.x, e.y], [e.x + e.width, e.y + e.height]]) : [[0, 0], [e.width.baseVal.value, e.height.baseVal.value]]) : [[0, 0], [e.clientWidth, e.clientHeight]];
}
function K6() {
  return this.__zoom || V2;
}
function $ge(e) {
  return -e.deltaY * (e.deltaMode === 1 ? 0.05 : e.deltaMode ? 1 : 2e-3) * (e.ctrlKey ? 10 : 1);
}
function Tge() {
  return navigator.maxTouchPoints || "ontouchstart" in this;
}
function Lge(e, t, n) {
  var r = e.invertX(t[0][0]) - n[0][0], a = e.invertX(t[1][0]) - n[1][0], s = e.invertY(t[0][1]) - n[0][1], l = e.invertY(t[1][1]) - n[1][1];
  return e.translate(
    a > r ? (r + a) / 2 : Math.min(0, r) || Math.max(0, a),
    l > s ? (s + l) / 2 : Math.min(0, s) || Math.max(0, l)
  );
}
function GB() {
  var e = Pge, t = Dge, n = Lge, r = $ge, a = Tge, s = [0, 1 / 0], l = [[-1 / 0, -1 / 0], [1 / 0, 1 / 0]], c = 250, d = j0, p = z2("start", "zoom", "end"), m, h, v, y = 500, w = 150, x = 0, b = 10;
  function k(I) {
    I.property("__zoom", K6).on("wheel.zoom", D, { passive: !1 }).on("mousedown.zoom", $).on("dblclick.zoom", z).filter(a).on("touchstart.zoom", B).on("touchmove.zoom", P).on("touchend.zoom touchcancel.zoom", W).style("-webkit-tap-highlight-color", "rgba(0,0,0,0)");
  }
  k.transform = function(I, G, L, K) {
    var q = I.selection ? I.selection() : I;
    q.property("__zoom", K6), I !== q ? N(I, G, L, K) : q.interrupt().each(function() {
      R(this, arguments).event(K).start().zoom(null, typeof G == "function" ? G.apply(this, arguments) : G).end();
    });
  }, k.scaleBy = function(I, G, L, K) {
    k.scaleTo(I, function() {
      var q = this.__zoom.k, Z = typeof G == "function" ? G.apply(this, arguments) : G;
      return q * Z;
    }, L, K);
  }, k.scaleTo = function(I, G, L, K) {
    k.transform(I, function() {
      var q = t.apply(this, arguments), Z = this.__zoom, V = L == null ? O(q) : typeof L == "function" ? L.apply(this, arguments) : L, F = Z.invert(V), X = typeof G == "function" ? G.apply(this, arguments) : G;
      return n(_(C(Z, X), V, F), q, l);
    }, L, K);
  }, k.translateBy = function(I, G, L, K) {
    k.transform(I, function() {
      return n(this.__zoom.translate(
        typeof G == "function" ? G.apply(this, arguments) : G,
        typeof L == "function" ? L.apply(this, arguments) : L
      ), t.apply(this, arguments), l);
    }, null, K);
  }, k.translateTo = function(I, G, L, K, q) {
    k.transform(I, function() {
      var Z = t.apply(this, arguments), V = this.__zoom, F = K == null ? O(Z) : typeof K == "function" ? K.apply(this, arguments) : K;
      return n(V2.translate(F[0], F[1]).scale(V.k).translate(
        typeof G == "function" ? -G.apply(this, arguments) : -G,
        typeof L == "function" ? -L.apply(this, arguments) : -L
      ), Z, l);
    }, K, q);
  };
  function C(I, G) {
    return G = Math.max(s[0], Math.min(s[1], G)), G === I.k ? I : new dc(G, I.x, I.y);
  }
  function _(I, G, L) {
    var K = G[0] - L[0] * I.k, q = G[1] - L[1] * I.k;
    return K === I.x && q === I.y ? I : new dc(I.k, K, q);
  }
  function O(I) {
    return [(+I[0][0] + +I[1][0]) / 2, (+I[0][1] + +I[1][1]) / 2];
  }
  function N(I, G, L, K) {
    I.on("start.zoom", function() {
      R(this, arguments).event(K).start();
    }).on("interrupt.zoom end.zoom", function() {
      R(this, arguments).event(K).end();
    }).tween("zoom", function() {
      var q = this, Z = arguments, V = R(q, Z).event(K), F = t.apply(q, Z), X = L == null ? O(F) : typeof L == "function" ? L.apply(q, Z) : L, U = Math.max(F[1][0] - F[0][0], F[1][1] - F[0][1]), H = q.__zoom, Q = typeof G == "function" ? G.apply(q, Z) : G, re = d(H.invert(X).concat(U / H.k), Q.invert(X).concat(U / Q.k));
      return function(de) {
        if (de === 1) de = Q;
        else {
          var le = re(de), me = U / le[2];
          de = new dc(me, X[0] - le[0] * me, X[1] - le[1] * me);
        }
        V.zoom(null, de);
      };
    });
  }
  function R(I, G, L) {
    return !L && I.__zooming || new j(I, G);
  }
  function j(I, G) {
    this.that = I, this.args = G, this.active = 0, this.sourceEvent = null, this.extent = t.apply(I, G), this.taps = 0;
  }
  j.prototype = {
    event: function(I) {
      return I && (this.sourceEvent = I), this;
    },
    start: function() {
      return ++this.active === 1 && (this.that.__zooming = this, this.emit("start")), this;
    },
    zoom: function(I, G) {
      return this.mouse && I !== "mouse" && (this.mouse[1] = G.invert(this.mouse[0])), this.touch0 && I !== "touch" && (this.touch0[1] = G.invert(this.touch0[0])), this.touch1 && I !== "touch" && (this.touch1[1] = G.invert(this.touch1[0])), this.that.__zoom = G, this.emit("zoom"), this;
    },
    end: function() {
      return --this.active === 0 && (delete this.that.__zooming, this.emit("end")), this;
    },
    emit: function(I) {
      var G = gi(this.that).datum();
      p.call(
        I,
        this.that,
        new jge(I, {
          sourceEvent: this.sourceEvent,
          target: k,
          transform: this.that.__zoom,
          dispatch: p
        }),
        G
      );
    }
  };
  function D(I, ...G) {
    if (!e.apply(this, arguments)) return;
    var L = R(this, G).event(I), K = this.__zoom, q = Math.max(s[0], Math.min(s[1], K.k * Math.pow(2, r.apply(this, arguments)))), Z = As(I);
    if (L.wheel)
      (L.mouse[0][0] !== Z[0] || L.mouse[0][1] !== Z[1]) && (L.mouse[1] = K.invert(L.mouse[0] = Z)), clearTimeout(L.wheel);
    else {
      if (K.k === q) return;
      L.mouse = [Z, K.invert(Z)], $0(this), L.start();
    }
    fw(I), L.wheel = setTimeout(V, w), L.zoom("mouse", n(_(C(K, q), L.mouse[0], L.mouse[1]), L.extent, l));
    function V() {
      L.wheel = null, L.end();
    }
  }
  function $(I, ...G) {
    if (v || !e.apply(this, arguments)) return;
    var L = I.currentTarget, K = R(this, G, !0).event(I), q = gi(I.view).on("mousemove.zoom", X, !0).on("mouseup.zoom", U, !0), Z = As(I, L), V = I.clientX, F = I.clientY;
    NB(I.view), TM(I), K.mouse = [Z, this.__zoom.invert(Z)], $0(this), K.start();
    function X(H) {
      if (fw(H), !K.moved) {
        var Q = H.clientX - V, re = H.clientY - F;
        K.moved = Q * Q + re * re > x;
      }
      K.event(H).zoom("mouse", n(_(K.that.__zoom, K.mouse[0] = As(H, L), K.mouse[1]), K.extent, l));
    }
    function U(H) {
      q.on("mousemove.zoom mouseup.zoom", null), RB(H.view, K.moved), fw(H), K.event(H).end();
    }
  }
  function z(I, ...G) {
    if (e.apply(this, arguments)) {
      var L = this.__zoom, K = As(I.changedTouches ? I.changedTouches[0] : I, this), q = L.invert(K), Z = L.k * (I.shiftKey ? 0.5 : 2), V = n(_(C(L, Z), K, q), t.apply(this, G), l);
      fw(I), c > 0 ? gi(this).transition().duration(c).call(N, V, K, I) : gi(this).call(k.transform, V, K, I);
    }
  }
  function B(I, ...G) {
    if (e.apply(this, arguments)) {
      var L = I.touches, K = L.length, q = R(this, G, I.changedTouches.length === K).event(I), Z, V, F, X;
      for (TM(I), V = 0; V < K; ++V)
        F = L[V], X = As(F, this), X = [X, this.__zoom.invert(X), F.identifier], q.touch0 ? !q.touch1 && q.touch0[2] !== X[2] && (q.touch1 = X, q.taps = 0) : (q.touch0 = X, Z = !0, q.taps = 1 + !!m);
      m && (m = clearTimeout(m)), Z && (q.taps < 2 && (h = X[0], m = setTimeout(function() {
        m = null;
      }, y)), $0(this), q.start());
    }
  }
  function P(I, ...G) {
    if (this.__zooming) {
      var L = R(this, G).event(I), K = I.changedTouches, q = K.length, Z, V, F, X;
      for (fw(I), Z = 0; Z < q; ++Z)
        V = K[Z], F = As(V, this), L.touch0 && L.touch0[2] === V.identifier ? L.touch0[0] = F : L.touch1 && L.touch1[2] === V.identifier && (L.touch1[0] = F);
      if (V = L.that.__zoom, L.touch1) {
        var U = L.touch0[0], H = L.touch0[1], Q = L.touch1[0], re = L.touch1[1], de = (de = Q[0] - U[0]) * de + (de = Q[1] - U[1]) * de, le = (le = re[0] - H[0]) * le + (le = re[1] - H[1]) * le;
        V = C(V, Math.sqrt(de / le)), F = [(U[0] + Q[0]) / 2, (U[1] + Q[1]) / 2], X = [(H[0] + re[0]) / 2, (H[1] + re[1]) / 2];
      } else if (L.touch0) F = L.touch0[0], X = L.touch0[1];
      else return;
      L.zoom("touch", n(_(V, F, X), L.extent, l));
    }
  }
  function W(I, ...G) {
    if (this.__zooming) {
      var L = R(this, G).event(I), K = I.changedTouches, q = K.length, Z, V;
      for (TM(I), v && clearTimeout(v), v = setTimeout(function() {
        v = null;
      }, y), Z = 0; Z < q; ++Z)
        V = K[Z], L.touch0 && L.touch0[2] === V.identifier ? delete L.touch0 : L.touch1 && L.touch1[2] === V.identifier && delete L.touch1;
      if (L.touch1 && !L.touch0 && (L.touch0 = L.touch1, delete L.touch1), L.touch0) L.touch0[1] = this.__zoom.invert(L.touch0[0]);
      else if (L.end(), L.taps === 2 && (V = As(V, this), Math.hypot(h[0] - V[0], h[1] - V[1]) < b)) {
        var F = gi(this).on("dblclick.zoom");
        F && F.apply(this, arguments);
      }
    }
  }
  return k.wheelDelta = function(I) {
    return arguments.length ? (r = typeof I == "function" ? I : fk(+I), k) : r;
  }, k.filter = function(I) {
    return arguments.length ? (e = typeof I == "function" ? I : fk(!!I), k) : e;
  }, k.touchable = function(I) {
    return arguments.length ? (a = typeof I == "function" ? I : fk(!!I), k) : a;
  }, k.extent = function(I) {
    return arguments.length ? (t = typeof I == "function" ? I : fk([[+I[0][0], +I[0][1]], [+I[1][0], +I[1][1]]]), k) : t;
  }, k.scaleExtent = function(I) {
    return arguments.length ? (s[0] = +I[0], s[1] = +I[1], k) : [s[0], s[1]];
  }, k.translateExtent = function(I) {
    return arguments.length ? (l[0][0] = +I[0][0], l[1][0] = +I[1][0], l[0][1] = +I[0][1], l[1][1] = +I[1][1], k) : [[l[0][0], l[0][1]], [l[1][0], l[1][1]]];
  }, k.constrain = function(I) {
    return arguments.length ? (n = I, k) : n;
  }, k.duration = function(I) {
    return arguments.length ? (c = +I, k) : c;
  }, k.interpolate = function(I) {
    return arguments.length ? (d = I, k) : d;
  }, k.on = function() {
    var I = p.on.apply(p, arguments);
    return I === p ? k : I;
  }, k.clickDistance = function(I) {
    return arguments.length ? (x = (I = +I) * I, k) : Math.sqrt(x);
  }, k.tapDistance = function(I) {
    return arguments.length ? (b = +I, k) : b;
  }, k;
}
const Ml = {
  error001: () => "[React Flow]: Seems like you have not used zustand provider as an ancestor. Help: https://reactflow.dev/error#001",
  error002: () => "It looks like you've created a new nodeTypes or edgeTypes object. If this wasn't on purpose please define the nodeTypes/edgeTypes outside of the component or memoize them.",
  error003: (e) => `Node type "${e}" not found. Using fallback type "default".`,
  error004: () => "The React Flow parent container needs a width and a height to render the graph.",
  error005: () => "Only child nodes can use a parent extent.",
  error006: () => "Can't create edge. An edge needs a source and a target.",
  error007: (e) => `The old edge with id=${e} does not exist.`,
  error009: (e) => `Marker type "${e}" doesn't exist.`,
  error008: (e, { id: t, sourceHandle: n, targetHandle: r }) => `Couldn't create edge for ${e} handle id: "${e === "source" ? n : r}", edge id: ${t}.`,
  error010: () => "Handle: No node id found. Make sure to only use a Handle inside a custom Node.",
  error011: (e) => `Edge type "${e}" not found. Using fallback type "default".`,
  error012: (e) => `Node with id "${e}" does not exist, it may have been removed. This can happen when a node is deleted before the "onNodeClick" handler is called.`,
  error013: (e = "react") => `It seems that you haven't loaded the styles. Please import '@xyflow/${e}/dist/style.css' or base.css to make sure everything is working properly.`,
  error014: () => "useNodeConnections: No node ID found. Call useNodeConnections inside a custom Node or provide a node ID.",
  error015: () => "It seems that you are trying to drag a node that is not initialized. Please use onNodesChange as explained in the docs."
}, _x = [
  [Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY],
  [Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY]
], KB = ["Enter", " ", "Escape"], XB = {
  "node.a11yDescription.default": "Press enter or space to select a node. Press delete to remove it and escape to cancel.",
  "node.a11yDescription.keyboardDisabled": "Press enter or space to select a node. You can then use the arrow keys to move the node around. Press delete to remove it and escape to cancel.",
  "node.a11yDescription.ariaLiveMessage": ({ direction: e, x: t, y: n }) => `Moved selected node ${e}. New position, x: ${t}, y: ${n}`,
  "edge.a11yDescription.default": "Press enter or space to select an edge. You can then press delete to remove it or escape to cancel.",
  // Control elements
  "controls.ariaLabel": "Control Panel",
  "controls.zoomIn.ariaLabel": "Zoom In",
  "controls.zoomOut.ariaLabel": "Zoom Out",
  "controls.fitView.ariaLabel": "Fit View",
  "controls.interactive.ariaLabel": "Toggle Interactivity",
  // Mini map
  "minimap.ariaLabel": "Mini Map",
  // Handle
  "handle.ariaLabel": "Handle"
};
var zh;
(function(e) {
  e.Strict = "strict", e.Loose = "loose";
})(zh || (zh = {}));
var am;
(function(e) {
  e.Free = "free", e.Vertical = "vertical", e.Horizontal = "horizontal";
})(am || (am = {}));
var Ex;
(function(e) {
  e.Partial = "partial", e.Full = "full";
})(Ex || (Ex = {}));
const YB = {
  inProgress: !1,
  isValid: null,
  from: null,
  fromHandle: null,
  fromPosition: null,
  fromNode: null,
  to: null,
  toHandle: null,
  toPosition: null,
  toNode: null,
  pointer: null
};
var Gc;
(function(e) {
  e.Bezier = "default", e.Straight = "straight", e.Step = "step", e.SmoothStep = "smoothstep", e.SimpleBezier = "simplebezier";
})(Gc || (Gc = {}));
var x_;
(function(e) {
  e.Arrow = "arrow", e.ArrowClosed = "arrowclosed";
})(x_ || (x_ = {}));
var st;
(function(e) {
  e.Left = "left", e.Top = "top", e.Right = "right", e.Bottom = "bottom";
})(st || (st = {}));
const X6 = {
  [st.Left]: st.Right,
  [st.Right]: st.Left,
  [st.Top]: st.Bottom,
  [st.Bottom]: st.Top
};
function QB(e) {
  return e === null ? null : e ? "valid" : "invalid";
}
const JB = (e) => "id" in e && "source" in e && "target" in e, Ige = (e) => "id" in e && "position" in e && !("source" in e) && !("target" in e), lA = (e) => "id" in e && "internals" in e && !("source" in e) && !("target" in e), vS = (e, t = [0, 0]) => {
  const { width: n, height: r } = Ac(e), a = e.origin ?? t, s = n * a[0], l = r * a[1];
  return {
    x: e.position.x - s,
    y: e.position.y - l
  };
}, zge = (e, t = { nodeOrigin: [0, 0] }) => {
  if (e.length === 0)
    return { x: 0, y: 0, width: 0, height: 0 };
  const n = e.reduce((r, a) => {
    const s = typeof a == "string";
    let l = !t.nodeLookup && !s ? a : void 0;
    t.nodeLookup && (l = s ? t.nodeLookup.get(a) : lA(a) ? a : t.nodeLookup.get(a.id));
    const c = l ? S_(l, t.nodeOrigin) : { x: 0, y: 0, x2: 0, y2: 0 };
    return H2(r, c);
  }, { x: 1 / 0, y: 1 / 0, x2: -1 / 0, y2: -1 / 0 });
  return q2(n);
}, yS = (e, t = {}) => {
  let n = { x: 1 / 0, y: 1 / 0, x2: -1 / 0, y2: -1 / 0 }, r = !1;
  return e.forEach((a) => {
    (t.filter === void 0 || t.filter(a)) && (n = H2(n, S_(a)), r = !0);
  }), r ? q2(n) : { x: 0, y: 0, width: 0, height: 0 };
}, uA = (e, t, [n, r, a] = [0, 0, 1], s = !1, l = !1) => {
  const c = {
    ...wS(t, [n, r, a]),
    width: t.width / a,
    height: t.height / a
  }, d = [];
  for (const p of e.values()) {
    const { measured: m, selectable: h = !0, hidden: v = !1 } = p;
    if (l && !h || v)
      continue;
    const y = m.width ?? p.width ?? p.initialWidth ?? null, w = m.height ?? p.height ?? p.initialHeight ?? null, x = Cx(c, Bh(p)), b = (y ?? 0) * (w ?? 0), k = s && x > 0;
    (!p.internals.handleBounds || k || x >= b || p.dragging) && d.push(p);
  }
  return d;
}, Fge = (e, t) => {
  const n = /* @__PURE__ */ new Set();
  return e.forEach((r) => {
    n.add(r.id);
  }), t.filter((r) => n.has(r.source) || n.has(r.target));
};
function Bge(e, t) {
  const n = /* @__PURE__ */ new Map(), r = t?.nodes ? new Set(t.nodes.map((a) => a.id)) : null;
  return e.forEach((a) => {
    a.measured.width && a.measured.height && (t?.includeHiddenNodes || !a.hidden) && (!r || r.has(a.id)) && n.set(a.id, a);
  }), n;
}
async function Uge({ nodes: e, width: t, height: n, panZoom: r, minZoom: a, maxZoom: s }, l) {
  if (e.size === 0)
    return Promise.resolve(!0);
  const c = Bge(e, l), d = yS(c), p = cA(d, t, n, l?.minZoom ?? a, l?.maxZoom ?? s, l?.padding ?? 0.1);
  return await r.setViewport(p, {
    duration: l?.duration,
    ease: l?.ease,
    interpolate: l?.interpolate
  }), Promise.resolve(!0);
}
function ZB({ nodeId: e, nextPosition: t, nodeLookup: n, nodeOrigin: r = [0, 0], nodeExtent: a, onError: s }) {
  const l = n.get(e), c = l.parentId ? n.get(l.parentId) : void 0, { x: d, y: p } = c ? c.internals.positionAbsolute : { x: 0, y: 0 }, m = l.origin ?? r;
  let h = l.extent || a;
  if (l.extent === "parent" && !l.expandParent)
    if (!c)
      s?.("005", Ml.error005());
    else {
      const y = c.measured.width, w = c.measured.height;
      y && w && (h = [
        [d, p],
        [d + y, p + w]
      ]);
    }
  else c && Uh(l.extent) && (h = [
    [l.extent[0][0] + d, l.extent[0][1] + p],
    [l.extent[1][0] + d, l.extent[1][1] + p]
  ]);
  const v = Uh(h) ? mm(t, h, l.measured) : t;
  return (l.measured.width === void 0 || l.measured.height === void 0) && s?.("015", Ml.error015()), {
    position: {
      x: v.x - d + (l.measured.width ?? 0) * m[0],
      y: v.y - p + (l.measured.height ?? 0) * m[1]
    },
    positionAbsolute: v
  };
}
async function Vge({ nodesToRemove: e = [], edgesToRemove: t = [], nodes: n, edges: r, onBeforeDelete: a }) {
  const s = new Set(e.map((h) => h.id)), l = [];
  for (const h of n) {
    if (h.deletable === !1)
      continue;
    const v = s.has(h.id), y = !v && h.parentId && l.find((w) => w.id === h.parentId);
    (v || y) && l.push(h);
  }
  const c = new Set(t.map((h) => h.id)), d = r.filter((h) => h.deletable !== !1), p = Fge(l, d);
  for (const h of d)
    c.has(h.id) && !p.find((v) => v.id === h.id) && p.push(h);
  if (!a)
    return {
      edges: p,
      nodes: l
    };
  const m = await a({
    nodes: l,
    edges: p
  });
  return typeof m == "boolean" ? m ? { edges: p, nodes: l } : { edges: [], nodes: [] } : m;
}
const Fh = (e, t = 0, n = 1) => Math.min(Math.max(e, t), n), mm = (e = { x: 0, y: 0 }, t, n) => ({
  x: Fh(e.x, t[0][0], t[1][0] - (n?.width ?? 0)),
  y: Fh(e.y, t[0][1], t[1][1] - (n?.height ?? 0))
});
function eU(e, t, n) {
  const { width: r, height: a } = Ac(n), { x: s, y: l } = n.internals.positionAbsolute;
  return mm(e, [
    [s, l],
    [s + r, l + a]
  ], t);
}
const Y6 = (e, t, n) => e < t ? Fh(Math.abs(e - t), 1, t) / t : e > n ? -Fh(Math.abs(e - n), 1, t) / t : 0, tU = (e, t, n = 15, r = 40) => {
  const a = Y6(e.x, r, t.width - r) * n, s = Y6(e.y, r, t.height - r) * n;
  return [a, s];
}, H2 = (e, t) => ({
  x: Math.min(e.x, t.x),
  y: Math.min(e.y, t.y),
  x2: Math.max(e.x2, t.x2),
  y2: Math.max(e.y2, t.y2)
}), F5 = ({ x: e, y: t, width: n, height: r }) => ({
  x: e,
  y: t,
  x2: e + n,
  y2: t + r
}), q2 = ({ x: e, y: t, x2: n, y2: r }) => ({
  x: e,
  y: t,
  width: n - e,
  height: r - t
}), Bh = (e, t = [0, 0]) => {
  const { x: n, y: r } = lA(e) ? e.internals.positionAbsolute : vS(e, t);
  return {
    x: n,
    y: r,
    width: e.measured?.width ?? e.width ?? e.initialWidth ?? 0,
    height: e.measured?.height ?? e.height ?? e.initialHeight ?? 0
  };
}, S_ = (e, t = [0, 0]) => {
  const { x: n, y: r } = lA(e) ? e.internals.positionAbsolute : vS(e, t);
  return {
    x: n,
    y: r,
    x2: n + (e.measured?.width ?? e.width ?? e.initialWidth ?? 0),
    y2: r + (e.measured?.height ?? e.height ?? e.initialHeight ?? 0)
  };
}, nU = (e, t) => q2(H2(F5(e), F5(t))), Cx = (e, t) => {
  const n = Math.max(0, Math.min(e.x + e.width, t.x + t.width) - Math.max(e.x, t.x)), r = Math.max(0, Math.min(e.y + e.height, t.y + t.height) - Math.max(e.y, t.y));
  return Math.ceil(n * r);
}, Q6 = (e) => $s(e.width) && $s(e.height) && $s(e.x) && $s(e.y), $s = (e) => !isNaN(e) && isFinite(e), Hge = (e, t) => {
}, bS = (e, t = [1, 1]) => ({
  x: t[0] * Math.round(e.x / t[0]),
  y: t[1] * Math.round(e.y / t[1])
}), wS = ({ x: e, y: t }, [n, r, a], s = !1, l = [1, 1]) => {
  const c = {
    x: (e - n) / a,
    y: (t - r) / a
  };
  return s ? bS(c, l) : c;
}, k_ = ({ x: e, y: t }, [n, r, a]) => ({
  x: e * a + n,
  y: t * a + r
});
function Xm(e, t) {
  if (typeof e == "number")
    return Math.floor((t - t / (1 + e)) * 0.5);
  if (typeof e == "string" && e.endsWith("px")) {
    const n = parseFloat(e);
    if (!Number.isNaN(n))
      return Math.floor(n);
  }
  if (typeof e == "string" && e.endsWith("%")) {
    const n = parseFloat(e);
    if (!Number.isNaN(n))
      return Math.floor(t * n * 0.01);
  }
  return console.error(`[React Flow] The padding value "${e}" is invalid. Please provide a number or a string with a valid unit (px or %).`), 0;
}
function qge(e, t, n) {
  if (typeof e == "string" || typeof e == "number") {
    const r = Xm(e, n), a = Xm(e, t);
    return {
      top: r,
      right: a,
      bottom: r,
      left: a,
      x: a * 2,
      y: r * 2
    };
  }
  if (typeof e == "object") {
    const r = Xm(e.top ?? e.y ?? 0, n), a = Xm(e.bottom ?? e.y ?? 0, n), s = Xm(e.left ?? e.x ?? 0, t), l = Xm(e.right ?? e.x ?? 0, t);
    return { top: r, right: l, bottom: a, left: s, x: s + l, y: r + a };
  }
  return { top: 0, right: 0, bottom: 0, left: 0, x: 0, y: 0 };
}
function Wge(e, t, n, r, a, s) {
  const { x: l, y: c } = k_(e, [t, n, r]), { x: d, y: p } = k_({ x: e.x + e.width, y: e.y + e.height }, [t, n, r]), m = a - d, h = s - p;
  return {
    left: Math.floor(l),
    top: Math.floor(c),
    right: Math.floor(m),
    bottom: Math.floor(h)
  };
}
const cA = (e, t, n, r, a, s) => {
  const l = qge(s, t, n), c = (t - l.x) / e.width, d = (n - l.y) / e.height, p = Math.min(c, d), m = Fh(p, r, a), h = e.x + e.width / 2, v = e.y + e.height / 2, y = t / 2 - h * m, w = n / 2 - v * m, x = Wge(e, y, w, m, t, n), b = {
    left: Math.min(x.left - l.left, 0),
    top: Math.min(x.top - l.top, 0),
    right: Math.min(x.right - l.right, 0),
    bottom: Math.min(x.bottom - l.bottom, 0)
  };
  return {
    x: y - b.left + b.right,
    y: w - b.top + b.bottom,
    zoom: m
  };
}, Ox = () => typeof navigator < "u" && navigator?.userAgent?.indexOf("Mac") >= 0;
function Uh(e) {
  return e != null && e !== "parent";
}
function Ac(e) {
  return {
    width: e.measured?.width ?? e.width ?? e.initialWidth ?? 0,
    height: e.measured?.height ?? e.height ?? e.initialHeight ?? 0
  };
}
function rU(e) {
  return (e.measured?.width ?? e.width ?? e.initialWidth) !== void 0 && (e.measured?.height ?? e.height ?? e.initialHeight) !== void 0;
}
function oU(e, t = { width: 0, height: 0 }, n, r, a) {
  const s = { ...e }, l = r.get(n);
  if (l) {
    const c = l.origin || a;
    s.x += l.internals.positionAbsolute.x - (t.width ?? 0) * c[0], s.y += l.internals.positionAbsolute.y - (t.height ?? 0) * c[1];
  }
  return s;
}
function J6(e, t) {
  if (e.size !== t.size)
    return !1;
  for (const n of e)
    if (!t.has(n))
      return !1;
  return !0;
}
function Gge() {
  let e, t;
  return { promise: new Promise((n, r) => {
    e = n, t = r;
  }), resolve: e, reject: t };
}
function Kge(e) {
  return { ...XB, ...e || {} };
}
function Yw(e, { snapGrid: t = [0, 0], snapToGrid: n = !1, transform: r, containerBounds: a }) {
  const { x: s, y: l } = Ts(e), c = wS({ x: s - (a?.left ?? 0), y: l - (a?.top ?? 0) }, r), { x: d, y: p } = n ? bS(c, t) : c;
  return {
    xSnapped: d,
    ySnapped: p,
    ...c
  };
}
const dA = (e) => ({
  width: e.offsetWidth,
  height: e.offsetHeight
}), aU = (e) => e?.getRootNode?.() || window?.document, Xge = ["INPUT", "SELECT", "TEXTAREA"];
function iU(e) {
  const t = e.composedPath?.()?.[0] || e.target;
  return t?.nodeType !== 1 ? !1 : Xge.includes(t.nodeName) || t.hasAttribute("contenteditable") || !!t.closest(".nokey");
}
const sU = (e) => "clientX" in e, Ts = (e, t) => {
  const n = sU(e), r = n ? e.clientX : e.touches?.[0].clientX, a = n ? e.clientY : e.touches?.[0].clientY;
  return {
    x: r - (t?.left ?? 0),
    y: a - (t?.top ?? 0)
  };
}, Z6 = (e, t, n, r, a) => {
  const s = t.querySelectorAll(`.${e}`);
  return !s || !s.length ? null : Array.from(s).map((l) => {
    const c = l.getBoundingClientRect();
    return {
      id: l.getAttribute("data-handleid"),
      type: e,
      nodeId: a,
      position: l.getAttribute("data-handlepos"),
      x: (c.left - n.left) / r,
      y: (c.top - n.top) / r,
      ...dA(l)
    };
  });
};
function lU({ sourceX: e, sourceY: t, targetX: n, targetY: r, sourceControlX: a, sourceControlY: s, targetControlX: l, targetControlY: c }) {
  const d = e * 0.125 + a * 0.375 + l * 0.375 + n * 0.125, p = t * 0.125 + s * 0.375 + c * 0.375 + r * 0.125, m = Math.abs(d - e), h = Math.abs(p - t);
  return [d, p, m, h];
}
function pk(e, t) {
  return e >= 0 ? 0.5 * e : t * 25 * Math.sqrt(-e);
}
function e$({ pos: e, x1: t, y1: n, x2: r, y2: a, c: s }) {
  switch (e) {
    case st.Left:
      return [t - pk(t - r, s), n];
    case st.Right:
      return [t + pk(r - t, s), n];
    case st.Top:
      return [t, n - pk(n - a, s)];
    case st.Bottom:
      return [t, n + pk(a - n, s)];
  }
}
function fA({ sourceX: e, sourceY: t, sourcePosition: n = st.Bottom, targetX: r, targetY: a, targetPosition: s = st.Top, curvature: l = 0.25 }) {
  const [c, d] = e$({
    pos: n,
    x1: e,
    y1: t,
    x2: r,
    y2: a,
    c: l
  }), [p, m] = e$({
    pos: s,
    x1: r,
    y1: a,
    x2: e,
    y2: t,
    c: l
  }), [h, v, y, w] = lU({
    sourceX: e,
    sourceY: t,
    targetX: r,
    targetY: a,
    sourceControlX: c,
    sourceControlY: d,
    targetControlX: p,
    targetControlY: m
  });
  return [
    `M${e},${t} C${c},${d} ${p},${m} ${r},${a}`,
    h,
    v,
    y,
    w
  ];
}
function uU({ sourceX: e, sourceY: t, targetX: n, targetY: r }) {
  const a = Math.abs(n - e) / 2, s = n < e ? n + a : n - a, l = Math.abs(r - t) / 2, c = r < t ? r + l : r - l;
  return [s, c, a, l];
}
function Yge({ sourceNode: e, targetNode: t, selected: n = !1, zIndex: r = 0, elevateOnSelect: a = !1, zIndexMode: s = "basic" }) {
  if (s === "manual")
    return r;
  const l = a && n ? r + 1e3 : r, c = Math.max(e.parentId || a && e.selected ? e.internals.z : 0, t.parentId || a && t.selected ? t.internals.z : 0);
  return l + c;
}
function Qge({ sourceNode: e, targetNode: t, width: n, height: r, transform: a }) {
  const s = H2(S_(e), S_(t));
  s.x === s.x2 && (s.x2 += 1), s.y === s.y2 && (s.y2 += 1);
  const l = {
    x: -a[0] / a[2],
    y: -a[1] / a[2],
    width: n / a[2],
    height: r / a[2]
  };
  return Cx(l, q2(s)) > 0;
}
const Jge = ({ source: e, sourceHandle: t, target: n, targetHandle: r }) => `xy-edge__${e}${t || ""}-${n}${r || ""}`, Zge = (e, t) => t.some((n) => n.source === e.source && n.target === e.target && (n.sourceHandle === e.sourceHandle || !n.sourceHandle && !e.sourceHandle) && (n.targetHandle === e.targetHandle || !n.targetHandle && !e.targetHandle)), eve = (e, t, n = {}) => {
  if (!e.source || !e.target)
    return t;
  const r = n.getEdgeId || Jge;
  let a;
  return JB(e) ? a = { ...e } : a = {
    ...e,
    id: r(e)
  }, Zge(a, t) ? t : (a.sourceHandle === null && delete a.sourceHandle, a.targetHandle === null && delete a.targetHandle, t.concat(a));
};
function cU({ sourceX: e, sourceY: t, targetX: n, targetY: r }) {
  const [a, s, l, c] = uU({
    sourceX: e,
    sourceY: t,
    targetX: n,
    targetY: r
  });
  return [`M ${e},${t}L ${n},${r}`, a, s, l, c];
}
const t$ = {
  [st.Left]: { x: -1, y: 0 },
  [st.Right]: { x: 1, y: 0 },
  [st.Top]: { x: 0, y: -1 },
  [st.Bottom]: { x: 0, y: 1 }
}, tve = ({ source: e, sourcePosition: t = st.Bottom, target: n }) => t === st.Left || t === st.Right ? e.x < n.x ? { x: 1, y: 0 } : { x: -1, y: 0 } : e.y < n.y ? { x: 0, y: 1 } : { x: 0, y: -1 }, n$ = (e, t) => Math.sqrt(Math.pow(t.x - e.x, 2) + Math.pow(t.y - e.y, 2));
function nve({ source: e, sourcePosition: t = st.Bottom, target: n, targetPosition: r = st.Top, center: a, offset: s, stepPosition: l }) {
  const c = t$[t], d = t$[r], p = { x: e.x + c.x * s, y: e.y + c.y * s }, m = { x: n.x + d.x * s, y: n.y + d.y * s }, h = tve({
    source: p,
    sourcePosition: t,
    target: m
  }), v = h.x !== 0 ? "x" : "y", y = h[v];
  let w = [], x, b;
  const k = { x: 0, y: 0 }, C = { x: 0, y: 0 }, [, , _, O] = uU({
    sourceX: e.x,
    sourceY: e.y,
    targetX: n.x,
    targetY: n.y
  });
  if (c[v] * d[v] === -1) {
    v === "x" ? (x = a.x ?? p.x + (m.x - p.x) * l, b = a.y ?? (p.y + m.y) / 2) : (x = a.x ?? (p.x + m.x) / 2, b = a.y ?? p.y + (m.y - p.y) * l);
    const N = [
      { x, y: p.y },
      { x, y: m.y }
    ], R = [
      { x: p.x, y: b },
      { x: m.x, y: b }
    ];
    c[v] === y ? w = v === "x" ? N : R : w = v === "x" ? R : N;
  } else {
    const N = [{ x: p.x, y: m.y }], R = [{ x: m.x, y: p.y }];
    if (v === "x" ? w = c.x === y ? R : N : w = c.y === y ? N : R, t === r) {
      const B = Math.abs(e[v] - n[v]);
      if (B <= s) {
        const P = Math.min(s - 1, s - B);
        c[v] === y ? k[v] = (p[v] > e[v] ? -1 : 1) * P : C[v] = (m[v] > n[v] ? -1 : 1) * P;
      }
    }
    if (t !== r) {
      const B = v === "x" ? "y" : "x", P = c[v] === d[B], W = p[B] > m[B], I = p[B] < m[B];
      (c[v] === 1 && (!P && W || P && I) || c[v] !== 1 && (!P && I || P && W)) && (w = v === "x" ? N : R);
    }
    const j = { x: p.x + k.x, y: p.y + k.y }, D = { x: m.x + C.x, y: m.y + C.y }, $ = Math.max(Math.abs(j.x - w[0].x), Math.abs(D.x - w[0].x)), z = Math.max(Math.abs(j.y - w[0].y), Math.abs(D.y - w[0].y));
    $ >= z ? (x = (j.x + D.x) / 2, b = w[0].y) : (x = w[0].x, b = (j.y + D.y) / 2);
  }
  return [[
    e,
    { x: p.x + k.x, y: p.y + k.y },
    ...w,
    { x: m.x + C.x, y: m.y + C.y },
    n
  ], x, b, _, O];
}
function rve(e, t, n, r) {
  const a = Math.min(n$(e, t) / 2, n$(t, n) / 2, r), { x: s, y: l } = t;
  if (e.x === s && s === n.x || e.y === l && l === n.y)
    return `L${s} ${l}`;
  if (e.y === l) {
    const p = e.x < n.x ? -1 : 1, m = e.y < n.y ? 1 : -1;
    return `L ${s + a * p},${l}Q ${s},${l} ${s},${l + a * m}`;
  }
  const c = e.x < n.x ? 1 : -1, d = e.y < n.y ? -1 : 1;
  return `L ${s},${l + a * d}Q ${s},${l} ${s + a * c},${l}`;
}
function B5({ sourceX: e, sourceY: t, sourcePosition: n = st.Bottom, targetX: r, targetY: a, targetPosition: s = st.Top, borderRadius: l = 5, centerX: c, centerY: d, offset: p = 20, stepPosition: m = 0.5 }) {
  const [h, v, y, w, x] = nve({
    source: { x: e, y: t },
    sourcePosition: n,
    target: { x: r, y: a },
    targetPosition: s,
    center: { x: c, y: d },
    offset: p,
    stepPosition: m
  });
  return [h.reduce((b, k, C) => {
    let _ = "";
    return C > 0 && C < h.length - 1 ? _ = rve(h[C - 1], k, h[C + 1], l) : _ = `${C === 0 ? "M" : "L"}${k.x} ${k.y}`, b += _, b;
  }, ""), v, y, w, x];
}
function r$(e) {
  return e && !!(e.internals.handleBounds || e.handles?.length) && !!(e.measured.width || e.width || e.initialWidth);
}
function ove(e) {
  const { sourceNode: t, targetNode: n } = e;
  if (!r$(t) || !r$(n))
    return null;
  const r = t.internals.handleBounds || o$(t.handles), a = n.internals.handleBounds || o$(n.handles), s = a$(r?.source ?? [], e.sourceHandle), l = a$(
    // when connection type is loose we can define all handles as sources and connect source -> source
    e.connectionMode === zh.Strict ? a?.target ?? [] : (a?.target ?? []).concat(a?.source ?? []),
    e.targetHandle
  );
  if (!s || !l)
    return e.onError?.("008", Ml.error008(s ? "target" : "source", {
      id: e.id,
      sourceHandle: e.sourceHandle,
      targetHandle: e.targetHandle
    })), null;
  const c = s?.position || st.Bottom, d = l?.position || st.Top, p = hm(t, s, c), m = hm(n, l, d);
  return {
    sourceX: p.x,
    sourceY: p.y,
    targetX: m.x,
    targetY: m.y,
    sourcePosition: c,
    targetPosition: d
  };
}
function o$(e) {
  if (!e)
    return null;
  const t = [], n = [];
  for (const r of e)
    r.width = r.width ?? 1, r.height = r.height ?? 1, r.type === "source" ? t.push(r) : r.type === "target" && n.push(r);
  return {
    source: t,
    target: n
  };
}
function hm(e, t, n = st.Left, r = !1) {
  const a = (t?.x ?? 0) + e.internals.positionAbsolute.x, s = (t?.y ?? 0) + e.internals.positionAbsolute.y, { width: l, height: c } = t ?? Ac(e);
  if (r)
    return { x: a + l / 2, y: s + c / 2 };
  switch (t?.position ?? n) {
    case st.Top:
      return { x: a + l / 2, y: s };
    case st.Right:
      return { x: a + l, y: s + c / 2 };
    case st.Bottom:
      return { x: a + l / 2, y: s + c };
    case st.Left:
      return { x: a, y: s + c / 2 };
  }
}
function a$(e, t) {
  return e && (t ? e.find((n) => n.id === t) : e[0]) || null;
}
function U5(e, t) {
  return e ? typeof e == "string" ? e : `${t ? `${t}__` : ""}${Object.keys(e).sort().map((n) => `${n}=${e[n]}`).join("&")}` : "";
}
function ave(e, { id: t, defaultColor: n, defaultMarkerStart: r, defaultMarkerEnd: a }) {
  const s = /* @__PURE__ */ new Set();
  return e.reduce((l, c) => ([c.markerStart || r, c.markerEnd || a].forEach((d) => {
    if (d && typeof d == "object") {
      const p = U5(d, t);
      s.has(p) || (l.push({ id: p, color: d.color || n, ...d }), s.add(p));
    }
  }), l), []).sort((l, c) => l.id.localeCompare(c.id));
}
const dU = 1e3, ive = 10, pA = {
  nodeOrigin: [0, 0],
  nodeExtent: _x,
  elevateNodesOnSelect: !0,
  zIndexMode: "basic",
  defaults: {}
}, sve = {
  ...pA,
  checkEquality: !0
};
function mA(e, t) {
  const n = { ...e };
  for (const r in t)
    t[r] !== void 0 && (n[r] = t[r]);
  return n;
}
function lve(e, t, n) {
  const r = mA(pA, n);
  for (const a of e.values())
    if (a.parentId)
      gA(a, e, t, r);
    else {
      const s = vS(a, r.nodeOrigin), l = Uh(a.extent) ? a.extent : r.nodeExtent, c = mm(s, l, Ac(a));
      a.internals.positionAbsolute = c;
    }
}
function uve(e, t) {
  if (!e.handles)
    return e.measured ? t?.internals.handleBounds : void 0;
  const n = [], r = [];
  for (const a of e.handles) {
    const s = {
      id: a.id,
      width: a.width ?? 1,
      height: a.height ?? 1,
      nodeId: e.id,
      x: a.x,
      y: a.y,
      position: a.position,
      type: a.type
    };
    a.type === "source" ? n.push(s) : a.type === "target" && r.push(s);
  }
  return {
    source: n,
    target: r
  };
}
function hA(e) {
  return e === "manual";
}
function V5(e, t, n, r = {}) {
  const a = mA(sve, r), s = { i: 0 }, l = new Map(t), c = a?.elevateNodesOnSelect && !hA(a.zIndexMode) ? dU : 0;
  let d = e.length > 0;
  t.clear(), n.clear();
  for (const p of e) {
    let m = l.get(p.id);
    if (a.checkEquality && p === m?.internals.userNode)
      t.set(p.id, m);
    else {
      const h = vS(p, a.nodeOrigin), v = Uh(p.extent) ? p.extent : a.nodeExtent, y = mm(h, v, Ac(p));
      m = {
        ...a.defaults,
        ...p,
        measured: {
          width: p.measured?.width,
          height: p.measured?.height
        },
        internals: {
          positionAbsolute: y,
          // if user re-initializes the node or removes `measured` for whatever reason, we reset the handleBounds so that the node gets re-measured
          handleBounds: uve(p, m),
          z: fU(p, c, a.zIndexMode),
          userNode: p
        }
      }, t.set(p.id, m);
    }
    (m.measured === void 0 || m.measured.width === void 0 || m.measured.height === void 0) && !m.hidden && (d = !1), p.parentId && gA(m, t, n, r, s);
  }
  return d;
}
function cve(e, t) {
  if (!e.parentId)
    return;
  const n = t.get(e.parentId);
  n ? n.set(e.id, e) : t.set(e.parentId, /* @__PURE__ */ new Map([[e.id, e]]));
}
function gA(e, t, n, r, a) {
  const { elevateNodesOnSelect: s, nodeOrigin: l, nodeExtent: c, zIndexMode: d } = mA(pA, r), p = e.parentId, m = t.get(p);
  if (!m) {
    console.warn(`Parent node ${p} not found. Please make sure that parent nodes are in front of their child nodes in the nodes array.`);
    return;
  }
  cve(e, n), a && !m.parentId && m.internals.rootParentIndex === void 0 && d === "auto" && (m.internals.rootParentIndex = ++a.i, m.internals.z = m.internals.z + a.i * ive), a && m.internals.rootParentIndex !== void 0 && (a.i = m.internals.rootParentIndex);
  const h = s && !hA(d) ? dU : 0, { x: v, y, z: w } = dve(e, m, l, c, h, d), { positionAbsolute: x } = e.internals, b = v !== x.x || y !== x.y;
  (b || w !== e.internals.z) && t.set(e.id, {
    ...e,
    internals: {
      ...e.internals,
      positionAbsolute: b ? { x: v, y } : x,
      z: w
    }
  });
}
function fU(e, t, n) {
  const r = $s(e.zIndex) ? e.zIndex : 0;
  return hA(n) ? r : r + (e.selected ? t : 0);
}
function dve(e, t, n, r, a, s) {
  const { x: l, y: c } = t.internals.positionAbsolute, d = Ac(e), p = vS(e, n), m = Uh(e.extent) ? mm(p, e.extent, d) : p;
  let h = mm({ x: l + m.x, y: c + m.y }, r, d);
  e.extent === "parent" && (h = eU(h, d, t));
  const v = fU(e, a, s), y = t.internals.z ?? 0;
  return {
    x: h.x,
    y: h.y,
    z: y >= v ? y + 1 : v
  };
}
function vA(e, t, n, r = [0, 0]) {
  const a = [], s = /* @__PURE__ */ new Map();
  for (const l of e) {
    const c = t.get(l.parentId);
    if (!c)
      continue;
    const d = s.get(l.parentId)?.expandedRect ?? Bh(c), p = nU(d, l.rect);
    s.set(l.parentId, { expandedRect: p, parent: c });
  }
  return s.size > 0 && s.forEach(({ expandedRect: l, parent: c }, d) => {
    const p = c.internals.positionAbsolute, m = Ac(c), h = c.origin ?? r, v = l.x < p.x ? Math.round(Math.abs(p.x - l.x)) : 0, y = l.y < p.y ? Math.round(Math.abs(p.y - l.y)) : 0, w = Math.max(m.width, Math.round(l.width)), x = Math.max(m.height, Math.round(l.height)), b = (w - m.width) * h[0], k = (x - m.height) * h[1];
    (v > 0 || y > 0 || b || k) && (a.push({
      id: d,
      type: "position",
      position: {
        x: c.position.x - v + b,
        y: c.position.y - y + k
      }
    }), n.get(d)?.forEach((C) => {
      e.some((_) => _.id === C.id) || a.push({
        id: C.id,
        type: "position",
        position: {
          x: C.position.x + v,
          y: C.position.y + y
        }
      });
    })), (m.width < l.width || m.height < l.height || v || y) && a.push({
      id: d,
      type: "dimensions",
      setAttributes: !0,
      dimensions: {
        width: w + (v ? h[0] * v - b : 0),
        height: x + (y ? h[1] * y - k : 0)
      }
    });
  }), a;
}
function fve(e, t, n, r, a, s, l) {
  const c = r?.querySelector(".xyflow__viewport");
  let d = !1;
  if (!c)
    return { changes: [], updatedInternals: d };
  const p = [], m = window.getComputedStyle(c), { m22: h } = new window.DOMMatrixReadOnly(m.transform), v = [];
  for (const y of e.values()) {
    const w = t.get(y.id);
    if (!w)
      continue;
    if (w.hidden) {
      t.set(w.id, {
        ...w,
        internals: {
          ...w.internals,
          handleBounds: void 0
        }
      }), d = !0;
      continue;
    }
    const x = dA(y.nodeElement), b = w.measured.width !== x.width || w.measured.height !== x.height;
    if (x.width && x.height && (b || !w.internals.handleBounds || y.force)) {
      const k = y.nodeElement.getBoundingClientRect(), C = Uh(w.extent) ? w.extent : s;
      let { positionAbsolute: _ } = w.internals;
      w.parentId && w.extent === "parent" ? _ = eU(_, x, t.get(w.parentId)) : C && (_ = mm(_, C, x));
      const O = {
        ...w,
        measured: x,
        internals: {
          ...w.internals,
          positionAbsolute: _,
          handleBounds: {
            source: Z6("source", y.nodeElement, k, h, w.id),
            target: Z6("target", y.nodeElement, k, h, w.id)
          }
        }
      };
      t.set(w.id, O), w.parentId && gA(O, t, n, { nodeOrigin: a, zIndexMode: l }), d = !0, b && (p.push({
        id: w.id,
        type: "dimensions",
        dimensions: x
      }), w.expandParent && w.parentId && v.push({
        id: w.id,
        parentId: w.parentId,
        rect: Bh(O, a)
      }));
    }
  }
  if (v.length > 0) {
    const y = vA(v, t, n, a);
    p.push(...y);
  }
  return { changes: p, updatedInternals: d };
}
async function pve({ delta: e, panZoom: t, transform: n, translateExtent: r, width: a, height: s }) {
  if (!t || !e.x && !e.y)
    return Promise.resolve(!1);
  const l = await t.setViewportConstrained({
    x: n[0] + e.x,
    y: n[1] + e.y,
    zoom: n[2]
  }, [
    [0, 0],
    [a, s]
  ], r), c = !!l && (l.x !== n[0] || l.y !== n[1] || l.k !== n[2]);
  return Promise.resolve(c);
}
function i$(e, t, n, r, a, s) {
  let l = a;
  const c = r.get(l) || /* @__PURE__ */ new Map();
  r.set(l, c.set(n, t)), l = `${a}-${e}`;
  const d = r.get(l) || /* @__PURE__ */ new Map();
  if (r.set(l, d.set(n, t)), s) {
    l = `${a}-${e}-${s}`;
    const p = r.get(l) || /* @__PURE__ */ new Map();
    r.set(l, p.set(n, t));
  }
}
function pU(e, t, n) {
  e.clear(), t.clear();
  for (const r of n) {
    const { source: a, target: s, sourceHandle: l = null, targetHandle: c = null } = r, d = { edgeId: r.id, source: a, target: s, sourceHandle: l, targetHandle: c }, p = `${a}-${l}--${s}-${c}`, m = `${s}-${c}--${a}-${l}`;
    i$("source", d, m, e, a, l), i$("target", d, p, e, s, c), t.set(r.id, r);
  }
}
function mU(e, t) {
  if (!e.parentId)
    return !1;
  const n = t.get(e.parentId);
  return n ? n.selected ? !0 : mU(n, t) : !1;
}
function s$(e, t, n) {
  let r = e;
  do {
    if (r?.matches?.(t))
      return !0;
    if (r === n)
      return !1;
    r = r?.parentElement;
  } while (r);
  return !1;
}
function mve(e, t, n, r) {
  const a = /* @__PURE__ */ new Map();
  for (const [s, l] of e)
    if ((l.selected || l.id === r) && (!l.parentId || !mU(l, e)) && (l.draggable || t && typeof l.draggable > "u")) {
      const c = e.get(s);
      c && a.set(s, {
        id: s,
        position: c.position || { x: 0, y: 0 },
        distance: {
          x: n.x - c.internals.positionAbsolute.x,
          y: n.y - c.internals.positionAbsolute.y
        },
        extent: c.extent,
        parentId: c.parentId,
        origin: c.origin,
        expandParent: c.expandParent,
        internals: {
          positionAbsolute: c.internals.positionAbsolute || { x: 0, y: 0 }
        },
        measured: {
          width: c.measured.width ?? 0,
          height: c.measured.height ?? 0
        }
      });
    }
  return a;
}
function LM({ nodeId: e, dragItems: t, nodeLookup: n, dragging: r = !0 }) {
  const a = [];
  for (const [l, c] of t) {
    const d = n.get(l)?.internals.userNode;
    d && a.push({
      ...d,
      position: c.position,
      dragging: r
    });
  }
  if (!e)
    return [a[0], a];
  const s = n.get(e)?.internals.userNode;
  return [
    s ? {
      ...s,
      position: t.get(e)?.position || s.position,
      dragging: r
    } : a[0],
    a
  ];
}
function hve({ dragItems: e, snapGrid: t, x: n, y: r }) {
  const a = e.values().next().value;
  if (!a)
    return null;
  const s = {
    x: n - a.distance.x,
    y: r - a.distance.y
  }, l = bS(s, t);
  return {
    x: l.x - s.x,
    y: l.y - s.y
  };
}
function gve({ onNodeMouseDown: e, getStoreItems: t, onDragStart: n, onDrag: r, onDragStop: a }) {
  let s = { x: null, y: null }, l = 0, c = /* @__PURE__ */ new Map(), d = !1, p = { x: 0, y: 0 }, m = null, h = !1, v = null, y = !1, w = !1, x = null;
  function b({ noDragClassName: C, handleSelector: _, domNode: O, isSelectable: N, nodeId: R, nodeClickDistance: j = 0 }) {
    v = gi(O);
    function D({ x: P, y: W }) {
      const { nodeLookup: I, nodeExtent: G, snapGrid: L, snapToGrid: K, nodeOrigin: q, onNodeDrag: Z, onSelectionDrag: V, onError: F, updateNodePositions: X } = t();
      s = { x: P, y: W };
      let U = !1;
      const H = c.size > 1, Q = H && G ? F5(yS(c)) : null, re = H && K ? hve({
        dragItems: c,
        snapGrid: L,
        x: P,
        y: W
      }) : null;
      for (const [de, le] of c) {
        if (!I.has(de))
          continue;
        let me = { x: P - le.distance.x, y: W - le.distance.y };
        K && (me = re ? {
          x: Math.round(me.x + re.x),
          y: Math.round(me.y + re.y)
        } : bS(me, L));
        let ve = null;
        if (H && G && !le.extent && Q) {
          const { positionAbsolute: pe } = le.internals, ge = pe.x - Q.x + G[0][0], xe = pe.x + le.measured.width - Q.x2 + G[1][0], _e = pe.y - Q.y + G[0][1], We = pe.y + le.measured.height - Q.y2 + G[1][1];
          ve = [
            [ge, _e],
            [xe, We]
          ];
        }
        const { position: ae, positionAbsolute: se } = ZB({
          nodeId: de,
          nextPosition: me,
          nodeLookup: I,
          nodeExtent: ve || G,
          nodeOrigin: q,
          onError: F
        });
        U = U || le.position.x !== ae.x || le.position.y !== ae.y, le.position = ae, le.internals.positionAbsolute = se;
      }
      if (w = w || U, !!U && (X(c, !0), x && (r || Z || !R && V))) {
        const [de, le] = LM({
          nodeId: R,
          dragItems: c,
          nodeLookup: I
        });
        r?.(x, c, de, le), Z?.(x, de, le), R || V?.(x, le);
      }
    }
    async function $() {
      if (!m)
        return;
      const { transform: P, panBy: W, autoPanSpeed: I, autoPanOnNodeDrag: G } = t();
      if (!G) {
        d = !1, cancelAnimationFrame(l);
        return;
      }
      const [L, K] = tU(p, m, I);
      (L !== 0 || K !== 0) && (s.x = (s.x ?? 0) - L / P[2], s.y = (s.y ?? 0) - K / P[2], await W({ x: L, y: K }) && D(s)), l = requestAnimationFrame($);
    }
    function z(P) {
      const { nodeLookup: W, multiSelectionActive: I, nodesDraggable: G, transform: L, snapGrid: K, snapToGrid: q, selectNodesOnDrag: Z, onNodeDragStart: V, onSelectionDragStart: F, unselectNodesAndEdges: X } = t();
      h = !0, (!Z || !N) && !I && R && (W.get(R)?.selected || X()), N && Z && R && e?.(R);
      const U = Yw(P.sourceEvent, { transform: L, snapGrid: K, snapToGrid: q, containerBounds: m });
      if (s = U, c = mve(W, G, U, R), c.size > 0 && (n || V || !R && F)) {
        const [H, Q] = LM({
          nodeId: R,
          dragItems: c,
          nodeLookup: W
        });
        n?.(P.sourceEvent, c, H, Q), V?.(P.sourceEvent, H, Q), R || F?.(P.sourceEvent, Q);
      }
    }
    const B = AB().clickDistance(j).on("start", (P) => {
      const { domNode: W, nodeDragThreshold: I, transform: G, snapGrid: L, snapToGrid: K } = t();
      m = W?.getBoundingClientRect() || null, y = !1, w = !1, x = P.sourceEvent, I === 0 && z(P), s = Yw(P.sourceEvent, { transform: G, snapGrid: L, snapToGrid: K, containerBounds: m }), p = Ts(P.sourceEvent, m);
    }).on("drag", (P) => {
      const { autoPanOnNodeDrag: W, transform: I, snapGrid: G, snapToGrid: L, nodeDragThreshold: K, nodeLookup: q } = t(), Z = Yw(P.sourceEvent, { transform: I, snapGrid: G, snapToGrid: L, containerBounds: m });
      if (x = P.sourceEvent, (P.sourceEvent.type === "touchmove" && P.sourceEvent.touches.length > 1 || // if user deletes a node while dragging, we need to abort the drag to prevent errors
      R && !q.has(R)) && (y = !0), !y) {
        if (!d && W && h && (d = !0, $()), !h) {
          const V = Ts(P.sourceEvent, m), F = V.x - p.x, X = V.y - p.y;
          Math.sqrt(F * F + X * X) > K && z(P);
        }
        (s.x !== Z.xSnapped || s.y !== Z.ySnapped) && c && h && (p = Ts(P.sourceEvent, m), D(Z));
      }
    }).on("end", (P) => {
      if (!(!h || y) && (d = !1, h = !1, cancelAnimationFrame(l), c.size > 0)) {
        const { nodeLookup: W, updateNodePositions: I, onNodeDragStop: G, onSelectionDragStop: L } = t();
        if (w && (I(c, !1), w = !1), a || G || !R && L) {
          const [K, q] = LM({
            nodeId: R,
            dragItems: c,
            nodeLookup: W,
            dragging: !1
          });
          a?.(P.sourceEvent, c, K, q), G?.(P.sourceEvent, K, q), R || L?.(P.sourceEvent, q);
        }
      }
    }).filter((P) => {
      const W = P.target;
      return !P.button && (!C || !s$(W, `.${C}`, O)) && (!_ || s$(W, _, O));
    });
    v.call(B);
  }
  function k() {
    v?.on(".drag", null);
  }
  return {
    update: b,
    destroy: k
  };
}
function vve(e, t, n) {
  const r = [], a = {
    x: e.x - n,
    y: e.y - n,
    width: n * 2,
    height: n * 2
  };
  for (const s of t.values())
    Cx(a, Bh(s)) > 0 && r.push(s);
  return r;
}
const yve = 250;
function bve(e, t, n, r) {
  let a = [], s = 1 / 0;
  const l = vve(e, n, t + yve);
  for (const c of l) {
    const d = [...c.internals.handleBounds?.source ?? [], ...c.internals.handleBounds?.target ?? []];
    for (const p of d) {
      if (r.nodeId === p.nodeId && r.type === p.type && r.id === p.id)
        continue;
      const { x: m, y: h } = hm(c, p, p.position, !0), v = Math.sqrt(Math.pow(m - e.x, 2) + Math.pow(h - e.y, 2));
      v > t || (v < s ? (a = [{ ...p, x: m, y: h }], s = v) : v === s && a.push({ ...p, x: m, y: h }));
    }
  }
  if (!a.length)
    return null;
  if (a.length > 1) {
    const c = r.type === "source" ? "target" : "source";
    return a.find((d) => d.type === c) ?? a[0];
  }
  return a[0];
}
function hU(e, t, n, r, a, s = !1) {
  const l = r.get(e);
  if (!l)
    return null;
  const c = a === "strict" ? l.internals.handleBounds?.[t] : [...l.internals.handleBounds?.source ?? [], ...l.internals.handleBounds?.target ?? []], d = (n ? c?.find((p) => p.id === n) : c?.[0]) ?? null;
  return d && s ? { ...d, ...hm(l, d, d.position, !0) } : d;
}
function gU(e, t) {
  return e || (t?.classList.contains("target") ? "target" : t?.classList.contains("source") ? "source" : null);
}
function wve(e, t) {
  let n = null;
  return t ? n = !0 : e && !t && (n = !1), n;
}
const vU = () => !0;
function xve(e, { connectionMode: t, connectionRadius: n, handleId: r, nodeId: a, edgeUpdaterType: s, isTarget: l, domNode: c, nodeLookup: d, lib: p, autoPanOnConnect: m, flowId: h, panBy: v, cancelConnection: y, onConnectStart: w, onConnect: x, onConnectEnd: b, isValidConnection: k = vU, onReconnectEnd: C, updateConnection: _, getTransform: O, getFromHandle: N, autoPanSpeed: R, dragThreshold: j = 1, handleDomNode: D }) {
  const $ = aU(e.target);
  let z = 0, B;
  const { x: P, y: W } = Ts(e), I = gU(s, D), G = c?.getBoundingClientRect();
  let L = !1;
  if (!G || !I)
    return;
  const K = hU(a, I, r, d, t);
  if (!K)
    return;
  let q = Ts(e, G), Z = !1, V = null, F = !1, X = null;
  function U() {
    if (!m || !G)
      return;
    const [ve, ae] = tU(q, G, R);
    v({ x: ve, y: ae }), z = requestAnimationFrame(U);
  }
  const H = {
    ...K,
    nodeId: a,
    type: I,
    position: K.position
  }, Q = d.get(a);
  let re = {
    inProgress: !0,
    isValid: null,
    from: hm(Q, H, st.Left, !0),
    fromHandle: H,
    fromPosition: H.position,
    fromNode: Q,
    to: q,
    toHandle: null,
    toPosition: X6[H.position],
    toNode: null,
    pointer: q
  };
  function de() {
    L = !0, _(re), w?.(e, { nodeId: a, handleId: r, handleType: I });
  }
  j === 0 && de();
  function le(ve) {
    if (!L) {
      const { x: _e, y: We } = Ts(ve), Xe = _e - P, et = We - W;
      if (!(Xe * Xe + et * et > j * j))
        return;
      de();
    }
    if (!N() || !H) {
      me(ve);
      return;
    }
    const ae = O();
    q = Ts(ve, G), B = bve(wS(q, ae, !1, [1, 1]), n, d, H), Z || (U(), Z = !0);
    const se = yU(ve, {
      handle: B,
      connectionMode: t,
      fromNodeId: a,
      fromHandleId: r,
      fromType: l ? "target" : "source",
      isValidConnection: k,
      doc: $,
      lib: p,
      flowId: h,
      nodeLookup: d
    });
    X = se.handleDomNode, V = se.connection, F = wve(!!B, se.isValid);
    const pe = d.get(a), ge = pe ? hm(pe, H, st.Left, !0) : re.from, xe = {
      ...re,
      from: ge,
      isValid: F,
      to: se.toHandle && F ? k_({ x: se.toHandle.x, y: se.toHandle.y }, ae) : q,
      toHandle: se.toHandle,
      toPosition: F && se.toHandle ? se.toHandle.position : X6[H.position],
      toNode: se.toHandle ? d.get(se.toHandle.nodeId) : null,
      pointer: q
    };
    _(xe), re = xe;
  }
  function me(ve) {
    if (!("touches" in ve && ve.touches.length > 0)) {
      if (L) {
        (B || X) && V && F && x?.(V);
        const { inProgress: ae, ...se } = re, pe = {
          ...se,
          toPosition: re.toHandle ? re.toPosition : null
        };
        b?.(ve, pe), s && C?.(ve, pe);
      }
      y(), cancelAnimationFrame(z), Z = !1, F = !1, V = null, X = null, $.removeEventListener("mousemove", le), $.removeEventListener("mouseup", me), $.removeEventListener("touchmove", le), $.removeEventListener("touchend", me);
    }
  }
  $.addEventListener("mousemove", le), $.addEventListener("mouseup", me), $.addEventListener("touchmove", le), $.addEventListener("touchend", me);
}
function yU(e, { handle: t, connectionMode: n, fromNodeId: r, fromHandleId: a, fromType: s, doc: l, lib: c, flowId: d, isValidConnection: p = vU, nodeLookup: m }) {
  const h = s === "target", v = t ? l.querySelector(`.${c}-flow__handle[data-id="${d}-${t?.nodeId}-${t?.id}-${t?.type}"]`) : null, { x: y, y: w } = Ts(e), x = l.elementFromPoint(y, w), b = x?.classList.contains(`${c}-flow__handle`) ? x : v, k = {
    handleDomNode: b,
    isValid: !1,
    connection: null,
    toHandle: null
  };
  if (b) {
    const C = gU(void 0, b), _ = b.getAttribute("data-nodeid"), O = b.getAttribute("data-handleid"), N = b.classList.contains("connectable"), R = b.classList.contains("connectableend");
    if (!_ || !C)
      return k;
    const j = {
      source: h ? _ : r,
      sourceHandle: h ? O : a,
      target: h ? r : _,
      targetHandle: h ? a : O
    };
    k.connection = j;
    const D = N && R && (n === zh.Strict ? h && C === "source" || !h && C === "target" : _ !== r || O !== a);
    k.isValid = D && p(j), k.toHandle = hU(_, C, O, m, n, !0);
  }
  return k;
}
const H5 = {
  onPointerDown: xve,
  isValid: yU
};
function Sve({ domNode: e, panZoom: t, getTransform: n, getViewScale: r }) {
  const a = gi(e);
  function s({ translateExtent: c, width: d, height: p, zoomStep: m = 1, pannable: h = !0, zoomable: v = !0, inversePan: y = !1 }) {
    const w = (_) => {
      if (_.sourceEvent.type !== "wheel" || !t)
        return;
      const O = n(), N = _.sourceEvent.ctrlKey && Ox() ? 10 : 1, R = -_.sourceEvent.deltaY * (_.sourceEvent.deltaMode === 1 ? 0.05 : _.sourceEvent.deltaMode ? 1 : 2e-3) * m, j = O[2] * Math.pow(2, R * N);
      t.scaleTo(j);
    };
    let x = [0, 0];
    const b = (_) => {
      (_.sourceEvent.type === "mousedown" || _.sourceEvent.type === "touchstart") && (x = [
        _.sourceEvent.clientX ?? _.sourceEvent.touches[0].clientX,
        _.sourceEvent.clientY ?? _.sourceEvent.touches[0].clientY
      ]);
    }, k = (_) => {
      const O = n();
      if (_.sourceEvent.type !== "mousemove" && _.sourceEvent.type !== "touchmove" || !t)
        return;
      const N = [
        _.sourceEvent.clientX ?? _.sourceEvent.touches[0].clientX,
        _.sourceEvent.clientY ?? _.sourceEvent.touches[0].clientY
      ], R = [N[0] - x[0], N[1] - x[1]];
      x = N;
      const j = r() * Math.max(O[2], Math.log(O[2])) * (y ? -1 : 1), D = {
        x: O[0] - R[0] * j,
        y: O[1] - R[1] * j
      }, $ = [
        [0, 0],
        [d, p]
      ];
      t.setViewportConstrained({
        x: D.x,
        y: D.y,
        zoom: O[2]
      }, $, c);
    }, C = GB().on("start", b).on("zoom", h ? k : null).on("zoom.wheel", v ? w : null);
    a.call(C, {});
  }
  function l() {
    a.on("zoom", null);
  }
  return {
    update: s,
    destroy: l,
    pointer: As
  };
}
const W2 = (e) => ({
  x: e.x,
  y: e.y,
  zoom: e.k
}), IM = ({ x: e, y: t, zoom: n }) => V2.translate(e, t).scale(n), fh = (e, t) => e.target.closest(`.${t}`), bU = (e, t) => t === 2 && Array.isArray(e) && e.includes(2), kve = (e) => ((e *= 2) <= 1 ? e * e * e : (e -= 2) * e * e + 2) / 2, zM = (e, t = 0, n = kve, r = () => {
}) => {
  const a = typeof t == "number" && t > 0;
  return a || r(), a ? e.transition().duration(t).ease(n).on("end", r) : e;
}, wU = (e) => {
  const t = e.ctrlKey && Ox() ? 10 : 1;
  return -e.deltaY * (e.deltaMode === 1 ? 0.05 : e.deltaMode ? 1 : 2e-3) * t;
};
function _ve({ zoomPanValues: e, noWheelClassName: t, d3Selection: n, d3Zoom: r, panOnScrollMode: a, panOnScrollSpeed: s, zoomOnPinch: l, onPanZoomStart: c, onPanZoom: d, onPanZoomEnd: p }) {
  return (m) => {
    if (fh(m, t))
      return m.ctrlKey && m.preventDefault(), !1;
    m.preventDefault(), m.stopImmediatePropagation();
    const h = n.property("__zoom").k || 1;
    if (m.ctrlKey && l) {
      const b = As(m), k = wU(m), C = h * Math.pow(2, k);
      r.scaleTo(n, C, b, m);
      return;
    }
    const v = m.deltaMode === 1 ? 20 : 1;
    let y = a === am.Vertical ? 0 : m.deltaX * v, w = a === am.Horizontal ? 0 : m.deltaY * v;
    !Ox() && m.shiftKey && a !== am.Vertical && (y = m.deltaY * v, w = 0), r.translateBy(
      n,
      -(y / h) * s,
      -(w / h) * s,
      // @ts-ignore
      { internal: !0 }
    );
    const x = W2(n.property("__zoom"));
    clearTimeout(e.panScrollTimeout), e.isPanScrolling ? (d?.(m, x), e.panScrollTimeout = setTimeout(() => {
      p?.(m, x), e.isPanScrolling = !1;
    }, 150)) : (e.isPanScrolling = !0, c?.(m, x));
  };
}
function Eve({ noWheelClassName: e, preventScrolling: t, d3ZoomHandler: n }) {
  return function(r, a) {
    const s = r.type === "wheel", l = !t && s && !r.ctrlKey, c = fh(r, e);
    if (r.ctrlKey && s && c && r.preventDefault(), l || c)
      return null;
    r.preventDefault(), n.call(this, r, a);
  };
}
function Cve({ zoomPanValues: e, onDraggingChange: t, onPanZoomStart: n }) {
  return (r) => {
    if (r.sourceEvent?.internal)
      return;
    const a = W2(r.transform);
    e.mouseButton = r.sourceEvent?.button || 0, e.isZoomingOrPanning = !0, e.prevViewport = a, r.sourceEvent?.type === "mousedown" && t(!0), n && n?.(r.sourceEvent, a);
  };
}
function Ove({ zoomPanValues: e, panOnDrag: t, onPaneContextMenu: n, onTransformChange: r, onPanZoom: a }) {
  return (s) => {
    e.usedRightMouseButton = !!(n && bU(t, e.mouseButton ?? 0)), s.sourceEvent?.sync || r([s.transform.x, s.transform.y, s.transform.k]), a && !s.sourceEvent?.internal && a?.(s.sourceEvent, W2(s.transform));
  };
}
function Mve({ zoomPanValues: e, panOnDrag: t, panOnScroll: n, onDraggingChange: r, onPanZoomEnd: a, onPaneContextMenu: s }) {
  return (l) => {
    if (!l.sourceEvent?.internal && (e.isZoomingOrPanning = !1, s && bU(t, e.mouseButton ?? 0) && !e.usedRightMouseButton && l.sourceEvent && s(l.sourceEvent), e.usedRightMouseButton = !1, r(!1), a)) {
      const c = W2(l.transform);
      e.prevViewport = c, clearTimeout(e.timerId), e.timerId = setTimeout(
        () => {
          a?.(l.sourceEvent, c);
        },
        // we need a setTimeout for panOnScroll to supress multiple end events fired during scroll
        n ? 150 : 0
      );
    }
  };
}
function Nve({ zoomActivationKeyPressed: e, zoomOnScroll: t, zoomOnPinch: n, panOnDrag: r, panOnScroll: a, zoomOnDoubleClick: s, userSelectionActive: l, noWheelClassName: c, noPanClassName: d, lib: p, connectionInProgress: m }) {
  return (h) => {
    const v = e || t, y = n && h.ctrlKey, w = h.type === "wheel";
    if (h.button === 1 && h.type === "mousedown" && (fh(h, `${p}-flow__node`) || fh(h, `${p}-flow__edge`)))
      return !0;
    if (!r && !v && !a && !s && !n || l || m && !w || fh(h, c) && w || fh(h, d) && (!w || a && w && !e) || !n && h.ctrlKey && w)
      return !1;
    if (!n && h.type === "touchstart" && h.touches?.length > 1)
      return h.preventDefault(), !1;
    if (!v && !a && !y && w || !r && (h.type === "mousedown" || h.type === "touchstart") || Array.isArray(r) && !r.includes(h.button) && h.type === "mousedown")
      return !1;
    const x = Array.isArray(r) && r.includes(h.button) || !h.button || h.button <= 1;
    return (!h.ctrlKey || w) && x;
  };
}
function Rve({ domNode: e, minZoom: t, maxZoom: n, translateExtent: r, viewport: a, onPanZoom: s, onPanZoomStart: l, onPanZoomEnd: c, onDraggingChange: d }) {
  const p = {
    isZoomingOrPanning: !1,
    usedRightMouseButton: !1,
    prevViewport: {},
    mouseButton: 0,
    timerId: void 0,
    panScrollTimeout: void 0,
    isPanScrolling: !1
  }, m = e.getBoundingClientRect(), h = GB().scaleExtent([t, n]).translateExtent(r), v = gi(e).call(h);
  C({
    x: a.x,
    y: a.y,
    zoom: Fh(a.zoom, t, n)
  }, [
    [0, 0],
    [m.width, m.height]
  ], r);
  const y = v.on("wheel.zoom"), w = v.on("dblclick.zoom");
  h.wheelDelta(wU);
  function x(B, P) {
    return v ? new Promise((W) => {
      h?.interpolate(P?.interpolate === "linear" ? Xw : j0).transform(zM(v, P?.duration, P?.ease, () => W(!0)), B);
    }) : Promise.resolve(!1);
  }
  function b({ noWheelClassName: B, noPanClassName: P, onPaneContextMenu: W, userSelectionActive: I, panOnScroll: G, panOnDrag: L, panOnScrollMode: K, panOnScrollSpeed: q, preventScrolling: Z, zoomOnPinch: V, zoomOnScroll: F, zoomOnDoubleClick: X, zoomActivationKeyPressed: U, lib: H, onTransformChange: Q, connectionInProgress: re, paneClickDistance: de, selectionOnDrag: le }) {
    I && !p.isZoomingOrPanning && k();
    const me = G && !U && !I;
    h.clickDistance(le ? 1 / 0 : !$s(de) || de < 0 ? 0 : de);
    const ve = me ? _ve({
      zoomPanValues: p,
      noWheelClassName: B,
      d3Selection: v,
      d3Zoom: h,
      panOnScrollMode: K,
      panOnScrollSpeed: q,
      zoomOnPinch: V,
      onPanZoomStart: l,
      onPanZoom: s,
      onPanZoomEnd: c
    }) : Eve({
      noWheelClassName: B,
      preventScrolling: Z,
      d3ZoomHandler: y
    });
    if (v.on("wheel.zoom", ve, { passive: !1 }), !I) {
      const se = Cve({
        zoomPanValues: p,
        onDraggingChange: d,
        onPanZoomStart: l
      });
      h.on("start", se);
      const pe = Ove({
        zoomPanValues: p,
        panOnDrag: L,
        onPaneContextMenu: !!W,
        onPanZoom: s,
        onTransformChange: Q
      });
      h.on("zoom", pe);
      const ge = Mve({
        zoomPanValues: p,
        panOnDrag: L,
        panOnScroll: G,
        onPaneContextMenu: W,
        onPanZoomEnd: c,
        onDraggingChange: d
      });
      h.on("end", ge);
    }
    const ae = Nve({
      zoomActivationKeyPressed: U,
      panOnDrag: L,
      zoomOnScroll: F,
      panOnScroll: G,
      zoomOnDoubleClick: X,
      zoomOnPinch: V,
      userSelectionActive: I,
      noPanClassName: P,
      noWheelClassName: B,
      lib: H,
      connectionInProgress: re
    });
    h.filter(ae), X ? v.on("dblclick.zoom", w) : v.on("dblclick.zoom", null);
  }
  function k() {
    h.on("zoom", null);
  }
  async function C(B, P, W) {
    const I = IM(B), G = h?.constrain()(I, P, W);
    return G && await x(G), new Promise((L) => L(G));
  }
  async function _(B, P) {
    const W = IM(B);
    return await x(W, P), new Promise((I) => I(W));
  }
  function O(B) {
    if (v) {
      const P = IM(B), W = v.property("__zoom");
      (W.k !== B.zoom || W.x !== B.x || W.y !== B.y) && h?.transform(v, P, null, { sync: !0 });
    }
  }
  function N() {
    const B = v ? WB(v.node()) : { x: 0, y: 0, k: 1 };
    return { x: B.x, y: B.y, zoom: B.k };
  }
  function R(B, P) {
    return v ? new Promise((W) => {
      h?.interpolate(P?.interpolate === "linear" ? Xw : j0).scaleTo(zM(v, P?.duration, P?.ease, () => W(!0)), B);
    }) : Promise.resolve(!1);
  }
  function j(B, P) {
    return v ? new Promise((W) => {
      h?.interpolate(P?.interpolate === "linear" ? Xw : j0).scaleBy(zM(v, P?.duration, P?.ease, () => W(!0)), B);
    }) : Promise.resolve(!1);
  }
  function D(B) {
    h?.scaleExtent(B);
  }
  function $(B) {
    h?.translateExtent(B);
  }
  function z(B) {
    const P = !$s(B) || B < 0 ? 0 : B;
    h?.clickDistance(P);
  }
  return {
    update: b,
    destroy: k,
    setViewport: _,
    setViewportConstrained: C,
    getViewport: N,
    scaleTo: R,
    scaleBy: j,
    setScaleExtent: D,
    setTranslateExtent: $,
    syncViewport: O,
    setClickDistance: z
  };
}
var Vh;
(function(e) {
  e.Line = "line", e.Handle = "handle";
})(Vh || (Vh = {}));
function Ave({ width: e, prevWidth: t, height: n, prevHeight: r, affectsX: a, affectsY: s }) {
  const l = e - t, c = n - r, d = [l > 0 ? 1 : l < 0 ? -1 : 0, c > 0 ? 1 : c < 0 ? -1 : 0];
  return l && a && (d[0] = d[0] * -1), c && s && (d[1] = d[1] * -1), d;
}
function l$(e) {
  const t = e.includes("right") || e.includes("left"), n = e.includes("bottom") || e.includes("top"), r = e.includes("left"), a = e.includes("top");
  return {
    isHorizontal: t,
    isVertical: n,
    affectsX: r,
    affectsY: a
  };
}
function Ic(e, t) {
  return Math.max(0, t - e);
}
function zc(e, t) {
  return Math.max(0, e - t);
}
function mk(e, t, n) {
  return Math.max(0, t - e, e - n);
}
function u$(e, t) {
  return e ? !t : t;
}
function jve(e, t, n, r, a, s, l, c) {
  let { affectsX: d, affectsY: p } = t;
  const { isHorizontal: m, isVertical: h } = t, v = m && h, { xSnapped: y, ySnapped: w } = n, { minWidth: x, maxWidth: b, minHeight: k, maxHeight: C } = r, { x: _, y: O, width: N, height: R, aspectRatio: j } = e;
  let D = Math.floor(m ? y - e.pointerX : 0), $ = Math.floor(h ? w - e.pointerY : 0);
  const z = N + (d ? -D : D), B = R + (p ? -$ : $), P = -s[0] * N, W = -s[1] * R;
  let I = mk(z, x, b), G = mk(B, k, C);
  if (l) {
    let q = 0, Z = 0;
    d && D < 0 ? q = Ic(_ + D + P, l[0][0]) : !d && D > 0 && (q = zc(_ + z + P, l[1][0])), p && $ < 0 ? Z = Ic(O + $ + W, l[0][1]) : !p && $ > 0 && (Z = zc(O + B + W, l[1][1])), I = Math.max(I, q), G = Math.max(G, Z);
  }
  if (c) {
    let q = 0, Z = 0;
    d && D > 0 ? q = zc(_ + D, c[0][0]) : !d && D < 0 && (q = Ic(_ + z, c[1][0])), p && $ > 0 ? Z = zc(O + $, c[0][1]) : !p && $ < 0 && (Z = Ic(O + B, c[1][1])), I = Math.max(I, q), G = Math.max(G, Z);
  }
  if (a) {
    if (m) {
      const q = mk(z / j, k, C) * j;
      if (I = Math.max(I, q), l) {
        let Z = 0;
        !d && !p || d && !p && v ? Z = zc(O + W + z / j, l[1][1]) * j : Z = Ic(O + W + (d ? D : -D) / j, l[0][1]) * j, I = Math.max(I, Z);
      }
      if (c) {
        let Z = 0;
        !d && !p || d && !p && v ? Z = Ic(O + z / j, c[1][1]) * j : Z = zc(O + (d ? D : -D) / j, c[0][1]) * j, I = Math.max(I, Z);
      }
    }
    if (h) {
      const q = mk(B * j, x, b) / j;
      if (G = Math.max(G, q), l) {
        let Z = 0;
        !d && !p || p && !d && v ? Z = zc(_ + B * j + P, l[1][0]) / j : Z = Ic(_ + (p ? $ : -$) * j + P, l[0][0]) / j, G = Math.max(G, Z);
      }
      if (c) {
        let Z = 0;
        !d && !p || p && !d && v ? Z = Ic(_ + B * j, c[1][0]) / j : Z = zc(_ + (p ? $ : -$) * j, c[0][0]) / j, G = Math.max(G, Z);
      }
    }
  }
  $ = $ + ($ < 0 ? G : -G), D = D + (D < 0 ? I : -I), a && (v ? z > B * j ? $ = (u$(d, p) ? -D : D) / j : D = (u$(d, p) ? -$ : $) * j : m ? ($ = D / j, p = d) : (D = $ * j, d = p));
  const L = d ? _ + D : _, K = p ? O + $ : O;
  return {
    width: N + (d ? -D : D),
    height: R + (p ? -$ : $),
    x: s[0] * D * (d ? -1 : 1) + L,
    y: s[1] * $ * (p ? -1 : 1) + K
  };
}
const xU = { width: 0, height: 0, x: 0, y: 0 }, Pve = {
  ...xU,
  pointerX: 0,
  pointerY: 0,
  aspectRatio: 1
};
function Dve(e) {
  return [
    [0, 0],
    [e.measured.width, e.measured.height]
  ];
}
function $ve(e, t, n) {
  const r = t.position.x + e.position.x, a = t.position.y + e.position.y, s = e.measured.width ?? 0, l = e.measured.height ?? 0, c = n[0] * s, d = n[1] * l;
  return [
    [r - c, a - d],
    [r + s - c, a + l - d]
  ];
}
function Tve({ domNode: e, nodeId: t, getStoreItems: n, onChange: r, onEnd: a }) {
  const s = gi(e);
  let l = {
    controlDirection: l$("bottom-right"),
    boundaries: {
      minWidth: 0,
      minHeight: 0,
      maxWidth: Number.MAX_VALUE,
      maxHeight: Number.MAX_VALUE
    },
    resizeDirection: void 0,
    keepAspectRatio: !1
  };
  function c({ controlPosition: p, boundaries: m, keepAspectRatio: h, resizeDirection: v, onResizeStart: y, onResize: w, onResizeEnd: x, shouldResize: b }) {
    let k = { ...xU }, C = { ...Pve };
    l = {
      boundaries: m,
      resizeDirection: v,
      keepAspectRatio: h,
      controlDirection: l$(p)
    };
    let _, O = null, N = [], R, j, D, $ = !1;
    const z = AB().on("start", (B) => {
      const { nodeLookup: P, transform: W, snapGrid: I, snapToGrid: G, nodeOrigin: L, paneDomNode: K } = n();
      if (_ = P.get(t), !_)
        return;
      O = K?.getBoundingClientRect() ?? null;
      const { xSnapped: q, ySnapped: Z } = Yw(B.sourceEvent, {
        transform: W,
        snapGrid: I,
        snapToGrid: G,
        containerBounds: O
      });
      k = {
        width: _.measured.width ?? 0,
        height: _.measured.height ?? 0,
        x: _.position.x ?? 0,
        y: _.position.y ?? 0
      }, C = {
        ...k,
        pointerX: q,
        pointerY: Z,
        aspectRatio: k.width / k.height
      }, R = void 0, _.parentId && (_.extent === "parent" || _.expandParent) && (R = P.get(_.parentId), j = R && _.extent === "parent" ? Dve(R) : void 0), N = [], D = void 0;
      for (const [V, F] of P)
        if (F.parentId === t && (N.push({
          id: V,
          position: { ...F.position },
          extent: F.extent
        }), F.extent === "parent" || F.expandParent)) {
          const X = $ve(F, _, F.origin ?? L);
          D ? D = [
            [Math.min(X[0][0], D[0][0]), Math.min(X[0][1], D[0][1])],
            [Math.max(X[1][0], D[1][0]), Math.max(X[1][1], D[1][1])]
          ] : D = X;
        }
      y?.(B, { ...k });
    }).on("drag", (B) => {
      const { transform: P, snapGrid: W, snapToGrid: I, nodeOrigin: G } = n(), L = Yw(B.sourceEvent, {
        transform: P,
        snapGrid: W,
        snapToGrid: I,
        containerBounds: O
      }), K = [];
      if (!_)
        return;
      const { x: q, y: Z, width: V, height: F } = k, X = {}, U = _.origin ?? G, { width: H, height: Q, x: re, y: de } = jve(C, l.controlDirection, L, l.boundaries, l.keepAspectRatio, U, j, D), le = H !== V, me = Q !== F, ve = re !== q && le, ae = de !== Z && me;
      if (!ve && !ae && !le && !me)
        return;
      if ((ve || ae || U[0] === 1 || U[1] === 1) && (X.x = ve ? re : k.x, X.y = ae ? de : k.y, k.x = X.x, k.y = X.y, N.length > 0)) {
        const ge = re - q, xe = de - Z;
        for (const _e of N)
          _e.position = {
            x: _e.position.x - ge + U[0] * (H - V),
            y: _e.position.y - xe + U[1] * (Q - F)
          }, K.push(_e);
      }
      if ((le || me) && (X.width = le && (!l.resizeDirection || l.resizeDirection === "horizontal") ? H : k.width, X.height = me && (!l.resizeDirection || l.resizeDirection === "vertical") ? Q : k.height, k.width = X.width, k.height = X.height), R && _.expandParent) {
        const ge = U[0] * (X.width ?? 0);
        X.x && X.x < ge && (k.x = ge, C.x = C.x - (X.x - ge));
        const xe = U[1] * (X.height ?? 0);
        X.y && X.y < xe && (k.y = xe, C.y = C.y - (X.y - xe));
      }
      const se = Ave({
        width: k.width,
        prevWidth: V,
        height: k.height,
        prevHeight: F,
        affectsX: l.controlDirection.affectsX,
        affectsY: l.controlDirection.affectsY
      }), pe = { ...k, direction: se };
      b?.(B, pe) !== !1 && ($ = !0, w?.(B, pe), r(X, K));
    }).on("end", (B) => {
      $ && (x?.(B, { ...k }), a?.({ ...k }), $ = !1);
    });
    s.call(z);
  }
  function d() {
    s.on(".drag", null);
  }
  return {
    update: c,
    destroy: d
  };
}
const { useDebugValue: Lve } = Qn, { useSyncExternalStoreWithSelector: Ive } = z7, zve = (e) => e;
function SU(e, t = zve, n) {
  const r = Ive(
    e.subscribe,
    e.getState,
    e.getServerState || e.getInitialState,
    t,
    n
  );
  return Lve(r), r;
}
const c$ = (e, t) => {
  const n = I7(e), r = (a, s = t) => SU(n, a, s);
  return Object.assign(r, n), r;
}, Fve = (e, t) => e ? c$(e, t) : c$;
function cr(e, t) {
  if (Object.is(e, t))
    return !0;
  if (typeof e != "object" || e === null || typeof t != "object" || t === null)
    return !1;
  if (e instanceof Map && t instanceof Map) {
    if (e.size !== t.size) return !1;
    for (const [r, a] of e)
      if (!Object.is(a, t.get(r)))
        return !1;
    return !0;
  }
  if (e instanceof Set && t instanceof Set) {
    if (e.size !== t.size) return !1;
    for (const r of e)
      if (!t.has(r))
        return !1;
    return !0;
  }
  const n = Object.keys(e);
  if (n.length !== Object.keys(t).length)
    return !1;
  for (const r of n)
    if (!Object.prototype.hasOwnProperty.call(t, r) || !Object.is(e[r], t[r]))
      return !1;
  return !0;
}
const G2 = M.createContext(null), Bve = G2.Provider, kU = Ml.error001();
function un(e, t) {
  const n = M.useContext(G2);
  if (n === null)
    throw new Error(kU);
  return SU(n, e, t);
}
function fr() {
  const e = M.useContext(G2);
  if (e === null)
    throw new Error(kU);
  return M.useMemo(() => ({
    getState: e.getState,
    setState: e.setState,
    subscribe: e.subscribe
  }), [e]);
}
const d$ = { display: "none" }, Uve = {
  position: "absolute",
  width: 1,
  height: 1,
  margin: -1,
  border: 0,
  padding: 0,
  overflow: "hidden",
  clip: "rect(0px, 0px, 0px, 0px)",
  clipPath: "inset(100%)"
}, _U = "react-flow__node-desc", EU = "react-flow__edge-desc", Vve = "react-flow__aria-live", Hve = (e) => e.ariaLiveMessage, qve = (e) => e.ariaLabelConfig;
function Wve({ rfId: e }) {
  const t = un(Hve);
  return E.jsx("div", { id: `${Vve}-${e}`, "aria-live": "assertive", "aria-atomic": "true", style: Uve, children: t });
}
function Gve({ rfId: e, disableKeyboardA11y: t }) {
  const n = un(qve);
  return E.jsxs(E.Fragment, { children: [E.jsx("div", { id: `${_U}-${e}`, style: d$, children: t ? n["node.a11yDescription.default"] : n["node.a11yDescription.keyboardDisabled"] }), E.jsx("div", { id: `${EU}-${e}`, style: d$, children: n["edge.a11yDescription.default"] }), !t && E.jsx(Wve, { rfId: e })] });
}
const K2 = M.forwardRef(({ position: e = "top-left", children: t, className: n, style: r, ...a }, s) => {
  const l = `${e}`.split("-");
  return E.jsx("div", { className: Pr(["react-flow__panel", n, ...l]), style: r, ref: s, ...a, children: t });
});
K2.displayName = "Panel";
function Kve({ proOptions: e, position: t = "bottom-right" }) {
  return e?.hideAttribution ? null : E.jsx(K2, { position: t, className: "react-flow__attribution", "data-message": "Please only hide this attribution when you are subscribed to React Flow Pro: https://pro.reactflow.dev", children: E.jsx("a", { href: "https://reactflow.dev", target: "_blank", rel: "noopener noreferrer", "aria-label": "React Flow attribution", children: "React Flow" }) });
}
const Xve = (e) => {
  const t = [], n = [];
  for (const [, r] of e.nodeLookup)
    r.selected && t.push(r.internals.userNode);
  for (const [, r] of e.edgeLookup)
    r.selected && n.push(r);
  return { selectedNodes: t, selectedEdges: n };
}, hk = (e) => e.id;
function Yve(e, t) {
  return cr(e.selectedNodes.map(hk), t.selectedNodes.map(hk)) && cr(e.selectedEdges.map(hk), t.selectedEdges.map(hk));
}
function Qve({ onSelectionChange: e }) {
  const t = fr(), { selectedNodes: n, selectedEdges: r } = un(Xve, Yve);
  return M.useEffect(() => {
    const a = { nodes: n, edges: r };
    e?.(a), t.getState().onSelectionChangeHandlers.forEach((s) => s(a));
  }, [n, r, e]), null;
}
const Jve = (e) => !!e.onSelectionChangeHandlers;
function Zve({ onSelectionChange: e }) {
  const t = un(Jve);
  return e || t ? E.jsx(Qve, { onSelectionChange: e }) : null;
}
const CU = [0, 0], eye = { x: 0, y: 0, zoom: 1 }, tye = [
  "nodes",
  "edges",
  "defaultNodes",
  "defaultEdges",
  "onConnect",
  "onConnectStart",
  "onConnectEnd",
  "onClickConnectStart",
  "onClickConnectEnd",
  "nodesDraggable",
  "autoPanOnNodeFocus",
  "nodesConnectable",
  "nodesFocusable",
  "edgesFocusable",
  "edgesReconnectable",
  "elevateNodesOnSelect",
  "elevateEdgesOnSelect",
  "minZoom",
  "maxZoom",
  "nodeExtent",
  "onNodesChange",
  "onEdgesChange",
  "elementsSelectable",
  "connectionMode",
  "snapGrid",
  "snapToGrid",
  "translateExtent",
  "connectOnClick",
  "defaultEdgeOptions",
  "fitView",
  "fitViewOptions",
  "onNodesDelete",
  "onEdgesDelete",
  "onDelete",
  "onNodeDrag",
  "onNodeDragStart",
  "onNodeDragStop",
  "onSelectionDrag",
  "onSelectionDragStart",
  "onSelectionDragStop",
  "onMoveStart",
  "onMove",
  "onMoveEnd",
  "noPanClassName",
  "nodeOrigin",
  "autoPanOnConnect",
  "autoPanOnNodeDrag",
  "onError",
  "connectionRadius",
  "isValidConnection",
  "selectNodesOnDrag",
  "nodeDragThreshold",
  "connectionDragThreshold",
  "onBeforeDelete",
  "debug",
  "autoPanSpeed",
  "ariaLabelConfig",
  "zIndexMode"
], f$ = [...tye, "rfId"], nye = (e) => ({
  setNodes: e.setNodes,
  setEdges: e.setEdges,
  setMinZoom: e.setMinZoom,
  setMaxZoom: e.setMaxZoom,
  setTranslateExtent: e.setTranslateExtent,
  setNodeExtent: e.setNodeExtent,
  reset: e.reset,
  setDefaultNodesAndEdges: e.setDefaultNodesAndEdges
}), p$ = {
  /*
   * these are values that are also passed directly to other components
   * than the StoreUpdater. We can reduce the number of setStore calls
   * by setting the same values here as prev fields.
   */
  translateExtent: _x,
  nodeOrigin: CU,
  minZoom: 0.5,
  maxZoom: 2,
  elementsSelectable: !0,
  noPanClassName: "nopan",
  rfId: "1"
};
function rye(e) {
  const { setNodes: t, setEdges: n, setMinZoom: r, setMaxZoom: a, setTranslateExtent: s, setNodeExtent: l, reset: c, setDefaultNodesAndEdges: d } = un(nye, cr), p = fr();
  M.useEffect(() => (d(e.defaultNodes, e.defaultEdges), () => {
    m.current = p$, c();
  }), []);
  const m = M.useRef(p$);
  return M.useEffect(
    () => {
      for (const h of f$) {
        const v = e[h], y = m.current[h];
        v !== y && (typeof e[h] > "u" || (h === "nodes" ? t(v) : h === "edges" ? n(v) : h === "minZoom" ? r(v) : h === "maxZoom" ? a(v) : h === "translateExtent" ? s(v) : h === "nodeExtent" ? l(v) : h === "ariaLabelConfig" ? p.setState({ ariaLabelConfig: Kge(v) }) : h === "fitView" ? p.setState({ fitViewQueued: v }) : h === "fitViewOptions" ? p.setState({ fitViewOptions: v }) : p.setState({ [h]: v })));
      }
      m.current = e;
    },
    // Only re-run the effect if one of the fields we track changes
    f$.map((h) => e[h])
  ), null;
}
function m$() {
  return typeof window > "u" || !window.matchMedia ? null : window.matchMedia("(prefers-color-scheme: dark)");
}
function oye(e) {
  const [t, n] = M.useState(e === "system" ? null : e);
  return M.useEffect(() => {
    if (e !== "system") {
      n(e);
      return;
    }
    const r = m$(), a = () => n(r?.matches ? "dark" : "light");
    return a(), r?.addEventListener("change", a), () => {
      r?.removeEventListener("change", a);
    };
  }, [e]), t !== null ? t : m$()?.matches ? "dark" : "light";
}
const h$ = typeof document < "u" ? document : null;
function fc(e = null, t = { target: h$, actInsideInputWithModifier: !0 }) {
  const [n, r] = M.useState(!1), a = M.useRef(!1), s = M.useRef(/* @__PURE__ */ new Set([])), [l, c] = M.useMemo(() => {
    if (e !== null) {
      const d = (Array.isArray(e) ? e : [e]).filter((m) => typeof m == "string").map((m) => m.replace("+", `
`).replace(`

`, `
+`).split(`
`)), p = d.reduce((m, h) => m.concat(...h), []);
      return [d, p];
    }
    return [[], []];
  }, [e]);
  return M.useEffect(() => {
    const d = t?.target ?? h$, p = t?.actInsideInputWithModifier ?? !0;
    if (e !== null) {
      const m = (y) => {
        if (a.current = y.ctrlKey || y.metaKey || y.shiftKey || y.altKey, (!a.current || a.current && !p) && iU(y))
          return !1;
        const w = v$(y.code, c);
        if (s.current.add(y[w]), g$(l, s.current, !1)) {
          const x = y.composedPath?.()?.[0] || y.target, b = x?.nodeName === "BUTTON" || x?.nodeName === "A";
          t.preventDefault !== !1 && (a.current || !b) && y.preventDefault(), r(!0);
        }
      }, h = (y) => {
        const w = v$(y.code, c);
        g$(l, s.current, !0) ? (r(!1), s.current.clear()) : s.current.delete(y[w]), y.key === "Meta" && s.current.clear(), a.current = !1;
      }, v = () => {
        s.current.clear(), r(!1);
      };
      return d?.addEventListener("keydown", m), d?.addEventListener("keyup", h), window.addEventListener("blur", v), window.addEventListener("contextmenu", v), () => {
        d?.removeEventListener("keydown", m), d?.removeEventListener("keyup", h), window.removeEventListener("blur", v), window.removeEventListener("contextmenu", v);
      };
    }
  }, [e, r]), n;
}
function g$(e, t, n) {
  return e.filter((r) => n || r.length === t.size).some((r) => r.every((a) => t.has(a)));
}
function v$(e, t) {
  return t.includes(e) ? "code" : "key";
}
const aye = () => {
  const e = fr();
  return M.useMemo(() => ({
    zoomIn: (t) => {
      const { panZoom: n } = e.getState();
      return n ? n.scaleBy(1.2, { duration: t?.duration }) : Promise.resolve(!1);
    },
    zoomOut: (t) => {
      const { panZoom: n } = e.getState();
      return n ? n.scaleBy(1 / 1.2, { duration: t?.duration }) : Promise.resolve(!1);
    },
    zoomTo: (t, n) => {
      const { panZoom: r } = e.getState();
      return r ? r.scaleTo(t, { duration: n?.duration }) : Promise.resolve(!1);
    },
    getZoom: () => e.getState().transform[2],
    setViewport: async (t, n) => {
      const { transform: [r, a, s], panZoom: l } = e.getState();
      return l ? (await l.setViewport({
        x: t.x ?? r,
        y: t.y ?? a,
        zoom: t.zoom ?? s
      }, n), Promise.resolve(!0)) : Promise.resolve(!1);
    },
    getViewport: () => {
      const [t, n, r] = e.getState().transform;
      return { x: t, y: n, zoom: r };
    },
    setCenter: async (t, n, r) => e.getState().setCenter(t, n, r),
    fitBounds: async (t, n) => {
      const { width: r, height: a, minZoom: s, maxZoom: l, panZoom: c } = e.getState(), d = cA(t, r, a, s, l, n?.padding ?? 0.1);
      return c ? (await c.setViewport(d, {
        duration: n?.duration,
        ease: n?.ease,
        interpolate: n?.interpolate
      }), Promise.resolve(!0)) : Promise.resolve(!1);
    },
    screenToFlowPosition: (t, n = {}) => {
      const { transform: r, snapGrid: a, snapToGrid: s, domNode: l } = e.getState();
      if (!l)
        return t;
      const { x: c, y: d } = l.getBoundingClientRect(), p = {
        x: t.x - c,
        y: t.y - d
      }, m = n.snapGrid ?? a, h = n.snapToGrid ?? s;
      return wS(p, r, h, m);
    },
    flowToScreenPosition: (t) => {
      const { transform: n, domNode: r } = e.getState();
      if (!r)
        return t;
      const { x: a, y: s } = r.getBoundingClientRect(), l = k_(t, n);
      return {
        x: l.x + a,
        y: l.y + s
      };
    }
  }), []);
};
function OU(e, t) {
  const n = [], r = /* @__PURE__ */ new Map(), a = [];
  for (const s of e)
    if (s.type === "add") {
      a.push(s);
      continue;
    } else if (s.type === "remove" || s.type === "replace")
      r.set(s.id, [s]);
    else {
      const l = r.get(s.id);
      l ? l.push(s) : r.set(s.id, [s]);
    }
  for (const s of t) {
    const l = r.get(s.id);
    if (!l) {
      n.push(s);
      continue;
    }
    if (l[0].type === "remove")
      continue;
    if (l[0].type === "replace") {
      n.push({ ...l[0].item });
      continue;
    }
    const c = { ...s };
    for (const d of l)
      iye(d, c);
    n.push(c);
  }
  return a.length && a.forEach((s) => {
    s.index !== void 0 ? n.splice(s.index, 0, { ...s.item }) : n.push({ ...s.item });
  }), n;
}
function iye(e, t) {
  switch (e.type) {
    case "select": {
      t.selected = e.selected;
      break;
    }
    case "position": {
      typeof e.position < "u" && (t.position = e.position), typeof e.dragging < "u" && (t.dragging = e.dragging);
      break;
    }
    case "dimensions": {
      typeof e.dimensions < "u" && (t.measured = {
        ...e.dimensions
      }, e.setAttributes && ((e.setAttributes === !0 || e.setAttributes === "width") && (t.width = e.dimensions.width), (e.setAttributes === !0 || e.setAttributes === "height") && (t.height = e.dimensions.height))), typeof e.resizing == "boolean" && (t.resizing = e.resizing);
      break;
    }
  }
}
function yA(e, t) {
  return OU(e, t);
}
function MU(e, t) {
  return OU(e, t);
}
function Xp(e, t) {
  return {
    id: e,
    type: "select",
    selected: t
  };
}
function ph(e, t = /* @__PURE__ */ new Set(), n = !1) {
  const r = [];
  for (const [a, s] of e) {
    const l = t.has(a);
    !(s.selected === void 0 && !l) && s.selected !== l && (n && (s.selected = l), r.push(Xp(s.id, l)));
  }
  return r;
}
function y$({ items: e = [], lookup: t }) {
  const n = [], r = new Map(e.map((a) => [a.id, a]));
  for (const [a, s] of e.entries()) {
    const l = t.get(s.id), c = l?.internals?.userNode ?? l;
    c !== void 0 && c !== s && n.push({ id: s.id, item: s, type: "replace" }), c === void 0 && n.push({ item: s, type: "add", index: a });
  }
  for (const [a] of t)
    r.get(a) === void 0 && n.push({ id: a, type: "remove" });
  return n;
}
function b$(e) {
  return {
    id: e.id,
    type: "remove"
  };
}
const w$ = (e) => Ige(e), sye = (e) => JB(e);
function NU(e) {
  return M.forwardRef(e);
}
const lye = typeof window < "u" ? M.useLayoutEffect : M.useEffect;
function x$(e) {
  const [t, n] = M.useState(BigInt(0)), [r] = M.useState(() => uye(() => n((a) => a + BigInt(1))));
  return lye(() => {
    const a = r.get();
    a.length && (e(a), r.reset());
  }, [t]), r;
}
function uye(e) {
  let t = [];
  return {
    get: () => t,
    reset: () => {
      t = [];
    },
    push: (n) => {
      t.push(n), e();
    }
  };
}
const RU = M.createContext(null);
function cye({ children: e }) {
  const t = fr(), n = M.useCallback((c) => {
    const { nodes: d = [], setNodes: p, hasDefaultNodes: m, onNodesChange: h, nodeLookup: v, fitViewQueued: y, onNodesChangeMiddlewareMap: w } = t.getState();
    let x = d;
    for (const k of c)
      x = typeof k == "function" ? k(x) : k;
    let b = y$({
      items: x,
      lookup: v
    });
    for (const k of w.values())
      b = k(b);
    m && p(x), b.length > 0 ? h?.(b) : y && window.requestAnimationFrame(() => {
      const { fitViewQueued: k, nodes: C, setNodes: _ } = t.getState();
      k && _(C);
    });
  }, []), r = x$(n), a = M.useCallback((c) => {
    const { edges: d = [], setEdges: p, hasDefaultEdges: m, onEdgesChange: h, edgeLookup: v } = t.getState();
    let y = d;
    for (const w of c)
      y = typeof w == "function" ? w(y) : w;
    m ? p(y) : h && h(y$({
      items: y,
      lookup: v
    }));
  }, []), s = x$(a), l = M.useMemo(() => ({ nodeQueue: r, edgeQueue: s }), []);
  return E.jsx(RU.Provider, { value: l, children: e });
}
function dye() {
  const e = M.useContext(RU);
  if (!e)
    throw new Error("useBatchContext must be used within a BatchProvider");
  return e;
}
const fye = (e) => !!e.panZoom;
function Sm() {
  const e = aye(), t = fr(), n = dye(), r = un(fye), a = M.useMemo(() => {
    const s = (h) => t.getState().nodeLookup.get(h), l = (h) => {
      n.nodeQueue.push(h);
    }, c = (h) => {
      n.edgeQueue.push(h);
    }, d = (h) => {
      const { nodeLookup: v, nodeOrigin: y } = t.getState(), w = w$(h) ? h : v.get(h.id), x = w.parentId ? oU(w.position, w.measured, w.parentId, v, y) : w.position, b = {
        ...w,
        position: x,
        width: w.measured?.width ?? w.width,
        height: w.measured?.height ?? w.height
      };
      return Bh(b);
    }, p = (h, v, y = { replace: !1 }) => {
      l((w) => w.map((x) => {
        if (x.id === h) {
          const b = typeof v == "function" ? v(x) : v;
          return y.replace && w$(b) ? b : { ...x, ...b };
        }
        return x;
      }));
    }, m = (h, v, y = { replace: !1 }) => {
      c((w) => w.map((x) => {
        if (x.id === h) {
          const b = typeof v == "function" ? v(x) : v;
          return y.replace && sye(b) ? b : { ...x, ...b };
        }
        return x;
      }));
    };
    return {
      getNodes: () => t.getState().nodes.map((h) => ({ ...h })),
      getNode: (h) => s(h)?.internals.userNode,
      getInternalNode: s,
      getEdges: () => {
        const { edges: h = [] } = t.getState();
        return h.map((v) => ({ ...v }));
      },
      getEdge: (h) => t.getState().edgeLookup.get(h),
      setNodes: l,
      setEdges: c,
      addNodes: (h) => {
        const v = Array.isArray(h) ? h : [h];
        n.nodeQueue.push((y) => [...y, ...v]);
      },
      addEdges: (h) => {
        const v = Array.isArray(h) ? h : [h];
        n.edgeQueue.push((y) => [...y, ...v]);
      },
      toObject: () => {
        const { nodes: h = [], edges: v = [], transform: y } = t.getState(), [w, x, b] = y;
        return {
          nodes: h.map((k) => ({ ...k })),
          edges: v.map((k) => ({ ...k })),
          viewport: {
            x: w,
            y: x,
            zoom: b
          }
        };
      },
      deleteElements: async ({ nodes: h = [], edges: v = [] }) => {
        const { nodes: y, edges: w, onNodesDelete: x, onEdgesDelete: b, triggerNodeChanges: k, triggerEdgeChanges: C, onDelete: _, onBeforeDelete: O } = t.getState(), { nodes: N, edges: R } = await Vge({
          nodesToRemove: h,
          edgesToRemove: v,
          nodes: y,
          edges: w,
          onBeforeDelete: O
        }), j = R.length > 0, D = N.length > 0;
        if (j) {
          const $ = R.map(b$);
          b?.(R), C($);
        }
        if (D) {
          const $ = N.map(b$);
          x?.(N), k($);
        }
        return (D || j) && _?.({ nodes: N, edges: R }), { deletedNodes: N, deletedEdges: R };
      },
      /**
       * Partial is defined as "the 2 nodes/areas are intersecting partially".
       * If a is contained in b or b is contained in a, they are both
       * considered fully intersecting.
       */
      getIntersectingNodes: (h, v = !0, y) => {
        const w = Q6(h), x = w ? h : d(h), b = y !== void 0;
        return x ? (y || t.getState().nodes).filter((k) => {
          const C = t.getState().nodeLookup.get(k.id);
          if (C && !w && (k.id === h.id || !C.internals.positionAbsolute))
            return !1;
          const _ = Bh(b ? k : C), O = Cx(_, x);
          return v && O > 0 || O >= _.width * _.height || O >= x.width * x.height;
        }) : [];
      },
      isNodeIntersecting: (h, v, y = !0) => {
        const w = Q6(h) ? h : d(h);
        if (!w)
          return !1;
        const x = Cx(w, v);
        return y && x > 0 || x >= v.width * v.height || x >= w.width * w.height;
      },
      updateNode: p,
      updateNodeData: (h, v, y = { replace: !1 }) => {
        p(h, (w) => {
          const x = typeof v == "function" ? v(w) : v;
          return y.replace ? { ...w, data: x } : { ...w, data: { ...w.data, ...x } };
        }, y);
      },
      updateEdge: m,
      updateEdgeData: (h, v, y = { replace: !1 }) => {
        m(h, (w) => {
          const x = typeof v == "function" ? v(w) : v;
          return y.replace ? { ...w, data: x } : { ...w, data: { ...w.data, ...x } };
        }, y);
      },
      getNodesBounds: (h) => {
        const { nodeLookup: v, nodeOrigin: y } = t.getState();
        return zge(h, { nodeLookup: v, nodeOrigin: y });
      },
      getHandleConnections: ({ type: h, id: v, nodeId: y }) => Array.from(t.getState().connectionLookup.get(`${y}-${h}${v ? `-${v}` : ""}`)?.values() ?? []),
      getNodeConnections: ({ type: h, handleId: v, nodeId: y }) => Array.from(t.getState().connectionLookup.get(`${y}${h ? v ? `-${h}-${v}` : `-${h}` : ""}`)?.values() ?? []),
      fitView: async (h) => {
        const v = t.getState().fitViewResolver ?? Gge();
        return t.setState({ fitViewQueued: !0, fitViewOptions: h, fitViewResolver: v }), n.nodeQueue.push((y) => [...y]), v.promise;
      }
    };
  }, []);
  return M.useMemo(() => ({
    ...a,
    ...e,
    viewportInitialized: r
  }), [r]);
}
const S$ = (e) => e.selected, pye = typeof window < "u" ? window : void 0;
function mye({ deleteKeyCode: e, multiSelectionKeyCode: t }) {
  const n = fr(), { deleteElements: r } = Sm(), a = fc(e, { actInsideInputWithModifier: !1 }), s = fc(t, { target: pye });
  M.useEffect(() => {
    if (a) {
      const { edges: l, nodes: c } = n.getState();
      r({ nodes: c.filter(S$), edges: l.filter(S$) }), n.setState({ nodesSelectionActive: !1 });
    }
  }, [a]), M.useEffect(() => {
    n.setState({ multiSelectionActive: s });
  }, [s]);
}
function hye(e) {
  const t = fr();
  M.useEffect(() => {
    const n = () => {
      if (!e.current || !(e.current.checkVisibility?.() ?? !0))
        return !1;
      const r = dA(e.current);
      (r.height === 0 || r.width === 0) && t.getState().onError?.("004", Ml.error004()), t.setState({ width: r.width || 500, height: r.height || 500 });
    };
    if (e.current) {
      n(), window.addEventListener("resize", n);
      const r = new ResizeObserver(() => n());
      return r.observe(e.current), () => {
        window.removeEventListener("resize", n), r && e.current && r.unobserve(e.current);
      };
    }
  }, []);
}
const X2 = {
  position: "absolute",
  width: "100%",
  height: "100%",
  top: 0,
  left: 0
}, gye = (e) => ({
  userSelectionActive: e.userSelectionActive,
  lib: e.lib,
  connectionInProgress: e.connection.inProgress
});
function vye({ onPaneContextMenu: e, zoomOnScroll: t = !0, zoomOnPinch: n = !0, panOnScroll: r = !1, panOnScrollSpeed: a = 0.5, panOnScrollMode: s = am.Free, zoomOnDoubleClick: l = !0, panOnDrag: c = !0, defaultViewport: d, translateExtent: p, minZoom: m, maxZoom: h, zoomActivationKeyCode: v, preventScrolling: y = !0, children: w, noWheelClassName: x, noPanClassName: b, onViewportChange: k, isControlledViewport: C, paneClickDistance: _, selectionOnDrag: O }) {
  const N = fr(), R = M.useRef(null), { userSelectionActive: j, lib: D, connectionInProgress: $ } = un(gye, cr), z = fc(v), B = M.useRef();
  hye(R);
  const P = M.useCallback((W) => {
    k?.({ x: W[0], y: W[1], zoom: W[2] }), C || N.setState({ transform: W });
  }, [k, C]);
  return M.useEffect(() => {
    if (R.current) {
      B.current = Rve({
        domNode: R.current,
        minZoom: m,
        maxZoom: h,
        translateExtent: p,
        viewport: d,
        onDraggingChange: (L) => N.setState({ paneDragging: L }),
        onPanZoomStart: (L, K) => {
          const { onViewportChangeStart: q, onMoveStart: Z } = N.getState();
          Z?.(L, K), q?.(K);
        },
        onPanZoom: (L, K) => {
          const { onViewportChange: q, onMove: Z } = N.getState();
          Z?.(L, K), q?.(K);
        },
        onPanZoomEnd: (L, K) => {
          const { onViewportChangeEnd: q, onMoveEnd: Z } = N.getState();
          Z?.(L, K), q?.(K);
        }
      });
      const { x: W, y: I, zoom: G } = B.current.getViewport();
      return N.setState({
        panZoom: B.current,
        transform: [W, I, G],
        domNode: R.current.closest(".react-flow")
      }), () => {
        B.current?.destroy();
      };
    }
  }, []), M.useEffect(() => {
    B.current?.update({
      onPaneContextMenu: e,
      zoomOnScroll: t,
      zoomOnPinch: n,
      panOnScroll: r,
      panOnScrollSpeed: a,
      panOnScrollMode: s,
      zoomOnDoubleClick: l,
      panOnDrag: c,
      zoomActivationKeyPressed: z,
      preventScrolling: y,
      noPanClassName: b,
      userSelectionActive: j,
      noWheelClassName: x,
      lib: D,
      onTransformChange: P,
      connectionInProgress: $,
      selectionOnDrag: O,
      paneClickDistance: _
    });
  }, [
    e,
    t,
    n,
    r,
    a,
    s,
    l,
    c,
    z,
    y,
    b,
    j,
    x,
    D,
    P,
    $,
    O,
    _
  ]), E.jsx("div", { className: "react-flow__renderer", ref: R, style: X2, children: w });
}
const yye = (e) => ({
  userSelectionActive: e.userSelectionActive,
  userSelectionRect: e.userSelectionRect
});
function bye() {
  const { userSelectionActive: e, userSelectionRect: t } = un(yye, cr);
  return e && t ? E.jsx("div", { className: "react-flow__selection react-flow__container", style: {
    width: t.width,
    height: t.height,
    transform: `translate(${t.x}px, ${t.y}px)`
  } }) : null;
}
const FM = (e, t) => (n) => {
  n.target === t.current && e?.(n);
}, wye = (e) => ({
  userSelectionActive: e.userSelectionActive,
  elementsSelectable: e.elementsSelectable,
  connectionInProgress: e.connection.inProgress,
  dragging: e.paneDragging
});
function xye({ isSelecting: e, selectionKeyPressed: t, selectionMode: n = Ex.Full, panOnDrag: r, paneClickDistance: a, selectionOnDrag: s, onSelectionStart: l, onSelectionEnd: c, onPaneClick: d, onPaneContextMenu: p, onPaneScroll: m, onPaneMouseEnter: h, onPaneMouseMove: v, onPaneMouseLeave: y, children: w }) {
  const x = fr(), { userSelectionActive: b, elementsSelectable: k, dragging: C, connectionInProgress: _ } = un(wye, cr), O = k && (e || b), N = M.useRef(null), R = M.useRef(), j = M.useRef(/* @__PURE__ */ new Set()), D = M.useRef(/* @__PURE__ */ new Set()), $ = M.useRef(!1), z = (q) => {
    if ($.current || _) {
      $.current = !1;
      return;
    }
    d?.(q), x.getState().resetSelectedElements(), x.setState({ nodesSelectionActive: !1 });
  }, B = (q) => {
    if (Array.isArray(r) && r?.includes(2)) {
      q.preventDefault();
      return;
    }
    p?.(q);
  }, P = m ? (q) => m(q) : void 0, W = (q) => {
    $.current && (q.stopPropagation(), $.current = !1);
  }, I = (q) => {
    const { domNode: Z } = x.getState();
    if (R.current = Z?.getBoundingClientRect(), !R.current)
      return;
    const V = q.target === N.current;
    if (!V && q.target.closest(".nokey") || !e || !(s && V || t) || q.button !== 0 || !q.isPrimary)
      return;
    q.target?.setPointerCapture?.(q.pointerId), $.current = !1;
    const { x: F, y: X } = Ts(q.nativeEvent, R.current);
    x.setState({
      userSelectionRect: {
        width: 0,
        height: 0,
        startX: F,
        startY: X,
        x: F,
        y: X
      }
    }), V || (q.stopPropagation(), q.preventDefault());
  }, G = (q) => {
    const { userSelectionRect: Z, transform: V, nodeLookup: F, edgeLookup: X, connectionLookup: U, triggerNodeChanges: H, triggerEdgeChanges: Q, defaultEdgeOptions: re, resetSelectedElements: de } = x.getState();
    if (!R.current || !Z)
      return;
    const { x: le, y: me } = Ts(q.nativeEvent, R.current), { startX: ve, startY: ae } = Z;
    if (!$.current) {
      const _e = t ? 0 : a;
      if (Math.hypot(le - ve, me - ae) <= _e)
        return;
      de(), l?.(q);
    }
    $.current = !0;
    const se = {
      startX: ve,
      startY: ae,
      x: le < ve ? le : ve,
      y: me < ae ? me : ae,
      width: Math.abs(le - ve),
      height: Math.abs(me - ae)
    }, pe = j.current, ge = D.current;
    j.current = new Set(uA(F, se, V, n === Ex.Partial, !0).map((_e) => _e.id)), D.current = /* @__PURE__ */ new Set();
    const xe = re?.selectable ?? !0;
    for (const _e of j.current) {
      const We = U.get(_e);
      if (We)
        for (const { edgeId: Xe } of We.values()) {
          const et = X.get(Xe);
          et && (et.selectable ?? xe) && D.current.add(Xe);
        }
    }
    if (!J6(pe, j.current)) {
      const _e = ph(F, j.current, !0);
      H(_e);
    }
    if (!J6(ge, D.current)) {
      const _e = ph(X, D.current);
      Q(_e);
    }
    x.setState({
      userSelectionRect: se,
      userSelectionActive: !0,
      nodesSelectionActive: !1
    });
  }, L = (q) => {
    q.button === 0 && (q.target?.releasePointerCapture?.(q.pointerId), !b && q.target === N.current && x.getState().userSelectionRect && z?.(q), x.setState({
      userSelectionActive: !1,
      userSelectionRect: null
    }), $.current && (c?.(q), x.setState({
      nodesSelectionActive: j.current.size > 0
    })));
  }, K = r === !0 || Array.isArray(r) && r.includes(0);
  return E.jsxs("div", { className: Pr(["react-flow__pane", { draggable: K, dragging: C, selection: e }]), onClick: O ? void 0 : FM(z, N), onContextMenu: FM(B, N), onWheel: FM(P, N), onPointerEnter: O ? void 0 : h, onPointerMove: O ? G : v, onPointerUp: O ? L : void 0, onPointerDownCapture: O ? I : void 0, onClickCapture: O ? W : void 0, onPointerLeave: y, ref: N, style: X2, children: [w, E.jsx(bye, {})] });
}
function q5({ id: e, store: t, unselect: n = !1, nodeRef: r }) {
  const { addSelectedNodes: a, unselectNodesAndEdges: s, multiSelectionActive: l, nodeLookup: c, onError: d } = t.getState(), p = c.get(e);
  if (!p) {
    d?.("012", Ml.error012(e));
    return;
  }
  t.setState({ nodesSelectionActive: !1 }), p.selected ? (n || p.selected && l) && (s({ nodes: [p], edges: [] }), requestAnimationFrame(() => r?.current?.blur())) : a([e]);
}
function AU({ nodeRef: e, disabled: t = !1, noDragClassName: n, handleSelector: r, nodeId: a, isSelectable: s, nodeClickDistance: l }) {
  const c = fr(), [d, p] = M.useState(!1), m = M.useRef();
  return M.useEffect(() => {
    m.current = gve({
      getStoreItems: () => c.getState(),
      onNodeMouseDown: (h) => {
        q5({
          id: h,
          store: c,
          nodeRef: e
        });
      },
      onDragStart: () => {
        p(!0);
      },
      onDragStop: () => {
        p(!1);
      }
    });
  }, []), M.useEffect(() => {
    if (t)
      m.current?.destroy();
    else if (e.current)
      return m.current?.update({
        noDragClassName: n,
        handleSelector: r,
        domNode: e.current,
        isSelectable: s,
        nodeId: a,
        nodeClickDistance: l
      }), () => {
        m.current?.destroy();
      };
  }, [n, r, t, s, e, a]), d;
}
const Sye = (e) => (t) => t.selected && (t.draggable || e && typeof t.draggable > "u");
function jU() {
  const e = fr();
  return M.useCallback((t) => {
    const { nodeExtent: n, snapToGrid: r, snapGrid: a, nodesDraggable: s, onError: l, updateNodePositions: c, nodeLookup: d, nodeOrigin: p } = e.getState(), m = /* @__PURE__ */ new Map(), h = Sye(s), v = r ? a[0] : 5, y = r ? a[1] : 5, w = t.direction.x * v * t.factor, x = t.direction.y * y * t.factor;
    for (const [, b] of d) {
      if (!h(b))
        continue;
      let k = {
        x: b.internals.positionAbsolute.x + w,
        y: b.internals.positionAbsolute.y + x
      };
      r && (k = bS(k, a));
      const { position: C, positionAbsolute: _ } = ZB({
        nodeId: b.id,
        nextPosition: k,
        nodeLookup: d,
        nodeExtent: n,
        nodeOrigin: p,
        onError: l
      });
      b.position = C, b.internals.positionAbsolute = _, m.set(b.id, b);
    }
    c(m);
  }, []);
}
const bA = M.createContext(null), kye = bA.Provider;
bA.Consumer;
const PU = () => M.useContext(bA), _ye = (e) => ({
  connectOnClick: e.connectOnClick,
  noPanClassName: e.noPanClassName,
  rfId: e.rfId
}), Eye = (e, t, n) => (r) => {
  const { connectionClickStartHandle: a, connectionMode: s, connection: l } = r, { fromHandle: c, toHandle: d, isValid: p } = l, m = d?.nodeId === e && d?.id === t && d?.type === n;
  return {
    connectingFrom: c?.nodeId === e && c?.id === t && c?.type === n,
    connectingTo: m,
    clickConnecting: a?.nodeId === e && a?.id === t && a?.type === n,
    isPossibleEndHandle: s === zh.Strict ? c?.type !== n : e !== c?.nodeId || t !== c?.id,
    connectionInProcess: !!c,
    clickConnectionInProcess: !!a,
    valid: m && p
  };
};
function Cye({ type: e = "source", position: t = st.Top, isValidConnection: n, isConnectable: r = !0, isConnectableStart: a = !0, isConnectableEnd: s = !0, id: l, onConnect: c, children: d, className: p, onMouseDown: m, onTouchStart: h, ...v }, y) {
  const w = l || null, x = e === "target", b = fr(), k = PU(), { connectOnClick: C, noPanClassName: _, rfId: O } = un(_ye, cr), { connectingFrom: N, connectingTo: R, clickConnecting: j, isPossibleEndHandle: D, connectionInProcess: $, clickConnectionInProcess: z, valid: B } = un(Eye(k, w, e), cr);
  k || b.getState().onError?.("010", Ml.error010());
  const P = (G) => {
    const { defaultEdgeOptions: L, onConnect: K, hasDefaultEdges: q } = b.getState(), Z = {
      ...L,
      ...G
    };
    if (q) {
      const { edges: V, setEdges: F } = b.getState();
      F(eve(Z, V));
    }
    K?.(Z), c?.(Z);
  }, W = (G) => {
    if (!k)
      return;
    const L = sU(G.nativeEvent);
    if (a && (L && G.button === 0 || !L)) {
      const K = b.getState();
      H5.onPointerDown(G.nativeEvent, {
        handleDomNode: G.currentTarget,
        autoPanOnConnect: K.autoPanOnConnect,
        connectionMode: K.connectionMode,
        connectionRadius: K.connectionRadius,
        domNode: K.domNode,
        nodeLookup: K.nodeLookup,
        lib: K.lib,
        isTarget: x,
        handleId: w,
        nodeId: k,
        flowId: K.rfId,
        panBy: K.panBy,
        cancelConnection: K.cancelConnection,
        onConnectStart: K.onConnectStart,
        onConnectEnd: K.onConnectEnd,
        updateConnection: K.updateConnection,
        onConnect: P,
        isValidConnection: n || K.isValidConnection,
        getTransform: () => b.getState().transform,
        getFromHandle: () => b.getState().connection.fromHandle,
        autoPanSpeed: K.autoPanSpeed,
        dragThreshold: K.connectionDragThreshold
      });
    }
    L ? m?.(G) : h?.(G);
  }, I = (G) => {
    const { onClickConnectStart: L, onClickConnectEnd: K, connectionClickStartHandle: q, connectionMode: Z, isValidConnection: V, lib: F, rfId: X, nodeLookup: U, connection: H } = b.getState();
    if (!k || !q && !a)
      return;
    if (!q) {
      L?.(G.nativeEvent, { nodeId: k, handleId: w, handleType: e }), b.setState({ connectionClickStartHandle: { nodeId: k, type: e, id: w } });
      return;
    }
    const Q = aU(G.target), re = n || V, { connection: de, isValid: le } = H5.isValid(G.nativeEvent, {
      handle: {
        nodeId: k,
        id: w,
        type: e
      },
      connectionMode: Z,
      fromNodeId: q.nodeId,
      fromHandleId: q.id || null,
      fromType: q.type,
      isValidConnection: re,
      flowId: X,
      doc: Q,
      lib: F,
      nodeLookup: U
    });
    le && de && P(de);
    const me = structuredClone(H);
    delete me.inProgress, me.toPosition = me.toHandle ? me.toHandle.position : null, K?.(G, me), b.setState({ connectionClickStartHandle: null });
  };
  return E.jsx("div", { "data-handleid": w, "data-nodeid": k, "data-handlepos": t, "data-id": `${O}-${k}-${w}-${e}`, className: Pr([
    "react-flow__handle",
    `react-flow__handle-${t}`,
    "nodrag",
    _,
    p,
    {
      source: !x,
      target: x,
      connectable: r,
      connectablestart: a,
      connectableend: s,
      clickconnecting: j,
      connectingfrom: N,
      connectingto: R,
      valid: B,
      /*
       * shows where you can start a connection from
       * and where you can end it while connecting
       */
      connectionindicator: r && (!$ || D) && ($ || z ? s : a)
    }
  ]), onMouseDown: W, onTouchStart: W, onClick: C ? I : void 0, ref: y, ...v, children: d });
}
const Mx = M.memo(NU(Cye));
function Oye({ data: e, isConnectable: t, sourcePosition: n = st.Bottom }) {
  return E.jsxs(E.Fragment, { children: [e?.label, E.jsx(Mx, { type: "source", position: n, isConnectable: t })] });
}
function Mye({ data: e, isConnectable: t, targetPosition: n = st.Top, sourcePosition: r = st.Bottom }) {
  return E.jsxs(E.Fragment, { children: [E.jsx(Mx, { type: "target", position: n, isConnectable: t }), e?.label, E.jsx(Mx, { type: "source", position: r, isConnectable: t })] });
}
function Nye() {
  return null;
}
function Rye({ data: e, isConnectable: t, targetPosition: n = st.Top }) {
  return E.jsxs(E.Fragment, { children: [E.jsx(Mx, { type: "target", position: n, isConnectable: t }), e?.label] });
}
const __ = {
  ArrowUp: { x: 0, y: -1 },
  ArrowDown: { x: 0, y: 1 },
  ArrowLeft: { x: -1, y: 0 },
  ArrowRight: { x: 1, y: 0 }
}, k$ = {
  input: Oye,
  default: Mye,
  output: Rye,
  group: Nye
};
function Aye(e) {
  return e.internals.handleBounds === void 0 ? {
    width: e.width ?? e.initialWidth ?? e.style?.width,
    height: e.height ?? e.initialHeight ?? e.style?.height
  } : {
    width: e.width ?? e.style?.width,
    height: e.height ?? e.style?.height
  };
}
const jye = (e) => {
  const { width: t, height: n, x: r, y: a } = yS(e.nodeLookup, {
    filter: (s) => !!s.selected
  });
  return {
    width: $s(t) ? t : null,
    height: $s(n) ? n : null,
    userSelectionActive: e.userSelectionActive,
    transformString: `translate(${e.transform[0]}px,${e.transform[1]}px) scale(${e.transform[2]}) translate(${r}px,${a}px)`
  };
};
function Pye({ onSelectionContextMenu: e, noPanClassName: t, disableKeyboardA11y: n }) {
  const r = fr(), { width: a, height: s, transformString: l, userSelectionActive: c } = un(jye, cr), d = jU(), p = M.useRef(null);
  if (M.useEffect(() => {
    n || p.current?.focus({
      preventScroll: !0
    });
  }, [n]), AU({
    nodeRef: p
  }), c || !a || !s)
    return null;
  const m = e ? (v) => {
    const y = r.getState().nodes.filter((w) => w.selected);
    e(v, y);
  } : void 0, h = (v) => {
    Object.prototype.hasOwnProperty.call(__, v.key) && (v.preventDefault(), d({
      direction: __[v.key],
      factor: v.shiftKey ? 4 : 1
    }));
  };
  return E.jsx("div", { className: Pr(["react-flow__nodesselection", "react-flow__container", t]), style: {
    transform: l
  }, children: E.jsx("div", { ref: p, className: "react-flow__nodesselection-rect", onContextMenu: m, tabIndex: n ? void 0 : -1, onKeyDown: n ? void 0 : h, style: {
    width: a,
    height: s
  } }) });
}
const _$ = typeof window < "u" ? window : void 0, Dye = (e) => ({ nodesSelectionActive: e.nodesSelectionActive, userSelectionActive: e.userSelectionActive });
function DU({ children: e, onPaneClick: t, onPaneMouseEnter: n, onPaneMouseMove: r, onPaneMouseLeave: a, onPaneContextMenu: s, onPaneScroll: l, paneClickDistance: c, deleteKeyCode: d, selectionKeyCode: p, selectionOnDrag: m, selectionMode: h, onSelectionStart: v, onSelectionEnd: y, multiSelectionKeyCode: w, panActivationKeyCode: x, zoomActivationKeyCode: b, elementsSelectable: k, zoomOnScroll: C, zoomOnPinch: _, panOnScroll: O, panOnScrollSpeed: N, panOnScrollMode: R, zoomOnDoubleClick: j, panOnDrag: D, defaultViewport: $, translateExtent: z, minZoom: B, maxZoom: P, preventScrolling: W, onSelectionContextMenu: I, noWheelClassName: G, noPanClassName: L, disableKeyboardA11y: K, onViewportChange: q, isControlledViewport: Z }) {
  const { nodesSelectionActive: V, userSelectionActive: F } = un(Dye, cr), X = fc(p, { target: _$ }), U = fc(x, { target: _$ }), H = U || D, Q = U || O, re = m && H !== !0, de = X || F || re;
  return mye({ deleteKeyCode: d, multiSelectionKeyCode: w }), E.jsx(vye, { onPaneContextMenu: s, elementsSelectable: k, zoomOnScroll: C, zoomOnPinch: _, panOnScroll: Q, panOnScrollSpeed: N, panOnScrollMode: R, zoomOnDoubleClick: j, panOnDrag: !X && H, defaultViewport: $, translateExtent: z, minZoom: B, maxZoom: P, zoomActivationKeyCode: b, preventScrolling: W, noWheelClassName: G, noPanClassName: L, onViewportChange: q, isControlledViewport: Z, paneClickDistance: c, selectionOnDrag: re, children: E.jsxs(xye, { onSelectionStart: v, onSelectionEnd: y, onPaneClick: t, onPaneMouseEnter: n, onPaneMouseMove: r, onPaneMouseLeave: a, onPaneContextMenu: s, onPaneScroll: l, panOnDrag: H, isSelecting: !!de, selectionMode: h, selectionKeyPressed: X, paneClickDistance: c, selectionOnDrag: re, children: [e, V && E.jsx(Pye, { onSelectionContextMenu: I, noPanClassName: L, disableKeyboardA11y: K })] }) });
}
DU.displayName = "FlowRenderer";
const $ye = M.memo(DU), Tye = (e) => (t) => e ? uA(t.nodeLookup, { x: 0, y: 0, width: t.width, height: t.height }, t.transform, !0).map((n) => n.id) : Array.from(t.nodeLookup.keys());
function Lye(e) {
  return un(M.useCallback(Tye(e), [e]), cr);
}
const Iye = (e) => e.updateNodeInternals;
function zye() {
  const e = un(Iye), [t] = M.useState(() => typeof ResizeObserver > "u" ? null : new ResizeObserver((n) => {
    const r = /* @__PURE__ */ new Map();
    n.forEach((a) => {
      const s = a.target.getAttribute("data-id");
      r.set(s, {
        id: s,
        nodeElement: a.target,
        force: !0
      });
    }), e(r);
  }));
  return M.useEffect(() => () => {
    t?.disconnect();
  }, [t]), t;
}
function Fye({ node: e, nodeType: t, hasDimensions: n, resizeObserver: r }) {
  const a = fr(), s = M.useRef(null), l = M.useRef(null), c = M.useRef(e.sourcePosition), d = M.useRef(e.targetPosition), p = M.useRef(t), m = n && !!e.internals.handleBounds;
  return M.useEffect(() => {
    s.current && !e.hidden && (!m || l.current !== s.current) && (l.current && r?.unobserve(l.current), r?.observe(s.current), l.current = s.current);
  }, [m, e.hidden]), M.useEffect(() => () => {
    l.current && (r?.unobserve(l.current), l.current = null);
  }, []), M.useEffect(() => {
    if (s.current) {
      const h = p.current !== t, v = c.current !== e.sourcePosition, y = d.current !== e.targetPosition;
      (h || v || y) && (p.current = t, c.current = e.sourcePosition, d.current = e.targetPosition, a.getState().updateNodeInternals(/* @__PURE__ */ new Map([[e.id, { id: e.id, nodeElement: s.current, force: !0 }]])));
    }
  }, [e.id, t, e.sourcePosition, e.targetPosition]), s;
}
function Bye({ id: e, onClick: t, onMouseEnter: n, onMouseMove: r, onMouseLeave: a, onContextMenu: s, onDoubleClick: l, nodesDraggable: c, elementsSelectable: d, nodesConnectable: p, nodesFocusable: m, resizeObserver: h, noDragClassName: v, noPanClassName: y, disableKeyboardA11y: w, rfId: x, nodeTypes: b, nodeClickDistance: k, onError: C }) {
  const { node: _, internals: O, isParent: N } = un((le) => {
    const me = le.nodeLookup.get(e), ve = le.parentLookup.has(e);
    return {
      node: me,
      internals: me.internals,
      isParent: ve
    };
  }, cr);
  let R = _.type || "default", j = b?.[R] || k$[R];
  j === void 0 && (C?.("003", Ml.error003(R)), R = "default", j = b?.default || k$.default);
  const D = !!(_.draggable || c && typeof _.draggable > "u"), $ = !!(_.selectable || d && typeof _.selectable > "u"), z = !!(_.connectable || p && typeof _.connectable > "u"), B = !!(_.focusable || m && typeof _.focusable > "u"), P = fr(), W = rU(_), I = Fye({ node: _, nodeType: R, hasDimensions: W, resizeObserver: h }), G = AU({
    nodeRef: I,
    disabled: _.hidden || !D,
    noDragClassName: v,
    handleSelector: _.dragHandle,
    nodeId: e,
    isSelectable: $,
    nodeClickDistance: k
  }), L = jU();
  if (_.hidden)
    return null;
  const K = Ac(_), q = Aye(_), Z = $ || D || t || n || r || a, V = n ? (le) => n(le, { ...O.userNode }) : void 0, F = r ? (le) => r(le, { ...O.userNode }) : void 0, X = a ? (le) => a(le, { ...O.userNode }) : void 0, U = s ? (le) => s(le, { ...O.userNode }) : void 0, H = l ? (le) => l(le, { ...O.userNode }) : void 0, Q = (le) => {
    const { selectNodesOnDrag: me, nodeDragThreshold: ve } = P.getState();
    $ && (!me || !D || ve > 0) && q5({
      id: e,
      store: P,
      nodeRef: I
    }), t && t(le, { ...O.userNode });
  }, re = (le) => {
    if (!(iU(le.nativeEvent) || w)) {
      if (KB.includes(le.key) && $) {
        const me = le.key === "Escape";
        q5({
          id: e,
          store: P,
          unselect: me,
          nodeRef: I
        });
      } else if (D && _.selected && Object.prototype.hasOwnProperty.call(__, le.key)) {
        le.preventDefault();
        const { ariaLabelConfig: me } = P.getState();
        P.setState({
          ariaLiveMessage: me["node.a11yDescription.ariaLiveMessage"]({
            direction: le.key.replace("Arrow", "").toLowerCase(),
            x: ~~O.positionAbsolute.x,
            y: ~~O.positionAbsolute.y
          })
        }), L({
          direction: __[le.key],
          factor: le.shiftKey ? 4 : 1
        });
      }
    }
  }, de = () => {
    if (w || !I.current?.matches(":focus-visible"))
      return;
    const { transform: le, width: me, height: ve, autoPanOnNodeFocus: ae, setCenter: se } = P.getState();
    ae && (uA(/* @__PURE__ */ new Map([[e, _]]), { x: 0, y: 0, width: me, height: ve }, le, !0).length > 0 || se(_.position.x + K.width / 2, _.position.y + K.height / 2, {
      zoom: le[2]
    }));
  };
  return E.jsx("div", { className: Pr([
    "react-flow__node",
    `react-flow__node-${R}`,
    {
      // this is overwritable by passing `nopan` as a class name
      [y]: D
    },
    _.className,
    {
      selected: _.selected,
      selectable: $,
      parent: N,
      draggable: D,
      dragging: G
    }
  ]), ref: I, style: {
    zIndex: O.z,
    transform: `translate(${O.positionAbsolute.x}px,${O.positionAbsolute.y}px)`,
    pointerEvents: Z ? "all" : "none",
    visibility: W ? "visible" : "hidden",
    ..._.style,
    ...q
  }, "data-id": e, "data-testid": `rf__node-${e}`, onMouseEnter: V, onMouseMove: F, onMouseLeave: X, onContextMenu: U, onClick: Q, onDoubleClick: H, onKeyDown: B ? re : void 0, tabIndex: B ? 0 : void 0, onFocus: B ? de : void 0, role: _.ariaRole ?? (B ? "group" : void 0), "aria-roledescription": "node", "aria-describedby": w ? void 0 : `${_U}-${x}`, "aria-label": _.ariaLabel, ..._.domAttributes, children: E.jsx(kye, { value: e, children: E.jsx(j, { id: e, data: _.data, type: R, positionAbsoluteX: O.positionAbsolute.x, positionAbsoluteY: O.positionAbsolute.y, selected: _.selected ?? !1, selectable: $, draggable: D, deletable: _.deletable ?? !0, isConnectable: z, sourcePosition: _.sourcePosition, targetPosition: _.targetPosition, dragging: G, dragHandle: _.dragHandle, zIndex: O.z, parentId: _.parentId, ...K }) }) });
}
var Uye = M.memo(Bye);
const Vye = (e) => ({
  nodesDraggable: e.nodesDraggable,
  nodesConnectable: e.nodesConnectable,
  nodesFocusable: e.nodesFocusable,
  elementsSelectable: e.elementsSelectable,
  onError: e.onError
});
function $U(e) {
  const { nodesDraggable: t, nodesConnectable: n, nodesFocusable: r, elementsSelectable: a, onError: s } = un(Vye, cr), l = Lye(e.onlyRenderVisibleElements), c = zye();
  return E.jsx("div", { className: "react-flow__nodes", style: X2, children: l.map((d) => (
    /*
     * The split of responsibilities between NodeRenderer and
     * NodeComponentWrapper may appear weird. However, its designed to
     * minimize the cost of updates when individual nodes change.
     *
     * For example, when youre dragging a single node, that node gets
     * updated multiple times per second. If `NodeRenderer` were to update
     * every time, it would have to re-run the `nodes.map()` loop every
     * time. This gets pricey with hundreds of nodes, especially if every
     * loop cycle does more than just rendering a JSX element!
     *
     * As a result of this choice, we took the following implementation
     * decisions:
     * - NodeRenderer subscribes *only* to node IDs  and therefore
     *   rerender *only* when visible nodes are added or removed.
     * - NodeRenderer performs all operations the result of which can be
     *   shared between nodes (such as creating the `ResizeObserver`
     *   instance, or subscribing to `selector`). This means extra prop
     *   drilling into `NodeComponentWrapper`, but it means we need to run
     *   these operations only once  instead of once per node.
     * - Any operations that youd normally write inside `nodes.map` are
     *   moved into `NodeComponentWrapper`. This ensures they are
     *   memorized  so if `NodeRenderer` *has* to rerender, it only
     *   needs to regenerate the list of nodes, nothing else.
     */
    E.jsx(Uye, { id: d, nodeTypes: e.nodeTypes, nodeExtent: e.nodeExtent, onClick: e.onNodeClick, onMouseEnter: e.onNodeMouseEnter, onMouseMove: e.onNodeMouseMove, onMouseLeave: e.onNodeMouseLeave, onContextMenu: e.onNodeContextMenu, onDoubleClick: e.onNodeDoubleClick, noDragClassName: e.noDragClassName, noPanClassName: e.noPanClassName, rfId: e.rfId, disableKeyboardA11y: e.disableKeyboardA11y, resizeObserver: c, nodesDraggable: t, nodesConnectable: n, nodesFocusable: r, elementsSelectable: a, nodeClickDistance: e.nodeClickDistance, onError: s }, d)
  )) });
}
$U.displayName = "NodeRenderer";
const Hye = M.memo($U);
function qye(e) {
  return un(M.useCallback((t) => {
    if (!e)
      return t.edges.map((r) => r.id);
    const n = [];
    if (t.width && t.height)
      for (const r of t.edges) {
        const a = t.nodeLookup.get(r.source), s = t.nodeLookup.get(r.target);
        a && s && Qge({
          sourceNode: a,
          targetNode: s,
          width: t.width,
          height: t.height,
          transform: t.transform
        }) && n.push(r.id);
      }
    return n;
  }, [e]), cr);
}
const Wye = ({ color: e = "none", strokeWidth: t = 1 }) => {
  const n = {
    strokeWidth: t,
    ...e && { stroke: e }
  };
  return E.jsx("polyline", { className: "arrow", style: n, strokeLinecap: "round", fill: "none", strokeLinejoin: "round", points: "-5,-4 0,0 -5,4" });
}, Gye = ({ color: e = "none", strokeWidth: t = 1 }) => {
  const n = {
    strokeWidth: t,
    ...e && { stroke: e, fill: e }
  };
  return E.jsx("polyline", { className: "arrowclosed", style: n, strokeLinecap: "round", strokeLinejoin: "round", points: "-5,-4 0,0 -5,4 -5,-4" });
}, E$ = {
  [x_.Arrow]: Wye,
  [x_.ArrowClosed]: Gye
};
function Kye(e) {
  const t = fr();
  return M.useMemo(() => Object.prototype.hasOwnProperty.call(E$, e) ? E$[e] : (t.getState().onError?.("009", Ml.error009(e)), null), [e]);
}
const Xye = ({ id: e, type: t, color: n, width: r = 12.5, height: a = 12.5, markerUnits: s = "strokeWidth", strokeWidth: l, orient: c = "auto-start-reverse" }) => {
  const d = Kye(t);
  return d ? E.jsx("marker", { className: "react-flow__arrowhead", id: e, markerWidth: `${r}`, markerHeight: `${a}`, viewBox: "-10 -10 20 20", markerUnits: s, orient: c, refX: "0", refY: "0", children: E.jsx(d, { color: n, strokeWidth: l }) }) : null;
}, TU = ({ defaultColor: e, rfId: t }) => {
  const n = un((s) => s.edges), r = un((s) => s.defaultEdgeOptions), a = M.useMemo(() => ave(n, {
    id: t,
    defaultColor: e,
    defaultMarkerStart: r?.markerStart,
    defaultMarkerEnd: r?.markerEnd
  }), [n, r, t, e]);
  return a.length ? E.jsx("svg", { className: "react-flow__marker", "aria-hidden": "true", children: E.jsx("defs", { children: a.map((s) => E.jsx(Xye, { id: s.id, type: s.type, color: s.color, width: s.width, height: s.height, markerUnits: s.markerUnits, strokeWidth: s.strokeWidth, orient: s.orient }, s.id)) }) }) : null;
};
TU.displayName = "MarkerDefinitions";
var Yye = M.memo(TU);
function LU({ x: e, y: t, label: n, labelStyle: r, labelShowBg: a = !0, labelBgStyle: s, labelBgPadding: l = [2, 4], labelBgBorderRadius: c = 2, children: d, className: p, ...m }) {
  const [h, v] = M.useState({ x: 1, y: 0, width: 0, height: 0 }), y = Pr(["react-flow__edge-textwrapper", p]), w = M.useRef(null);
  return M.useEffect(() => {
    if (w.current) {
      const x = w.current.getBBox();
      v({
        x: x.x,
        y: x.y,
        width: x.width,
        height: x.height
      });
    }
  }, [n]), n ? E.jsxs("g", { transform: `translate(${e - h.width / 2} ${t - h.height / 2})`, className: y, visibility: h.width ? "visible" : "hidden", ...m, children: [a && E.jsx("rect", { width: h.width + 2 * l[0], x: -l[0], y: -l[1], height: h.height + 2 * l[1], className: "react-flow__edge-textbg", style: s, rx: c, ry: c }), E.jsx("text", { className: "react-flow__edge-text", y: h.height / 2, dy: "0.3em", ref: w, style: r, children: n }), d] }) : null;
}
LU.displayName = "EdgeText";
const Qye = M.memo(LU);
function xS({ path: e, labelX: t, labelY: n, label: r, labelStyle: a, labelShowBg: s, labelBgStyle: l, labelBgPadding: c, labelBgBorderRadius: d, interactionWidth: p = 20, ...m }) {
  return E.jsxs(E.Fragment, { children: [E.jsx("path", { ...m, d: e, fill: "none", className: Pr(["react-flow__edge-path", m.className]) }), p ? E.jsx("path", { d: e, fill: "none", strokeOpacity: 0, strokeWidth: p, className: "react-flow__edge-interaction" }) : null, r && $s(t) && $s(n) ? E.jsx(Qye, { x: t, y: n, label: r, labelStyle: a, labelShowBg: s, labelBgStyle: l, labelBgPadding: c, labelBgBorderRadius: d }) : null] });
}
function C$({ pos: e, x1: t, y1: n, x2: r, y2: a }) {
  return e === st.Left || e === st.Right ? [0.5 * (t + r), n] : [t, 0.5 * (n + a)];
}
function IU({ sourceX: e, sourceY: t, sourcePosition: n = st.Bottom, targetX: r, targetY: a, targetPosition: s = st.Top }) {
  const [l, c] = C$({
    pos: n,
    x1: e,
    y1: t,
    x2: r,
    y2: a
  }), [d, p] = C$({
    pos: s,
    x1: r,
    y1: a,
    x2: e,
    y2: t
  }), [m, h, v, y] = lU({
    sourceX: e,
    sourceY: t,
    targetX: r,
    targetY: a,
    sourceControlX: l,
    sourceControlY: c,
    targetControlX: d,
    targetControlY: p
  });
  return [
    `M${e},${t} C${l},${c} ${d},${p} ${r},${a}`,
    m,
    h,
    v,
    y
  ];
}
function zU(e) {
  return M.memo(({ id: t, sourceX: n, sourceY: r, targetX: a, targetY: s, sourcePosition: l, targetPosition: c, label: d, labelStyle: p, labelShowBg: m, labelBgStyle: h, labelBgPadding: v, labelBgBorderRadius: y, style: w, markerEnd: x, markerStart: b, interactionWidth: k }) => {
    const [C, _, O] = IU({
      sourceX: n,
      sourceY: r,
      sourcePosition: l,
      targetX: a,
      targetY: s,
      targetPosition: c
    }), N = e.isInternal ? void 0 : t;
    return E.jsx(xS, { id: N, path: C, labelX: _, labelY: O, label: d, labelStyle: p, labelShowBg: m, labelBgStyle: h, labelBgPadding: v, labelBgBorderRadius: y, style: w, markerEnd: x, markerStart: b, interactionWidth: k });
  });
}
const Jye = zU({ isInternal: !1 }), FU = zU({ isInternal: !0 });
Jye.displayName = "SimpleBezierEdge";
FU.displayName = "SimpleBezierEdgeInternal";
function BU(e) {
  return M.memo(({ id: t, sourceX: n, sourceY: r, targetX: a, targetY: s, label: l, labelStyle: c, labelShowBg: d, labelBgStyle: p, labelBgPadding: m, labelBgBorderRadius: h, style: v, sourcePosition: y = st.Bottom, targetPosition: w = st.Top, markerEnd: x, markerStart: b, pathOptions: k, interactionWidth: C }) => {
    const [_, O, N] = B5({
      sourceX: n,
      sourceY: r,
      sourcePosition: y,
      targetX: a,
      targetY: s,
      targetPosition: w,
      borderRadius: k?.borderRadius,
      offset: k?.offset,
      stepPosition: k?.stepPosition
    }), R = e.isInternal ? void 0 : t;
    return E.jsx(xS, { id: R, path: _, labelX: O, labelY: N, label: l, labelStyle: c, labelShowBg: d, labelBgStyle: p, labelBgPadding: m, labelBgBorderRadius: h, style: v, markerEnd: x, markerStart: b, interactionWidth: C });
  });
}
const UU = BU({ isInternal: !1 }), VU = BU({ isInternal: !0 });
UU.displayName = "SmoothStepEdge";
VU.displayName = "SmoothStepEdgeInternal";
function HU(e) {
  return M.memo(({ id: t, ...n }) => {
    const r = e.isInternal ? void 0 : t;
    return E.jsx(UU, { ...n, id: r, pathOptions: M.useMemo(() => ({ borderRadius: 0, offset: n.pathOptions?.offset }), [n.pathOptions?.offset]) });
  });
}
const Zye = HU({ isInternal: !1 }), qU = HU({ isInternal: !0 });
Zye.displayName = "StepEdge";
qU.displayName = "StepEdgeInternal";
function WU(e) {
  return M.memo(({ id: t, sourceX: n, sourceY: r, targetX: a, targetY: s, label: l, labelStyle: c, labelShowBg: d, labelBgStyle: p, labelBgPadding: m, labelBgBorderRadius: h, style: v, markerEnd: y, markerStart: w, interactionWidth: x }) => {
    const [b, k, C] = cU({ sourceX: n, sourceY: r, targetX: a, targetY: s }), _ = e.isInternal ? void 0 : t;
    return E.jsx(xS, { id: _, path: b, labelX: k, labelY: C, label: l, labelStyle: c, labelShowBg: d, labelBgStyle: p, labelBgPadding: m, labelBgBorderRadius: h, style: v, markerEnd: y, markerStart: w, interactionWidth: x });
  });
}
const ebe = WU({ isInternal: !1 }), GU = WU({ isInternal: !0 });
ebe.displayName = "StraightEdge";
GU.displayName = "StraightEdgeInternal";
function KU(e) {
  return M.memo(({ id: t, sourceX: n, sourceY: r, targetX: a, targetY: s, sourcePosition: l = st.Bottom, targetPosition: c = st.Top, label: d, labelStyle: p, labelShowBg: m, labelBgStyle: h, labelBgPadding: v, labelBgBorderRadius: y, style: w, markerEnd: x, markerStart: b, pathOptions: k, interactionWidth: C }) => {
    const [_, O, N] = fA({
      sourceX: n,
      sourceY: r,
      sourcePosition: l,
      targetX: a,
      targetY: s,
      targetPosition: c,
      curvature: k?.curvature
    }), R = e.isInternal ? void 0 : t;
    return E.jsx(xS, { id: R, path: _, labelX: O, labelY: N, label: d, labelStyle: p, labelShowBg: m, labelBgStyle: h, labelBgPadding: v, labelBgBorderRadius: y, style: w, markerEnd: x, markerStart: b, interactionWidth: C });
  });
}
const tbe = KU({ isInternal: !1 }), XU = KU({ isInternal: !0 });
tbe.displayName = "BezierEdge";
XU.displayName = "BezierEdgeInternal";
const O$ = {
  default: XU,
  straight: GU,
  step: qU,
  smoothstep: VU,
  simplebezier: FU
}, M$ = {
  sourceX: null,
  sourceY: null,
  targetX: null,
  targetY: null,
  sourcePosition: null,
  targetPosition: null
}, nbe = (e, t, n) => n === st.Left ? e - t : n === st.Right ? e + t : e, rbe = (e, t, n) => n === st.Top ? e - t : n === st.Bottom ? e + t : e, N$ = "react-flow__edgeupdater";
function R$({ position: e, centerX: t, centerY: n, radius: r = 10, onMouseDown: a, onMouseEnter: s, onMouseOut: l, type: c }) {
  return E.jsx("circle", { onMouseDown: a, onMouseEnter: s, onMouseOut: l, className: Pr([N$, `${N$}-${c}`]), cx: nbe(t, r, e), cy: rbe(n, r, e), r, stroke: "transparent", fill: "transparent" });
}
function obe({ isReconnectable: e, reconnectRadius: t, edge: n, sourceX: r, sourceY: a, targetX: s, targetY: l, sourcePosition: c, targetPosition: d, onReconnect: p, onReconnectStart: m, onReconnectEnd: h, setReconnecting: v, setUpdateHover: y }) {
  const w = fr(), x = (O, N) => {
    if (O.button !== 0)
      return;
    const { autoPanOnConnect: R, domNode: j, isValidConnection: D, connectionMode: $, connectionRadius: z, lib: B, onConnectStart: P, onConnectEnd: W, cancelConnection: I, nodeLookup: G, rfId: L, panBy: K, updateConnection: q } = w.getState(), Z = N.type === "target", V = (U, H) => {
      v(!1), h?.(U, n, N.type, H);
    }, F = (U) => p?.(n, U), X = (U, H) => {
      v(!0), m?.(O, n, N.type), P?.(U, H);
    };
    H5.onPointerDown(O.nativeEvent, {
      autoPanOnConnect: R,
      connectionMode: $,
      connectionRadius: z,
      domNode: j,
      handleId: N.id,
      nodeId: N.nodeId,
      nodeLookup: G,
      isTarget: Z,
      edgeUpdaterType: N.type,
      lib: B,
      flowId: L,
      cancelConnection: I,
      panBy: K,
      isValidConnection: D,
      onConnect: F,
      onConnectStart: X,
      onConnectEnd: W,
      onReconnectEnd: V,
      updateConnection: q,
      getTransform: () => w.getState().transform,
      getFromHandle: () => w.getState().connection.fromHandle,
      dragThreshold: w.getState().connectionDragThreshold,
      handleDomNode: O.currentTarget
    });
  }, b = (O) => x(O, { nodeId: n.target, id: n.targetHandle ?? null, type: "target" }), k = (O) => x(O, { nodeId: n.source, id: n.sourceHandle ?? null, type: "source" }), C = () => y(!0), _ = () => y(!1);
  return E.jsxs(E.Fragment, { children: [(e === !0 || e === "source") && E.jsx(R$, { position: c, centerX: r, centerY: a, radius: t, onMouseDown: b, onMouseEnter: C, onMouseOut: _, type: "source" }), (e === !0 || e === "target") && E.jsx(R$, { position: d, centerX: s, centerY: l, radius: t, onMouseDown: k, onMouseEnter: C, onMouseOut: _, type: "target" })] });
}
function abe({ id: e, edgesFocusable: t, edgesReconnectable: n, elementsSelectable: r, onClick: a, onDoubleClick: s, onContextMenu: l, onMouseEnter: c, onMouseMove: d, onMouseLeave: p, reconnectRadius: m, onReconnect: h, onReconnectStart: v, onReconnectEnd: y, rfId: w, edgeTypes: x, noPanClassName: b, onError: k, disableKeyboardA11y: C }) {
  let _ = un((se) => se.edgeLookup.get(e));
  const O = un((se) => se.defaultEdgeOptions);
  _ = O ? { ...O, ..._ } : _;
  let N = _.type || "default", R = x?.[N] || O$[N];
  R === void 0 && (k?.("011", Ml.error011(N)), N = "default", R = x?.default || O$.default);
  const j = !!(_.focusable || t && typeof _.focusable > "u"), D = typeof h < "u" && (_.reconnectable || n && typeof _.reconnectable > "u"), $ = !!(_.selectable || r && typeof _.selectable > "u"), z = M.useRef(null), [B, P] = M.useState(!1), [W, I] = M.useState(!1), G = fr(), { zIndex: L, sourceX: K, sourceY: q, targetX: Z, targetY: V, sourcePosition: F, targetPosition: X } = un(M.useCallback((se) => {
    const pe = se.nodeLookup.get(_.source), ge = se.nodeLookup.get(_.target);
    if (!pe || !ge)
      return {
        zIndex: _.zIndex,
        ...M$
      };
    const xe = ove({
      id: e,
      sourceNode: pe,
      targetNode: ge,
      sourceHandle: _.sourceHandle || null,
      targetHandle: _.targetHandle || null,
      connectionMode: se.connectionMode,
      onError: k
    });
    return {
      zIndex: Yge({
        selected: _.selected,
        zIndex: _.zIndex,
        sourceNode: pe,
        targetNode: ge,
        elevateOnSelect: se.elevateEdgesOnSelect,
        zIndexMode: se.zIndexMode
      }),
      ...xe || M$
    };
  }, [_.source, _.target, _.sourceHandle, _.targetHandle, _.selected, _.zIndex]), cr), U = M.useMemo(() => _.markerStart ? `url('#${U5(_.markerStart, w)}')` : void 0, [_.markerStart, w]), H = M.useMemo(() => _.markerEnd ? `url('#${U5(_.markerEnd, w)}')` : void 0, [_.markerEnd, w]);
  if (_.hidden || K === null || q === null || Z === null || V === null)
    return null;
  const Q = (se) => {
    const { addSelectedEdges: pe, unselectNodesAndEdges: ge, multiSelectionActive: xe } = G.getState();
    $ && (G.setState({ nodesSelectionActive: !1 }), _.selected && xe ? (ge({ nodes: [], edges: [_] }), z.current?.blur()) : pe([e])), a && a(se, _);
  }, re = s ? (se) => {
    s(se, { ..._ });
  } : void 0, de = l ? (se) => {
    l(se, { ..._ });
  } : void 0, le = c ? (se) => {
    c(se, { ..._ });
  } : void 0, me = d ? (se) => {
    d(se, { ..._ });
  } : void 0, ve = p ? (se) => {
    p(se, { ..._ });
  } : void 0, ae = (se) => {
    if (!C && KB.includes(se.key) && $) {
      const { unselectNodesAndEdges: pe, addSelectedEdges: ge } = G.getState();
      se.key === "Escape" ? (z.current?.blur(), pe({ edges: [_] })) : ge([e]);
    }
  };
  return E.jsx("svg", { style: { zIndex: L }, children: E.jsxs("g", { className: Pr([
    "react-flow__edge",
    `react-flow__edge-${N}`,
    _.className,
    b,
    {
      selected: _.selected,
      animated: _.animated,
      inactive: !$ && !a,
      updating: B,
      selectable: $
    }
  ]), onClick: Q, onDoubleClick: re, onContextMenu: de, onMouseEnter: le, onMouseMove: me, onMouseLeave: ve, onKeyDown: j ? ae : void 0, tabIndex: j ? 0 : void 0, role: _.ariaRole ?? (j ? "group" : "img"), "aria-roledescription": "edge", "data-id": e, "data-testid": `rf__edge-${e}`, "aria-label": _.ariaLabel === null ? void 0 : _.ariaLabel || `Edge from ${_.source} to ${_.target}`, "aria-describedby": j ? `${EU}-${w}` : void 0, ref: z, ..._.domAttributes, children: [!W && E.jsx(R, { id: e, source: _.source, target: _.target, type: _.type, selected: _.selected, animated: _.animated, selectable: $, deletable: _.deletable ?? !0, label: _.label, labelStyle: _.labelStyle, labelShowBg: _.labelShowBg, labelBgStyle: _.labelBgStyle, labelBgPadding: _.labelBgPadding, labelBgBorderRadius: _.labelBgBorderRadius, sourceX: K, sourceY: q, targetX: Z, targetY: V, sourcePosition: F, targetPosition: X, data: _.data, style: _.style, sourceHandleId: _.sourceHandle, targetHandleId: _.targetHandle, markerStart: U, markerEnd: H, pathOptions: "pathOptions" in _ ? _.pathOptions : void 0, interactionWidth: _.interactionWidth }), D && E.jsx(obe, { edge: _, isReconnectable: D, reconnectRadius: m, onReconnect: h, onReconnectStart: v, onReconnectEnd: y, sourceX: K, sourceY: q, targetX: Z, targetY: V, sourcePosition: F, targetPosition: X, setUpdateHover: P, setReconnecting: I })] }) });
}
var ibe = M.memo(abe);
const sbe = (e) => ({
  edgesFocusable: e.edgesFocusable,
  edgesReconnectable: e.edgesReconnectable,
  elementsSelectable: e.elementsSelectable,
  connectionMode: e.connectionMode,
  onError: e.onError
});
function YU({ defaultMarkerColor: e, onlyRenderVisibleElements: t, rfId: n, edgeTypes: r, noPanClassName: a, onReconnect: s, onEdgeContextMenu: l, onEdgeMouseEnter: c, onEdgeMouseMove: d, onEdgeMouseLeave: p, onEdgeClick: m, reconnectRadius: h, onEdgeDoubleClick: v, onReconnectStart: y, onReconnectEnd: w, disableKeyboardA11y: x }) {
  const { edgesFocusable: b, edgesReconnectable: k, elementsSelectable: C, onError: _ } = un(sbe, cr), O = qye(t);
  return E.jsxs("div", { className: "react-flow__edges", children: [E.jsx(Yye, { defaultColor: e, rfId: n }), O.map((N) => E.jsx(ibe, { id: N, edgesFocusable: b, edgesReconnectable: k, elementsSelectable: C, noPanClassName: a, onReconnect: s, onContextMenu: l, onMouseEnter: c, onMouseMove: d, onMouseLeave: p, onClick: m, reconnectRadius: h, onDoubleClick: v, onReconnectStart: y, onReconnectEnd: w, rfId: n, onError: _, edgeTypes: r, disableKeyboardA11y: x }, N))] });
}
YU.displayName = "EdgeRenderer";
const lbe = M.memo(YU), ube = (e) => `translate(${e.transform[0]}px,${e.transform[1]}px) scale(${e.transform[2]})`;
function cbe({ children: e }) {
  const t = un(ube);
  return E.jsx("div", { className: "react-flow__viewport xyflow__viewport react-flow__container", style: { transform: t }, children: e });
}
function dbe(e) {
  const t = Sm(), n = M.useRef(!1);
  M.useEffect(() => {
    !n.current && t.viewportInitialized && e && (setTimeout(() => e(t), 1), n.current = !0);
  }, [e, t.viewportInitialized]);
}
const fbe = (e) => e.panZoom?.syncViewport;
function pbe(e) {
  const t = un(fbe), n = fr();
  return M.useEffect(() => {
    e && (t?.(e), n.setState({ transform: [e.x, e.y, e.zoom] }));
  }, [e, t]), null;
}
function mbe(e) {
  return e.connection.inProgress ? { ...e.connection, to: wS(e.connection.to, e.transform) } : { ...e.connection };
}
function hbe(e) {
  return mbe;
}
function gbe(e) {
  const t = hbe();
  return un(t, cr);
}
const vbe = (e) => ({
  nodesConnectable: e.nodesConnectable,
  isValid: e.connection.isValid,
  inProgress: e.connection.inProgress,
  width: e.width,
  height: e.height
});
function ybe({ containerStyle: e, style: t, type: n, component: r }) {
  const { nodesConnectable: a, width: s, height: l, isValid: c, inProgress: d } = un(vbe, cr);
  return s && a && d ? E.jsx("svg", { style: e, width: s, height: l, className: "react-flow__connectionline react-flow__container", children: E.jsx("g", { className: Pr(["react-flow__connection", QB(c)]), children: E.jsx(QU, { style: t, type: n, CustomComponent: r, isValid: c }) }) }) : null;
}
const QU = ({ style: e, type: t = Gc.Bezier, CustomComponent: n, isValid: r }) => {
  const { inProgress: a, from: s, fromNode: l, fromHandle: c, fromPosition: d, to: p, toNode: m, toHandle: h, toPosition: v, pointer: y } = gbe();
  if (!a)
    return;
  if (n)
    return E.jsx(n, { connectionLineType: t, connectionLineStyle: e, fromNode: l, fromHandle: c, fromX: s.x, fromY: s.y, toX: p.x, toY: p.y, fromPosition: d, toPosition: v, connectionStatus: QB(r), toNode: m, toHandle: h, pointer: y });
  let w = "";
  const x = {
    sourceX: s.x,
    sourceY: s.y,
    sourcePosition: d,
    targetX: p.x,
    targetY: p.y,
    targetPosition: v
  };
  switch (t) {
    case Gc.Bezier:
      [w] = fA(x);
      break;
    case Gc.SimpleBezier:
      [w] = IU(x);
      break;
    case Gc.Step:
      [w] = B5({
        ...x,
        borderRadius: 0
      });
      break;
    case Gc.SmoothStep:
      [w] = B5(x);
      break;
    default:
      [w] = cU(x);
  }
  return E.jsx("path", { d: w, fill: "none", className: "react-flow__connection-path", style: e });
};
QU.displayName = "ConnectionLine";
const bbe = {};
function A$(e = bbe) {
  M.useRef(e), fr(), M.useEffect(() => {
  }, [e]);
}
function wbe() {
  fr(), M.useRef(!1), M.useEffect(() => {
  }, []);
}
function JU({ nodeTypes: e, edgeTypes: t, onInit: n, onNodeClick: r, onEdgeClick: a, onNodeDoubleClick: s, onEdgeDoubleClick: l, onNodeMouseEnter: c, onNodeMouseMove: d, onNodeMouseLeave: p, onNodeContextMenu: m, onSelectionContextMenu: h, onSelectionStart: v, onSelectionEnd: y, connectionLineType: w, connectionLineStyle: x, connectionLineComponent: b, connectionLineContainerStyle: k, selectionKeyCode: C, selectionOnDrag: _, selectionMode: O, multiSelectionKeyCode: N, panActivationKeyCode: R, zoomActivationKeyCode: j, deleteKeyCode: D, onlyRenderVisibleElements: $, elementsSelectable: z, defaultViewport: B, translateExtent: P, minZoom: W, maxZoom: I, preventScrolling: G, defaultMarkerColor: L, zoomOnScroll: K, zoomOnPinch: q, panOnScroll: Z, panOnScrollSpeed: V, panOnScrollMode: F, zoomOnDoubleClick: X, panOnDrag: U, onPaneClick: H, onPaneMouseEnter: Q, onPaneMouseMove: re, onPaneMouseLeave: de, onPaneScroll: le, onPaneContextMenu: me, paneClickDistance: ve, nodeClickDistance: ae, onEdgeContextMenu: se, onEdgeMouseEnter: pe, onEdgeMouseMove: ge, onEdgeMouseLeave: xe, reconnectRadius: _e, onReconnect: We, onReconnectStart: Xe, onReconnectEnd: et, noDragClassName: tt, noWheelClassName: je, noPanClassName: an, disableKeyboardA11y: dt, nodeExtent: Ce, rfId: Me, viewport: he, onViewportChange: ye }) {
  return A$(e), A$(t), wbe(), dbe(n), pbe(he), E.jsx($ye, { onPaneClick: H, onPaneMouseEnter: Q, onPaneMouseMove: re, onPaneMouseLeave: de, onPaneContextMenu: me, onPaneScroll: le, paneClickDistance: ve, deleteKeyCode: D, selectionKeyCode: C, selectionOnDrag: _, selectionMode: O, onSelectionStart: v, onSelectionEnd: y, multiSelectionKeyCode: N, panActivationKeyCode: R, zoomActivationKeyCode: j, elementsSelectable: z, zoomOnScroll: K, zoomOnPinch: q, zoomOnDoubleClick: X, panOnScroll: Z, panOnScrollSpeed: V, panOnScrollMode: F, panOnDrag: U, defaultViewport: B, translateExtent: P, minZoom: W, maxZoom: I, onSelectionContextMenu: h, preventScrolling: G, noDragClassName: tt, noWheelClassName: je, noPanClassName: an, disableKeyboardA11y: dt, onViewportChange: ye, isControlledViewport: !!he, children: E.jsxs(cbe, { children: [E.jsx(lbe, { edgeTypes: t, onEdgeClick: a, onEdgeDoubleClick: l, onReconnect: We, onReconnectStart: Xe, onReconnectEnd: et, onlyRenderVisibleElements: $, onEdgeContextMenu: se, onEdgeMouseEnter: pe, onEdgeMouseMove: ge, onEdgeMouseLeave: xe, reconnectRadius: _e, defaultMarkerColor: L, noPanClassName: an, disableKeyboardA11y: dt, rfId: Me }), E.jsx(ybe, { style: x, type: w, component: b, containerStyle: k }), E.jsx("div", { className: "react-flow__edgelabel-renderer" }), E.jsx(Hye, { nodeTypes: e, onNodeClick: r, onNodeDoubleClick: s, onNodeMouseEnter: c, onNodeMouseMove: d, onNodeMouseLeave: p, onNodeContextMenu: m, nodeClickDistance: ae, onlyRenderVisibleElements: $, noPanClassName: an, noDragClassName: tt, disableKeyboardA11y: dt, nodeExtent: Ce, rfId: Me }), E.jsx("div", { className: "react-flow__viewport-portal" })] }) });
}
JU.displayName = "GraphView";
const xbe = M.memo(JU), j$ = ({ nodes: e, edges: t, defaultNodes: n, defaultEdges: r, width: a, height: s, fitView: l, fitViewOptions: c, minZoom: d = 0.5, maxZoom: p = 2, nodeOrigin: m, nodeExtent: h, zIndexMode: v = "basic" } = {}) => {
  const y = /* @__PURE__ */ new Map(), w = /* @__PURE__ */ new Map(), x = /* @__PURE__ */ new Map(), b = /* @__PURE__ */ new Map(), k = r ?? t ?? [], C = n ?? e ?? [], _ = m ?? [0, 0], O = h ?? _x;
  pU(x, b, k);
  const N = V5(C, y, w, {
    nodeOrigin: _,
    nodeExtent: O,
    zIndexMode: v
  });
  let R = [0, 0, 1];
  if (l && a && s) {
    const j = yS(y, {
      filter: (B) => !!((B.width || B.initialWidth) && (B.height || B.initialHeight))
    }), { x: D, y: $, zoom: z } = cA(j, a, s, d, p, c?.padding ?? 0.1);
    R = [D, $, z];
  }
  return {
    rfId: "1",
    width: a ?? 0,
    height: s ?? 0,
    transform: R,
    nodes: C,
    nodesInitialized: N,
    nodeLookup: y,
    parentLookup: w,
    edges: k,
    edgeLookup: b,
    connectionLookup: x,
    onNodesChange: null,
    onEdgesChange: null,
    hasDefaultNodes: n !== void 0,
    hasDefaultEdges: r !== void 0,
    panZoom: null,
    minZoom: d,
    maxZoom: p,
    translateExtent: _x,
    nodeExtent: O,
    nodesSelectionActive: !1,
    userSelectionActive: !1,
    userSelectionRect: null,
    connectionMode: zh.Strict,
    domNode: null,
    paneDragging: !1,
    noPanClassName: "nopan",
    nodeOrigin: _,
    nodeDragThreshold: 1,
    connectionDragThreshold: 1,
    snapGrid: [15, 15],
    snapToGrid: !1,
    nodesDraggable: !0,
    nodesConnectable: !0,
    nodesFocusable: !0,
    edgesFocusable: !0,
    edgesReconnectable: !0,
    elementsSelectable: !0,
    elevateNodesOnSelect: !0,
    elevateEdgesOnSelect: !0,
    selectNodesOnDrag: !0,
    multiSelectionActive: !1,
    fitViewQueued: l ?? !1,
    fitViewOptions: c,
    fitViewResolver: null,
    connection: { ...YB },
    connectionClickStartHandle: null,
    connectOnClick: !0,
    ariaLiveMessage: "",
    autoPanOnConnect: !0,
    autoPanOnNodeDrag: !0,
    autoPanOnNodeFocus: !0,
    autoPanSpeed: 15,
    connectionRadius: 20,
    onError: Hge,
    isValidConnection: void 0,
    onSelectionChangeHandlers: [],
    lib: "react",
    debug: !1,
    ariaLabelConfig: XB,
    zIndexMode: v,
    onNodesChangeMiddlewareMap: /* @__PURE__ */ new Map(),
    onEdgesChangeMiddlewareMap: /* @__PURE__ */ new Map()
  };
}, Sbe = ({ nodes: e, edges: t, defaultNodes: n, defaultEdges: r, width: a, height: s, fitView: l, fitViewOptions: c, minZoom: d, maxZoom: p, nodeOrigin: m, nodeExtent: h, zIndexMode: v }) => Fve((y, w) => {
  async function x() {
    const { nodeLookup: b, panZoom: k, fitViewOptions: C, fitViewResolver: _, width: O, height: N, minZoom: R, maxZoom: j } = w();
    k && (await Uge({
      nodes: b,
      width: O,
      height: N,
      panZoom: k,
      minZoom: R,
      maxZoom: j
    }, C), _?.resolve(!0), y({ fitViewResolver: null }));
  }
  return {
    ...j$({
      nodes: e,
      edges: t,
      width: a,
      height: s,
      fitView: l,
      fitViewOptions: c,
      minZoom: d,
      maxZoom: p,
      nodeOrigin: m,
      nodeExtent: h,
      defaultNodes: n,
      defaultEdges: r,
      zIndexMode: v
    }),
    setNodes: (b) => {
      const { nodeLookup: k, parentLookup: C, nodeOrigin: _, elevateNodesOnSelect: O, fitViewQueued: N, zIndexMode: R } = w(), j = V5(b, k, C, {
        nodeOrigin: _,
        nodeExtent: h,
        elevateNodesOnSelect: O,
        checkEquality: !0,
        zIndexMode: R
      });
      N && j ? (x(), y({ nodes: b, nodesInitialized: j, fitViewQueued: !1, fitViewOptions: void 0 })) : y({ nodes: b, nodesInitialized: j });
    },
    setEdges: (b) => {
      const { connectionLookup: k, edgeLookup: C } = w();
      pU(k, C, b), y({ edges: b });
    },
    setDefaultNodesAndEdges: (b, k) => {
      if (b) {
        const { setNodes: C } = w();
        C(b), y({ hasDefaultNodes: !0 });
      }
      if (k) {
        const { setEdges: C } = w();
        C(k), y({ hasDefaultEdges: !0 });
      }
    },
    /*
     * Every node gets registerd at a ResizeObserver. Whenever a node
     * changes its dimensions, this function is called to measure the
     * new dimensions and update the nodes.
     */
    updateNodeInternals: (b) => {
      const { triggerNodeChanges: k, nodeLookup: C, parentLookup: _, domNode: O, nodeOrigin: N, nodeExtent: R, debug: j, fitViewQueued: D, zIndexMode: $ } = w(), { changes: z, updatedInternals: B } = fve(b, C, _, O, N, R, $);
      B && (lve(C, _, { nodeOrigin: N, nodeExtent: R, zIndexMode: $ }), D ? (x(), y({ fitViewQueued: !1, fitViewOptions: void 0 })) : y({}), z?.length > 0 && (j && console.log("React Flow: trigger node changes", z), k?.(z)));
    },
    updateNodePositions: (b, k = !1) => {
      const C = [];
      let _ = [];
      const { nodeLookup: O, triggerNodeChanges: N, connection: R, updateConnection: j, onNodesChangeMiddlewareMap: D } = w();
      for (const [$, z] of b) {
        const B = O.get($), P = !!(B?.expandParent && B?.parentId && z?.position), W = {
          id: $,
          type: "position",
          position: P ? {
            x: Math.max(0, z.position.x),
            y: Math.max(0, z.position.y)
          } : z.position,
          dragging: k
        };
        if (B && R.inProgress && R.fromNode.id === B.id) {
          const I = hm(B, R.fromHandle, st.Left, !0);
          j({ ...R, from: I });
        }
        P && B.parentId && C.push({
          id: $,
          parentId: B.parentId,
          rect: {
            ...z.internals.positionAbsolute,
            width: z.measured.width ?? 0,
            height: z.measured.height ?? 0
          }
        }), _.push(W);
      }
      if (C.length > 0) {
        const { parentLookup: $, nodeOrigin: z } = w(), B = vA(C, O, $, z);
        _.push(...B);
      }
      for (const $ of D.values())
        _ = $(_);
      N(_);
    },
    triggerNodeChanges: (b) => {
      const { onNodesChange: k, setNodes: C, nodes: _, hasDefaultNodes: O, debug: N } = w();
      if (b?.length) {
        if (O) {
          const R = yA(b, _);
          C(R);
        }
        N && console.log("React Flow: trigger node changes", b), k?.(b);
      }
    },
    triggerEdgeChanges: (b) => {
      const { onEdgesChange: k, setEdges: C, edges: _, hasDefaultEdges: O, debug: N } = w();
      if (b?.length) {
        if (O) {
          const R = MU(b, _);
          C(R);
        }
        N && console.log("React Flow: trigger edge changes", b), k?.(b);
      }
    },
    addSelectedNodes: (b) => {
      const { multiSelectionActive: k, edgeLookup: C, nodeLookup: _, triggerNodeChanges: O, triggerEdgeChanges: N } = w();
      if (k) {
        const R = b.map((j) => Xp(j, !0));
        O(R);
        return;
      }
      O(ph(_, /* @__PURE__ */ new Set([...b]), !0)), N(ph(C));
    },
    addSelectedEdges: (b) => {
      const { multiSelectionActive: k, edgeLookup: C, nodeLookup: _, triggerNodeChanges: O, triggerEdgeChanges: N } = w();
      if (k) {
        const R = b.map((j) => Xp(j, !0));
        N(R);
        return;
      }
      N(ph(C, /* @__PURE__ */ new Set([...b]))), O(ph(_, /* @__PURE__ */ new Set(), !0));
    },
    unselectNodesAndEdges: ({ nodes: b, edges: k } = {}) => {
      const { edges: C, nodes: _, nodeLookup: O, triggerNodeChanges: N, triggerEdgeChanges: R } = w(), j = b || _, D = k || C, $ = j.map((B) => {
        const P = O.get(B.id);
        return P && (P.selected = !1), Xp(B.id, !1);
      }), z = D.map((B) => Xp(B.id, !1));
      N($), R(z);
    },
    setMinZoom: (b) => {
      const { panZoom: k, maxZoom: C } = w();
      k?.setScaleExtent([b, C]), y({ minZoom: b });
    },
    setMaxZoom: (b) => {
      const { panZoom: k, minZoom: C } = w();
      k?.setScaleExtent([C, b]), y({ maxZoom: b });
    },
    setTranslateExtent: (b) => {
      w().panZoom?.setTranslateExtent(b), y({ translateExtent: b });
    },
    resetSelectedElements: () => {
      const { edges: b, nodes: k, triggerNodeChanges: C, triggerEdgeChanges: _, elementsSelectable: O } = w();
      if (!O)
        return;
      const N = k.reduce((j, D) => D.selected ? [...j, Xp(D.id, !1)] : j, []), R = b.reduce((j, D) => D.selected ? [...j, Xp(D.id, !1)] : j, []);
      C(N), _(R);
    },
    setNodeExtent: (b) => {
      const { nodes: k, nodeLookup: C, parentLookup: _, nodeOrigin: O, elevateNodesOnSelect: N, nodeExtent: R, zIndexMode: j } = w();
      b[0][0] === R[0][0] && b[0][1] === R[0][1] && b[1][0] === R[1][0] && b[1][1] === R[1][1] || (V5(k, C, _, {
        nodeOrigin: O,
        nodeExtent: b,
        elevateNodesOnSelect: N,
        checkEquality: !1,
        zIndexMode: j
      }), y({ nodeExtent: b }));
    },
    panBy: (b) => {
      const { transform: k, width: C, height: _, panZoom: O, translateExtent: N } = w();
      return pve({ delta: b, panZoom: O, transform: k, translateExtent: N, width: C, height: _ });
    },
    setCenter: async (b, k, C) => {
      const { width: _, height: O, maxZoom: N, panZoom: R } = w();
      if (!R)
        return Promise.resolve(!1);
      const j = typeof C?.zoom < "u" ? C.zoom : N;
      return await R.setViewport({
        x: _ / 2 - b * j,
        y: O / 2 - k * j,
        zoom: j
      }, { duration: C?.duration, ease: C?.ease, interpolate: C?.interpolate }), Promise.resolve(!0);
    },
    cancelConnection: () => {
      y({
        connection: { ...YB }
      });
    },
    updateConnection: (b) => {
      y({ connection: b });
    },
    reset: () => y({ ...j$() })
  };
}, Object.is);
function kbe({ initialNodes: e, initialEdges: t, defaultNodes: n, defaultEdges: r, initialWidth: a, initialHeight: s, initialMinZoom: l, initialMaxZoom: c, initialFitViewOptions: d, fitView: p, nodeOrigin: m, nodeExtent: h, zIndexMode: v, children: y }) {
  const [w] = M.useState(() => Sbe({
    nodes: e,
    edges: t,
    defaultNodes: n,
    defaultEdges: r,
    width: a,
    height: s,
    fitView: p,
    minZoom: l,
    maxZoom: c,
    fitViewOptions: d,
    nodeOrigin: m,
    nodeExtent: h,
    zIndexMode: v
  }));
  return E.jsx(Bve, { value: w, children: E.jsx(cye, { children: y }) });
}
function _be({ children: e, nodes: t, edges: n, defaultNodes: r, defaultEdges: a, width: s, height: l, fitView: c, fitViewOptions: d, minZoom: p, maxZoom: m, nodeOrigin: h, nodeExtent: v, zIndexMode: y }) {
  return M.useContext(G2) ? E.jsx(E.Fragment, { children: e }) : E.jsx(kbe, { initialNodes: t, initialEdges: n, defaultNodes: r, defaultEdges: a, initialWidth: s, initialHeight: l, fitView: c, initialFitViewOptions: d, initialMinZoom: p, initialMaxZoom: m, nodeOrigin: h, nodeExtent: v, zIndexMode: y, children: e });
}
const Ebe = {
  width: "100%",
  height: "100%",
  overflow: "hidden",
  position: "relative",
  zIndex: 0
};
function Cbe({ nodes: e, edges: t, defaultNodes: n, defaultEdges: r, className: a, nodeTypes: s, edgeTypes: l, onNodeClick: c, onEdgeClick: d, onInit: p, onMove: m, onMoveStart: h, onMoveEnd: v, onConnect: y, onConnectStart: w, onConnectEnd: x, onClickConnectStart: b, onClickConnectEnd: k, onNodeMouseEnter: C, onNodeMouseMove: _, onNodeMouseLeave: O, onNodeContextMenu: N, onNodeDoubleClick: R, onNodeDragStart: j, onNodeDrag: D, onNodeDragStop: $, onNodesDelete: z, onEdgesDelete: B, onDelete: P, onSelectionChange: W, onSelectionDragStart: I, onSelectionDrag: G, onSelectionDragStop: L, onSelectionContextMenu: K, onSelectionStart: q, onSelectionEnd: Z, onBeforeDelete: V, connectionMode: F, connectionLineType: X = Gc.Bezier, connectionLineStyle: U, connectionLineComponent: H, connectionLineContainerStyle: Q, deleteKeyCode: re = "Backspace", selectionKeyCode: de = "Shift", selectionOnDrag: le = !1, selectionMode: me = Ex.Full, panActivationKeyCode: ve = "Space", multiSelectionKeyCode: ae = Ox() ? "Meta" : "Control", zoomActivationKeyCode: se = Ox() ? "Meta" : "Control", snapToGrid: pe, snapGrid: ge, onlyRenderVisibleElements: xe = !1, selectNodesOnDrag: _e, nodesDraggable: We, autoPanOnNodeFocus: Xe, nodesConnectable: et, nodesFocusable: tt, nodeOrigin: je = CU, edgesFocusable: an, edgesReconnectable: dt, elementsSelectable: Ce = !0, defaultViewport: Me = eye, minZoom: he = 0.5, maxZoom: ye = 2, translateExtent: Ee = _x, preventScrolling: Le = !0, nodeExtent: ze, defaultMarkerColor: It = "#b1b1b7", zoomOnScroll: zt = !0, zoomOnPinch: Wt = !0, panOnScroll: Ot = !1, panOnScrollSpeed: bn = 0.5, panOnScrollMode: Re = am.Free, zoomOnDoubleClick: Ft = !0, panOnDrag: Xt = !0, onPaneClick: To, onPaneMouseEnter: Lo, onPaneMouseMove: dn, onPaneMouseLeave: kn, onPaneScroll: wr, onPaneContextMenu: Io, paneClickDistance: pr = 1, nodeClickDistance: hg = 0, children: xd, onReconnect: zl, onReconnectStart: ja, onReconnectEnd: gg, onEdgeContextMenu: Sd, onEdgeDoubleClick: kd, onEdgeMouseEnter: _d, onEdgeMouseMove: Fl, onEdgeMouseLeave: Bl, reconnectRadius: Ed = 10, onNodesChange: Cd, onEdgesChange: Dr, noDragClassName: Yt = "nodrag", noWheelClassName: mn = "nowheel", noPanClassName: zo = "nopan", fitView: Xs, fitViewOptions: Tm, connectOnClick: vg, attributionPosition: Od, proOptions: Pa, defaultEdgeOptions: Ul, elevateNodesOnSelect: Qo = !0, elevateEdgesOnSelect: Jo = !1, disableKeyboardA11y: ka = !1, autoPanOnConnect: Zo, autoPanOnNodeDrag: Bt, autoPanSpeed: Md, connectionRadius: Nd, isValidConnection: oo, onError: ea, style: yg, id: Lc, nodeDragThreshold: Rd, connectionDragThreshold: bg, viewport: zi, onViewportChange: Fi, width: xr, height: Tn, colorMode: Ad = "light", debug: wg, onScroll: Ys, ariaLabelConfig: jd, zIndexMode: Ei = "basic", ...xg }, Gn) {
  const Bi = Lc || "1", Pd = oye(Ad), Vl = M.useCallback((Fo) => {
    Fo.currentTarget.scrollTo({ top: 0, left: 0, behavior: "instant" }), Ys?.(Fo);
  }, [Ys]);
  return E.jsx("div", { "data-testid": "rf__wrapper", ...xg, onScroll: Vl, style: { ...yg, ...Ebe }, ref: Gn, className: Pr(["react-flow", a, Pd]), id: Lc, role: "application", children: E.jsxs(_be, { nodes: e, edges: t, width: xr, height: Tn, fitView: Xs, fitViewOptions: Tm, minZoom: he, maxZoom: ye, nodeOrigin: je, nodeExtent: ze, zIndexMode: Ei, children: [E.jsx(xbe, { onInit: p, onNodeClick: c, onEdgeClick: d, onNodeMouseEnter: C, onNodeMouseMove: _, onNodeMouseLeave: O, onNodeContextMenu: N, onNodeDoubleClick: R, nodeTypes: s, edgeTypes: l, connectionLineType: X, connectionLineStyle: U, connectionLineComponent: H, connectionLineContainerStyle: Q, selectionKeyCode: de, selectionOnDrag: le, selectionMode: me, deleteKeyCode: re, multiSelectionKeyCode: ae, panActivationKeyCode: ve, zoomActivationKeyCode: se, onlyRenderVisibleElements: xe, defaultViewport: Me, translateExtent: Ee, minZoom: he, maxZoom: ye, preventScrolling: Le, zoomOnScroll: zt, zoomOnPinch: Wt, zoomOnDoubleClick: Ft, panOnScroll: Ot, panOnScrollSpeed: bn, panOnScrollMode: Re, panOnDrag: Xt, onPaneClick: To, onPaneMouseEnter: Lo, onPaneMouseMove: dn, onPaneMouseLeave: kn, onPaneScroll: wr, onPaneContextMenu: Io, paneClickDistance: pr, nodeClickDistance: hg, onSelectionContextMenu: K, onSelectionStart: q, onSelectionEnd: Z, onReconnect: zl, onReconnectStart: ja, onReconnectEnd: gg, onEdgeContextMenu: Sd, onEdgeDoubleClick: kd, onEdgeMouseEnter: _d, onEdgeMouseMove: Fl, onEdgeMouseLeave: Bl, reconnectRadius: Ed, defaultMarkerColor: It, noDragClassName: Yt, noWheelClassName: mn, noPanClassName: zo, rfId: Bi, disableKeyboardA11y: ka, nodeExtent: ze, viewport: zi, onViewportChange: Fi }), E.jsx(rye, { nodes: e, edges: t, defaultNodes: n, defaultEdges: r, onConnect: y, onConnectStart: w, onConnectEnd: x, onClickConnectStart: b, onClickConnectEnd: k, nodesDraggable: We, autoPanOnNodeFocus: Xe, nodesConnectable: et, nodesFocusable: tt, edgesFocusable: an, edgesReconnectable: dt, elementsSelectable: Ce, elevateNodesOnSelect: Qo, elevateEdgesOnSelect: Jo, minZoom: he, maxZoom: ye, nodeExtent: ze, onNodesChange: Cd, onEdgesChange: Dr, snapToGrid: pe, snapGrid: ge, connectionMode: F, translateExtent: Ee, connectOnClick: vg, defaultEdgeOptions: Ul, fitView: Xs, fitViewOptions: Tm, onNodesDelete: z, onEdgesDelete: B, onDelete: P, onNodeDragStart: j, onNodeDrag: D, onNodeDragStop: $, onSelectionDrag: G, onSelectionDragStart: I, onSelectionDragStop: L, onMove: m, onMoveStart: h, onMoveEnd: v, noPanClassName: zo, nodeOrigin: je, rfId: Bi, autoPanOnConnect: Zo, autoPanOnNodeDrag: Bt, autoPanSpeed: Md, onError: ea, connectionRadius: Nd, isValidConnection: oo, selectNodesOnDrag: _e, nodeDragThreshold: Rd, connectionDragThreshold: bg, onBeforeDelete: V, debug: wg, ariaLabelConfig: jd, zIndexMode: Ei }), E.jsx(Zve, { onSelectionChange: W }), xd, E.jsx(Kve, { proOptions: Pa, position: Od }), E.jsx(Gve, { rfId: Bi, disableKeyboardA11y: ka })] }) });
}
var Obe = NU(Cbe);
function Mbe({ dimensions: e, lineWidth: t, variant: n, className: r }) {
  return E.jsx("path", { strokeWidth: t, d: `M${e[0] / 2} 0 V${e[1]} M0 ${e[1] / 2} H${e[0]}`, className: Pr(["react-flow__background-pattern", n, r]) });
}
function Nbe({ radius: e, className: t }) {
  return E.jsx("circle", { cx: e, cy: e, r: e, className: Pr(["react-flow__background-pattern", "dots", t]) });
}
var ya;
(function(e) {
  e.Lines = "lines", e.Dots = "dots", e.Cross = "cross";
})(ya || (ya = {}));
const Rbe = {
  [ya.Dots]: 1,
  [ya.Lines]: 1,
  [ya.Cross]: 6
}, Abe = (e) => ({ transform: e.transform, patternId: `pattern-${e.rfId}` });
function ZU({
  id: e,
  variant: t = ya.Dots,
  // only used for dots and cross
  gap: n = 20,
  // only used for lines and cross
  size: r,
  lineWidth: a = 1,
  offset: s = 0,
  color: l,
  bgColor: c,
  style: d,
  className: p,
  patternClassName: m
}) {
  const h = M.useRef(null), { transform: v, patternId: y } = un(Abe, cr), w = r || Rbe[t], x = t === ya.Dots, b = t === ya.Cross, k = Array.isArray(n) ? n : [n, n], C = [k[0] * v[2] || 1, k[1] * v[2] || 1], _ = w * v[2], O = Array.isArray(s) ? s : [s, s], N = b ? [_, _] : C, R = [
    O[0] * v[2] || 1 + N[0] / 2,
    O[1] * v[2] || 1 + N[1] / 2
  ], j = `${y}${e || ""}`;
  return E.jsxs("svg", { className: Pr(["react-flow__background", p]), style: {
    ...d,
    ...X2,
    "--xy-background-color-props": c,
    "--xy-background-pattern-color-props": l
  }, ref: h, "data-testid": "rf__background", children: [E.jsx("pattern", { id: j, x: v[0] % C[0], y: v[1] % C[1], width: C[0], height: C[1], patternUnits: "userSpaceOnUse", patternTransform: `translate(-${R[0]},-${R[1]})`, children: x ? E.jsx(Nbe, { radius: _ / 2, className: m }) : E.jsx(Mbe, { dimensions: N, lineWidth: a, variant: t, className: m }) }), E.jsx("rect", { x: "0", y: "0", width: "100%", height: "100%", fill: `url(#${j})` })] });
}
ZU.displayName = "Background";
const jbe = M.memo(ZU);
function Pbe() {
  return E.jsx("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 32 32", children: E.jsx("path", { d: "M32 18.133H18.133V32h-4.266V18.133H0v-4.266h13.867V0h4.266v13.867H32z" }) });
}
function Dbe() {
  return E.jsx("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 32 5", children: E.jsx("path", { d: "M0 0h32v4.2H0z" }) });
}
function $be() {
  return E.jsx("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 32 30", children: E.jsx("path", { d: "M3.692 4.63c0-.53.4-.938.939-.938h5.215V0H4.708C2.13 0 0 2.054 0 4.63v5.216h3.692V4.631zM27.354 0h-5.2v3.692h5.17c.53 0 .984.4.984.939v5.215H32V4.631A4.624 4.624 0 0027.354 0zm.954 24.83c0 .532-.4.94-.939.94h-5.215v3.768h5.215c2.577 0 4.631-2.13 4.631-4.707v-5.139h-3.692v5.139zm-23.677.94c-.531 0-.939-.4-.939-.94v-5.138H0v5.139c0 2.577 2.13 4.707 4.708 4.707h5.138V25.77H4.631z" }) });
}
function Tbe() {
  return E.jsx("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 25 32", children: E.jsx("path", { d: "M21.333 10.667H19.81V7.619C19.81 3.429 16.38 0 12.19 0 8 0 4.571 3.429 4.571 7.619v3.048H3.048A3.056 3.056 0 000 13.714v15.238A3.056 3.056 0 003.048 32h18.285a3.056 3.056 0 003.048-3.048V13.714a3.056 3.056 0 00-3.048-3.047zM12.19 24.533a3.056 3.056 0 01-3.047-3.047 3.056 3.056 0 013.047-3.048 3.056 3.056 0 013.048 3.048 3.056 3.056 0 01-3.048 3.047zm4.724-13.866H7.467V7.619c0-2.59 2.133-4.724 4.723-4.724 2.591 0 4.724 2.133 4.724 4.724v3.048z" }) });
}
function Lbe() {
  return E.jsx("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 25 32", children: E.jsx("path", { d: "M21.333 10.667H19.81V7.619C19.81 3.429 16.38 0 12.19 0c-4.114 1.828-1.37 2.133.305 2.438 1.676.305 4.42 2.59 4.42 5.181v3.048H3.047A3.056 3.056 0 000 13.714v15.238A3.056 3.056 0 003.048 32h18.285a3.056 3.056 0 003.048-3.048V13.714a3.056 3.056 0 00-3.048-3.047zM12.19 24.533a3.056 3.056 0 01-3.047-3.047 3.056 3.056 0 013.047-3.048 3.056 3.056 0 013.048 3.048 3.056 3.056 0 01-3.048 3.047z" }) });
}
function gk({ children: e, className: t, ...n }) {
  return E.jsx("button", { type: "button", className: Pr(["react-flow__controls-button", t]), ...n, children: e });
}
const Ibe = (e) => ({
  isInteractive: e.nodesDraggable || e.nodesConnectable || e.elementsSelectable,
  minZoomReached: e.transform[2] <= e.minZoom,
  maxZoomReached: e.transform[2] >= e.maxZoom,
  ariaLabelConfig: e.ariaLabelConfig
});
function eV({ style: e, showZoom: t = !0, showFitView: n = !0, showInteractive: r = !0, fitViewOptions: a, onZoomIn: s, onZoomOut: l, onFitView: c, onInteractiveChange: d, className: p, children: m, position: h = "bottom-left", orientation: v = "vertical", "aria-label": y }) {
  const w = fr(), { isInteractive: x, minZoomReached: b, maxZoomReached: k, ariaLabelConfig: C } = un(Ibe, cr), { zoomIn: _, zoomOut: O, fitView: N } = Sm(), R = () => {
    _(), s?.();
  }, j = () => {
    O(), l?.();
  }, D = () => {
    N(a), c?.();
  }, $ = () => {
    w.setState({
      nodesDraggable: !x,
      nodesConnectable: !x,
      elementsSelectable: !x
    }), d?.(!x);
  }, z = v === "horizontal" ? "horizontal" : "vertical";
  return E.jsxs(K2, { className: Pr(["react-flow__controls", z, p]), position: h, style: e, "data-testid": "rf__controls", "aria-label": y ?? C["controls.ariaLabel"], children: [t && E.jsxs(E.Fragment, { children: [E.jsx(gk, { onClick: R, className: "react-flow__controls-zoomin", title: C["controls.zoomIn.ariaLabel"], "aria-label": C["controls.zoomIn.ariaLabel"], disabled: k, children: E.jsx(Pbe, {}) }), E.jsx(gk, { onClick: j, className: "react-flow__controls-zoomout", title: C["controls.zoomOut.ariaLabel"], "aria-label": C["controls.zoomOut.ariaLabel"], disabled: b, children: E.jsx(Dbe, {}) })] }), n && E.jsx(gk, { className: "react-flow__controls-fitview", onClick: D, title: C["controls.fitView.ariaLabel"], "aria-label": C["controls.fitView.ariaLabel"], children: E.jsx($be, {}) }), r && E.jsx(gk, { className: "react-flow__controls-interactive", onClick: $, title: C["controls.interactive.ariaLabel"], "aria-label": C["controls.interactive.ariaLabel"], children: x ? E.jsx(Lbe, {}) : E.jsx(Tbe, {}) }), m] });
}
eV.displayName = "Controls";
M.memo(eV);
function zbe({ id: e, x: t, y: n, width: r, height: a, style: s, color: l, strokeColor: c, strokeWidth: d, className: p, borderRadius: m, shapeRendering: h, selected: v, onClick: y }) {
  const { background: w, backgroundColor: x } = s || {}, b = l || w || x;
  return E.jsx("rect", { className: Pr(["react-flow__minimap-node", { selected: v }, p]), x: t, y: n, rx: m, ry: m, width: r, height: a, style: {
    fill: b,
    stroke: c,
    strokeWidth: d
  }, shapeRendering: h, onClick: y ? (k) => y(k, e) : void 0 });
}
const Fbe = M.memo(zbe), Bbe = (e) => e.nodes.map((t) => t.id), BM = (e) => e instanceof Function ? e : () => e;
function Ube({
  nodeStrokeColor: e,
  nodeColor: t,
  nodeClassName: n = "",
  nodeBorderRadius: r = 5,
  nodeStrokeWidth: a,
  /*
   * We need to rename the prop to be `CapitalCase` so that JSX will render it as
   * a component properly.
   */
  nodeComponent: s = Fbe,
  onClick: l
}) {
  const c = un(Bbe, cr), d = BM(t), p = BM(e), m = BM(n), h = typeof window > "u" || window.chrome ? "crispEdges" : "geometricPrecision";
  return E.jsx(E.Fragment, { children: c.map((v) => (
    /*
     * The split of responsibilities between MiniMapNodes and
     * NodeComponentWrapper may appear weird. However, its designed to
     * minimize the cost of updates when individual nodes change.
     *
     * For more details, see a similar commit in `NodeRenderer/index.tsx`.
     */
    E.jsx(Hbe, { id: v, nodeColorFunc: d, nodeStrokeColorFunc: p, nodeClassNameFunc: m, nodeBorderRadius: r, nodeStrokeWidth: a, NodeComponent: s, onClick: l, shapeRendering: h }, v)
  )) });
}
function Vbe({ id: e, nodeColorFunc: t, nodeStrokeColorFunc: n, nodeClassNameFunc: r, nodeBorderRadius: a, nodeStrokeWidth: s, shapeRendering: l, NodeComponent: c, onClick: d }) {
  const { node: p, x: m, y: h, width: v, height: y } = un((w) => {
    const { internals: x } = w.nodeLookup.get(e), b = x.userNode, { x: k, y: C } = x.positionAbsolute, { width: _, height: O } = Ac(b);
    return {
      node: b,
      x: k,
      y: C,
      width: _,
      height: O
    };
  }, cr);
  return !p || p.hidden || !rU(p) ? null : E.jsx(c, { x: m, y: h, width: v, height: y, style: p.style, selected: !!p.selected, className: r(p), color: t(p), borderRadius: a, strokeColor: n(p), strokeWidth: s, shapeRendering: l, onClick: d, id: p.id });
}
const Hbe = M.memo(Vbe);
var qbe = M.memo(Ube);
const Wbe = 200, Gbe = 150, Kbe = (e) => !e.hidden, Xbe = (e) => {
  const t = {
    x: -e.transform[0] / e.transform[2],
    y: -e.transform[1] / e.transform[2],
    width: e.width / e.transform[2],
    height: e.height / e.transform[2]
  };
  return {
    viewBB: t,
    boundingRect: e.nodeLookup.size > 0 ? nU(yS(e.nodeLookup, { filter: Kbe }), t) : t,
    rfId: e.rfId,
    panZoom: e.panZoom,
    translateExtent: e.translateExtent,
    flowWidth: e.width,
    flowHeight: e.height,
    ariaLabelConfig: e.ariaLabelConfig
  };
}, Ybe = "react-flow__minimap-desc";
function tV({
  style: e,
  className: t,
  nodeStrokeColor: n,
  nodeColor: r,
  nodeClassName: a = "",
  nodeBorderRadius: s = 5,
  nodeStrokeWidth: l,
  /*
   * We need to rename the prop to be `CapitalCase` so that JSX will render it as
   * a component properly.
   */
  nodeComponent: c,
  bgColor: d,
  maskColor: p,
  maskStrokeColor: m,
  maskStrokeWidth: h,
  position: v = "bottom-right",
  onClick: y,
  onNodeClick: w,
  pannable: x = !1,
  zoomable: b = !1,
  ariaLabel: k,
  inversePan: C,
  zoomStep: _ = 1,
  offsetScale: O = 5
}) {
  const N = fr(), R = M.useRef(null), { boundingRect: j, viewBB: D, rfId: $, panZoom: z, translateExtent: B, flowWidth: P, flowHeight: W, ariaLabelConfig: I } = un(Xbe, cr), G = e?.width ?? Wbe, L = e?.height ?? Gbe, K = j.width / G, q = j.height / L, Z = Math.max(K, q), V = Z * G, F = Z * L, X = O * Z, U = j.x - (V - j.width) / 2 - X, H = j.y - (F - j.height) / 2 - X, Q = V + X * 2, re = F + X * 2, de = `${Ybe}-${$}`, le = M.useRef(0), me = M.useRef();
  le.current = Z, M.useEffect(() => {
    if (R.current && z)
      return me.current = Sve({
        domNode: R.current,
        panZoom: z,
        getTransform: () => N.getState().transform,
        getViewScale: () => le.current
      }), () => {
        me.current?.destroy();
      };
  }, [z]), M.useEffect(() => {
    me.current?.update({
      translateExtent: B,
      width: P,
      height: W,
      inversePan: C,
      pannable: x,
      zoomStep: _,
      zoomable: b
    });
  }, [x, b, C, _, B, P, W]);
  const ve = y ? (pe) => {
    const [ge, xe] = me.current?.pointer(pe) || [0, 0];
    y(pe, { x: ge, y: xe });
  } : void 0, ae = w ? M.useCallback((pe, ge) => {
    const xe = N.getState().nodeLookup.get(ge).internals.userNode;
    w(pe, xe);
  }, []) : void 0, se = k ?? I["minimap.ariaLabel"];
  return E.jsx(K2, { position: v, style: {
    ...e,
    "--xy-minimap-background-color-props": typeof d == "string" ? d : void 0,
    "--xy-minimap-mask-background-color-props": typeof p == "string" ? p : void 0,
    "--xy-minimap-mask-stroke-color-props": typeof m == "string" ? m : void 0,
    "--xy-minimap-mask-stroke-width-props": typeof h == "number" ? h * Z : void 0,
    "--xy-minimap-node-background-color-props": typeof r == "string" ? r : void 0,
    "--xy-minimap-node-stroke-color-props": typeof n == "string" ? n : void 0,
    "--xy-minimap-node-stroke-width-props": typeof l == "number" ? l : void 0
  }, className: Pr(["react-flow__minimap", t]), "data-testid": "rf__minimap", children: E.jsxs("svg", { width: G, height: L, viewBox: `${U} ${H} ${Q} ${re}`, className: "react-flow__minimap-svg", role: "img", "aria-labelledby": de, ref: R, onClick: ve, children: [se && E.jsx("title", { id: de, children: se }), E.jsx(qbe, { onClick: ae, nodeColor: r, nodeStrokeColor: n, nodeBorderRadius: s, nodeClassName: a, nodeStrokeWidth: l, nodeComponent: c }), E.jsx("path", { className: "react-flow__minimap-mask", d: `M${U - X},${H - X}h${Q + X * 2}v${re + X * 2}h${-Q - X * 2}z
        M${D.x},${D.y}h${D.width}v${D.height}h${-D.width}z`, fillRule: "evenodd", pointerEvents: "none" })] }) });
}
tV.displayName = "MiniMap";
const Qbe = M.memo(tV), Jbe = (e) => (t) => e ? `${Math.max(1 / t.transform[2], 1)}` : void 0, Zbe = {
  [Vh.Line]: "right",
  [Vh.Handle]: "bottom-right"
};
function ewe({ nodeId: e, position: t, variant: n = Vh.Handle, className: r, style: a = void 0, children: s, color: l, minWidth: c = 10, minHeight: d = 10, maxWidth: p = Number.MAX_VALUE, maxHeight: m = Number.MAX_VALUE, keepAspectRatio: h = !1, resizeDirection: v, autoScale: y = !0, shouldResize: w, onResizeStart: x, onResize: b, onResizeEnd: k }) {
  const C = PU(), _ = typeof e == "string" ? e : C, O = fr(), N = M.useRef(null), R = n === Vh.Handle, j = un(M.useCallback(Jbe(R && y), [R, y]), cr), D = M.useRef(null), $ = t ?? Zbe[n];
  M.useEffect(() => {
    if (!(!N.current || !_))
      return D.current || (D.current = Tve({
        domNode: N.current,
        nodeId: _,
        getStoreItems: () => {
          const { nodeLookup: B, transform: P, snapGrid: W, snapToGrid: I, nodeOrigin: G, domNode: L } = O.getState();
          return {
            nodeLookup: B,
            transform: P,
            snapGrid: W,
            snapToGrid: I,
            nodeOrigin: G,
            paneDomNode: L
          };
        },
        onChange: (B, P) => {
          const { triggerNodeChanges: W, nodeLookup: I, parentLookup: G, nodeOrigin: L } = O.getState(), K = [], q = { x: B.x, y: B.y }, Z = I.get(_);
          if (Z && Z.expandParent && Z.parentId) {
            const V = Z.origin ?? L, F = B.width ?? Z.measured.width ?? 0, X = B.height ?? Z.measured.height ?? 0, U = {
              id: Z.id,
              parentId: Z.parentId,
              rect: {
                width: F,
                height: X,
                ...oU({
                  x: B.x ?? Z.position.x,
                  y: B.y ?? Z.position.y
                }, { width: F, height: X }, Z.parentId, I, V)
              }
            }, H = vA([U], I, G, L);
            K.push(...H), q.x = B.x ? Math.max(V[0] * F, B.x) : void 0, q.y = B.y ? Math.max(V[1] * X, B.y) : void 0;
          }
          if (q.x !== void 0 && q.y !== void 0) {
            const V = {
              id: _,
              type: "position",
              position: { ...q }
            };
            K.push(V);
          }
          if (B.width !== void 0 && B.height !== void 0) {
            const V = {
              id: _,
              type: "dimensions",
              resizing: !0,
              setAttributes: v ? v === "horizontal" ? "width" : "height" : !0,
              dimensions: {
                width: B.width,
                height: B.height
              }
            };
            K.push(V);
          }
          for (const V of P) {
            const F = {
              ...V,
              type: "position"
            };
            K.push(F);
          }
          W(K);
        },
        onEnd: ({ width: B, height: P }) => {
          const W = {
            id: _,
            type: "dimensions",
            resizing: !1,
            dimensions: {
              width: B,
              height: P
            }
          };
          O.getState().triggerNodeChanges([W]);
        }
      })), D.current.update({
        controlPosition: $,
        boundaries: {
          minWidth: c,
          minHeight: d,
          maxWidth: p,
          maxHeight: m
        },
        keepAspectRatio: h,
        resizeDirection: v,
        onResizeStart: x,
        onResize: b,
        onResizeEnd: k,
        shouldResize: w
      }), () => {
        D.current?.destroy();
      };
  }, [
    $,
    c,
    d,
    p,
    m,
    h,
    x,
    b,
    k,
    w
  ]);
  const z = $.split("-");
  return E.jsx("div", { className: Pr(["react-flow__resize-control", "nodrag", ...z, n, r]), ref: N, style: {
    ...a,
    scale: j,
    ...l && { [R ? "backgroundColor" : "borderColor"]: l }
  }, children: s });
}
M.memo(ewe);
function twe(e, t) {
  if (Object.is(e, t))
    return !0;
  if (typeof e != "object" || e === null || typeof t != "object" || t === null)
    return !1;
  if (e instanceof Map && t instanceof Map) {
    if (e.size !== t.size) return !1;
    for (const [r, a] of e)
      if (!Object.is(a, t.get(r)))
        return !1;
    return !0;
  }
  if (e instanceof Set && t instanceof Set) {
    if (e.size !== t.size) return !1;
    for (const r of e)
      if (!t.has(r))
        return !1;
    return !0;
  }
  const n = Object.keys(e);
  if (n.length !== Object.keys(t).length)
    return !1;
  for (const r of n)
    if (!Object.prototype.hasOwnProperty.call(t, r) || !Object.is(e[r], t[r]))
      return !1;
  return !0;
}
const { useRef: nwe } = Qn;
function wA(e) {
  const t = nwe();
  return (n) => {
    const r = e(n);
    return twe(t.current, r) ? t.current : t.current = r;
  };
}
const rwe = () => {
  const { group: e } = xa();
  return async (t, n) => {
    if (e)
      return await e.group_nodes(t, n);
  };
}, owe = () => {
  const { group: e } = xa();
  return async (t) => {
    if (e)
      for (const n of t)
        await e.remove_group(n);
  };
}, awe = ({ data: e }) => {
  const t = e?.group?.id || e?.id, n = owe(), r = M.useCallback(
    (a) => {
      a.stopPropagation(), t && n([t]);
    },
    [t, n]
  );
  return /* @__PURE__ */ E.jsxs("div", { className: "fn-group", children: [
    /* @__PURE__ */ E.jsx(
      "button",
      {
        className: "fn-group-remove",
        title: "Remove group",
        onClick: r,
        children: /* @__PURE__ */ E.jsx(_2, {})
      }
    ),
    "Group"
  ] });
}, nV = (e, t) => {
  if (typeof e == "string")
    return e in t ? [t[e], e] : [e, e];
  if ("allOf" in e && e.allOf !== void 0)
    return [void 0, void 0];
  if ("anyOf" in e && e.anyOf !== void 0) {
    const n = e.anyOf.map(
      (r) => nV(r || "any", t)
    );
    for (const r of n)
      switch (r[0]) {
        case "bool":
          return ["bool", r[1]];
        case "enum":
          return ["enum", r[1]];
        case "float":
          return ["float", r[1]];
        case "int":
          return ["int", r[1]];
        case "string":
          return ["string", r[1]];
        case "str":
          return ["string", r[1]];
      }
    return [void 0, void 0];
  }
  return !("type" in e) || e.type === void 0 ? [void 0, void 0] : e.type === "enum" ? ["enum", "enum"] : [void 0, void 0];
}, km = (e, t) => nV(e.render_options?.type ?? "any", t), xA = M.memo(
  ({ value: e }) => {
    const t = e?.toString() ?? "", n = Math.round(3 * t.length / 4);
    return /* @__PURE__ */ E.jsx("div", { children: /* @__PURE__ */ E.jsxs("pre", { children: [
      "Bytes(",
      n,
      ")"
    ] }) });
  }
), rV = M.memo(
  ({ value: e }) => typeof e != "string" ? /* @__PURE__ */ E.jsx("div", { children: "Invalid SVG" }) : /* @__PURE__ */ E.jsx(wce, { value: e })
), oV = ({
  value: e,
  preValue: t,
  onLoaded: n
}) => {
  const [r, a] = M.useState(
    t?.toString() || e?.toString()
  );
  return M.useEffect(() => {
    if (e === t || e == null) return;
    const s = new Image(), l = e.toString();
    return s.onload = () => {
      n?.(), a(l);
    }, s.src = l, () => {
      s.onload = null;
    };
  }, [e, t, n]), r === void 0 ? /* @__PURE__ */ E.jsx(E.Fragment, {}) : typeof r != "string" ? (console.error("ImageRenderer: value is not a string", r), /* @__PURE__ */ E.jsx(E.Fragment, {})) : r.startsWith("data:") || r.startsWith("blob:") ? /* @__PURE__ */ E.jsx(xce, { src: r }) : /* @__PURE__ */ E.jsx(bce, { value: r, format: "jpeg" });
}, iwe = M.memo(
  ({ value: e }) => {
    let t = "";
    try {
      t = JSON.stringify(e);
    } catch {
    }
    return /* @__PURE__ */ E.jsx("div", { children: /* @__PURE__ */ E.jsx("pre", { children: t }) });
  }
), Y2 = ({
  value: e
}) => /* @__PURE__ */ E.jsx(rce, { data: e }), aV = M.memo(
  ({ value: e }) => {
    if (typeof e != "object" || e == null)
      return /* @__PURE__ */ E.jsx("div", { children: "Invalid Table" });
    if (!("columns" in e && "index" in e && "data" in e))
      return /* @__PURE__ */ E.jsx("div", { children: "Invalid Table" });
    if (!Array.isArray(e.columns) || !Array.isArray(e.index) || !Array.isArray(e.data) || !e.data.every((n) => Array.isArray(n)))
      return /* @__PURE__ */ E.jsx("div", { children: "Invalid Table" });
    const t = {
      columns: e.columns || [],
      index: e.index || [],
      data: e.data || []
    };
    return /* @__PURE__ */ E.jsx(g9, { tabledata: t });
  }
), E_ = (e) => /* @__PURE__ */ E.jsx(iwe, { ...e }), C_ = Y2, SA = {
  string: E_,
  str: E_,
  table: aV,
  image: oV,
  svg: rV,
  dict: Y2,
  bytes: xA
}, Q2 = M.createContext({}), ki = () => M.useContext(Q2), dd = M.createContext(void 0);
function dr(e) {
  if (e)
    return ki().io_stores.get(e);
  {
    const t = M.useContext(dd);
    if (!t)
      throw new Error("IOContext not set");
    return t;
  }
}
const swe = () => {
  const e = dr(), { full: t, preview: n } = e.valuestore(), r = JSON.stringify(t?.value || n?.value) || "";
  return `Bytes(${Math.round(3 * r.length / 4)})`;
}, lwe = {
  bytes: swe
}, J2 = (e) => ({ value: t, preValue: n, onLoaded: r }) => /* @__PURE__ */ E.jsx(e, { value: t, preValue: n, onLoaded: r }), Ea = (e, t = void 0, n = {}) => ({}) => {
  const r = dr(), { full: a, preview: s } = r.valuestore(), l = (a === void 0 ? s : a)?.value || t;
  return /* @__PURE__ */ E.jsx(e, { value: l, ...n });
}, iV = (e) => ({}) => /* @__PURE__ */ E.jsx(e, {}), sV = (e, t = void 0) => ({}) => {
  const n = dr(), { full: r, preview: a } = n.valuestore(), s = (r === void 0 ? a : r)?.value || t;
  return /* @__PURE__ */ E.jsx(e, { value: s });
}, uwe = {
  ...Object.fromEntries(
    Object.entries(SA).map(([e, t]) => [
      e,
      t ? J2(t) : void 0
    ])
  )
}, P$ = J2(Y2), lV = {
  ...Object.fromEntries(
    Object.entries(SA).map(([e, t]) => [
      e,
      t ? Ea(t) : void 0
    ])
  ),
  string: Ea(E_),
  str: Ea(E_),
  table: Ea(aV, void 0, {
    pageSize: 10
  }),
  image: Ea(oV),
  svg: Ea(rV, ""),
  dict: Ea(Y2, "{}"),
  bytes: Ea(xA, "")
}, cwe = {
  ...Object.fromEntries(
    Object.entries(lV).map(([e, t]) => [
      e,
      t ? iV(t) : void 0
    ])
  )
}, dwe = () => {
  const e = dr(), { preview: t, full: n } = e.valuestore();
  let r = (JSON.stringify(n || t) || "").replace(/\\n/g, `
`);
  return r.length > 63 && (r = r.slice(0, 60) + "..."), /* @__PURE__ */ E.jsx("div", { children: r });
}, fwe = {};
function _m(e) {
  const { node: t } = xa();
  if (e || (e = dr().use()), typeof e == "string" && (e = dr(e)?.use(), !e))
    throw new Error(`No IO found for ${e}`);
  if (!e)
    throw new Error("No IO found");
  return M.useCallback(
    (n, r) => {
      t?.set_io_value({
        nid: e.node,
        ioid: e.id,
        value: n,
        set_default: r ?? e.render_options.set_default
      });
    },
    [e, t]
  );
}
function pwe(e) {
  const { node: t } = xa();
  let n, r;
  if (!e) {
    const a = dr().useShallow((s) => ({
      io_id: s.id,
      node_id: s.node
    }));
    n = a.io_id, r = a.node_id;
  }
  if (typeof e == "string") {
    const a = dr(e);
    if (!a)
      throw new Error(`No IO found for ${e}`);
    const s = a.useShallow((l) => ({
      io_id: l.id,
      node_id: l.node
    }));
    n = s.io_id, r = s.node_id;
  } else {
    if (!e)
      throw new Error("No IO found");
    n = e.id, r = e.node;
  }
  return M.useCallback(
    (a) => {
      t?.set_io_value_options({
        nid: r,
        ioid: n,
        values: a.values ?? a.keys,
        keys: a.keys,
        nullable: a.nullable ?? !1
      });
    },
    [t, n, r]
  );
}
function mwe(e) {
  return dr(e)?.valuestore();
}
function SS(e) {
  const t = dr(e);
  if (!t) return;
  const { node: n, id: r } = t.useShallow((s) => ({
    node: s.node,
    id: s.id
  })), { node: a } = xa();
  return M.useCallback(async () => {
    const s = await a?.get_io_full_value({ nid: n, ioid: r });
    return t.updateValueStore({ full: s }), s;
  }, [a, n, r]);
}
function kA(e) {
  const t = dr(e);
  if (!t) return;
  const { node: n, id: r } = t.useShallow((s) => ({
    node: s.node,
    id: s.id
  })), { node: a } = xa();
  return M.useCallback(
    (s) => {
      a?.update_io_options({
        nid: n,
        ioid: r,
        options: { hidden: s }
      });
    },
    [a, n, r]
  );
}
const hwe = ({ inputconverter: e }) => {
  const t = dr(), { preview: n } = t.valuestore(), r = t.use(), a = n?.value === void 0, s = M.useRef(null), l = _m(r);
  M.useEffect(() => {
    s.current && (s.current.indeterminate = a);
  }, [s, a]);
  const c = M.useCallback(
    (d) => {
      let p = d.target.checked;
      try {
        p = e[0](d.target.checked);
      } catch {
      }
      l(p);
    },
    [l, e]
  );
  return /* @__PURE__ */ E.jsx(
    "input",
    {
      ref: s,
      type: "checkbox",
      className: "styledcheckbox booleaninput",
      checked: !!e[1](n?.value),
      onChange: c,
      disabled: r.connected
    }
  );
}, gwe = ({}) => {
  const e = dr(), t = yn(), n = e.use(), { preview: r, full: a } = e.valuestore(), s = a === void 0 ? r?.value : a.value, l = _m(n), c = typeof s == "string" || Array.isArray(s) && s.every((v) => typeof v == "number") ? s : void 0, d = n.value_options?.colorspace || "hex", p = M.useCallback(
    (v) => {
      let y = "<NoValue>";
      v && (v[d] ? y = v[d]() : y = v.hex()), v === null && (y = null);
      try {
        y = y;
      } catch {
      }
      l(y);
    },
    [l, d]
  );
  let m = !1;
  typeof n.type != "string" && "anyOf" in n.type && n.type.anyOf !== void 0 && (m = n.type.anyOf.some((v) => v === "None"));
  const h = t.local_state(() => t.reactflowRef);
  return /* @__PURE__ */ E.jsx(
    sse,
    {
      onChange: p,
      inicolordata: c,
      allow_null: m,
      inicolorspace: d,
      portalContainer: h
    }
  );
};
function uV(e, [t, n]) {
  return Math.min(n, Math.max(t, e));
}
var vwe = M.createContext(void 0);
function Z2(e) {
  const t = M.useContext(vwe);
  return e || t || "ltr";
}
function ywe(e) {
  const t = M.useRef({ value: e, previous: e });
  return M.useMemo(() => (t.current.value !== e && (t.current.previous = t.current.value, t.current.value = e), t.current.previous), [e]);
}
var cV = ["PageUp", "PageDown"], dV = ["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight"], fV = {
  "from-left": ["Home", "PageDown", "ArrowDown", "ArrowLeft"],
  "from-right": ["Home", "PageDown", "ArrowDown", "ArrowRight"],
  "from-bottom": ["Home", "PageDown", "ArrowDown", "ArrowLeft"],
  "from-top": ["Home", "PageDown", "ArrowUp", "ArrowLeft"]
}, sg = "Slider", [W5, bwe, wwe] = A2(sg), [pV] = jl(sg, [
  wwe
]), [xwe, eE] = pV(sg), mV = M.forwardRef(
  (e, t) => {
    const {
      name: n,
      min: r = 0,
      max: a = 100,
      step: s = 1,
      orientation: l = "horizontal",
      disabled: c = !1,
      minStepsBetweenThumbs: d = 0,
      defaultValue: p = [r],
      value: m,
      onValueChange: h = () => {
      },
      onValueCommit: v = () => {
      },
      inverted: y = !1,
      form: w,
      ...x
    } = e, b = M.useRef(/* @__PURE__ */ new Set()), k = M.useRef(0), C = l === "horizontal" ? Swe : kwe, [_ = [], O] = gd({
      prop: m,
      defaultProp: p,
      onChange: (z) => {
        [...b.current][k.current]?.focus(), h(z);
      }
    }), N = M.useRef(_);
    function R(z) {
      const B = Mwe(_, z);
      $(z, B);
    }
    function j(z) {
      $(z, k.current);
    }
    function D() {
      const z = N.current[k.current];
      _[k.current] !== z && v(_);
    }
    function $(z, B, { commit: P } = { commit: !1 }) {
      const W = jwe(s), I = Pwe(Math.round((z - r) / s) * s + r, W), G = uV(I, [r, a]);
      O((L = []) => {
        const K = Cwe(L, G, B);
        if (Awe(K, d * s)) {
          k.current = K.indexOf(G);
          const q = String(K) !== String(L);
          return q && P && v(K), q ? K : L;
        } else
          return L;
      });
    }
    return /* @__PURE__ */ E.jsx(
      xwe,
      {
        scope: e.__scopeSlider,
        name: n,
        disabled: c,
        min: r,
        max: a,
        valueIndexToChangeRef: k,
        thumbs: b.current,
        values: _,
        orientation: l,
        form: w,
        children: /* @__PURE__ */ E.jsx(W5.Provider, { scope: e.__scopeSlider, children: /* @__PURE__ */ E.jsx(W5.Slot, { scope: e.__scopeSlider, children: /* @__PURE__ */ E.jsx(
          C,
          {
            "aria-disabled": c,
            "data-disabled": c ? "" : void 0,
            ...x,
            ref: t,
            onPointerDown: Ze(x.onPointerDown, () => {
              c || (N.current = _);
            }),
            min: r,
            max: a,
            inverted: y,
            onSlideStart: c ? void 0 : R,
            onSlideMove: c ? void 0 : j,
            onSlideEnd: c ? void 0 : D,
            onHomeKeyDown: () => !c && $(r, 0, { commit: !0 }),
            onEndKeyDown: () => !c && $(a, _.length - 1, { commit: !0 }),
            onStepKeyDown: ({ event: z, direction: B }) => {
              if (!c) {
                const P = cV.includes(z.key) || z.shiftKey && dV.includes(z.key) ? 10 : 1, W = k.current, I = _[W], G = s * P * B;
                $(I + G, W, { commit: !0 });
              }
            }
          }
        ) }) })
      }
    );
  }
);
mV.displayName = sg;
var [hV, gV] = pV(sg, {
  startEdge: "left",
  endEdge: "right",
  size: "width",
  direction: 1
}), Swe = M.forwardRef(
  (e, t) => {
    const {
      min: n,
      max: r,
      dir: a,
      inverted: s,
      onSlideStart: l,
      onSlideMove: c,
      onSlideEnd: d,
      onStepKeyDown: p,
      ...m
    } = e, [h, v] = M.useState(null), y = Wn(t, (_) => v(_)), w = M.useRef(void 0), x = Z2(a), b = x === "ltr", k = b && !s || !b && s;
    function C(_) {
      const O = w.current || h.getBoundingClientRect(), N = [0, O.width], R = _A(N, k ? [n, r] : [r, n]);
      return w.current = O, R(_ - O.left);
    }
    return /* @__PURE__ */ E.jsx(
      hV,
      {
        scope: e.__scopeSlider,
        startEdge: k ? "left" : "right",
        endEdge: k ? "right" : "left",
        direction: k ? 1 : -1,
        size: "width",
        children: /* @__PURE__ */ E.jsx(
          vV,
          {
            dir: x,
            "data-orientation": "horizontal",
            ...m,
            ref: y,
            style: {
              ...m.style,
              "--radix-slider-thumb-transform": "translateX(-50%)"
            },
            onSlideStart: (_) => {
              const O = C(_.clientX);
              l?.(O);
            },
            onSlideMove: (_) => {
              const O = C(_.clientX);
              c?.(O);
            },
            onSlideEnd: () => {
              w.current = void 0, d?.();
            },
            onStepKeyDown: (_) => {
              const O = fV[k ? "from-left" : "from-right"].includes(_.key);
              p?.({ event: _, direction: O ? -1 : 1 });
            }
          }
        )
      }
    );
  }
), kwe = M.forwardRef(
  (e, t) => {
    const {
      min: n,
      max: r,
      inverted: a,
      onSlideStart: s,
      onSlideMove: l,
      onSlideEnd: c,
      onStepKeyDown: d,
      ...p
    } = e, m = M.useRef(null), h = Wn(t, m), v = M.useRef(void 0), y = !a;
    function w(x) {
      const b = v.current || m.current.getBoundingClientRect(), k = [0, b.height], C = _A(k, y ? [r, n] : [n, r]);
      return v.current = b, C(x - b.top);
    }
    return /* @__PURE__ */ E.jsx(
      hV,
      {
        scope: e.__scopeSlider,
        startEdge: y ? "bottom" : "top",
        endEdge: y ? "top" : "bottom",
        size: "height",
        direction: y ? 1 : -1,
        children: /* @__PURE__ */ E.jsx(
          vV,
          {
            "data-orientation": "vertical",
            ...p,
            ref: h,
            style: {
              ...p.style,
              "--radix-slider-thumb-transform": "translateY(50%)"
            },
            onSlideStart: (x) => {
              const b = w(x.clientY);
              s?.(b);
            },
            onSlideMove: (x) => {
              const b = w(x.clientY);
              l?.(b);
            },
            onSlideEnd: () => {
              v.current = void 0, c?.();
            },
            onStepKeyDown: (x) => {
              const b = fV[y ? "from-bottom" : "from-top"].includes(x.key);
              d?.({ event: x, direction: b ? -1 : 1 });
            }
          }
        )
      }
    );
  }
), vV = M.forwardRef(
  (e, t) => {
    const {
      __scopeSlider: n,
      onSlideStart: r,
      onSlideMove: a,
      onSlideEnd: s,
      onHomeKeyDown: l,
      onEndKeyDown: c,
      onStepKeyDown: d,
      ...p
    } = e, m = eE(sg, n);
    return /* @__PURE__ */ E.jsx(
      Kt.span,
      {
        ...p,
        ref: t,
        onKeyDown: Ze(e.onKeyDown, (h) => {
          h.key === "Home" ? (l(h), h.preventDefault()) : h.key === "End" ? (c(h), h.preventDefault()) : cV.concat(dV).includes(h.key) && (d(h), h.preventDefault());
        }),
        onPointerDown: Ze(e.onPointerDown, (h) => {
          const v = h.target;
          v.setPointerCapture(h.pointerId), h.preventDefault(), m.thumbs.has(v) ? v.focus() : r(h);
        }),
        onPointerMove: Ze(e.onPointerMove, (h) => {
          h.target.hasPointerCapture(h.pointerId) && a(h);
        }),
        onPointerUp: Ze(e.onPointerUp, (h) => {
          const v = h.target;
          v.hasPointerCapture(h.pointerId) && (v.releasePointerCapture(h.pointerId), s(h));
        })
      }
    );
  }
), yV = "SliderTrack", bV = M.forwardRef(
  (e, t) => {
    const { __scopeSlider: n, ...r } = e, a = eE(yV, n);
    return /* @__PURE__ */ E.jsx(
      Kt.span,
      {
        "data-disabled": a.disabled ? "" : void 0,
        "data-orientation": a.orientation,
        ...r,
        ref: t
      }
    );
  }
);
bV.displayName = yV;
var G5 = "SliderRange", wV = M.forwardRef(
  (e, t) => {
    const { __scopeSlider: n, ...r } = e, a = eE(G5, n), s = gV(G5, n), l = M.useRef(null), c = Wn(t, l), d = a.values.length, p = a.values.map(
      (v) => kV(v, a.min, a.max)
    ), m = d > 1 ? Math.min(...p) : 0, h = 100 - Math.max(...p);
    return /* @__PURE__ */ E.jsx(
      Kt.span,
      {
        "data-orientation": a.orientation,
        "data-disabled": a.disabled ? "" : void 0,
        ...r,
        ref: c,
        style: {
          ...e.style,
          [s.startEdge]: m + "%",
          [s.endEdge]: h + "%"
        }
      }
    );
  }
);
wV.displayName = G5;
var K5 = "SliderThumb", xV = M.forwardRef(
  (e, t) => {
    const n = bwe(e.__scopeSlider), [r, a] = M.useState(null), s = Wn(t, (c) => a(c)), l = M.useMemo(
      () => r ? n().findIndex((c) => c.ref.current === r) : -1,
      [n, r]
    );
    return /* @__PURE__ */ E.jsx(_we, { ...e, ref: s, index: l });
  }
), _we = M.forwardRef(
  (e, t) => {
    const { __scopeSlider: n, index: r, name: a, ...s } = e, l = eE(K5, n), c = gV(K5, n), [d, p] = M.useState(null), m = Wn(t, (C) => p(C)), h = d ? l.form || !!d.closest("form") : !0, v = v8(d), y = l.values[r], w = y === void 0 ? 0 : kV(y, l.min, l.max), x = Owe(r, l.values.length), b = v?.[c.size], k = b ? Nwe(b, w, c.direction) : 0;
    return M.useEffect(() => {
      if (d)
        return l.thumbs.add(d), () => {
          l.thumbs.delete(d);
        };
    }, [d, l.thumbs]), /* @__PURE__ */ E.jsxs(
      "span",
      {
        style: {
          transform: "var(--radix-slider-thumb-transform)",
          position: "absolute",
          [c.startEdge]: `calc(${w}% + ${k}px)`
        },
        children: [
          /* @__PURE__ */ E.jsx(W5.ItemSlot, { scope: e.__scopeSlider, children: /* @__PURE__ */ E.jsx(
            Kt.span,
            {
              role: "slider",
              "aria-label": e["aria-label"] || x,
              "aria-valuemin": l.min,
              "aria-valuenow": y,
              "aria-valuemax": l.max,
              "aria-orientation": l.orientation,
              "data-orientation": l.orientation,
              "data-disabled": l.disabled ? "" : void 0,
              tabIndex: l.disabled ? void 0 : 0,
              ...s,
              ref: m,
              style: y === void 0 ? { display: "none" } : e.style,
              onFocus: Ze(e.onFocus, () => {
                l.valueIndexToChangeRef.current = r;
              })
            }
          ) }),
          h && /* @__PURE__ */ E.jsx(
            SV,
            {
              name: a ?? (l.name ? l.name + (l.values.length > 1 ? "[]" : "") : void 0),
              form: l.form,
              value: y
            },
            r
          )
        ]
      }
    );
  }
);
xV.displayName = K5;
var Ewe = "RadioBubbleInput", SV = M.forwardRef(
  ({ __scopeSlider: e, value: t, ...n }, r) => {
    const a = M.useRef(null), s = Wn(a, r), l = ywe(t);
    return M.useEffect(() => {
      const c = a.current;
      if (!c) return;
      const d = window.HTMLInputElement.prototype, p = Object.getOwnPropertyDescriptor(d, "value").set;
      if (l !== t && p) {
        const m = new Event("input", { bubbles: !0 });
        p.call(c, t), c.dispatchEvent(m);
      }
    }, [l, t]), /* @__PURE__ */ E.jsx(
      Kt.input,
      {
        style: { display: "none" },
        ...n,
        ref: s,
        defaultValue: t
      }
    );
  }
);
SV.displayName = Ewe;
function Cwe(e = [], t, n) {
  const r = [...e];
  return r[n] = t, r.sort((a, s) => a - s);
}
function kV(e, t, n) {
  const r = 100 / (n - t) * (e - t);
  return uV(r, [0, 100]);
}
function Owe(e, t) {
  return t > 2 ? `Value ${e + 1} of ${t}` : t === 2 ? ["Minimum", "Maximum"][e] : void 0;
}
function Mwe(e, t) {
  if (e.length === 1) return 0;
  const n = e.map((a) => Math.abs(a - t)), r = Math.min(...n);
  return n.indexOf(r);
}
function Nwe(e, t, n) {
  const r = e / 2, a = _A([0, 50], [0, r]);
  return (r - a(t) * n) * n;
}
function Rwe(e) {
  return e.slice(0, -1).map((t, n) => e[n + 1] - t);
}
function Awe(e, t) {
  if (t > 0) {
    const n = Rwe(e);
    return Math.min(...n) >= t;
  }
  return !0;
}
function _A(e, t) {
  return (n) => {
    if (e[0] === e[1] || t[0] === t[1]) return t[0];
    const r = (t[1] - t[0]) / (e[1] - e[0]);
    return t[0] + r * (n - e[0]);
  };
}
function jwe(e) {
  return (String(e).split(".")[1] || "").length;
}
function Pwe(e, t) {
  const n = Math.pow(10, t);
  return Math.round(e * n) / n;
}
var Dwe = mV, $we = bV, Twe = wV, Lwe = xV;
function Iwe(e) {
  return e === 0 ? 0 : Math.abs(e) < 1e-12 ? e : Number(e.toPrecision(12));
}
const _V = ({
  inputconverter: e,
  parser: t = (n) => parseFloat(n)
}) => {
  const n = dr(), { preview: r } = n.valuestore(), a = n.use(), s = _m(a), [l, c] = M.useState(
    e[1](r?.value)
  );
  M.useEffect(() => {
    c(e[1](r?.value));
  }, [r]);
  const d = M.useCallback(
    (y) => {
      y = t(
        parseFloat(y.toString()).toString()
        // parse float first for e notation
      ), isNaN(y) ? (y = "<NoValue>", c("")) : (a.value_options?.min !== void 0 && y < a.value_options.min && (y = a.value_options.min), a.value_options?.max !== void 0 && y > a.value_options.max && (y = a.value_options.max), y = Iwe(y), c(y.toString()));
      try {
        y = e[0](y);
      } catch {
      }
      y !== r?.value && s(y);
    },
    [a, e, s]
  ), p = M.useCallback(
    (y) => {
      d(y.target.value);
    },
    [d]
  );
  let m = a.connected ? e[1](r?.value) : l;
  m === void 0 && (m = a.value_options?.min), m === void 0 && (m = a.value_options?.max), m === void 0 && (m = ""), m === null && (m = "");
  let h = null, v = 1;
  return a.value_options?.step !== void 0 ? v = a.value_options.step : a.value_options?.max !== void 0 && a.value_options?.min !== void 0 && (v = (a.value_options?.max - a.value_options?.min) / 1e3), a.value_options?.max !== void 0 && a.value_options?.min !== void 0 && !a.connected && (h = /* @__PURE__ */ E.jsx("div", { style: { minWidth: "6.25rem" }, className: "SliderContainer", children: /* @__PURE__ */ E.jsxs(
    Dwe,
    {
      className: "SliderRoot",
      value: [m === void 0 ? a.value_options?.min : m],
      min: a.value_options?.min,
      max: a.value_options?.max,
      step: v,
      disabled: a.connected,
      onValueCommit: (y) => {
        isNaN(y[0]) || d(y[0]);
      },
      onValueChange: (y) => {
        isNaN(y[0]) || c(y[0].toString());
      },
      onKeyDown: (y) => {
        ["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight"].includes(
          y.key
        ) && y.stopPropagation();
      },
      children: [
        /* @__PURE__ */ E.jsx($we, { className: "SliderTrack", children: /* @__PURE__ */ E.jsx(Twe, { className: "SliderRange" }) }),
        /* @__PURE__ */ E.jsx(Lwe, { className: "SliderThumb" })
      ]
    }
  ) })), /* @__PURE__ */ E.jsxs(E.Fragment, { children: [
    h,
    /* @__PURE__ */ E.jsx(
      "input",
      {
        type: "text",
        className: "nodedatainput styledinput numberinput",
        value: m,
        onChange: (y) => c(y.target.value),
        onBlur: p,
        step: v,
        onKeyDown: (y) => {
          if (!(y.ctrlKey || y.metaKey)) {
            if (y.key === "ArrowUp") {
              y.shiftKey && (v *= 10);
              let w = (parseFloat(m) || 0) + v;
              d(w);
              return;
            }
            if (y.key === "ArrowDown") {
              y.shiftKey && (v *= 10);
              let w = (parseFloat(m) || 0) - v;
              d(w);
              return;
            }
            !/^[0-9.eE+-]$/.test(y.key) && !["Backspace", "ArrowLeft", "ArrowRight", "Delete", "Tab"].includes(
              y.key
            ) && y.preventDefault();
          }
        },
        disabled: a.connected,
        min: a.value_options?.min,
        max: a.value_options?.max
      }
    )
  ] });
}, zwe = ({ inputconverter: e }) => _V({ inputconverter: e, parser: parseFloat }), Fwe = ({ inputconverter: e }) => _V({ inputconverter: e, parser: parseInt }), Bwe = (e) => e, Uwe = (e) => parseFloat(e), Vwe = (e) => !!e, Hwe = (e) => e === "null" ? null : e, qwe = (e) => e === "nuinputconvertermber" ? Uwe : e === "boolean" ? Vwe : e === "undefined" ? Hwe : Bwe, Nx = ({
  inputconverter: e,
  parser: t
}) => {
  const n = dr(), r = n.use(), { preview: a, full: s } = n.valuestore(), l = s === void 0 ? a?.value : s.value, c = _m(r);
  let d = r.value_options?.options || [];
  Array.isArray(d) && (d = {
    type: "enum",
    values: d,
    keys: d.map((x) => x === null ? "None" : x.toString()),
    nullable: !1
  }), d.type !== "enum" && (d = {
    type: "enum",
    values: Object.values(d),
    keys: Object.keys(d),
    nullable: !1
  }), d = d, d.nullable && !d.values.includes(null) && !d.keys.includes("None") && (d.values.unshift(null), d.keys.unshift("None"));
  const p = [];
  for (let x = 0; x < d.values.length; x++) {
    const b = d.values[x] === null || d.values[x] === void 0 ? "undefined" : typeof d.values[x];
    let k = d.values[x];
    k === null && (k = "null"), k === void 0 && (k = "undefined"), p.push([d.keys[x], k.toString(), b]);
  }
  const m = M.useCallback(
    ({
      value: x,
      // label
      datatype: b
    }) => {
      let k = (t || qwe(b))(x);
      try {
        k = e[0](x);
      } catch {
      }
      c(k);
    },
    [r, e, c]
  );
  let h = l;
  h === null && (h = "null"), h === void 0 && (h = "undefined");
  const v = p.find((x) => x[1] === h.toString());
  let y;
  v !== void 0 && (y = {
    value: v[1],
    label: v[0],
    datatype: v[2]
  });
  const w = p.map(
    (x) => ({
      value: x[1],
      label: x[0],
      datatype: x[2]
    })
  );
  return (
    // <Suspense fallback={<select disabled={true}></select>}>
    /* @__PURE__ */ E.jsx(
      Fue,
      {
        className: "nodedatainput styleddropdown",
        options: w,
        defaultValue: y,
        onChange: (x) => {
          if (x === null) {
            m({
              value: "<NoValue>",
              datatype: "string"
            });
            return;
          }
          m(x);
        }
      }
    )
  );
}, D$ = ({ inputconverter: e }) => {
  const t = dr(), { preview: n, full: r } = t.valuestore(), a = t.use(), s = r === void 0 ? n?.value : r?.value, l = _m(a), [c, d] = M.useState(e[1](s));
  M.useEffect(() => {
    d(e[1](s));
  }, [s]);
  const p = M.useCallback(
    (y) => {
      let w = y.target.value;
      w || (w = "<NoValue>");
      try {
        w = e[0](w);
      } catch {
      }
      w !== s && l(w);
    },
    [l, e, s]
  );
  let m = a.connected ? e[1](s) : c;
  m == null && (m = ""), m = m.toString();
  const h = (m.toString().match(/\n/g) || []).length, v = Math.max(...m.split(`
`).map((y) => y.length), 0);
  return /* @__PURE__ */ E.jsx(
    "textarea",
    {
      className: "nodedatainput styledinput stringinput",
      value: m,
      onChange: (y) => d(y.target.value),
      onBlur: (y) => {
        p(y);
      },
      disabled: a.connected,
      rows: h + 1,
      cols: v + 1
    }
  );
};
function on(e) {
  return typeof e != "object" || e === null || typeof e.lastModified == "number" && typeof File < "u" && e instanceof File || typeof e.getMonth == "function" && typeof Date < "u" && e instanceof Date ? !1 : !Array.isArray(e);
}
function Wwe(e) {
  return e.additionalItems === !0 && console.warn("additionalItems=true is currently not supported"), on(e.additionalItems);
}
function $$(e) {
  if (e === "")
    return;
  if (e === null)
    return null;
  if (/\.$/.test(e) || /\.0$/.test(e) || /\.\d*0$/.test(e))
    return e;
  const t = Number(e);
  return typeof t == "number" && !Number.isNaN(t) ? t : e;
}
const hc = "__additional_property", O_ = "additionalProperties", fd = "allOf", sn = "anyOf", Di = "const", tE = "default", EA = "dependencies", Gwe = "enum", Po = "__errors", $n = "$id", Kwe = "if", Hh = "items", Xwe = "_$junk_option_schema_id$_", T0 = "$name", Ht = "oneOf", X5 = "patternProperties", fn = "properties", UM = "readonly", EV = "required", M_ = "submitButtonOptions", sr = "$ref", Lw = "$schema", CV = "root", OV = "_", Ywe = ["discriminator", "propertyName"], T$ = "formContext", Qwe = "layoutGridLookupMap", CA = "__rjsf_additionalProperties", MV = "__rjsf_rootSchema", Jwe = "ui:field", OA = "ui:widget", Zc = "ui:options", Y5 = "ui:globalOptions", Zwe = "https://json-schema.org/draft/2019-09/schema", L0 = "https://json-schema.org/draft/2020-12/schema";
function ht(e = {}, t = {}) {
  return e ? Object.keys(e).filter((n) => n.indexOf("ui:") === 0).reduce((n, r) => {
    const a = e[r];
    return r === OA && on(a) ? (console.error("Setting options via ui:widget object is no longer supported, use ui:options instead"), n) : r === Zc && on(a) ? { ...n, ...a } : { ...n, [r.substring(3)]: a };
  }, { ...t }) : { ...t };
}
function NV(e, t = {}, n) {
  if (!(e.additionalProperties || e.patternProperties))
    return !1;
  const { expandable: r = !0 } = ht(t);
  return r === !1 ? r : e.maxProperties !== void 0 && n ? Object.keys(n).length < e.maxProperties : !0;
}
var RV = typeof Nw == "object" && Nw && Nw.Object === Object && Nw, exe = typeof self == "object" && self && self.Object === Object && self, Tl = RV || exe || Function("return this")(), $i = Tl.Symbol, AV = Object.prototype, txe = AV.hasOwnProperty, nxe = AV.toString, pw = $i ? $i.toStringTag : void 0;
function rxe(e) {
  var t = txe.call(e, pw), n = e[pw];
  try {
    e[pw] = void 0;
    var r = !0;
  } catch {
  }
  var a = nxe.call(e);
  return r && (t ? e[pw] = n : delete e[pw]), a;
}
var oxe = Object.prototype, axe = oxe.toString;
function ixe(e) {
  return axe.call(e);
}
var sxe = "[object Null]", lxe = "[object Undefined]", L$ = $i ? $i.toStringTag : void 0;
function jc(e) {
  return e == null ? e === void 0 ? lxe : sxe : L$ && L$ in Object(e) ? rxe(e) : ixe(e);
}
function jV(e, t) {
  return function(n) {
    return e(t(n));
  };
}
var nE = jV(Object.getPrototypeOf, Object);
function Ti(e) {
  return e != null && typeof e == "object";
}
var uxe = "[object Object]", cxe = Function.prototype, dxe = Object.prototype, PV = cxe.toString, fxe = dxe.hasOwnProperty, pxe = PV.call(Object);
function pd(e) {
  if (!Ti(e) || jc(e) != uxe)
    return !1;
  var t = nE(e);
  if (t === null)
    return !0;
  var n = fxe.call(t, "constructor") && t.constructor;
  return typeof n == "function" && n instanceof n && PV.call(n) == pxe;
}
function Q5(e) {
  const t = {
    // We store the list of errors for this node in a property named __errors
    // to avoid name collision with a possible sub schema field named
    // 'errors' (see `utils.toErrorSchema`).
    [Po]: [],
    addError(n) {
      this[Po].push(n);
    }
  };
  if (Array.isArray(e))
    return e.reduce((n, r, a) => ({ ...n, [a]: Q5(r) }), t);
  if (pd(e)) {
    const n = e;
    return Object.keys(n).reduce((r, a) => ({ ...r, [a]: Q5(n[a]) }), t);
  }
  return t;
}
function mxe() {
  this.__data__ = [], this.size = 0;
}
function kS(e, t) {
  return e === t || e !== e && t !== t;
}
function rE(e, t) {
  for (var n = e.length; n--; )
    if (kS(e[n][0], t))
      return n;
  return -1;
}
var hxe = Array.prototype, gxe = hxe.splice;
function vxe(e) {
  var t = this.__data__, n = rE(t, e);
  if (n < 0)
    return !1;
  var r = t.length - 1;
  return n == r ? t.pop() : gxe.call(t, n, 1), --this.size, !0;
}
function yxe(e) {
  var t = this.__data__, n = rE(t, e);
  return n < 0 ? void 0 : t[n][1];
}
function bxe(e) {
  return rE(this.__data__, e) > -1;
}
function wxe(e, t) {
  var n = this.__data__, r = rE(n, e);
  return r < 0 ? (++this.size, n.push([e, t])) : n[r][1] = t, this;
}
function Pc(e) {
  var t = -1, n = e == null ? 0 : e.length;
  for (this.clear(); ++t < n; ) {
    var r = e[t];
    this.set(r[0], r[1]);
  }
}
Pc.prototype.clear = mxe;
Pc.prototype.delete = vxe;
Pc.prototype.get = yxe;
Pc.prototype.has = bxe;
Pc.prototype.set = wxe;
function xxe() {
  this.__data__ = new Pc(), this.size = 0;
}
function Sxe(e) {
  var t = this.__data__, n = t.delete(e);
  return this.size = t.size, n;
}
function kxe(e) {
  return this.__data__.get(e);
}
function _xe(e) {
  return this.__data__.has(e);
}
function cn(e) {
  var t = typeof e;
  return e != null && (t == "object" || t == "function");
}
var Exe = "[object AsyncFunction]", Cxe = "[object Function]", Oxe = "[object GeneratorFunction]", Mxe = "[object Proxy]";
function _S(e) {
  if (!cn(e))
    return !1;
  var t = jc(e);
  return t == Cxe || t == Oxe || t == Exe || t == Mxe;
}
var VM = Tl["__core-js_shared__"], I$ = (function() {
  var e = /[^.]+$/.exec(VM && VM.keys && VM.keys.IE_PROTO || "");
  return e ? "Symbol(src)_1." + e : "";
})();
function Nxe(e) {
  return !!I$ && I$ in e;
}
var Rxe = Function.prototype, Axe = Rxe.toString;
function Em(e) {
  if (e != null) {
    try {
      return Axe.call(e);
    } catch {
    }
    try {
      return e + "";
    } catch {
    }
  }
  return "";
}
var jxe = /[\\^$.*+?()[\]{}|]/g, Pxe = /^\[object .+?Constructor\]$/, Dxe = Function.prototype, $xe = Object.prototype, Txe = Dxe.toString, Lxe = $xe.hasOwnProperty, Ixe = RegExp(
  "^" + Txe.call(Lxe).replace(jxe, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
);
function zxe(e) {
  if (!cn(e) || Nxe(e))
    return !1;
  var t = _S(e) ? Ixe : Pxe;
  return t.test(Em(e));
}
function Fxe(e, t) {
  return e?.[t];
}
function Cm(e, t) {
  var n = Fxe(e, t);
  return zxe(n) ? n : void 0;
}
var Rx = Cm(Tl, "Map"), Ax = Cm(Object, "create");
function Bxe() {
  this.__data__ = Ax ? Ax(null) : {}, this.size = 0;
}
function Uxe(e) {
  var t = this.has(e) && delete this.__data__[e];
  return this.size -= t ? 1 : 0, t;
}
var Vxe = "__lodash_hash_undefined__", Hxe = Object.prototype, qxe = Hxe.hasOwnProperty;
function Wxe(e) {
  var t = this.__data__;
  if (Ax) {
    var n = t[e];
    return n === Vxe ? void 0 : n;
  }
  return qxe.call(t, e) ? t[e] : void 0;
}
var Gxe = Object.prototype, Kxe = Gxe.hasOwnProperty;
function Xxe(e) {
  var t = this.__data__;
  return Ax ? t[e] !== void 0 : Kxe.call(t, e);
}
var Yxe = "__lodash_hash_undefined__";
function Qxe(e, t) {
  var n = this.__data__;
  return this.size += this.has(e) ? 0 : 1, n[e] = Ax && t === void 0 ? Yxe : t, this;
}
function gm(e) {
  var t = -1, n = e == null ? 0 : e.length;
  for (this.clear(); ++t < n; ) {
    var r = e[t];
    this.set(r[0], r[1]);
  }
}
gm.prototype.clear = Bxe;
gm.prototype.delete = Uxe;
gm.prototype.get = Wxe;
gm.prototype.has = Xxe;
gm.prototype.set = Qxe;
function Jxe() {
  this.size = 0, this.__data__ = {
    hash: new gm(),
    map: new (Rx || Pc)(),
    string: new gm()
  };
}
function Zxe(e) {
  var t = typeof e;
  return t == "string" || t == "number" || t == "symbol" || t == "boolean" ? e !== "__proto__" : e === null;
}
function oE(e, t) {
  var n = e.__data__;
  return Zxe(t) ? n[typeof t == "string" ? "string" : "hash"] : n.map;
}
function eSe(e) {
  var t = oE(this, e).delete(e);
  return this.size -= t ? 1 : 0, t;
}
function tSe(e) {
  return oE(this, e).get(e);
}
function nSe(e) {
  return oE(this, e).has(e);
}
function rSe(e, t) {
  var n = oE(this, e), r = n.size;
  return n.set(e, t), this.size += n.size == r ? 0 : 1, this;
}
function Dc(e) {
  var t = -1, n = e == null ? 0 : e.length;
  for (this.clear(); ++t < n; ) {
    var r = e[t];
    this.set(r[0], r[1]);
  }
}
Dc.prototype.clear = Jxe;
Dc.prototype.delete = eSe;
Dc.prototype.get = tSe;
Dc.prototype.has = nSe;
Dc.prototype.set = rSe;
var oSe = 200;
function aSe(e, t) {
  var n = this.__data__;
  if (n instanceof Pc) {
    var r = n.__data__;
    if (!Rx || r.length < oSe - 1)
      return r.push([e, t]), this.size = ++n.size, this;
    n = this.__data__ = new Dc(r);
  }
  return n.set(e, t), this.size = n.size, this;
}
function Ls(e) {
  var t = this.__data__ = new Pc(e);
  this.size = t.size;
}
Ls.prototype.clear = xxe;
Ls.prototype.delete = Sxe;
Ls.prototype.get = kxe;
Ls.prototype.has = _xe;
Ls.prototype.set = aSe;
var iSe = "__lodash_hash_undefined__";
function sSe(e) {
  return this.__data__.set(e, iSe), this;
}
function lSe(e) {
  return this.__data__.has(e);
}
function vm(e) {
  var t = -1, n = e == null ? 0 : e.length;
  for (this.__data__ = new Dc(); ++t < n; )
    this.add(e[t]);
}
vm.prototype.add = vm.prototype.push = sSe;
vm.prototype.has = lSe;
function uSe(e, t) {
  for (var n = -1, r = e == null ? 0 : e.length; ++n < r; )
    if (t(e[n], n, e))
      return !0;
  return !1;
}
function jx(e, t) {
  return e.has(t);
}
var cSe = 1, dSe = 2;
function DV(e, t, n, r, a, s) {
  var l = n & cSe, c = e.length, d = t.length;
  if (c != d && !(l && d > c))
    return !1;
  var p = s.get(e), m = s.get(t);
  if (p && m)
    return p == t && m == e;
  var h = -1, v = !0, y = n & dSe ? new vm() : void 0;
  for (s.set(e, t), s.set(t, e); ++h < c; ) {
    var w = e[h], x = t[h];
    if (r)
      var b = l ? r(x, w, h, t, e, s) : r(w, x, h, e, t, s);
    if (b !== void 0) {
      if (b)
        continue;
      v = !1;
      break;
    }
    if (y) {
      if (!uSe(t, function(k, C) {
        if (!jx(y, C) && (w === k || a(w, k, n, r, s)))
          return y.push(C);
      })) {
        v = !1;
        break;
      }
    } else if (!(w === x || a(w, x, n, r, s))) {
      v = !1;
      break;
    }
  }
  return s.delete(e), s.delete(t), v;
}
var N_ = Tl.Uint8Array;
function fSe(e) {
  var t = -1, n = Array(e.size);
  return e.forEach(function(r, a) {
    n[++t] = [a, r];
  }), n;
}
function MA(e) {
  var t = -1, n = Array(e.size);
  return e.forEach(function(r) {
    n[++t] = r;
  }), n;
}
var pSe = 1, mSe = 2, hSe = "[object Boolean]", gSe = "[object Date]", vSe = "[object Error]", ySe = "[object Map]", bSe = "[object Number]", wSe = "[object RegExp]", xSe = "[object Set]", SSe = "[object String]", kSe = "[object Symbol]", _Se = "[object ArrayBuffer]", ESe = "[object DataView]", z$ = $i ? $i.prototype : void 0, HM = z$ ? z$.valueOf : void 0;
function CSe(e, t, n, r, a, s, l) {
  switch (n) {
    case ESe:
      if (e.byteLength != t.byteLength || e.byteOffset != t.byteOffset)
        return !1;
      e = e.buffer, t = t.buffer;
    case _Se:
      return !(e.byteLength != t.byteLength || !s(new N_(e), new N_(t)));
    case hSe:
    case gSe:
    case bSe:
      return kS(+e, +t);
    case vSe:
      return e.name == t.name && e.message == t.message;
    case wSe:
    case SSe:
      return e == t + "";
    case ySe:
      var c = fSe;
    case xSe:
      var d = r & pSe;
      if (c || (c = MA), e.size != t.size && !d)
        return !1;
      var p = l.get(e);
      if (p)
        return p == t;
      r |= mSe, l.set(e, t);
      var m = DV(c(e), c(t), r, a, s, l);
      return l.delete(e), m;
    case kSe:
      if (HM)
        return HM.call(e) == HM.call(t);
  }
  return !1;
}
function NA(e, t) {
  for (var n = -1, r = t.length, a = e.length; ++n < r; )
    e[a + n] = t[n];
  return e;
}
var eo = Array.isArray;
function $V(e, t, n) {
  var r = t(e);
  return eo(e) ? r : NA(r, n(e));
}
function OSe(e, t) {
  for (var n = -1, r = e == null ? 0 : e.length, a = 0, s = []; ++n < r; ) {
    var l = e[n];
    t(l, n, e) && (s[a++] = l);
  }
  return s;
}
function TV() {
  return [];
}
var MSe = Object.prototype, NSe = MSe.propertyIsEnumerable, F$ = Object.getOwnPropertySymbols, RA = F$ ? function(e) {
  return e == null ? [] : (e = Object(e), OSe(F$(e), function(t) {
    return NSe.call(e, t);
  }));
} : TV;
function LV(e, t) {
  for (var n = -1, r = Array(e); ++n < e; )
    r[n] = t(n);
  return r;
}
var RSe = "[object Arguments]";
function B$(e) {
  return Ti(e) && jc(e) == RSe;
}
var IV = Object.prototype, ASe = IV.hasOwnProperty, jSe = IV.propertyIsEnumerable, qh = B$(/* @__PURE__ */ (function() {
  return arguments;
})()) ? B$ : function(e) {
  return Ti(e) && ASe.call(e, "callee") && !jSe.call(e, "callee");
};
function PSe() {
  return !1;
}
var zV = typeof exports == "object" && exports && !exports.nodeType && exports, U$ = zV && typeof module == "object" && module && !module.nodeType && module, DSe = U$ && U$.exports === zV, V$ = DSe ? Tl.Buffer : void 0, $Se = V$ ? V$.isBuffer : void 0, ym = $Se || PSe, TSe = 9007199254740991, LSe = /^(?:0|[1-9]\d*)$/;
function aE(e, t) {
  var n = typeof e;
  return t = t ?? TSe, !!t && (n == "number" || n != "symbol" && LSe.test(e)) && e > -1 && e % 1 == 0 && e < t;
}
var ISe = 9007199254740991;
function AA(e) {
  return typeof e == "number" && e > -1 && e % 1 == 0 && e <= ISe;
}
var zSe = "[object Arguments]", FSe = "[object Array]", BSe = "[object Boolean]", USe = "[object Date]", VSe = "[object Error]", HSe = "[object Function]", qSe = "[object Map]", WSe = "[object Number]", GSe = "[object Object]", KSe = "[object RegExp]", XSe = "[object Set]", YSe = "[object String]", QSe = "[object WeakMap]", JSe = "[object ArrayBuffer]", ZSe = "[object DataView]", eke = "[object Float32Array]", tke = "[object Float64Array]", nke = "[object Int8Array]", rke = "[object Int16Array]", oke = "[object Int32Array]", ake = "[object Uint8Array]", ike = "[object Uint8ClampedArray]", ske = "[object Uint16Array]", lke = "[object Uint32Array]", ar = {};
ar[eke] = ar[tke] = ar[nke] = ar[rke] = ar[oke] = ar[ake] = ar[ike] = ar[ske] = ar[lke] = !0;
ar[zSe] = ar[FSe] = ar[JSe] = ar[BSe] = ar[ZSe] = ar[USe] = ar[VSe] = ar[HSe] = ar[qSe] = ar[WSe] = ar[GSe] = ar[KSe] = ar[XSe] = ar[YSe] = ar[QSe] = !1;
function uke(e) {
  return Ti(e) && AA(e.length) && !!ar[jc(e)];
}
function jA(e) {
  return function(t) {
    return e(t);
  };
}
var FV = typeof exports == "object" && exports && !exports.nodeType && exports, Qw = FV && typeof module == "object" && module && !module.nodeType && module, cke = Qw && Qw.exports === FV, qM = cke && RV.process, Wh = (function() {
  try {
    var e = Qw && Qw.require && Qw.require("util").types;
    return e || qM && qM.binding && qM.binding("util");
  } catch {
  }
})(), H$ = Wh && Wh.isTypedArray, ES = H$ ? jA(H$) : uke, dke = Object.prototype, fke = dke.hasOwnProperty;
function BV(e, t) {
  var n = eo(e), r = !n && qh(e), a = !n && !r && ym(e), s = !n && !r && !a && ES(e), l = n || r || a || s, c = l ? LV(e.length, String) : [], d = c.length;
  for (var p in e)
    (t || fke.call(e, p)) && !(l && // Safari 9 has enumerable `arguments.length` in strict mode.
    (p == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
    a && (p == "offset" || p == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
    s && (p == "buffer" || p == "byteLength" || p == "byteOffset") || // Skip index properties.
    aE(p, d))) && c.push(p);
  return c;
}
var pke = Object.prototype;
function iE(e) {
  var t = e && e.constructor, n = typeof t == "function" && t.prototype || pke;
  return e === n;
}
var mke = jV(Object.keys, Object), hke = Object.prototype, gke = hke.hasOwnProperty;
function UV(e) {
  if (!iE(e))
    return mke(e);
  var t = [];
  for (var n in Object(e))
    gke.call(e, n) && n != "constructor" && t.push(n);
  return t;
}
function Om(e) {
  return e != null && AA(e.length) && !_S(e);
}
function Ps(e) {
  return Om(e) ? BV(e) : UV(e);
}
function J5(e) {
  return $V(e, Ps, RA);
}
var vke = 1, yke = Object.prototype, bke = yke.hasOwnProperty;
function wke(e, t, n, r, a, s) {
  var l = n & vke, c = J5(e), d = c.length, p = J5(t), m = p.length;
  if (d != m && !l)
    return !1;
  for (var h = d; h--; ) {
    var v = c[h];
    if (!(l ? v in t : bke.call(t, v)))
      return !1;
  }
  var y = s.get(e), w = s.get(t);
  if (y && w)
    return y == t && w == e;
  var x = !0;
  s.set(e, t), s.set(t, e);
  for (var b = l; ++h < d; ) {
    v = c[h];
    var k = e[v], C = t[v];
    if (r)
      var _ = l ? r(C, k, v, t, e, s) : r(k, C, v, e, t, s);
    if (!(_ === void 0 ? k === C || a(k, C, n, r, s) : _)) {
      x = !1;
      break;
    }
    b || (b = v == "constructor");
  }
  if (x && !b) {
    var O = e.constructor, N = t.constructor;
    O != N && "constructor" in e && "constructor" in t && !(typeof O == "function" && O instanceof O && typeof N == "function" && N instanceof N) && (x = !1);
  }
  return s.delete(e), s.delete(t), x;
}
var Z5 = Cm(Tl, "DataView"), e3 = Cm(Tl, "Promise"), Oh = Cm(Tl, "Set"), t3 = Cm(Tl, "WeakMap"), q$ = "[object Map]", xke = "[object Object]", W$ = "[object Promise]", G$ = "[object Set]", K$ = "[object WeakMap]", X$ = "[object DataView]", Ske = Em(Z5), kke = Em(Rx), _ke = Em(e3), Eke = Em(Oh), Cke = Em(t3), Ni = jc;
(Z5 && Ni(new Z5(new ArrayBuffer(1))) != X$ || Rx && Ni(new Rx()) != q$ || e3 && Ni(e3.resolve()) != W$ || Oh && Ni(new Oh()) != G$ || t3 && Ni(new t3()) != K$) && (Ni = function(e) {
  var t = jc(e), n = t == xke ? e.constructor : void 0, r = n ? Em(n) : "";
  if (r)
    switch (r) {
      case Ske:
        return X$;
      case kke:
        return q$;
      case _ke:
        return W$;
      case Eke:
        return G$;
      case Cke:
        return K$;
    }
  return t;
});
var Oke = 1, Y$ = "[object Arguments]", Q$ = "[object Array]", vk = "[object Object]", Mke = Object.prototype, J$ = Mke.hasOwnProperty;
function Nke(e, t, n, r, a, s) {
  var l = eo(e), c = eo(t), d = l ? Q$ : Ni(e), p = c ? Q$ : Ni(t);
  d = d == Y$ ? vk : d, p = p == Y$ ? vk : p;
  var m = d == vk, h = p == vk, v = d == p;
  if (v && ym(e)) {
    if (!ym(t))
      return !1;
    l = !0, m = !1;
  }
  if (v && !m)
    return s || (s = new Ls()), l || ES(e) ? DV(e, t, n, r, a, s) : CSe(e, t, d, n, r, a, s);
  if (!(n & Oke)) {
    var y = m && J$.call(e, "__wrapped__"), w = h && J$.call(t, "__wrapped__");
    if (y || w) {
      var x = y ? e.value() : e, b = w ? t.value() : t;
      return s || (s = new Ls()), a(x, b, n, r, s);
    }
  }
  return v ? (s || (s = new Ls()), wke(e, t, n, r, a, s)) : !1;
}
function CS(e, t, n, r, a) {
  return e === t ? !0 : e == null || t == null || !Ti(e) && !Ti(t) ? e !== e && t !== t : Nke(e, t, n, r, CS, a);
}
function Rke(e, t, n) {
  n = typeof n == "function" ? n : void 0;
  var r = n ? n(e, t) : void 0;
  return r === void 0 ? CS(e, t, void 0, n) : !!r;
}
function Yn(e, t) {
  return Rke(e, t, (n, r) => {
    if (typeof n == "function" && typeof r == "function")
      return !0;
  });
}
var Ake = "[object Symbol]";
function OS(e) {
  return typeof e == "symbol" || Ti(e) && jc(e) == Ake;
}
var jke = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, Pke = /^\w*$/;
function PA(e, t) {
  if (eo(e))
    return !1;
  var n = typeof e;
  return n == "number" || n == "symbol" || n == "boolean" || e == null || OS(e) ? !0 : Pke.test(e) || !jke.test(e) || t != null && e in Object(t);
}
var Dke = "Expected a function";
function DA(e, t) {
  if (typeof e != "function" || t != null && typeof t != "function")
    throw new TypeError(Dke);
  var n = function() {
    var r = arguments, a = t ? t.apply(this, r) : r[0], s = n.cache;
    if (s.has(a))
      return s.get(a);
    var l = e.apply(this, r);
    return n.cache = s.set(a, l) || s, l;
  };
  return n.cache = new (DA.Cache || Dc)(), n;
}
DA.Cache = Dc;
var $ke = 500;
function Tke(e) {
  var t = DA(e, function(r) {
    return n.size === $ke && n.clear(), r;
  }), n = t.cache;
  return t;
}
var Lke = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g, Ike = /\\(\\)?/g, VV = Tke(function(e) {
  var t = [];
  return e.charCodeAt(0) === 46 && t.push(""), e.replace(Lke, function(n, r, a, s) {
    t.push(a ? s.replace(Ike, "$1") : r || n);
  }), t;
});
function lg(e, t) {
  for (var n = -1, r = e == null ? 0 : e.length, a = Array(r); ++n < r; )
    a[n] = t(e[n], n, e);
  return a;
}
var Z$ = $i ? $i.prototype : void 0, eT = Z$ ? Z$.toString : void 0;
function HV(e) {
  if (typeof e == "string")
    return e;
  if (eo(e))
    return lg(e, HV) + "";
  if (OS(e))
    return eT ? eT.call(e) : "";
  var t = e + "";
  return t == "0" && 1 / e == -1 / 0 ? "-0" : t;
}
function $A(e) {
  return e == null ? "" : HV(e);
}
function ug(e, t) {
  return eo(e) ? e : PA(e, t) ? [e] : VV($A(e));
}
function Mm(e) {
  if (typeof e == "string" || OS(e))
    return e;
  var t = e + "";
  return t == "0" && 1 / e == -1 / 0 ? "-0" : t;
}
function sE(e, t) {
  t = ug(t, e);
  for (var n = 0, r = t.length; e != null && n < r; )
    e = e[Mm(t[n++])];
  return n && n == r ? e : void 0;
}
function Ae(e, t, n) {
  var r = e == null ? void 0 : sE(e, t);
  return r === void 0 ? n : r;
}
var zke = Object.prototype, Fke = zke.hasOwnProperty;
function Bke(e, t) {
  return e != null && Fke.call(e, t);
}
function qV(e, t, n) {
  t = ug(t, e);
  for (var r = -1, a = t.length, s = !1; ++r < a; ) {
    var l = Mm(t[r]);
    if (!(s = e != null && n(e, l)))
      break;
    e = e[l];
  }
  return s || ++r != a ? s : (a = e == null ? 0 : e.length, !!a && AA(a) && aE(l, a) && (eo(e) || qh(e)));
}
function Zt(e, t) {
  return e != null && qV(e, t, Bke);
}
function Px(e, t) {
  return CS(e, t);
}
var R_ = (function() {
  try {
    var e = Cm(Object, "defineProperty");
    return e({}, "", {}), e;
  } catch {
  }
})();
function TA(e, t, n) {
  t == "__proto__" && R_ ? R_(e, t, {
    configurable: !0,
    enumerable: !0,
    value: n,
    writable: !0
  }) : e[t] = n;
}
var Uke = Object.prototype, Vke = Uke.hasOwnProperty;
function LA(e, t, n) {
  var r = e[t];
  (!(Vke.call(e, t) && kS(r, n)) || n === void 0 && !(t in e)) && TA(e, t, n);
}
function IA(e, t, n, r) {
  if (!cn(e))
    return e;
  t = ug(t, e);
  for (var a = -1, s = t.length, l = s - 1, c = e; c != null && ++a < s; ) {
    var d = Mm(t[a]), p = n;
    if (d === "__proto__" || d === "constructor" || d === "prototype")
      return e;
    if (a != l) {
      var m = c[d];
      p = r ? r(m, d, c) : void 0, p === void 0 && (p = cn(m) ? m : aE(t[a + 1]) ? [] : {});
    }
    LA(c, d, p), c = c[d];
  }
  return e;
}
function Pn(e, t, n) {
  return e == null ? e : IA(e, t, n);
}
function lE(e) {
  return e;
}
function WV(e) {
  return typeof e == "function" ? e : lE;
}
var Hke = /\s/;
function qke(e) {
  for (var t = e.length; t-- && Hke.test(e.charAt(t)); )
    ;
  return t;
}
var Wke = /^\s+/;
function Gke(e) {
  return e && e.slice(0, qke(e) + 1).replace(Wke, "");
}
var tT = NaN, Kke = /^[-+]0x[0-9a-f]+$/i, Xke = /^0b[01]+$/i, Yke = /^0o[0-7]+$/i, Qke = parseInt;
function Jke(e) {
  if (typeof e == "number")
    return e;
  if (OS(e))
    return tT;
  if (cn(e)) {
    var t = typeof e.valueOf == "function" ? e.valueOf() : e;
    e = cn(t) ? t + "" : t;
  }
  if (typeof e != "string")
    return e === 0 ? e : +e;
  e = Gke(e);
  var n = Xke.test(e);
  return n || Yke.test(e) ? Qke(e.slice(2), n ? 2 : 8) : Kke.test(e) ? tT : +e;
}
var nT = 1 / 0, Zke = 17976931348623157e292;
function e0e(e) {
  if (!e)
    return e === 0 ? e : 0;
  if (e = Jke(e), e === nT || e === -nT) {
    var t = e < 0 ? -1 : 1;
    return t * Zke;
  }
  return e === e ? e : 0;
}
function GV(e) {
  var t = e0e(e), n = t % 1;
  return t === t ? n ? t - n : t : 0;
}
var t0e = 9007199254740991, WM = 4294967295, n0e = Math.min;
function KV(e, t) {
  if (e = GV(e), e < 1 || e > t0e)
    return [];
  var n = WM, r = n0e(e, WM);
  t = WV(t), e -= WM;
  for (var a = LV(r, t); ++n < e; )
    t(n);
  return a;
}
function zA(e, t) {
  for (var n = -1, r = e == null ? 0 : e.length; ++n < r && t(e[n], n, e) !== !1; )
    ;
  return e;
}
var rT = Object.create, XV = /* @__PURE__ */ (function() {
  function e() {
  }
  return function(t) {
    if (!cn(t))
      return {};
    if (rT)
      return rT(t);
    e.prototype = t;
    var n = new e();
    return e.prototype = void 0, n;
  };
})();
function r0e(e) {
  return function(t, n, r) {
    for (var a = -1, s = Object(t), l = r(t), c = l.length; c--; ) {
      var d = l[++a];
      if (n(s[d], d, s) === !1)
        break;
    }
    return t;
  };
}
var YV = r0e();
function QV(e, t) {
  return e && YV(e, t, Ps);
}
var o0e = 1, a0e = 2;
function i0e(e, t, n, r) {
  var a = n.length, s = a;
  if (e == null)
    return !s;
  for (e = Object(e); a--; ) {
    var l = n[a];
    if (l[2] ? l[1] !== e[l[0]] : !(l[0] in e))
      return !1;
  }
  for (; ++a < s; ) {
    l = n[a];
    var c = l[0], d = e[c], p = l[1];
    if (l[2]) {
      if (d === void 0 && !(c in e))
        return !1;
    } else {
      var m = new Ls(), h;
      if (!(h === void 0 ? CS(p, d, o0e | a0e, r, m) : h))
        return !1;
    }
  }
  return !0;
}
function JV(e) {
  return e === e && !cn(e);
}
function s0e(e) {
  for (var t = Ps(e), n = t.length; n--; ) {
    var r = t[n], a = e[r];
    t[n] = [r, a, JV(a)];
  }
  return t;
}
function ZV(e, t) {
  return function(n) {
    return n == null ? !1 : n[e] === t && (t !== void 0 || e in Object(n));
  };
}
function l0e(e) {
  var t = s0e(e);
  return t.length == 1 && t[0][2] ? ZV(t[0][0], t[0][1]) : function(n) {
    return n === e || i0e(n, e, t);
  };
}
function u0e(e, t) {
  return e != null && t in Object(e);
}
function eH(e, t) {
  return e != null && qV(e, t, u0e);
}
var c0e = 1, d0e = 2;
function f0e(e, t) {
  return PA(e) && JV(t) ? ZV(Mm(e), t) : function(n) {
    var r = Ae(n, e);
    return r === void 0 && r === t ? eH(n, e) : CS(t, r, c0e | d0e);
  };
}
function p0e(e) {
  return function(t) {
    return t?.[e];
  };
}
function m0e(e) {
  return function(t) {
    return sE(t, e);
  };
}
function h0e(e) {
  return PA(e) ? p0e(Mm(e)) : m0e(e);
}
function FA(e) {
  return typeof e == "function" ? e : e == null ? lE : typeof e == "object" ? eo(e) ? f0e(e[0], e[1]) : l0e(e) : h0e(e);
}
function g0e(e, t, n) {
  var r = eo(e), a = r || ym(e) || ES(e);
  if (t = FA(t), n == null) {
    var s = e && e.constructor;
    a ? n = r ? new s() : [] : cn(e) ? n = _S(s) ? XV(nE(e)) : {} : n = {};
  }
  return (a ? zA : QV)(e, function(l, c, d) {
    return t(n, l, c, d);
  }), n;
}
function n3(e, t, n) {
  (n !== void 0 && !kS(e[t], n) || n === void 0 && !(t in e)) && TA(e, t, n);
}
var tH = typeof exports == "object" && exports && !exports.nodeType && exports, oT = tH && typeof module == "object" && module && !module.nodeType && module, v0e = oT && oT.exports === tH, aT = v0e ? Tl.Buffer : void 0, iT = aT ? aT.allocUnsafe : void 0;
function nH(e, t) {
  if (t)
    return e.slice();
  var n = e.length, r = iT ? iT(n) : new e.constructor(n);
  return e.copy(r), r;
}
function BA(e) {
  var t = new e.constructor(e.byteLength);
  return new N_(t).set(new N_(e)), t;
}
function rH(e, t) {
  var n = t ? BA(e.buffer) : e.buffer;
  return new e.constructor(n, e.byteOffset, e.length);
}
function UA(e, t) {
  var n = -1, r = e.length;
  for (t || (t = Array(r)); ++n < r; )
    t[n] = e[n];
  return t;
}
function oH(e) {
  return typeof e.constructor == "function" && !iE(e) ? XV(nE(e)) : {};
}
function Dx(e) {
  return Ti(e) && Om(e);
}
function r3(e, t) {
  if (!(t === "constructor" && typeof e[t] == "function") && t != "__proto__")
    return e[t];
}
function cg(e, t, n, r) {
  var a = !n;
  n || (n = {});
  for (var s = -1, l = t.length; ++s < l; ) {
    var c = t[s], d = void 0;
    d === void 0 && (d = e[c]), a ? TA(n, c, d) : LA(n, c, d);
  }
  return n;
}
function y0e(e) {
  var t = [];
  if (e != null)
    for (var n in Object(e))
      t.push(n);
  return t;
}
var b0e = Object.prototype, w0e = b0e.hasOwnProperty;
function x0e(e) {
  if (!cn(e))
    return y0e(e);
  var t = iE(e), n = [];
  for (var r in e)
    r == "constructor" && (t || !w0e.call(e, r)) || n.push(r);
  return n;
}
function MS(e) {
  return Om(e) ? BV(e, !0) : x0e(e);
}
function S0e(e) {
  return cg(e, MS(e));
}
function k0e(e, t, n, r, a, s, l) {
  var c = r3(e, n), d = r3(t, n), p = l.get(d);
  if (p) {
    n3(e, n, p);
    return;
  }
  var m = s ? s(c, d, n + "", e, t, l) : void 0, h = m === void 0;
  if (h) {
    var v = eo(d), y = !v && ym(d), w = !v && !y && ES(d);
    m = d, v || y || w ? eo(c) ? m = c : Dx(c) ? m = UA(c) : y ? (h = !1, m = nH(d, !0)) : w ? (h = !1, m = rH(d, !0)) : m = [] : pd(d) || qh(d) ? (m = c, qh(c) ? m = S0e(c) : (!cn(c) || _S(c)) && (m = oH(d))) : h = !1;
  }
  h && (l.set(d, m), a(m, d, r, s, l), l.delete(d)), n3(e, n, m);
}
function aH(e, t, n, r, a) {
  e !== t && YV(t, function(s, l) {
    if (a || (a = new Ls()), cn(s))
      k0e(e, t, l, n, aH, r, a);
    else {
      var c = r ? r(r3(e, l), s, l + "", e, t, a) : void 0;
      c === void 0 && (c = s), n3(e, l, c);
    }
  }, MS);
}
function _0e(e, t, n) {
  switch (n.length) {
    case 0:
      return e.call(t);
    case 1:
      return e.call(t, n[0]);
    case 2:
      return e.call(t, n[0], n[1]);
    case 3:
      return e.call(t, n[0], n[1], n[2]);
  }
  return e.apply(t, n);
}
var sT = Math.max;
function iH(e, t, n) {
  return t = sT(t === void 0 ? e.length - 1 : t, 0), function() {
    for (var r = arguments, a = -1, s = sT(r.length - t, 0), l = Array(s); ++a < s; )
      l[a] = r[t + a];
    a = -1;
    for (var c = Array(t + 1); ++a < t; )
      c[a] = r[a];
    return c[t] = n(l), _0e(e, this, c);
  };
}
function E0e(e) {
  return function() {
    return e;
  };
}
var C0e = R_ ? function(e, t) {
  return R_(e, "toString", {
    configurable: !0,
    enumerable: !1,
    value: E0e(t),
    writable: !0
  });
} : lE, O0e = 800, M0e = 16, N0e = Date.now;
function R0e(e) {
  var t = 0, n = 0;
  return function() {
    var r = N0e(), a = M0e - (r - n);
    if (n = r, a > 0) {
      if (++t >= O0e)
        return arguments[0];
    } else
      t = 0;
    return e.apply(void 0, arguments);
  };
}
var sH = R0e(C0e);
function uE(e, t) {
  return sH(iH(e, t, lE), e + "");
}
function A0e(e, t, n) {
  if (!cn(n))
    return !1;
  var r = typeof t;
  return (r == "number" ? Om(n) && aE(t, n.length) : r == "string" && t in n) ? kS(n[t], e) : !1;
}
function j0e(e) {
  return uE(function(t, n) {
    var r = -1, a = n.length, s = a > 1 ? n[a - 1] : void 0, l = a > 2 ? n[2] : void 0;
    for (s = e.length > 3 && typeof s == "function" ? (a--, s) : void 0, l && A0e(n[0], n[1], l) && (s = a < 3 ? void 0 : s, a = 1), t = Object(t); ++r < a; ) {
      var c = n[r];
      c && e(t, c, r, s);
    }
    return t;
  });
}
var P0e = j0e(function(e, t, n) {
  aH(e, t, n);
}), lT = $i ? $i.isConcatSpreadable : void 0;
function D0e(e) {
  return eo(e) || qh(e) || !!(lT && e && e[lT]);
}
function NS(e, t, n, r, a) {
  var s = -1, l = e.length;
  for (n || (n = D0e), a || (a = []); ++s < l; ) {
    var c = e[s];
    t > 0 && n(c) ? t > 1 ? NS(c, t - 1, n, r, a) : NA(a, c) : r || (a[a.length] = c);
  }
  return a;
}
var $0e = 1 / 0;
function T0e(e) {
  var t = e == null ? 0 : e.length;
  return t ? NS(e, $0e) : [];
}
function L0e(e, t, n, r) {
  for (var a = e.length, s = n + -1; ++s < a; )
    if (t(e[s], s, e))
      return s;
  return -1;
}
function I0e(e) {
  return e !== e;
}
function z0e(e, t, n) {
  for (var r = n - 1, a = e.length; ++r < a; )
    if (e[r] === t)
      return r;
  return -1;
}
function lH(e, t, n) {
  return t === t ? z0e(e, t, n) : L0e(e, I0e, n);
}
function VA(e, t) {
  var n = e == null ? 0 : e.length;
  return !!n && lH(e, t, 0) > -1;
}
function I0() {
}
var F0e = 1 / 0, B0e = Oh && 1 / MA(new Oh([, -0]))[1] == F0e ? function(e) {
  return new Oh(e);
} : I0, U0e = 200;
function uH(e, t, n) {
  var r = -1, a = VA, s = e.length, l = !0, c = [], d = c;
  if (s >= U0e) {
    var p = B0e(e);
    if (p)
      return MA(p);
    l = !1, a = jx, d = new vm();
  } else
    d = c;
  e:
    for (; ++r < s; ) {
      var m = e[r], h = m;
      if (m = m !== 0 ? m : 0, l && h === h) {
        for (var v = d.length; v--; )
          if (d[v] === h)
            continue e;
        c.push(m);
      } else a(d, h, n) || (d !== c && d.push(h), c.push(m));
    }
  return c;
}
function cH(e) {
  return e && e.length ? uH(e) : [];
}
var V0e = "[object Map]", H0e = "[object Set]", q0e = Object.prototype, W0e = q0e.hasOwnProperty;
function jr(e) {
  if (e == null)
    return !0;
  if (Om(e) && (eo(e) || typeof e == "string" || typeof e.splice == "function" || ym(e) || ES(e) || qh(e)))
    return !e.length;
  var t = Ni(e);
  if (t == V0e || t == H0e)
    return !e.size;
  if (iE(e))
    return !UV(e).length;
  for (var n in e)
    if (W0e.call(e, n))
      return !1;
  return !0;
}
const G0e = Object.prototype;
function Iw(e) {
  for (const t in e)
    if (G0e.hasOwnProperty.call(e, t))
      return !1;
  return !0;
}
const K0e = [
  "array",
  "boolean",
  "integer",
  "null",
  "number",
  "object",
  "string"
];
new Set(K0e);
const X0e = [
  "$defs",
  "definitions",
  "properties",
  "patternProperties",
  "dependencies"
];
new Set(X0e);
const Y0e = [
  "items",
  "allOf",
  "oneOf",
  "anyOf"
];
new Set(Y0e);
const Q0e = [
  "items",
  "additionalItems",
  "additionalProperties",
  "propertyNames",
  "contains",
  "if",
  "then",
  "else",
  "not"
];
new Set(Q0e);
function z0(e) {
  return typeof e == "object";
}
function al(e) {
  return z0(e) ? Iw(e) : e === !0;
}
function mh(e, t) {
  return e < t ? -1 : e > t ? 1 : 0;
}
function GM(e, t) {
  const n = e.length;
  if (n === 0)
    return t;
  let r = t.length;
  if (r === 0)
    return e;
  if (n < r) {
    const s = e;
    e = t, t = s, r = n;
  }
  const a = new Set(e);
  for (let s = 0; s < r; s++)
    a.add(t[s]);
  return Array.from(a);
}
function J0e(e, t) {
  const n = [];
  if (e.length === 0 || t.length === 0)
    return n;
  if (e.length > t.length) {
    const a = e;
    e = t, t = a;
  }
  const r = new Set(t);
  for (let a = 0; a < e.length && r.size > 0; a++) {
    const s = e[a];
    r.delete(s) && n.push(s);
  }
  return n;
}
function uT(e) {
  return e.length === 0;
}
function KM(e) {
  return (t, n) => {
    const r = t.length - n.length;
    if (r !== 0)
      return r;
    for (let a = 0; a < t.length; a++)
      if (t[a] !== n[a]) {
        const s = e(t[a], n[a]);
        if (s !== 0)
          return s;
      }
    return 0;
  };
}
function dH(e, { threshold: t = 12 } = {}) {
  return (n) => {
    const r = n.length;
    if (r === 0)
      return n;
    if (r <= t) {
      const l = [];
      let c = 0;
      e: for (let d = 0; d < r; d++) {
        const p = n[d];
        for (let m = 0; m < c; m++)
          if (e(p, l[m]) === 0)
            continue e;
        c = l.push(p);
      }
      return l;
    }
    const a = n.slice().sort(e);
    let s = 0;
    for (let l = 1; l < r; l++)
      e(a[s], a[l]) !== 0 && ++s !== l && (a[s] = a[l]);
    return a.length = s + 1, a;
  };
}
function Z0e(e) {
  return (t, n) => {
    const r = [];
    let a = t.length, s = n.length;
    if (a === 0 || s === 0)
      return r;
    if (a > s) {
      const m = t;
      t = n, n = m;
      const h = a;
      a = s, s = h;
    }
    const l = [...t].sort(e), c = [...n].sort(e);
    let d = 0, p = 0;
    for (; d < a && p < s; ) {
      const m = e(l[d], c[p]);
      m === 0 ? ((r.length === 0 || e(r[r.length - 1], l[d]) !== 0) && r.push(l[d]), d++, p++) : m < 0 ? d++ : p++;
    }
    return r;
  };
}
function e_e(e, t) {
  return (n) => {
    if (e.has(n))
      return e.get(n);
    const r = t(n);
    return e.set(n, r), r;
  };
}
const cT = e_e, fH = () => 0, t_e = (e) => e === void 0, n_e = (e) => typeof e != "object", dT = {
  boolean: 0,
  number: 1,
  string: 2
};
function r_e(e, t) {
  const n = typeof e, r = typeof t;
  return n === r ? mh(e, t) : dT[n] - dT[r];
}
function o_e(e, t) {
  const n = e.length;
  if (n === 0)
    return t;
  const r = t.length;
  if (r === 0)
    return e;
  if (r > n) {
    const l = e;
    e = t, t = l;
  }
  const a = new Set(e), s = t.length;
  for (let l = 0; l < s; l++) {
    const c = t[l];
    a.has(c) || e.push(c);
  }
  return e;
}
function cE(e, t, n = fH) {
  return (r, a) => e(r) ? e(a) ? n(r, a) : -1 : e(a) ? 1 : t(r, a);
}
function sh(e) {
  return cE(t_e, e);
}
function Hc(e, t) {
  return cE((n) => n === void 0 || e(n), t);
}
function XM(e, t) {
  return cE(Array.isArray, e, t);
}
const Mr = sh(mh), YM = Hc((e) => e === 0, (e, t) => e - t);
function a_e({ deduplicationCache: e = /* @__PURE__ */ new WeakMap(), sortedKeysCache: t = /* @__PURE__ */ new WeakMap() } = {}) {
  const n = cT(t, (x) => Object.keys(x).sort());
  function r(x) {
    return (b, k) => {
      const C = n(b), _ = n(k), O = Math.min(C.length, _.length);
      for (let N = 0; N < O; N++) {
        const R = mh(C[N], _[N]);
        if (R !== 0)
          return R;
      }
      if (C.length !== _.length)
        return C.length - _.length;
      for (let N = 0; N < O; N++) {
        const R = C[N], j = x(b[R], k[R]);
        if (j !== 0)
          return j;
      }
      return 0;
    };
  }
  function a(x) {
    const b = KM(x), k = cT(
      e,
      // NOTE: Always sort output
      dH(x, { threshold: 0 })
    );
    return (C, _) => b(k(C), k(_));
  }
  const s = a(mh);
  function l(x, b) {
    if (z0(x)) {
      if (z0(b)) {
        const k = Object.keys(x), C = Object.keys(b), _ = o_e(k, C), O = _.length;
        for (let N = 0; N < O; N++) {
          const R = _[N];
          if (x[R] === b[R])
            continue;
          const j = (w[R] ?? c)(x[R], b[R]);
          if (j !== 0)
            return j;
        }
        return 0;
      }
      return b === !0 && Iw(x) ? 0 : 1;
    }
    return z0(b) ? x === !0 && Iw(b) ? 0 : -1 : mh(x, b);
  }
  const c = sh(p), d = cE(n_e, XM(r(c), KM(p)), r_e);
  function p(x, b) {
    return x === null ? -1 : b === null ? 1 : d(x, b);
  }
  const m = sh(l), h = Hc(Iw, r(m)), v = sh(a(l)), y = Hc(al, l), w = {
    $id: Mr,
    $comment: Mr,
    $defs: h,
    $ref: Mr,
    $schema: Mr,
    const: c,
    contains: m,
    contentEncoding: Mr,
    contentMediaType: Mr,
    default: c,
    definitions: h,
    description: Mr,
    else: m,
    examples: c,
    exclusiveMaximum: Mr,
    exclusiveMinimum: Mr,
    format: Mr,
    if: m,
    maximum: Mr,
    maxItems: Mr,
    maxLength: Mr,
    maxProperties: Mr,
    minimum: Mr,
    multipleOf: Mr,
    not: m,
    pattern: Mr,
    propertyNames: m,
    readOnly: Mr,
    then: m,
    title: Mr,
    writeOnly: Mr,
    uniqueItems: Hc((x) => x === !1, fH),
    minLength: YM,
    minItems: YM,
    minProperties: YM,
    required: Hc(uT, s),
    enum: Hc(uT, a(p)),
    type: sh((x, b) => {
      const k = Array.isArray(x), C = Array.isArray(b);
      return !k && !C ? mh(x, b) : s(k ? x : [x], C ? b : [b]);
    }),
    items: Hc((x) => !Array.isArray(x) && al(x), XM(l, KM(l))),
    anyOf: v,
    allOf: v,
    oneOf: v,
    properties: h,
    patternProperties: h,
    additionalProperties: y,
    additionalItems: y,
    dependencies: Hc(Iw, r(sh(XM(l, s))))
  };
  return {
    compareSchemaValues: p,
    compareSchemaDefinitions: l
  };
}
function fT(e) {
  return e;
}
const pH = (e, t) => e ? pH(t % e, e) : t, i_e = (e, t) => Math.abs(e * t) / pH(e, t);
function s_e(e, t) {
  return e === t ? e : `^(?=.*(?:${e}))(?=.*(?:${t})).*$`;
}
function* QM(e, t, n) {
  const r = e.length, a = t.length;
  if (r > 0 && a > 0)
    for (let s = 0; s < r; s++) {
      const l = e[s];
      for (let c = 0; c < a; c++)
        yield n(l, t[c]);
    }
}
function JM(e, t) {
  return e || t;
}
function pT(e) {
  return (t, n) => {
    const r = { ...t }, a = Object.keys(n), s = a.length;
    for (let l = 0; l < s; l++) {
      const c = a[l];
      r[c] = t[c] === void 0 ? n[c] : e(t[c], n[c]);
    }
    return r;
  };
}
function l_e(e) {
  const t = /* @__PURE__ */ new Map();
  for (const n of e)
    for (const r of n[0])
      t.set(r, n[1]);
  return t;
}
function Fp(e, t, n) {
  n === void 0 || al(n) ? delete e[t] : e[t] = n;
}
const u_e = [
  "properties",
  "patternProperties",
  "additionalProperties"
];
function mT(e) {
  const t = Object.keys(e), n = t.length, r = [];
  for (let a = 0; a < n; a++) {
    const s = t[a];
    r.push({
      regExp: new RegExp(s),
      schema: e[s]
    });
  }
  return [r, t];
}
const hT = [[], []];
function gT(e, t, n) {
  const r = n.length;
  for (let a = 0; a < r; a++) {
    const s = n[a];
    if (!s.regExp.test(t))
      continue;
    const l = s.schema;
    if (l === !1)
      return !0;
    e.push(l);
  }
  return !1;
}
const c_e = [
  "items",
  "additionalItems"
], d_e = [
  "if",
  "then",
  "else"
];
function vT(e, t) {
  return t.if !== void 0 && (e.if = t.if), t.then !== void 0 && (e.then = t.then), t.else !== void 0 && (e.else = t.else), e;
}
function ZM(e, t) {
  if (e === t)
    return e;
  switch (e) {
    case "number":
      if (t === "integer")
        return "integer";
    // eslint-disable-next-line no-fallthrough
    case "integer":
      if (t === "number")
        return "integer";
    // eslint-disable-next-line no-fallthrough
    default:
      return;
  }
}
function Bp(e, t, n) {
  return [e, t, n];
}
function f_e(e) {
  const t = /* @__PURE__ */ new Map();
  for (const [n, r, a] of e) {
    const s = (l) => {
      if (!a(l))
        throw new Error(`Schema keys '${n}' and '${r}' are conflicting (${n}: ${JSON.stringify(l[n])}, ${r}: ${JSON.stringify(l[r])})`);
    };
    for (const l of [
      [n, r],
      [r, n]
    ]) {
      let c = t.get(l[0]);
      c === void 0 && (c = [], t.set(l[0], c)), c.push({ oppositeKey: l[1], check: s });
    }
  }
  return t;
}
const p_e = [
  Bp("minimum", "maximum", (e) => e.maximum >= e.minimum),
  Bp("exclusiveMinimum", "maximum", (e) => e.maximum > e.exclusiveMinimum),
  Bp("minimum", "exclusiveMaximum", (e) => e.exclusiveMaximum > e.minimum),
  Bp("exclusiveMinimum", "exclusiveMaximum", (e) => e.exclusiveMaximum > e.exclusiveMinimum),
  Bp("minLength", "maxLength", (e) => e.maxLength >= e.minLength),
  Bp("minItems", "maxItems", (e) => e.maxItems >= e.minItems),
  Bp("minProperties", "maxProperties", (e) => e.maxProperties >= e.minProperties)
];
function m_e({ mergePatterns: e = s_e, isSubRegExp: t = Object.is, intersectJson: n = J0e, deduplicateJsonSchemaDef: r = fT, defaultMerger: a = fT, assigners: s = [], checks: l = p_e, mergers: c } = {}) {
  function d(O) {
    const N = O.length;
    let R = O[0];
    for (let j = 1; j < N; j++) {
      const D = k(R, O[j]);
      if (D === !1)
        return !1;
      al(D) || (R = D);
    }
    return R;
  }
  function p(O, N, R, j, D, $, z) {
    if (O.length = 0, R === !1)
      return !1;
    if (O.push(R), D !== void 0) {
      if (D === !1)
        return !1;
      O.push(D);
    }
    if (gT(O, N, $))
      return !1;
    const B = O.length < 2;
    if (z === !1) {
      if (B)
        return;
      if (gT(O, N, j))
        return !1;
    } else B && z !== void 0 && O.push(z);
    return O.length === 1 ? O[0] : d(O);
  }
  function m(O, N, R, j, D, $) {
    const z = R.length;
    if (z > 0 && D !== !1)
      if ($)
        Object.assign(O, N);
      else
        for (let B = 0; B < z; B++) {
          const P = R[B];
          j.has(P) || (O[P] = k(N[P], D));
        }
    return O;
  }
  const h = (O, { properties: N = {}, patternProperties: R, additionalProperties: j = !0 }, { properties: D = {}, patternProperties: $, additionalProperties: z = !0 }) => {
    const B = al(j), P = al(z);
    if (B && P)
      return Fp(O, "properties", C(N, D)), Fp(O, "patternProperties", R && $ ? C(R, $) : R ?? $), delete O.additionalProperties, O;
    const W = k(j, z);
    Fp(O, "additionalProperties", W);
    const I = {}, G = Object.keys(N), L = G.length, [K, q] = R ? mT(R) : hT, [Z, V] = $ ? mT($) : hT, F = [], X = /* @__PURE__ */ new Set(), U = P ? void 0 : z;
    for (let me = 0; me < L; me++) {
      const ve = G[me];
      X.add(ve);
      const ae = p(F, ve, N[ve], K, D[ve], Z, U);
      ae !== void 0 && (I[ve] = ae);
    }
    const H = Object.keys(D), Q = H.length, re = B ? void 0 : j;
    for (let me = 0; me < Q; me++) {
      const ve = H[me];
      if (X.has(ve))
        continue;
      const ae = p(F, ve, D[ve], Z, void 0, K, re);
      ae !== void 0 && (I[ve] = ae);
    }
    Fp(O, "properties", I);
    let de = {};
    const le = /* @__PURE__ */ new Set();
    if (q.length > 0 && V.length > 0) {
      const me = QM(q, V, (ve, ae) => {
        t(ve, ae) && le.add(ve), t(ae, ve) && le.add(ae), de[e(ve, ae)] = k(R[ve], $[ae]);
      });
      for (; !me.next().done; )
        ;
    }
    return de = m(de, R, q, le, z, P), de = m(de, $, V, le, j, B), Fp(O, "patternProperties", de), O;
  }, v = (O, { items: N = [], additionalItems: R }, { items: j = [], additionalItems: D }) => {
    const $ = Array.isArray(N), z = Array.isArray(j), B = [];
    if (O.items = B, $ && z) {
      const [P, W, I] = N.length < j.length ? [N.length, R, j] : [j.length, D, N];
      let G = 0;
      for (; G < P; G++)
        B.push(k(N[G], j[G]));
      if (W === !1)
        O.additionalItems = !1;
      else {
        const L = W === void 0 || al(W);
        for (; G < I.length; G++)
          B.push(L ? I[G] : k(I[G], W));
        Fp(O, "additionalItems", R !== void 0 && D !== void 0 ? k(R, D) : R ?? D);
      }
    } else if ($ || z) {
      const [P, W, I] = $ ? [N, j, R] : [j, N, D];
      Fp(O, "additionalItems", I && k(I, W));
      for (let G = 0; G < P.length; G++)
        B.push(k(P[G], W));
    } else
      delete O.additionalItems, O.items = k(N, j);
    return O;
  }, y = (O, N, R) => {
    vT(O, N);
    const j = vT({}, R);
    return O.allOf === void 0 ? O.allOf = [j] : O.allOf = O.allOf.concat(j), O;
  };
  function w(O, N) {
    return r(Array.from(QM(O, N, k)));
  }
  const x = l_e([
    [u_e, h],
    [c_e, v],
    [d_e, y],
    ...s
  ]), b = f_e(l);
  function k(O, N) {
    if (O === !1 || N === !1)
      return !1;
    if (al(O))
      return al(N) ? !0 : N;
    if (al(N))
      return O;
    let R = { ...O };
    const j = /* @__PURE__ */ new Set(), D = /* @__PURE__ */ new Set(), $ = Object.keys(N), z = $.length;
    for (let B = 0; B < z; B++) {
      const P = $[B], W = N[P];
      if (W === void 0)
        continue;
      const I = b.get(P);
      if (I !== void 0) {
        const q = I.length;
        for (let Z = 0; Z < q; Z++) {
          const V = I[Z];
          O[V.oppositeKey] !== void 0 && D.add(V.check);
        }
      }
      const G = O[P];
      if (G === void 0) {
        R[P] = W;
        continue;
      }
      const L = x.get(P);
      if (L) {
        j.add(L);
        continue;
      }
      const K = _[P] ?? a;
      R[P] = K(G, W);
    }
    for (const B of j)
      R = B(R, O, N);
    for (const B of D)
      B(R);
    return R;
  }
  const C = pT(k), _ = {
    $id: a,
    $ref: a,
    $schema: a,
    $comment: a,
    $defs: C,
    definitions: C,
    type: (O, N) => {
      if (O === N)
        return O;
      const R = Array.isArray(O), j = Array.isArray(N);
      if (!R && !j) {
        const D = ZM(O, N);
        if (D !== void 0)
          return D;
      } else if (R || j) {
        const D = /* @__PURE__ */ new Set();
        if (R && j)
          for (const z of QM(O, N, ZM))
            z !== void 0 && D.add(z);
        else {
          const z = R ? O : N, B = R ? N : O, P = z.length;
          for (let W = 0; W < P; W++) {
            const I = ZM(B, z[W]);
            I !== void 0 && D.add(I);
          }
        }
        const $ = D.size;
        if ($ === 1)
          return D.values().next().value;
        if ($ > 1)
          return Array.from(D);
      }
      throw new Error(`It is not possible to create an intersection of the following incompatible types: ${O.toString()}, ${N.toString()}`);
    },
    default: a,
    description: a,
    title: a,
    const: a,
    format: a,
    contentEncoding: a,
    contentMediaType: a,
    not: (O, N) => {
      const R = r([O, N]);
      return R.length === 1 ? R[0] : { anyOf: R };
    },
    pattern: e,
    readOnly: JM,
    writeOnly: JM,
    enum: (O, N) => {
      const R = n(O, N);
      if (R.length === 0)
        throw new Error(`Intersection of the following enums is empty: "${JSON.stringify(O)}", "${JSON.stringify(N)}"`);
      return R;
    },
    anyOf: w,
    oneOf: w,
    allOf: (O, N) => r(O.concat(N)),
    propertyNames: k,
    contains: k,
    dependencies: pT((O, N) => Array.isArray(O) ? Array.isArray(N) ? GM(O, N) : k(N, { required: O }) : Array.isArray(N) ? k(O, { required: N }) : k(O, N)),
    examples: (O, N) => {
      if (!Array.isArray(O) || !Array.isArray(N))
        throw new Error(`Value of the 'examples' field should be an array, but got "${JSON.stringify(O)}" and "${JSON.stringify(N)}"`);
      return GM(O, N);
    },
    multipleOf: (O, N) => {
      let R = 1;
      for (; !Number.isInteger(O) || !Number.isInteger(N); )
        R *= 10, O *= 10, N *= 10;
      return i_e(O, N) / R;
    },
    exclusiveMaximum: Math.min,
    maximum: Math.min,
    maxItems: Math.min,
    maxLength: Math.min,
    maxProperties: Math.min,
    exclusiveMinimum: Math.max,
    minimum: Math.max,
    minItems: Math.max,
    minLength: Math.max,
    minProperties: Math.max,
    uniqueItems: JM,
    required: GM,
    ...c
  };
  return {
    mergeSchemaDefinitions: k,
    mergeArrayOfSchemaDefinitions: d
  };
}
function h_e(e) {
  const t = [], n = [e];
  for (; n.length > 0; ) {
    const r = n.pop();
    if (typeof r == "boolean" || r.allOf === void 0) {
      t.push(r);
      continue;
    }
    const { allOf: a, ...s } = r;
    t.push(s);
    for (let l = a.length - 1; l >= 0; l--)
      n.push(a[l]);
  }
  return t;
}
function g_e(e) {
  return (t) => e(h_e(t));
}
var mw = {}, yT;
function v_e() {
  if (yT) return mw;
  yT = 1;
  var e = /~/, t = /~[01]/g;
  function n(p) {
    switch (p) {
      case "~1":
        return "/";
      case "~0":
        return "~";
    }
    throw new Error("Invalid tilde escape: " + p);
  }
  function r(p) {
    return e.test(p) ? p.replace(t, n) : p;
  }
  function a(p, m, h) {
    for (var v, y, w = 1, x = m.length; w < x; ) {
      if (m[w] === "constructor" || m[w] === "prototype" || m[w] === "__proto__") return p;
      if (v = r(m[w++]), y = x > w, typeof p[v] > "u" && (Array.isArray(p) && v === "-" && (v = p.length), y && (m[w] !== "" && m[w] < 1 / 0 || m[w] === "-" ? p[v] = [] : p[v] = {})), !y) break;
      p = p[v];
    }
    var b = p[v];
    return h === void 0 ? delete p[v] : p[v] = h, b;
  }
  function s(p) {
    if (typeof p == "string") {
      if (p = p.split("/"), p[0] === "") return p;
      throw new Error("Invalid JSON pointer.");
    } else if (Array.isArray(p)) {
      for (const m of p)
        if (typeof m != "string" && typeof m != "number")
          throw new Error("Invalid JSON pointer. Must be of type string or number.");
      return p;
    }
    throw new Error("Invalid JSON pointer.");
  }
  function l(p, m) {
    if (typeof p != "object") throw new Error("Invalid input object.");
    m = s(m);
    var h = m.length;
    if (h === 1) return p;
    for (var v = 1; v < h; ) {
      if (p = p[r(m[v++])], h === v) return p;
      if (typeof p != "object" || p === null) return;
    }
  }
  function c(p, m, h) {
    if (typeof p != "object") throw new Error("Invalid input object.");
    if (m = s(m), m.length === 0) throw new Error("Invalid JSON pointer for set.");
    return a(p, m, h);
  }
  function d(p) {
    var m = s(p);
    return {
      get: function(h) {
        return l(h, m);
      },
      set: function(h, v) {
        return c(h, m, v);
      }
    };
  }
  return mw.get = l, mw.set = c, mw.compile = d, mw;
}
var y_e = v_e();
const eN = /* @__PURE__ */ Oc(y_e);
function b_e(e, t) {
  return e && cg(t, Ps(t), e);
}
function w_e(e, t) {
  return e && cg(t, MS(t), e);
}
function x_e(e, t) {
  return cg(e, RA(e), t);
}
var S_e = Object.getOwnPropertySymbols, mH = S_e ? function(e) {
  for (var t = []; e; )
    NA(t, RA(e)), e = nE(e);
  return t;
} : TV;
function k_e(e, t) {
  return cg(e, mH(e), t);
}
function HA(e) {
  return $V(e, MS, mH);
}
var __e = Object.prototype, E_e = __e.hasOwnProperty;
function C_e(e) {
  var t = e.length, n = new e.constructor(t);
  return t && typeof e[0] == "string" && E_e.call(e, "index") && (n.index = e.index, n.input = e.input), n;
}
function O_e(e, t) {
  var n = t ? BA(e.buffer) : e.buffer;
  return new e.constructor(n, e.byteOffset, e.byteLength);
}
var M_e = /\w*$/;
function N_e(e) {
  var t = new e.constructor(e.source, M_e.exec(e));
  return t.lastIndex = e.lastIndex, t;
}
var bT = $i ? $i.prototype : void 0, wT = bT ? bT.valueOf : void 0;
function R_e(e) {
  return wT ? Object(wT.call(e)) : {};
}
var A_e = "[object Boolean]", j_e = "[object Date]", P_e = "[object Map]", D_e = "[object Number]", $_e = "[object RegExp]", T_e = "[object Set]", L_e = "[object String]", I_e = "[object Symbol]", z_e = "[object ArrayBuffer]", F_e = "[object DataView]", B_e = "[object Float32Array]", U_e = "[object Float64Array]", V_e = "[object Int8Array]", H_e = "[object Int16Array]", q_e = "[object Int32Array]", W_e = "[object Uint8Array]", G_e = "[object Uint8ClampedArray]", K_e = "[object Uint16Array]", X_e = "[object Uint32Array]";
function Y_e(e, t, n) {
  var r = e.constructor;
  switch (t) {
    case z_e:
      return BA(e);
    case A_e:
    case j_e:
      return new r(+e);
    case F_e:
      return O_e(e, n);
    case B_e:
    case U_e:
    case V_e:
    case H_e:
    case q_e:
    case W_e:
    case G_e:
    case K_e:
    case X_e:
      return rH(e, n);
    case P_e:
      return new r();
    case D_e:
    case L_e:
      return new r(e);
    case $_e:
      return N_e(e);
    case T_e:
      return new r();
    case I_e:
      return R_e(e);
  }
}
var Q_e = "[object Map]";
function J_e(e) {
  return Ti(e) && Ni(e) == Q_e;
}
var xT = Wh && Wh.isMap, Z_e = xT ? jA(xT) : J_e, e2e = "[object Set]";
function t2e(e) {
  return Ti(e) && Ni(e) == e2e;
}
var ST = Wh && Wh.isSet, n2e = ST ? jA(ST) : t2e, r2e = 1, o2e = 2, a2e = 4, hH = "[object Arguments]", i2e = "[object Array]", s2e = "[object Boolean]", l2e = "[object Date]", u2e = "[object Error]", gH = "[object Function]", c2e = "[object GeneratorFunction]", d2e = "[object Map]", f2e = "[object Number]", vH = "[object Object]", p2e = "[object RegExp]", m2e = "[object Set]", h2e = "[object String]", g2e = "[object Symbol]", v2e = "[object WeakMap]", y2e = "[object ArrayBuffer]", b2e = "[object DataView]", w2e = "[object Float32Array]", x2e = "[object Float64Array]", S2e = "[object Int8Array]", k2e = "[object Int16Array]", _2e = "[object Int32Array]", E2e = "[object Uint8Array]", C2e = "[object Uint8ClampedArray]", O2e = "[object Uint16Array]", M2e = "[object Uint32Array]", Kn = {};
Kn[hH] = Kn[i2e] = Kn[y2e] = Kn[b2e] = Kn[s2e] = Kn[l2e] = Kn[w2e] = Kn[x2e] = Kn[S2e] = Kn[k2e] = Kn[_2e] = Kn[d2e] = Kn[f2e] = Kn[vH] = Kn[p2e] = Kn[m2e] = Kn[h2e] = Kn[g2e] = Kn[E2e] = Kn[C2e] = Kn[O2e] = Kn[M2e] = !0;
Kn[u2e] = Kn[gH] = Kn[v2e] = !1;
function Jw(e, t, n, r, a, s) {
  var l, c = t & r2e, d = t & o2e, p = t & a2e;
  if (n && (l = a ? n(e, r, a, s) : n(e)), l !== void 0)
    return l;
  if (!cn(e))
    return e;
  var m = eo(e);
  if (m) {
    if (l = C_e(e), !c)
      return UA(e, l);
  } else {
    var h = Ni(e), v = h == gH || h == c2e;
    if (ym(e))
      return nH(e, c);
    if (h == vH || h == hH || v && !a) {
      if (l = d || v ? {} : oH(e), !c)
        return d ? k_e(e, w_e(l, e)) : x_e(e, b_e(l, e));
    } else {
      if (!Kn[h])
        return a ? e : {};
      l = Y_e(e, h, c);
    }
  }
  s || (s = new Ls());
  var y = s.get(e);
  if (y)
    return y;
  s.set(e, l), n2e(e) ? e.forEach(function(b) {
    l.add(Jw(b, t, n, b, e, s));
  }) : Z_e(e) && e.forEach(function(b, k) {
    l.set(k, Jw(b, t, n, k, e, s));
  });
  var w = p ? d ? HA : J5 : d ? MS : Ps, x = m ? void 0 : w(e);
  return zA(x || e, function(b, k) {
    x && (k = b, b = e[k]), LA(l, k, Jw(b, t, n, k, e, s));
  }), l;
}
function yH(e) {
  var t = e == null ? 0 : e.length;
  return t ? e[t - 1] : void 0;
}
function N2e(e, t, n) {
  var r = -1, a = e.length;
  t < 0 && (t = -t > a ? 0 : a + t), n = n > a ? a : n, n < 0 && (n += a), a = t > n ? 0 : n - t >>> 0, t >>>= 0;
  for (var s = Array(a); ++r < a; )
    s[r] = e[r + t];
  return s;
}
function R2e(e, t) {
  return t.length < 2 ? e : sE(e, N2e(t, 0, -1));
}
function bH(e, t) {
  return t = ug(t, e), e = R2e(e, t), e == null || delete e[Mm(yH(t))];
}
function A2e(e) {
  return pd(e) ? void 0 : e;
}
function o3(e) {
  var t = e == null ? 0 : e.length;
  return t ? NS(e, 1) : [];
}
function wH(e) {
  return sH(iH(e, void 0, o3), e + "");
}
var j2e = 1, P2e = 2, D2e = 4, $x = wH(function(e, t) {
  var n = {};
  if (e == null)
    return n;
  var r = !1;
  t = lg(t, function(s) {
    return s = ug(s, e), r || (r = s.length > 1), s;
  }), cg(e, HA(e), n), r && (n = Jw(n, j2e | P2e | D2e, A2e));
  for (var a = t.length; a--; )
    bH(n, t[a]);
  return n;
}), hw = { exports: {} }, tN, kT;
function xH() {
  if (kT) return tN;
  kT = 1;
  const e = RegExp.prototype.test.bind(/^[\da-f]{8}-[\da-f]{4}-[\da-f]{4}-[\da-f]{4}-[\da-f]{12}$/iu), t = RegExp.prototype.test.bind(/^(?:(?:25[0-5]|2[0-4]\d|1\d{2}|[1-9]\d|\d)\.){3}(?:25[0-5]|2[0-4]\d|1\d{2}|[1-9]\d|\d)$/u);
  function n(v) {
    let y = "", w = 0, x = 0;
    for (x = 0; x < v.length; x++)
      if (w = v[x].charCodeAt(0), w !== 48) {
        if (!(w >= 48 && w <= 57 || w >= 65 && w <= 70 || w >= 97 && w <= 102))
          return "";
        y += v[x];
        break;
      }
    for (x += 1; x < v.length; x++) {
      if (w = v[x].charCodeAt(0), !(w >= 48 && w <= 57 || w >= 65 && w <= 70 || w >= 97 && w <= 102))
        return "";
      y += v[x];
    }
    return y;
  }
  const r = RegExp.prototype.test.bind(/[^!"$&'()*+,\-.;=_`a-z{}~]/u);
  function a(v) {
    return v.length = 0, !0;
  }
  function s(v, y, w) {
    if (v.length) {
      const x = n(v);
      if (x !== "")
        y.push(x);
      else
        return w.error = !0, !1;
      v.length = 0;
    }
    return !0;
  }
  function l(v) {
    let y = 0;
    const w = { error: !1, address: "", zone: "" }, x = [], b = [];
    let k = !1, C = !1, _ = s;
    for (let O = 0; O < v.length; O++) {
      const N = v[O];
      if (!(N === "[" || N === "]"))
        if (N === ":") {
          if (k === !0 && (C = !0), !_(b, x, w))
            break;
          if (++y > 7) {
            w.error = !0;
            break;
          }
          O > 0 && v[O - 1] === ":" && (k = !0), x.push(":");
          continue;
        } else if (N === "%") {
          if (!_(b, x, w))
            break;
          _ = a;
        } else {
          b.push(N);
          continue;
        }
    }
    return b.length && (_ === a ? w.zone = b.join("") : C ? x.push(b.join("")) : x.push(n(b))), w.address = x.join(""), w;
  }
  function c(v) {
    if (d(v, ":") < 2)
      return { host: v, isIPV6: !1 };
    const y = l(v);
    if (y.error)
      return { host: v, isIPV6: !1 };
    {
      let w = y.address, x = y.address;
      return y.zone && (w += "%" + y.zone, x += "%25" + y.zone), { host: w, isIPV6: !0, escapedHost: x };
    }
  }
  function d(v, y) {
    let w = 0;
    for (let x = 0; x < v.length; x++)
      v[x] === y && w++;
    return w;
  }
  function p(v) {
    let y = v;
    const w = [];
    let x = -1, b = 0;
    for (; b = y.length; ) {
      if (b === 1) {
        if (y === ".")
          break;
        if (y === "/") {
          w.push("/");
          break;
        } else {
          w.push(y);
          break;
        }
      } else if (b === 2) {
        if (y[0] === ".") {
          if (y[1] === ".")
            break;
          if (y[1] === "/") {
            y = y.slice(2);
            continue;
          }
        } else if (y[0] === "/" && (y[1] === "." || y[1] === "/")) {
          w.push("/");
          break;
        }
      } else if (b === 3 && y === "/..") {
        w.length !== 0 && w.pop(), w.push("/");
        break;
      }
      if (y[0] === ".") {
        if (y[1] === ".") {
          if (y[2] === "/") {
            y = y.slice(3);
            continue;
          }
        } else if (y[1] === "/") {
          y = y.slice(2);
          continue;
        }
      } else if (y[0] === "/" && y[1] === ".") {
        if (y[2] === "/") {
          y = y.slice(2);
          continue;
        } else if (y[2] === "." && y[3] === "/") {
          y = y.slice(3), w.length !== 0 && w.pop();
          continue;
        }
      }
      if ((x = y.indexOf("/", 1)) === -1) {
        w.push(y);
        break;
      } else
        w.push(y.slice(0, x)), y = y.slice(x);
    }
    return w.join("");
  }
  function m(v, y) {
    const w = y !== !0 ? escape : unescape;
    return v.scheme !== void 0 && (v.scheme = w(v.scheme)), v.userinfo !== void 0 && (v.userinfo = w(v.userinfo)), v.host !== void 0 && (v.host = w(v.host)), v.path !== void 0 && (v.path = w(v.path)), v.query !== void 0 && (v.query = w(v.query)), v.fragment !== void 0 && (v.fragment = w(v.fragment)), v;
  }
  function h(v) {
    const y = [];
    if (v.userinfo !== void 0 && (y.push(v.userinfo), y.push("@")), v.host !== void 0) {
      let w = unescape(v.host);
      if (!t(w)) {
        const x = c(w);
        x.isIPV6 === !0 ? w = `[${x.escapedHost}]` : w = v.host;
      }
      y.push(w);
    }
    return (typeof v.port == "number" || typeof v.port == "string") && (y.push(":"), y.push(String(v.port))), y.length ? y.join("") : void 0;
  }
  return tN = {
    nonSimpleDomain: r,
    recomposeAuthority: h,
    normalizeComponentEncoding: m,
    removeDotSegments: p,
    isIPv4: t,
    isUUID: e,
    normalizeIPv6: c,
    stringArrayToHexStripped: n
  }, tN;
}
var nN, _T;
function $2e() {
  if (_T) return nN;
  _T = 1;
  const { isUUID: e } = xH(), t = /([\da-z][\d\-a-z]{0,31}):((?:[\w!$'()*+,\-.:;=@]|%[\da-f]{2})+)/iu, n = (
    /** @type {const} */
    [
      "http",
      "https",
      "ws",
      "wss",
      "urn",
      "urn:uuid"
    ]
  );
  function r(_) {
    return n.indexOf(
      /** @type {*} */
      _
    ) !== -1;
  }
  function a(_) {
    return _.secure === !0 ? !0 : _.secure === !1 ? !1 : _.scheme ? _.scheme.length === 3 && (_.scheme[0] === "w" || _.scheme[0] === "W") && (_.scheme[1] === "s" || _.scheme[1] === "S") && (_.scheme[2] === "s" || _.scheme[2] === "S") : !1;
  }
  function s(_) {
    return _.host || (_.error = _.error || "HTTP URIs must have a host."), _;
  }
  function l(_) {
    const O = String(_.scheme).toLowerCase() === "https";
    return (_.port === (O ? 443 : 80) || _.port === "") && (_.port = void 0), _.path || (_.path = "/"), _;
  }
  function c(_) {
    return _.secure = a(_), _.resourceName = (_.path || "/") + (_.query ? "?" + _.query : ""), _.path = void 0, _.query = void 0, _;
  }
  function d(_) {
    if ((_.port === (a(_) ? 443 : 80) || _.port === "") && (_.port = void 0), typeof _.secure == "boolean" && (_.scheme = _.secure ? "wss" : "ws", _.secure = void 0), _.resourceName) {
      const [O, N] = _.resourceName.split("?");
      _.path = O && O !== "/" ? O : void 0, _.query = N, _.resourceName = void 0;
    }
    return _.fragment = void 0, _;
  }
  function p(_, O) {
    if (!_.path)
      return _.error = "URN can not be parsed", _;
    const N = _.path.match(t);
    if (N) {
      const R = O.scheme || _.scheme || "urn";
      _.nid = N[1].toLowerCase(), _.nss = N[2];
      const j = `${R}:${O.nid || _.nid}`, D = C(j);
      _.path = void 0, D && (_ = D.parse(_, O));
    } else
      _.error = _.error || "URN can not be parsed.";
    return _;
  }
  function m(_, O) {
    if (_.nid === void 0)
      throw new Error("URN without nid cannot be serialized");
    const N = O.scheme || _.scheme || "urn", R = _.nid.toLowerCase(), j = `${N}:${O.nid || R}`, D = C(j);
    D && (_ = D.serialize(_, O));
    const $ = _, z = _.nss;
    return $.path = `${R || O.nid}:${z}`, O.skipEscape = !0, $;
  }
  function h(_, O) {
    const N = _;
    return N.uuid = N.nss, N.nss = void 0, !O.tolerant && (!N.uuid || !e(N.uuid)) && (N.error = N.error || "UUID is not valid."), N;
  }
  function v(_) {
    const O = _;
    return O.nss = (_.uuid || "").toLowerCase(), O;
  }
  const y = (
    /** @type {SchemeHandler} */
    {
      scheme: "http",
      domainHost: !0,
      parse: s,
      serialize: l
    }
  ), w = (
    /** @type {SchemeHandler} */
    {
      scheme: "https",
      domainHost: y.domainHost,
      parse: s,
      serialize: l
    }
  ), x = (
    /** @type {SchemeHandler} */
    {
      scheme: "ws",
      domainHost: !0,
      parse: c,
      serialize: d
    }
  ), b = (
    /** @type {SchemeHandler} */
    {
      scheme: "wss",
      domainHost: x.domainHost,
      parse: x.parse,
      serialize: x.serialize
    }
  ), k = (
    /** @type {Record<SchemeName, SchemeHandler>} */
    {
      http: y,
      https: w,
      ws: x,
      wss: b,
      urn: (
        /** @type {SchemeHandler} */
        {
          scheme: "urn",
          parse: p,
          serialize: m,
          skipNormalize: !0
        }
      ),
      "urn:uuid": (
        /** @type {SchemeHandler} */
        {
          scheme: "urn:uuid",
          parse: h,
          serialize: v,
          skipNormalize: !0
        }
      )
    }
  );
  Object.setPrototypeOf(k, null);
  function C(_) {
    return _ && (k[
      /** @type {SchemeName} */
      _
    ] || k[
      /** @type {SchemeName} */
      _.toLowerCase()
    ]) || void 0;
  }
  return nN = {
    wsIsSecure: a,
    SCHEMES: k,
    isValidSchemeName: r,
    getSchemeHandler: C
  }, nN;
}
var ET;
function T2e() {
  if (ET) return hw.exports;
  ET = 1;
  const { normalizeIPv6: e, removeDotSegments: t, recomposeAuthority: n, normalizeComponentEncoding: r, isIPv4: a, nonSimpleDomain: s } = xH(), { SCHEMES: l, getSchemeHandler: c } = $2e();
  function d(b, k) {
    return typeof b == "string" ? b = /** @type {T} */
    v(w(b, k), k) : typeof b == "object" && (b = /** @type {T} */
    w(v(b, k), k)), b;
  }
  function p(b, k, C) {
    const _ = C ? Object.assign({ scheme: "null" }, C) : { scheme: "null" }, O = m(w(b, _), w(k, _), _, !0);
    return _.skipEscape = !0, v(O, _);
  }
  function m(b, k, C, _) {
    const O = {};
    return _ || (b = w(v(b, C), C), k = w(v(k, C), C)), C = C || {}, !C.tolerant && k.scheme ? (O.scheme = k.scheme, O.userinfo = k.userinfo, O.host = k.host, O.port = k.port, O.path = t(k.path || ""), O.query = k.query) : (k.userinfo !== void 0 || k.host !== void 0 || k.port !== void 0 ? (O.userinfo = k.userinfo, O.host = k.host, O.port = k.port, O.path = t(k.path || ""), O.query = k.query) : (k.path ? (k.path[0] === "/" ? O.path = t(k.path) : ((b.userinfo !== void 0 || b.host !== void 0 || b.port !== void 0) && !b.path ? O.path = "/" + k.path : b.path ? O.path = b.path.slice(0, b.path.lastIndexOf("/") + 1) + k.path : O.path = k.path, O.path = t(O.path)), O.query = k.query) : (O.path = b.path, k.query !== void 0 ? O.query = k.query : O.query = b.query), O.userinfo = b.userinfo, O.host = b.host, O.port = b.port), O.scheme = b.scheme), O.fragment = k.fragment, O;
  }
  function h(b, k, C) {
    return typeof b == "string" ? (b = unescape(b), b = v(r(w(b, C), !0), { ...C, skipEscape: !0 })) : typeof b == "object" && (b = v(r(b, !0), { ...C, skipEscape: !0 })), typeof k == "string" ? (k = unescape(k), k = v(r(w(k, C), !0), { ...C, skipEscape: !0 })) : typeof k == "object" && (k = v(r(k, !0), { ...C, skipEscape: !0 })), b.toLowerCase() === k.toLowerCase();
  }
  function v(b, k) {
    const C = {
      host: b.host,
      scheme: b.scheme,
      userinfo: b.userinfo,
      port: b.port,
      path: b.path,
      query: b.query,
      nid: b.nid,
      nss: b.nss,
      uuid: b.uuid,
      fragment: b.fragment,
      reference: b.reference,
      resourceName: b.resourceName,
      secure: b.secure,
      error: ""
    }, _ = Object.assign({}, k), O = [], N = c(_.scheme || C.scheme);
    N && N.serialize && N.serialize(C, _), C.path !== void 0 && (_.skipEscape ? C.path = unescape(C.path) : (C.path = escape(C.path), C.scheme !== void 0 && (C.path = C.path.split("%3A").join(":")))), _.reference !== "suffix" && C.scheme && O.push(C.scheme, ":");
    const R = n(C);
    if (R !== void 0 && (_.reference !== "suffix" && O.push("//"), O.push(R), C.path && C.path[0] !== "/" && O.push("/")), C.path !== void 0) {
      let j = C.path;
      !_.absolutePath && (!N || !N.absolutePath) && (j = t(j)), R === void 0 && j[0] === "/" && j[1] === "/" && (j = "/%2F" + j.slice(2)), O.push(j);
    }
    return C.query !== void 0 && O.push("?", C.query), C.fragment !== void 0 && O.push("#", C.fragment), O.join("");
  }
  const y = /^(?:([^#/:?]+):)?(?:\/\/((?:([^#/?@]*)@)?(\[[^#/?\]]+\]|[^#/:?]*)(?::(\d*))?))?([^#?]*)(?:\?([^#]*))?(?:#((?:.|[\n\r])*))?/u;
  function w(b, k) {
    const C = Object.assign({}, k), _ = {
      scheme: void 0,
      userinfo: void 0,
      host: "",
      port: void 0,
      path: "",
      query: void 0,
      fragment: void 0
    };
    let O = !1;
    C.reference === "suffix" && (C.scheme ? b = C.scheme + ":" + b : b = "//" + b);
    const N = b.match(y);
    if (N) {
      if (_.scheme = N[1], _.userinfo = N[3], _.host = N[4], _.port = parseInt(N[5], 10), _.path = N[6] || "", _.query = N[7], _.fragment = N[8], isNaN(_.port) && (_.port = N[5]), _.host)
        if (a(_.host) === !1) {
          const j = e(_.host);
          _.host = j.host.toLowerCase(), O = j.isIPV6;
        } else
          O = !0;
      _.scheme === void 0 && _.userinfo === void 0 && _.host === void 0 && _.port === void 0 && _.query === void 0 && !_.path ? _.reference = "same-document" : _.scheme === void 0 ? _.reference = "relative" : _.fragment === void 0 ? _.reference = "absolute" : _.reference = "uri", C.reference && C.reference !== "suffix" && C.reference !== _.reference && (_.error = _.error || "URI is not a " + C.reference + " reference.");
      const R = c(C.scheme || _.scheme);
      if (!C.unicodeSupport && (!R || !R.unicodeSupport) && _.host && (C.domainHost || R && R.domainHost) && O === !1 && s(_.host))
        try {
          _.host = URL.domainToASCII(_.host.toLowerCase());
        } catch (j) {
          _.error = _.error || "Host's domain name can not be converted to ASCII: " + j;
        }
      (!R || R && !R.skipNormalize) && (b.indexOf("%") !== -1 && (_.scheme !== void 0 && (_.scheme = unescape(_.scheme)), _.host !== void 0 && (_.host = unescape(_.host))), _.path && (_.path = escape(unescape(_.path))), _.fragment && (_.fragment = encodeURI(decodeURIComponent(_.fragment)))), R && R.parse && R.parse(_, C);
    } else
      _.error = _.error || "URI can not be parsed.";
    return _;
  }
  const x = {
    SCHEMES: l,
    normalize: d,
    resolve: p,
    resolveComponent: m,
    equal: h,
    serialize: v,
    parse: w
  };
  return hw.exports = x, hw.exports.default = x, hw.exports.fastUri = x, hw.exports;
}
var L2e = T2e();
const qA = /* @__PURE__ */ Oc(L2e);
function A_(e, t) {
  if ($n in e && qA.equal(e[$n], t))
    return e;
  for (const n of Object.values(e))
    if (Array.isArray(n)) {
      for (const r of n)
        if (cn(r)) {
          const a = A_(r, t);
          if (a !== void 0)
            return a;
        }
    } else if (cn(n)) {
      const r = A_(n, t);
      if (r !== void 0)
        return r;
    }
}
function a3(e, t) {
  const n = Ae(e, $n, t);
  sr in e && (e = { ...e, [sr]: qA.resolve(n, e[sr]) });
  for (const [r, a] of Object.entries(e))
    Array.isArray(a) ? e = {
      ...e,
      [r]: a.map((s) => cn(s) ? a3(s, n) : s)
    } : cn(a) && (e = { ...e, [r]: a3(a, n) });
  return e;
}
function WA(e, t) {
  const n = t[e];
  return [$x(t, [e]), n];
}
function SH(e, t = {}, n = [], r = Ae(t, [$n])) {
  const a = e || "";
  let s;
  if (a.startsWith("#")) {
    const c = decodeURIComponent(a.substring(1));
    r === void 0 || $n in t && t[$n] === r ? s = eN.get(t, c) : t[Lw] === L0 && (s = A_(t, r.replace(/\/$/, "")), s !== void 0 && (s = eN.get(s, c)));
  } else if (t[Lw] === L0) {
    const c = r ? qA.resolve(r, a) : a, [d, ...p] = c.replace(/#\/?$/, "").split("#");
    s = A_(t, d.replace(/\/$/, "")), s !== void 0 && (r = s[$n], jr(p) || (s = eN.get(s, decodeURIComponent(p.join("#")))));
  }
  if (s === void 0)
    throw new Error(`Could not find a definition for ${e}.`);
  const l = s[sr];
  if (l) {
    if (n.includes(l)) {
      if (n.length === 1)
        throw new Error(`Definition for ${e} is a circular reference`);
      const [m, ...h] = n, v = [...h, a, m].join(" -> ");
      throw new Error(`Definition for ${m} contains a circular reference through ${v}`);
    }
    const [c, d] = WA(sr, s), p = SH(d, t, [...n, a], r);
    return Object.keys(c).length > 0 ? t[Lw] === Zwe || t[Lw] === L0 ? { [fd]: [c, p] } : { ...c, ...p } : p;
  }
  return s;
}
function kH(e, t = {}, n = Ae(t, [$n])) {
  return SH(e, t, [], n);
}
var I2e = "[object String]";
function md(e) {
  return typeof e == "string" || !eo(e) && Ti(e) && jc(e) == I2e;
}
function Nl(e) {
  let t;
  const n = Ae(e, Ywe);
  return md(n) ? t = n : n !== void 0 && console.warn(`Expecting discriminator to be a string, got "${typeof n}" instead`), t;
}
function Tx(e) {
  return Array.isArray(e) ? "array" : typeof e == "string" ? "string" : e == null ? "null" : typeof e == "boolean" ? "boolean" : isNaN(e) ? typeof e == "object" ? "object" : "string" : "number";
}
var z2e = uE(function(e) {
  return uH(NS(e, 1, Dx, !0));
});
function Vs(e) {
  let { type: t } = e;
  return !t && e.const ? Tx(e.const) : !t && e.enum ? "string" : !t && (e.properties || e.additionalProperties || e.patternProperties) ? "object" : (Array.isArray(t) && (t.length === 2 && t.includes("null") ? t = t.find((n) => n !== "null") : t = t[0]), t);
}
function Ec(e, t) {
  const n = Object.assign({}, e);
  return Object.keys(t).reduce((r, a) => {
    const s = e ? e[a] : {}, l = t[a];
    return e && a in e && on(l) ? r[a] = Ec(s, l) : e && t && (Vs(e) === "object" || Vs(t) === "object") && a === EV && Array.isArray(s) && Array.isArray(l) ? r[a] = z2e(s, l) : r[a] = l, r;
  }, n);
}
var F2e = "[object Number]";
function _H(e) {
  return typeof e == "number" || Ti(e) && jc(e) == F2e;
}
function EH(e, t, n) {
  var r;
  if (e && n) {
    const a = Ae(e, n);
    if (a === void 0)
      return;
    for (let s = 0; s < t.length; s++) {
      const l = t[s], c = Ae(l, [fn, n], {});
      if (!(c.type === "object" || c.type === "array") && (c.const === a || !((r = c.enum) === null || r === void 0) && r.includes(a)))
        return s;
    }
  }
}
function GA(e, t, n, r, a) {
  if (t === void 0)
    return 0;
  const s = EH(t, n, a);
  if (_H(s))
    return s;
  for (let l = 0; l < n.length; l++) {
    const c = n[l];
    if (a && Zt(c, [fn, a])) {
      const d = Ae(t, a), p = Ae(c, [fn, a], {});
      if (e.isValid(p, d, r))
        return l;
    } else if (c[fn]) {
      const d = {
        anyOf: Object.keys(c[fn]).map((m) => ({
          required: [m]
        }))
      };
      let p;
      if (c.anyOf) {
        const { ...m } = c;
        m.allOf ? m.allOf = m.allOf.slice() : m.allOf = [], m.allOf.push(d), p = m;
      } else
        p = Object.assign({}, c, d);
      if (delete p.required, e.isValid(p, t, r))
        return l;
    } else if (e.isValid(c, t, r))
      return l;
  }
  return 0;
}
function qo(e, t, n = {}, r, a, s = !1) {
  return hl(e, t, n, r, void 0, void 0, a, s)[0];
}
function B2e(e, t, n, r, a, s, l) {
  const { if: c, then: d, else: p, ...m } = t, h = e.isValid(c, s || {}, n);
  let v = [m], y = [];
  if (r)
    d && typeof d != "boolean" && (y = y.concat(hl(e, d, n, s, r, a, l))), p && typeof p != "boolean" && (y = y.concat(hl(e, p, n, s, r, a, l)));
  else {
    const w = h ? d : p;
    w && typeof w != "boolean" && (y = y.concat(hl(e, w, n, s, r, a, l)));
  }
  return y.length && (v = y.map((w) => Ec(m, w))), v.flatMap((w) => hl(e, w, n, s, r, a, l));
}
function CH(e) {
  return e.reduce((t, n) => n.length > 1 ? n.flatMap((r) => KV(t.length, (a) => [...t[a]].concat(r))) : (t.forEach((r) => r.push(n[0])), t), [[]]);
}
function OH(e, t) {
  return Object.keys(e.patternProperties).filter((n) => RegExp(n).test(t)).reduce((n, r) => (Pn(n, [r], e.patternProperties[r]), n), {});
}
function U2e(e, t, n, r, a, s, l, c) {
  const d = MH(e, t, n, r, a, s, l, c);
  if (d.length > 1 || d[0] !== t)
    return d;
  if (EA in t)
    return NH(e, t, n, r, a, s, l).flatMap((p) => hl(e, p, n, s, r, a, l));
  if (fd in t && Array.isArray(t[fd])) {
    const p = t.allOf.map((m) => hl(e, m, n, s, r, a, l));
    return CH(p).map((m) => ({
      ...t,
      allOf: m
    }));
  }
  return [t];
}
function MH(e, t, n, r, a, s, l, c) {
  const d = Mh(t, n, a, void 0, c);
  return d !== t ? hl(e, d, n, s, r, a, l, c) : [t];
}
function Mh(e, t, n, r, a) {
  if (!on(e))
    return e;
  let s = e;
  if (sr in s) {
    const { $ref: l, ...c } = s;
    if (n.includes(l))
      return s;
    n.push(l), s = { ...kH(l, t, r), ...c }, $n in s && (r = s[$n]);
  }
  if (fn in s) {
    const l = [], c = g0e(s[fn], (d, p, m) => {
      const h = [...n];
      d[m] = Mh(p, t, h, r, a), l.push(h);
    }, {});
    P0e(n, cH(T0e(l))), s = { ...s, [fn]: c };
  }
  if (Hh in s && !Array.isArray(s.items) && typeof s.items != "boolean" && (s = {
    ...s,
    items: Mh(s.items, t, n, r, a)
  }), a) {
    let l, c;
    sn in e && Array.isArray(e[sn]) ? (l = sn, c = s[sn]) : Ht in e && Array.isArray(e[Ht]) && (l = Ht, c = s[Ht]), l && c && (s = {
      ...s,
      [l]: c.map((d) => Mh(d, t, n, r, a))
    });
  }
  return Yn(e, s) ? e : s;
}
function V2e(e, t, n, r, a) {
  const s = {
    ...t,
    properties: { ...t.properties }
  }, l = r && on(r) ? r : {};
  return Object.keys(l).forEach((c) => {
    if (!(c in s.properties)) {
      if (X5 in s) {
        const d = OH(s, c);
        if (!jr(d)) {
          s.properties[c] = qo(e, { [fd]: Object.values(d) }, n, Ae(l, [c]), a), Pn(s.properties, [c, hc], !0);
          return;
        }
      }
      if (O_ in s && s.additionalProperties !== !1) {
        let d;
        typeof s.additionalProperties != "boolean" ? sr in s.additionalProperties ? d = qo(e, { [sr]: Ae(s.additionalProperties, [sr]) }, n, l, a) : "type" in s.additionalProperties ? d = { ...s.additionalProperties } : sn in s.additionalProperties || Ht in s.additionalProperties ? d = {
          type: "object",
          ...s.additionalProperties
        } : d = { type: Tx(Ae(l, [c])) } : d = { type: Tx(Ae(l, [c])) }, s.properties[c] = d, Pn(s.properties, [c, hc], !0);
      } else
        s.properties[c] = { type: "null" }, Pn(s.properties, [c, hc], !0);
    }
  }), s;
}
const { compareSchemaDefinitions: H2e, compareSchemaValues: q2e } = a_e(), { mergeArrayOfSchemaDefinitions: W2e } = m_e({
  intersectJson: Z0e(q2e),
  deduplicateJsonSchemaDef: dH(H2e)
}), G2e = g_e(W2e);
function K2e(e) {
  return G2e(e);
}
function hl(e, t, n, r, a = !1, s = [], l, c) {
  return on(t) ? U2e(e, t, n, a, s, r, l, c).flatMap((d) => {
    var p;
    let m = d;
    if (Kwe in m)
      return B2e(e, m, n, a, s, r, l);
    if (fd in m) {
      if (a) {
        const { allOf: h, ...v } = m;
        return [...h, v];
      }
      try {
        const h = [], v = [];
        (p = m.allOf) === null || p === void 0 || p.forEach((y) => {
          typeof y == "object" && y.contains ? h.push(y) : v.push(y);
        }), h.length && (m = { ...m, allOf: v }), m = l ? l(m) : K2e(m), h.length && (m.allOf = h);
      } catch (h) {
        console.warn(`could not merge subschemas in allOf:
`, h);
        const { allOf: v, ...y } = m;
        return y;
      }
    }
    return fn in m && X5 in m && (m = Object.keys(m.properties).reduce((h, v) => {
      const y = OH(h, v);
      return jr(y) || (h.properties[v] = qo(e, { allOf: [h.properties[v], ...Object.values(y)] }, n, Ae(r, [v]), l)), h;
    }, {
      ...m,
      properties: { ...m.properties }
    })), X5 in m || O_ in m && m.additionalProperties !== !1 ? V2e(e, m, n, r, l) : m;
  }) : [{}];
}
function X2e(e, t, n, r, a) {
  let s;
  const { oneOf: l, anyOf: c, ...d } = t;
  if (Array.isArray(l) ? s = l : Array.isArray(c) && (s = c), s) {
    const p = a === void 0 && r ? {} : a, m = Nl(t);
    s = s.map((v) => Mh(v, n, []));
    const h = GA(e, p, s, n, m);
    if (r)
      return s.map((v) => Ec(d, v));
    t = Ec(d, s[h]);
  }
  return [t];
}
function NH(e, t, n, r, a, s, l) {
  const { dependencies: c, ...d } = t;
  return X2e(e, d, n, r, s).flatMap((p) => RH(e, c, p, n, r, a, s, l));
}
function RH(e, t, n, r, a, s, l, c) {
  let d = [n];
  for (const p in t) {
    if (!a && Ae(l, [p]) === void 0 || n.properties && !(p in n.properties))
      continue;
    const [m, h] = WA(p, t);
    return Array.isArray(h) ? d[0] = Y2e(n, h) : on(h) && (d = Q2e(e, n, r, p, h, a, s, l, c)), d.flatMap((v) => RH(e, m, v, r, a, s, l, c));
  }
  return d;
}
function Y2e(e, t) {
  if (!t)
    return e;
  const n = Array.isArray(e.required) ? Array.from(/* @__PURE__ */ new Set([...e.required, ...t])) : t;
  return { ...e, required: n };
}
function Q2e(e, t, n, r, a, s, l, c, d) {
  return hl(e, a, n, c, s, l, d).flatMap((p) => {
    const { oneOf: m, ...h } = p;
    if (t = Ec(t, h), m === void 0)
      return t;
    const v = m.map((y) => typeof y == "boolean" || !(sr in y) ? [y] : MH(e, y, n, s, l, c));
    return CH(v).flatMap((y) => J2e(e, t, n, r, y, s, l, c, d));
  });
}
function J2e(e, t, n, r, a, s, l, c, d) {
  const p = a.filter((m) => {
    if (typeof m == "boolean" || !m || !m.properties)
      return !1;
    const { [r]: h } = m.properties;
    if (h) {
      const v = {
        type: "object",
        properties: {
          [r]: h
        }
      };
      return e.isValid(v, c, n) || s;
    }
    return !1;
  });
  return !s && p.length !== 1 ? (console.warn("ignoring oneOf in dependencies because there isn't exactly one subschema that is valid"), [t]) : p.flatMap((m) => {
    const h = m, [v] = WA(r, h.properties), y = { ...h, properties: v };
    return hl(e, y, n, c, s, l, d).map((w) => Ec(t, w));
  });
}
function zw(e, t, n, r, a, s = {}, l) {
  if (Array.isArray(n[a])) {
    const c = Nl(n) || r, d = n[a].map((m) => qo(e, m, t, s, l)), p = Ae(s, c);
    if (p !== void 0)
      return d.find((m) => Px(Ae(m, [fn, c, tE], Ae(m, [fn, c, Di])), p));
  }
}
function AH(e, t, n, r, a) {
  let s = n;
  if (Zt(n, sr) && (s = qo(e, n, t, void 0, a)), jr(r))
    return s;
  const l = Array.isArray(r) ? r : r.split("."), [c, ...d] = l;
  if (c && Zt(s, c))
    return s = Ae(s, c), AH(e, t, s, d, a);
}
function F0(e, t, n, r, a, s) {
  const l = AH(e, t, n, r, s);
  return l === void 0 ? a : l;
}
const CT = { title: "!@#$_UNKNOWN_$#@!" };
function Z2e(e, t, n, r, a = {}, s) {
  const l = Array.isArray(r) ? [...r] : r.split(".");
  let c = n;
  const d = l.pop();
  l.length && l.forEach((v) => {
    c = F0(e, t, c, [fn, v], {}, s), Zt(c, Ht) ? c = zw(e, t, c, d, Ht, Ae(a, v), s) : Zt(c, sn) && (c = zw(e, t, c, d, sn, Ae(a, v), s));
  }), Zt(c, Ht) ? c = zw(e, t, c, d, Ht, a, s) : Zt(c, sn) && (c = zw(e, t, c, d, sn, a, s));
  let p = F0(e, t, c, [fn, d], CT, s);
  p === CT && (p = void 0);
  const m = F0(e, t, c, EV, [], s);
  let h;
  return p && Array.isArray(m) && (h = m.includes(d)), { field: p, isRequired: h };
}
function eEe(e, t, n, r) {
  var a = -1, s = e == null ? 0 : e.length;
  for (r && s && (n = e[++a]); ++a < s; )
    n = t(n, e[a], a, e);
  return n;
}
function tEe(e, t) {
  return function(n, r) {
    if (n == null)
      return n;
    if (!Om(n))
      return e(n, r);
    for (var a = n.length, s = -1, l = Object(n); ++s < a && r(l[s], s, l) !== !1; )
      ;
    return n;
  };
}
var jH = tEe(QV);
function nEe(e, t, n, r, a) {
  return a(e, function(s, l, c) {
    n = r ? (r = !1, s) : t(n, s, l, c);
  }), n;
}
function rEe(e, t, n) {
  var r = eo(e) ? eEe : nEe, a = arguments.length < 3;
  return r(e, FA(t), n, a, jH);
}
const oEe = {
  type: "object",
  $id: Xwe,
  properties: {
    __not_really_there__: {
      type: "number"
    }
  }
};
function i3(e, t, n, r, a) {
  let s = 0;
  return n && (cn(n.properties) ? s += rEe(n.properties, (l, c, d) => {
    const p = Ae(r, d);
    if (typeof c == "boolean")
      return l;
    if (Zt(c, sr)) {
      const m = qo(e, c, t, p, a);
      return l + i3(e, t, m, p || {}, a);
    }
    if ((Zt(c, Ht) || Zt(c, sn)) && p) {
      const m = Zt(c, Ht) ? Ht : sn, h = Nl(c);
      return l + Lx(e, t, p, Ae(c, m), -1, h, a);
    }
    if (c.type === "object")
      return cn(p) && (l += 1), l + i3(e, t, c, p, a);
    if (c.type === Tx(p)) {
      let m = l + 1;
      return c.default ? m += p === c.default ? 1 : -1 : c.const && (m += p === c.const ? 1 : -1), m;
    }
    return l;
  }, 0) : md(n.type) && n.type === Tx(r) && (s += 1)), s;
}
function Lx(e, t, n, r, a = -1, s, l) {
  const c = r.map((v) => Mh(v, t, [])), d = EH(n, r, s);
  if (_H(d))
    return d;
  const p = c.reduce((v, y, w) => (GA(e, n, [oEe, y], t, s) === 1 && v.push(w), v), []);
  if (p.length === 1)
    return p[0];
  p.length || KV(c.length, (v) => p.push(v));
  const m = /* @__PURE__ */ new Set(), { bestIndex: h } = p.reduce((v, y) => {
    const { bestScore: w } = v, x = c[y], b = i3(e, t, x, n, l);
    return m.add(b), b > w ? { bestIndex: y, bestScore: b } : v;
  }, { bestIndex: a, bestScore: 0 });
  return m.size === 1 && a >= 0 ? a : h;
}
function KA(e) {
  return Array.isArray(e.items) && e.items.length > 0 && e.items.every((t) => on(t));
}
function j_(e) {
  return e == null;
}
function Ix(e, t, n = !1, r = !1, a = !1) {
  if (Array.isArray(t)) {
    const s = Array.isArray(e) ? e : [], l = a ? s : t, c = a ? t : s, d = l.map((p, m) => c[m] !== void 0 ? Ix(s[m], t[m], n, r, a) : p);
    return (n || a) && d.length < c.length && d.push(...c.slice(d.length)), d;
  }
  if (on(t)) {
    const s = Object.assign({}, e);
    return Object.keys(t).reduce((l, c) => {
      var d;
      const p = Ae(t, c), m = on(e) && c in e, h = c in t, v = (d = Ae(e, c)) !== null && d !== void 0 ? d : {}, y = m && Object.entries(v).some(([, b]) => on(b)), w = m && on(Ae(e, c)), x = h && on(p);
      return w && x && !y ? (l[c] = {
        ...Ae(e, c),
        ...p
      }, l) : (l[c] = Ix(
        Ae(e, c),
        p,
        n,
        r,
        // overrideFormDataWithDefaults can be true only when the key value exists in defaults
        // Or if the key value doesn't exist in formData
        a && (m || !h)
      ), l);
    }, s);
  }
  return r && (e !== void 0 && j_(t) || typeof t == "number" && isNaN(t)) || a && !j_(t) ? e : t;
}
function zx(e, t, n = !1) {
  return Object.keys(t).reduce((r, a) => {
    const s = e ? e[a] : {}, l = t[a];
    if (e && a in e && on(l))
      r[a] = zx(s, l, n);
    else if (n && Array.isArray(s) && Array.isArray(l)) {
      let c = l;
      n === "preventDuplicates" && (c = l.reduce((d, p) => (s.includes(p) || d.push(p), d), [])), r[a] = s.concat(c);
    } else
      r[a] = l;
    return r;
  }, Object.assign({}, e));
}
function PH(e) {
  return Array.isArray(e.enum) && e.enum.length === 1 || Di in e;
}
function XA(e, t, n = {}, r) {
  const a = qo(e, t, n, void 0, r), s = a.oneOf || a.anyOf;
  return Array.isArray(a.enum) ? !0 : Array.isArray(s) ? s.every((l) => typeof l != "boolean" && PH(l)) : !1;
}
function YA(e, t, n, r) {
  return !t.uniqueItems || !t.items || typeof t.items == "boolean" ? !1 : XA(e, t.items, n, r);
}
function DH(e) {
  const t = e[Di], n = Vs(e);
  return on(t) && md(t?.$data) && n !== "object" && n !== "array";
}
function aEe(e) {
  if (Gwe in e && Array.isArray(e.enum) && e.enum.length === 1)
    return e.enum[0];
  if (Di in e)
    return e.const;
  throw new Error("schema cannot be inferred as a constant");
}
function Gh(e, t) {
  if (e.enum) {
    let s;
    if (t) {
      const { enumNames: l } = ht(t);
      s = l;
    }
    return e.enum.map((l, c) => ({ label: s?.[c] || String(l), value: l }));
  }
  let n, r;
  e.anyOf ? (n = e.anyOf, r = t?.anyOf) : e.oneOf && (n = e.oneOf, r = t?.oneOf);
  let a = Nl(e);
  if (t) {
    const { optionsSchemaSelector: s = a } = ht(t);
    a = s;
  }
  return n && n.map((s, l) => {
    const { title: c } = ht(r?.[l]), d = s;
    let p, m = c;
    if (a) {
      const h = Ae(d, [fn, a], {});
      p = Ae(h, tE, Ae(h, Di)), m = m || h?.title || d.title || String(p);
    } else
      p = aEe(d), m = m || d.title || String(p);
    return {
      schema: d,
      label: m,
      value: p
    };
  });
}
const iEe = ["string", "number", "integer", "boolean", "null"];
var Kh;
(function(e) {
  e[e.Ignore = 0] = "Ignore", e[e.Invert = 1] = "Invert", e[e.Fallback = 2] = "Fallback";
})(Kh || (Kh = {}));
function rN(e, t = Kh.Ignore, n = -1) {
  if (n >= 0) {
    if (Array.isArray(e.items) && n < e.items.length) {
      const r = e.items[n];
      if (typeof r != "boolean")
        return r;
    }
  } else if (e.items && !Array.isArray(e.items) && typeof e.items != "boolean")
    return e.items;
  return t !== Kh.Ignore && on(e.additionalItems) ? e.additionalItems : {};
}
function $H(e, t) {
  const { default: n, type: r } = e;
  return Array.isArray(r) && r.includes("null") && jr(t) && n === null ? null : t;
}
function OT(e, t, n, r, a, s = [], l = {}, c = !1, d = !1) {
  const { emptyObjectFields: p = "populateAllDefaults" } = l;
  if (r === !0 || c)
    e[t] = n;
  else if (r === "excludeObjectChildren")
    (d && n !== void 0 || !on(n) || !jr(n)) && (e[t] = n);
  else if (p !== "skipDefaults") {
    const m = a === void 0 ? s.includes(t) : a;
    on(n) ? p === "skipEmptyDefaults" ? jr(n) || (e[t] = n) : (!jr(n) || s.includes(t)) && (m || p !== "populateRequiredDefaults") && (e[t] = n) : (
      // Store computedDefault if it's a defined primitive (e.g., true) and satisfies certain conditions
      // Condition 1: computedDefault is not undefined
      // Condition 2: If emptyObjectFields is 'populateAllDefaults' or 'skipEmptyDefaults)
      // Or if isSelfOrParentRequired is 'true' and the key is a required field
      n !== void 0 && (p === "populateAllDefaults" || p === "skipEmptyDefaults" || m && s.includes(t)) && (e[t] = n)
    );
  }
}
function ed(e, t, n = {}) {
  const { parentDefaults: r, rawFormData: a, rootSchema: s = {}, includeUndefinedValues: l = !1, _recurseList: c = [], experimental_defaultFormStateBehavior: d = void 0, experimental_customMergeAllOf: p = void 0, required: m, shouldMergeDefaultsIntoFormData: h = !1, initialDefaultsGenerated: v } = n;
  let y = on(a) ? a : {};
  const w = on(t) ? t : {};
  let x = r, b = null, k = d, C = c;
  if (w[Di] !== void 0 && d?.constAsDefaults !== "never" && !DH(w))
    x = w[Di];
  else if (on(x) && on(w.default))
    x = zx(x, w.default);
  else if (tE in w && !w[sn] && !w[Ht] && !w[sr])
    x = w.default;
  else if (sr in w) {
    const N = w[sr];
    c.includes(N) || (C = c.concat(N), b = kH(N, s)), b && !x && (x = w.default), h && b && !on(a) && (y = a);
  } else if (EA in w) {
    const N = {
      ...MT(e, w, n, x),
      ...y
    };
    b = NH(e, w, s, !1, [], N, p)[0];
  } else if (KA(w))
    x = w.items.map((N, R) => ed(e, N, {
      rootSchema: s,
      includeUndefinedValues: l,
      _recurseList: c,
      experimental_defaultFormStateBehavior: d,
      experimental_customMergeAllOf: p,
      parentDefaults: Array.isArray(r) ? r[R] : void 0,
      rawFormData: y,
      required: m,
      shouldMergeDefaultsIntoFormData: h
    }));
  else if (Ht in w) {
    const { oneOf: N, ...R } = w;
    if (N.length === 0)
      return;
    const j = Nl(w), { type: D = "null" } = R;
    !Array.isArray(D) && iEe.includes(D) && k?.constAsDefaults === "skipOneOf" && (k = {
      ...k,
      constAsDefaults: "never"
    }), b = N[Lx(e, s, a ?? w.default, N, 0, j, p)], b = Ec(R, b);
  } else if (sn in w) {
    const { anyOf: N, ...R } = w;
    if (N.length === 0)
      return;
    const j = Nl(w);
    b = N[Lx(e, s, a ?? w.default, N, 0, j, p)], b = Ec(R, b);
  }
  if (b)
    return ed(e, b, {
      rootSchema: s,
      includeUndefinedValues: l,
      _recurseList: C,
      experimental_defaultFormStateBehavior: k,
      experimental_customMergeAllOf: p,
      parentDefaults: x,
      rawFormData: a ?? y,
      required: m,
      shouldMergeDefaultsIntoFormData: h,
      initialDefaultsGenerated: v
    });
  x === void 0 && (x = w.default);
  let O = MT(e, w, n, x) ?? x;
  if (h) {
    const { arrayMinItems: N = {} } = d || {}, { mergeExtraDefaults: R } = N, j = sEe(e, w, s, a, d, p);
    (!on(a) || fd in w) && (O = Ix(O, j, R, !0));
  }
  return O;
}
function sEe(e, t, n, r, a, s) {
  const l = !PH(t) && XA(e, t, n, s);
  let c = r;
  return l && (c = Gh(t)?.some((p) => Yn(p.value, r)) ? r : void 0), t[Di] && a?.constAsDefaults === "always" && (c = t.const), c;
}
function lEe(e, t, { rawFormData: n, rootSchema: r = {}, includeUndefinedValues: a = !1, _recurseList: s = [], experimental_defaultFormStateBehavior: l = void 0, experimental_customMergeAllOf: c = void 0, required: d, shouldMergeDefaultsIntoFormData: p, initialDefaultsGenerated: m } = {}, h) {
  {
    const v = on(n) ? n : {}, y = t, w = l?.allOf === "populateDefaults" && fd in y ? qo(e, y, r, v, c) : y, x = w[Di], b = Object.keys(w.properties || {}).reduce((k, C) => {
      var _;
      const O = Ae(w, [fn, C], {}), N = on(x) && x[C] !== void 0, R = (on(O) && Di in O || N) && l?.constAsDefaults !== "never" && !DH(O), j = ed(e, O, {
        rootSchema: r,
        _recurseList: s,
        experimental_defaultFormStateBehavior: l,
        experimental_customMergeAllOf: c,
        includeUndefinedValues: a === !0,
        parentDefaults: Ae(h, [C]),
        rawFormData: Ae(v, [C]),
        required: (_ = w.required) === null || _ === void 0 ? void 0 : _.includes(C),
        shouldMergeDefaultsIntoFormData: p,
        initialDefaultsGenerated: m
      });
      return OT(k, C, j, a, d, w.required, l, R, O?.type === "null"), k;
    }, {});
    if (w.additionalProperties && !m) {
      const k = on(w.additionalProperties) ? w.additionalProperties : {}, C = /* @__PURE__ */ new Set();
      on(h) && Object.keys(h).filter((O) => !w.properties || !w.properties[O]).forEach((O) => C.add(O));
      const _ = [];
      Object.keys(v).filter((O) => !w.properties || !w.properties[O]).forEach((O) => {
        C.add(O), _.push(O);
      }), C.forEach((O) => {
        var N;
        const R = ed(e, k, {
          rootSchema: r,
          _recurseList: s,
          experimental_defaultFormStateBehavior: l,
          experimental_customMergeAllOf: c,
          includeUndefinedValues: a === !0,
          parentDefaults: Ae(h, [O]),
          rawFormData: Ae(v, [O]),
          required: (N = w.required) === null || N === void 0 ? void 0 : N.includes(O),
          shouldMergeDefaultsIntoFormData: p,
          initialDefaultsGenerated: m
        });
        OT(b, O, R, a, d, _);
      });
    }
    return $H(t, b);
  }
}
function uEe(e, t, { rawFormData: n, rootSchema: r = {}, _recurseList: a = [], experimental_defaultFormStateBehavior: s = void 0, experimental_customMergeAllOf: l = void 0, required: c, requiredAsRoot: d = !1, shouldMergeDefaultsIntoFormData: p, initialDefaultsGenerated: m } = {}, h) {
  var v, y;
  const w = t, x = (v = s?.arrayMinItems) !== null && v !== void 0 ? v : {}, { populate: b, mergeExtraDefaults: k } = x, C = b === "never", _ = b === "requiredOnly", O = b === "all" || !C && !_, N = (y = x?.computeSkipPopulate) !== null && y !== void 0 ? y : (() => !1), R = s?.emptyObjectFields === "skipEmptyDefaults" ? void 0 : [];
  if (Array.isArray(h) && (h = h.map(($, z) => {
    const B = rN(w, Kh.Fallback, z);
    return ed(e, B, {
      rootSchema: r,
      _recurseList: a,
      experimental_defaultFormStateBehavior: s,
      experimental_customMergeAllOf: l,
      parentDefaults: $,
      required: c,
      shouldMergeDefaultsIntoFormData: p,
      initialDefaultsGenerated: m
    });
  })), Array.isArray(n)) {
    const $ = rN(w);
    if (C)
      h = n;
    else {
      const z = n.map((B, P) => ed(e, $, {
        rootSchema: r,
        _recurseList: a,
        experimental_defaultFormStateBehavior: s,
        experimental_customMergeAllOf: l,
        rawFormData: B,
        parentDefaults: Ae(h, [P]),
        required: c,
        shouldMergeDefaultsIntoFormData: p,
        initialDefaultsGenerated: m
      }));
      h = Ix(h, z, (_ && c || O) && k);
    }
  }
  if ((on(w) && Di in w && s?.constAsDefaults !== "never") === !1) {
    if (C)
      return h ?? R;
    if (_ && !c)
      return h || void 0;
  }
  let j;
  const D = Array.isArray(h) ? h.length : 0;
  if (!w.minItems || YA(e, w, r, l) || N(e, w, r) || w.minItems <= D)
    j = h || !c && !d ? h : R;
  else {
    const $ = h || [], z = rN(w, Kh.Invert), B = z.default, P = Array.from({ length: w.minItems - D }, () => ed(e, z, {
      parentDefaults: B,
      rootSchema: r,
      _recurseList: a,
      experimental_defaultFormStateBehavior: s,
      experimental_customMergeAllOf: l,
      required: c,
      shouldMergeDefaultsIntoFormData: p
    }));
    j = $.concat(P);
  }
  return $H(t, j);
}
function MT(e, t, n = {}, r) {
  switch (Vs(t)) {
    // We need to recurse for object schema inner default values.
    case "object":
      return lEe(e, t, n, r);
    case "array":
      return uEe(e, t, n, r);
  }
}
function TH(e, t, n, r, a = !1, s, l, c) {
  if (!on(t))
    throw new Error("Invalid schema: " + t);
  const d = qo(e, t, r, n, l), p = ed(e, d, {
    rootSchema: r,
    includeUndefinedValues: a,
    experimental_defaultFormStateBehavior: s,
    experimental_customMergeAllOf: l,
    rawFormData: n,
    shouldMergeDefaultsIntoFormData: !0,
    initialDefaultsGenerated: c,
    requiredAsRoot: !0
  });
  if (d.type !== "object" && on(d.default))
    return {
      ...p,
      ...n
    };
  if (on(n) || Array.isArray(n)) {
    const { mergeDefaultsIntoFormData: m } = s || {};
    return Ix(
      p,
      n,
      !0,
      m === "useDefaultIfFormDataUndefined",
      !0
    );
  }
  return p;
}
function LH(e = {}) {
  return (
    // TODO: Remove the `&& uiSchema['ui:widget'] !== 'hidden'` once we support hidden widgets for arrays.
    // https://rjsf-team.github.io/react-jsonschema-form/docs/usage/widgets/#hidden-widgets
    "widget" in ht(e) && ht(e).widget !== "hidden"
  );
}
function IH(e, t, n = {}, r, a) {
  if (n[OA] === "files")
    return !0;
  if (t.items) {
    const s = qo(e, t.items, r, void 0, a);
    return s.type === "string" && s.format === "data-url";
  }
  return !1;
}
function cEe(e, t, n = {}, r, a, s) {
  const l = ht(n, a), { label: c = !0 } = l;
  let d = !!c;
  if (d) {
    const p = Vs(t), m = Ae(t, hc, !1);
    p === "array" && (d = m || YA(e, t, r, s) || IH(e, t, n, r, s) || LH(n)), p === "object" && (d = m), p === "boolean" && n && !n[OA] && (d = !1), n && n[Jwe] && (d = !1);
  }
  return d;
}
const Ym = /* @__PURE__ */ Symbol("no Value");
function s3(e, t, n, r, a = {}, s) {
  let l;
  if (Zt(n, fn)) {
    const c = {};
    if (Zt(r, fn)) {
      const m = Ae(r, fn, {});
      Object.keys(m).forEach((h) => {
        Zt(a, h) && (c[h] = void 0);
      });
    }
    const d = Object.keys(Ae(n, fn, {})), p = {};
    d.forEach((m) => {
      const h = Ae(a, m);
      let v = Ae(r, [fn, m], {}), y = Ae(n, [fn, m], {});
      Zt(v, sr) && (v = qo(e, v, t, h, s)), Zt(y, sr) && (y = qo(e, y, t, h, s));
      const w = Ae(v, "type"), x = Ae(y, "type");
      if (!w || w === x)
        if (Zt(c, m) && delete c[m], x === "object" || x === "array" && Array.isArray(h)) {
          const b = s3(e, t, y, v, h, s);
          (b !== void 0 || x === "array") && (p[m] = b);
        } else {
          const b = Ae(y, "default", Ym), k = Ae(v, "default", Ym);
          b !== Ym && b !== h && (k === h ? c[m] = b : Ae(y, "readOnly") === !0 && (c[m] = void 0));
          const C = Ae(y, "const", Ym), _ = Ae(v, "const", Ym);
          C !== Ym && C !== h && (c[m] = _ === h ? C : void 0);
        }
    }), l = {
      ...typeof a == "string" || Array.isArray(a) ? void 0 : a,
      ...c,
      ...p
    };
  } else if (Ae(r, "type") === "array" && Ae(n, "type") === "array" && Array.isArray(a)) {
    let c = Ae(r, "items"), d = Ae(n, "items");
    if (typeof c == "object" && typeof d == "object" && !Array.isArray(c) && !Array.isArray(d)) {
      Zt(c, sr) && (c = qo(e, c, t, a, s)), Zt(d, sr) && (d = qo(e, d, t, a, s));
      const p = Ae(c, "type"), m = Ae(d, "type");
      if (!p || p === m) {
        const h = Ae(n, "maxItems", -1);
        m === "object" ? l = a.reduce((v, y) => {
          const w = s3(e, t, d, c, y, s);
          return w !== void 0 && (h < 0 || v.length < h) && v.push(w), v;
        }, []) : l = h > 0 && a.length > h ? a.slice(0, h) : a;
      }
    } else typeof c == "boolean" && typeof d == "boolean" && c === d && (l = a);
  }
  return l;
}
function Yp(e, t, n, r, a, s = [], l) {
  if (sr in t || EA in t || fd in t) {
    const d = qo(e, t, r, a, l);
    if (s.findIndex((p) => Yn(p, d)) === -1)
      return Yp(e, d, n, r, a, s.concat(d), l);
  }
  let c = {
    [T0]: n.replace(/^\./, "")
  };
  if (Ht in t || sn in t) {
    const d = Ht in t ? t.oneOf : t.anyOf, p = Nl(t), m = Lx(e, r, a, d, 0, p, l), h = d[m];
    c = {
      ...c,
      ...Yp(e, h, n, r, a, s, l)
    };
  }
  if (O_ in t && t[O_] !== !1 && Pn(c, CA, !0), Hh in t && Array.isArray(a)) {
    const { items: d, additionalItems: p } = t;
    Array.isArray(d) ? a.forEach((m, h) => {
      d[h] ? c[h] = Yp(e, d[h], `${n}.${h}`, r, m, s, l) : p ? c[h] = Yp(e, p, `${n}.${h}`, r, m, s, l) : console.warn(`Unable to generate path schema for "${n}.${h}". No schema defined for it`);
    }) : a.forEach((m, h) => {
      c[h] = Yp(e, d, `${n}.${h}`, r, m, s, l);
    });
  } else if (fn in t)
    for (const d in t.properties) {
      const p = Ae(t, [fn, d], {});
      c[d] = Yp(
        e,
        p,
        `${n}.${d}`,
        r,
        // It's possible that formData is not an object -- this can happen if an
        // array item has just been added, but not populated with data yet
        Ae(a, [d]),
        s,
        l
      );
    }
  return c;
}
function dEe(e, t, n = "", r, a, s) {
  return Yp(e, t, n, r, a, void 0, s);
}
class fEe {
  /** Constructs the `SchemaUtils` instance with the given `validator` and `rootSchema` stored as instance variables
   *
   * @param validator - An implementation of the `ValidatorType` interface that will be forwarded to all the APIs
   * @param rootSchema - The root schema that will be forwarded to all the APIs
   * @param experimental_defaultFormStateBehavior - Configuration flags to allow users to override default form state behavior
   * @param [experimental_customMergeAllOf] - Optional function that allows for custom merging of `allOf` schemas
   */
  constructor(t, n, r, a) {
    n && n[Lw] === L0 ? this.rootSchema = a3(n, Ae(n, $n, "#")) : this.rootSchema = n, this.validator = t, this.experimental_defaultFormStateBehavior = r, this.experimental_customMergeAllOf = a;
  }
  /** Returns the `rootSchema` in the `SchemaUtilsType`
   *
   * @returns - The `rootSchema`
   */
  getRootSchema() {
    return this.rootSchema;
  }
  /** Returns the `ValidatorType` in the `SchemaUtilsType`
   *
   * @returns - The `ValidatorType`
   */
  getValidator() {
    return this.validator;
  }
  /** Determines whether either the `validator` and `rootSchema` differ from the ones associated with this instance of
   * the `SchemaUtilsType`. If either `validator` or `rootSchema` are falsy, then return false to prevent the creation
   * of a new `SchemaUtilsType` with incomplete properties.
   *
   * @param validator - An implementation of the `ValidatorType` interface that will be compared against the current one
   * @param rootSchema - The root schema that will be compared against the current one
   * @param [experimental_defaultFormStateBehavior] Optional configuration object, if provided, allows users to override default form state behavior
   * @param [experimental_customMergeAllOf] - Optional function that allows for custom merging of `allOf` schemas
   * @returns - True if the `SchemaUtilsType` differs from the given `validator` or `rootSchema`
   */
  doesSchemaUtilsDiffer(t, n, r = {}, a) {
    return !t || !n ? !1 : this.validator !== t || !Yn(this.rootSchema, n) || !Yn(this.experimental_defaultFormStateBehavior, r) || this.experimental_customMergeAllOf !== a;
  }
  /** Finds the field specified by the `path` within the root or recursed `schema`. If there is no field for the specified
   * `path`, then the default `{ field: undefined, isRequired: undefined }` is returned. It determines whether a leaf
   * field is in the `required` list for its parent and if so, it is marked as required on return.
   *
   * @param schema - The current node within the JSON schema
   * @param path - The remaining keys in the path to the desired field
   * @param [formData] - The form data that is used to determine which oneOf option
   * @returns - An object that contains the field and its required state. If no field can be found then
   *            `{ field: undefined, isRequired: undefined }` is returned.
   */
  findFieldInSchema(t, n, r) {
    return Z2e(this.validator, this.rootSchema, t, n, r, this.experimental_customMergeAllOf);
  }
  /** Finds the oneOf option inside the `schema['any/oneOf']` list which has the `properties[selectorField].default` that
   * matches the `formData[selectorField]` value. For the purposes of this function, `selectorField` is either
   * `schema.discriminator.propertyName` or `fallbackField`.
   *
   * @param schema - The schema element in which to search for the selected oneOf option
   * @param fallbackField - The field to use as a backup selector field if the schema does not have a required field
   * @param xxx - Either `oneOf` or `anyOf`, defines which value is being sought
   * @param [formData={}] - The form data that is used to determine which oneOf option
   * @returns - The anyOf/oneOf option that matches the selector field in the schema or undefined if nothing is selected
   */
  findSelectedOptionInXxxOf(t, n, r, a) {
    return zw(this.validator, this.rootSchema, t, n, r, a, this.experimental_customMergeAllOf);
  }
  /** Returns the superset of `formData` that includes the given set updated to include any missing fields that have
   * computed to have defaults provided in the `schema`.
   *
   * @param schema - The schema for which the default state is desired
   * @param [formData] - The current formData, if any, onto which to provide any missing defaults
   * @param [includeUndefinedValues=false] - Optional flag, if true, cause undefined values to be added as defaults.
   *          If "excludeObjectChildren", pass `includeUndefinedValues` as false when computing defaults for any nested
   *          object properties.
   * @param initialDefaultsGenerated - Indicates whether or not initial defaults have been generated
   * @returns - The resulting `formData` with all the defaults provided
   */
  getDefaultFormState(t, n, r = !1, a) {
    return TH(this.validator, t, n, this.rootSchema, r, this.experimental_defaultFormStateBehavior, this.experimental_customMergeAllOf, a);
  }
  /** Determines whether the combination of `schema` and `uiSchema` properties indicates that the label for the `schema`
   * should be displayed in a UI.
   *
   * @param schema - The schema for which the display label flag is desired
   * @param [uiSchema] - The UI schema from which to derive potentially displayable information
   * @param [globalOptions={}] - The optional Global UI Schema from which to get any fallback `xxx` options
   * @returns - True if the label should be displayed or false if it should not
   */
  getDisplayLabel(t, n, r) {
    return cEe(this.validator, t, n, this.rootSchema, r, this.experimental_customMergeAllOf);
  }
  /** Determines which of the given `options` provided most closely matches the `formData`.
   * Returns the index of the option that is valid and is the closest match, or 0 if there is no match.
   *
   * The closest match is determined using the number of matching properties, and more heavily favors options with
   * matching readOnly, default, or const values.
   *
   * @param formData - The form data associated with the schema
   * @param options - The list of options that can be selected from
   * @param [selectedOption] - The index of the currently selected option, defaulted to -1 if not specified
   * @param [discriminatorField] - The optional name of the field within the options object whose value is used to
   *          determine which option is selected
   * @returns - The index of the option that is the closest match to the `formData` or the `selectedOption` if no match
   */
  getClosestMatchingOption(t, n, r, a) {
    return Lx(this.validator, this.rootSchema, t, n, r, a, this.experimental_customMergeAllOf);
  }
  /** Given the `formData` and list of `options`, attempts to find the index of the first option that matches the data.
   * Always returns the first option if there is nothing that matches.
   *
   * @param formData - The current formData, if any, used to figure out a match
   * @param options - The list of options to find a matching options from
   * @param [discriminatorField] - The optional name of the field within the options object whose value is used to
   *          determine which option is selected
   * @returns - The firstindex of the matched option or 0 if none is available
   */
  getFirstMatchingOption(t, n, r) {
    return GA(this.validator, t, n, this.rootSchema, r);
  }
  getFromSchema(t, n, r) {
    return F0(
      this.validator,
      this.rootSchema,
      t,
      n,
      // @ts-expect-error TS2769: No overload matches this call
      r,
      this.experimental_customMergeAllOf
    );
  }
  /** Checks to see if the `schema` and `uiSchema` combination represents an array of files
   *
   * @param schema - The schema for which check for array of files flag is desired
   * @param [uiSchema] - The UI schema from which to check the widget
   * @returns - True if schema/uiSchema contains an array of files, otherwise false
   */
  isFilesArray(t, n) {
    return IH(this.validator, t, n, this.rootSchema, this.experimental_customMergeAllOf);
  }
  /** Checks to see if the `schema` combination represents a multi-select
   *
   * @param schema - The schema for which check for a multi-select flag is desired
   * @returns - True if schema contains a multi-select, otherwise false
   */
  isMultiSelect(t) {
    return YA(this.validator, t, this.rootSchema, this.experimental_customMergeAllOf);
  }
  /** Checks to see if the `schema` combination represents a select
   *
   * @param schema - The schema for which check for a select flag is desired
   * @returns - True if schema contains a select, otherwise false
   */
  isSelect(t) {
    return XA(this.validator, t, this.rootSchema, this.experimental_customMergeAllOf);
  }
  /** Retrieves an expanded schema that has had all of its conditions, additional properties, references and
   * dependencies resolved and merged into the `schema` given a `rawFormData` that is used to do the potentially
   * recursive resolution.
   *
   * @param schema - The schema for which retrieving a schema is desired
   * @param [rawFormData] - The current formData, if any, to assist retrieving a schema
   * @param [resolveAnyOfOrOneOfRefs] - Optional flag indicating whether to resolved refs in anyOf/oneOf lists
   * @returns - The schema having its conditions, additional properties, references and dependencies resolved
   */
  retrieveSchema(t, n, r) {
    return qo(this.validator, t, this.rootSchema, n, this.experimental_customMergeAllOf, r);
  }
  /** Sanitize the `data` associated with the `oldSchema` so it is considered appropriate for the `newSchema`. If the
   * new schema does not contain any properties, then `undefined` is returned to clear all the form data. Due to the
   * nature of schemas, this sanitization happens recursively for nested objects of data. Also, any properties in the
   * old schemas that are non-existent in the new schema are set to `undefined`.
   *
   * @param [newSchema] - The new schema for which the data is being sanitized
   * @param [oldSchema] - The old schema from which the data originated
   * @param [data={}] - The form data associated with the schema, defaulting to an empty object when undefined
   * @returns - The new form data, with all the fields uniquely associated with the old schema set
   *      to `undefined`. Will return `undefined` if the new schema is not an object containing properties.
   */
  sanitizeDataForNewSchema(t, n, r) {
    return s3(this.validator, this.rootSchema, t, n, r, this.experimental_customMergeAllOf);
  }
  /** Generates an `PathSchema` object for the `schema`, recursively
   *
   * @param schema - The schema for which the display label flag is desired
   * @param [name] - The base name for the schema
   * @param [formData] - The current formData, if any, onto which to provide any missing defaults
   * @returns - The `PathSchema` object for the `schema`
   */
  toPathSchema(t, n, r) {
    return dEe(this.validator, t, n, this.rootSchema, r, this.experimental_customMergeAllOf);
  }
}
function pEe(e, t, n = {}, r) {
  return new fEe(e, t, n, r);
}
function mEe(e) {
  var t;
  if (e.indexOf("data:") === -1)
    throw new Error("File is invalid: URI must be a dataURI");
  const n = e.slice(5).split(";base64,");
  if (n.length !== 2)
    throw new Error("File is invalid: dataURI must be base64");
  const [r, a] = n, [s, ...l] = r.split(";"), c = s || "", d = decodeURI(
    // parse the parameters into key-value pairs, find a key, and extract a value
    // if no key is found, then the name is unknown
    ((t = l.map((p) => p.split("=")).find(([p]) => p === "name")) === null || t === void 0 ? void 0 : t[1]) || "unknown"
  );
  try {
    const p = atob(a), m = new Array(p.length);
    for (let h = 0; h < p.length; h++)
      m[h] = p.charCodeAt(h);
    return { blob: new window.Blob([new Uint8Array(m)], { type: c }), name: d };
  } catch (p) {
    throw new Error("File is invalid: " + p.message);
  }
}
function qc(e, t) {
  let n = String(e);
  for (; n.length < t; )
    n = "0" + n;
  return n;
}
function zH(e, t) {
  if (e <= 0 && t <= 0)
    e = (/* @__PURE__ */ new Date()).getFullYear() + e, t = (/* @__PURE__ */ new Date()).getFullYear() + t;
  else if (e < 0 || t < 0)
    throw new Error(`Both start (${e}) and stop (${t}) must both be <= 0 or > 0, got one of each`);
  if (e > t)
    return zH(t, e).reverse();
  const n = [];
  for (let r = e; r <= t; r++)
    n.push({ value: r, label: qc(r, 2) });
  return n;
}
function NT(e, t) {
  if (Object.is(e, t))
    return !0;
  if (e == null || t == null || typeof e != "object" || typeof t != "object")
    return !1;
  const n = Object.keys(e), r = Object.keys(t);
  if (n.length !== r.length)
    return !1;
  for (let a = 0; a < n.length; a++) {
    const s = n[a];
    if (!Object.prototype.hasOwnProperty.call(t, s) || !Object.is(e[s], t[s]))
      return !1;
  }
  return !0;
}
function hEe(e, t) {
  let n = e;
  if (Array.isArray(t)) {
    const r = n.split(/(%\d)/);
    t.forEach((a, s) => {
      const l = r.findIndex((c) => c === `%${s + 1}`);
      l >= 0 && (r[l] = a);
    }), n = r.join("");
  }
  return n;
}
function gEe(e, t) {
  return hEe(e, t);
}
function to(e, t = [], n) {
  if (Array.isArray(e))
    return e.map((s) => to(s, t)).filter((s) => s !== n);
  const r = e === "" || e === null ? -1 : Number(e), a = t[r];
  return a ? a.value : n;
}
function FH(e, t, n = []) {
  const r = to(e, n);
  return Array.isArray(t) ? t.filter((a) => !Yn(a, r)) : Yn(r, t) ? void 0 : t;
}
function dE(e, t) {
  return Array.isArray(t) ? t.some((n) => Yn(n, e)) : Yn(t, e);
}
function QA(e, t = [], n = !1) {
  const r = t.map((a, s) => dE(a.value, e) ? String(s) : void 0).filter((a) => typeof a < "u");
  return n ? r : r[0];
}
function BH(e, t, n = []) {
  const r = to(e, n);
  if (!j_(r)) {
    const a = n.findIndex((l) => r === l.value), s = n.map(({ value: l }) => l);
    return t.slice(0, a).concat(r, t.slice(a)).sort((l, c) => +(s.indexOf(l) > s.indexOf(c)));
  }
  return t;
}
var vEe = 1, yEe = 4;
function JA(e) {
  return Jw(e, vEe | yEe);
}
function bEe(e, t, n, r) {
  return r = typeof r == "function" ? r : void 0, e == null ? e : IA(e, t, n, r);
}
class UH {
  /** Construct an `ErrorSchemaBuilder` with an optional initial set of errors in an `ErrorSchema`.
   *
   * @param [initialSchema] - The optional set of initial errors, that will be cloned into the class
   */
  constructor(t) {
    this.errorSchema = {}, this.resetAllErrors(t);
  }
  /** Returns the `ErrorSchema` that has been updated by the methods of the `ErrorSchemaBuilder`
   */
  get ErrorSchema() {
    return this.errorSchema;
  }
  /** Will get an existing `ErrorSchema` at the specified `pathOfError` or create and return one.
   *
   * @param [pathOfError] - The optional path into the `ErrorSchema` at which to add the error(s)
   * @returns - The error block for the given `pathOfError` or the root if not provided
   * @private
   */
  getOrCreateErrorBlock(t) {
    let n = Array.isArray(t) && t.length > 0 || typeof t == "string" ? Ae(this.errorSchema, t) : this.errorSchema;
    return !n && t && (n = {}, bEe(this.errorSchema, t, n, Object)), n;
  }
  /** Resets all errors in the `ErrorSchemaBuilder` back to the `initialSchema` if provided, otherwise an empty set.
   *
   * @param [initialSchema] - The optional set of initial errors, that will be cloned into the class
   * @returns - The `ErrorSchemaBuilder` object for chaining purposes
   */
  resetAllErrors(t) {
    return this.errorSchema = t ? JA(t) : {}, this;
  }
  /** Adds the `errorOrList` to the list of errors in the `ErrorSchema` at either the root level or the location within
   * the schema described by the `pathOfError`. For more information about how to specify the path see the
   * [eslint lodash plugin docs](https://github.com/wix/eslint-plugin-lodash/blob/master/docs/rules/path-style.md).
   *
   * @param errorOrList - The error or list of errors to add into the `ErrorSchema`
   * @param [pathOfError] - The optional path into the `ErrorSchema` at which to add the error(s)
   * @returns - The `ErrorSchemaBuilder` object for chaining purposes
   */
  addErrors(t, n) {
    const r = this.getOrCreateErrorBlock(n);
    let a = Ae(r, Po);
    return Array.isArray(a) || (a = [], r[Po] = a), Array.isArray(t) ? Pn(r, Po, [.../* @__PURE__ */ new Set([...a, ...t])]) : Pn(r, Po, [.../* @__PURE__ */ new Set([...a, t])]), this;
  }
  /** Sets/replaces the `errorOrList` as the error(s) in the `ErrorSchema` at either the root level or the location
   * within the schema described by the `pathOfError`. For more information about how to specify the path see the
   * [eslint lodash plugin docs](https://github.com/wix/eslint-plugin-lodash/blob/master/docs/rules/path-style.md).
   *
   * @param errorOrList - The error or list of errors to set into the `ErrorSchema`
   * @param [pathOfError] - The optional path into the `ErrorSchema` at which to set the error(s)
   * @returns - The `ErrorSchemaBuilder` object for chaining purposes
   */
  setErrors(t, n) {
    const r = this.getOrCreateErrorBlock(n), a = Array.isArray(t) ? [.../* @__PURE__ */ new Set([...t])] : [t];
    return Pn(r, Po, a), this;
  }
  /** Clears the error(s) in the `ErrorSchema` at either the root level or the location within the schema described by
   * the `pathOfError`. For more information about how to specify the path see the
   * [eslint lodash plugin docs](https://github.com/wix/eslint-plugin-lodash/blob/master/docs/rules/path-style.md).
   *
   * @param [pathOfError] - The optional path into the `ErrorSchema` at which to clear the error(s)
   * @returns - The `ErrorSchemaBuilder` object for chaining purposes
   */
  clearErrors(t) {
    const n = this.getOrCreateErrorBlock(t);
    return Pn(n, Po, []), this;
  }
}
function VH(e, t, n) {
  for (var r = -1, a = t.length, s = {}; ++r < a; ) {
    var l = t[r], c = sE(e, l);
    n(c, l) && IA(s, ug(l, e), c);
  }
  return s;
}
function wEe(e, t) {
  if (e == null)
    return {};
  var n = lg(HA(e), function(r) {
    return [r];
  });
  return t = FA(t), VH(e, n, function(r, a) {
    return t(r, a[0]);
  });
}
var xEe = 200;
function SEe(e, t, n, r) {
  var a = -1, s = VA, l = !0, c = e.length, d = [], p = t.length;
  if (!c)
    return d;
  t.length >= xEe && (s = jx, l = !1, t = new vm(t));
  e:
    for (; ++a < c; ) {
      var m = e[a], h = m;
      if (m = m !== 0 ? m : 0, l && h === h) {
        for (var v = p; v--; )
          if (t[v] === h)
            continue e;
        d.push(m);
      } else s(t, h, r) || d.push(m);
    }
  return d;
}
var kEe = uE(function(e, t) {
  return Dx(e) ? SEe(e, NS(t, 1, Dx, !0)) : [];
});
function RT(e, t) {
  const n = pd(e), r = pd(t);
  if (e === t || !n && !r)
    return [];
  if (n && !r)
    return Ps(e);
  if (!n && r)
    return Ps(t);
  {
    const a = Ps(wEe(e, (l, c) => !Yn(l, Ae(t, c)))), s = kEe(Ps(t), Ps(e));
    return [...a, ...s];
  }
}
function _Ee(e, t, n = [1900, (/* @__PURE__ */ new Date()).getFullYear() + 2], r = "YMD") {
  const { day: a, month: s, year: l, hour: c, minute: d, second: p } = e, m = { type: "day", range: [1, 31], value: a }, h = { type: "month", range: [1, 12], value: s }, v = { type: "year", range: n, value: l }, y = [];
  switch (r) {
    case "MDY":
      y.push(h, m, v);
      break;
    case "DMY":
      y.push(m, h, v);
      break;
    default:
      y.push(v, h, m);
  }
  return t && y.push({ type: "hour", range: [0, 23], value: c }, { type: "minute", range: [0, 59], value: d }, { type: "second", range: [0, 59], value: p }), y;
}
function HH(e) {
  const t = {};
  return e.multipleOf && (t.step = e.multipleOf), (e.minimum || e.minimum === 0) && (t.min = e.minimum), (e.maximum || e.maximum === 0) && (t.max = e.maximum), t;
}
function qH(e, t, n = {}, r = !0) {
  const a = {
    type: t || "text",
    ...HH(e)
  };
  return n.inputType ? a.type = n.inputType : t || (e.type === "number" ? (a.type = "number", r && a.step === void 0 && (a.step = "any")) : e.type === "integer" && (a.type = "number", a.step === void 0 && (a.step = 1))), n.autocomplete && (a.autoComplete = n.autocomplete), n.accept && (a.accept = n.accept), a;
}
const AT = {
  props: {
    disabled: !1
  },
  submitText: "Submit",
  norender: !1
};
function WH(e = {}) {
  const t = ht(e);
  if (t && t[M_]) {
    const n = t[M_];
    return { ...AT, ...n };
  }
  return AT;
}
function bt(e, t, n = {}) {
  const { templates: r } = t;
  if (e === "ButtonTemplates")
    return r[e];
  if (Object.hasOwn(n, e) && typeof n[e] == "string" && Object.hasOwn(r, n[e])) {
    const a = n[e];
    return r[a];
  }
  return (
    // Evaluating uiOptions[name] results in TS2590: Expression produces a union type that is too complex to represent
    // To avoid that, we cast uiOptions to `any` before accessing the name field
    n[e] || r[e]
  );
}
var EEe = 0;
function GH(e) {
  var t = ++EEe;
  return $A(e) + t;
}
function ZA() {
  if (typeof process > "u" || Ae(process, "env.NODE_ENV") !== "test")
    return {};
  const e = /* @__PURE__ */ new Map();
  return new Proxy({}, {
    get(t, n) {
      return e.has(n) || e.set(n, GH("test-id-")), e.get(n);
    }
  });
}
var jT = { exports: {} }, xn = {}, PT;
function CEe() {
  if (PT) return xn;
  PT = 1;
  var e = /* @__PURE__ */ Symbol.for("react.element"), t = /* @__PURE__ */ Symbol.for("react.portal"), n = /* @__PURE__ */ Symbol.for("react.fragment"), r = /* @__PURE__ */ Symbol.for("react.strict_mode"), a = /* @__PURE__ */ Symbol.for("react.profiler"), s = /* @__PURE__ */ Symbol.for("react.provider"), l = /* @__PURE__ */ Symbol.for("react.context"), c = /* @__PURE__ */ Symbol.for("react.server_context"), d = /* @__PURE__ */ Symbol.for("react.forward_ref"), p = /* @__PURE__ */ Symbol.for("react.suspense"), m = /* @__PURE__ */ Symbol.for("react.suspense_list"), h = /* @__PURE__ */ Symbol.for("react.memo"), v = /* @__PURE__ */ Symbol.for("react.lazy"), y = /* @__PURE__ */ Symbol.for("react.offscreen"), w;
  w = /* @__PURE__ */ Symbol.for("react.module.reference");
  function x(b) {
    if (typeof b == "object" && b !== null) {
      var k = b.$$typeof;
      switch (k) {
        case e:
          switch (b = b.type, b) {
            case n:
            case a:
            case r:
            case p:
            case m:
              return b;
            default:
              switch (b = b && b.$$typeof, b) {
                case c:
                case l:
                case d:
                case v:
                case h:
                case s:
                  return b;
                default:
                  return k;
              }
          }
        case t:
          return k;
      }
    }
  }
  return xn.ContextConsumer = l, xn.ContextProvider = s, xn.Element = e, xn.ForwardRef = d, xn.Fragment = n, xn.Lazy = v, xn.Memo = h, xn.Portal = t, xn.Profiler = a, xn.StrictMode = r, xn.Suspense = p, xn.SuspenseList = m, xn.isAsyncMode = function() {
    return !1;
  }, xn.isConcurrentMode = function() {
    return !1;
  }, xn.isContextConsumer = function(b) {
    return x(b) === l;
  }, xn.isContextProvider = function(b) {
    return x(b) === s;
  }, xn.isElement = function(b) {
    return typeof b == "object" && b !== null && b.$$typeof === e;
  }, xn.isForwardRef = function(b) {
    return x(b) === d;
  }, xn.isFragment = function(b) {
    return x(b) === n;
  }, xn.isLazy = function(b) {
    return x(b) === v;
  }, xn.isMemo = function(b) {
    return x(b) === h;
  }, xn.isPortal = function(b) {
    return x(b) === t;
  }, xn.isProfiler = function(b) {
    return x(b) === a;
  }, xn.isStrictMode = function(b) {
    return x(b) === r;
  }, xn.isSuspense = function(b) {
    return x(b) === p;
  }, xn.isSuspenseList = function(b) {
    return x(b) === m;
  }, xn.isValidElementType = function(b) {
    return typeof b == "string" || typeof b == "function" || b === n || b === a || b === r || b === p || b === m || b === y || typeof b == "object" && b !== null && (b.$$typeof === v || b.$$typeof === h || b.$$typeof === s || b.$$typeof === l || b.$$typeof === d || b.$$typeof === w || b.getModuleId !== void 0);
  }, xn.typeOf = x, xn;
}
var DT;
function OEe() {
  return DT || (DT = 1, jT.exports = CEe()), jT.exports;
}
var MEe = OEe();
const $T = /* @__PURE__ */ Oc(MEe), oN = {
  boolean: {
    checkbox: "CheckboxWidget",
    radio: "RadioWidget",
    select: "SelectWidget",
    hidden: "HiddenWidget"
  },
  string: {
    text: "TextWidget",
    password: "PasswordWidget",
    email: "EmailWidget",
    hostname: "TextWidget",
    ipv4: "TextWidget",
    ipv6: "TextWidget",
    uri: "URLWidget",
    "data-url": "FileWidget",
    radio: "RadioWidget",
    select: "SelectWidget",
    textarea: "TextareaWidget",
    hidden: "HiddenWidget",
    date: "DateWidget",
    datetime: "DateTimeWidget",
    "date-time": "DateTimeWidget",
    "alt-date": "AltDateWidget",
    "alt-datetime": "AltDateTimeWidget",
    time: "TimeWidget",
    color: "ColorWidget",
    file: "FileWidget"
  },
  number: {
    text: "TextWidget",
    select: "SelectWidget",
    updown: "UpDownWidget",
    range: "RangeWidget",
    radio: "RadioWidget",
    hidden: "HiddenWidget"
  },
  integer: {
    text: "TextWidget",
    select: "SelectWidget",
    updown: "UpDownWidget",
    range: "RangeWidget",
    radio: "RadioWidget",
    hidden: "HiddenWidget"
  },
  array: {
    select: "SelectWidget",
    checkboxes: "CheckboxesWidget",
    files: "FileWidget",
    hidden: "HiddenWidget"
  }
};
function NEe(e) {
  let t = Ae(e, "MergedWidget");
  if (!t) {
    const n = e.defaultProps && e.defaultProps.options || {};
    t = ({ options: r, ...a }) => E.jsx(e, { options: { ...n, ...r }, ...a }), Pn(e, "MergedWidget", t);
  }
  return t;
}
function Rl(e, t, n = {}) {
  const r = Vs(e);
  if (typeof t == "function" || t && $T.isForwardRef(M.createElement(t)) || $T.isMemo(t))
    return NEe(t);
  if (typeof t != "string")
    throw new Error(`Unsupported widget definition: ${typeof t} in schema: ${JSON.stringify(e)}`);
  if (t in n) {
    const a = n[t];
    return Rl(e, a, n);
  }
  if (typeof r == "string") {
    if (!(r in oN))
      throw new Error(`No widget for type '${r}' in schema: ${JSON.stringify(e)}`);
    if (t in oN[r]) {
      const a = n[oN[r][t]];
      return Rl(e, a, n);
    }
  }
  throw new Error(`No widget '${t}' for type '${r}' in schema: ${JSON.stringify(e)}`);
}
function REe(e) {
  let t = 0;
  for (let n = 0; n < e.length; n += 1) {
    const r = e.charCodeAt(n);
    t = (t << 5) - t + r, t = t & t;
  }
  return t.toString(16);
}
function AEe(e) {
  const t = /* @__PURE__ */ new Set();
  return JSON.stringify(e, (n, r) => (t.add(n), r)), JSON.stringify(e, Array.from(t).sort());
}
function gl(e) {
  return REe(AEe(e));
}
function jEe(e) {
  return gl(e);
}
function PEe(e, t, n = {}) {
  try {
    return Rl(e, t, n), !0;
  } catch (r) {
    const a = r;
    if (a.message && (a.message.startsWith("No widget") || a.message.startsWith("Unsupported widget")))
      return !1;
    throw r;
  }
}
function Nm(e, t) {
  return `${md(e) ? e : e[$n]}__${t}`;
}
function Rm(e) {
  return Nm(e, "description");
}
function e4(e) {
  return Nm(e, "error");
}
function Fx(e) {
  return Nm(e, "examples");
}
function t4(e) {
  return Nm(e, "help");
}
function fE(e) {
  return Nm(e, "title");
}
function _i(e, t = !1) {
  const n = t ? ` ${Fx(e)}` : "";
  return `${e4(e)} ${Rm(e)} ${t4(e)}${n}`;
}
function pE(e, t) {
  return `${e}-${t}`;
}
function vl(e, t) {
  return Nm(e, t);
}
function aN(e, t) {
  return Nm(e, `optional${t}`);
}
function dg(e) {
  return !j_(e) && (!cn(e) || Array.isArray(e) || !jr(e));
}
function DEe(e, t) {
  const { rootSchema: n, schemaUtils: r } = e;
  if (Px(t, n))
    return !0;
  if (sr in n) {
    const a = r.retrieveSchema(n);
    return Px(t, a);
  }
  return !1;
}
function Am(e, t, n) {
  return t ? n : e;
}
function $Ee(e) {
  return e ? new Date(e).toJSON() : void 0;
}
function n4(e, t, n) {
  const r = [Qwe];
  return Zt(e, T$) && r.unshift(T$), Ae(e, [...r, t], n);
}
function TEe(e, t) {
  if (!Array.isArray(t))
    return e;
  const n = (m) => m.reduce((h, v) => (h[v] = !0, h), {}), r = (m) => m.length > 1 ? `properties '${m.join("', '")}'` : `property '${m[0]}'`, a = n(e), s = t.filter((m) => m === "*" || a[m]), l = n(s), c = e.filter((m) => !l[m]), d = s.indexOf("*");
  if (d === -1) {
    if (c.length)
      throw new Error(`uiSchema order list does not contain ${r(c)}`);
    return s;
  }
  if (d !== s.lastIndexOf("*"))
    throw new Error("uiSchema order list contains more than one wildcard item");
  const p = [...s];
  return p.splice(d, 1, ...c), p;
}
function iN(e, t = !0) {
  if (!e)
    return {
      year: -1,
      month: -1,
      day: -1,
      hour: t ? -1 : 0,
      minute: t ? -1 : 0,
      second: t ? -1 : 0
    };
  const n = new Date(e);
  if (Number.isNaN(n.getTime()))
    throw new Error("Unable to parse date " + e);
  return {
    year: n.getUTCFullYear(),
    month: n.getUTCMonth() + 1,
    // oh you, javascript.
    day: n.getUTCDate(),
    hour: t ? n.getUTCHours() : 0,
    minute: t ? n.getUTCMinutes() : 0,
    second: t ? n.getUTCSeconds() : 0
  };
}
function Zw(e) {
  if (e.const || e.enum && e.enum.length === 1 && e.enum[0] === !0)
    return !0;
  if (e.anyOf && e.anyOf.length === 1)
    return Zw(e.anyOf[0]);
  if (e.oneOf && e.oneOf.length === 1)
    return Zw(e.oneOf[0]);
  if (e.allOf) {
    const t = (n) => Zw(n);
    return e.allOf.some(t);
  }
  return !1;
}
function KH(e, t, n, r = "customDeep") {
  if (r === "always")
    return !0;
  if (r === "shallow") {
    const { props: l, state: c } = e;
    return !NT(l, t) || !NT(c, n);
  }
  const { props: a, state: s } = e;
  return !Yn(a, t) || !Yn(s, n);
}
function TT(e) {
  const t = cH(e.map((n) => cn(n) ? Vs(n) : void 0).flat().filter((n) => n !== void 0));
  return t.length === 1 ? t[0] : t;
}
function RS(e, t, n, r) {
  const { enableOptionalDataFieldForType: a = [] } = ht(r, e.globalUiOptions);
  let s;
  return sn in t && Array.isArray(t[sn]) ? s = TT(t[sn]) : Ht in t && Array.isArray(t[Ht]) ? s = TT(t[Ht]) : s = Vs(t), !DEe(e, t) && !n && !!s && !Array.isArray(s) && !!a.find((l) => l === s);
}
function LT(e, t = !0) {
  const { year: n, month: r, day: a, hour: s = 0, minute: l = 0, second: c = 0 } = e, d = Date.UTC(n, r - 1, a, s, l, c), p = new Date(d).toJSON();
  return t ? p : p.slice(0, 10);
}
function r4(e, t = []) {
  if (!e)
    return [];
  let n = [];
  return Po in e && (n = n.concat(e[Po].map((r) => {
    const a = `.${t.join(".")}`;
    return {
      property: a,
      message: r,
      stack: `${a} ${r}`
    };
  }))), Object.keys(e).reduce((r, a) => {
    if (a !== Po) {
      const s = e[a];
      pd(s) && (r = r.concat(r4(s, [...t, a])));
    }
    return r;
  }, n);
}
function XH(e) {
  return eo(e) ? lg(e, Mm) : OS(e) ? [e] : UA(VV($A(e)));
}
function LEe(e) {
  const t = new UH();
  return e.length && e.forEach((n) => {
    const { property: r, message: a } = n, s = r === "." ? [] : XH(r);
    s.length > 0 && s[0] === "" && s.splice(0, 1), a && t.addErrors(a, s);
  }), t.ErrorSchema;
}
function Li(e, t, n, r) {
  const a = Array.isArray(n) ? n : n?.path, s = e === "" ? [] : [e], l = a ? a.concat(...s) : s, c = [t.idPrefix, ...l].join(t.idSeparator);
  let d;
  return t.nameGenerator && l.length > 0 && (d = t.nameGenerator(l, t.idPrefix, r)), { path: l, [$n]: c, ...d !== void 0 && { name: d } };
}
function YH(e) {
  return Object.keys(e).reduce((t, n) => {
    if (n === "addError")
      return t;
    {
      const r = e[n];
      return pd(r) ? {
        ...t,
        [n]: YH(r)
      } : { ...t, [n]: r };
    }
  }, {});
}
function IEe(e) {
  return Object.values(e).every((t) => t !== -1);
}
function zEe(e) {
  const { className: t = "form-control", type: n, range: r, value: a, select: s, rootId: l, name: c, disabled: d, readonly: p, autofocus: m, registry: h, onBlur: v, onFocus: y } = e, w = `${l}_${n}`, { SelectWidget: x } = h.widgets, b = M.useCallback((k) => s(n, k), [s, n]);
  return E.jsx(x, { schema: { type: "integer" }, id: w, name: c, className: t, options: { enumOptions: zH(r[0], r[1]) }, placeholder: n, value: a, disabled: d, readonly: p, autofocus: m, onChange: b, onBlur: v, onFocus: y, registry: h, label: "", "aria-describedby": _i(l) });
}
function FEe(e) {
  const { time: t = !1, disabled: n = !1, readonly: r = !1, options: a, onChange: s, value: l } = e, [c, d] = M.useState(iN(l, t));
  M.useEffect(() => {
    d(iN(l, t));
  }, [t, l]);
  const p = M.useCallback((v, y) => {
    const w = {
      ...c,
      [v]: typeof y > "u" ? -1 : y
    };
    IEe(w) ? s(LT(w, t)) : d(w);
  }, [c, s, t]), m = M.useCallback((v) => {
    v.preventDefault(), !(n || r) && s(void 0);
  }, [n, r, s]), h = M.useCallback((v) => {
    if (v.preventDefault(), n || r)
      return;
    const y = iN((/* @__PURE__ */ new Date()).toJSON(), t);
    s(LT(y, t));
  }, [n, r, t, s]);
  return { elements: M.useMemo(() => _Ee(c, t, a.yearsRange, a.format), [c, t, a.yearsRange, a.format]), handleChange: p, handleClear: m, handleSetNow: h };
}
function jm(e) {
  const t = M.useRef(e);
  return Px(e, t.current) || (t.current = e), t.current;
}
function BEe(e, t) {
  return e.replace(";base64", `;name=${encodeURIComponent(t)};base64`);
}
function UEe(e) {
  const { name: t, size: n, type: r } = e;
  return new Promise((a, s) => {
    const l = new window.FileReader();
    l.onerror = s, l.onload = (c) => {
      var d;
      typeof ((d = c.target) === null || d === void 0 ? void 0 : d.result) == "string" ? a({
        dataURL: BEe(c.target.result, t),
        name: t,
        size: n,
        type: r
      }) : a({
        dataURL: null,
        name: t,
        size: n,
        type: r
      });
    }, l.readAsDataURL(e);
  });
}
function VEe(e) {
  return Promise.all(Array.from(e).map(UEe));
}
function IT(e) {
  return e.reduce((t, n) => {
    if (!n)
      return t;
    try {
      const { blob: r, name: a } = mEe(n);
      return [
        ...t,
        {
          dataURL: n,
          name: a,
          size: r.size,
          type: r.type
        }
      ];
    } catch {
      return t;
    }
  }, []);
}
function HEe(e, t, n = !1) {
  const r = M.useMemo(() => n && e ? Array.isArray(e) ? e : [e] : [], [e, n]), a = M.useMemo(() => Array.isArray(e) ? IT(e) : IT([e || ""]), [e]), s = M.useCallback((c) => {
    VEe(c).then((d) => {
      const p = d.map((m) => m.dataURL || null);
      t(n ? r.concat(...p) : p[0]);
    });
  }, [r, n, t]), l = M.useCallback((c) => {
    if (n) {
      const d = r.filter((p, m) => m !== c);
      t(d);
    } else
      t(void 0);
  }, [r, n, t]);
  return { filesInfo: a, handleChange: s, handleRemove: l };
}
function qEe(e) {
  if (!e)
    return "";
  const t = new Date(e), n = qc(t.getFullYear(), 4), r = qc(t.getMonth() + 1, 2), a = qc(t.getDate(), 2), s = qc(t.getHours(), 2), l = qc(t.getMinutes(), 2), c = qc(t.getSeconds(), 2), d = qc(t.getMilliseconds(), 3);
  return `${n}-${r}-${a}T${s}:${l}:${c}.${d}`;
}
function B0(e, t, n = !1) {
  if (!t)
    return e;
  const { errors: r, errorSchema: a } = e;
  let s = r4(t), l = t;
  return jr(a) || (l = zx(a, t, n ? "preventDuplicates" : !0), s = [...r].concat(s)), { errorSchema: l, errors: s };
}
function WEe(e) {
  for (const t in e) {
    const n = e, r = n[t];
    t === sr && typeof r == "string" && r.startsWith("#") ? n[t] = MV + r : n[t] = o4(r);
  }
  return e;
}
function GEe(e) {
  for (let t = 0; t < e.length; t++)
    e[t] = o4(e[t]);
  return e;
}
function o4(e) {
  return Array.isArray(e) ? GEe([...e]) : cn(e) ? WEe({ ...e }) : e;
}
var Gt;
(function(e) {
  e.ArrayItemTitle = "Item", e.MissingItems = "Missing items definition", e.EmptyArray = "No items yet. Use the button below to add some.", e.YesLabel = "Yes", e.NoLabel = "No", e.CloseLabel = "Close", e.ErrorsLabel = "Errors", e.NewStringDefault = "New Value", e.AddButton = "Add", e.AddItemButton = "Add Item", e.CopyButton = "Copy", e.MoveDownButton = "Move down", e.MoveUpButton = "Move up", e.RemoveButton = "Remove", e.NowLabel = "Now", e.ClearLabel = "Clear", e.AriaDateLabel = "Select a date", e.PreviewLabel = "Preview", e.DecrementAriaLabel = "Decrease value by 1", e.IncrementAriaLabel = "Increase value by 1", e.OptionalObjectAdd = "Add data for optional field", e.OptionalObjectRemove = "Remove data for optional field", e.OptionalObjectEmptyMsg = "No data for optional field", e.Type = "Type", e.Value = "Value", e.UnknownFieldType = "Unknown field type %1", e.OptionPrefix = "Option %1", e.TitleOptionPrefix = "%1 option %2", e.KeyLabel = "%1 Key", e.InvalidObjectField = 'Invalid "%1" object field configuration: _%2_.', e.UnsupportedField = "Unsupported field schema.", e.UnsupportedFieldWithId = "Unsupported field schema for field `%1`.", e.UnsupportedFieldWithReason = "Unsupported field schema: _%1_.", e.UnsupportedFieldWithIdAndReason = "Unsupported field schema for field `%1`: _%2_.", e.FilesInfo = "**%1** (%2, %3 bytes)";
})(Gt || (Gt = {}));
function KEe(e, t) {
  var n = eo(e) ? zA : jH;
  return n(e, WV(t));
}
var sN = { exports: {} }, zT = {}, oc = {}, Up = {}, FT = {}, BT = {}, UT = {}, VT;
function P_() {
  return VT || (VT = 1, (function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.regexpCode = e.getEsmExportName = e.getProperty = e.safeStringify = e.stringify = e.strConcat = e.addCodeArg = e.str = e._ = e.nil = e._Code = e.Name = e.IDENTIFIER = e._CodeOrName = void 0;
    class t {
    }
    e._CodeOrName = t, e.IDENTIFIER = /^[a-z$_][a-z$_0-9]*$/i;
    class n extends t {
      constructor(C) {
        if (super(), !e.IDENTIFIER.test(C))
          throw new Error("CodeGen: name must be a valid identifier");
        this.str = C;
      }
      toString() {
        return this.str;
      }
      emptyStr() {
        return !1;
      }
      get names() {
        return { [this.str]: 1 };
      }
    }
    e.Name = n;
    class r extends t {
      constructor(C) {
        super(), this._items = typeof C == "string" ? [C] : C;
      }
      toString() {
        return this.str;
      }
      emptyStr() {
        if (this._items.length > 1)
          return !1;
        const C = this._items[0];
        return C === "" || C === '""';
      }
      get str() {
        var C;
        return (C = this._str) !== null && C !== void 0 ? C : this._str = this._items.reduce((_, O) => `${_}${O}`, "");
      }
      get names() {
        var C;
        return (C = this._names) !== null && C !== void 0 ? C : this._names = this._items.reduce((_, O) => (O instanceof n && (_[O.str] = (_[O.str] || 0) + 1), _), {});
      }
    }
    e._Code = r, e.nil = new r("");
    function a(k, ...C) {
      const _ = [k[0]];
      let O = 0;
      for (; O < C.length; )
        c(_, C[O]), _.push(k[++O]);
      return new r(_);
    }
    e._ = a;
    const s = new r("+");
    function l(k, ...C) {
      const _ = [y(k[0])];
      let O = 0;
      for (; O < C.length; )
        _.push(s), c(_, C[O]), _.push(s, y(k[++O]));
      return d(_), new r(_);
    }
    e.str = l;
    function c(k, C) {
      C instanceof r ? k.push(...C._items) : C instanceof n ? k.push(C) : k.push(h(C));
    }
    e.addCodeArg = c;
    function d(k) {
      let C = 1;
      for (; C < k.length - 1; ) {
        if (k[C] === s) {
          const _ = p(k[C - 1], k[C + 1]);
          if (_ !== void 0) {
            k.splice(C - 1, 3, _);
            continue;
          }
          k[C++] = "+";
        }
        C++;
      }
    }
    function p(k, C) {
      if (C === '""')
        return k;
      if (k === '""')
        return C;
      if (typeof k == "string")
        return C instanceof n || k[k.length - 1] !== '"' ? void 0 : typeof C != "string" ? `${k.slice(0, -1)}${C}"` : C[0] === '"' ? k.slice(0, -1) + C.slice(1) : void 0;
      if (typeof C == "string" && C[0] === '"' && !(k instanceof n))
        return `"${k}${C.slice(1)}`;
    }
    function m(k, C) {
      return C.emptyStr() ? k : k.emptyStr() ? C : l`${k}${C}`;
    }
    e.strConcat = m;
    function h(k) {
      return typeof k == "number" || typeof k == "boolean" || k === null ? k : y(Array.isArray(k) ? k.join(",") : k);
    }
    function v(k) {
      return new r(y(k));
    }
    e.stringify = v;
    function y(k) {
      return JSON.stringify(k).replace(/\u2028/g, "\\u2028").replace(/\u2029/g, "\\u2029");
    }
    e.safeStringify = y;
    function w(k) {
      return typeof k == "string" && e.IDENTIFIER.test(k) ? new r(`.${k}`) : a`[${k}]`;
    }
    e.getProperty = w;
    function x(k) {
      if (typeof k == "string" && e.IDENTIFIER.test(k))
        return new r(`${k}`);
      throw new Error(`CodeGen: invalid export name: ${k}, use explicit $id name mapping`);
    }
    e.getEsmExportName = x;
    function b(k) {
      return new r(k.toString());
    }
    e.regexpCode = b;
  })(UT)), UT;
}
var HT = {}, qT;
function WT() {
  return qT || (qT = 1, (function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.ValueScope = e.ValueScopeName = e.Scope = e.varKinds = e.UsedValueState = void 0;
    const t = P_();
    class n extends Error {
      constructor(p) {
        super(`CodeGen: "code" for ${p} not defined`), this.value = p.value;
      }
    }
    var r;
    (function(d) {
      d[d.Started = 0] = "Started", d[d.Completed = 1] = "Completed";
    })(r || (e.UsedValueState = r = {})), e.varKinds = {
      const: new t.Name("const"),
      let: new t.Name("let"),
      var: new t.Name("var")
    };
    class a {
      constructor({ prefixes: p, parent: m } = {}) {
        this._names = {}, this._prefixes = p, this._parent = m;
      }
      toName(p) {
        return p instanceof t.Name ? p : this.name(p);
      }
      name(p) {
        return new t.Name(this._newName(p));
      }
      _newName(p) {
        const m = this._names[p] || this._nameGroup(p);
        return `${p}${m.index++}`;
      }
      _nameGroup(p) {
        var m, h;
        if (!((h = (m = this._parent) === null || m === void 0 ? void 0 : m._prefixes) === null || h === void 0) && h.has(p) || this._prefixes && !this._prefixes.has(p))
          throw new Error(`CodeGen: prefix "${p}" is not allowed in this scope`);
        return this._names[p] = { prefix: p, index: 0 };
      }
    }
    e.Scope = a;
    class s extends t.Name {
      constructor(p, m) {
        super(m), this.prefix = p;
      }
      setValue(p, { property: m, itemIndex: h }) {
        this.value = p, this.scopePath = (0, t._)`.${new t.Name(m)}[${h}]`;
      }
    }
    e.ValueScopeName = s;
    const l = (0, t._)`\n`;
    class c extends a {
      constructor(p) {
        super(p), this._values = {}, this._scope = p.scope, this.opts = { ...p, _n: p.lines ? l : t.nil };
      }
      get() {
        return this._scope;
      }
      name(p) {
        return new s(p, this._newName(p));
      }
      value(p, m) {
        var h;
        if (m.ref === void 0)
          throw new Error("CodeGen: ref must be passed in value");
        const v = this.toName(p), { prefix: y } = v, w = (h = m.key) !== null && h !== void 0 ? h : m.ref;
        let x = this._values[y];
        if (x) {
          const C = x.get(w);
          if (C)
            return C;
        } else
          x = this._values[y] = /* @__PURE__ */ new Map();
        x.set(w, v);
        const b = this._scope[y] || (this._scope[y] = []), k = b.length;
        return b[k] = m.ref, v.setValue(m, { property: y, itemIndex: k }), v;
      }
      getValue(p, m) {
        const h = this._values[p];
        if (h)
          return h.get(m);
      }
      scopeRefs(p, m = this._values) {
        return this._reduceValues(m, (h) => {
          if (h.scopePath === void 0)
            throw new Error(`CodeGen: name "${h}" has no value`);
          return (0, t._)`${p}${h.scopePath}`;
        });
      }
      scopeCode(p = this._values, m, h) {
        return this._reduceValues(p, (v) => {
          if (v.value === void 0)
            throw new Error(`CodeGen: name "${v}" has no value`);
          return v.value.code;
        }, m, h);
      }
      _reduceValues(p, m, h = {}, v) {
        let y = t.nil;
        for (const w in p) {
          const x = p[w];
          if (!x)
            continue;
          const b = h[w] = h[w] || /* @__PURE__ */ new Map();
          x.forEach((k) => {
            if (b.has(k))
              return;
            b.set(k, r.Started);
            let C = m(k);
            if (C) {
              const _ = this.opts.es5 ? e.varKinds.var : e.varKinds.const;
              y = (0, t._)`${y}${_} ${k} = ${C};${this.opts._n}`;
            } else if (C = v?.(k))
              y = (0, t._)`${y}${C}${this.opts._n}`;
            else
              throw new n(k);
            b.set(k, r.Completed);
          });
        }
        return y;
      }
    }
    e.ValueScope = c;
  })(HT)), HT;
}
var GT;
function qt() {
  return GT || (GT = 1, (function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.or = e.and = e.not = e.CodeGen = e.operators = e.varKinds = e.ValueScopeName = e.ValueScope = e.Scope = e.Name = e.regexpCode = e.stringify = e.getProperty = e.nil = e.strConcat = e.str = e._ = void 0;
    const t = P_(), n = WT();
    var r = P_();
    Object.defineProperty(e, "_", { enumerable: !0, get: function() {
      return r._;
    } }), Object.defineProperty(e, "str", { enumerable: !0, get: function() {
      return r.str;
    } }), Object.defineProperty(e, "strConcat", { enumerable: !0, get: function() {
      return r.strConcat;
    } }), Object.defineProperty(e, "nil", { enumerable: !0, get: function() {
      return r.nil;
    } }), Object.defineProperty(e, "getProperty", { enumerable: !0, get: function() {
      return r.getProperty;
    } }), Object.defineProperty(e, "stringify", { enumerable: !0, get: function() {
      return r.stringify;
    } }), Object.defineProperty(e, "regexpCode", { enumerable: !0, get: function() {
      return r.regexpCode;
    } }), Object.defineProperty(e, "Name", { enumerable: !0, get: function() {
      return r.Name;
    } });
    var a = WT();
    Object.defineProperty(e, "Scope", { enumerable: !0, get: function() {
      return a.Scope;
    } }), Object.defineProperty(e, "ValueScope", { enumerable: !0, get: function() {
      return a.ValueScope;
    } }), Object.defineProperty(e, "ValueScopeName", { enumerable: !0, get: function() {
      return a.ValueScopeName;
    } }), Object.defineProperty(e, "varKinds", { enumerable: !0, get: function() {
      return a.varKinds;
    } }), e.operators = {
      GT: new t._Code(">"),
      GTE: new t._Code(">="),
      LT: new t._Code("<"),
      LTE: new t._Code("<="),
      EQ: new t._Code("==="),
      NEQ: new t._Code("!=="),
      NOT: new t._Code("!"),
      OR: new t._Code("||"),
      AND: new t._Code("&&"),
      ADD: new t._Code("+")
    };
    class s {
      optimizeNodes() {
        return this;
      }
      optimizeNames(H, Q) {
        return this;
      }
    }
    class l extends s {
      constructor(H, Q, re) {
        super(), this.varKind = H, this.name = Q, this.rhs = re;
      }
      render({ es5: H, _n: Q }) {
        const re = H ? n.varKinds.var : this.varKind, de = this.rhs === void 0 ? "" : ` = ${this.rhs}`;
        return `${re} ${this.name}${de};` + Q;
      }
      optimizeNames(H, Q) {
        if (H[this.name.str])
          return this.rhs && (this.rhs = I(this.rhs, H, Q)), this;
      }
      get names() {
        return this.rhs instanceof t._CodeOrName ? this.rhs.names : {};
      }
    }
    class c extends s {
      constructor(H, Q, re) {
        super(), this.lhs = H, this.rhs = Q, this.sideEffects = re;
      }
      render({ _n: H }) {
        return `${this.lhs} = ${this.rhs};` + H;
      }
      optimizeNames(H, Q) {
        if (!(this.lhs instanceof t.Name && !H[this.lhs.str] && !this.sideEffects))
          return this.rhs = I(this.rhs, H, Q), this;
      }
      get names() {
        const H = this.lhs instanceof t.Name ? {} : { ...this.lhs.names };
        return W(H, this.rhs);
      }
    }
    class d extends c {
      constructor(H, Q, re, de) {
        super(H, re, de), this.op = Q;
      }
      render({ _n: H }) {
        return `${this.lhs} ${this.op}= ${this.rhs};` + H;
      }
    }
    class p extends s {
      constructor(H) {
        super(), this.label = H, this.names = {};
      }
      render({ _n: H }) {
        return `${this.label}:` + H;
      }
    }
    class m extends s {
      constructor(H) {
        super(), this.label = H, this.names = {};
      }
      render({ _n: H }) {
        return `break${this.label ? ` ${this.label}` : ""};` + H;
      }
    }
    class h extends s {
      constructor(H) {
        super(), this.error = H;
      }
      render({ _n: H }) {
        return `throw ${this.error};` + H;
      }
      get names() {
        return this.error.names;
      }
    }
    class v extends s {
      constructor(H) {
        super(), this.code = H;
      }
      render({ _n: H }) {
        return `${this.code};` + H;
      }
      optimizeNodes() {
        return `${this.code}` ? this : void 0;
      }
      optimizeNames(H, Q) {
        return this.code = I(this.code, H, Q), this;
      }
      get names() {
        return this.code instanceof t._CodeOrName ? this.code.names : {};
      }
    }
    class y extends s {
      constructor(H = []) {
        super(), this.nodes = H;
      }
      render(H) {
        return this.nodes.reduce((Q, re) => Q + re.render(H), "");
      }
      optimizeNodes() {
        const { nodes: H } = this;
        let Q = H.length;
        for (; Q--; ) {
          const re = H[Q].optimizeNodes();
          Array.isArray(re) ? H.splice(Q, 1, ...re) : re ? H[Q] = re : H.splice(Q, 1);
        }
        return H.length > 0 ? this : void 0;
      }
      optimizeNames(H, Q) {
        const { nodes: re } = this;
        let de = re.length;
        for (; de--; ) {
          const le = re[de];
          le.optimizeNames(H, Q) || (G(H, le.names), re.splice(de, 1));
        }
        return re.length > 0 ? this : void 0;
      }
      get names() {
        return this.nodes.reduce((H, Q) => P(H, Q.names), {});
      }
    }
    class w extends y {
      render(H) {
        return "{" + H._n + super.render(H) + "}" + H._n;
      }
    }
    class x extends y {
    }
    class b extends w {
    }
    b.kind = "else";
    class k extends w {
      constructor(H, Q) {
        super(Q), this.condition = H;
      }
      render(H) {
        let Q = `if(${this.condition})` + super.render(H);
        return this.else && (Q += "else " + this.else.render(H)), Q;
      }
      optimizeNodes() {
        super.optimizeNodes();
        const H = this.condition;
        if (H === !0)
          return this.nodes;
        let Q = this.else;
        if (Q) {
          const re = Q.optimizeNodes();
          Q = this.else = Array.isArray(re) ? new b(re) : re;
        }
        if (Q)
          return H === !1 ? Q instanceof k ? Q : Q.nodes : this.nodes.length ? this : new k(L(H), Q instanceof k ? [Q] : Q.nodes);
        if (!(H === !1 || !this.nodes.length))
          return this;
      }
      optimizeNames(H, Q) {
        var re;
        if (this.else = (re = this.else) === null || re === void 0 ? void 0 : re.optimizeNames(H, Q), !!(super.optimizeNames(H, Q) || this.else))
          return this.condition = I(this.condition, H, Q), this;
      }
      get names() {
        const H = super.names;
        return W(H, this.condition), this.else && P(H, this.else.names), H;
      }
    }
    k.kind = "if";
    class C extends w {
    }
    C.kind = "for";
    class _ extends C {
      constructor(H) {
        super(), this.iteration = H;
      }
      render(H) {
        return `for(${this.iteration})` + super.render(H);
      }
      optimizeNames(H, Q) {
        if (super.optimizeNames(H, Q))
          return this.iteration = I(this.iteration, H, Q), this;
      }
      get names() {
        return P(super.names, this.iteration.names);
      }
    }
    class O extends C {
      constructor(H, Q, re, de) {
        super(), this.varKind = H, this.name = Q, this.from = re, this.to = de;
      }
      render(H) {
        const Q = H.es5 ? n.varKinds.var : this.varKind, { name: re, from: de, to: le } = this;
        return `for(${Q} ${re}=${de}; ${re}<${le}; ${re}++)` + super.render(H);
      }
      get names() {
        const H = W(super.names, this.from);
        return W(H, this.to);
      }
    }
    class N extends C {
      constructor(H, Q, re, de) {
        super(), this.loop = H, this.varKind = Q, this.name = re, this.iterable = de;
      }
      render(H) {
        return `for(${this.varKind} ${this.name} ${this.loop} ${this.iterable})` + super.render(H);
      }
      optimizeNames(H, Q) {
        if (super.optimizeNames(H, Q))
          return this.iterable = I(this.iterable, H, Q), this;
      }
      get names() {
        return P(super.names, this.iterable.names);
      }
    }
    class R extends w {
      constructor(H, Q, re) {
        super(), this.name = H, this.args = Q, this.async = re;
      }
      render(H) {
        return `${this.async ? "async " : ""}function ${this.name}(${this.args})` + super.render(H);
      }
    }
    R.kind = "func";
    class j extends y {
      render(H) {
        return "return " + super.render(H);
      }
    }
    j.kind = "return";
    class D extends w {
      render(H) {
        let Q = "try" + super.render(H);
        return this.catch && (Q += this.catch.render(H)), this.finally && (Q += this.finally.render(H)), Q;
      }
      optimizeNodes() {
        var H, Q;
        return super.optimizeNodes(), (H = this.catch) === null || H === void 0 || H.optimizeNodes(), (Q = this.finally) === null || Q === void 0 || Q.optimizeNodes(), this;
      }
      optimizeNames(H, Q) {
        var re, de;
        return super.optimizeNames(H, Q), (re = this.catch) === null || re === void 0 || re.optimizeNames(H, Q), (de = this.finally) === null || de === void 0 || de.optimizeNames(H, Q), this;
      }
      get names() {
        const H = super.names;
        return this.catch && P(H, this.catch.names), this.finally && P(H, this.finally.names), H;
      }
    }
    class $ extends w {
      constructor(H) {
        super(), this.error = H;
      }
      render(H) {
        return `catch(${this.error})` + super.render(H);
      }
    }
    $.kind = "catch";
    class z extends w {
      render(H) {
        return "finally" + super.render(H);
      }
    }
    z.kind = "finally";
    class B {
      constructor(H, Q = {}) {
        this._values = {}, this._blockStarts = [], this._constants = {}, this.opts = { ...Q, _n: Q.lines ? `
` : "" }, this._extScope = H, this._scope = new n.Scope({ parent: H }), this._nodes = [new x()];
      }
      toString() {
        return this._root.render(this.opts);
      }
      // returns unique name in the internal scope
      name(H) {
        return this._scope.name(H);
      }
      // reserves unique name in the external scope
      scopeName(H) {
        return this._extScope.name(H);
      }
      // reserves unique name in the external scope and assigns value to it
      scopeValue(H, Q) {
        const re = this._extScope.value(H, Q);
        return (this._values[re.prefix] || (this._values[re.prefix] = /* @__PURE__ */ new Set())).add(re), re;
      }
      getScopeValue(H, Q) {
        return this._extScope.getValue(H, Q);
      }
      // return code that assigns values in the external scope to the names that are used internally
      // (same names that were returned by gen.scopeName or gen.scopeValue)
      scopeRefs(H) {
        return this._extScope.scopeRefs(H, this._values);
      }
      scopeCode() {
        return this._extScope.scopeCode(this._values);
      }
      _def(H, Q, re, de) {
        const le = this._scope.toName(Q);
        return re !== void 0 && de && (this._constants[le.str] = re), this._leafNode(new l(H, le, re)), le;
      }
      // `const` declaration (`var` in es5 mode)
      const(H, Q, re) {
        return this._def(n.varKinds.const, H, Q, re);
      }
      // `let` declaration with optional assignment (`var` in es5 mode)
      let(H, Q, re) {
        return this._def(n.varKinds.let, H, Q, re);
      }
      // `var` declaration with optional assignment
      var(H, Q, re) {
        return this._def(n.varKinds.var, H, Q, re);
      }
      // assignment code
      assign(H, Q, re) {
        return this._leafNode(new c(H, Q, re));
      }
      // `+=` code
      add(H, Q) {
        return this._leafNode(new d(H, e.operators.ADD, Q));
      }
      // appends passed SafeExpr to code or executes Block
      code(H) {
        return typeof H == "function" ? H() : H !== t.nil && this._leafNode(new v(H)), this;
      }
      // returns code for object literal for the passed argument list of key-value pairs
      object(...H) {
        const Q = ["{"];
        for (const [re, de] of H)
          Q.length > 1 && Q.push(","), Q.push(re), (re !== de || this.opts.es5) && (Q.push(":"), (0, t.addCodeArg)(Q, de));
        return Q.push("}"), new t._Code(Q);
      }
      // `if` clause (or statement if `thenBody` and, optionally, `elseBody` are passed)
      if(H, Q, re) {
        if (this._blockNode(new k(H)), Q && re)
          this.code(Q).else().code(re).endIf();
        else if (Q)
          this.code(Q).endIf();
        else if (re)
          throw new Error('CodeGen: "else" body without "then" body');
        return this;
      }
      // `else if` clause - invalid without `if` or after `else` clauses
      elseIf(H) {
        return this._elseNode(new k(H));
      }
      // `else` clause - only valid after `if` or `else if` clauses
      else() {
        return this._elseNode(new b());
      }
      // end `if` statement (needed if gen.if was used only with condition)
      endIf() {
        return this._endBlockNode(k, b);
      }
      _for(H, Q) {
        return this._blockNode(H), Q && this.code(Q).endFor(), this;
      }
      // a generic `for` clause (or statement if `forBody` is passed)
      for(H, Q) {
        return this._for(new _(H), Q);
      }
      // `for` statement for a range of values
      forRange(H, Q, re, de, le = this.opts.es5 ? n.varKinds.var : n.varKinds.let) {
        const me = this._scope.toName(H);
        return this._for(new O(le, me, Q, re), () => de(me));
      }
      // `for-of` statement (in es5 mode replace with a normal for loop)
      forOf(H, Q, re, de = n.varKinds.const) {
        const le = this._scope.toName(H);
        if (this.opts.es5) {
          const me = Q instanceof t.Name ? Q : this.var("_arr", Q);
          return this.forRange("_i", 0, (0, t._)`${me}.length`, (ve) => {
            this.var(le, (0, t._)`${me}[${ve}]`), re(le);
          });
        }
        return this._for(new N("of", de, le, Q), () => re(le));
      }
      // `for-in` statement.
      // With option `ownProperties` replaced with a `for-of` loop for object keys
      forIn(H, Q, re, de = this.opts.es5 ? n.varKinds.var : n.varKinds.const) {
        if (this.opts.ownProperties)
          return this.forOf(H, (0, t._)`Object.keys(${Q})`, re);
        const le = this._scope.toName(H);
        return this._for(new N("in", de, le, Q), () => re(le));
      }
      // end `for` loop
      endFor() {
        return this._endBlockNode(C);
      }
      // `label` statement
      label(H) {
        return this._leafNode(new p(H));
      }
      // `break` statement
      break(H) {
        return this._leafNode(new m(H));
      }
      // `return` statement
      return(H) {
        const Q = new j();
        if (this._blockNode(Q), this.code(H), Q.nodes.length !== 1)
          throw new Error('CodeGen: "return" should have one node');
        return this._endBlockNode(j);
      }
      // `try` statement
      try(H, Q, re) {
        if (!Q && !re)
          throw new Error('CodeGen: "try" without "catch" and "finally"');
        const de = new D();
        if (this._blockNode(de), this.code(H), Q) {
          const le = this.name("e");
          this._currNode = de.catch = new $(le), Q(le);
        }
        return re && (this._currNode = de.finally = new z(), this.code(re)), this._endBlockNode($, z);
      }
      // `throw` statement
      throw(H) {
        return this._leafNode(new h(H));
      }
      // start self-balancing block
      block(H, Q) {
        return this._blockStarts.push(this._nodes.length), H && this.code(H).endBlock(Q), this;
      }
      // end the current self-balancing block
      endBlock(H) {
        const Q = this._blockStarts.pop();
        if (Q === void 0)
          throw new Error("CodeGen: not in self-balancing block");
        const re = this._nodes.length - Q;
        if (re < 0 || H !== void 0 && re !== H)
          throw new Error(`CodeGen: wrong number of nodes: ${re} vs ${H} expected`);
        return this._nodes.length = Q, this;
      }
      // `function` heading (or definition if funcBody is passed)
      func(H, Q = t.nil, re, de) {
        return this._blockNode(new R(H, Q, re)), de && this.code(de).endFunc(), this;
      }
      // end function definition
      endFunc() {
        return this._endBlockNode(R);
      }
      optimize(H = 1) {
        for (; H-- > 0; )
          this._root.optimizeNodes(), this._root.optimizeNames(this._root.names, this._constants);
      }
      _leafNode(H) {
        return this._currNode.nodes.push(H), this;
      }
      _blockNode(H) {
        this._currNode.nodes.push(H), this._nodes.push(H);
      }
      _endBlockNode(H, Q) {
        const re = this._currNode;
        if (re instanceof H || Q && re instanceof Q)
          return this._nodes.pop(), this;
        throw new Error(`CodeGen: not in block "${Q ? `${H.kind}/${Q.kind}` : H.kind}"`);
      }
      _elseNode(H) {
        const Q = this._currNode;
        if (!(Q instanceof k))
          throw new Error('CodeGen: "else" without "if"');
        return this._currNode = Q.else = H, this;
      }
      get _root() {
        return this._nodes[0];
      }
      get _currNode() {
        const H = this._nodes;
        return H[H.length - 1];
      }
      set _currNode(H) {
        const Q = this._nodes;
        Q[Q.length - 1] = H;
      }
    }
    e.CodeGen = B;
    function P(U, H) {
      for (const Q in H)
        U[Q] = (U[Q] || 0) + (H[Q] || 0);
      return U;
    }
    function W(U, H) {
      return H instanceof t._CodeOrName ? P(U, H.names) : U;
    }
    function I(U, H, Q) {
      if (U instanceof t.Name)
        return re(U);
      if (!de(U))
        return U;
      return new t._Code(U._items.reduce((le, me) => (me instanceof t.Name && (me = re(me)), me instanceof t._Code ? le.push(...me._items) : le.push(me), le), []));
      function re(le) {
        const me = Q[le.str];
        return me === void 0 || H[le.str] !== 1 ? le : (delete H[le.str], me);
      }
      function de(le) {
        return le instanceof t._Code && le._items.some((me) => me instanceof t.Name && H[me.str] === 1 && Q[me.str] !== void 0);
      }
    }
    function G(U, H) {
      for (const Q in H)
        U[Q] = (U[Q] || 0) - (H[Q] || 0);
    }
    function L(U) {
      return typeof U == "boolean" || typeof U == "number" || U === null ? !U : (0, t._)`!${X(U)}`;
    }
    e.not = L;
    const K = F(e.operators.AND);
    function q(...U) {
      return U.reduce(K);
    }
    e.and = q;
    const Z = F(e.operators.OR);
    function V(...U) {
      return U.reduce(Z);
    }
    e.or = V;
    function F(U) {
      return (H, Q) => H === t.nil ? Q : Q === t.nil ? H : (0, t._)`${X(H)} ${U} ${X(Q)}`;
    }
    function X(U) {
      return U instanceof t.Name ? U : (0, t._)`(${U})`;
    }
  })(BT)), BT;
}
var Vt = {}, KT;
function pn() {
  if (KT) return Vt;
  KT = 1, Object.defineProperty(Vt, "__esModule", { value: !0 }), Vt.checkStrictMode = Vt.getErrorPath = Vt.Type = Vt.useFunc = Vt.setEvaluated = Vt.evaluatedPropsToName = Vt.mergeEvaluated = Vt.eachItem = Vt.unescapeJsonPointer = Vt.escapeJsonPointer = Vt.escapeFragment = Vt.unescapeFragment = Vt.schemaRefOrVal = Vt.schemaHasRulesButRef = Vt.schemaHasRules = Vt.checkUnknownRules = Vt.alwaysValidSchema = Vt.toHash = void 0;
  const e = qt(), t = P_();
  function n(N) {
    const R = {};
    for (const j of N)
      R[j] = !0;
    return R;
  }
  Vt.toHash = n;
  function r(N, R) {
    return typeof R == "boolean" ? R : Object.keys(R).length === 0 ? !0 : (a(N, R), !s(R, N.self.RULES.all));
  }
  Vt.alwaysValidSchema = r;
  function a(N, R = N.schema) {
    const { opts: j, self: D } = N;
    if (!j.strictSchema || typeof R == "boolean")
      return;
    const $ = D.RULES.keywords;
    for (const z in R)
      $[z] || O(N, `unknown keyword: "${z}"`);
  }
  Vt.checkUnknownRules = a;
  function s(N, R) {
    if (typeof N == "boolean")
      return !N;
    for (const j in N)
      if (R[j])
        return !0;
    return !1;
  }
  Vt.schemaHasRules = s;
  function l(N, R) {
    if (typeof N == "boolean")
      return !N;
    for (const j in N)
      if (j !== "$ref" && R.all[j])
        return !0;
    return !1;
  }
  Vt.schemaHasRulesButRef = l;
  function c({ topSchemaRef: N, schemaPath: R }, j, D, $) {
    if (!$) {
      if (typeof j == "number" || typeof j == "boolean")
        return j;
      if (typeof j == "string")
        return (0, e._)`${j}`;
    }
    return (0, e._)`${N}${R}${(0, e.getProperty)(D)}`;
  }
  Vt.schemaRefOrVal = c;
  function d(N) {
    return h(decodeURIComponent(N));
  }
  Vt.unescapeFragment = d;
  function p(N) {
    return encodeURIComponent(m(N));
  }
  Vt.escapeFragment = p;
  function m(N) {
    return typeof N == "number" ? `${N}` : N.replace(/~/g, "~0").replace(/\//g, "~1");
  }
  Vt.escapeJsonPointer = m;
  function h(N) {
    return N.replace(/~1/g, "/").replace(/~0/g, "~");
  }
  Vt.unescapeJsonPointer = h;
  function v(N, R) {
    if (Array.isArray(N))
      for (const j of N)
        R(j);
    else
      R(N);
  }
  Vt.eachItem = v;
  function y({ mergeNames: N, mergeToName: R, mergeValues: j, resultToName: D }) {
    return ($, z, B, P) => {
      const W = B === void 0 ? z : B instanceof e.Name ? (z instanceof e.Name ? N($, z, B) : R($, z, B), B) : z instanceof e.Name ? (R($, B, z), z) : j(z, B);
      return P === e.Name && !(W instanceof e.Name) ? D($, W) : W;
    };
  }
  Vt.mergeEvaluated = {
    props: y({
      mergeNames: (N, R, j) => N.if((0, e._)`${j} !== true && ${R} !== undefined`, () => {
        N.if((0, e._)`${R} === true`, () => N.assign(j, !0), () => N.assign(j, (0, e._)`${j} || {}`).code((0, e._)`Object.assign(${j}, ${R})`));
      }),
      mergeToName: (N, R, j) => N.if((0, e._)`${j} !== true`, () => {
        R === !0 ? N.assign(j, !0) : (N.assign(j, (0, e._)`${j} || {}`), x(N, j, R));
      }),
      mergeValues: (N, R) => N === !0 ? !0 : { ...N, ...R },
      resultToName: w
    }),
    items: y({
      mergeNames: (N, R, j) => N.if((0, e._)`${j} !== true && ${R} !== undefined`, () => N.assign(j, (0, e._)`${R} === true ? true : ${j} > ${R} ? ${j} : ${R}`)),
      mergeToName: (N, R, j) => N.if((0, e._)`${j} !== true`, () => N.assign(j, R === !0 ? !0 : (0, e._)`${j} > ${R} ? ${j} : ${R}`)),
      mergeValues: (N, R) => N === !0 ? !0 : Math.max(N, R),
      resultToName: (N, R) => N.var("items", R)
    })
  };
  function w(N, R) {
    if (R === !0)
      return N.var("props", !0);
    const j = N.var("props", (0, e._)`{}`);
    return R !== void 0 && x(N, j, R), j;
  }
  Vt.evaluatedPropsToName = w;
  function x(N, R, j) {
    Object.keys(j).forEach((D) => N.assign((0, e._)`${R}${(0, e.getProperty)(D)}`, !0));
  }
  Vt.setEvaluated = x;
  const b = {};
  function k(N, R) {
    return N.scopeValue("func", {
      ref: R,
      code: b[R.code] || (b[R.code] = new t._Code(R.code))
    });
  }
  Vt.useFunc = k;
  var C;
  (function(N) {
    N[N.Num = 0] = "Num", N[N.Str = 1] = "Str";
  })(C || (Vt.Type = C = {}));
  function _(N, R, j) {
    if (N instanceof e.Name) {
      const D = R === C.Num;
      return j ? D ? (0, e._)`"[" + ${N} + "]"` : (0, e._)`"['" + ${N} + "']"` : D ? (0, e._)`"/" + ${N}` : (0, e._)`"/" + ${N}.replace(/~/g, "~0").replace(/\\//g, "~1")`;
    }
    return j ? (0, e.getProperty)(N).toString() : "/" + m(N);
  }
  Vt.getErrorPath = _;
  function O(N, R, j = N.opts.strictSchema) {
    if (j) {
      if (R = `strict mode: ${R}`, j === !0)
        throw new Error(R);
      N.self.logger.warn(R);
    }
  }
  return Vt.checkStrictMode = O, Vt;
}
var yk = {}, XT;
function yd() {
  if (XT) return yk;
  XT = 1, Object.defineProperty(yk, "__esModule", { value: !0 });
  const e = qt(), t = {
    // validation function arguments
    data: new e.Name("data"),
    // data passed to validation function
    // args passed from referencing schema
    valCxt: new e.Name("valCxt"),
    // validation/data context - should not be used directly, it is destructured to the names below
    instancePath: new e.Name("instancePath"),
    parentData: new e.Name("parentData"),
    parentDataProperty: new e.Name("parentDataProperty"),
    rootData: new e.Name("rootData"),
    // root data - same as the data passed to the first/top validation function
    dynamicAnchors: new e.Name("dynamicAnchors"),
    // used to support recursiveRef and dynamicRef
    // function scoped variables
    vErrors: new e.Name("vErrors"),
    // null or array of validation errors
    errors: new e.Name("errors"),
    // counter of validation errors
    this: new e.Name("this"),
    // "globals"
    self: new e.Name("self"),
    scope: new e.Name("scope"),
    // JTD serialize/parse name for JSON string and position
    json: new e.Name("json"),
    jsonPos: new e.Name("jsonPos"),
    jsonLen: new e.Name("jsonLen"),
    jsonPart: new e.Name("jsonPart")
  };
  return yk.default = t, yk;
}
var YT;
function mE() {
  return YT || (YT = 1, (function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.extendErrors = e.resetErrorsCount = e.reportExtraError = e.reportError = e.keyword$DataError = e.keywordError = void 0;
    const t = qt(), n = pn(), r = yd();
    e.keywordError = {
      message: ({ keyword: b }) => (0, t.str)`must pass "${b}" keyword validation`
    }, e.keyword$DataError = {
      message: ({ keyword: b, schemaType: k }) => k ? (0, t.str)`"${b}" keyword must be ${k} ($data)` : (0, t.str)`"${b}" keyword is invalid ($data)`
    };
    function a(b, k = e.keywordError, C, _) {
      const { it: O } = b, { gen: N, compositeRule: R, allErrors: j } = O, D = h(b, k, C);
      _ ?? (R || j) ? d(N, D) : p(O, (0, t._)`[${D}]`);
    }
    e.reportError = a;
    function s(b, k = e.keywordError, C) {
      const { it: _ } = b, { gen: O, compositeRule: N, allErrors: R } = _, j = h(b, k, C);
      d(O, j), N || R || p(_, r.default.vErrors);
    }
    e.reportExtraError = s;
    function l(b, k) {
      b.assign(r.default.errors, k), b.if((0, t._)`${r.default.vErrors} !== null`, () => b.if(k, () => b.assign((0, t._)`${r.default.vErrors}.length`, k), () => b.assign(r.default.vErrors, null)));
    }
    e.resetErrorsCount = l;
    function c({ gen: b, keyword: k, schemaValue: C, data: _, errsCount: O, it: N }) {
      if (O === void 0)
        throw new Error("ajv implementation error");
      const R = b.name("err");
      b.forRange("i", O, r.default.errors, (j) => {
        b.const(R, (0, t._)`${r.default.vErrors}[${j}]`), b.if((0, t._)`${R}.instancePath === undefined`, () => b.assign((0, t._)`${R}.instancePath`, (0, t.strConcat)(r.default.instancePath, N.errorPath))), b.assign((0, t._)`${R}.schemaPath`, (0, t.str)`${N.errSchemaPath}/${k}`), N.opts.verbose && (b.assign((0, t._)`${R}.schema`, C), b.assign((0, t._)`${R}.data`, _));
      });
    }
    e.extendErrors = c;
    function d(b, k) {
      const C = b.const("err", k);
      b.if((0, t._)`${r.default.vErrors} === null`, () => b.assign(r.default.vErrors, (0, t._)`[${C}]`), (0, t._)`${r.default.vErrors}.push(${C})`), b.code((0, t._)`${r.default.errors}++`);
    }
    function p(b, k) {
      const { gen: C, validateName: _, schemaEnv: O } = b;
      O.$async ? C.throw((0, t._)`new ${b.ValidationError}(${k})`) : (C.assign((0, t._)`${_}.errors`, k), C.return(!1));
    }
    const m = {
      keyword: new t.Name("keyword"),
      schemaPath: new t.Name("schemaPath"),
      // also used in JTD errors
      params: new t.Name("params"),
      propertyName: new t.Name("propertyName"),
      message: new t.Name("message"),
      schema: new t.Name("schema"),
      parentSchema: new t.Name("parentSchema")
    };
    function h(b, k, C) {
      const { createErrors: _ } = b.it;
      return _ === !1 ? (0, t._)`{}` : v(b, k, C);
    }
    function v(b, k, C = {}) {
      const { gen: _, it: O } = b, N = [
        y(O, C),
        w(b, C)
      ];
      return x(b, k, N), _.object(...N);
    }
    function y({ errorPath: b }, { instancePath: k }) {
      const C = k ? (0, t.str)`${b}${(0, n.getErrorPath)(k, n.Type.Str)}` : b;
      return [r.default.instancePath, (0, t.strConcat)(r.default.instancePath, C)];
    }
    function w({ keyword: b, it: { errSchemaPath: k } }, { schemaPath: C, parentSchema: _ }) {
      let O = _ ? k : (0, t.str)`${k}/${b}`;
      return C && (O = (0, t.str)`${O}${(0, n.getErrorPath)(C, n.Type.Str)}`), [m.schemaPath, O];
    }
    function x(b, { params: k, message: C }, _) {
      const { keyword: O, data: N, schemaValue: R, it: j } = b, { opts: D, propertyName: $, topSchemaRef: z, schemaPath: B } = j;
      _.push([m.keyword, O], [m.params, typeof k == "function" ? k(b) : k || (0, t._)`{}`]), D.messages && _.push([m.message, typeof C == "function" ? C(b) : C]), D.verbose && _.push([m.schema, R], [m.parentSchema, (0, t._)`${z}${B}`], [r.default.data, N]), $ && _.push([m.propertyName, $]);
    }
  })(FT)), FT;
}
var QT;
function XEe() {
  if (QT) return Up;
  QT = 1, Object.defineProperty(Up, "__esModule", { value: !0 }), Up.boolOrEmptySchema = Up.topBoolOrEmptySchema = void 0;
  const e = mE(), t = qt(), n = yd(), r = {
    message: "boolean schema is false"
  };
  function a(c) {
    const { gen: d, schema: p, validateName: m } = c;
    p === !1 ? l(c, !1) : typeof p == "object" && p.$async === !0 ? d.return(n.default.data) : (d.assign((0, t._)`${m}.errors`, null), d.return(!0));
  }
  Up.topBoolOrEmptySchema = a;
  function s(c, d) {
    const { gen: p, schema: m } = c;
    m === !1 ? (p.var(d, !1), l(c)) : p.var(d, !0);
  }
  Up.boolOrEmptySchema = s;
  function l(c, d) {
    const { gen: p, data: m } = c, h = {
      gen: p,
      keyword: "false schema",
      data: m,
      schema: !1,
      schemaCode: !1,
      schemaValue: !1,
      params: {},
      it: c
    };
    (0, e.reportError)(h, r, void 0, d);
  }
  return Up;
}
var No = {}, Vp = {}, JT;
function QH() {
  if (JT) return Vp;
  JT = 1, Object.defineProperty(Vp, "__esModule", { value: !0 }), Vp.getRules = Vp.isJSONType = void 0;
  const e = ["string", "number", "integer", "boolean", "null", "object", "array"], t = new Set(e);
  function n(a) {
    return typeof a == "string" && t.has(a);
  }
  Vp.isJSONType = n;
  function r() {
    const a = {
      number: { type: "number", rules: [] },
      string: { type: "string", rules: [] },
      array: { type: "array", rules: [] },
      object: { type: "object", rules: [] }
    };
    return {
      types: { ...a, integer: !0, boolean: !0, null: !0 },
      rules: [{ rules: [] }, a.number, a.string, a.array, a.object],
      post: { rules: [] },
      all: {},
      keywords: {}
    };
  }
  return Vp.getRules = r, Vp;
}
var ac = {}, ZT;
function JH() {
  if (ZT) return ac;
  ZT = 1, Object.defineProperty(ac, "__esModule", { value: !0 }), ac.shouldUseRule = ac.shouldUseGroup = ac.schemaHasRulesForType = void 0;
  function e({ schema: r, self: a }, s) {
    const l = a.RULES.types[s];
    return l && l !== !0 && t(r, l);
  }
  ac.schemaHasRulesForType = e;
  function t(r, a) {
    return a.rules.some((s) => n(r, s));
  }
  ac.shouldUseGroup = t;
  function n(r, a) {
    var s;
    return r[a.keyword] !== void 0 || ((s = a.definition.implements) === null || s === void 0 ? void 0 : s.some((l) => r[l] !== void 0));
  }
  return ac.shouldUseRule = n, ac;
}
var eL;
function D_() {
  if (eL) return No;
  eL = 1, Object.defineProperty(No, "__esModule", { value: !0 }), No.reportTypeError = No.checkDataTypes = No.checkDataType = No.coerceAndCheckDataType = No.getJSONTypes = No.getSchemaTypes = No.DataType = void 0;
  const e = QH(), t = JH(), n = mE(), r = qt(), a = pn();
  var s;
  (function(C) {
    C[C.Correct = 0] = "Correct", C[C.Wrong = 1] = "Wrong";
  })(s || (No.DataType = s = {}));
  function l(C) {
    const _ = c(C.type);
    if (_.includes("null")) {
      if (C.nullable === !1)
        throw new Error("type: null contradicts nullable: false");
    } else {
      if (!_.length && C.nullable !== void 0)
        throw new Error('"nullable" cannot be used without "type"');
      C.nullable === !0 && _.push("null");
    }
    return _;
  }
  No.getSchemaTypes = l;
  function c(C) {
    const _ = Array.isArray(C) ? C : C ? [C] : [];
    if (_.every(e.isJSONType))
      return _;
    throw new Error("type must be JSONType or JSONType[]: " + _.join(","));
  }
  No.getJSONTypes = c;
  function d(C, _) {
    const { gen: O, data: N, opts: R } = C, j = m(_, R.coerceTypes), D = _.length > 0 && !(j.length === 0 && _.length === 1 && (0, t.schemaHasRulesForType)(C, _[0]));
    if (D) {
      const $ = w(_, N, R.strictNumbers, s.Wrong);
      O.if($, () => {
        j.length ? h(C, _, j) : b(C);
      });
    }
    return D;
  }
  No.coerceAndCheckDataType = d;
  const p = /* @__PURE__ */ new Set(["string", "number", "integer", "boolean", "null"]);
  function m(C, _) {
    return _ ? C.filter((O) => p.has(O) || _ === "array" && O === "array") : [];
  }
  function h(C, _, O) {
    const { gen: N, data: R, opts: j } = C, D = N.let("dataType", (0, r._)`typeof ${R}`), $ = N.let("coerced", (0, r._)`undefined`);
    j.coerceTypes === "array" && N.if((0, r._)`${D} == 'object' && Array.isArray(${R}) && ${R}.length == 1`, () => N.assign(R, (0, r._)`${R}[0]`).assign(D, (0, r._)`typeof ${R}`).if(w(_, R, j.strictNumbers), () => N.assign($, R))), N.if((0, r._)`${$} !== undefined`);
    for (const B of O)
      (p.has(B) || B === "array" && j.coerceTypes === "array") && z(B);
    N.else(), b(C), N.endIf(), N.if((0, r._)`${$} !== undefined`, () => {
      N.assign(R, $), v(C, $);
    });
    function z(B) {
      switch (B) {
        case "string":
          N.elseIf((0, r._)`${D} == "number" || ${D} == "boolean"`).assign($, (0, r._)`"" + ${R}`).elseIf((0, r._)`${R} === null`).assign($, (0, r._)`""`);
          return;
        case "number":
          N.elseIf((0, r._)`${D} == "boolean" || ${R} === null
              || (${D} == "string" && ${R} && ${R} == +${R})`).assign($, (0, r._)`+${R}`);
          return;
        case "integer":
          N.elseIf((0, r._)`${D} === "boolean" || ${R} === null
              || (${D} === "string" && ${R} && ${R} == +${R} && !(${R} % 1))`).assign($, (0, r._)`+${R}`);
          return;
        case "boolean":
          N.elseIf((0, r._)`${R} === "false" || ${R} === 0 || ${R} === null`).assign($, !1).elseIf((0, r._)`${R} === "true" || ${R} === 1`).assign($, !0);
          return;
        case "null":
          N.elseIf((0, r._)`${R} === "" || ${R} === 0 || ${R} === false`), N.assign($, null);
          return;
        case "array":
          N.elseIf((0, r._)`${D} === "string" || ${D} === "number"
              || ${D} === "boolean" || ${R} === null`).assign($, (0, r._)`[${R}]`);
      }
    }
  }
  function v({ gen: C, parentData: _, parentDataProperty: O }, N) {
    C.if((0, r._)`${_} !== undefined`, () => C.assign((0, r._)`${_}[${O}]`, N));
  }
  function y(C, _, O, N = s.Correct) {
    const R = N === s.Correct ? r.operators.EQ : r.operators.NEQ;
    let j;
    switch (C) {
      case "null":
        return (0, r._)`${_} ${R} null`;
      case "array":
        j = (0, r._)`Array.isArray(${_})`;
        break;
      case "object":
        j = (0, r._)`${_} && typeof ${_} == "object" && !Array.isArray(${_})`;
        break;
      case "integer":
        j = D((0, r._)`!(${_} % 1) && !isNaN(${_})`);
        break;
      case "number":
        j = D();
        break;
      default:
        return (0, r._)`typeof ${_} ${R} ${C}`;
    }
    return N === s.Correct ? j : (0, r.not)(j);
    function D($ = r.nil) {
      return (0, r.and)((0, r._)`typeof ${_} == "number"`, $, O ? (0, r._)`isFinite(${_})` : r.nil);
    }
  }
  No.checkDataType = y;
  function w(C, _, O, N) {
    if (C.length === 1)
      return y(C[0], _, O, N);
    let R;
    const j = (0, a.toHash)(C);
    if (j.array && j.object) {
      const D = (0, r._)`typeof ${_} != "object"`;
      R = j.null ? D : (0, r._)`!${_} || ${D}`, delete j.null, delete j.array, delete j.object;
    } else
      R = r.nil;
    j.number && delete j.integer;
    for (const D in j)
      R = (0, r.and)(R, y(D, _, O, N));
    return R;
  }
  No.checkDataTypes = w;
  const x = {
    message: ({ schema: C }) => `must be ${C}`,
    params: ({ schema: C, schemaValue: _ }) => typeof C == "string" ? (0, r._)`{type: ${C}}` : (0, r._)`{type: ${_}}`
  };
  function b(C) {
    const _ = k(C);
    (0, n.reportError)(_, x);
  }
  No.reportTypeError = b;
  function k(C) {
    const { gen: _, data: O, schema: N } = C, R = (0, a.schemaRefOrVal)(C, N, "type");
    return {
      gen: _,
      keyword: "type",
      data: O,
      schema: N.type,
      schemaCode: R,
      schemaValue: R,
      parentSchema: N,
      params: {},
      it: C
    };
  }
  return No;
}
var gw = {}, tL;
function YEe() {
  if (tL) return gw;
  tL = 1, Object.defineProperty(gw, "__esModule", { value: !0 }), gw.assignDefaults = void 0;
  const e = qt(), t = pn();
  function n(a, s) {
    const { properties: l, items: c } = a.schema;
    if (s === "object" && l)
      for (const d in l)
        r(a, d, l[d].default);
    else s === "array" && Array.isArray(c) && c.forEach((d, p) => r(a, p, d.default));
  }
  gw.assignDefaults = n;
  function r(a, s, l) {
    const { gen: c, compositeRule: d, data: p, opts: m } = a;
    if (l === void 0)
      return;
    const h = (0, e._)`${p}${(0, e.getProperty)(s)}`;
    if (d) {
      (0, t.checkStrictMode)(a, `default is ignored for: ${h}`);
      return;
    }
    let v = (0, e._)`${h} === undefined`;
    m.useDefaults === "empty" && (v = (0, e._)`${v} || ${h} === null || ${h} === ""`), c.if(v, (0, e._)`${h} = ${(0, e.stringify)(l)}`);
  }
  return gw;
}
var Ns = {}, jn = {}, nL;
function Ks() {
  if (nL) return jn;
  nL = 1, Object.defineProperty(jn, "__esModule", { value: !0 }), jn.validateUnion = jn.validateArray = jn.usePattern = jn.callValidateCode = jn.schemaProperties = jn.allSchemaProperties = jn.noPropertyInData = jn.propertyInData = jn.isOwnProperty = jn.hasPropFunc = jn.reportMissingProp = jn.checkMissingProp = jn.checkReportMissingProp = void 0;
  const e = qt(), t = pn(), n = yd(), r = pn();
  function a(C, _) {
    const { gen: O, data: N, it: R } = C;
    O.if(m(O, N, _, R.opts.ownProperties), () => {
      C.setParams({ missingProperty: (0, e._)`${_}` }, !0), C.error();
    });
  }
  jn.checkReportMissingProp = a;
  function s({ gen: C, data: _, it: { opts: O } }, N, R) {
    return (0, e.or)(...N.map((j) => (0, e.and)(m(C, _, j, O.ownProperties), (0, e._)`${R} = ${j}`)));
  }
  jn.checkMissingProp = s;
  function l(C, _) {
    C.setParams({ missingProperty: _ }, !0), C.error();
  }
  jn.reportMissingProp = l;
  function c(C) {
    return C.scopeValue("func", {
      // eslint-disable-next-line @typescript-eslint/unbound-method
      ref: Object.prototype.hasOwnProperty,
      code: (0, e._)`Object.prototype.hasOwnProperty`
    });
  }
  jn.hasPropFunc = c;
  function d(C, _, O) {
    return (0, e._)`${c(C)}.call(${_}, ${O})`;
  }
  jn.isOwnProperty = d;
  function p(C, _, O, N) {
    const R = (0, e._)`${_}${(0, e.getProperty)(O)} !== undefined`;
    return N ? (0, e._)`${R} && ${d(C, _, O)}` : R;
  }
  jn.propertyInData = p;
  function m(C, _, O, N) {
    const R = (0, e._)`${_}${(0, e.getProperty)(O)} === undefined`;
    return N ? (0, e.or)(R, (0, e.not)(d(C, _, O))) : R;
  }
  jn.noPropertyInData = m;
  function h(C) {
    return C ? Object.keys(C).filter((_) => _ !== "__proto__") : [];
  }
  jn.allSchemaProperties = h;
  function v(C, _) {
    return h(_).filter((O) => !(0, t.alwaysValidSchema)(C, _[O]));
  }
  jn.schemaProperties = v;
  function y({ schemaCode: C, data: _, it: { gen: O, topSchemaRef: N, schemaPath: R, errorPath: j }, it: D }, $, z, B) {
    const P = B ? (0, e._)`${C}, ${_}, ${N}${R}` : _, W = [
      [n.default.instancePath, (0, e.strConcat)(n.default.instancePath, j)],
      [n.default.parentData, D.parentData],
      [n.default.parentDataProperty, D.parentDataProperty],
      [n.default.rootData, n.default.rootData]
    ];
    D.opts.dynamicRef && W.push([n.default.dynamicAnchors, n.default.dynamicAnchors]);
    const I = (0, e._)`${P}, ${O.object(...W)}`;
    return z !== e.nil ? (0, e._)`${$}.call(${z}, ${I})` : (0, e._)`${$}(${I})`;
  }
  jn.callValidateCode = y;
  const w = (0, e._)`new RegExp`;
  function x({ gen: C, it: { opts: _ } }, O) {
    const N = _.unicodeRegExp ? "u" : "", { regExp: R } = _.code, j = R(O, N);
    return C.scopeValue("pattern", {
      key: j.toString(),
      ref: j,
      code: (0, e._)`${R.code === "new RegExp" ? w : (0, r.useFunc)(C, R)}(${O}, ${N})`
    });
  }
  jn.usePattern = x;
  function b(C) {
    const { gen: _, data: O, keyword: N, it: R } = C, j = _.name("valid");
    if (R.allErrors) {
      const $ = _.let("valid", !0);
      return D(() => _.assign($, !1)), $;
    }
    return _.var(j, !0), D(() => _.break()), j;
    function D($) {
      const z = _.const("len", (0, e._)`${O}.length`);
      _.forRange("i", 0, z, (B) => {
        C.subschema({
          keyword: N,
          dataProp: B,
          dataPropType: t.Type.Num
        }, j), _.if((0, e.not)(j), $);
      });
    }
  }
  jn.validateArray = b;
  function k(C) {
    const { gen: _, schema: O, keyword: N, it: R } = C;
    if (!Array.isArray(O))
      throw new Error("ajv implementation error");
    if (O.some(($) => (0, t.alwaysValidSchema)(R, $)) && !R.opts.unevaluated)
      return;
    const j = _.let("valid", !1), D = _.name("_valid");
    _.block(() => O.forEach(($, z) => {
      const B = C.subschema({
        keyword: N,
        schemaProp: z,
        compositeRule: !0
      }, D);
      _.assign(j, (0, e._)`${j} || ${D}`), C.mergeValidEvaluated(B, D) || _.if((0, e.not)(j));
    })), C.result(j, () => C.reset(), () => C.error(!0));
  }
  return jn.validateUnion = k, jn;
}
var rL;
function QEe() {
  if (rL) return Ns;
  rL = 1, Object.defineProperty(Ns, "__esModule", { value: !0 }), Ns.validateKeywordUsage = Ns.validSchemaType = Ns.funcKeywordCode = Ns.macroKeywordCode = void 0;
  const e = qt(), t = yd(), n = Ks(), r = mE();
  function a(v, y) {
    const { gen: w, keyword: x, schema: b, parentSchema: k, it: C } = v, _ = y.macro.call(C.self, b, k, C), O = p(w, x, _);
    C.opts.validateSchema !== !1 && C.self.validateSchema(_, !0);
    const N = w.name("valid");
    v.subschema({
      schema: _,
      schemaPath: e.nil,
      errSchemaPath: `${C.errSchemaPath}/${x}`,
      topSchemaRef: O,
      compositeRule: !0
    }, N), v.pass(N, () => v.error(!0));
  }
  Ns.macroKeywordCode = a;
  function s(v, y) {
    var w;
    const { gen: x, keyword: b, schema: k, parentSchema: C, $data: _, it: O } = v;
    d(O, y);
    const N = !_ && y.compile ? y.compile.call(O.self, k, C, O) : y.validate, R = p(x, b, N), j = x.let("valid");
    v.block$data(j, D), v.ok((w = y.valid) !== null && w !== void 0 ? w : j);
    function D() {
      if (y.errors === !1)
        B(), y.modifying && l(v), P(() => v.error());
      else {
        const W = y.async ? $() : z();
        y.modifying && l(v), P(() => c(v, W));
      }
    }
    function $() {
      const W = x.let("ruleErrs", null);
      return x.try(() => B((0, e._)`await `), (I) => x.assign(j, !1).if((0, e._)`${I} instanceof ${O.ValidationError}`, () => x.assign(W, (0, e._)`${I}.errors`), () => x.throw(I))), W;
    }
    function z() {
      const W = (0, e._)`${R}.errors`;
      return x.assign(W, null), B(e.nil), W;
    }
    function B(W = y.async ? (0, e._)`await ` : e.nil) {
      const I = O.opts.passContext ? t.default.this : t.default.self, G = !("compile" in y && !_ || y.schema === !1);
      x.assign(j, (0, e._)`${W}${(0, n.callValidateCode)(v, R, I, G)}`, y.modifying);
    }
    function P(W) {
      var I;
      x.if((0, e.not)((I = y.valid) !== null && I !== void 0 ? I : j), W);
    }
  }
  Ns.funcKeywordCode = s;
  function l(v) {
    const { gen: y, data: w, it: x } = v;
    y.if(x.parentData, () => y.assign(w, (0, e._)`${x.parentData}[${x.parentDataProperty}]`));
  }
  function c(v, y) {
    const { gen: w } = v;
    w.if((0, e._)`Array.isArray(${y})`, () => {
      w.assign(t.default.vErrors, (0, e._)`${t.default.vErrors} === null ? ${y} : ${t.default.vErrors}.concat(${y})`).assign(t.default.errors, (0, e._)`${t.default.vErrors}.length`), (0, r.extendErrors)(v);
    }, () => v.error());
  }
  function d({ schemaEnv: v }, y) {
    if (y.async && !v.$async)
      throw new Error("async keyword in sync schema");
  }
  function p(v, y, w) {
    if (w === void 0)
      throw new Error(`keyword "${y}" failed to compile`);
    return v.scopeValue("keyword", typeof w == "function" ? { ref: w } : { ref: w, code: (0, e.stringify)(w) });
  }
  function m(v, y, w = !1) {
    return !y.length || y.some((x) => x === "array" ? Array.isArray(v) : x === "object" ? v && typeof v == "object" && !Array.isArray(v) : typeof v == x || w && typeof v > "u");
  }
  Ns.validSchemaType = m;
  function h({ schema: v, opts: y, self: w, errSchemaPath: x }, b, k) {
    if (Array.isArray(b.keyword) ? !b.keyword.includes(k) : b.keyword !== k)
      throw new Error("ajv implementation error");
    const C = b.dependencies;
    if (C?.some((_) => !Object.prototype.hasOwnProperty.call(v, _)))
      throw new Error(`parent schema must have dependencies of ${k}: ${C.join(",")}`);
    if (b.validateSchema && !b.validateSchema(v[k])) {
      const _ = `keyword "${k}" value is invalid at path "${x}": ` + w.errorsText(b.validateSchema.errors);
      if (y.validateSchema === "log")
        w.logger.error(_);
      else
        throw new Error(_);
    }
  }
  return Ns.validateKeywordUsage = h, Ns;
}
var ic = {}, oL;
function JEe() {
  if (oL) return ic;
  oL = 1, Object.defineProperty(ic, "__esModule", { value: !0 }), ic.extendSubschemaMode = ic.extendSubschemaData = ic.getSubschema = void 0;
  const e = qt(), t = pn();
  function n(s, { keyword: l, schemaProp: c, schema: d, schemaPath: p, errSchemaPath: m, topSchemaRef: h }) {
    if (l !== void 0 && d !== void 0)
      throw new Error('both "keyword" and "schema" passed, only one allowed');
    if (l !== void 0) {
      const v = s.schema[l];
      return c === void 0 ? {
        schema: v,
        schemaPath: (0, e._)`${s.schemaPath}${(0, e.getProperty)(l)}`,
        errSchemaPath: `${s.errSchemaPath}/${l}`
      } : {
        schema: v[c],
        schemaPath: (0, e._)`${s.schemaPath}${(0, e.getProperty)(l)}${(0, e.getProperty)(c)}`,
        errSchemaPath: `${s.errSchemaPath}/${l}/${(0, t.escapeFragment)(c)}`
      };
    }
    if (d !== void 0) {
      if (p === void 0 || m === void 0 || h === void 0)
        throw new Error('"schemaPath", "errSchemaPath" and "topSchemaRef" are required with "schema"');
      return {
        schema: d,
        schemaPath: p,
        topSchemaRef: h,
        errSchemaPath: m
      };
    }
    throw new Error('either "keyword" or "schema" must be passed');
  }
  ic.getSubschema = n;
  function r(s, l, { dataProp: c, dataPropType: d, data: p, dataTypes: m, propertyName: h }) {
    if (p !== void 0 && c !== void 0)
      throw new Error('both "data" and "dataProp" passed, only one allowed');
    const { gen: v } = l;
    if (c !== void 0) {
      const { errorPath: w, dataPathArr: x, opts: b } = l, k = v.let("data", (0, e._)`${l.data}${(0, e.getProperty)(c)}`, !0);
      y(k), s.errorPath = (0, e.str)`${w}${(0, t.getErrorPath)(c, d, b.jsPropertySyntax)}`, s.parentDataProperty = (0, e._)`${c}`, s.dataPathArr = [...x, s.parentDataProperty];
    }
    if (p !== void 0) {
      const w = p instanceof e.Name ? p : v.let("data", p, !0);
      y(w), h !== void 0 && (s.propertyName = h);
    }
    m && (s.dataTypes = m);
    function y(w) {
      s.data = w, s.dataLevel = l.dataLevel + 1, s.dataTypes = [], l.definedProperties = /* @__PURE__ */ new Set(), s.parentData = l.data, s.dataNames = [...l.dataNames, w];
    }
  }
  ic.extendSubschemaData = r;
  function a(s, { jtdDiscriminator: l, jtdMetadata: c, compositeRule: d, createErrors: p, allErrors: m }) {
    d !== void 0 && (s.compositeRule = d), p !== void 0 && (s.createErrors = p), m !== void 0 && (s.allErrors = m), s.jtdDiscriminator = l, s.jtdMetadata = c;
  }
  return ic.extendSubschemaMode = a, ic;
}
var va = {}, aL, iL;
function ZH() {
  return iL || (iL = 1, aL = function e(t, n) {
    if (t === n) return !0;
    if (t && n && typeof t == "object" && typeof n == "object") {
      if (t.constructor !== n.constructor) return !1;
      var r, a, s;
      if (Array.isArray(t)) {
        if (r = t.length, r != n.length) return !1;
        for (a = r; a-- !== 0; )
          if (!e(t[a], n[a])) return !1;
        return !0;
      }
      if (t.constructor === RegExp) return t.source === n.source && t.flags === n.flags;
      if (t.valueOf !== Object.prototype.valueOf) return t.valueOf() === n.valueOf();
      if (t.toString !== Object.prototype.toString) return t.toString() === n.toString();
      if (s = Object.keys(t), r = s.length, r !== Object.keys(n).length) return !1;
      for (a = r; a-- !== 0; )
        if (!Object.prototype.hasOwnProperty.call(n, s[a])) return !1;
      for (a = r; a-- !== 0; ) {
        var l = s[a];
        if (!e(t[l], n[l])) return !1;
      }
      return !0;
    }
    return t !== t && n !== n;
  }), aL;
}
var lN = { exports: {} }, sL;
function ZEe() {
  if (sL) return lN.exports;
  sL = 1;
  var e = lN.exports = function(r, a, s) {
    typeof a == "function" && (s = a, a = {}), s = a.cb || s;
    var l = typeof s == "function" ? s : s.pre || function() {
    }, c = s.post || function() {
    };
    t(a, l, c, r, "", r);
  };
  e.keywords = {
    additionalItems: !0,
    items: !0,
    contains: !0,
    additionalProperties: !0,
    propertyNames: !0,
    not: !0,
    if: !0,
    then: !0,
    else: !0
  }, e.arrayKeywords = {
    items: !0,
    allOf: !0,
    anyOf: !0,
    oneOf: !0
  }, e.propsKeywords = {
    $defs: !0,
    definitions: !0,
    properties: !0,
    patternProperties: !0,
    dependencies: !0
  }, e.skipKeywords = {
    default: !0,
    enum: !0,
    const: !0,
    required: !0,
    maximum: !0,
    minimum: !0,
    exclusiveMaximum: !0,
    exclusiveMinimum: !0,
    multipleOf: !0,
    maxLength: !0,
    minLength: !0,
    pattern: !0,
    format: !0,
    maxItems: !0,
    minItems: !0,
    uniqueItems: !0,
    maxProperties: !0,
    minProperties: !0
  };
  function t(r, a, s, l, c, d, p, m, h, v) {
    if (l && typeof l == "object" && !Array.isArray(l)) {
      a(l, c, d, p, m, h, v);
      for (var y in l) {
        var w = l[y];
        if (Array.isArray(w)) {
          if (y in e.arrayKeywords)
            for (var x = 0; x < w.length; x++)
              t(r, a, s, w[x], c + "/" + y + "/" + x, d, c, y, l, x);
        } else if (y in e.propsKeywords) {
          if (w && typeof w == "object")
            for (var b in w)
              t(r, a, s, w[b], c + "/" + y + "/" + n(b), d, c, y, l, b);
        } else (y in e.keywords || r.allKeys && !(y in e.skipKeywords)) && t(r, a, s, w, c + "/" + y, d, c, y, l);
      }
      s(l, c, d, p, m, h, v);
    }
  }
  function n(r) {
    return r.replace(/~/g, "~0").replace(/\//g, "~1");
  }
  return lN.exports;
}
var lL;
function hE() {
  if (lL) return va;
  lL = 1, Object.defineProperty(va, "__esModule", { value: !0 }), va.getSchemaRefs = va.resolveUrl = va.normalizeId = va._getFullPath = va.getFullPath = va.inlineRef = void 0;
  const e = pn(), t = ZH(), n = ZEe(), r = /* @__PURE__ */ new Set([
    "type",
    "format",
    "pattern",
    "maxLength",
    "minLength",
    "maxProperties",
    "minProperties",
    "maxItems",
    "minItems",
    "maximum",
    "minimum",
    "uniqueItems",
    "multipleOf",
    "required",
    "enum",
    "const"
  ]);
  function a(x, b = !0) {
    return typeof x == "boolean" ? !0 : b === !0 ? !l(x) : b ? c(x) <= b : !1;
  }
  va.inlineRef = a;
  const s = /* @__PURE__ */ new Set([
    "$ref",
    "$recursiveRef",
    "$recursiveAnchor",
    "$dynamicRef",
    "$dynamicAnchor"
  ]);
  function l(x) {
    for (const b in x) {
      if (s.has(b))
        return !0;
      const k = x[b];
      if (Array.isArray(k) && k.some(l) || typeof k == "object" && l(k))
        return !0;
    }
    return !1;
  }
  function c(x) {
    let b = 0;
    for (const k in x)
      if (k === "$ref" || (b++, !r.has(k) && (typeof x[k] == "object" && (0, e.eachItem)(x[k], (C) => b += c(C)), b === 1 / 0)))
        return 1 / 0;
    return b;
  }
  function d(x, b = "", k) {
    k !== !1 && (b = h(b));
    const C = x.parse(b);
    return p(x, C);
  }
  va.getFullPath = d;
  function p(x, b) {
    return x.serialize(b).split("#")[0] + "#";
  }
  va._getFullPath = p;
  const m = /#\/?$/;
  function h(x) {
    return x ? x.replace(m, "") : "";
  }
  va.normalizeId = h;
  function v(x, b, k) {
    return k = h(k), x.resolve(b, k);
  }
  va.resolveUrl = v;
  const y = /^[a-z_][-a-z0-9._]*$/i;
  function w(x, b) {
    if (typeof x == "boolean")
      return {};
    const { schemaId: k, uriResolver: C } = this.opts, _ = h(x[k] || b), O = { "": _ }, N = d(C, _, !1), R = {}, j = /* @__PURE__ */ new Set();
    return n(x, { allKeys: !0 }, (z, B, P, W) => {
      if (W === void 0)
        return;
      const I = N + B;
      let G = O[W];
      typeof z[k] == "string" && (G = L.call(this, z[k])), K.call(this, z.$anchor), K.call(this, z.$dynamicAnchor), O[B] = G;
      function L(q) {
        const Z = this.opts.uriResolver.resolve;
        if (q = h(G ? Z(G, q) : q), j.has(q))
          throw $(q);
        j.add(q);
        let V = this.refs[q];
        return typeof V == "string" && (V = this.refs[V]), typeof V == "object" ? D(z, V.schema, q) : q !== h(I) && (q[0] === "#" ? (D(z, R[q], q), R[q] = z) : this.refs[q] = I), q;
      }
      function K(q) {
        if (typeof q == "string") {
          if (!y.test(q))
            throw new Error(`invalid anchor "${q}"`);
          L.call(this, `#${q}`);
        }
      }
    }), R;
    function D(z, B, P) {
      if (B !== void 0 && !t(z, B))
        throw $(P);
    }
    function $(z) {
      return new Error(`reference "${z}" resolves to more than one schema`);
    }
  }
  return va.getSchemaRefs = w, va;
}
var uL;
function gE() {
  if (uL) return oc;
  uL = 1, Object.defineProperty(oc, "__esModule", { value: !0 }), oc.getData = oc.KeywordCxt = oc.validateFunctionCode = void 0;
  const e = XEe(), t = D_(), n = JH(), r = D_(), a = YEe(), s = QEe(), l = JEe(), c = qt(), d = yd(), p = hE(), m = pn(), h = mE();
  function v(ae) {
    if (N(ae) && (j(ae), O(ae))) {
      b(ae);
      return;
    }
    y(ae, () => (0, e.topBoolOrEmptySchema)(ae));
  }
  oc.validateFunctionCode = v;
  function y({ gen: ae, validateName: se, schema: pe, schemaEnv: ge, opts: xe }, _e) {
    xe.code.es5 ? ae.func(se, (0, c._)`${d.default.data}, ${d.default.valCxt}`, ge.$async, () => {
      ae.code((0, c._)`"use strict"; ${C(pe, xe)}`), x(ae, xe), ae.code(_e);
    }) : ae.func(se, (0, c._)`${d.default.data}, ${w(xe)}`, ge.$async, () => ae.code(C(pe, xe)).code(_e));
  }
  function w(ae) {
    return (0, c._)`{${d.default.instancePath}="", ${d.default.parentData}, ${d.default.parentDataProperty}, ${d.default.rootData}=${d.default.data}${ae.dynamicRef ? (0, c._)`, ${d.default.dynamicAnchors}={}` : c.nil}}={}`;
  }
  function x(ae, se) {
    ae.if(d.default.valCxt, () => {
      ae.var(d.default.instancePath, (0, c._)`${d.default.valCxt}.${d.default.instancePath}`), ae.var(d.default.parentData, (0, c._)`${d.default.valCxt}.${d.default.parentData}`), ae.var(d.default.parentDataProperty, (0, c._)`${d.default.valCxt}.${d.default.parentDataProperty}`), ae.var(d.default.rootData, (0, c._)`${d.default.valCxt}.${d.default.rootData}`), se.dynamicRef && ae.var(d.default.dynamicAnchors, (0, c._)`${d.default.valCxt}.${d.default.dynamicAnchors}`);
    }, () => {
      ae.var(d.default.instancePath, (0, c._)`""`), ae.var(d.default.parentData, (0, c._)`undefined`), ae.var(d.default.parentDataProperty, (0, c._)`undefined`), ae.var(d.default.rootData, d.default.data), se.dynamicRef && ae.var(d.default.dynamicAnchors, (0, c._)`{}`);
    });
  }
  function b(ae) {
    const { schema: se, opts: pe, gen: ge } = ae;
    y(ae, () => {
      pe.$comment && se.$comment && W(ae), z(ae), ge.let(d.default.vErrors, null), ge.let(d.default.errors, 0), pe.unevaluated && k(ae), D(ae), I(ae);
    });
  }
  function k(ae) {
    const { gen: se, validateName: pe } = ae;
    ae.evaluated = se.const("evaluated", (0, c._)`${pe}.evaluated`), se.if((0, c._)`${ae.evaluated}.dynamicProps`, () => se.assign((0, c._)`${ae.evaluated}.props`, (0, c._)`undefined`)), se.if((0, c._)`${ae.evaluated}.dynamicItems`, () => se.assign((0, c._)`${ae.evaluated}.items`, (0, c._)`undefined`));
  }
  function C(ae, se) {
    const pe = typeof ae == "object" && ae[se.schemaId];
    return pe && (se.code.source || se.code.process) ? (0, c._)`/*# sourceURL=${pe} */` : c.nil;
  }
  function _(ae, se) {
    if (N(ae) && (j(ae), O(ae))) {
      R(ae, se);
      return;
    }
    (0, e.boolOrEmptySchema)(ae, se);
  }
  function O({ schema: ae, self: se }) {
    if (typeof ae == "boolean")
      return !ae;
    for (const pe in ae)
      if (se.RULES.all[pe])
        return !0;
    return !1;
  }
  function N(ae) {
    return typeof ae.schema != "boolean";
  }
  function R(ae, se) {
    const { schema: pe, gen: ge, opts: xe } = ae;
    xe.$comment && pe.$comment && W(ae), B(ae), P(ae);
    const _e = ge.const("_errs", d.default.errors);
    D(ae, _e), ge.var(se, (0, c._)`${_e} === ${d.default.errors}`);
  }
  function j(ae) {
    (0, m.checkUnknownRules)(ae), $(ae);
  }
  function D(ae, se) {
    if (ae.opts.jtd)
      return L(ae, [], !1, se);
    const pe = (0, t.getSchemaTypes)(ae.schema), ge = (0, t.coerceAndCheckDataType)(ae, pe);
    L(ae, pe, !ge, se);
  }
  function $(ae) {
    const { schema: se, errSchemaPath: pe, opts: ge, self: xe } = ae;
    se.$ref && ge.ignoreKeywordsWithRef && (0, m.schemaHasRulesButRef)(se, xe.RULES) && xe.logger.warn(`$ref: keywords ignored in schema at path "${pe}"`);
  }
  function z(ae) {
    const { schema: se, opts: pe } = ae;
    se.default !== void 0 && pe.useDefaults && pe.strictSchema && (0, m.checkStrictMode)(ae, "default is ignored in the schema root");
  }
  function B(ae) {
    const se = ae.schema[ae.opts.schemaId];
    se && (ae.baseId = (0, p.resolveUrl)(ae.opts.uriResolver, ae.baseId, se));
  }
  function P(ae) {
    if (ae.schema.$async && !ae.schemaEnv.$async)
      throw new Error("async schema in sync schema");
  }
  function W({ gen: ae, schemaEnv: se, schema: pe, errSchemaPath: ge, opts: xe }) {
    const _e = pe.$comment;
    if (xe.$comment === !0)
      ae.code((0, c._)`${d.default.self}.logger.log(${_e})`);
    else if (typeof xe.$comment == "function") {
      const We = (0, c.str)`${ge}/$comment`, Xe = ae.scopeValue("root", { ref: se.root });
      ae.code((0, c._)`${d.default.self}.opts.$comment(${_e}, ${We}, ${Xe}.schema)`);
    }
  }
  function I(ae) {
    const { gen: se, schemaEnv: pe, validateName: ge, ValidationError: xe, opts: _e } = ae;
    pe.$async ? se.if((0, c._)`${d.default.errors} === 0`, () => se.return(d.default.data), () => se.throw((0, c._)`new ${xe}(${d.default.vErrors})`)) : (se.assign((0, c._)`${ge}.errors`, d.default.vErrors), _e.unevaluated && G(ae), se.return((0, c._)`${d.default.errors} === 0`));
  }
  function G({ gen: ae, evaluated: se, props: pe, items: ge }) {
    pe instanceof c.Name && ae.assign((0, c._)`${se}.props`, pe), ge instanceof c.Name && ae.assign((0, c._)`${se}.items`, ge);
  }
  function L(ae, se, pe, ge) {
    const { gen: xe, schema: _e, data: We, allErrors: Xe, opts: et, self: tt } = ae, { RULES: je } = tt;
    if (_e.$ref && (et.ignoreKeywordsWithRef || !(0, m.schemaHasRulesButRef)(_e, je))) {
      xe.block(() => de(ae, "$ref", je.all.$ref.definition));
      return;
    }
    et.jtd || q(ae, se), xe.block(() => {
      for (const dt of je.rules)
        an(dt);
      an(je.post);
    });
    function an(dt) {
      (0, n.shouldUseGroup)(_e, dt) && (dt.type ? (xe.if((0, r.checkDataType)(dt.type, We, et.strictNumbers)), K(ae, dt), se.length === 1 && se[0] === dt.type && pe && (xe.else(), (0, r.reportTypeError)(ae)), xe.endIf()) : K(ae, dt), Xe || xe.if((0, c._)`${d.default.errors} === ${ge || 0}`));
    }
  }
  function K(ae, se) {
    const { gen: pe, schema: ge, opts: { useDefaults: xe } } = ae;
    xe && (0, a.assignDefaults)(ae, se.type), pe.block(() => {
      for (const _e of se.rules)
        (0, n.shouldUseRule)(ge, _e) && de(ae, _e.keyword, _e.definition, se.type);
    });
  }
  function q(ae, se) {
    ae.schemaEnv.meta || !ae.opts.strictTypes || (Z(ae, se), ae.opts.allowUnionTypes || V(ae, se), F(ae, ae.dataTypes));
  }
  function Z(ae, se) {
    if (se.length) {
      if (!ae.dataTypes.length) {
        ae.dataTypes = se;
        return;
      }
      se.forEach((pe) => {
        U(ae.dataTypes, pe) || Q(ae, `type "${pe}" not allowed by context "${ae.dataTypes.join(",")}"`);
      }), H(ae, se);
    }
  }
  function V(ae, se) {
    se.length > 1 && !(se.length === 2 && se.includes("null")) && Q(ae, "use allowUnionTypes to allow union type keyword");
  }
  function F(ae, se) {
    const pe = ae.self.RULES.all;
    for (const ge in pe) {
      const xe = pe[ge];
      if (typeof xe == "object" && (0, n.shouldUseRule)(ae.schema, xe)) {
        const { type: _e } = xe.definition;
        _e.length && !_e.some((We) => X(se, We)) && Q(ae, `missing type "${_e.join(",")}" for keyword "${ge}"`);
      }
    }
  }
  function X(ae, se) {
    return ae.includes(se) || se === "number" && ae.includes("integer");
  }
  function U(ae, se) {
    return ae.includes(se) || se === "integer" && ae.includes("number");
  }
  function H(ae, se) {
    const pe = [];
    for (const ge of ae.dataTypes)
      U(se, ge) ? pe.push(ge) : se.includes("integer") && ge === "number" && pe.push("integer");
    ae.dataTypes = pe;
  }
  function Q(ae, se) {
    const pe = ae.schemaEnv.baseId + ae.errSchemaPath;
    se += ` at "${pe}" (strictTypes)`, (0, m.checkStrictMode)(ae, se, ae.opts.strictTypes);
  }
  class re {
    constructor(se, pe, ge) {
      if ((0, s.validateKeywordUsage)(se, pe, ge), this.gen = se.gen, this.allErrors = se.allErrors, this.keyword = ge, this.data = se.data, this.schema = se.schema[ge], this.$data = pe.$data && se.opts.$data && this.schema && this.schema.$data, this.schemaValue = (0, m.schemaRefOrVal)(se, this.schema, ge, this.$data), this.schemaType = pe.schemaType, this.parentSchema = se.schema, this.params = {}, this.it = se, this.def = pe, this.$data)
        this.schemaCode = se.gen.const("vSchema", ve(this.$data, se));
      else if (this.schemaCode = this.schemaValue, !(0, s.validSchemaType)(this.schema, pe.schemaType, pe.allowUndefined))
        throw new Error(`${ge} value must be ${JSON.stringify(pe.schemaType)}`);
      ("code" in pe ? pe.trackErrors : pe.errors !== !1) && (this.errsCount = se.gen.const("_errs", d.default.errors));
    }
    result(se, pe, ge) {
      this.failResult((0, c.not)(se), pe, ge);
    }
    failResult(se, pe, ge) {
      this.gen.if(se), ge ? ge() : this.error(), pe ? (this.gen.else(), pe(), this.allErrors && this.gen.endIf()) : this.allErrors ? this.gen.endIf() : this.gen.else();
    }
    pass(se, pe) {
      this.failResult((0, c.not)(se), void 0, pe);
    }
    fail(se) {
      if (se === void 0) {
        this.error(), this.allErrors || this.gen.if(!1);
        return;
      }
      this.gen.if(se), this.error(), this.allErrors ? this.gen.endIf() : this.gen.else();
    }
    fail$data(se) {
      if (!this.$data)
        return this.fail(se);
      const { schemaCode: pe } = this;
      this.fail((0, c._)`${pe} !== undefined && (${(0, c.or)(this.invalid$data(), se)})`);
    }
    error(se, pe, ge) {
      if (pe) {
        this.setParams(pe), this._error(se, ge), this.setParams({});
        return;
      }
      this._error(se, ge);
    }
    _error(se, pe) {
      (se ? h.reportExtraError : h.reportError)(this, this.def.error, pe);
    }
    $dataError() {
      (0, h.reportError)(this, this.def.$dataError || h.keyword$DataError);
    }
    reset() {
      if (this.errsCount === void 0)
        throw new Error('add "trackErrors" to keyword definition');
      (0, h.resetErrorsCount)(this.gen, this.errsCount);
    }
    ok(se) {
      this.allErrors || this.gen.if(se);
    }
    setParams(se, pe) {
      pe ? Object.assign(this.params, se) : this.params = se;
    }
    block$data(se, pe, ge = c.nil) {
      this.gen.block(() => {
        this.check$data(se, ge), pe();
      });
    }
    check$data(se = c.nil, pe = c.nil) {
      if (!this.$data)
        return;
      const { gen: ge, schemaCode: xe, schemaType: _e, def: We } = this;
      ge.if((0, c.or)((0, c._)`${xe} === undefined`, pe)), se !== c.nil && ge.assign(se, !0), (_e.length || We.validateSchema) && (ge.elseIf(this.invalid$data()), this.$dataError(), se !== c.nil && ge.assign(se, !1)), ge.else();
    }
    invalid$data() {
      const { gen: se, schemaCode: pe, schemaType: ge, def: xe, it: _e } = this;
      return (0, c.or)(We(), Xe());
      function We() {
        if (ge.length) {
          if (!(pe instanceof c.Name))
            throw new Error("ajv implementation error");
          const et = Array.isArray(ge) ? ge : [ge];
          return (0, c._)`${(0, r.checkDataTypes)(et, pe, _e.opts.strictNumbers, r.DataType.Wrong)}`;
        }
        return c.nil;
      }
      function Xe() {
        if (xe.validateSchema) {
          const et = se.scopeValue("validate$data", { ref: xe.validateSchema });
          return (0, c._)`!${et}(${pe})`;
        }
        return c.nil;
      }
    }
    subschema(se, pe) {
      const ge = (0, l.getSubschema)(this.it, se);
      (0, l.extendSubschemaData)(ge, this.it, se), (0, l.extendSubschemaMode)(ge, se);
      const xe = { ...this.it, ...ge, items: void 0, props: void 0 };
      return _(xe, pe), xe;
    }
    mergeEvaluated(se, pe) {
      const { it: ge, gen: xe } = this;
      ge.opts.unevaluated && (ge.props !== !0 && se.props !== void 0 && (ge.props = m.mergeEvaluated.props(xe, se.props, ge.props, pe)), ge.items !== !0 && se.items !== void 0 && (ge.items = m.mergeEvaluated.items(xe, se.items, ge.items, pe)));
    }
    mergeValidEvaluated(se, pe) {
      const { it: ge, gen: xe } = this;
      if (ge.opts.unevaluated && (ge.props !== !0 || ge.items !== !0))
        return xe.if(pe, () => this.mergeEvaluated(se, c.Name)), !0;
    }
  }
  oc.KeywordCxt = re;
  function de(ae, se, pe, ge) {
    const xe = new re(ae, pe, se);
    "code" in pe ? pe.code(xe, ge) : xe.$data && pe.validate ? (0, s.funcKeywordCode)(xe, pe) : "macro" in pe ? (0, s.macroKeywordCode)(xe, pe) : (pe.compile || pe.validate) && (0, s.funcKeywordCode)(xe, pe);
  }
  const le = /^\/(?:[^~]|~0|~1)*$/, me = /^([0-9]+)(#|\/(?:[^~]|~0|~1)*)?$/;
  function ve(ae, { dataLevel: se, dataNames: pe, dataPathArr: ge }) {
    let xe, _e;
    if (ae === "")
      return d.default.rootData;
    if (ae[0] === "/") {
      if (!le.test(ae))
        throw new Error(`Invalid JSON-pointer: ${ae}`);
      xe = ae, _e = d.default.rootData;
    } else {
      const tt = me.exec(ae);
      if (!tt)
        throw new Error(`Invalid JSON-pointer: ${ae}`);
      const je = +tt[1];
      if (xe = tt[2], xe === "#") {
        if (je >= se)
          throw new Error(et("property/index", je));
        return ge[se - je];
      }
      if (je > se)
        throw new Error(et("data", je));
      if (_e = pe[se - je], !xe)
        return _e;
    }
    let We = _e;
    const Xe = xe.split("/");
    for (const tt of Xe)
      tt && (_e = (0, c._)`${_e}${(0, c.getProperty)((0, m.unescapeJsonPointer)(tt))}`, We = (0, c._)`${We} && ${_e}`);
    return We;
    function et(tt, je) {
      return `Cannot access ${tt} ${je} levels up, current level is ${se}`;
    }
  }
  return oc.getData = ve, oc;
}
var bk = {}, cL;
function a4() {
  if (cL) return bk;
  cL = 1, Object.defineProperty(bk, "__esModule", { value: !0 });
  class e extends Error {
    constructor(n) {
      super("validation failed"), this.errors = n, this.ajv = this.validation = !0;
    }
  }
  return bk.default = e, bk;
}
var wk = {}, dL;
function vE() {
  if (dL) return wk;
  dL = 1, Object.defineProperty(wk, "__esModule", { value: !0 });
  const e = hE();
  class t extends Error {
    constructor(r, a, s, l) {
      super(l || `can't resolve reference ${s} from id ${a}`), this.missingRef = (0, e.resolveUrl)(r, a, s), this.missingSchema = (0, e.normalizeId)((0, e.getFullPath)(r, this.missingRef));
    }
  }
  return wk.default = t, wk;
}
var fi = {}, fL;
function i4() {
  if (fL) return fi;
  fL = 1, Object.defineProperty(fi, "__esModule", { value: !0 }), fi.resolveSchema = fi.getCompilingSchema = fi.resolveRef = fi.compileSchema = fi.SchemaEnv = void 0;
  const e = qt(), t = a4(), n = yd(), r = hE(), a = pn(), s = gE();
  class l {
    constructor(k) {
      var C;
      this.refs = {}, this.dynamicAnchors = {};
      let _;
      typeof k.schema == "object" && (_ = k.schema), this.schema = k.schema, this.schemaId = k.schemaId, this.root = k.root || this, this.baseId = (C = k.baseId) !== null && C !== void 0 ? C : (0, r.normalizeId)(_?.[k.schemaId || "$id"]), this.schemaPath = k.schemaPath, this.localRefs = k.localRefs, this.meta = k.meta, this.$async = _?.$async, this.refs = {};
    }
  }
  fi.SchemaEnv = l;
  function c(b) {
    const k = m.call(this, b);
    if (k)
      return k;
    const C = (0, r.getFullPath)(this.opts.uriResolver, b.root.baseId), { es5: _, lines: O } = this.opts.code, { ownProperties: N } = this.opts, R = new e.CodeGen(this.scope, { es5: _, lines: O, ownProperties: N });
    let j;
    b.$async && (j = R.scopeValue("Error", {
      ref: t.default,
      code: (0, e._)`require("ajv/dist/runtime/validation_error").default`
    }));
    const D = R.scopeName("validate");
    b.validateName = D;
    const $ = {
      gen: R,
      allErrors: this.opts.allErrors,
      data: n.default.data,
      parentData: n.default.parentData,
      parentDataProperty: n.default.parentDataProperty,
      dataNames: [n.default.data],
      dataPathArr: [e.nil],
      // TODO can its length be used as dataLevel if nil is removed?
      dataLevel: 0,
      dataTypes: [],
      definedProperties: /* @__PURE__ */ new Set(),
      topSchemaRef: R.scopeValue("schema", this.opts.code.source === !0 ? { ref: b.schema, code: (0, e.stringify)(b.schema) } : { ref: b.schema }),
      validateName: D,
      ValidationError: j,
      schema: b.schema,
      schemaEnv: b,
      rootId: C,
      baseId: b.baseId || C,
      schemaPath: e.nil,
      errSchemaPath: b.schemaPath || (this.opts.jtd ? "" : "#"),
      errorPath: (0, e._)`""`,
      opts: this.opts,
      self: this
    };
    let z;
    try {
      this._compilations.add(b), (0, s.validateFunctionCode)($), R.optimize(this.opts.code.optimize);
      const B = R.toString();
      z = `${R.scopeRefs(n.default.scope)}return ${B}`, this.opts.code.process && (z = this.opts.code.process(z, b));
      const P = new Function(`${n.default.self}`, `${n.default.scope}`, z)(this, this.scope.get());
      if (this.scope.value(D, { ref: P }), P.errors = null, P.schema = b.schema, P.schemaEnv = b, b.$async && (P.$async = !0), this.opts.code.source === !0 && (P.source = { validateName: D, validateCode: B, scopeValues: R._values }), this.opts.unevaluated) {
        const { props: W, items: I } = $;
        P.evaluated = {
          props: W instanceof e.Name ? void 0 : W,
          items: I instanceof e.Name ? void 0 : I,
          dynamicProps: W instanceof e.Name,
          dynamicItems: I instanceof e.Name
        }, P.source && (P.source.evaluated = (0, e.stringify)(P.evaluated));
      }
      return b.validate = P, b;
    } catch (B) {
      throw delete b.validate, delete b.validateName, z && this.logger.error("Error compiling schema, function code:", z), B;
    } finally {
      this._compilations.delete(b);
    }
  }
  fi.compileSchema = c;
  function d(b, k, C) {
    var _;
    C = (0, r.resolveUrl)(this.opts.uriResolver, k, C);
    const O = b.refs[C];
    if (O)
      return O;
    let N = v.call(this, b, C);
    if (N === void 0) {
      const R = (_ = b.localRefs) === null || _ === void 0 ? void 0 : _[C], { schemaId: j } = this.opts;
      R && (N = new l({ schema: R, schemaId: j, root: b, baseId: k }));
    }
    if (N !== void 0)
      return b.refs[C] = p.call(this, N);
  }
  fi.resolveRef = d;
  function p(b) {
    return (0, r.inlineRef)(b.schema, this.opts.inlineRefs) ? b.schema : b.validate ? b : c.call(this, b);
  }
  function m(b) {
    for (const k of this._compilations)
      if (h(k, b))
        return k;
  }
  fi.getCompilingSchema = m;
  function h(b, k) {
    return b.schema === k.schema && b.root === k.root && b.baseId === k.baseId;
  }
  function v(b, k) {
    let C;
    for (; typeof (C = this.refs[k]) == "string"; )
      k = C;
    return C || this.schemas[k] || y.call(this, b, k);
  }
  function y(b, k) {
    const C = this.opts.uriResolver.parse(k), _ = (0, r._getFullPath)(this.opts.uriResolver, C);
    let O = (0, r.getFullPath)(this.opts.uriResolver, b.baseId, void 0);
    if (Object.keys(b.schema).length > 0 && _ === O)
      return x.call(this, C, b);
    const N = (0, r.normalizeId)(_), R = this.refs[N] || this.schemas[N];
    if (typeof R == "string") {
      const j = y.call(this, b, R);
      return typeof j?.schema != "object" ? void 0 : x.call(this, C, j);
    }
    if (typeof R?.schema == "object") {
      if (R.validate || c.call(this, R), N === (0, r.normalizeId)(k)) {
        const { schema: j } = R, { schemaId: D } = this.opts, $ = j[D];
        return $ && (O = (0, r.resolveUrl)(this.opts.uriResolver, O, $)), new l({ schema: j, schemaId: D, root: b, baseId: O });
      }
      return x.call(this, C, R);
    }
  }
  fi.resolveSchema = y;
  const w = /* @__PURE__ */ new Set([
    "properties",
    "patternProperties",
    "enum",
    "dependencies",
    "definitions"
  ]);
  function x(b, { baseId: k, schema: C, root: _ }) {
    var O;
    if (((O = b.fragment) === null || O === void 0 ? void 0 : O[0]) !== "/")
      return;
    for (const j of b.fragment.slice(1).split("/")) {
      if (typeof C == "boolean")
        return;
      const D = C[(0, a.unescapeFragment)(j)];
      if (D === void 0)
        return;
      C = D;
      const $ = typeof C == "object" && C[this.opts.schemaId];
      !w.has(j) && $ && (k = (0, r.resolveUrl)(this.opts.uriResolver, k, $));
    }
    let N;
    if (typeof C != "boolean" && C.$ref && !(0, a.schemaHasRulesButRef)(C, this.RULES)) {
      const j = (0, r.resolveUrl)(this.opts.uriResolver, k, C.$ref);
      N = y.call(this, _, j);
    }
    const { schemaId: R } = this.opts;
    if (N = N || new l({ schema: C, schemaId: R, root: _, baseId: k }), N.schema !== N.root.schema)
      return N;
  }
  return fi;
}
const eCe = "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#", tCe = "Meta-schema for $data reference (JSON AnySchema extension proposal)", nCe = "object", rCe = ["$data"], oCe = { $data: { type: "string", anyOf: [{ format: "relative-json-pointer" }, { format: "json-pointer" }] } }, aCe = !1, iCe = {
  $id: eCe,
  description: tCe,
  type: nCe,
  required: rCe,
  properties: oCe,
  additionalProperties: aCe
};
var xk = {}, vw = { exports: {} }, pL, mL;
function sCe() {
  return mL || (mL = 1, pL = {
    HEX: {
      0: 0,
      1: 1,
      2: 2,
      3: 3,
      4: 4,
      5: 5,
      6: 6,
      7: 7,
      8: 8,
      9: 9,
      a: 10,
      A: 10,
      b: 11,
      B: 11,
      c: 12,
      C: 12,
      d: 13,
      D: 13,
      e: 14,
      E: 14,
      f: 15,
      F: 15
    }
  }), pL;
}
var uN, hL;
function lCe() {
  if (hL) return uN;
  hL = 1;
  const { HEX: e } = sCe(), t = /^(?:(?:25[0-5]|2[0-4]\d|1\d{2}|[1-9]\d|\d)\.){3}(?:25[0-5]|2[0-4]\d|1\d{2}|[1-9]\d|\d)$/u;
  function n(x) {
    if (c(x, ".") < 3)
      return { host: x, isIPV4: !1 };
    const b = x.match(t) || [], [k] = b;
    return k ? { host: l(k, "."), isIPV4: !0 } : { host: x, isIPV4: !1 };
  }
  function r(x, b = !1) {
    let k = "", C = !0;
    for (const _ of x) {
      if (e[_] === void 0) return;
      _ !== "0" && C === !0 && (C = !1), C || (k += _);
    }
    return b && k.length === 0 && (k = "0"), k;
  }
  function a(x) {
    let b = 0;
    const k = { error: !1, address: "", zone: "" }, C = [], _ = [];
    let O = !1, N = !1, R = !1;
    function j() {
      if (_.length) {
        if (O === !1) {
          const D = r(_);
          if (D !== void 0)
            C.push(D);
          else
            return k.error = !0, !1;
        }
        _.length = 0;
      }
      return !0;
    }
    for (let D = 0; D < x.length; D++) {
      const $ = x[D];
      if (!($ === "[" || $ === "]"))
        if ($ === ":") {
          if (N === !0 && (R = !0), !j())
            break;
          if (b++, C.push(":"), b > 7) {
            k.error = !0;
            break;
          }
          D - 1 >= 0 && x[D - 1] === ":" && (N = !0);
          continue;
        } else if ($ === "%") {
          if (!j())
            break;
          O = !0;
        } else {
          _.push($);
          continue;
        }
    }
    return _.length && (O ? k.zone = _.join("") : R ? C.push(_.join("")) : C.push(r(_))), k.address = C.join(""), k;
  }
  function s(x) {
    if (c(x, ":") < 2)
      return { host: x, isIPV6: !1 };
    const b = a(x);
    if (b.error)
      return { host: x, isIPV6: !1 };
    {
      let k = b.address, C = b.address;
      return b.zone && (k += "%" + b.zone, C += "%25" + b.zone), { host: k, escapedHost: C, isIPV6: !0 };
    }
  }
  function l(x, b) {
    let k = "", C = !0;
    const _ = x.length;
    for (let O = 0; O < _; O++) {
      const N = x[O];
      N === "0" && C ? (O + 1 <= _ && x[O + 1] === b || O + 1 === _) && (k += N, C = !1) : (N === b ? C = !0 : C = !1, k += N);
    }
    return k;
  }
  function c(x, b) {
    let k = 0;
    for (let C = 0; C < x.length; C++)
      x[C] === b && k++;
    return k;
  }
  const d = /^\.\.?\//u, p = /^\/\.(?:\/|$)/u, m = /^\/\.\.(?:\/|$)/u, h = /^\/?(?:.|\n)*?(?=\/|$)/u;
  function v(x) {
    const b = [];
    for (; x.length; )
      if (x.match(d))
        x = x.replace(d, "");
      else if (x.match(p))
        x = x.replace(p, "/");
      else if (x.match(m))
        x = x.replace(m, "/"), b.pop();
      else if (x === "." || x === "..")
        x = "";
      else {
        const k = x.match(h);
        if (k) {
          const C = k[0];
          x = x.slice(C.length), b.push(C);
        } else
          throw new Error("Unexpected dot segment condition");
      }
    return b.join("");
  }
  function y(x, b) {
    const k = b !== !0 ? escape : unescape;
    return x.scheme !== void 0 && (x.scheme = k(x.scheme)), x.userinfo !== void 0 && (x.userinfo = k(x.userinfo)), x.host !== void 0 && (x.host = k(x.host)), x.path !== void 0 && (x.path = k(x.path)), x.query !== void 0 && (x.query = k(x.query)), x.fragment !== void 0 && (x.fragment = k(x.fragment)), x;
  }
  function w(x) {
    const b = [];
    if (x.userinfo !== void 0 && (b.push(x.userinfo), b.push("@")), x.host !== void 0) {
      let k = unescape(x.host);
      const C = n(k);
      if (C.isIPV4)
        k = C.host;
      else {
        const _ = s(C.host);
        _.isIPV6 === !0 ? k = `[${_.escapedHost}]` : k = x.host;
      }
      b.push(k);
    }
    return (typeof x.port == "number" || typeof x.port == "string") && (b.push(":"), b.push(String(x.port))), b.length ? b.join("") : void 0;
  }
  return uN = {
    recomposeAuthority: w,
    normalizeComponentEncoding: y,
    removeDotSegments: v,
    normalizeIPv4: n,
    normalizeIPv6: s,
    stringArrayToHexStripped: r
  }, uN;
}
var cN, gL;
function uCe() {
  if (gL) return cN;
  gL = 1;
  const e = /^[\da-f]{8}-[\da-f]{4}-[\da-f]{4}-[\da-f]{4}-[\da-f]{12}$/iu, t = /([\da-z][\d\-a-z]{0,31}):((?:[\w!$'()*+,\-.:;=@]|%[\da-f]{2})+)/iu;
  function n(b) {
    return typeof b.secure == "boolean" ? b.secure : String(b.scheme).toLowerCase() === "wss";
  }
  function r(b) {
    return b.host || (b.error = b.error || "HTTP URIs must have a host."), b;
  }
  function a(b) {
    const k = String(b.scheme).toLowerCase() === "https";
    return (b.port === (k ? 443 : 80) || b.port === "") && (b.port = void 0), b.path || (b.path = "/"), b;
  }
  function s(b) {
    return b.secure = n(b), b.resourceName = (b.path || "/") + (b.query ? "?" + b.query : ""), b.path = void 0, b.query = void 0, b;
  }
  function l(b) {
    if ((b.port === (n(b) ? 443 : 80) || b.port === "") && (b.port = void 0), typeof b.secure == "boolean" && (b.scheme = b.secure ? "wss" : "ws", b.secure = void 0), b.resourceName) {
      const [k, C] = b.resourceName.split("?");
      b.path = k && k !== "/" ? k : void 0, b.query = C, b.resourceName = void 0;
    }
    return b.fragment = void 0, b;
  }
  function c(b, k) {
    if (!b.path)
      return b.error = "URN can not be parsed", b;
    const C = b.path.match(t);
    if (C) {
      const _ = k.scheme || b.scheme || "urn";
      b.nid = C[1].toLowerCase(), b.nss = C[2];
      const O = `${_}:${k.nid || b.nid}`, N = x[O];
      b.path = void 0, N && (b = N.parse(b, k));
    } else
      b.error = b.error || "URN can not be parsed.";
    return b;
  }
  function d(b, k) {
    const C = k.scheme || b.scheme || "urn", _ = b.nid.toLowerCase(), O = `${C}:${k.nid || _}`, N = x[O];
    N && (b = N.serialize(b, k));
    const R = b, j = b.nss;
    return R.path = `${_ || k.nid}:${j}`, k.skipEscape = !0, R;
  }
  function p(b, k) {
    const C = b;
    return C.uuid = C.nss, C.nss = void 0, !k.tolerant && (!C.uuid || !e.test(C.uuid)) && (C.error = C.error || "UUID is not valid."), C;
  }
  function m(b) {
    const k = b;
    return k.nss = (b.uuid || "").toLowerCase(), k;
  }
  const h = {
    scheme: "http",
    domainHost: !0,
    parse: r,
    serialize: a
  }, v = {
    scheme: "https",
    domainHost: h.domainHost,
    parse: r,
    serialize: a
  }, y = {
    scheme: "ws",
    domainHost: !0,
    parse: s,
    serialize: l
  }, w = {
    scheme: "wss",
    domainHost: y.domainHost,
    parse: y.parse,
    serialize: y.serialize
  }, x = {
    http: h,
    https: v,
    ws: y,
    wss: w,
    urn: {
      scheme: "urn",
      parse: c,
      serialize: d,
      skipNormalize: !0
    },
    "urn:uuid": {
      scheme: "urn:uuid",
      parse: p,
      serialize: m,
      skipNormalize: !0
    }
  };
  return cN = x, cN;
}
var vL;
function cCe() {
  if (vL) return vw.exports;
  vL = 1;
  const { normalizeIPv6: e, normalizeIPv4: t, removeDotSegments: n, recomposeAuthority: r, normalizeComponentEncoding: a } = lCe(), s = uCe();
  function l(b, k) {
    return typeof b == "string" ? b = m(w(b, k), k) : typeof b == "object" && (b = w(m(b, k), k)), b;
  }
  function c(b, k, C) {
    const _ = Object.assign({ scheme: "null" }, C), O = d(w(b, _), w(k, _), _, !0);
    return m(O, { ..._, skipEscape: !0 });
  }
  function d(b, k, C, _) {
    const O = {};
    return _ || (b = w(m(b, C), C), k = w(m(k, C), C)), C = C || {}, !C.tolerant && k.scheme ? (O.scheme = k.scheme, O.userinfo = k.userinfo, O.host = k.host, O.port = k.port, O.path = n(k.path || ""), O.query = k.query) : (k.userinfo !== void 0 || k.host !== void 0 || k.port !== void 0 ? (O.userinfo = k.userinfo, O.host = k.host, O.port = k.port, O.path = n(k.path || ""), O.query = k.query) : (k.path ? (k.path.charAt(0) === "/" ? O.path = n(k.path) : ((b.userinfo !== void 0 || b.host !== void 0 || b.port !== void 0) && !b.path ? O.path = "/" + k.path : b.path ? O.path = b.path.slice(0, b.path.lastIndexOf("/") + 1) + k.path : O.path = k.path, O.path = n(O.path)), O.query = k.query) : (O.path = b.path, k.query !== void 0 ? O.query = k.query : O.query = b.query), O.userinfo = b.userinfo, O.host = b.host, O.port = b.port), O.scheme = b.scheme), O.fragment = k.fragment, O;
  }
  function p(b, k, C) {
    return typeof b == "string" ? (b = unescape(b), b = m(a(w(b, C), !0), { ...C, skipEscape: !0 })) : typeof b == "object" && (b = m(a(b, !0), { ...C, skipEscape: !0 })), typeof k == "string" ? (k = unescape(k), k = m(a(w(k, C), !0), { ...C, skipEscape: !0 })) : typeof k == "object" && (k = m(a(k, !0), { ...C, skipEscape: !0 })), b.toLowerCase() === k.toLowerCase();
  }
  function m(b, k) {
    const C = {
      host: b.host,
      scheme: b.scheme,
      userinfo: b.userinfo,
      port: b.port,
      path: b.path,
      query: b.query,
      nid: b.nid,
      nss: b.nss,
      uuid: b.uuid,
      fragment: b.fragment,
      reference: b.reference,
      resourceName: b.resourceName,
      secure: b.secure,
      error: ""
    }, _ = Object.assign({}, k), O = [], N = s[(_.scheme || C.scheme || "").toLowerCase()];
    N && N.serialize && N.serialize(C, _), C.path !== void 0 && (_.skipEscape ? C.path = unescape(C.path) : (C.path = escape(C.path), C.scheme !== void 0 && (C.path = C.path.split("%3A").join(":")))), _.reference !== "suffix" && C.scheme && O.push(C.scheme, ":");
    const R = r(C);
    if (R !== void 0 && (_.reference !== "suffix" && O.push("//"), O.push(R), C.path && C.path.charAt(0) !== "/" && O.push("/")), C.path !== void 0) {
      let j = C.path;
      !_.absolutePath && (!N || !N.absolutePath) && (j = n(j)), R === void 0 && (j = j.replace(/^\/\//u, "/%2F")), O.push(j);
    }
    return C.query !== void 0 && O.push("?", C.query), C.fragment !== void 0 && O.push("#", C.fragment), O.join("");
  }
  const h = Array.from({ length: 127 }, (b, k) => /[^!"$&'()*+,\-.;=_`a-z{}~]/u.test(String.fromCharCode(k)));
  function v(b) {
    let k = 0;
    for (let C = 0, _ = b.length; C < _; ++C)
      if (k = b.charCodeAt(C), k > 126 || h[k])
        return !0;
    return !1;
  }
  const y = /^(?:([^#/:?]+):)?(?:\/\/((?:([^#/?@]*)@)?(\[[^#/?\]]+\]|[^#/:?]*)(?::(\d*))?))?([^#?]*)(?:\?([^#]*))?(?:#((?:.|[\n\r])*))?/u;
  function w(b, k) {
    const C = Object.assign({}, k), _ = {
      scheme: void 0,
      userinfo: void 0,
      host: "",
      port: void 0,
      path: "",
      query: void 0,
      fragment: void 0
    }, O = b.indexOf("%") !== -1;
    let N = !1;
    C.reference === "suffix" && (b = (C.scheme ? C.scheme + ":" : "") + "//" + b);
    const R = b.match(y);
    if (R) {
      if (_.scheme = R[1], _.userinfo = R[3], _.host = R[4], _.port = parseInt(R[5], 10), _.path = R[6] || "", _.query = R[7], _.fragment = R[8], isNaN(_.port) && (_.port = R[5]), _.host) {
        const D = t(_.host);
        if (D.isIPV4 === !1) {
          const $ = e(D.host);
          _.host = $.host.toLowerCase(), N = $.isIPV6;
        } else
          _.host = D.host, N = !0;
      }
      _.scheme === void 0 && _.userinfo === void 0 && _.host === void 0 && _.port === void 0 && _.query === void 0 && !_.path ? _.reference = "same-document" : _.scheme === void 0 ? _.reference = "relative" : _.fragment === void 0 ? _.reference = "absolute" : _.reference = "uri", C.reference && C.reference !== "suffix" && C.reference !== _.reference && (_.error = _.error || "URI is not a " + C.reference + " reference.");
      const j = s[(C.scheme || _.scheme || "").toLowerCase()];
      if (!C.unicodeSupport && (!j || !j.unicodeSupport) && _.host && (C.domainHost || j && j.domainHost) && N === !1 && v(_.host))
        try {
          _.host = URL.domainToASCII(_.host.toLowerCase());
        } catch (D) {
          _.error = _.error || "Host's domain name can not be converted to ASCII: " + D;
        }
      (!j || j && !j.skipNormalize) && (O && _.scheme !== void 0 && (_.scheme = unescape(_.scheme)), O && _.host !== void 0 && (_.host = unescape(_.host)), _.path && (_.path = escape(unescape(_.path))), _.fragment && (_.fragment = encodeURI(decodeURIComponent(_.fragment)))), j && j.parse && j.parse(_, C);
    } else
      _.error = _.error || "URI can not be parsed.";
    return _;
  }
  const x = {
    SCHEMES: s,
    normalize: l,
    resolve: c,
    resolveComponents: d,
    equal: p,
    serialize: m,
    parse: w
  };
  return vw.exports = x, vw.exports.default = x, vw.exports.fastUri = x, vw.exports;
}
var yL;
function dCe() {
  if (yL) return xk;
  yL = 1, Object.defineProperty(xk, "__esModule", { value: !0 });
  const e = cCe();
  return e.code = 'require("ajv/dist/runtime/uri").default', xk.default = e, xk;
}
var bL;
function fCe() {
  return bL || (bL = 1, (function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.CodeGen = e.Name = e.nil = e.stringify = e.str = e._ = e.KeywordCxt = void 0;
    var t = gE();
    Object.defineProperty(e, "KeywordCxt", { enumerable: !0, get: function() {
      return t.KeywordCxt;
    } });
    var n = qt();
    Object.defineProperty(e, "_", { enumerable: !0, get: function() {
      return n._;
    } }), Object.defineProperty(e, "str", { enumerable: !0, get: function() {
      return n.str;
    } }), Object.defineProperty(e, "stringify", { enumerable: !0, get: function() {
      return n.stringify;
    } }), Object.defineProperty(e, "nil", { enumerable: !0, get: function() {
      return n.nil;
    } }), Object.defineProperty(e, "Name", { enumerable: !0, get: function() {
      return n.Name;
    } }), Object.defineProperty(e, "CodeGen", { enumerable: !0, get: function() {
      return n.CodeGen;
    } });
    const r = a4(), a = vE(), s = QH(), l = i4(), c = qt(), d = hE(), p = D_(), m = pn(), h = iCe, v = dCe(), y = (V, F) => new RegExp(V, F);
    y.code = "new RegExp";
    const w = ["removeAdditional", "useDefaults", "coerceTypes"], x = /* @__PURE__ */ new Set([
      "validate",
      "serialize",
      "parse",
      "wrapper",
      "root",
      "schema",
      "keyword",
      "pattern",
      "formats",
      "validate$data",
      "func",
      "obj",
      "Error"
    ]), b = {
      errorDataPath: "",
      format: "`validateFormats: false` can be used instead.",
      nullable: '"nullable" keyword is supported by default.',
      jsonPointers: "Deprecated jsPropertySyntax can be used instead.",
      extendRefs: "Deprecated ignoreKeywordsWithRef can be used instead.",
      missingRefs: "Pass empty schema with $id that should be ignored to ajv.addSchema.",
      processCode: "Use option `code: {process: (code, schemaEnv: object) => string}`",
      sourceCode: "Use option `code: {source: true}`",
      strictDefaults: "It is default now, see option `strict`.",
      strictKeywords: "It is default now, see option `strict`.",
      uniqueItems: '"uniqueItems" keyword is always validated.',
      unknownFormats: "Disable strict mode or pass `true` to `ajv.addFormat` (or `formats` option).",
      cache: "Map is used as cache, schema object as key.",
      serialize: "Map is used as cache, schema object as key.",
      ajvErrors: "It is default now."
    }, k = {
      ignoreKeywordsWithRef: "",
      jsPropertySyntax: "",
      unicode: '"minLength"/"maxLength" account for unicode characters by default.'
    }, C = 200;
    function _(V) {
      var F, X, U, H, Q, re, de, le, me, ve, ae, se, pe, ge, xe, _e, We, Xe, et, tt, je, an, dt, Ce, Me;
      const he = V.strict, ye = (F = V.code) === null || F === void 0 ? void 0 : F.optimize, Ee = ye === !0 || ye === void 0 ? 1 : ye || 0, Le = (U = (X = V.code) === null || X === void 0 ? void 0 : X.regExp) !== null && U !== void 0 ? U : y, ze = (H = V.uriResolver) !== null && H !== void 0 ? H : v.default;
      return {
        strictSchema: (re = (Q = V.strictSchema) !== null && Q !== void 0 ? Q : he) !== null && re !== void 0 ? re : !0,
        strictNumbers: (le = (de = V.strictNumbers) !== null && de !== void 0 ? de : he) !== null && le !== void 0 ? le : !0,
        strictTypes: (ve = (me = V.strictTypes) !== null && me !== void 0 ? me : he) !== null && ve !== void 0 ? ve : "log",
        strictTuples: (se = (ae = V.strictTuples) !== null && ae !== void 0 ? ae : he) !== null && se !== void 0 ? se : "log",
        strictRequired: (ge = (pe = V.strictRequired) !== null && pe !== void 0 ? pe : he) !== null && ge !== void 0 ? ge : !1,
        code: V.code ? { ...V.code, optimize: Ee, regExp: Le } : { optimize: Ee, regExp: Le },
        loopRequired: (xe = V.loopRequired) !== null && xe !== void 0 ? xe : C,
        loopEnum: (_e = V.loopEnum) !== null && _e !== void 0 ? _e : C,
        meta: (We = V.meta) !== null && We !== void 0 ? We : !0,
        messages: (Xe = V.messages) !== null && Xe !== void 0 ? Xe : !0,
        inlineRefs: (et = V.inlineRefs) !== null && et !== void 0 ? et : !0,
        schemaId: (tt = V.schemaId) !== null && tt !== void 0 ? tt : "$id",
        addUsedSchema: (je = V.addUsedSchema) !== null && je !== void 0 ? je : !0,
        validateSchema: (an = V.validateSchema) !== null && an !== void 0 ? an : !0,
        validateFormats: (dt = V.validateFormats) !== null && dt !== void 0 ? dt : !0,
        unicodeRegExp: (Ce = V.unicodeRegExp) !== null && Ce !== void 0 ? Ce : !0,
        int32range: (Me = V.int32range) !== null && Me !== void 0 ? Me : !0,
        uriResolver: ze
      };
    }
    class O {
      constructor(F = {}) {
        this.schemas = {}, this.refs = {}, this.formats = {}, this._compilations = /* @__PURE__ */ new Set(), this._loading = {}, this._cache = /* @__PURE__ */ new Map(), F = this.opts = { ...F, ..._(F) };
        const { es5: X, lines: U } = this.opts.code;
        this.scope = new c.ValueScope({ scope: {}, prefixes: x, es5: X, lines: U }), this.logger = P(F.logger);
        const H = F.validateFormats;
        F.validateFormats = !1, this.RULES = (0, s.getRules)(), N.call(this, b, F, "NOT SUPPORTED"), N.call(this, k, F, "DEPRECATED", "warn"), this._metaOpts = z.call(this), F.formats && D.call(this), this._addVocabularies(), this._addDefaultMetaSchema(), F.keywords && $.call(this, F.keywords), typeof F.meta == "object" && this.addMetaSchema(F.meta), j.call(this), F.validateFormats = H;
      }
      _addVocabularies() {
        this.addKeyword("$async");
      }
      _addDefaultMetaSchema() {
        const { $data: F, meta: X, schemaId: U } = this.opts;
        let H = h;
        U === "id" && (H = { ...h }, H.id = H.$id, delete H.$id), X && F && this.addMetaSchema(H, H[U], !1);
      }
      defaultMeta() {
        const { meta: F, schemaId: X } = this.opts;
        return this.opts.defaultMeta = typeof F == "object" ? F[X] || F : void 0;
      }
      validate(F, X) {
        let U;
        if (typeof F == "string") {
          if (U = this.getSchema(F), !U)
            throw new Error(`no schema with key or ref "${F}"`);
        } else
          U = this.compile(F);
        const H = U(X);
        return "$async" in U || (this.errors = U.errors), H;
      }
      compile(F, X) {
        const U = this._addSchema(F, X);
        return U.validate || this._compileSchemaEnv(U);
      }
      compileAsync(F, X) {
        if (typeof this.opts.loadSchema != "function")
          throw new Error("options.loadSchema should be a function");
        const { loadSchema: U } = this.opts;
        return H.call(this, F, X);
        async function H(ve, ae) {
          await Q.call(this, ve.$schema);
          const se = this._addSchema(ve, ae);
          return se.validate || re.call(this, se);
        }
        async function Q(ve) {
          ve && !this.getSchema(ve) && await H.call(this, { $ref: ve }, !0);
        }
        async function re(ve) {
          try {
            return this._compileSchemaEnv(ve);
          } catch (ae) {
            if (!(ae instanceof a.default))
              throw ae;
            return de.call(this, ae), await le.call(this, ae.missingSchema), re.call(this, ve);
          }
        }
        function de({ missingSchema: ve, missingRef: ae }) {
          if (this.refs[ve])
            throw new Error(`AnySchema ${ve} is loaded but ${ae} cannot be resolved`);
        }
        async function le(ve) {
          const ae = await me.call(this, ve);
          this.refs[ve] || await Q.call(this, ae.$schema), this.refs[ve] || this.addSchema(ae, ve, X);
        }
        async function me(ve) {
          const ae = this._loading[ve];
          if (ae)
            return ae;
          try {
            return await (this._loading[ve] = U(ve));
          } finally {
            delete this._loading[ve];
          }
        }
      }
      // Adds schema to the instance
      addSchema(F, X, U, H = this.opts.validateSchema) {
        if (Array.isArray(F)) {
          for (const re of F)
            this.addSchema(re, void 0, U, H);
          return this;
        }
        let Q;
        if (typeof F == "object") {
          const { schemaId: re } = this.opts;
          if (Q = F[re], Q !== void 0 && typeof Q != "string")
            throw new Error(`schema ${re} must be string`);
        }
        return X = (0, d.normalizeId)(X || Q), this._checkUnique(X), this.schemas[X] = this._addSchema(F, U, X, H, !0), this;
      }
      // Add schema that will be used to validate other schemas
      // options in META_IGNORE_OPTIONS are alway set to false
      addMetaSchema(F, X, U = this.opts.validateSchema) {
        return this.addSchema(F, X, !0, U), this;
      }
      //  Validate schema against its meta-schema
      validateSchema(F, X) {
        if (typeof F == "boolean")
          return !0;
        let U;
        if (U = F.$schema, U !== void 0 && typeof U != "string")
          throw new Error("$schema must be a string");
        if (U = U || this.opts.defaultMeta || this.defaultMeta(), !U)
          return this.logger.warn("meta-schema not available"), this.errors = null, !0;
        const H = this.validate(U, F);
        if (!H && X) {
          const Q = "schema is invalid: " + this.errorsText();
          if (this.opts.validateSchema === "log")
            this.logger.error(Q);
          else
            throw new Error(Q);
        }
        return H;
      }
      // Get compiled schema by `key` or `ref`.
      // (`key` that was passed to `addSchema` or full schema reference - `schema.$id` or resolved id)
      getSchema(F) {
        let X;
        for (; typeof (X = R.call(this, F)) == "string"; )
          F = X;
        if (X === void 0) {
          const { schemaId: U } = this.opts, H = new l.SchemaEnv({ schema: {}, schemaId: U });
          if (X = l.resolveSchema.call(this, H, F), !X)
            return;
          this.refs[F] = X;
        }
        return X.validate || this._compileSchemaEnv(X);
      }
      // Remove cached schema(s).
      // If no parameter is passed all schemas but meta-schemas are removed.
      // If RegExp is passed all schemas with key/id matching pattern but meta-schemas are removed.
      // Even if schema is referenced by other schemas it still can be removed as other schemas have local references.
      removeSchema(F) {
        if (F instanceof RegExp)
          return this._removeAllSchemas(this.schemas, F), this._removeAllSchemas(this.refs, F), this;
        switch (typeof F) {
          case "undefined":
            return this._removeAllSchemas(this.schemas), this._removeAllSchemas(this.refs), this._cache.clear(), this;
          case "string": {
            const X = R.call(this, F);
            return typeof X == "object" && this._cache.delete(X.schema), delete this.schemas[F], delete this.refs[F], this;
          }
          case "object": {
            const X = F;
            this._cache.delete(X);
            let U = F[this.opts.schemaId];
            return U && (U = (0, d.normalizeId)(U), delete this.schemas[U], delete this.refs[U]), this;
          }
          default:
            throw new Error("ajv.removeSchema: invalid parameter");
        }
      }
      // add "vocabulary" - a collection of keywords
      addVocabulary(F) {
        for (const X of F)
          this.addKeyword(X);
        return this;
      }
      addKeyword(F, X) {
        let U;
        if (typeof F == "string")
          U = F, typeof X == "object" && (this.logger.warn("these parameters are deprecated, see docs for addKeyword"), X.keyword = U);
        else if (typeof F == "object" && X === void 0) {
          if (X = F, U = X.keyword, Array.isArray(U) && !U.length)
            throw new Error("addKeywords: keyword must be string or non-empty array");
        } else
          throw new Error("invalid addKeywords parameters");
        if (I.call(this, U, X), !X)
          return (0, m.eachItem)(U, (Q) => G.call(this, Q)), this;
        K.call(this, X);
        const H = {
          ...X,
          type: (0, p.getJSONTypes)(X.type),
          schemaType: (0, p.getJSONTypes)(X.schemaType)
        };
        return (0, m.eachItem)(U, H.type.length === 0 ? (Q) => G.call(this, Q, H) : (Q) => H.type.forEach((re) => G.call(this, Q, H, re))), this;
      }
      getKeyword(F) {
        const X = this.RULES.all[F];
        return typeof X == "object" ? X.definition : !!X;
      }
      // Remove keyword
      removeKeyword(F) {
        const { RULES: X } = this;
        delete X.keywords[F], delete X.all[F];
        for (const U of X.rules) {
          const H = U.rules.findIndex((Q) => Q.keyword === F);
          H >= 0 && U.rules.splice(H, 1);
        }
        return this;
      }
      // Add format
      addFormat(F, X) {
        return typeof X == "string" && (X = new RegExp(X)), this.formats[F] = X, this;
      }
      errorsText(F = this.errors, { separator: X = ", ", dataVar: U = "data" } = {}) {
        return !F || F.length === 0 ? "No errors" : F.map((H) => `${U}${H.instancePath} ${H.message}`).reduce((H, Q) => H + X + Q);
      }
      $dataMetaSchema(F, X) {
        const U = this.RULES.all;
        F = JSON.parse(JSON.stringify(F));
        for (const H of X) {
          const Q = H.split("/").slice(1);
          let re = F;
          for (const de of Q)
            re = re[de];
          for (const de in U) {
            const le = U[de];
            if (typeof le != "object")
              continue;
            const { $data: me } = le.definition, ve = re[de];
            me && ve && (re[de] = Z(ve));
          }
        }
        return F;
      }
      _removeAllSchemas(F, X) {
        for (const U in F) {
          const H = F[U];
          (!X || X.test(U)) && (typeof H == "string" ? delete F[U] : H && !H.meta && (this._cache.delete(H.schema), delete F[U]));
        }
      }
      _addSchema(F, X, U, H = this.opts.validateSchema, Q = this.opts.addUsedSchema) {
        let re;
        const { schemaId: de } = this.opts;
        if (typeof F == "object")
          re = F[de];
        else {
          if (this.opts.jtd)
            throw new Error("schema must be object");
          if (typeof F != "boolean")
            throw new Error("schema must be object or boolean");
        }
        let le = this._cache.get(F);
        if (le !== void 0)
          return le;
        U = (0, d.normalizeId)(re || U);
        const me = d.getSchemaRefs.call(this, F, U);
        return le = new l.SchemaEnv({ schema: F, schemaId: de, meta: X, baseId: U, localRefs: me }), this._cache.set(le.schema, le), Q && !U.startsWith("#") && (U && this._checkUnique(U), this.refs[U] = le), H && this.validateSchema(F, !0), le;
      }
      _checkUnique(F) {
        if (this.schemas[F] || this.refs[F])
          throw new Error(`schema with key or id "${F}" already exists`);
      }
      _compileSchemaEnv(F) {
        if (F.meta ? this._compileMetaSchema(F) : l.compileSchema.call(this, F), !F.validate)
          throw new Error("ajv implementation error");
        return F.validate;
      }
      _compileMetaSchema(F) {
        const X = this.opts;
        this.opts = this._metaOpts;
        try {
          l.compileSchema.call(this, F);
        } finally {
          this.opts = X;
        }
      }
    }
    O.ValidationError = r.default, O.MissingRefError = a.default, e.default = O;
    function N(V, F, X, U = "error") {
      for (const H in V) {
        const Q = H;
        Q in F && this.logger[U](`${X}: option ${H}. ${V[Q]}`);
      }
    }
    function R(V) {
      return V = (0, d.normalizeId)(V), this.schemas[V] || this.refs[V];
    }
    function j() {
      const V = this.opts.schemas;
      if (V)
        if (Array.isArray(V))
          this.addSchema(V);
        else
          for (const F in V)
            this.addSchema(V[F], F);
    }
    function D() {
      for (const V in this.opts.formats) {
        const F = this.opts.formats[V];
        F && this.addFormat(V, F);
      }
    }
    function $(V) {
      if (Array.isArray(V)) {
        this.addVocabulary(V);
        return;
      }
      this.logger.warn("keywords option as map is deprecated, pass array");
      for (const F in V) {
        const X = V[F];
        X.keyword || (X.keyword = F), this.addKeyword(X);
      }
    }
    function z() {
      const V = { ...this.opts };
      for (const F of w)
        delete V[F];
      return V;
    }
    const B = { log() {
    }, warn() {
    }, error() {
    } };
    function P(V) {
      if (V === !1)
        return B;
      if (V === void 0)
        return console;
      if (V.log && V.warn && V.error)
        return V;
      throw new Error("logger must implement log, warn and error methods");
    }
    const W = /^[a-z_$][a-z0-9_$:-]*$/i;
    function I(V, F) {
      const { RULES: X } = this;
      if ((0, m.eachItem)(V, (U) => {
        if (X.keywords[U])
          throw new Error(`Keyword ${U} is already defined`);
        if (!W.test(U))
          throw new Error(`Keyword ${U} has invalid name`);
      }), !!F && F.$data && !("code" in F || "validate" in F))
        throw new Error('$data keyword must have "code" or "validate" function');
    }
    function G(V, F, X) {
      var U;
      const H = F?.post;
      if (X && H)
        throw new Error('keyword with "post" flag cannot have "type"');
      const { RULES: Q } = this;
      let re = H ? Q.post : Q.rules.find(({ type: le }) => le === X);
      if (re || (re = { type: X, rules: [] }, Q.rules.push(re)), Q.keywords[V] = !0, !F)
        return;
      const de = {
        keyword: V,
        definition: {
          ...F,
          type: (0, p.getJSONTypes)(F.type),
          schemaType: (0, p.getJSONTypes)(F.schemaType)
        }
      };
      F.before ? L.call(this, re, de, F.before) : re.rules.push(de), Q.all[V] = de, (U = F.implements) === null || U === void 0 || U.forEach((le) => this.addKeyword(le));
    }
    function L(V, F, X) {
      const U = V.rules.findIndex((H) => H.keyword === X);
      U >= 0 ? V.rules.splice(U, 0, F) : (V.rules.push(F), this.logger.warn(`rule ${X} is not defined`));
    }
    function K(V) {
      let { metaSchema: F } = V;
      F !== void 0 && (V.$data && this.opts.$data && (F = Z(F)), V.validateSchema = this.compile(F, !0));
    }
    const q = {
      $ref: "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#"
    };
    function Z(V) {
      return { anyOf: [V, q] };
    }
  })(zT)), zT;
}
var Sk = {}, kk = {}, _k = {}, wL;
function pCe() {
  if (wL) return _k;
  wL = 1, Object.defineProperty(_k, "__esModule", { value: !0 });
  const e = {
    keyword: "id",
    code() {
      throw new Error('NOT SUPPORTED: keyword "id", use "$id" for schema ID');
    }
  };
  return _k.default = e, _k;
}
var Fc = {}, xL;
function mCe() {
  if (xL) return Fc;
  xL = 1, Object.defineProperty(Fc, "__esModule", { value: !0 }), Fc.callRef = Fc.getValidate = void 0;
  const e = vE(), t = Ks(), n = qt(), r = yd(), a = i4(), s = pn(), l = {
    keyword: "$ref",
    schemaType: "string",
    code(p) {
      const { gen: m, schema: h, it: v } = p, { baseId: y, schemaEnv: w, validateName: x, opts: b, self: k } = v, { root: C } = w;
      if ((h === "#" || h === "#/") && y === C.baseId)
        return O();
      const _ = a.resolveRef.call(k, C, y, h);
      if (_ === void 0)
        throw new e.default(v.opts.uriResolver, y, h);
      if (_ instanceof a.SchemaEnv)
        return N(_);
      return R(_);
      function O() {
        if (w === C)
          return d(p, x, w, w.$async);
        const j = m.scopeValue("root", { ref: C });
        return d(p, (0, n._)`${j}.validate`, C, C.$async);
      }
      function N(j) {
        const D = c(p, j);
        d(p, D, j, j.$async);
      }
      function R(j) {
        const D = m.scopeValue("schema", b.code.source === !0 ? { ref: j, code: (0, n.stringify)(j) } : { ref: j }), $ = m.name("valid"), z = p.subschema({
          schema: j,
          dataTypes: [],
          schemaPath: n.nil,
          topSchemaRef: D,
          errSchemaPath: h
        }, $);
        p.mergeEvaluated(z), p.ok($);
      }
    }
  };
  function c(p, m) {
    const { gen: h } = p;
    return m.validate ? h.scopeValue("validate", { ref: m.validate }) : (0, n._)`${h.scopeValue("wrapper", { ref: m })}.validate`;
  }
  Fc.getValidate = c;
  function d(p, m, h, v) {
    const { gen: y, it: w } = p, { allErrors: x, schemaEnv: b, opts: k } = w, C = k.passContext ? r.default.this : n.nil;
    v ? _() : O();
    function _() {
      if (!b.$async)
        throw new Error("async schema referenced by sync schema");
      const j = y.let("valid");
      y.try(() => {
        y.code((0, n._)`await ${(0, t.callValidateCode)(p, m, C)}`), R(m), x || y.assign(j, !0);
      }, (D) => {
        y.if((0, n._)`!(${D} instanceof ${w.ValidationError})`, () => y.throw(D)), N(D), x || y.assign(j, !1);
      }), p.ok(j);
    }
    function O() {
      p.result((0, t.callValidateCode)(p, m, C), () => R(m), () => N(m));
    }
    function N(j) {
      const D = (0, n._)`${j}.errors`;
      y.assign(r.default.vErrors, (0, n._)`${r.default.vErrors} === null ? ${D} : ${r.default.vErrors}.concat(${D})`), y.assign(r.default.errors, (0, n._)`${r.default.vErrors}.length`);
    }
    function R(j) {
      var D;
      if (!w.opts.unevaluated)
        return;
      const $ = (D = h?.validate) === null || D === void 0 ? void 0 : D.evaluated;
      if (w.props !== !0)
        if ($ && !$.dynamicProps)
          $.props !== void 0 && (w.props = s.mergeEvaluated.props(y, $.props, w.props));
        else {
          const z = y.var("props", (0, n._)`${j}.evaluated.props`);
          w.props = s.mergeEvaluated.props(y, z, w.props, n.Name);
        }
      if (w.items !== !0)
        if ($ && !$.dynamicItems)
          $.items !== void 0 && (w.items = s.mergeEvaluated.items(y, $.items, w.items));
        else {
          const z = y.var("items", (0, n._)`${j}.evaluated.items`);
          w.items = s.mergeEvaluated.items(y, z, w.items, n.Name);
        }
    }
  }
  return Fc.callRef = d, Fc.default = l, Fc;
}
var SL;
function hCe() {
  if (SL) return kk;
  SL = 1, Object.defineProperty(kk, "__esModule", { value: !0 });
  const e = pCe(), t = mCe(), n = [
    "$schema",
    "$id",
    "$defs",
    "$vocabulary",
    { keyword: "$comment" },
    "definitions",
    e.default,
    t.default
  ];
  return kk.default = n, kk;
}
var Ek = {}, Ck = {}, kL;
function gCe() {
  if (kL) return Ck;
  kL = 1, Object.defineProperty(Ck, "__esModule", { value: !0 });
  const e = qt(), t = e.operators, n = {
    maximum: { okStr: "<=", ok: t.LTE, fail: t.GT },
    minimum: { okStr: ">=", ok: t.GTE, fail: t.LT },
    exclusiveMaximum: { okStr: "<", ok: t.LT, fail: t.GTE },
    exclusiveMinimum: { okStr: ">", ok: t.GT, fail: t.LTE }
  }, r = {
    message: ({ keyword: s, schemaCode: l }) => (0, e.str)`must be ${n[s].okStr} ${l}`,
    params: ({ keyword: s, schemaCode: l }) => (0, e._)`{comparison: ${n[s].okStr}, limit: ${l}}`
  }, a = {
    keyword: Object.keys(n),
    type: "number",
    schemaType: "number",
    $data: !0,
    error: r,
    code(s) {
      const { keyword: l, data: c, schemaCode: d } = s;
      s.fail$data((0, e._)`${c} ${n[l].fail} ${d} || isNaN(${c})`);
    }
  };
  return Ck.default = a, Ck;
}
var Ok = {}, _L;
function vCe() {
  if (_L) return Ok;
  _L = 1, Object.defineProperty(Ok, "__esModule", { value: !0 });
  const e = qt(), t = {
    keyword: "multipleOf",
    type: "number",
    schemaType: "number",
    $data: !0,
    error: {
      message: ({ schemaCode: n }) => (0, e.str)`must be multiple of ${n}`,
      params: ({ schemaCode: n }) => (0, e._)`{multipleOf: ${n}}`
    },
    code(n) {
      const { gen: r, data: a, schemaCode: s, it: l } = n, c = l.opts.multipleOfPrecision, d = r.let("res"), p = c ? (0, e._)`Math.abs(Math.round(${d}) - ${d}) > 1e-${c}` : (0, e._)`${d} !== parseInt(${d})`;
      n.fail$data((0, e._)`(${s} === 0 || (${d} = ${a}/${s}, ${p}))`);
    }
  };
  return Ok.default = t, Ok;
}
var Mk = {}, Nk = {}, EL;
function yCe() {
  if (EL) return Nk;
  EL = 1, Object.defineProperty(Nk, "__esModule", { value: !0 });
  function e(t) {
    const n = t.length;
    let r = 0, a = 0, s;
    for (; a < n; )
      r++, s = t.charCodeAt(a++), s >= 55296 && s <= 56319 && a < n && (s = t.charCodeAt(a), (s & 64512) === 56320 && a++);
    return r;
  }
  return Nk.default = e, e.code = 'require("ajv/dist/runtime/ucs2length").default', Nk;
}
var CL;
function bCe() {
  if (CL) return Mk;
  CL = 1, Object.defineProperty(Mk, "__esModule", { value: !0 });
  const e = qt(), t = pn(), n = yCe(), r = {
    keyword: ["maxLength", "minLength"],
    type: "string",
    schemaType: "number",
    $data: !0,
    error: {
      message({ keyword: a, schemaCode: s }) {
        const l = a === "maxLength" ? "more" : "fewer";
        return (0, e.str)`must NOT have ${l} than ${s} characters`;
      },
      params: ({ schemaCode: a }) => (0, e._)`{limit: ${a}}`
    },
    code(a) {
      const { keyword: s, data: l, schemaCode: c, it: d } = a, p = s === "maxLength" ? e.operators.GT : e.operators.LT, m = d.opts.unicode === !1 ? (0, e._)`${l}.length` : (0, e._)`${(0, t.useFunc)(a.gen, n.default)}(${l})`;
      a.fail$data((0, e._)`${m} ${p} ${c}`);
    }
  };
  return Mk.default = r, Mk;
}
var Rk = {}, OL;
function wCe() {
  if (OL) return Rk;
  OL = 1, Object.defineProperty(Rk, "__esModule", { value: !0 });
  const e = Ks(), t = qt(), n = {
    keyword: "pattern",
    type: "string",
    schemaType: "string",
    $data: !0,
    error: {
      message: ({ schemaCode: r }) => (0, t.str)`must match pattern "${r}"`,
      params: ({ schemaCode: r }) => (0, t._)`{pattern: ${r}}`
    },
    code(r) {
      const { data: a, $data: s, schema: l, schemaCode: c, it: d } = r, p = d.opts.unicodeRegExp ? "u" : "", m = s ? (0, t._)`(new RegExp(${c}, ${p}))` : (0, e.usePattern)(r, l);
      r.fail$data((0, t._)`!${m}.test(${a})`);
    }
  };
  return Rk.default = n, Rk;
}
var Ak = {}, ML;
function xCe() {
  if (ML) return Ak;
  ML = 1, Object.defineProperty(Ak, "__esModule", { value: !0 });
  const e = qt(), t = {
    keyword: ["maxProperties", "minProperties"],
    type: "object",
    schemaType: "number",
    $data: !0,
    error: {
      message({ keyword: n, schemaCode: r }) {
        const a = n === "maxProperties" ? "more" : "fewer";
        return (0, e.str)`must NOT have ${a} than ${r} properties`;
      },
      params: ({ schemaCode: n }) => (0, e._)`{limit: ${n}}`
    },
    code(n) {
      const { keyword: r, data: a, schemaCode: s } = n, l = r === "maxProperties" ? e.operators.GT : e.operators.LT;
      n.fail$data((0, e._)`Object.keys(${a}).length ${l} ${s}`);
    }
  };
  return Ak.default = t, Ak;
}
var jk = {}, NL;
function SCe() {
  if (NL) return jk;
  NL = 1, Object.defineProperty(jk, "__esModule", { value: !0 });
  const e = Ks(), t = qt(), n = pn(), r = {
    keyword: "required",
    type: "object",
    schemaType: "array",
    $data: !0,
    error: {
      message: ({ params: { missingProperty: a } }) => (0, t.str)`must have required property '${a}'`,
      params: ({ params: { missingProperty: a } }) => (0, t._)`{missingProperty: ${a}}`
    },
    code(a) {
      const { gen: s, schema: l, schemaCode: c, data: d, $data: p, it: m } = a, { opts: h } = m;
      if (!p && l.length === 0)
        return;
      const v = l.length >= h.loopRequired;
      if (m.allErrors ? y() : w(), h.strictRequired) {
        const k = a.parentSchema.properties, { definedProperties: C } = a.it;
        for (const _ of l)
          if (k?.[_] === void 0 && !C.has(_)) {
            const O = m.schemaEnv.baseId + m.errSchemaPath, N = `required property "${_}" is not defined at "${O}" (strictRequired)`;
            (0, n.checkStrictMode)(m, N, m.opts.strictRequired);
          }
      }
      function y() {
        if (v || p)
          a.block$data(t.nil, x);
        else
          for (const k of l)
            (0, e.checkReportMissingProp)(a, k);
      }
      function w() {
        const k = s.let("missing");
        if (v || p) {
          const C = s.let("valid", !0);
          a.block$data(C, () => b(k, C)), a.ok(C);
        } else
          s.if((0, e.checkMissingProp)(a, l, k)), (0, e.reportMissingProp)(a, k), s.else();
      }
      function x() {
        s.forOf("prop", c, (k) => {
          a.setParams({ missingProperty: k }), s.if((0, e.noPropertyInData)(s, d, k, h.ownProperties), () => a.error());
        });
      }
      function b(k, C) {
        a.setParams({ missingProperty: k }), s.forOf(k, c, () => {
          s.assign(C, (0, e.propertyInData)(s, d, k, h.ownProperties)), s.if((0, t.not)(C), () => {
            a.error(), s.break();
          });
        }, t.nil);
      }
    }
  };
  return jk.default = r, jk;
}
var Pk = {}, RL;
function kCe() {
  if (RL) return Pk;
  RL = 1, Object.defineProperty(Pk, "__esModule", { value: !0 });
  const e = qt(), t = {
    keyword: ["maxItems", "minItems"],
    type: "array",
    schemaType: "number",
    $data: !0,
    error: {
      message({ keyword: n, schemaCode: r }) {
        const a = n === "maxItems" ? "more" : "fewer";
        return (0, e.str)`must NOT have ${a} than ${r} items`;
      },
      params: ({ schemaCode: n }) => (0, e._)`{limit: ${n}}`
    },
    code(n) {
      const { keyword: r, data: a, schemaCode: s } = n, l = r === "maxItems" ? e.operators.GT : e.operators.LT;
      n.fail$data((0, e._)`${a}.length ${l} ${s}`);
    }
  };
  return Pk.default = t, Pk;
}
var Dk = {}, $k = {}, AL;
function s4() {
  if (AL) return $k;
  AL = 1, Object.defineProperty($k, "__esModule", { value: !0 });
  const e = ZH();
  return e.code = 'require("ajv/dist/runtime/equal").default', $k.default = e, $k;
}
var jL;
function _Ce() {
  if (jL) return Dk;
  jL = 1, Object.defineProperty(Dk, "__esModule", { value: !0 });
  const e = D_(), t = qt(), n = pn(), r = s4(), a = {
    keyword: "uniqueItems",
    type: "array",
    schemaType: "boolean",
    $data: !0,
    error: {
      message: ({ params: { i: s, j: l } }) => (0, t.str)`must NOT have duplicate items (items ## ${l} and ${s} are identical)`,
      params: ({ params: { i: s, j: l } }) => (0, t._)`{i: ${s}, j: ${l}}`
    },
    code(s) {
      const { gen: l, data: c, $data: d, schema: p, parentSchema: m, schemaCode: h, it: v } = s;
      if (!d && !p)
        return;
      const y = l.let("valid"), w = m.items ? (0, e.getSchemaTypes)(m.items) : [];
      s.block$data(y, x, (0, t._)`${h} === false`), s.ok(y);
      function x() {
        const _ = l.let("i", (0, t._)`${c}.length`), O = l.let("j");
        s.setParams({ i: _, j: O }), l.assign(y, !0), l.if((0, t._)`${_} > 1`, () => (b() ? k : C)(_, O));
      }
      function b() {
        return w.length > 0 && !w.some((_) => _ === "object" || _ === "array");
      }
      function k(_, O) {
        const N = l.name("item"), R = (0, e.checkDataTypes)(w, N, v.opts.strictNumbers, e.DataType.Wrong), j = l.const("indices", (0, t._)`{}`);
        l.for((0, t._)`;${_}--;`, () => {
          l.let(N, (0, t._)`${c}[${_}]`), l.if(R, (0, t._)`continue`), w.length > 1 && l.if((0, t._)`typeof ${N} == "string"`, (0, t._)`${N} += "_"`), l.if((0, t._)`typeof ${j}[${N}] == "number"`, () => {
            l.assign(O, (0, t._)`${j}[${N}]`), s.error(), l.assign(y, !1).break();
          }).code((0, t._)`${j}[${N}] = ${_}`);
        });
      }
      function C(_, O) {
        const N = (0, n.useFunc)(l, r.default), R = l.name("outer");
        l.label(R).for((0, t._)`;${_}--;`, () => l.for((0, t._)`${O} = ${_}; ${O}--;`, () => l.if((0, t._)`${N}(${c}[${_}], ${c}[${O}])`, () => {
          s.error(), l.assign(y, !1).break(R);
        })));
      }
    }
  };
  return Dk.default = a, Dk;
}
var Tk = {}, PL;
function ECe() {
  if (PL) return Tk;
  PL = 1, Object.defineProperty(Tk, "__esModule", { value: !0 });
  const e = qt(), t = pn(), n = s4(), r = {
    keyword: "const",
    $data: !0,
    error: {
      message: "must be equal to constant",
      params: ({ schemaCode: a }) => (0, e._)`{allowedValue: ${a}}`
    },
    code(a) {
      const { gen: s, data: l, $data: c, schemaCode: d, schema: p } = a;
      c || p && typeof p == "object" ? a.fail$data((0, e._)`!${(0, t.useFunc)(s, n.default)}(${l}, ${d})`) : a.fail((0, e._)`${p} !== ${l}`);
    }
  };
  return Tk.default = r, Tk;
}
var Lk = {}, DL;
function CCe() {
  if (DL) return Lk;
  DL = 1, Object.defineProperty(Lk, "__esModule", { value: !0 });
  const e = qt(), t = pn(), n = s4(), r = {
    keyword: "enum",
    schemaType: "array",
    $data: !0,
    error: {
      message: "must be equal to one of the allowed values",
      params: ({ schemaCode: a }) => (0, e._)`{allowedValues: ${a}}`
    },
    code(a) {
      const { gen: s, data: l, $data: c, schema: d, schemaCode: p, it: m } = a;
      if (!c && d.length === 0)
        throw new Error("enum must have non-empty array");
      const h = d.length >= m.opts.loopEnum;
      let v;
      const y = () => v ?? (v = (0, t.useFunc)(s, n.default));
      let w;
      if (h || c)
        w = s.let("valid"), a.block$data(w, x);
      else {
        if (!Array.isArray(d))
          throw new Error("ajv implementation error");
        const k = s.const("vSchema", p);
        w = (0, e.or)(...d.map((C, _) => b(k, _)));
      }
      a.pass(w);
      function x() {
        s.assign(w, !1), s.forOf("v", p, (k) => s.if((0, e._)`${y()}(${l}, ${k})`, () => s.assign(w, !0).break()));
      }
      function b(k, C) {
        const _ = d[C];
        return typeof _ == "object" && _ !== null ? (0, e._)`${y()}(${l}, ${k}[${C}])` : (0, e._)`${l} === ${_}`;
      }
    }
  };
  return Lk.default = r, Lk;
}
var $L;
function OCe() {
  if ($L) return Ek;
  $L = 1, Object.defineProperty(Ek, "__esModule", { value: !0 });
  const e = gCe(), t = vCe(), n = bCe(), r = wCe(), a = xCe(), s = SCe(), l = kCe(), c = _Ce(), d = ECe(), p = CCe(), m = [
    // number
    e.default,
    t.default,
    // string
    n.default,
    r.default,
    // object
    a.default,
    s.default,
    // array
    l.default,
    c.default,
    // any
    { keyword: "type", schemaType: ["string", "array"] },
    { keyword: "nullable", schemaType: "boolean" },
    d.default,
    p.default
  ];
  return Ek.default = m, Ek;
}
var Ik = {}, Qm = {}, TL;
function eq() {
  if (TL) return Qm;
  TL = 1, Object.defineProperty(Qm, "__esModule", { value: !0 }), Qm.validateAdditionalItems = void 0;
  const e = qt(), t = pn(), n = {
    keyword: "additionalItems",
    type: "array",
    schemaType: ["boolean", "object"],
    before: "uniqueItems",
    error: {
      message: ({ params: { len: a } }) => (0, e.str)`must NOT have more than ${a} items`,
      params: ({ params: { len: a } }) => (0, e._)`{limit: ${a}}`
    },
    code(a) {
      const { parentSchema: s, it: l } = a, { items: c } = s;
      if (!Array.isArray(c)) {
        (0, t.checkStrictMode)(l, '"additionalItems" is ignored when "items" is not an array of schemas');
        return;
      }
      r(a, c);
    }
  };
  function r(a, s) {
    const { gen: l, schema: c, data: d, keyword: p, it: m } = a;
    m.items = !0;
    const h = l.const("len", (0, e._)`${d}.length`);
    if (c === !1)
      a.setParams({ len: s.length }), a.pass((0, e._)`${h} <= ${s.length}`);
    else if (typeof c == "object" && !(0, t.alwaysValidSchema)(m, c)) {
      const y = l.var("valid", (0, e._)`${h} <= ${s.length}`);
      l.if((0, e.not)(y), () => v(y)), a.ok(y);
    }
    function v(y) {
      l.forRange("i", s.length, h, (w) => {
        a.subschema({ keyword: p, dataProp: w, dataPropType: t.Type.Num }, y), m.allErrors || l.if((0, e.not)(y), () => l.break());
      });
    }
  }
  return Qm.validateAdditionalItems = r, Qm.default = n, Qm;
}
var zk = {}, Jm = {}, LL;
function tq() {
  if (LL) return Jm;
  LL = 1, Object.defineProperty(Jm, "__esModule", { value: !0 }), Jm.validateTuple = void 0;
  const e = qt(), t = pn(), n = Ks(), r = {
    keyword: "items",
    type: "array",
    schemaType: ["object", "array", "boolean"],
    before: "uniqueItems",
    code(s) {
      const { schema: l, it: c } = s;
      if (Array.isArray(l))
        return a(s, "additionalItems", l);
      c.items = !0, !(0, t.alwaysValidSchema)(c, l) && s.ok((0, n.validateArray)(s));
    }
  };
  function a(s, l, c = s.schema) {
    const { gen: d, parentSchema: p, data: m, keyword: h, it: v } = s;
    x(p), v.opts.unevaluated && c.length && v.items !== !0 && (v.items = t.mergeEvaluated.items(d, c.length, v.items));
    const y = d.name("valid"), w = d.const("len", (0, e._)`${m}.length`);
    c.forEach((b, k) => {
      (0, t.alwaysValidSchema)(v, b) || (d.if((0, e._)`${w} > ${k}`, () => s.subschema({
        keyword: h,
        schemaProp: k,
        dataProp: k
      }, y)), s.ok(y));
    });
    function x(b) {
      const { opts: k, errSchemaPath: C } = v, _ = c.length, O = _ === b.minItems && (_ === b.maxItems || b[l] === !1);
      if (k.strictTuples && !O) {
        const N = `"${h}" is ${_}-tuple, but minItems or maxItems/${l} are not specified or different at path "${C}"`;
        (0, t.checkStrictMode)(v, N, k.strictTuples);
      }
    }
  }
  return Jm.validateTuple = a, Jm.default = r, Jm;
}
var IL;
function MCe() {
  if (IL) return zk;
  IL = 1, Object.defineProperty(zk, "__esModule", { value: !0 });
  const e = tq(), t = {
    keyword: "prefixItems",
    type: "array",
    schemaType: ["array"],
    before: "uniqueItems",
    code: (n) => (0, e.validateTuple)(n, "items")
  };
  return zk.default = t, zk;
}
var Fk = {}, zL;
function NCe() {
  if (zL) return Fk;
  zL = 1, Object.defineProperty(Fk, "__esModule", { value: !0 });
  const e = qt(), t = pn(), n = Ks(), r = eq(), a = {
    keyword: "items",
    type: "array",
    schemaType: ["object", "boolean"],
    before: "uniqueItems",
    error: {
      message: ({ params: { len: s } }) => (0, e.str)`must NOT have more than ${s} items`,
      params: ({ params: { len: s } }) => (0, e._)`{limit: ${s}}`
    },
    code(s) {
      const { schema: l, parentSchema: c, it: d } = s, { prefixItems: p } = c;
      d.items = !0, !(0, t.alwaysValidSchema)(d, l) && (p ? (0, r.validateAdditionalItems)(s, p) : s.ok((0, n.validateArray)(s)));
    }
  };
  return Fk.default = a, Fk;
}
var Bk = {}, FL;
function RCe() {
  if (FL) return Bk;
  FL = 1, Object.defineProperty(Bk, "__esModule", { value: !0 });
  const e = qt(), t = pn(), n = {
    keyword: "contains",
    type: "array",
    schemaType: ["object", "boolean"],
    before: "uniqueItems",
    trackErrors: !0,
    error: {
      message: ({ params: { min: r, max: a } }) => a === void 0 ? (0, e.str)`must contain at least ${r} valid item(s)` : (0, e.str)`must contain at least ${r} and no more than ${a} valid item(s)`,
      params: ({ params: { min: r, max: a } }) => a === void 0 ? (0, e._)`{minContains: ${r}}` : (0, e._)`{minContains: ${r}, maxContains: ${a}}`
    },
    code(r) {
      const { gen: a, schema: s, parentSchema: l, data: c, it: d } = r;
      let p, m;
      const { minContains: h, maxContains: v } = l;
      d.opts.next ? (p = h === void 0 ? 1 : h, m = v) : p = 1;
      const y = a.const("len", (0, e._)`${c}.length`);
      if (r.setParams({ min: p, max: m }), m === void 0 && p === 0) {
        (0, t.checkStrictMode)(d, '"minContains" == 0 without "maxContains": "contains" keyword ignored');
        return;
      }
      if (m !== void 0 && p > m) {
        (0, t.checkStrictMode)(d, '"minContains" > "maxContains" is always invalid'), r.fail();
        return;
      }
      if ((0, t.alwaysValidSchema)(d, s)) {
        let C = (0, e._)`${y} >= ${p}`;
        m !== void 0 && (C = (0, e._)`${C} && ${y} <= ${m}`), r.pass(C);
        return;
      }
      d.items = !0;
      const w = a.name("valid");
      m === void 0 && p === 1 ? b(w, () => a.if(w, () => a.break())) : p === 0 ? (a.let(w, !0), m !== void 0 && a.if((0, e._)`${c}.length > 0`, x)) : (a.let(w, !1), x()), r.result(w, () => r.reset());
      function x() {
        const C = a.name("_valid"), _ = a.let("count", 0);
        b(C, () => a.if(C, () => k(_)));
      }
      function b(C, _) {
        a.forRange("i", 0, y, (O) => {
          r.subschema({
            keyword: "contains",
            dataProp: O,
            dataPropType: t.Type.Num,
            compositeRule: !0
          }, C), _();
        });
      }
      function k(C) {
        a.code((0, e._)`${C}++`), m === void 0 ? a.if((0, e._)`${C} >= ${p}`, () => a.assign(w, !0).break()) : (a.if((0, e._)`${C} > ${m}`, () => a.assign(w, !1).break()), p === 1 ? a.assign(w, !0) : a.if((0, e._)`${C} >= ${p}`, () => a.assign(w, !0)));
      }
    }
  };
  return Bk.default = n, Bk;
}
var BL = {}, UL;
function ACe() {
  return UL || (UL = 1, (function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.validateSchemaDeps = e.validatePropertyDeps = e.error = void 0;
    const t = qt(), n = pn(), r = Ks();
    e.error = {
      message: ({ params: { property: d, depsCount: p, deps: m } }) => {
        const h = p === 1 ? "property" : "properties";
        return (0, t.str)`must have ${h} ${m} when property ${d} is present`;
      },
      params: ({ params: { property: d, depsCount: p, deps: m, missingProperty: h } }) => (0, t._)`{property: ${d},
    missingProperty: ${h},
    depsCount: ${p},
    deps: ${m}}`
      // TODO change to reference
    };
    const a = {
      keyword: "dependencies",
      type: "object",
      schemaType: "object",
      error: e.error,
      code(d) {
        const [p, m] = s(d);
        l(d, p), c(d, m);
      }
    };
    function s({ schema: d }) {
      const p = {}, m = {};
      for (const h in d) {
        if (h === "__proto__")
          continue;
        const v = Array.isArray(d[h]) ? p : m;
        v[h] = d[h];
      }
      return [p, m];
    }
    function l(d, p = d.schema) {
      const { gen: m, data: h, it: v } = d;
      if (Object.keys(p).length === 0)
        return;
      const y = m.let("missing");
      for (const w in p) {
        const x = p[w];
        if (x.length === 0)
          continue;
        const b = (0, r.propertyInData)(m, h, w, v.opts.ownProperties);
        d.setParams({
          property: w,
          depsCount: x.length,
          deps: x.join(", ")
        }), v.allErrors ? m.if(b, () => {
          for (const k of x)
            (0, r.checkReportMissingProp)(d, k);
        }) : (m.if((0, t._)`${b} && (${(0, r.checkMissingProp)(d, x, y)})`), (0, r.reportMissingProp)(d, y), m.else());
      }
    }
    e.validatePropertyDeps = l;
    function c(d, p = d.schema) {
      const { gen: m, data: h, keyword: v, it: y } = d, w = m.name("valid");
      for (const x in p)
        (0, n.alwaysValidSchema)(y, p[x]) || (m.if(
          (0, r.propertyInData)(m, h, x, y.opts.ownProperties),
          () => {
            const b = d.subschema({ keyword: v, schemaProp: x }, w);
            d.mergeValidEvaluated(b, w);
          },
          () => m.var(w, !0)
          // TODO var
        ), d.ok(w));
    }
    e.validateSchemaDeps = c, e.default = a;
  })(BL)), BL;
}
var Uk = {}, VL;
function jCe() {
  if (VL) return Uk;
  VL = 1, Object.defineProperty(Uk, "__esModule", { value: !0 });
  const e = qt(), t = pn(), n = {
    keyword: "propertyNames",
    type: "object",
    schemaType: ["object", "boolean"],
    error: {
      message: "property name must be valid",
      params: ({ params: r }) => (0, e._)`{propertyName: ${r.propertyName}}`
    },
    code(r) {
      const { gen: a, schema: s, data: l, it: c } = r;
      if ((0, t.alwaysValidSchema)(c, s))
        return;
      const d = a.name("valid");
      a.forIn("key", l, (p) => {
        r.setParams({ propertyName: p }), r.subschema({
          keyword: "propertyNames",
          data: p,
          dataTypes: ["string"],
          propertyName: p,
          compositeRule: !0
        }, d), a.if((0, e.not)(d), () => {
          r.error(!0), c.allErrors || a.break();
        });
      }), r.ok(d);
    }
  };
  return Uk.default = n, Uk;
}
var Vk = {}, HL;
function nq() {
  if (HL) return Vk;
  HL = 1, Object.defineProperty(Vk, "__esModule", { value: !0 });
  const e = Ks(), t = qt(), n = yd(), r = pn(), a = {
    keyword: "additionalProperties",
    type: ["object"],
    schemaType: ["boolean", "object"],
    allowUndefined: !0,
    trackErrors: !0,
    error: {
      message: "must NOT have additional properties",
      params: ({ params: s }) => (0, t._)`{additionalProperty: ${s.additionalProperty}}`
    },
    code(s) {
      const { gen: l, schema: c, parentSchema: d, data: p, errsCount: m, it: h } = s;
      if (!m)
        throw new Error("ajv implementation error");
      const { allErrors: v, opts: y } = h;
      if (h.props = !0, y.removeAdditional !== "all" && (0, r.alwaysValidSchema)(h, c))
        return;
      const w = (0, e.allSchemaProperties)(d.properties), x = (0, e.allSchemaProperties)(d.patternProperties);
      b(), s.ok((0, t._)`${m} === ${n.default.errors}`);
      function b() {
        l.forIn("key", p, (N) => {
          !w.length && !x.length ? _(N) : l.if(k(N), () => _(N));
        });
      }
      function k(N) {
        let R;
        if (w.length > 8) {
          const j = (0, r.schemaRefOrVal)(h, d.properties, "properties");
          R = (0, e.isOwnProperty)(l, j, N);
        } else w.length ? R = (0, t.or)(...w.map((j) => (0, t._)`${N} === ${j}`)) : R = t.nil;
        return x.length && (R = (0, t.or)(R, ...x.map((j) => (0, t._)`${(0, e.usePattern)(s, j)}.test(${N})`))), (0, t.not)(R);
      }
      function C(N) {
        l.code((0, t._)`delete ${p}[${N}]`);
      }
      function _(N) {
        if (y.removeAdditional === "all" || y.removeAdditional && c === !1) {
          C(N);
          return;
        }
        if (c === !1) {
          s.setParams({ additionalProperty: N }), s.error(), v || l.break();
          return;
        }
        if (typeof c == "object" && !(0, r.alwaysValidSchema)(h, c)) {
          const R = l.name("valid");
          y.removeAdditional === "failing" ? (O(N, R, !1), l.if((0, t.not)(R), () => {
            s.reset(), C(N);
          })) : (O(N, R), v || l.if((0, t.not)(R), () => l.break()));
        }
      }
      function O(N, R, j) {
        const D = {
          keyword: "additionalProperties",
          dataProp: N,
          dataPropType: r.Type.Str
        };
        j === !1 && Object.assign(D, {
          compositeRule: !0,
          createErrors: !1,
          allErrors: !1
        }), s.subschema(D, R);
      }
    }
  };
  return Vk.default = a, Vk;
}
var Hk = {}, qL;
function PCe() {
  if (qL) return Hk;
  qL = 1, Object.defineProperty(Hk, "__esModule", { value: !0 });
  const e = gE(), t = Ks(), n = pn(), r = nq(), a = {
    keyword: "properties",
    type: "object",
    schemaType: "object",
    code(s) {
      const { gen: l, schema: c, parentSchema: d, data: p, it: m } = s;
      m.opts.removeAdditional === "all" && d.additionalProperties === void 0 && r.default.code(new e.KeywordCxt(m, r.default, "additionalProperties"));
      const h = (0, t.allSchemaProperties)(c);
      for (const b of h)
        m.definedProperties.add(b);
      m.opts.unevaluated && h.length && m.props !== !0 && (m.props = n.mergeEvaluated.props(l, (0, n.toHash)(h), m.props));
      const v = h.filter((b) => !(0, n.alwaysValidSchema)(m, c[b]));
      if (v.length === 0)
        return;
      const y = l.name("valid");
      for (const b of v)
        w(b) ? x(b) : (l.if((0, t.propertyInData)(l, p, b, m.opts.ownProperties)), x(b), m.allErrors || l.else().var(y, !0), l.endIf()), s.it.definedProperties.add(b), s.ok(y);
      function w(b) {
        return m.opts.useDefaults && !m.compositeRule && c[b].default !== void 0;
      }
      function x(b) {
        s.subschema({
          keyword: "properties",
          schemaProp: b,
          dataProp: b
        }, y);
      }
    }
  };
  return Hk.default = a, Hk;
}
var qk = {}, WL;
function DCe() {
  if (WL) return qk;
  WL = 1, Object.defineProperty(qk, "__esModule", { value: !0 });
  const e = Ks(), t = qt(), n = pn(), r = pn(), a = {
    keyword: "patternProperties",
    type: "object",
    schemaType: "object",
    code(s) {
      const { gen: l, schema: c, data: d, parentSchema: p, it: m } = s, { opts: h } = m, v = (0, e.allSchemaProperties)(c), y = v.filter((O) => (0, n.alwaysValidSchema)(m, c[O]));
      if (v.length === 0 || y.length === v.length && (!m.opts.unevaluated || m.props === !0))
        return;
      const w = h.strictSchema && !h.allowMatchingProperties && p.properties, x = l.name("valid");
      m.props !== !0 && !(m.props instanceof t.Name) && (m.props = (0, r.evaluatedPropsToName)(l, m.props));
      const { props: b } = m;
      k();
      function k() {
        for (const O of v)
          w && C(O), m.allErrors ? _(O) : (l.var(x, !0), _(O), l.if(x));
      }
      function C(O) {
        for (const N in w)
          new RegExp(O).test(N) && (0, n.checkStrictMode)(m, `property ${N} matches pattern ${O} (use allowMatchingProperties)`);
      }
      function _(O) {
        l.forIn("key", d, (N) => {
          l.if((0, t._)`${(0, e.usePattern)(s, O)}.test(${N})`, () => {
            const R = y.includes(O);
            R || s.subschema({
              keyword: "patternProperties",
              schemaProp: O,
              dataProp: N,
              dataPropType: r.Type.Str
            }, x), m.opts.unevaluated && b !== !0 ? l.assign((0, t._)`${b}[${N}]`, !0) : !R && !m.allErrors && l.if((0, t.not)(x), () => l.break());
          });
        });
      }
    }
  };
  return qk.default = a, qk;
}
var Wk = {}, GL;
function $Ce() {
  if (GL) return Wk;
  GL = 1, Object.defineProperty(Wk, "__esModule", { value: !0 });
  const e = pn(), t = {
    keyword: "not",
    schemaType: ["object", "boolean"],
    trackErrors: !0,
    code(n) {
      const { gen: r, schema: a, it: s } = n;
      if ((0, e.alwaysValidSchema)(s, a)) {
        n.fail();
        return;
      }
      const l = r.name("valid");
      n.subschema({
        keyword: "not",
        compositeRule: !0,
        createErrors: !1,
        allErrors: !1
      }, l), n.failResult(l, () => n.reset(), () => n.error());
    },
    error: { message: "must NOT be valid" }
  };
  return Wk.default = t, Wk;
}
var Gk = {}, KL;
function TCe() {
  if (KL) return Gk;
  KL = 1, Object.defineProperty(Gk, "__esModule", { value: !0 });
  const e = {
    keyword: "anyOf",
    schemaType: "array",
    trackErrors: !0,
    code: Ks().validateUnion,
    error: { message: "must match a schema in anyOf" }
  };
  return Gk.default = e, Gk;
}
var Kk = {}, XL;
function LCe() {
  if (XL) return Kk;
  XL = 1, Object.defineProperty(Kk, "__esModule", { value: !0 });
  const e = qt(), t = pn(), n = {
    keyword: "oneOf",
    schemaType: "array",
    trackErrors: !0,
    error: {
      message: "must match exactly one schema in oneOf",
      params: ({ params: r }) => (0, e._)`{passingSchemas: ${r.passing}}`
    },
    code(r) {
      const { gen: a, schema: s, parentSchema: l, it: c } = r;
      if (!Array.isArray(s))
        throw new Error("ajv implementation error");
      if (c.opts.discriminator && l.discriminator)
        return;
      const d = s, p = a.let("valid", !1), m = a.let("passing", null), h = a.name("_valid");
      r.setParams({ passing: m }), a.block(v), r.result(p, () => r.reset(), () => r.error(!0));
      function v() {
        d.forEach((y, w) => {
          let x;
          (0, t.alwaysValidSchema)(c, y) ? a.var(h, !0) : x = r.subschema({
            keyword: "oneOf",
            schemaProp: w,
            compositeRule: !0
          }, h), w > 0 && a.if((0, e._)`${h} && ${p}`).assign(p, !1).assign(m, (0, e._)`[${m}, ${w}]`).else(), a.if(h, () => {
            a.assign(p, !0), a.assign(m, w), x && r.mergeEvaluated(x, e.Name);
          });
        });
      }
    }
  };
  return Kk.default = n, Kk;
}
var Xk = {}, YL;
function ICe() {
  if (YL) return Xk;
  YL = 1, Object.defineProperty(Xk, "__esModule", { value: !0 });
  const e = pn(), t = {
    keyword: "allOf",
    schemaType: "array",
    code(n) {
      const { gen: r, schema: a, it: s } = n;
      if (!Array.isArray(a))
        throw new Error("ajv implementation error");
      const l = r.name("valid");
      a.forEach((c, d) => {
        if ((0, e.alwaysValidSchema)(s, c))
          return;
        const p = n.subschema({ keyword: "allOf", schemaProp: d }, l);
        n.ok(l), n.mergeEvaluated(p);
      });
    }
  };
  return Xk.default = t, Xk;
}
var Yk = {}, QL;
function zCe() {
  if (QL) return Yk;
  QL = 1, Object.defineProperty(Yk, "__esModule", { value: !0 });
  const e = qt(), t = pn(), n = {
    keyword: "if",
    schemaType: ["object", "boolean"],
    trackErrors: !0,
    error: {
      message: ({ params: a }) => (0, e.str)`must match "${a.ifClause}" schema`,
      params: ({ params: a }) => (0, e._)`{failingKeyword: ${a.ifClause}}`
    },
    code(a) {
      const { gen: s, parentSchema: l, it: c } = a;
      l.then === void 0 && l.else === void 0 && (0, t.checkStrictMode)(c, '"if" without "then" and "else" is ignored');
      const d = r(c, "then"), p = r(c, "else");
      if (!d && !p)
        return;
      const m = s.let("valid", !0), h = s.name("_valid");
      if (v(), a.reset(), d && p) {
        const w = s.let("ifClause");
        a.setParams({ ifClause: w }), s.if(h, y("then", w), y("else", w));
      } else d ? s.if(h, y("then")) : s.if((0, e.not)(h), y("else"));
      a.pass(m, () => a.error(!0));
      function v() {
        const w = a.subschema({
          keyword: "if",
          compositeRule: !0,
          createErrors: !1,
          allErrors: !1
        }, h);
        a.mergeEvaluated(w);
      }
      function y(w, x) {
        return () => {
          const b = a.subschema({ keyword: w }, h);
          s.assign(m, h), a.mergeValidEvaluated(b, m), x ? s.assign(x, (0, e._)`${w}`) : a.setParams({ ifClause: w });
        };
      }
    }
  };
  function r(a, s) {
    const l = a.schema[s];
    return l !== void 0 && !(0, t.alwaysValidSchema)(a, l);
  }
  return Yk.default = n, Yk;
}
var Qk = {}, JL;
function FCe() {
  if (JL) return Qk;
  JL = 1, Object.defineProperty(Qk, "__esModule", { value: !0 });
  const e = pn(), t = {
    keyword: ["then", "else"],
    schemaType: ["object", "boolean"],
    code({ keyword: n, parentSchema: r, it: a }) {
      r.if === void 0 && (0, e.checkStrictMode)(a, `"${n}" without "if" is ignored`);
    }
  };
  return Qk.default = t, Qk;
}
var ZL;
function BCe() {
  if (ZL) return Ik;
  ZL = 1, Object.defineProperty(Ik, "__esModule", { value: !0 });
  const e = eq(), t = MCe(), n = tq(), r = NCe(), a = RCe(), s = ACe(), l = jCe(), c = nq(), d = PCe(), p = DCe(), m = $Ce(), h = TCe(), v = LCe(), y = ICe(), w = zCe(), x = FCe();
  function b(k = !1) {
    const C = [
      // any
      m.default,
      h.default,
      v.default,
      y.default,
      w.default,
      x.default,
      // object
      l.default,
      c.default,
      s.default,
      d.default,
      p.default
    ];
    return k ? C.push(t.default, r.default) : C.push(e.default, n.default), C.push(a.default), C;
  }
  return Ik.default = b, Ik;
}
var Jk = {}, Zk = {}, eI;
function UCe() {
  if (eI) return Zk;
  eI = 1, Object.defineProperty(Zk, "__esModule", { value: !0 });
  const e = qt(), t = {
    keyword: "format",
    type: ["number", "string"],
    schemaType: "string",
    $data: !0,
    error: {
      message: ({ schemaCode: n }) => (0, e.str)`must match format "${n}"`,
      params: ({ schemaCode: n }) => (0, e._)`{format: ${n}}`
    },
    code(n, r) {
      const { gen: a, data: s, $data: l, schema: c, schemaCode: d, it: p } = n, { opts: m, errSchemaPath: h, schemaEnv: v, self: y } = p;
      if (!m.validateFormats)
        return;
      l ? w() : x();
      function w() {
        const b = a.scopeValue("formats", {
          ref: y.formats,
          code: m.code.formats
        }), k = a.const("fDef", (0, e._)`${b}[${d}]`), C = a.let("fType"), _ = a.let("format");
        a.if((0, e._)`typeof ${k} == "object" && !(${k} instanceof RegExp)`, () => a.assign(C, (0, e._)`${k}.type || "string"`).assign(_, (0, e._)`${k}.validate`), () => a.assign(C, (0, e._)`"string"`).assign(_, k)), n.fail$data((0, e.or)(O(), N()));
        function O() {
          return m.strictSchema === !1 ? e.nil : (0, e._)`${d} && !${_}`;
        }
        function N() {
          const R = v.$async ? (0, e._)`(${k}.async ? await ${_}(${s}) : ${_}(${s}))` : (0, e._)`${_}(${s})`, j = (0, e._)`(typeof ${_} == "function" ? ${R} : ${_}.test(${s}))`;
          return (0, e._)`${_} && ${_} !== true && ${C} === ${r} && !${j}`;
        }
      }
      function x() {
        const b = y.formats[c];
        if (!b) {
          O();
          return;
        }
        if (b === !0)
          return;
        const [k, C, _] = N(b);
        k === r && n.pass(R());
        function O() {
          if (m.strictSchema === !1) {
            y.logger.warn(j());
            return;
          }
          throw new Error(j());
          function j() {
            return `unknown format "${c}" ignored in schema at path "${h}"`;
          }
        }
        function N(j) {
          const D = j instanceof RegExp ? (0, e.regexpCode)(j) : m.code.formats ? (0, e._)`${m.code.formats}${(0, e.getProperty)(c)}` : void 0, $ = a.scopeValue("formats", { key: c, ref: j, code: D });
          return typeof j == "object" && !(j instanceof RegExp) ? [j.type || "string", j.validate, (0, e._)`${$}.validate`] : ["string", j, $];
        }
        function R() {
          if (typeof b == "object" && !(b instanceof RegExp) && b.async) {
            if (!v.$async)
              throw new Error("async format in sync schema");
            return (0, e._)`await ${_}(${s})`;
          }
          return typeof C == "function" ? (0, e._)`${_}(${s})` : (0, e._)`${_}.test(${s})`;
        }
      }
    }
  };
  return Zk.default = t, Zk;
}
var tI;
function VCe() {
  if (tI) return Jk;
  tI = 1, Object.defineProperty(Jk, "__esModule", { value: !0 });
  const e = [UCe().default];
  return Jk.default = e, Jk;
}
var Zm = {}, nI;
function HCe() {
  return nI || (nI = 1, Object.defineProperty(Zm, "__esModule", { value: !0 }), Zm.contentVocabulary = Zm.metadataVocabulary = void 0, Zm.metadataVocabulary = [
    "title",
    "description",
    "default",
    "deprecated",
    "readOnly",
    "writeOnly",
    "examples"
  ], Zm.contentVocabulary = [
    "contentMediaType",
    "contentEncoding",
    "contentSchema"
  ]), Zm;
}
var rI;
function qCe() {
  if (rI) return Sk;
  rI = 1, Object.defineProperty(Sk, "__esModule", { value: !0 });
  const e = hCe(), t = OCe(), n = BCe(), r = VCe(), a = HCe(), s = [
    e.default,
    t.default,
    (0, n.default)(),
    r.default,
    a.metadataVocabulary,
    a.contentVocabulary
  ];
  return Sk.default = s, Sk;
}
var e0 = {}, yw = {}, oI;
function WCe() {
  if (oI) return yw;
  oI = 1, Object.defineProperty(yw, "__esModule", { value: !0 }), yw.DiscrError = void 0;
  var e;
  return (function(t) {
    t.Tag = "tag", t.Mapping = "mapping";
  })(e || (yw.DiscrError = e = {})), yw;
}
var aI;
function GCe() {
  if (aI) return e0;
  aI = 1, Object.defineProperty(e0, "__esModule", { value: !0 });
  const e = qt(), t = WCe(), n = i4(), r = vE(), a = pn(), s = {
    keyword: "discriminator",
    type: "object",
    schemaType: "object",
    error: {
      message: ({ params: { discrError: l, tagName: c } }) => l === t.DiscrError.Tag ? `tag "${c}" must be string` : `value of tag "${c}" must be in oneOf`,
      params: ({ params: { discrError: l, tag: c, tagName: d } }) => (0, e._)`{error: ${l}, tag: ${d}, tagValue: ${c}}`
    },
    code(l) {
      const { gen: c, data: d, schema: p, parentSchema: m, it: h } = l, { oneOf: v } = m;
      if (!h.opts.discriminator)
        throw new Error("discriminator: requires discriminator option");
      const y = p.propertyName;
      if (typeof y != "string")
        throw new Error("discriminator: requires propertyName");
      if (p.mapping)
        throw new Error("discriminator: mapping is not supported");
      if (!v)
        throw new Error("discriminator: requires oneOf keyword");
      const w = c.let("valid", !1), x = c.const("tag", (0, e._)`${d}${(0, e.getProperty)(y)}`);
      c.if((0, e._)`typeof ${x} == "string"`, () => b(), () => l.error(!1, { discrError: t.DiscrError.Tag, tag: x, tagName: y })), l.ok(w);
      function b() {
        const _ = C();
        c.if(!1);
        for (const O in _)
          c.elseIf((0, e._)`${x} === ${O}`), c.assign(w, k(_[O]));
        c.else(), l.error(!1, { discrError: t.DiscrError.Mapping, tag: x, tagName: y }), c.endIf();
      }
      function k(_) {
        const O = c.name("valid"), N = l.subschema({ keyword: "oneOf", schemaProp: _ }, O);
        return l.mergeEvaluated(N, e.Name), O;
      }
      function C() {
        var _;
        const O = {}, N = j(m);
        let R = !0;
        for (let z = 0; z < v.length; z++) {
          let B = v[z];
          if (B?.$ref && !(0, a.schemaHasRulesButRef)(B, h.self.RULES)) {
            const W = B.$ref;
            if (B = n.resolveRef.call(h.self, h.schemaEnv.root, h.baseId, W), B instanceof n.SchemaEnv && (B = B.schema), B === void 0)
              throw new r.default(h.opts.uriResolver, h.baseId, W);
          }
          const P = (_ = B?.properties) === null || _ === void 0 ? void 0 : _[y];
          if (typeof P != "object")
            throw new Error(`discriminator: oneOf subschemas (or referenced schemas) must have "properties/${y}"`);
          R = R && (N || j(B)), D(P, z);
        }
        if (!R)
          throw new Error(`discriminator: "${y}" must be required`);
        return O;
        function j({ required: z }) {
          return Array.isArray(z) && z.includes(y);
        }
        function D(z, B) {
          if (z.const)
            $(z.const, B);
          else if (z.enum)
            for (const P of z.enum)
              $(P, B);
          else
            throw new Error(`discriminator: "properties/${y}" must have "const" or "enum"`);
        }
        function $(z, B) {
          if (typeof z != "string" || z in O)
            throw new Error(`discriminator: "${y}" values must be unique strings`);
          O[z] = B;
        }
      }
    }
  };
  return e0.default = s, e0;
}
const KCe = "http://json-schema.org/draft-07/schema#", XCe = "http://json-schema.org/draft-07/schema#", YCe = "Core schema meta-schema", QCe = { schemaArray: { type: "array", minItems: 1, items: { $ref: "#" } }, nonNegativeInteger: { type: "integer", minimum: 0 }, nonNegativeIntegerDefault0: { allOf: [{ $ref: "#/definitions/nonNegativeInteger" }, { default: 0 }] }, simpleTypes: { enum: ["array", "boolean", "integer", "null", "number", "object", "string"] }, stringArray: { type: "array", items: { type: "string" }, uniqueItems: !0, default: [] } }, JCe = ["object", "boolean"], ZCe = { $id: { type: "string", format: "uri-reference" }, $schema: { type: "string", format: "uri" }, $ref: { type: "string", format: "uri-reference" }, $comment: { type: "string" }, title: { type: "string" }, description: { type: "string" }, default: !0, readOnly: { type: "boolean", default: !1 }, examples: { type: "array", items: !0 }, multipleOf: { type: "number", exclusiveMinimum: 0 }, maximum: { type: "number" }, exclusiveMaximum: { type: "number" }, minimum: { type: "number" }, exclusiveMinimum: { type: "number" }, maxLength: { $ref: "#/definitions/nonNegativeInteger" }, minLength: { $ref: "#/definitions/nonNegativeIntegerDefault0" }, pattern: { type: "string", format: "regex" }, additionalItems: { $ref: "#" }, items: { anyOf: [{ $ref: "#" }, { $ref: "#/definitions/schemaArray" }], default: !0 }, maxItems: { $ref: "#/definitions/nonNegativeInteger" }, minItems: { $ref: "#/definitions/nonNegativeIntegerDefault0" }, uniqueItems: { type: "boolean", default: !1 }, contains: { $ref: "#" }, maxProperties: { $ref: "#/definitions/nonNegativeInteger" }, minProperties: { $ref: "#/definitions/nonNegativeIntegerDefault0" }, required: { $ref: "#/definitions/stringArray" }, additionalProperties: { $ref: "#" }, definitions: { type: "object", additionalProperties: { $ref: "#" }, default: {} }, properties: { type: "object", additionalProperties: { $ref: "#" }, default: {} }, patternProperties: { type: "object", additionalProperties: { $ref: "#" }, propertyNames: { format: "regex" }, default: {} }, dependencies: { type: "object", additionalProperties: { anyOf: [{ $ref: "#" }, { $ref: "#/definitions/stringArray" }] } }, propertyNames: { $ref: "#" }, const: !0, enum: { type: "array", items: !0, minItems: 1, uniqueItems: !0 }, type: { anyOf: [{ $ref: "#/definitions/simpleTypes" }, { type: "array", items: { $ref: "#/definitions/simpleTypes" }, minItems: 1, uniqueItems: !0 }] }, format: { type: "string" }, contentMediaType: { type: "string" }, contentEncoding: { type: "string" }, if: { $ref: "#" }, then: { $ref: "#" }, else: { $ref: "#" }, allOf: { $ref: "#/definitions/schemaArray" }, anyOf: { $ref: "#/definitions/schemaArray" }, oneOf: { $ref: "#/definitions/schemaArray" }, not: { $ref: "#" } }, eOe = {
  $schema: KCe,
  $id: XCe,
  title: YCe,
  definitions: QCe,
  type: JCe,
  properties: ZCe,
  default: !0
};
var iI;
function rq() {
  return iI || (iI = 1, (function(e, t) {
    Object.defineProperty(t, "__esModule", { value: !0 }), t.MissingRefError = t.ValidationError = t.CodeGen = t.Name = t.nil = t.stringify = t.str = t._ = t.KeywordCxt = t.Ajv = void 0;
    const n = fCe(), r = qCe(), a = GCe(), s = eOe, l = ["/properties"], c = "http://json-schema.org/draft-07/schema";
    class d extends n.default {
      _addVocabularies() {
        super._addVocabularies(), r.default.forEach((w) => this.addVocabulary(w)), this.opts.discriminator && this.addKeyword(a.default);
      }
      _addDefaultMetaSchema() {
        if (super._addDefaultMetaSchema(), !this.opts.meta)
          return;
        const w = this.opts.$data ? this.$dataMetaSchema(s, l) : s;
        this.addMetaSchema(w, c, !1), this.refs["http://json-schema.org/schema"] = c;
      }
      defaultMeta() {
        return this.opts.defaultMeta = super.defaultMeta() || (this.getSchema(c) ? c : void 0);
      }
    }
    t.Ajv = d, e.exports = t = d, e.exports.Ajv = d, Object.defineProperty(t, "__esModule", { value: !0 }), t.default = d;
    var p = gE();
    Object.defineProperty(t, "KeywordCxt", { enumerable: !0, get: function() {
      return p.KeywordCxt;
    } });
    var m = qt();
    Object.defineProperty(t, "_", { enumerable: !0, get: function() {
      return m._;
    } }), Object.defineProperty(t, "str", { enumerable: !0, get: function() {
      return m.str;
    } }), Object.defineProperty(t, "stringify", { enumerable: !0, get: function() {
      return m.stringify;
    } }), Object.defineProperty(t, "nil", { enumerable: !0, get: function() {
      return m.nil;
    } }), Object.defineProperty(t, "Name", { enumerable: !0, get: function() {
      return m.Name;
    } }), Object.defineProperty(t, "CodeGen", { enumerable: !0, get: function() {
      return m.CodeGen;
    } });
    var h = a4();
    Object.defineProperty(t, "ValidationError", { enumerable: !0, get: function() {
      return h.default;
    } });
    var v = vE();
    Object.defineProperty(t, "MissingRefError", { enumerable: !0, get: function() {
      return v.default;
    } });
  })(sN, sN.exports)), sN.exports;
}
var tOe = rq();
const nOe = /* @__PURE__ */ Oc(tOe);
var dN = { exports: {} }, sI = {}, lI;
function rOe() {
  return lI || (lI = 1, (function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.formatNames = e.fastFormats = e.fullFormats = void 0;
    function t($, z) {
      return { validate: $, compare: z };
    }
    e.fullFormats = {
      // date: http://tools.ietf.org/html/rfc3339#section-5.6
      date: t(s, l),
      // date-time: http://tools.ietf.org/html/rfc3339#section-5.6
      time: t(d, p),
      "date-time": t(h, v),
      // duration: https://tools.ietf.org/html/rfc3339#appendix-A
      duration: /^P(?!$)((\d+Y)?(\d+M)?(\d+D)?(T(?=\d)(\d+H)?(\d+M)?(\d+S)?)?|(\d+W)?)$/,
      uri: x,
      "uri-reference": /^(?:[a-z][a-z0-9+\-.]*:)?(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'"()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?(?:\?(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i,
      // uri-template: https://tools.ietf.org/html/rfc6570
      "uri-template": /^(?:(?:[^\x00-\x20"'<>%\\^`{|}]|%[0-9a-f]{2})|\{[+#./;?&=,!@|]?(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?(?:,(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?)*\})*$/i,
      // For the source: https://gist.github.com/dperini/729294
      // For test cases: https://mathiasbynens.be/demo/url-regex
      url: /^(?:https?|ftp):\/\/(?:\S+(?::\S*)?@)?(?:(?!(?:10|127)(?:\.\d{1,3}){3})(?!(?:169\.254|192\.168)(?:\.\d{1,3}){2})(?!172\.(?:1[6-9]|2\d|3[0-1])(?:\.\d{1,3}){2})(?:[1-9]\d?|1\d\d|2[01]\d|22[0-3])(?:\.(?:1?\d{1,2}|2[0-4]\d|25[0-5])){2}(?:\.(?:[1-9]\d?|1\d\d|2[0-4]\d|25[0-4]))|(?:(?:[a-z0-9\u{00a1}-\u{ffff}]+-)*[a-z0-9\u{00a1}-\u{ffff}]+)(?:\.(?:[a-z0-9\u{00a1}-\u{ffff}]+-)*[a-z0-9\u{00a1}-\u{ffff}]+)*(?:\.(?:[a-z\u{00a1}-\u{ffff}]{2,})))(?::\d{2,5})?(?:\/[^\s]*)?$/iu,
      email: /^[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?$/i,
      hostname: /^(?=.{1,253}\.?$)[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[-0-9a-z]{0,61}[0-9a-z])?)*\.?$/i,
      // optimized https://www.safaribooksonline.com/library/view/regular-expressions-cookbook/9780596802837/ch07s16.html
      ipv4: /^(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)$/,
      ipv6: /^((([0-9a-f]{1,4}:){7}([0-9a-f]{1,4}|:))|(([0-9a-f]{1,4}:){6}(:[0-9a-f]{1,4}|((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9a-f]{1,4}:){5}(((:[0-9a-f]{1,4}){1,2})|:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9a-f]{1,4}:){4}(((:[0-9a-f]{1,4}){1,3})|((:[0-9a-f]{1,4})?:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){3}(((:[0-9a-f]{1,4}){1,4})|((:[0-9a-f]{1,4}){0,2}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){2}(((:[0-9a-f]{1,4}){1,5})|((:[0-9a-f]{1,4}){0,3}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){1}(((:[0-9a-f]{1,4}){1,6})|((:[0-9a-f]{1,4}){0,4}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(:(((:[0-9a-f]{1,4}){1,7})|((:[0-9a-f]{1,4}){0,5}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))$/i,
      regex: D,
      // uuid: http://tools.ietf.org/html/rfc4122
      uuid: /^(?:urn:uuid:)?[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12}$/i,
      // JSON-pointer: https://tools.ietf.org/html/rfc6901
      // uri fragment: https://tools.ietf.org/html/rfc3986#appendix-A
      "json-pointer": /^(?:\/(?:[^~/]|~0|~1)*)*$/,
      "json-pointer-uri-fragment": /^#(?:\/(?:[a-z0-9_\-.!$&'()*+,;:=@]|%[0-9a-f]{2}|~0|~1)*)*$/i,
      // relative JSON-pointer: http://tools.ietf.org/html/draft-luff-relative-json-pointer-00
      "relative-json-pointer": /^(?:0|[1-9][0-9]*)(?:#|(?:\/(?:[^~/]|~0|~1)*)*)$/,
      // the following formats are used by the openapi specification: https://spec.openapis.org/oas/v3.0.0#data-types
      // byte: https://github.com/miguelmota/is-base64
      byte: k,
      // signed 32 bit integer
      int32: { type: "number", validate: O },
      // signed 64 bit integer
      int64: { type: "number", validate: N },
      // C-type float
      float: { type: "number", validate: R },
      // C-type double
      double: { type: "number", validate: R },
      // hint to the UI to hide input strings
      password: !0,
      // unchecked string payload
      binary: !0
    }, e.fastFormats = {
      ...e.fullFormats,
      date: t(/^\d\d\d\d-[0-1]\d-[0-3]\d$/, l),
      time: t(/^(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)?$/i, p),
      "date-time": t(/^\d\d\d\d-[0-1]\d-[0-3]\d[t\s](?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)$/i, v),
      // uri: https://github.com/mafintosh/is-my-json-valid/blob/master/formats.js
      uri: /^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/)?[^\s]*$/i,
      "uri-reference": /^(?:(?:[a-z][a-z0-9+\-.]*:)?\/?\/)?(?:[^\\\s#][^\s#]*)?(?:#[^\\\s]*)?$/i,
      // email (sources from jsen validator):
      // http://stackoverflow.com/questions/201323/using-a-regular-expression-to-validate-an-email-address#answer-8829363
      // http://www.w3.org/TR/html5/forms.html#valid-e-mail-address (search for 'wilful violation')
      email: /^[a-z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?)*$/i
    }, e.formatNames = Object.keys(e.fullFormats);
    function n($) {
      return $ % 4 === 0 && ($ % 100 !== 0 || $ % 400 === 0);
    }
    const r = /^(\d\d\d\d)-(\d\d)-(\d\d)$/, a = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
    function s($) {
      const z = r.exec($);
      if (!z)
        return !1;
      const B = +z[1], P = +z[2], W = +z[3];
      return P >= 1 && P <= 12 && W >= 1 && W <= (P === 2 && n(B) ? 29 : a[P]);
    }
    function l($, z) {
      if ($ && z)
        return $ > z ? 1 : $ < z ? -1 : 0;
    }
    const c = /^(\d\d):(\d\d):(\d\d)(\.\d+)?(z|[+-]\d\d(?::?\d\d)?)?$/i;
    function d($, z) {
      const B = c.exec($);
      if (!B)
        return !1;
      const P = +B[1], W = +B[2], I = +B[3], G = B[5];
      return (P <= 23 && W <= 59 && I <= 59 || P === 23 && W === 59 && I === 60) && (!z || G !== "");
    }
    function p($, z) {
      if (!($ && z))
        return;
      const B = c.exec($), P = c.exec(z);
      if (B && P)
        return $ = B[1] + B[2] + B[3] + (B[4] || ""), z = P[1] + P[2] + P[3] + (P[4] || ""), $ > z ? 1 : $ < z ? -1 : 0;
    }
    const m = /t|\s/i;
    function h($) {
      const z = $.split(m);
      return z.length === 2 && s(z[0]) && d(z[1], !0);
    }
    function v($, z) {
      if (!($ && z))
        return;
      const [B, P] = $.split(m), [W, I] = z.split(m), G = l(B, W);
      if (G !== void 0)
        return G || p(P, I);
    }
    const y = /\/|:/, w = /^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)(?:\?(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i;
    function x($) {
      return y.test($) && w.test($);
    }
    const b = /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/gm;
    function k($) {
      return b.lastIndex = 0, b.test($);
    }
    const C = -2147483648, _ = 2 ** 31 - 1;
    function O($) {
      return Number.isInteger($) && $ <= _ && $ >= C;
    }
    function N($) {
      return Number.isInteger($);
    }
    function R() {
      return !0;
    }
    const j = /[^\\]\\Z/;
    function D($) {
      if (j.test($))
        return !1;
      try {
        return new RegExp($), !0;
      } catch {
        return !1;
      }
    }
  })(sI)), sI;
}
var uI = {}, cI;
function oOe() {
  return cI || (cI = 1, (function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.formatLimitDefinition = void 0;
    const t = rq(), n = qt(), r = n.operators, a = {
      formatMaximum: { okStr: "<=", ok: r.LTE, fail: r.GT },
      formatMinimum: { okStr: ">=", ok: r.GTE, fail: r.LT },
      formatExclusiveMaximum: { okStr: "<", ok: r.LT, fail: r.GTE },
      formatExclusiveMinimum: { okStr: ">", ok: r.GT, fail: r.LTE }
    }, s = {
      message: ({ keyword: c, schemaCode: d }) => n.str`should be ${a[c].okStr} ${d}`,
      params: ({ keyword: c, schemaCode: d }) => n._`{comparison: ${a[c].okStr}, limit: ${d}}`
    };
    e.formatLimitDefinition = {
      keyword: Object.keys(a),
      type: "string",
      schemaType: "string",
      $data: !0,
      error: s,
      code(c) {
        const { gen: d, data: p, schemaCode: m, keyword: h, it: v } = c, { opts: y, self: w } = v;
        if (!y.validateFormats)
          return;
        const x = new t.KeywordCxt(v, w.RULES.all.format.definition, "format");
        x.$data ? b() : k();
        function b() {
          const _ = d.scopeValue("formats", {
            ref: w.formats,
            code: y.code.formats
          }), O = d.const("fmt", n._`${_}[${x.schemaCode}]`);
          c.fail$data(n.or(n._`typeof ${O} != "object"`, n._`${O} instanceof RegExp`, n._`typeof ${O}.compare != "function"`, C(O)));
        }
        function k() {
          const _ = x.schema, O = w.formats[_];
          if (!O || O === !0)
            return;
          if (typeof O != "object" || O instanceof RegExp || typeof O.compare != "function")
            throw new Error(`"${h}": format "${_}" does not define "compare" function`);
          const N = d.scopeValue("formats", {
            key: _,
            ref: O,
            code: y.code.formats ? n._`${y.code.formats}${n.getProperty(_)}` : void 0
          });
          c.fail$data(C(N));
        }
        function C(_) {
          return n._`${_}.compare(${p}, ${m}) ${a[h].fail} 0`;
        }
      },
      dependencies: ["format"]
    };
    const l = (c) => (c.addKeyword(e.formatLimitDefinition), c);
    e.default = l;
  })(uI)), uI;
}
var dI;
function aOe() {
  return dI || (dI = 1, (function(e, t) {
    Object.defineProperty(t, "__esModule", { value: !0 });
    const n = rOe(), r = oOe(), a = qt(), s = new a.Name("fullFormats"), l = new a.Name("fastFormats"), c = (p, m = { keywords: !0 }) => {
      if (Array.isArray(m))
        return d(p, m, n.fullFormats, s), p;
      const [h, v] = m.mode === "fast" ? [n.fastFormats, l] : [n.fullFormats, s], y = m.formats || n.formatNames;
      return d(p, y, h, v), m.keywords && r.default(p), p;
    };
    c.get = (p, m = "full") => {
      const h = (m === "fast" ? n.fastFormats : n.fullFormats)[p];
      if (!h)
        throw new Error(`Unknown format "${p}"`);
      return h;
    };
    function d(p, m, h, v) {
      var y, w;
      (y = (w = p.opts.code).formats) !== null && y !== void 0 || (w.formats = a._`require("ajv-formats/dist/formats").${v}`);
      for (const x of m)
        p.addFormat(x, h[x]);
    }
    e.exports = t = c, Object.defineProperty(t, "__esModule", { value: !0 }), t.default = c;
  })(dN, dN.exports)), dN.exports;
}
var iOe = aOe();
const fI = /* @__PURE__ */ Oc(iOe), sOe = {
  allErrors: !0,
  multipleOfPrecision: 8,
  strict: !1,
  verbose: !0,
  discriminator: !1
  // TODO enable this in V6
}, lOe = /^(#?([0-9A-Fa-f]{3}){1,2}\b|aqua|black|blue|fuchsia|gray|green|lime|maroon|navy|olive|orange|purple|red|silver|teal|white|yellow|(rgb\(\s*\b([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\b\s*,\s*\b([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\b\s*,\s*\b([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\b\s*\))|(rgb\(\s*(\d?\d%|100%)+\s*,\s*(\d?\d%|100%)+\s*,\s*(\d?\d%|100%)+\s*\)))$/, uOe = /^data:([a-z]+\/[a-z0-9-+.]+)?;(?:name=(.*);)?base64,(.*)$/;
function cOe(e, t, n = {}, r, a = nOe, s) {
  let l = new a({ ...sOe, ...n });
  return r ? fI(l, r) : r !== !1 && fI(l), l.addFormat("data-url", uOe), l.addFormat("color", lOe), l.addKeyword(hc), l.addKeyword(CA), Array.isArray(e) && l.addMetaSchema(e), cn(t) && Object.keys(t).forEach((c) => {
    l.addFormat(c, t[c]);
  }), s && (l = s(l)), l;
}
function dOe(e = [], t) {
  return e.map((n) => {
    var r;
    const { instancePath: a, keyword: s, params: l, schemaPath: c, parentSchema: d, ...p } = n;
    let { message: m = "" } = p, h = a.replace(/\//g, "."), v = `${h} ${m}`.trim(), y = "";
    const w = [
      ...((r = l.deps) === null || r === void 0 ? void 0 : r.split(", ")) || [],
      l.missingProperty,
      l.property
    ].filter((x) => x);
    if (w.length > 0)
      w.forEach((x) => {
        const b = h ? `${h}.${x}` : x;
        let k = ht(Ae(t, `${b.replace(/^\./, "")}`)).title;
        if (k === void 0) {
          const C = c.replace(/\/properties\//g, "/").split("/").slice(1, -1).concat([x]);
          k = ht(Ae(t, C)).title;
        }
        if (k)
          m = m.replace(`'${x}'`, `'${k}'`), y = k;
        else {
          const C = Ae(d, [fn, x, "title"]);
          C && (m = m.replace(`'${x}'`, `'${C}'`), y = C);
        }
      }), v = m;
    else {
      const x = ht(Ae(t, `${h.replace(/^\./, "")}`)).title;
      if (x)
        v = `'${x}' ${m}`.trim(), y = x;
      else {
        const b = d?.title;
        b && (v = `'${b}' ${m}`.trim(), y = b);
      }
    }
    return "missingProperty" in l && (h = h ? `${h}.${l.missingProperty}` : l.missingProperty), {
      name: s,
      property: h,
      message: m,
      params: l,
      // specific to ajv
      stack: v,
      schemaPath: c,
      title: y
    };
  }).reduce((n, r) => {
    const { message: a, schemaPath: s } = r, l = s?.indexOf(`/${sn}/`), c = s?.indexOf(`/${Ht}/`);
    let d;
    return l && l >= 0 ? d = s?.substring(0, l) : c && c >= 0 && (d = s?.substring(0, c)), d && n.find((p) => {
      var m;
      return p.message === a && ((m = p.schemaPath) === null || m === void 0 ? void 0 : m.startsWith(d));
    }) || n.push(r), n;
  }, []);
}
function fOe(e, t, n, r, a, s, l) {
  const { validationError: c } = t;
  let d = dOe(t.errors, l);
  c && (d = [...d, { stack: c.message }]), typeof s == "function" && (d = s(d, l));
  let p = LEe(d);
  if (c && (p = {
    ...p,
    $schema: {
      __errors: [c.message]
    }
  }), typeof a != "function")
    return { errors: d, errorSchema: p };
  const m = TH(e, r, n, r, !0), h = a(m, Q5(m), l), v = YH(h);
  return B0({ errors: d, errorSchema: p }, v);
}
class pOe {
  /** Constructs an `AJV8Validator` instance using the `options`
   *
   * @param options - The `CustomValidatorOptionsType` options that are used to create the AJV instance
   * @param [localizer] - If provided, is used to localize a list of Ajv `ErrorObject`s
   */
  constructor(t, n) {
    const { additionalMetaSchemas: r, customFormats: a, ajvOptionsOverrides: s, ajvFormatOptions: l, AjvClass: c, extenderFn: d } = t;
    this.ajv = cOe(r, a, s, l, c, d), this.localizer = n;
  }
  /** Resets the internal AJV validator to clear schemas from it. Can be helpful for resetting the validator for tests.
   */
  reset() {
    this.ajv.removeSchema();
  }
  /** Runs the pure validation of the `schema` and `formData` without any of the RJSF functionality. Provided for use
   * by the playground. Returns the `errors` from the validation
   *
   * @param schema - The schema against which to validate the form data   * @param schema
   * @param formData - The form data to validate
   */
  rawValidation(t, n) {
    var r, a;
    let s, l;
    try {
      t[$n] && (l = this.ajv.getSchema(t[$n])), l === void 0 && (l = this.ajv.compile(t)), l(n);
    } catch (d) {
      s = d;
    }
    let c;
    return l && (typeof this.localizer == "function" && (((r = l.errors) !== null && r !== void 0 ? r : []).forEach((d) => {
      var p;
      ["missingProperty", "property"].forEach((m) => {
        var h;
        !((h = d.params) === null || h === void 0) && h[m] && (d.params[m] = `'${d.params[m]}'`);
      }), !((p = d.params) === null || p === void 0) && p.deps && (d.params.deps = d.params.deps.split(", ").map((m) => `'${m}'`).join(", "));
    }), this.localizer(l.errors), ((a = l.errors) !== null && a !== void 0 ? a : []).forEach((d) => {
      var p;
      ["missingProperty", "property"].forEach((m) => {
        var h;
        !((h = d.params) === null || h === void 0) && h[m] && (d.params[m] = d.params[m].slice(1, -1));
      }), !((p = d.params) === null || p === void 0) && p.deps && (d.params.deps = d.params.deps.split(", ").map((m) => m.slice(1, -1)).join(", "));
    })), c = l.errors || void 0, l.errors = null), {
      errors: c,
      validationError: s
    };
  }
  /** This function processes the `formData` with an optional user contributed `customValidate` function, which receives
   * the form data and a `errorHandler` function that will be used to add custom validation errors for each field. Also
   * supports a `transformErrors` function that will take the raw AJV validation errors, prior to custom validation and
   * transform them in what ever way it chooses.
   *
   * @param formData - The form data to validate
   * @param schema - The schema against which to validate the form data
   * @param [customValidate] - An optional function that is used to perform custom validation
   * @param [transformErrors] - An optional function that is used to transform errors after AJV validation
   * @param [uiSchema] - An optional uiSchema that is passed to `transformErrors` and `customValidate`
   */
  validateFormData(t, n, r, a, s) {
    const l = this.rawValidation(n, t);
    return fOe(this, l, t, n, r, a, s);
  }
  /**
   * This function checks if a schema needs to be added and if the root schemas don't match it removes the old root schema from the ajv instance and adds the new one.
   * @param rootSchema - The root schema used to provide $ref resolutions
   */
  handleSchemaUpdate(t) {
    var n, r;
    const a = (n = t[$n]) !== null && n !== void 0 ? n : MV;
    this.ajv.getSchema(a) === void 0 ? this.ajv.addSchema(t, a) : Yn(t, (r = this.ajv.getSchema(a)) === null || r === void 0 ? void 0 : r.schema) || (this.ajv.removeSchema(a), this.ajv.addSchema(t, a));
  }
  /** Validates data against a schema, returning true if the data is valid, or
   * false otherwise. If the schema is invalid, then this function will return
   * false.
   *
   * @param schema - The schema against which to validate the form data
   * @param formData - The form data to validate
   * @param rootSchema - The root schema used to provide $ref resolutions
   */
  isValid(t, n, r) {
    var a;
    try {
      this.handleSchemaUpdate(r);
      const s = o4(t), l = (a = s[$n]) !== null && a !== void 0 ? a : jEe(s);
      let c;
      return c = this.ajv.getSchema(l), c === void 0 && (c = this.ajv.addSchema(s, l).getSchema(l) || this.ajv.compile(s)), c(n);
    } catch (s) {
      return console.warn("Error encountered compiling schema:", s), !1;
    }
  }
}
function mOe(e = {}, t) {
  return new pOe(e, t);
}
const hOe = mOe();
function gOe(e, t) {
  return VH(e, t, function(n, r) {
    return eH(e, r);
  });
}
var oq = wH(function(e, t) {
  return e == null ? {} : gOe(e, t);
});
function vOe(e, t) {
  return e == null ? !0 : bH(e, t);
}
function l3() {
  return GH("rjsf-array-item-");
}
function pI(e) {
  return Array.isArray(e) ? e.map((t) => ({
    key: l3(),
    item: t
  })) : [];
}
function aq(e) {
  return Array.isArray(e) ? e.map((t) => t.item) : [];
}
function yOe(e) {
  return Array.isArray(e.type) ? !e.type.includes("null") : e.type !== "null";
}
function iq(e, t, n, r) {
  let { addable: a } = ht(r, e.globalUiOptions);
  return a !== !1 && (t.maxItems !== void 0 ? a = n.length < t.maxItems : a = !0), a;
}
function sq(e, t, n, r) {
  if (typeof e.items == "function")
    try {
      return e.items(t, n, r);
    } catch (a) {
      console.error(`Error executing dynamic uiSchema.items function for item at index ${n}:`, a);
      return;
    }
  else
    return e.items;
}
function bOe(e, t) {
  const { schemaUtils: n, globalFormOptions: r } = e;
  let a = t.items;
  return r.useFallbackUiForUnsupportedType && !a ? a = {} : KA(t) && Wwe(t) && (a = t.additionalItems), n.getDefaultFormState(a);
}
function wOe(e) {
  const { schema: t, fieldPathId: n, uiSchema: r, formData: a = [], disabled: s = !1, readonly: l = !1, autofocus: c = !1, required: d = !1, placeholder: p, onBlur: m, onFocus: h, registry: v, rawErrors: y, name: w, onSelectChange: x } = e, { widgets: b, schemaUtils: k, globalFormOptions: C, globalUiOptions: _ } = v, O = k.retrieveSchema(t.items, a), N = Gh(O, r), { widget: R = "select", title: j, ...D } = ht(r, _), $ = Rl(t, R, b), z = j ?? t.title ?? w, B = k.getDisplayLabel(t, r, _), P = jm(Li("", C, n, !0));
  return E.jsx($, { id: P[$n], name: w, multiple: !0, onChange: x, onBlur: m, onFocus: h, options: { ...D, enumOptions: N }, schema: t, uiSchema: r, registry: v, value: a, disabled: s, readonly: l, required: d, label: z, hideLabel: !B, placeholder: p, autofocus: c, rawErrors: y, htmlName: P.name });
}
function xOe(e) {
  const { schema: t, fieldPathId: n, uiSchema: r, disabled: a = !1, readonly: s = !1, autofocus: l = !1, required: c = !1, hideError: d, placeholder: p, onBlur: m, onFocus: h, formData: v = [], registry: y, rawErrors: w, name: x, onSelectChange: b } = e, { widgets: k, schemaUtils: C, globalFormOptions: _, globalUiOptions: O } = y, { widget: N, title: R, ...j } = ht(r, O), D = Rl(t, N, k), $ = R ?? t.title ?? x, z = C.getDisplayLabel(t, r, O), B = jm(Li("", _, n, !0));
  return E.jsx(D, { id: B[$n], name: x, multiple: !0, onChange: b, onBlur: m, onFocus: h, options: j, schema: t, uiSchema: r, registry: y, value: v, disabled: a, readonly: s, hideError: d, required: c, label: $, hideLabel: !z, placeholder: p, autofocus: l, rawErrors: w, htmlName: B.name });
}
function SOe(e) {
  const { schema: t, uiSchema: n, fieldPathId: r, name: a, disabled: s = !1, readonly: l = !1, autofocus: c = !1, required: d = !1, onBlur: p, onFocus: m, registry: h, formData: v = [], rawErrors: y, onSelectChange: w } = e, { widgets: x, schemaUtils: b, globalFormOptions: k, globalUiOptions: C } = h, { widget: _ = "files", title: O, ...N } = ht(n, C), R = Rl(t, _, x), j = O ?? t.title ?? a, D = b.getDisplayLabel(t, n, C), $ = jm(Li("", k, r, !0));
  return E.jsx(R, { options: N, id: $[$n], name: a, multiple: !0, onChange: w, onBlur: p, onFocus: m, schema: t, uiSchema: n, value: v, disabled: s, readonly: l, required: d, registry: h, autofocus: c, rawErrors: y, label: j, hideLabel: !D, htmlName: $.name });
}
function lq(e) {
  const { itemKey: t, index: n, name: r, disabled: a, hideError: s, readonly: l, registry: c, uiOptions: d, parentUiSchema: p, canAdd: m, canRemove: h = !0, canMoveUp: v, canMoveDown: y, itemSchema: w, itemData: x, itemUiSchema: b, itemFieldPathId: k, itemErrorSchema: C, autofocus: _, onBlur: O, onFocus: N, onChange: R, rawErrors: j, totalItems: D, title: $, handleAddItem: z, handleCopyItem: B, handleRemoveItem: P, handleReorderItems: W } = e, { schemaUtils: I, fields: { ArraySchemaField: G, SchemaField: L }, globalUiOptions: K } = c, q = jm(k), Z = G || L, V = bt("ArrayFieldItemTemplate", c, d), F = I.getDisplayLabel(w, b, K), { description: X } = ht(b), U = !!X || !!w.description, { orderable: H = !0, removable: Q = !0, copyable: re = !1 } = d, de = {
    moveUp: H && v,
    moveDown: H && y,
    copy: re && m,
    remove: Q && h,
    toolbar: !1
  };
  de.toolbar = Object.keys(de).some((ge) => de[ge]);
  const le = M.useCallback((ge) => {
    z(ge, n + 1);
  }, [z, n]), me = M.useCallback((ge) => {
    B(ge, n);
  }, [B, n]), ve = M.useCallback((ge) => {
    P(ge, n);
  }, [P, n]), ae = M.useCallback((ge) => {
    W(ge, n, n - 1);
  }, [W, n]), se = M.useCallback((ge) => {
    W(ge, n, n + 1);
  }, [W, n]), pe = {
    children: E.jsx(Z, { name: r, title: $, index: n, schema: w, uiSchema: b, formData: x, errorSchema: C, fieldPathId: q, required: yOe(w), onChange: R, onBlur: O, onFocus: N, registry: c, disabled: a, readonly: l, hideError: s, autofocus: _, rawErrors: j }),
    buttonsProps: {
      fieldPathId: q,
      disabled: a,
      readonly: l,
      canAdd: m,
      hasCopy: de.copy,
      hasMoveUp: de.moveUp,
      hasMoveDown: de.moveDown,
      hasRemove: de.remove,
      index: n,
      totalItems: D,
      onAddItem: le,
      onCopyItem: me,
      onRemoveItem: ve,
      onMoveUpItem: ae,
      onMoveDownItem: se,
      registry: c,
      schema: w,
      uiSchema: b
    },
    itemKey: t,
    className: "rjsf-array-item",
    disabled: a,
    hasToolbar: de.toolbar,
    index: n,
    totalItems: D,
    readonly: l,
    registry: c,
    schema: w,
    uiSchema: b,
    parentUiSchema: p,
    displayLabel: F,
    hasDescription: U
  };
  return E.jsx(V, { ...pe });
}
function kOe(e) {
  const { schema: t, uiSchema: n = {}, errorSchema: r, fieldPathId: a, formData: s, name: l, title: c, disabled: d = !1, readonly: p = !1, autofocus: m = !1, required: h = !1, hideError: v = !1, registry: y, onBlur: w, onFocus: x, rawErrors: b, onChange: k, keyedFormData: C, handleAddItem: _, handleCopyItem: O, handleRemoveItem: N, handleReorderItems: R } = e, j = t.title || c || l, { schemaUtils: D, fields: $, formContext: z, globalFormOptions: B, globalUiOptions: P } = y, { OptionalDataControlsField: W } = $, I = ht(n, P), G = cn(t.items) ? t.items : {}, L = D.retrieveSchema(G), K = aq(C), q = RS(y, t, h, n), Z = dg(s), V = iq(y, t, K, n) && (!q || Z), F = Z ? C : [], X = q ? " rjsf-optional-array-field" : "", U = e.childFieldPathId ?? a, H = q ? E.jsx(W, { ...e, fieldPathId: U }) : void 0, Q = {
    canAdd: V,
    items: F.map((de, le) => {
      const { key: me, item: ve } = de, ae = ve, se = D.retrieveSchema(G, ae), pe = r ? r[le] : void 0, ge = Li(le, B, U), xe = sq(n, ve, le, z), _e = {
        itemKey: me,
        index: le,
        name: l && `${l}-${le}`,
        registry: y,
        uiOptions: I,
        hideError: v,
        readonly: p,
        disabled: d,
        required: h,
        title: j ? `${j}-${le + 1}` : void 0,
        canAdd: V,
        canMoveUp: le > 0,
        canMoveDown: le < K.length - 1,
        itemSchema: se,
        itemFieldPathId: ge,
        itemErrorSchema: pe,
        itemData: ae,
        itemUiSchema: xe,
        autofocus: m && le === 0,
        onBlur: w,
        onFocus: x,
        rawErrors: b,
        totalItems: C.length,
        handleAddItem: _,
        handleCopyItem: O,
        handleRemoveItem: N,
        handleReorderItems: R,
        onChange: k
      };
      return E.jsx(lq, { ..._e }, me);
    }),
    className: `rjsf-field rjsf-field-array rjsf-field-array-of-${L.type}${X}`,
    disabled: d,
    fieldPathId: a,
    uiSchema: n,
    onAddClick: _,
    readonly: p,
    required: h,
    schema: t,
    title: j,
    formData: K,
    rawErrors: b,
    registry: y,
    optionalDataControl: H
  }, re = bt("ArrayFieldTemplate", y, I);
  return E.jsx(re, { ...Q });
}
function _Oe(e) {
  const { schema: t, uiSchema: n = {}, formData: r, errorSchema: a, fieldPathId: s, name: l, title: c, disabled: d = !1, readonly: p = !1, autofocus: m = !1, required: h = !1, hideError: v = !1, registry: y, onBlur: w, onFocus: x, rawErrors: b, keyedFormData: k, onChange: C, handleAddItem: _, handleCopyItem: O, handleRemoveItem: N, handleReorderItems: R } = e;
  let { formData: j = [] } = e;
  const D = t.title || c || l, { schemaUtils: $, fields: z, formContext: B, globalFormOptions: P, globalUiOptions: W } = y, I = ht(n, W), { OptionalDataControlsField: G } = z, L = RS(y, t, h, n), K = dg(r), q = (cn(t.items) ? t.items : []).map((de, le) => $.retrieveSchema(de, j[le])), Z = cn(t.additionalItems) ? $.retrieveSchema(t.additionalItems, r) : null, V = e.childFieldPathId ?? s;
  j.length < q.length && (j = j.concat(new Array(q.length - j.length)));
  const F = K ? k : [], X = L ? " rjsf-optional-array-field" : "", U = L ? E.jsx(G, { ...e, fieldPathId: V }) : void 0, H = iq(y, t, j, n) && !!Z && (!L || K), Q = {
    canAdd: H,
    className: `rjsf-field rjsf-field-array rjsf-field-array-fixed-items${X}`,
    disabled: d,
    fieldPathId: s,
    formData: r,
    items: F.map((de, le) => {
      const { key: me, item: ve } = de, ae = ve, se = le >= q.length, pe = (se && cn(t.additionalItems) ? $.retrieveSchema(t.additionalItems, ae) : q[le]) || {}, ge = Li(le, P, V);
      let xe;
      se ? xe = n.additionalItems : Array.isArray(n.items) ? xe = n.items[le] : xe = sq(n, ve, le, B);
      const _e = a ? a[le] : void 0, We = {
        index: le,
        itemKey: me,
        name: l && `${l}-${le}`,
        registry: y,
        uiOptions: I,
        hideError: v,
        readonly: p,
        disabled: d,
        required: h,
        title: D ? `${D}-${le + 1}` : void 0,
        canAdd: H,
        canRemove: se,
        canMoveUp: le >= q.length + 1,
        canMoveDown: se && le < j.length - 1,
        itemSchema: pe,
        itemData: ae,
        itemUiSchema: xe,
        itemFieldPathId: ge,
        itemErrorSchema: _e,
        autofocus: m && le === 0,
        onBlur: w,
        onFocus: x,
        rawErrors: b,
        totalItems: k.length,
        onChange: C,
        handleAddItem: _,
        handleCopyItem: O,
        handleRemoveItem: N,
        handleReorderItems: R
      };
      return E.jsx(lq, { ...We }, me);
    }),
    onAddClick: _,
    readonly: p,
    required: h,
    registry: y,
    schema: t,
    uiSchema: n,
    title: D,
    errorSchema: a,
    rawErrors: b,
    optionalDataControl: U
  }, re = bt("ArrayFieldTemplate", y, I);
  return E.jsx(re, { ...Q });
}
function EOe(e = []) {
  const t = M.useMemo(() => gl(e), [e]), [n, r] = M.useState(() => ({
    formDataHash: t,
    keyedFormData: pI(e)
  }));
  let { keyedFormData: a, formDataHash: s } = n;
  if (t !== s) {
    const c = Array.isArray(e) ? e : [], d = a || [];
    a = c.length === d.length ? d.map((p, m) => ({
      key: p.key,
      item: c[m]
    })) : pI(c), s = t, r({ formDataHash: s, keyedFormData: a });
  }
  const l = M.useCallback((c) => {
    const d = aq(c), p = gl(d);
    return r({ formDataHash: p, keyedFormData: c }), d;
  }, []);
  return { keyedFormData: a, updateKeyedFormData: l };
}
function COe(e) {
  const { schema: t, uiSchema: n, errorSchema: r, fieldPathId: a, registry: s, formData: l, onChange: c } = e, { globalFormOptions: d, schemaUtils: p, translateString: m } = s, { keyedFormData: h, updateKeyedFormData: v } = EOe(l), y = e.childFieldPathId ?? a, w = M.useCallback((R, j) => {
    R && R.preventDefault();
    let D;
    if (r) {
      D = {};
      for (const B in r) {
        const P = parseInt(B);
        j === void 0 || P < j ? Pn(D, [P], r[B]) : P >= j && Pn(D, [P + 1], r[B]);
      }
    }
    const $ = {
      key: l3(),
      item: bOe(s, t)
    }, z = [...h];
    j !== void 0 ? z.splice(j, 0, $) : z.push($), c(v(z), y.path, D);
  }, [h, s, t, c, v, r, y]), x = M.useCallback((R, j) => {
    R && R.preventDefault();
    let D;
    if (r) {
      D = {};
      for (const B in r) {
        const P = parseInt(B);
        P <= j ? Pn(D, [P], r[B]) : P > j && Pn(D, [P + 1], r[B]);
      }
    }
    const $ = {
      key: l3(),
      item: JA(h[j].item)
    }, z = [...h];
    j !== void 0 ? z.splice(j + 1, 0, $) : z.push($), c(v(z), y.path, D);
  }, [h, c, v, r, y]), b = M.useCallback((R, j) => {
    R && R.preventDefault();
    let D;
    if (r) {
      D = {};
      for (const z in r) {
        const B = parseInt(z);
        B < j ? Pn(D, [B], r[z]) : B > j && Pn(D, [B - 1], r[z]);
      }
    }
    const $ = h.filter((z, B) => B !== j);
    c(v($), y.path, D);
  }, [h, c, v, r, y]), k = M.useCallback((R, j, D) => {
    R && (R.preventDefault(), R.currentTarget.blur());
    let $;
    if (r) {
      $ = {};
      for (const P in r) {
        const W = parseInt(P);
        W == j ? Pn($, [D], r[j]) : W == D ? Pn($, [j], r[D]) : Pn($, [P], r[W]);
      }
    }
    function z() {
      const P = h.slice();
      return P.splice(j, 1), P.splice(D, 0, h[j]), P;
    }
    const B = z();
    c(v(B), y.path, $);
  }, [h, c, v, r, y]), C = M.useCallback((R, j, D, $) => {
    c(
      // We need to treat undefined items as nulls to have validation.
      // See https://github.com/tdegrunt/jsonschema/issues/206
      R === void 0 ? null : R,
      j,
      D,
      $
    );
  }, [c]), _ = M.useCallback((R) => {
    c(R, y.path, void 0, y?.[$n]);
  }, [c, y]), O = {
    ...e,
    formData: l,
    fieldPathId: y,
    onSelectChange: _
  }, N = {
    ...e,
    handleAddItem: w,
    handleCopyItem: x,
    handleRemoveItem: b,
    handleReorderItems: k,
    keyedFormData: h,
    onChange: C
  };
  if (!(Hh in t)) {
    if (!d.useFallbackUiForUnsupportedType) {
      const j = ht(n), D = bt("UnsupportedFieldTemplate", s, j);
      return E.jsx(D, { schema: t, fieldPathId: a, reason: m(Gt.MissingItems), registry: s });
    }
    const R = { ...t, [Hh]: { type: void 0 } };
    O.schema = R, N.schema = R;
  }
  return p.isMultiSelect(O.schema) ? E.jsx(wOe, { ...O }) : LH(n) ? E.jsx(xOe, { ...O }) : KA(O.schema) ? E.jsx(_Oe, { ...N }) : p.isFilesArray(O.schema, n) ? E.jsx(SOe, { ...O }) : E.jsx(kOe, { ...N });
}
function OOe(e) {
  const { schema: t, name: n, uiSchema: r, fieldPathId: a, formData: s, registry: l, required: c, disabled: d, readonly: p, hideError: m, autofocus: h, title: v, onChange: y, onFocus: w, onBlur: x, rawErrors: b } = e, { title: k } = t, { widgets: C, translateString: _, globalUiOptions: O } = l, {
    widget: N = "checkbox",
    title: R,
    // Unlike the other fields, don't use `getDisplayLabel()` since it always returns false for the boolean type
    label: j = !0,
    enumNames: D,
    ...$
  } = ht(r, O), z = Rl(t, N, C), B = _(Gt.YesLabel), P = _(Gt.NoLabel);
  let W;
  const I = R ?? k ?? v ?? n;
  if (Array.isArray(t.oneOf))
    W = Gh({
      oneOf: t.oneOf.map((L) => {
        if (cn(L))
          return {
            ...L,
            title: L.title || (L.const === !0 ? B : P)
          };
      }).filter((L) => L)
      // cast away the error that typescript can't grok is fixed
    }, r);
  else {
    const L = t.enum ?? [!0, !1];
    !D && L.length === 2 && L.every((K) => typeof K == "boolean") ? W = [
      {
        value: L[0],
        label: L[0] ? B : P
      },
      {
        value: L[1],
        label: L[1] ? B : P
      }
    ] : W = Gh({ enum: L }, r);
  }
  const G = M.useCallback((L, K, q) => y(L, a.path, K, q), [y, a]);
  return E.jsx(z, { options: { ...$, enumOptions: W }, schema: t, uiSchema: r, id: a.$id, name: n, onChange: G, onFocus: w, onBlur: x, label: I, hideLabel: !j, value: s, required: c, disabled: d, readonly: p, hideError: m, registry: l, autofocus: h, rawErrors: b, htmlName: a.name });
}
function MOe(e) {
  return {
    type: "string",
    enum: ["string", "number", "boolean", "object", "array"],
    default: "string",
    title: e
  };
}
function NOe(e) {
  const t = typeof e;
  return t === "string" || t === "number" || t === "boolean" ? t : t === "object" ? Array.isArray(e) ? "array" : "object" : "string";
}
function ROe(e, t) {
  switch (t) {
    case "string":
      return String(e);
    case "number": {
      const n = Number(e);
      return isNaN(n) ? 0 : n;
    }
    case "boolean":
      return !!e;
    default:
      return e;
  }
}
function AOe(e) {
  const { id: t, formData: n, displayLabel: r = !0, schema: a, name: s, uiSchema: l, required: c, disabled: d = !1, readonly: p = !1, onBlur: m, onFocus: h, registry: v, fieldPathId: y, onChange: w, errorSchema: x } = e, { translateString: b, fields: k, globalFormOptions: C } = v, [_, O] = M.useState(NOe(n)), N = ht(l), R = jm(Li("__internal_type_selector", C, y)), j = b(Gt.Type), D = M.useMemo(() => MOe(j), [j]), $ = (P) => {
    P != null && (O(P), w(ROe(n, P), y.path, x, t));
  };
  if (!C.useFallbackUiForUnsupportedType) {
    const { reason: P = b(Gt.UnknownFieldType, [String(a.type)]) } = e, W = bt("UnsupportedFieldTemplate", v, N);
    return E.jsx(W, { schema: a, fieldPathId: y, reason: P, registry: v });
  }
  const z = bt("FallbackFieldTemplate", v, N), { SchemaField: B } = k;
  return E.jsx(z, { schema: a, registry: v, typeSelector: E.jsx(B, { fieldPathId: R, name: `${s}__fallback_type`, schema: D, formData: _, onChange: $, onBlur: m, onFocus: h, registry: v, hideLabel: !r, disabled: d, readonly: p, required: c }, n ? gl(n) : "__empty__"), schemaField: E.jsx(B, { ...e, schema: {
    type: _,
    title: b(Gt.Value),
    ..._ === "object" && { additionalProperties: !0 }
  } }) });
}
function jOe(e, t) {
  return lg(t, function(n) {
    return e[n];
  });
}
function POe(e) {
  return e == null ? [] : jOe(e, Ps(e));
}
var DOe = Math.max;
function $Oe(e, t, n, r) {
  e = Om(e) ? e : POe(e), n = n ? GV(n) : 0;
  var a = e.length;
  return n < 0 && (n = DOe(a + n, 0)), md(e) ? n <= a && e.indexOf(t, n) > -1 : !!a && lH(e, t, n) > -1;
}
var TOe = Math.min;
function LOe(e, t, n) {
  for (var r = VA, a = e[0].length, s = e.length, l = s, c = Array(s), d = 1 / 0, p = []; l--; ) {
    var m = e[l];
    d = TOe(m.length, d), c[l] = a >= 120 && m.length >= 120 ? new vm(l && m) : void 0;
  }
  m = e[0];
  var h = -1, v = c[0];
  e:
    for (; ++h < a && p.length < d; ) {
      var y = m[h], w = y;
      if (y = y !== 0 ? y : 0, !(v ? jx(v, w) : r(p, w))) {
        for (l = s; --l; ) {
          var x = c[l];
          if (!(x ? jx(x, w) : r(e[l], w)))
            continue e;
        }
        v && v.push(w), p.push(y);
      }
    }
  return p;
}
function IOe(e) {
  return Dx(e) ? e : [];
}
var mI = uE(function(e) {
  var t = lg(e, IOe);
  return t.length && t[0] === e[0] ? LOe(t) : [];
});
function uq(e) {
  return e === void 0;
}
var yl;
(function(e) {
  e.ROW = "ui:row", e.COLUMN = "ui:col", e.COLUMNS = "ui:columns", e.CONDITION = "ui:condition";
})(yl || (yl = {}));
var ex;
(function(e) {
  e.ALL = "all", e.SOME = "some", e.NONE = "none";
})(ex || (ex = {}));
const zOe = /^\$lookup=(.+)/, fN = "layoutGrid";
function hI(e, t) {
  return e ?? t;
}
function FOe(e) {
  return /^\d+?$/.test(e);
}
const td = ZA();
function BOe(e, t, n, r, a) {
  const s = Ae(n, [Y5], {}), l = Ae(n, e), c = { ...Ae(l, [Zc], {}), ...t, ...s }, d = { ...l };
  jr(c) || Pn(d, [Zc], c), jr(s) || Pn(d, [Y5], s);
  let { readonly: p } = ht(d);
  return (a === !0 || uq(p) && r === !0) && (p = !0, Zt(c, UM) ? Pn(d, [Zc, UM], !0) : Pn(d, `ui:${UM}`, !0)), { fieldUiSchema: d, uiReadonly: p };
}
function UOe(e, t, n = "$0m3tH1nG Un3xP3cT3d") {
  const r = o3([t]).sort(), a = o3([n]).sort();
  switch (e) {
    case ex.ALL:
      return Px(r, a);
    case ex.SOME:
      return mI(r, a).length > 0;
    case ex.NONE:
      return mI(r, a).length === 0;
    default:
      return !1;
  }
}
function yE(e, t, n) {
  let r = {}, a = e[t];
  if (pd(a)) {
    const { children: s, className: l, ...c } = a;
    if (a = s, l) {
      const d = l.split(" ").map((p) => n4(n, p, p)).join(" ");
      r = { ...c, className: d };
    } else
      r = c;
  }
  if (!Array.isArray(a))
    throw new TypeError(`Expected array for "${t}" in ${JSON.stringify(e)}`);
  return { children: a, gridProps: r };
}
function gI(e, t, n) {
  let r;
  if (FOe(n) && e && e?.type === "array" && Zt(e, Hh)) {
    const a = Number(n), s = e[Hh];
    Array.isArray(s) ? a > s.length ? r = yH(s) : r = s[a] : r = s, t = {
      [$n]: t[$n],
      path: [...t.path.slice(0, t.path.length - 1), a]
    };
  }
  return { rawSchema: r, fieldPathId: t };
}
function VOe(e, t, n, r, a) {
  const { schemaUtils: s, globalFormOptions: l } = e;
  let c = n, d = a;
  const p = t.split("."), m = p.pop();
  let h = s.retrieveSchema(c, r), v = r, y = h.readOnly;
  p.forEach((b) => {
    if (d = Li(b, l, d), Zt(h, fn))
      c = Ae(h, [fn, b], {});
    else if (h && (Zt(h, Ht) || Zt(h, sn))) {
      const k = Zt(h, Ht) ? Ht : sn, C = s.findSelectedOptionInXxxOf(h, b, k, v);
      c = Ae(C, [fn, b], {});
    } else {
      const k = gI(h, d, b);
      c = k.rawSchema ?? {}, d = k.fieldPathId;
    }
    v = Ae(v, b, {}), h = s.retrieveSchema(c, v), y = hI(h.readOnly, y);
  });
  let w, x = !1;
  if (jr(h) && (h = void 0), h && m) {
    if (h && (Zt(h, Ht) || Zt(h, sn))) {
      const k = Zt(h, Ht) ? Ht : sn;
      h = s.findSelectedOptionInXxxOf(h, m, k, v);
    }
    d = Li(m, l, d), x = h !== void 0 && Array.isArray(h.required) && $Oe(h.required, m);
    const b = gI(h, d, m);
    if (b.rawSchema ? (h = b.rawSchema, d = b.fieldPathId) : (h = Ae(h, [fn, m]), h = h && s.retrieveSchema(h)), y = hI(h?.readOnly, y), h && (Zt(h, Ht) || Zt(h, sn))) {
      const k = Zt(h, Ht) ? Ht : sn, C = Nl(h);
      w = { options: h[k], hasDiscriminator: !!C };
    }
  }
  return { schema: h, isRequired: x, isReadonly: y, optionsInfo: w, fieldPathId: d };
}
function HOe(e, t) {
  let n = e;
  return md(n) && (n = n4(t, n)), _S(n) ? n : null;
}
function qOe(e, t) {
  let n, r = null, a = {}, s;
  if (md(t) || uq(t))
    n = t ?? "";
  else {
    const { name: l = "", render: c, ...d } = t;
    n = l, a = d, jr(a) || KEe(a, (p, m) => {
      if (md(p)) {
        const h = zOe.exec(p);
        if (Array.isArray(h) && h.length > 1) {
          const v = h[1];
          a[m] = n4(e, v, v);
        }
      }
    }), r = HOe(c, e), !l && r && (s = E.jsx(r, { ...d, "data-testid": td.uiComponent }));
  }
  return { name: n, UIComponent: r, uiProps: a, rendered: s };
}
function bE(e) {
  const { childrenLayoutGridSchemaId: t, ...n } = e, { registry: r, schema: a, formData: s } = n, { schemaUtils: l } = r, c = l.retrieveSchema(a, s);
  return t.map((d) => M.createElement(l4, { ...n, key: `layoutGrid-${gl(d)}`, schema: c, layoutGridSchema: d }));
}
function WOe(e) {
  const { layoutGridSchema: t, ...n } = e, { formData: r, registry: a } = n, { children: s, gridProps: l } = yE(t, yl.CONDITION, a), { operator: c, field: d = "", value: p } = l, m = Ae(r, d, null);
  return UOe(c, m, p) ? E.jsx(bE, { ...n, childrenLayoutGridSchemaId: s }) : null;
}
function GOe(e) {
  const { layoutGridSchema: t, ...n } = e, { registry: r, uiSchema: a } = n, { children: s, gridProps: l } = yE(t, yl.COLUMN, r), c = ht(a), d = bt("GridTemplate", r, c);
  return E.jsx(d, { column: !0, "data-testid": td.col, ...l, children: E.jsx(bE, { ...n, childrenLayoutGridSchemaId: s }) });
}
function KOe(e) {
  const { layoutGridSchema: t, ...n } = e, { registry: r, uiSchema: a } = n, { children: s, gridProps: l } = yE(t, yl.COLUMNS, r), c = ht(a), d = bt("GridTemplate", r, c);
  return s.map((p) => E.jsx(d, { column: !0, "data-testid": td.col, ...l, children: E.jsx(bE, { ...n, childrenLayoutGridSchemaId: [p] }) }, `column-${gl(p)}`));
}
function XOe(e) {
  const { layoutGridSchema: t, ...n } = e, { registry: r, uiSchema: a } = n, { children: s, gridProps: l } = yE(t, yl.ROW, r), c = ht(a), d = bt("GridTemplate", r, c);
  return E.jsx(d, { ...l, "data-testid": td.row, children: E.jsx(bE, { ...n, childrenLayoutGridSchemaId: s }) });
}
function YOe(e) {
  const {
    gridSchema: t,
    schema: n,
    uiSchema: r,
    errorSchema: a,
    fieldPathId: s,
    onBlur: l,
    onFocus: c,
    formData: d,
    readonly: p,
    registry: m,
    layoutGridSchema: h,
    // Used to pull this out of otherProps since we don't want to pass it through
    ...v
  } = e, { onChange: y } = v, { fields: w } = m, { SchemaField: x, LayoutMultiSchemaField: b } = w, k = qOe(m, t), { name: C, UIComponent: _, uiProps: O } = k, { schema: N, isRequired: R, isReadonly: j, optionsInfo: D, fieldPathId: $ } = VOe(m, C, n, d, s), z = jm($);
  if (k.rendered)
    return k.rendered;
  if (N) {
    const B = D?.hasDiscriminator ? b : x, { fieldUiSchema: P, uiReadonly: W } = BOe(C, O, r, j, p);
    return E.jsx(B, { "data-testid": D?.hasDiscriminator ? td.layoutMultiSchemaField : td.field, ...v, name: C, required: R, readonly: W, schema: N, uiSchema: P, errorSchema: Ae(a, C), fieldPathId: z, formData: Ae(d, C), onChange: y, onBlur: l, onFocus: c, options: D?.options, registry: m });
  }
  return _ ? E.jsx(_, { "data-testid": td.uiComponent, ...v, name: C, required: R, formData: d, readOnly: !!j || p, errorSchema: a, uiSchema: r, schema: n, fieldPathId: s, onBlur: l, onFocus: c, registry: m, ...O }) : null;
}
function l4(e) {
  const { uiSchema: t } = e;
  let { layoutGridSchema: n } = e;
  const r = ht(t);
  if (!n && fN in r && cn(r[fN]) && (n = r[fN]), cn(n)) {
    if (yl.ROW in n)
      return E.jsx(XOe, { ...e, layoutGridSchema: n });
    if (yl.COLUMN in n)
      return E.jsx(GOe, { ...e, layoutGridSchema: n });
    if (yl.COLUMNS in n)
      return E.jsx(KOe, { ...e, layoutGridSchema: n });
    if (yl.CONDITION in n)
      return E.jsx(WOe, { ...e, layoutGridSchema: n });
  }
  return E.jsx(YOe, { ...e, gridSchema: n });
}
l4.TEST_IDS = td;
function QOe(e) {
  const { fieldPathId: t, title: n, schema: r, uiSchema: a, required: s, registry: l, name: c } = e, d = ht(a, l.globalUiOptions), { title: p } = d, { title: m } = r, h = p || n || m || c;
  if (!h)
    return null;
  const v = bt("TitleFieldTemplate", l, d);
  return E.jsx(v, { id: fE(t), title: h, required: s, schema: r, uiSchema: a, registry: l });
}
function pN(e, t, n) {
  const r = "!@#!@$@#$!@$#";
  return e.map(({ schema: a }) => a).find((a) => {
    const s = Ae(a, [fn, t]);
    return Ae(s, tE, Ae(s, Di, r)) === n;
  });
}
function vI(e, t, n, r, a) {
  const s = t.map((d) => n.retrieveSchema(d, a));
  let l = e;
  Zt(e, Ht) ? l = { ...e, [Ht]: s } : Zt(e, sn) && (l = { ...e, [sn]: s });
  const c = Gh(l, r);
  if (!c)
    throw new Error(`No enumOptions were computed from the schema ${JSON.stringify(l)}`);
  return c;
}
function JOe(e) {
  const { name: t, baseType: n, disabled: r = !1, formData: a, fieldPathId: s, onBlur: l, onChange: c, options: d, onFocus: p, registry: m, uiSchema: h, schema: v, autofocus: y, readonly: w, required: x, errorSchema: b, hideError: k = !1 } = e, { widgets: C, schemaUtils: _, globalUiOptions: O } = m, [N, R] = M.useState(vI(v, d, _, h, a)), j = Ae(s, $n), D = Nl(v), $ = bt("FieldErrorTemplate", m, d), z = bt("FieldTemplate", m, d), B = gl(v), P = gl(d), W = h ? gl(h) : "", I = a ? gl(a) : "";
  M.useEffect(() => {
    R(vI(v, d, _, h, a));
  }, [B, P, _, W, I]);
  const { widget: G = D ? "radio" : "select", title: L = "", placeholder: K = "", optionsSchemaSelector: q = D, hideError: Z, ...V } = ht(h);
  if (!q)
    throw new Error("No selector field provided for the LayoutMultiSchemaField");
  const F = Ae(a, q);
  let X = Ae(N[0]?.schema, [fn, q], {});
  const U = pN(N, q, F);
  X = X?.type ? X : { ...X, type: U?.type || n };
  const H = Rl(X, G, C), Q = Z === void 0 ? k : !!Z, re = Ae(b, [Po], []), de = $x(b, [Po]), le = _.getDisplayLabel(v, h, O), me = (se) => {
    const pe = pN(N, q, se), ge = pN(N, q, F);
    let xe = _.sanitizeDataForNewSchema(pe, ge, a);
    xe && pe && (xe = _.getDefaultFormState(pe, xe, "excludeObjectChildren")), xe && Pn(xe, q, se), c(xe, s.path, void 0, j);
  }, ve = { enumOptions: N, ...V }, ae = !Q && re.length > 0 ? E.jsx($, { fieldPathId: s, schema: v, errors: re, registry: m }) : void 0;
  return E.jsx(z, { id: j, schema: v, label: (L || v.title) ?? "", disabled: r || Array.isArray(N) && jr(N), uiSchema: h, required: x, readonly: !!w, registry: m, displayLabel: le, errors: ae, onChange: c, onKeyRename: I0, onKeyRenameBlur: I0, onRemoveProperty: I0, children: E.jsx(H, { id: j, name: t, schema: v, label: (L || v.title) ?? "", disabled: r || Array.isArray(N) && jr(N), uiSchema: h, autofocus: y, readonly: w, required: x, registry: m, multiple: !1, rawErrors: re, hideError: Q, hideLabel: !le, errorSchema: de, placeholder: K, onChange: me, onBlur: l, onFocus: p, value: F, options: ve, htmlName: s.name }) });
}
class yI extends M.Component {
  /** Constructs an `AnyOfField` with the given `props` to initialize the initially selected option in state
   *
   * @param props - The `FieldProps` for this template
   */
  constructor(n) {
    super(n);
    /** Callback handler to remember what the currently selected option is. In addition to that the `formData` is updated
     * to remove properties that are not part of the newly selected option schema, and then the updated data is passed to
     * the `onChange` handler.
     *
     * @param option - The new option value being selected
     */
    Jr(this, "onOptionChange", (n) => {
      const { selectedOption: r, retrievedOptions: a } = this.state, { formData: s, onChange: l, registry: c, fieldPathId: d } = this.props, { schemaUtils: p } = c, m = n !== void 0 ? parseInt(n, 10) : -1;
      if (m === r)
        return;
      const h = m >= 0 ? a[m] : void 0, v = r >= 0 ? a[r] : void 0;
      let y = p.sanitizeDataForNewSchema(h, v, s);
      h && (y = p.getDefaultFormState(h, y, "excludeObjectChildren")), this.setState({ selectedOption: m }, () => {
        l(y, d.path, void 0, this.getFieldId());
      });
    });
    const { formData: r, options: a, registry: { schemaUtils: s } } = this.props, l = a.map((c) => s.retrieveSchema(c, r));
    this.state = {
      retrievedOptions: l,
      selectedOption: this.getMatchingOption(0, r, l)
    };
  }
  /** React lifecycle method that is called when the props and/or state for this component is updated. It recomputes the
   * currently selected option based on the overall `formData`
   *
   * @param prevProps - The previous `FieldProps` for this template
   * @param prevState - The previous `AnyOfFieldState` for this template
   */
  componentDidUpdate(n, r) {
    const { formData: a, options: s, fieldPathId: l } = this.props, { selectedOption: c } = this.state;
    let d = this.state;
    if (!Yn(n.options, s)) {
      const { registry: { schemaUtils: p } } = this.props, m = s.map((h) => p.retrieveSchema(h, a));
      d = { selectedOption: c, retrievedOptions: m };
    }
    if (!Yn(a, n.formData) && l.$id === n.fieldPathId.$id) {
      const { retrievedOptions: p } = d, m = this.getMatchingOption(c, a, p);
      r && m !== c && (d = { selectedOption: m, retrievedOptions: p });
    }
    d !== this.state && this.setState(d);
  }
  /** Determines the best matching option for the given `formData` and `options`.
   *
   * @param formData - The new formData
   * @param options - The list of options to choose from
   * @return - The index of the `option` that best matches the `formData`
   */
  getMatchingOption(n, r, a) {
    const { schema: s, registry: { schemaUtils: l } } = this.props, c = Nl(s);
    return l.getClosestMatchingOption(r, a, n, c);
  }
  getFieldId() {
    const { fieldPathId: n, schema: r } = this.props;
    return `${n.$id}${r.oneOf ? "__oneof_select" : "__anyof_select"}`;
  }
  /** Renders the `AnyOfField` selector along with a `SchemaField` for the value of the `formData`
   */
  render() {
    const { name: n, disabled: r = !1, errorSchema: a = {}, formData: s, onBlur: l, onFocus: c, readonly: d, required: p = !1, registry: m, schema: h, uiSchema: v } = this.props, { widgets: y, fields: w, translateString: x, globalUiOptions: b, schemaUtils: k } = m, { SchemaField: C } = w, _ = bt("MultiSchemaFieldTemplate", m, b), O = RS(m, h, p, v), N = dg(s), { selectedOption: R, retrievedOptions: j } = this.state, { widget: D = "select", placeholder: $, autofocus: z, autocomplete: B, title: P = h.title, ...W } = ht(v, b), I = Rl({ type: "number" }, D, y), G = Ae(a, Po, []), L = $x(a, [Po]), K = k.getDisplayLabel(h, v, b), q = R >= 0 && j[R] || null;
    let Z;
    if (q) {
      const { required: de } = h;
      Z = de ? Ec({ required: de }, q) : q;
    }
    let V = [];
    Ht in h && v && Ht in v ? Array.isArray(v[Ht]) ? V = v[Ht] : console.warn(`uiSchema.oneOf is not an array for "${P || n}"`) : sn in h && v && sn in v && (Array.isArray(v[sn]) ? V = v[sn] : console.warn(`uiSchema.anyOf is not an array for "${P || n}"`));
    let F = v;
    R >= 0 && V.length > R && (F = V[R]);
    const X = P ? Gt.TitleOptionPrefix : Gt.OptionPrefix, U = P ? [P] : [], H = j.map((de, le) => {
      const { title: me = de.title } = ht(V[le]);
      return {
        label: me || x(X, U.concat(String(le + 1))),
        value: le
      };
    }), Q = !O || N ? E.jsx(I, { id: this.getFieldId(), name: `${n}${h.oneOf ? "__oneof_select" : "__anyof_select"}`, schema: { type: "number", default: 0 }, onChange: this.onOptionChange, onBlur: l, onFocus: c, disabled: r || jr(H), multiple: !1, rawErrors: G, errorSchema: L, value: R >= 0 ? R : void 0, options: { enumOptions: H, ...W }, registry: m, placeholder: $, autocomplete: B, autofocus: z, label: P ?? n, hideLabel: !K, readonly: d }) : void 0, re = Z && Z.type !== "null" && E.jsx(C, { ...this.props, schema: Z, uiSchema: F }) || null;
    return E.jsx(_, { schema: h, registry: m, uiSchema: v, selector: Q, optionSchemaField: re });
  }
}
const ZOe = /\.([0-9]*0)*$/, eMe = /[0.]0*$/;
function tMe(e) {
  const { registry: t, onChange: n, formData: r, value: a } = e, [s, l] = M.useState(a), { StringField: c } = t.fields;
  let d = r;
  const p = M.useCallback((m, h, v, y) => {
    l(m), `${m}`.charAt(0) === "." && (m = `0${m}`);
    const w = typeof m == "string" && m.match(ZOe) ? $$(m.replace(eMe, "")) : $$(m);
    n(w, h, v, y);
  }, [n]);
  if (typeof s == "string" && typeof d == "number") {
    const m = new RegExp(`^(${String(d).replace(".", "\\.")})?\\.?0*$`);
    s.match(m) && (d = s);
  }
  return E.jsx(c, { ...e, formData: d, onChange: p });
}
function ul() {
  return ul = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var r in n) ({}).hasOwnProperty.call(n, r) && (e[r] = n[r]);
    }
    return e;
  }, ul.apply(null, arguments);
}
const t0 = ["strong", "em", "del", "mark"], bI = [["**", t0[0]], ["__", t0[0]], ["~~", t0[2]], ["==", t0[3]], ["*", "em"], ["_", "em"]];
function nMe(e, t) {
  for (var n = 1, r = t + 1; r < e.length && n > 0; ) e[r] !== "\\" ? (e[r] === "[" && n++, e[r] === "]" && n--, r++) : r += 2;
  if (n === 0 && r < e.length && (e[r] === "(" || e[r] === "[")) {
    var a = e[r] === "(" ? ")" : "]", s = 1;
    for (r++; r < e.length && s > 0; ) e[r] !== "\\" ? (e[r] === "(" && a === ")" && s++, e[r] === a && s--, r++) : r += 2;
    if (s === 0) return r;
  }
  return -1;
}
function rMe(e, t) {
  if (!t || !t.inline && !t.simple) return null;
  var n = e[0];
  if (n !== "*" && n !== "_" && n !== "~" && n !== "=") return null;
  for (var r = "", a = 0, s = "", l = 0; l < 6; l++) {
    var c = bI[l][0];
    if (e.startsWith(c) && e.length >= 2 * c.length) {
      r = c, a = c.length, s = bI[l][1];
      break;
    }
  }
  if (!r) return null;
  for (var d = a, p = !1, m = !1, h = "", v = 0, y = "", w = !1, x = ""; d < e.length; ) {
    var b = e[d];
    if (w) y += b, w = !1, x = b, d++;
    else if (b !== "\\") if (b !== "`" || v !== 0) {
      if (b === "[" && !p && v === 0) {
        var k = nMe(e, d);
        if (k !== -1) {
          y += e.slice(d, k), d = k, x = e[k - 1];
          continue;
        }
      }
      if (m) y += b, h ? b === h && (h = "") : b === '"' || b === "'" ? h = b : b === ">" && (m = !1), x = b, d++;
      else if (b !== "<" || p) {
        if (b === `
` && x === `
` && !p && v === 0) return null;
        if (!p && v === 0) {
          for (var C = 0; d + C < e.length && e[d + C] === r[0]; ) C++;
          if (C >= a && (a !== 1 || r !== "*" && r !== "_" || e[d - 1] !== r && e[d + 1] !== r)) {
            var _ = [e.slice(0, d + C), s, y + e.slice(d + a, d + C)];
            return _.index = 0, _.input = e, _;
          }
        }
        y += b, x = b, d++;
      } else {
        var O = e[d + 1], N = e.indexOf(">", d);
        if (N !== -1) {
          var R = e.slice(d, N + 1).endsWith("/>");
          O === "/" ? v = Math.max(0, v - 1) : R || v++;
        }
        m = !0, y += b, x = b, d++;
      }
    } else p = !p, y += b, x = b, d++;
    else y += b, w = !0, x = b, d++;
  }
  return null;
}
const oMe = ["children", "options"], wI = ["allowFullScreen", "allowTransparency", "autoComplete", "autoFocus", "autoPlay", "cellPadding", "cellSpacing", "charSet", "classId", "colSpan", "contentEditable", "contextMenu", "crossOrigin", "encType", "formAction", "formEncType", "formMethod", "formNoValidate", "formTarget", "frameBorder", "hrefLang", "inputMode", "keyParams", "keyType", "marginHeight", "marginWidth", "maxLength", "mediaGroup", "minLength", "noValidate", "radioGroup", "readOnly", "rowSpan", "spellCheck", "srcDoc", "srcLang", "srcSet", "tabIndex", "useMap"].reduce((e, t) => (e[t.toLowerCase()] = t, e), { class: "className", for: "htmlFor" }), xI = { amp: "&", apos: "'", gt: ">", lt: "<", nbsp: "", quot: "" }, aMe = ["style", "script", "pre"], iMe = ["src", "href", "data", "formAction", "srcDoc", "action"], sMe = /([-A-Z0-9_:]+)(?:\s*=\s*(?:(?:"((?:\\.|[^"])*)")|(?:'((?:\\.|[^'])*)')|(?:\{((?:\\.|{[^}]*?}|[^}])*)\})))?/gi, lMe = /\n{2,}$/, SI = /^(\s*>[\s\S]*?)(?=\n\n|$)/, uMe = /^ *> ?/gm, cMe = /^(?:\[!([^\]]*)\]\n)?([\s\S]*)/, dMe = /^ {2,}\n/, fMe = /^(?:([-*_])( *\1){2,}) *(?:\n *)+\n/, kI = /^(?: {1,3})?(`{3,}|~{3,}) *(\S+)? *([^\n]*?)?\n([\s\S]*?)(?:\1\n?|$)/, _I = /^(?: {4}[^\n]+\n*)+(?:\n *)+\n?/, pMe = /^(`+)((?:\\`|(?!\1)`|[^`])+)\1/, mMe = /^(?:\n *)*\n/, hMe = /\r\n?/g, gMe = /^\[\^([^\]]+)](:(.*)((\n+ {4,}.*)|(\n(?!\[\^).+))*)/, vMe = /^\[\^([^\]]+)]/, yMe = /\f/g, bMe = /^---[ \t]*\n(.|\n)*\n---[ \t]*\n/, wMe = /^\[(x|\s)\]/, EI = /^(#{1,6}) *([^\n]+?)(?: +#*)?(?:\n *)*(?:\n|$)/, CI = /^ *(#{1,6}) +([^\n]+?)(?: +#*)?(?:\n *)*(?:\n|$)/, OI = /^([^\n]+)\n *(=|-)\2{2,} *\n/, u4 = /^<([a-z][^ >/]*) ?((?:[^>]*[^/])?)>/i;
function xMe(e) {
  const t = u4.exec(e);
  if (!t) return null;
  const n = t[1], r = n.toLowerCase(), a = r.length + 1;
  let s = t[0].length;
  e[s] === `
` && s++;
  const l = s;
  let c = s, d = 1;
  const p = e.length;
  for (; d > 0; ) {
    const h = e.indexOf("<", s);
    if (h === -1) return null;
    let v = -1, y = -1;
    if (e[h + 1] === "/") y = h;
    else if (e[h + 1] === r[0] || e[h + 1] === n[0]) {
      let w = !0;
      for (let x = 0; x < r.length; x++) {
        const b = e[h + 1 + x];
        if (b !== r[x] && b !== n[x]) {
          w = !1;
          break;
        }
      }
      !w || e[h + a] !== " " && e[h + a] !== ">" || (v = h);
    }
    if (v !== -1 || y !== -1) if (v !== -1 && (y === -1 || v < y)) s = v + a + 1, d++;
    else {
      let w = y + 2;
      for (; w < p; ) {
        const b = e[w];
        if (b !== " " && b !== "	" && b !== `
` && b !== "\r") break;
        w++;
      }
      if (w + r.length > p) return null;
      let x = !0;
      for (let b = 0; b < r.length; b++) {
        const k = e[w + b];
        if (k !== r[b] && k !== n[b]) {
          x = !1;
          break;
        }
      }
      if (!x) {
        s = w;
        continue;
      }
      for (w += r.length; w < p; ) {
        const b = e[w];
        if (b !== " " && b !== "	" && b !== `
` && b !== "\r") break;
        w++;
      }
      if (w >= p || e[w] !== ">") {
        s = w;
        continue;
      }
      c = y, s = w + 1, d--;
    }
    else s = h + 1;
  }
  let m = 0;
  for (; s + m < p && e[s + m] === `
`; ) m++;
  return [e.slice(0, s + m), n, t[2], e.slice(l, c)];
}
const SMe = /&([a-z0-9]+|#[0-9]{1,6}|#x[0-9a-fA-F]{1,6});/gi, MI = /^<!--[\s\S]*?(?:-->)/, kMe = /^(data|aria|x)-[a-z_][a-z\d_.-]*$/, u3 = /^ *<([a-z][a-z0-9:]*)(?:\s+((?:<.*?>|[^>])*))?\/?>(?!<\/\1>)(\s*\n)?/i, _Me = /^\{.*\}$/, EMe = /^(https?:\/\/[^\s<]+[^<.,:;"')\]\s])/, CMe = /^<([^ >]+[:@\/][^ >]+)>/, OMe = /-([a-z])?/gi, NI = /^(\|.*)\n(?: *(\|? *[-:]+ *\|[-| :]*)\n((?:.*\|.*\n)*))?\n?/, MMe = /^[^\n]+(?:  \n|\n{2,})/, NMe = /^\[([^\]]*)\]:\s+<?([^\s>]+)>?\s*("([^"]*)")?/, RMe = /^!\[([^\]]*)\] ?\[([^\]]*)\]/, AMe = /^\[([^\]]*)\] ?\[([^\]]*)\]/, jMe = /(\n|^[-*]\s|^#|^ {2,}|^-{2,}|^>\s)/, PMe = /\t/g, DMe = /(^ *\||\| *$)/g, $Me = /^ *:-+: *$/, TMe = /^ *:-+ *$/, LMe = /^ *-+: *$/, IMe = /^(:[a-zA-Z0-9-_]+:)/, zMe = /^\\([^0-9A-Za-z\s])/, FMe = /\\([^0-9A-Za-z\s])/g, BMe = /^[\s\S](?:(?!  \n|[0-9]\.|http)[^=*_~\-\n:<`\\\[!])*/, UMe = /^\n+/, VMe = /^([ \t]*)/, HMe = /(?:^|\n)( *)$/, c4 = "(?:\\d+\\.)", d4 = "(?:[*+-])";
function cq(e) {
  return "( *)(" + (e === 1 ? c4 : d4) + ") +";
}
const dq = cq(1), fq = cq(2);
function pq(e) {
  return RegExp("^" + (e === 1 ? dq : fq));
}
const qMe = pq(1), WMe = pq(2);
function mq(e) {
  return RegExp("^" + (e === 1 ? dq : fq) + "[^\\n]*(?:\\n(?!\\1" + (e === 1 ? c4 : d4) + " )[^\\n]*)*(\\n|$)", "gm");
}
const GMe = mq(1), KMe = mq(2);
function hq(e) {
  const t = e === 1 ? c4 : d4;
  return RegExp("^( *)(" + t + ") [\\s\\S]+?(?:\\n{2,}(?! )(?!\\1" + t + " (?!" + t + " ))\\n*|\\s*\\n*$)");
}
const gq = hq(1), vq = hq(2);
function RI(e, t) {
  const n = t === 1, r = n ? gq : vq, a = n ? GMe : KMe, s = n ? qMe : WMe;
  return { t: (l) => s.test(l), o: Qc(function(l, c) {
    const d = HMe.exec(c.prevCapture);
    return d && (c.list || !c.inline && !c.simple) ? r.exec(l = d[1] + l) : null;
  }), u: 1, i(l, c, d) {
    const p = n ? +l[2] : void 0, m = l[0].replace(lMe, `
`).match(a), h = s.exec(m[0]), v = RegExp("^ {1," + (h ? h[0].length : 0) + "}", "gm");
    let y = !1;
    return { items: m.map(function(w, x) {
      const b = w.replace(v, "").replace(s, ""), k = x === m.length - 1, C = tl(b, `

`) || k && y;
      y = C;
      const _ = d.inline, O = d.list;
      let N;
      d.list = !0, C ? (d.inline = !1, N = tx(b) + `

`) : (d.inline = !0, N = tx(b));
      const R = c(N, d);
      return d.inline = _, d.list = O, R;
    }), ordered: n, start: p };
  } };
}
const XMe = RegExp(`^\\[((?:\\[[^\\[\\]]*(?:\\[[^\\[\\]]*\\][^\\[\\]]*)*\\]|[^\\[\\]])*)\\]\\(\\s*<?((?:\\([^)]*\\)|[^\\s\\\\]|\\\\.)*?)>?(?:\\s+['"]([\\s\\S]*?)['"])?\\s*\\)`), YMe = /^!\[(.*?)\]\( *((?:\([^)]*\)|[^() ])*) *"?([^)"]*)?"?\)/;
function AI(e) {
  return typeof e == "string";
}
function tx(e) {
  let t = e.length;
  for (; t > 0 && e[t - 1] <= " "; ) t--;
  return e.slice(0, t);
}
function c3(e, t) {
  return e.startsWith(t);
}
function tl(e, t) {
  return e.indexOf(t) !== -1;
}
function QMe(e, t, n) {
  if (Array.isArray(n)) {
    for (let r = 0; r < n.length; r++) if (c3(e, n[r])) return !0;
    return !1;
  }
  return n(e, t);
}
function bw(e) {
  return e.replace(/[]/g, "a").replace(/[]/g, "c").replace(/[]/g, "d").replace(/[]/g, "e").replace(/[]/g, "i").replace(/[]/g, "n").replace(/[]/g, "o").replace(/[]/g, "u").replace(/[]/g, "y").replace(/[^a-z0-9- ]/gi, "").replace(/ /gi, "-").toLowerCase();
}
function JMe(e) {
  return LMe.test(e) ? "right" : $Me.test(e) ? "center" : TMe.test(e) ? "left" : null;
}
function jI(e, t, n, r) {
  const a = n.inTable;
  n.inTable = !0;
  let s = [[]], l = "";
  function c() {
    if (!l) return;
    const d = s[s.length - 1];
    d.push.apply(d, t(l, n)), l = "";
  }
  return e.trim().split(/(`[^`]*`|\\\||\|)/).filter(Boolean).forEach((d, p, m) => {
    d.trim() === "|" && (c(), r) ? p !== 0 && p !== m.length - 1 && s.push([]) : l += d;
  }), c(), n.inTable = a, s;
}
function ZMe(e, t, n) {
  n.inline = !0;
  const r = e[2] ? e[2].replace(DMe, "").split("|").map(JMe) : [], a = e[3] ? (function(l, c, d) {
    return l.trim().split(`
`).map(function(p) {
      return jI(p, c, d, !0);
    });
  })(e[3], t, n) : [], s = jI(e[1], t, n, !!a.length);
  return n.inline = !1, a.length ? { align: r, cells: a, header: s, type: "25" } : { children: s, type: "21" };
}
function PI(e, t) {
  return e.align[t] == null ? {} : { textAlign: e.align[t] };
}
function Qc(e) {
  return e.inline = 1, e;
}
function Bc(e) {
  return Qc(function(t, n) {
    return n.inline ? e.exec(t) : null;
  });
}
function n0(e) {
  return Qc(function(t, n) {
    return n.inline || n.simple ? e.exec(t) : null;
  });
}
function sc(e) {
  return function(t, n) {
    return n.inline || n.simple ? null : e.exec(t);
  };
}
function DI(e) {
  return Qc(function(t) {
    return e.exec(t);
  });
}
const eNe = /(javascript|vbscript|data(?!:image)):/i;
function tNe(e) {
  try {
    const t = decodeURIComponent(e).replace(/[^A-Za-z0-9/:]/g, "");
    if (eNe.test(t)) return null;
  } catch {
    return null;
  }
  return e;
}
function rl(e) {
  return e && e.replace(FMe, "$1");
}
function U0(e, t, n) {
  const r = n.inline || !1, a = n.simple || !1;
  n.inline = !0, n.simple = !0;
  const s = e(t, n);
  return n.inline = r, n.simple = a, s;
}
function nNe(e, t, n) {
  const r = n.inline || !1, a = n.simple || !1;
  n.inline = !1, n.simple = !0;
  const s = e(t, n);
  return n.inline = r, n.simple = a, s;
}
function rNe(e, t, n) {
  const r = n.inline || !1;
  n.inline = !1;
  const a = e(t, n);
  return n.inline = r, a;
}
const oNe = (e, t, n) => ({ children: U0(t, e[2], n) });
function mN() {
  return {};
}
function aNe(...e) {
  return e.filter(Boolean).join(" ");
}
function hN(e, t, n) {
  let r = e;
  const a = t.split(".");
  for (; a.length && (r = r[a[0]], r !== void 0); ) a.shift();
  return r || n;
}
function gN(e, t, n, r) {
  if (!t || !t.trim()) return null;
  const a = t.match(sMe);
  return a ? a.reduce(function(s, l) {
    const c = l.indexOf("=");
    if (c !== -1) {
      const d = (function(h) {
        return h.indexOf("-") !== -1 && h.match(kMe) === null && (h = h.replace(OMe, function(v, y) {
          return y.toUpperCase();
        })), h;
      })(l.slice(0, c)).trim(), p = wI[d] || d;
      if (p === "ref") return s;
      const m = s[p] = (function(h, v, y, w) {
        return v === "style" ? (function(x) {
          const b = [];
          if (!x) return b;
          let k = "", C = 0, _ = "";
          for (let N = 0; N < x.length; N++) {
            const R = x[N];
            if (R === '"' || R === "'") _ ? R === _ && (_ = "", C--) : (_ = R, C++);
            else if (R === "(" && k.endsWith("url")) C++;
            else if (R === ")" && C > 0) C--;
            else if (R === ";" && C === 0) {
              const j = k.indexOf(":");
              j > 0 && b.push([k.slice(0, j).trim(), k.slice(j + 1).trim()]), k = "";
              continue;
            }
            k += R;
          }
          const O = k.indexOf(":");
          return O > 0 && b.push([k.slice(0, O).trim(), k.slice(O + 1).trim()]), b;
        })(y).reduce(function(x, [b, k]) {
          return x[b.replace(/(-[a-z])/g, (C) => C[1].toUpperCase())] = w(k, h, b), x;
        }, {}) : iMe.indexOf(v) !== -1 ? w(rl(y), h, v) : (y.match(_Me) && (y = rl(y.slice(1, y.length - 1))), y === "true" || y !== "false" && y);
      })(e, d, (function(h) {
        const v = h[0];
        return (v === '"' || v === "'") && h.length >= 2 && h[h.length - 1] === v ? h.slice(1, -1) : h;
      })(l.slice(c + 1).trim()), n);
      typeof m == "string" && (u4.test(m) || u3.test(m)) && (s[p] = r(m.trim()));
    } else l !== "style" && (s[wI[l] || l] = !0);
    return s;
  }, {}) : null;
}
function $I(e, t) {
  for (let n = 0; n < e.length; n++) if (e[n].test(t)) return !0;
  return !1;
}
function iNe(e = "", t = {}) {
  t.overrides = t.overrides || {}, t.namedCodesToUnicode = t.namedCodesToUnicode ? ul({}, xI, t.namedCodesToUnicode) : xI;
  const n = t.slugify || bw, r = t.sanitizer || tNe, a = t.createElement || M.createElement, s = [SI, kI, _I, t.enforceAtxHeadings ? CI : EI, OI, NI, gq, vq], l = [...s, MMe, u4, MI, u3];
  function c(w, x, ...b) {
    const k = hN(t.overrides, w + ".props", {});
    return a((function(C, _) {
      const O = hN(_, C);
      return O ? typeof O == "function" || typeof O == "object" && "render" in O ? O : hN(_, C + ".component", C) : C;
    })(w, t.overrides), ul({}, x, k, { className: aNe(x?.className, k.className) || void 0 }), ...b);
  }
  function d(w) {
    w = w.replace(bMe, "");
    let x = !1;
    t.forceInline ? x = !0 : t.forceBlock || (x = jMe.test(w) === !1);
    const b = v(x ? w : tx(w).replace(UMe, "") + `

`, { inline: x });
    if (t.ast) return b;
    const k = y(b);
    for (; AI(k[k.length - 1]) && !k[k.length - 1].trim(); ) k.pop();
    if (p.length && k.push(c("footer", { key: "footer" }, p.map(function(O) {
      return c("div", { id: n(O.identifier, bw), key: O.identifier }, O.identifier, y(v(O.footnote, { inline: !0 })));
    }))), t.wrapper === null) return k;
    const C = t.wrapper || (x ? "span" : "div");
    let _;
    if (k.length > 1 || t.forceWrapper) _ = k;
    else {
      if (k.length === 1) return _ = k[0], typeof _ == "string" ? c("span", { key: "outer" }, _) : _;
      _ = null;
    }
    return a(C, ul({ key: "outer" }, t.wrapperProps), _);
  }
  const p = [], m = {}, h = { 0: { t: [">"], o: sc(SI), u: 1, i(w, x, b) {
    const [, k, C] = w[0].replace(uMe, "").match(cMe);
    return { alert: k, children: x(C, b) };
  } }, 1: { t: ["  "], o: Bc(dMe), u: 1, i: mN }, 2: { t: function(w, x) {
    if (x.inline || x.simple) return !1;
    var b = w[0];
    return b === "-" || b === "*" || b === "_";
  }, o: sc(fMe), u: 1, i: mN }, 3: { t: ["    "], o: sc(_I), u: 0, i: (w) => ({ lang: void 0, text: rl(tx(w[0].replace(/^ {4}/gm, ""))) }) }, 4: { t: ["```", "~~~"], o: sc(kI), u: 0, i: (w) => ({ attrs: gN("code", w[3] || "", r, d), lang: w[2] || void 0, text: w[4], type: "3" }) }, 5: { t: ["`"], o: n0(pMe), u: 3, i: (w) => ({ text: rl(w[2]) }) }, 6: { t: ["[^"], o: sc(gMe), u: 0, i: (w) => (p.push({ footnote: w[2], identifier: w[1] }), {}) }, 7: { t: ["[^"], o: Bc(vMe), u: 1, i: (w) => ({ target: "#" + n(w[1], bw), text: w[1] }) }, 8: { t: ["[ ]", "[x]"], o: Bc(wMe), u: 1, i: (w) => ({ completed: w[1].toLowerCase() === "x" }) }, 9: { t: ["#"], o: sc(t.enforceAtxHeadings ? CI : EI), u: 1, i: (w, x, b) => ({ children: U0(x, w[2], b), id: n(w[2], bw), level: w[1].length }) }, 10: { t: (w) => {
    const x = w.indexOf(`
`);
    return x > 0 && x < w.length - 1 && (w[x + 1] === "=" || w[x + 1] === "-");
  }, o: sc(OI), u: 1, i: (w, x, b) => ({ children: U0(x, w[1], b), level: w[2] === "=" ? 1 : 2, type: "9" }) }, 11: { t: ["<"], o: Qc(xMe), u: 1, i(w, x, b) {
    const [, k] = w[3].match(VMe), C = RegExp("^" + k, "gm"), _ = w[3].replace(C, ""), O = $I(l, _) ? rNe : U0, N = w[1].toLowerCase(), R = aMe.indexOf(N) !== -1, j = (R ? N : w[1]).trim(), D = { attrs: gN(j, w[2], r, d), noInnerParse: R, tag: j };
    if (b.inAnchor = b.inAnchor || N === "a", R) D.text = w[3];
    else {
      const $ = b.inHTML;
      b.inHTML = !0, D.children = O(x, _, b), b.inHTML = $;
    }
    return b.inAnchor = !1, D;
  } }, 13: { t: ["<"], o: DI(u3), u: 1, i(w) {
    const x = w[1].trim();
    return { attrs: gN(x, w[2] || "", r, d), tag: x };
  } }, 12: { t: ["<!--"], o: DI(MI), u: 1, i: () => ({}) }, 14: { t: ["!["], o: n0(YMe), u: 1, i: (w) => ({ alt: rl(w[1]), target: rl(w[2]), title: rl(w[3]) }) }, 15: { t: ["["], o: Bc(XMe), u: 3, i: (w, x, b) => ({ children: nNe(x, w[1], b), target: rl(w[2]), title: rl(w[3]) }) }, 16: { t: function(w, x) {
    return !(!x.inline || x.inAnchor) && w[0] === "<" && (tl(w, ":") || tl(w, "@") || tl(w, "/"));
  }, o: Bc(CMe), u: 0, i(w) {
    let x = w[1], b = !1;
    return tl(x, "@") && !tl(x, "//") && (b = !0, x = x.replace("mailto:", "")), { children: [{ text: x, type: "27" }], target: b ? "mailto:" + x : x, type: "15" };
  } }, 17: { t: (w, x) => !x.inAnchor && !t.disableAutoLink && c3(w, "http"), o: Bc(EMe), u: 0, i: (w) => ({ children: [{ text: w[1], type: "27" }], target: w[1], title: void 0, type: "15" }) }, 20: RI(0, 1), 30: RI(0, 2), 19: { t: [`
`], o: sc(mMe), u: 3, i: mN }, 21: { t: function(w, x) {
    return !x.inline && !x.simple;
  }, o: Qc(function(w, x) {
    if (x.inline || x.simple || x.inHTML && !tl(w, `

`) && !tl(x.prevCapture, `

`)) return null;
    let b = "", k = 0;
    for (; ; ) {
      const _ = w.indexOf(`
`, k), O = w.slice(k, _ === -1 ? void 0 : _ + 1), N = w[k];
      if ((N === ">" || N === "#" || N === "|" || N === "`" || N === "~" || N === "*" || N === "-" || N === "_" || N === " ") && $I(s, O) || (b += O, _ === -1 || !O.trim())) break;
      k = _ + 1;
    }
    const C = tx(b);
    return C === "" ? null : [b, , C];
  }), u: 3, i: oNe }, 22: { t: ["["], o: Bc(NMe), u: 0, i: (w) => (m[w[1]] = { target: w[2], title: w[4] }, {}) }, 23: { t: ["!["], o: n0(RMe), u: 0, i: (w) => ({ alt: w[1] ? rl(w[1]) : void 0, ref: w[2] }) }, 24: { t: (w) => w[0] === "[" && !tl(w, "]("), o: Bc(AMe), u: 0, i: (w, x, b) => ({ children: x(w[1], b), fallbackChildren: w[0], ref: w[2] }) }, 25: { t: ["|"], o: sc(NI), u: 1, i: ZMe }, 27: { o: Qc(function(w, x) {
    let b;
    return c3(w, ":") && (b = IMe.exec(w)), b || BMe.exec(w);
  }), u: 4, i(w) {
    const x = w[0];
    return { text: tl(x, "&") ? x.replace(SMe, (b, k) => t.namedCodesToUnicode[k] || b) : x };
  } }, 34: { t: ["*", "_", "~", "="], o: Qc(rMe), u: 2, i: (w, x, b) => ({ children: x(w[2], b), tag: w[1] }) }, 28: { t: ["\\"], o: n0(zMe), u: 1, i: (w) => ({ text: w[1], type: "27" }) } };
  t.disableParsingRawHTML === !0 && (delete h[11], delete h[13]);
  const v = (function(w) {
    var x = Object.keys(w);
    function b(k, C) {
      var _ = [];
      if (C.prevCapture = C.prevCapture || "", k.trim()) for (; k; ) for (var O = 0; O < x.length; ) {
        var N = x[O], R = w[N];
        if (!R.t || QMe(k, C, R.t)) {
          var j = R.o(k, C);
          if (j && j[0]) {
            k = k.substring(j[0].length);
            var D = R.i(j, b, C);
            C.prevCapture += j[0], D.type || (D.type = N), _.push(D);
            break;
          }
          O++;
        } else O++;
      }
      return C.prevCapture = "", _;
    }
    return x.sort(function(k, C) {
      return w[k].u - w[C].u || (k < C ? -1 : 1);
    }), function(k, C) {
      return b((function(_) {
        return _.replace(hMe, `
`).replace(yMe, "").replace(PMe, "    ");
      })(k), C);
    };
  })(h), y = /* @__PURE__ */ (function(w, x, b, k, C) {
    function _(O) {
      return Array.isArray(O) ? O.map((N) => "text" in N ? N.text : "") : "text" in O ? O.text : "";
    }
    return function O(N, R = {}) {
      const j = (R.renderDepth || 0) + 1;
      if (j > 2500) return _(N);
      R.renderDepth = j;
      try {
        if (Array.isArray(N)) {
          const $ = R.key, z = [];
          let B = !1;
          for (let P = 0; P < N.length; P++) {
            R.key = P;
            const W = O(N[P], R), I = AI(W);
            I && B ? z[z.length - 1] += W : W !== null && z.push(W), B = I;
          }
          return R.key = $, R.renderDepth = j - 1, z;
        }
        const D = (function($, z, B) {
          const P = () => (function(W, I, G, L, K, q, Z) {
            switch (W.type) {
              case "0": {
                const V = { key: G.key };
                return W.alert && (V.className = "markdown-alert-" + q(W.alert.toLowerCase(), bw), W.children.unshift({ attrs: {}, children: [{ type: "27", text: W.alert }], noInnerParse: !0, type: "11", tag: "header" })), L("blockquote", V, I(W.children, G));
              }
              case "1":
                return L("br", { key: G.key });
              case "2":
                return L("hr", { key: G.key });
              case "3":
                return L("pre", { key: G.key }, L("code", ul({}, W.attrs, { className: W.lang ? "lang-" + W.lang : "" }), W.text));
              case "5":
                return L("code", { key: G.key }, W.text);
              case "7":
                return L("a", { key: G.key, href: K(W.target, "a", "href") }, L("sup", { key: G.key }, W.text));
              case "8":
                return L("input", { checked: W.completed, key: G.key, readOnly: !0, type: "checkbox" });
              case "9":
                return L("h" + W.level, { id: W.id, key: G.key }, I(W.children, G));
              case "11":
                return L(W.tag, ul({ key: G.key }, W.attrs), W.text || (W.children ? I(W.children, G) : ""));
              case "13":
                return L(W.tag, ul({}, W.attrs, { key: G.key }));
              case "14":
                return L("img", { key: G.key, alt: W.alt || void 0, title: W.title || void 0, src: K(W.target, "img", "src") });
              case "15":
                return L("a", { key: G.key, href: K(W.target, "a", "href"), title: W.title }, I(W.children, G));
              case "23":
                return Z[W.ref] ? L("img", { key: G.key, alt: W.alt, src: K(Z[W.ref].target, "img", "src"), title: Z[W.ref].title }) : null;
              case "24":
                return Z[W.ref] ? L("a", { key: G.key, href: K(Z[W.ref].target, "a", "href"), title: Z[W.ref].title }, I(W.children, G)) : L("span", { key: G.key }, W.fallbackChildren);
              case "25": {
                const V = W;
                return L("table", { key: G.key }, L("thead", null, L("tr", null, V.header.map(function(F, X) {
                  return L("th", { key: X, style: PI(V, X) }, I(F, G));
                }))), L("tbody", null, V.cells.map(function(F, X) {
                  return L("tr", { key: X }, F.map(function(U, H) {
                    return L("td", { key: H, style: PI(V, H) }, I(U, G));
                  }));
                })));
              }
              case "27":
                return W.text;
              case "34":
                return L(W.tag, { key: G.key }, I(W.children, G));
              case "20":
              case "30":
                return L(W.ordered ? "ol" : "ul", { key: G.key, start: W.type === "20" ? W.start : void 0 }, W.items.map(function(V, F) {
                  return L("li", { key: F }, I(V, G));
                }));
              case "19":
                return `
`;
              case "21":
                return L("p", { key: G.key }, I(W.children, G));
              default:
                return null;
            }
          })($, z, B, x, b, k, C);
          return w ? w(P, $, z, B) : P();
        })(N, O, R);
        return R.renderDepth = j - 1, D;
      } catch (D) {
        if (D instanceof RangeError && D.message.includes("Maximum call stack")) return _(N);
        throw D;
      }
    };
  })(t.renderRule, c, r, n, m);
  return d(e);
}
const AS = (e) => {
  let { children: t, options: n } = e, r = (function(a, s) {
    if (a == null) return {};
    var l = {};
    for (var c in a) if ({}.hasOwnProperty.call(a, c)) {
      if (s.indexOf(c) !== -1) continue;
      l[c] = a[c];
    }
    return l;
  })(e, oMe);
  return iNe(t ?? "", ul({}, n, { wrapperProps: ul({}, n?.wrapperProps, r) }));
}, yq = /* @__PURE__ */ Symbol("remove-this-key"), TI = /* @__PURE__ */ Symbol("reset");
function sNe(e, t) {
  return Array.isArray(e.required) && e.required.indexOf(t) !== -1;
}
function lNe(e, t) {
  switch (t) {
    case "array":
      return [];
    case "boolean":
      return !1;
    case "null":
      return null;
    case "number":
      return 0;
    case "object":
      return {};
    default:
      return e(Gt.NewStringDefault);
  }
}
function uNe(e) {
  const { fieldPathId: t, schema: n, registry: r, uiSchema: a, errorSchema: s, formData: l, onChange: c, onBlur: d, onFocus: p, disabled: m, readonly: h, required: v, hideError: y, propertyName: w, handleKeyRename: x, handleRemoveProperty: b, addedByAdditionalProperties: k } = e, [C, _] = M.useState(!1), { globalFormOptions: O, fields: N } = r, { SchemaField: R } = N, j = jm(Li(w, O, t.path)), D = M.useCallback((P, W, I, G) => {
    P === void 0 && k && (P = ""), c(P, W, I, G);
  }, [c, k]), $ = M.useCallback((P) => {
    w !== P && _(!0), x(w, P);
  }, [w, x]), z = M.useCallback((P) => {
    const { target: { value: W } } = P;
    $(W);
  }, [$]), B = M.useCallback(() => {
    b(w);
  }, [w, b]);
  return E.jsx(R, { name: w, required: v, schema: n, uiSchema: a, errorSchema: s, fieldPathId: j, formData: l, wasPropertyKeyModified: C, onKeyRename: $, onKeyRenameBlur: z, onRemoveProperty: B, onChange: D, onBlur: d, onFocus: p, registry: r, disabled: m, readonly: h, hideError: y });
}
function cNe(e) {
  const { schema: t, uiSchema: n = {}, formData: r, errorSchema: a, fieldPathId: s, name: l, required: c = !1, disabled: d, readonly: p, hideError: m, onBlur: h, onFocus: v, onChange: y, registry: w, title: x } = e, { fields: b, schemaUtils: k, translateString: C, globalUiOptions: _ } = w, { OptionalDataControlsField: O } = b, N = k.retrieveSchema(t, r, !0), R = ht(n, _), { properties: j = {} } = N, D = e.childFieldPathId ?? s, $ = R.title ?? N.title ?? x ?? l, z = R.description ?? N.description, B = RS(w, N, c, n), P = dg(r);
  let W = [];
  const I = M.useCallback((F, X) => {
    const { duplicateKeySuffixSeparator: U = "-" } = ht(n, _);
    let H = 0, Q = F;
    for (; Zt(X, Q); )
      Q = `${F}${U}${++H}`;
    return Q;
  }, [n, _]), G = M.useCallback(() => {
    if (!(N.additionalProperties || N.patternProperties))
      return;
    const { translateString: F } = w, X = { ...r }, U = I("newKey", X);
    if (N.patternProperties)
      Pn(X, U, null);
    else {
      let H, Q, re;
      if (cn(N.additionalProperties)) {
        H = N.additionalProperties.type, Q = N.additionalProperties.const, re = N.additionalProperties.default;
        let le = N.additionalProperties;
        if (sr in le) {
          const { schemaUtils: me } = w;
          le = me.retrieveSchema({ [sr]: le[sr] }, r), H = le.type, Q = le.const, re = le.default;
        }
        !H && (sn in le || Ht in le) && (H = "object");
      }
      const de = Q ?? re ?? lNe(F, H);
      Pn(X, U, de);
    }
    y(X, D.path);
  }, [r, y, w, D, I, N]), L = M.useCallback((F, X) => {
    if (F !== X) {
      const U = I(X, r), H = {
        ...r
      }, Q = { [F]: U }, re = Object.keys(H).map((le) => ({ [Q[le] || le]: H[le] })), de = Object.assign({}, ...re);
      y(de, D.path);
    }
  }, [r, y, D, I]), K = M.useCallback((F) => {
    y(yq, [...D.path, F]);
  }, [y, D]);
  if (!B || P)
    try {
      const F = Object.keys(j);
      W = TEe(F, R.order);
    } catch (F) {
      return E.jsxs("div", { children: [E.jsx("p", { className: "rjsf-config-error", style: { color: "red" }, children: E.jsx(AS, { options: { disableParsingRawHTML: !0 }, children: C(Gt.InvalidObjectField, [l || "root", F.message]) }) }), E.jsx("pre", { children: JSON.stringify(N) })] });
    }
  const q = bt("ObjectFieldTemplate", w, R), Z = B ? E.jsx(O, { ...e, fieldPathId: D, schema: N }) : void 0, V = {
    // getDisplayLabel() always returns false for object types, so just check the `uiOptions.label`
    title: R.label === !1 ? "" : $,
    description: R.label === !1 ? void 0 : z,
    properties: W.map((F) => {
      const X = Zt(N, [fn, F, hc]), U = X ? n.additionalProperties : n[F], H = ht(U).widget === "hidden";
      return {
        content: E.jsx(uNe, { propertyName: F, required: sNe(N, F), schema: Ae(N, [fn, F], {}), uiSchema: U, errorSchema: Ae(a, [F]), fieldPathId: D, formData: Ae(r, [F]), handleKeyRename: L, handleRemoveProperty: K, addedByAdditionalProperties: X, onChange: y, onBlur: h, onFocus: v, registry: w, disabled: d, readonly: p, hideError: m }, F),
        name: F,
        readonly: p,
        disabled: d,
        required: c,
        hidden: H
      };
    }),
    readonly: p,
    disabled: d,
    required: c,
    fieldPathId: s,
    uiSchema: n,
    errorSchema: a,
    schema: N,
    formData: r,
    registry: w,
    optionalDataControl: Z,
    className: B ? "rjsf-optional-object-field" : void 0
  };
  return E.jsx(q, { ...V, onAddProperty: G });
}
function dNe(e) {
  const { schema: t, uiSchema: n = {}, formData: r, disabled: a = !1, readonly: s = !1, onChange: l, errorSchema: c, fieldPathId: d, registry: p } = e, { globalUiOptions: m = {}, schemaUtils: h, translateString: v } = p, y = ht(n, m), w = bt("OptionalDataControlsTemplate", p, y), x = dg(r);
  let b, k, C, _;
  if (a || s)
    b = aN(d, "Msg"), k = x ? void 0 : v(Gt.OptionalObjectEmptyMsg);
  else {
    const O = x ? Gt.OptionalObjectRemove : Gt.OptionalObjectAdd;
    k = v(O), x ? (b = aN(d, "Remove"), _ = () => l(void 0, d.path, c)) : (b = aN(d, "Add"), C = () => {
      let N = h.getDefaultFormState(t, r, "excludeObjectChildren");
      N === void 0 && (N = Vs(t) === "array" ? [] : {}), l(N, d.path, c);
    });
  }
  return k && E.jsx(w, { id: b, registry: p, schema: t, uiSchema: n, label: k, onAddClick: C, onRemoveClick: _ });
}
const fNe = {
  array: "ArrayField",
  boolean: "BooleanField",
  integer: "NumberField",
  number: "NumberField",
  object: "ObjectField",
  string: "StringField",
  null: "NullField"
};
function pNe(e, t, n) {
  const r = t.field, { fields: a } = n;
  if (typeof r == "function")
    return r;
  if (typeof r == "string" && r in a)
    return a[r];
  const s = Vs(e), l = Array.isArray(s) ? s[0] : s || "", c = e.$id;
  let d = fNe[l];
  return c && c in a && (d = c), !d && (e.anyOf || e.oneOf) ? () => null : d in a ? a[d] : a.FallbackField;
}
function mNe(e) {
  const { schema: t, fieldPathId: n, uiSchema: r, formData: a, errorSchema: s, name: l, onChange: c, onKeyRename: d, onKeyRenameBlur: p, onRemoveProperty: m, required: h = !1, registry: v, wasPropertyKeyModified: y = !1 } = e, { schemaUtils: w, globalFormOptions: x, globalUiOptions: b, fields: k } = v, { AnyOfField: C, OneOfField: _ } = k, O = ht(r, b), N = bt("FieldTemplate", v, O), R = bt("DescriptionFieldTemplate", v, O), j = bt("FieldHelpTemplate", v, O), D = bt("FieldErrorTemplate", v, O), $ = w.retrieveSchema(t, a), z = n[$n], B = M.useCallback((_e, We, Xe, et) => c(_e, We, Xe, et || z), [z, c]), P = pNe($, O, v), W = !!(O.disabled ?? e.disabled), I = !!(O.readonly ?? (e.readonly || e.schema.readOnly || $.readOnly)), G = O.hideError, L = G === void 0 ? e.hideError : !!G, K = !!(O.autofocus ?? e.autofocus);
  if (Object.keys($).length === 0)
    return null;
  let q = w.getDisplayLabel($, r, b);
  const Z = O.field && O.fieldReplacesAnyOrOneOf === !0;
  let V, F, X = { fieldPathId: n };
  if ((sn in $ || Ht in $) && !Z && !w.isSelect($)) {
    $[sn] ? (V = C, F = $[sn].map((Xe) => w.retrieveSchema(cn(Xe) ? Xe : {}, a))) : $[Ht] && (V = _, F = $[Ht].map((Xe) => w.retrieveSchema(cn(Xe) ? Xe : {}, a)));
    const _e = RS(v, $, h, r), We = dg(a);
    q = q && (!_e || We), X = {
      childFieldPathId: n,
      // The main FieldComponent will add `XxxOf` onto the fieldPathId to avoid duplication with the rendering of the
      // same FieldComponent by the `XxxOfField`
      fieldPathId: Li("XxxOf", x, n)
    };
  }
  const { __errors: U, ...H } = s || {}, Q = $x(r, ["ui:classNames", "classNames", "ui:style"]);
  Zc in Q && (Q[Zc] = $x(Q[Zc], ["classNames", "style"]));
  const re = E.jsx(P, { ...e, onChange: B, ...X, schema: $, uiSchema: Q, disabled: W, readonly: I, hideError: L, autofocus: K, errorSchema: H, rawErrors: U }), de = n[$n];
  let le;
  y ? le = l : le = hc in $ ? l : O.title || e.schema.title || $.title || e.title || l;
  const me = O.description || e.schema.description || $.description || "", ve = O.help, ae = O.widget === "hidden", se = ["rjsf-field", `rjsf-field-${Vs($)}`];
  !L && U && U.length > 0 && se.push("rjsf-field-error"), O.classNames && se.push(O.classNames);
  const pe = E.jsx(j, { help: ve, fieldPathId: n, schema: $, uiSchema: r, hasErrors: !L && U && U.length > 0, registry: v }), ge = L || V && !w.isSelect($) ? void 0 : E.jsx(D, { errors: U, errorSchema: s, fieldPathId: n, schema: $, uiSchema: r, registry: v }), xe = {
    description: E.jsx(R, { id: Rm(de), description: me, schema: $, uiSchema: r, registry: v }),
    rawDescription: me,
    help: pe,
    rawHelp: typeof ve == "string" ? ve : void 0,
    errors: ge,
    rawErrors: L ? void 0 : U,
    id: de,
    label: le,
    hidden: ae,
    onChange: c,
    onKeyRename: d,
    onKeyRenameBlur: p,
    onRemoveProperty: m,
    required: h,
    disabled: W,
    readonly: I,
    hideError: L,
    displayLabel: q,
    classNames: se.join(" ").trim(),
    style: O.style,
    formData: a,
    schema: $,
    uiSchema: r,
    registry: v
  };
  return E.jsx(N, { ...xe, children: E.jsxs(E.Fragment, { children: [re, V && E.jsx(V, { name: l, disabled: W, readonly: I, hideError: L, errorSchema: s, formData: a, fieldPathId: n, onBlur: e.onBlur, onChange: e.onChange, onFocus: e.onFocus, options: F, registry: v, required: h, schema: $, uiSchema: r })] }) });
}
class hNe extends M.Component {
  shouldComponentUpdate(t) {
    const { registry: { globalFormOptions: n } } = this.props, { experimental_componentUpdateStrategy: r = "customDeep" } = n;
    return KH(this, t, this.state, r);
  }
  render() {
    return E.jsx(mNe, { ...this.props });
  }
}
function gNe(e) {
  const { schema: t, name: n, uiSchema: r, fieldPathId: a, formData: s, required: l, disabled: c = !1, readonly: d = !1, autofocus: p = !1, onChange: m, onBlur: h, onFocus: v, registry: y, rawErrors: w, hideError: x, title: b } = e, { title: k, format: C } = t, { widgets: _, schemaUtils: O, globalUiOptions: N } = y, R = O.isSelect(t) ? Gh(t, r) : void 0;
  let j = R ? "select" : "text";
  C && PEe(t, C, _) && (j = C);
  const { widget: D = j, placeholder: $ = "", title: z, ...B } = ht(r), P = O.getDisplayLabel(t, r, N), W = z ?? b ?? k ?? n, I = Rl(t, D, _), G = M.useCallback((L, K, q) => m(L, a.path, K, q), [m, a]);
  return E.jsx(I, { options: { ...B, enumOptions: R }, schema: t, uiSchema: r, id: a.$id, name: n, label: W, hideLabel: !P, hideError: x, value: s, onChange: G, onBlur: h, onFocus: v, required: l, disabled: c, readonly: d, autofocus: p, registry: y, placeholder: $, rawErrors: w, htmlName: a.name });
}
function vNe(e) {
  const { formData: t, onChange: n, fieldPathId: r } = e;
  return M.useEffect(() => {
    t === void 0 && n(null, r.path);
  }, [r, t, n]), null;
}
function yNe() {
  return {
    AnyOfField: yI,
    ArrayField: COe,
    // ArrayField falls back to SchemaField if ArraySchemaField is not defined, which it isn't by default
    BooleanField: OOe,
    FallbackField: AOe,
    LayoutGridField: l4,
    LayoutHeaderField: QOe,
    LayoutMultiSchemaField: JOe,
    NumberField: tMe,
    ObjectField: cNe,
    OneOfField: yI,
    OptionalDataControlsField: dNe,
    SchemaField: hNe,
    StringField: gNe,
    NullField: vNe
  };
}
function bNe(e) {
  const { fieldPathId: t, description: n, registry: r, schema: a, uiSchema: s } = e, l = ht(s, r.globalUiOptions), { label: c = !0 } = l;
  if (!n || !c)
    return null;
  const d = bt("DescriptionFieldTemplate", r, l);
  return E.jsx(d, { id: Rm(t), description: n, schema: a, uiSchema: s, registry: r });
}
function wNe(e) {
  const { children: t, className: n, buttonsProps: r, displayLabel: a, hasDescription: s, hasToolbar: l, registry: c, uiSchema: d } = e, p = ht(d), m = bt("ArrayFieldItemButtonsTemplate", c, p), h = {
    flex: 1,
    paddingLeft: 6,
    paddingRight: 6,
    fontWeight: "bold"
  }, v = s ? 31 : 9, y = { display: "flex", alignItems: a ? "center" : "baseline" }, w = { display: "flex", justifyContent: "flex-end", marginTop: a ? `${v}px` : 0 };
  return E.jsxs("div", { className: n, style: y, children: [E.jsx("div", { className: l ? "col-xs-9 col-md-10 col-xl-11" : "col-xs-12", children: t }), l && E.jsx("div", { className: "col-xs-3 col-md-2 col-xl-1 array-item-toolbox", children: E.jsx("div", { className: "btn-group", style: w, children: E.jsx(m, { ...r, style: h }) }) })] });
}
function xNe(e) {
  const { disabled: t, hasCopy: n, hasMoveDown: r, hasMoveUp: a, hasRemove: s, fieldPathId: l, onCopyItem: c, onRemoveItem: d, onMoveDownItem: p, onMoveUpItem: m, readonly: h, registry: v, uiSchema: y } = e, { CopyButton: w, MoveDownButton: x, MoveUpButton: b, RemoveButton: k } = v.templates.ButtonTemplates;
  return E.jsxs(E.Fragment, { children: [(a || r) && E.jsx(b, { id: vl(l, "moveUp"), className: "rjsf-array-item-move-up", disabled: t || h || !a, onClick: m, uiSchema: y, registry: v }), (a || r) && E.jsx(x, { id: vl(l, "moveDown"), className: "rjsf-array-item-move-down", disabled: t || h || !r, onClick: p, uiSchema: y, registry: v }), n && E.jsx(w, { id: vl(l, "copy"), className: "rjsf-array-item-copy", disabled: t || h, onClick: c, uiSchema: y, registry: v }), s && E.jsx(k, { id: vl(l, "remove"), className: "rjsf-array-item-remove", disabled: t || h, onClick: d, uiSchema: y, registry: v })] });
}
function SNe(e) {
  const { canAdd: t, className: n, disabled: r, fieldPathId: a, uiSchema: s, items: l, optionalDataControl: c, onAddClick: d, readonly: p, registry: m, required: h, schema: v, title: y } = e, w = ht(s), x = bt("ArrayFieldDescriptionTemplate", m, w), b = bt("ArrayFieldTitleTemplate", m, w), k = !p && !r, { ButtonTemplates: { AddButton: C } } = m.templates;
  return E.jsxs("fieldset", { className: n, id: a.$id, children: [E.jsx(b, { fieldPathId: a, title: w.title || y, required: h, schema: v, uiSchema: s, registry: m, optionalDataControl: k ? c : void 0 }), E.jsx(x, { fieldPathId: a, description: w.description || v.description, schema: v, uiSchema: s, registry: m }), k ? void 0 : c, E.jsx("div", { className: "row array-item-list", children: l }), t && E.jsx(C, { id: vl(a, "add"), className: "rjsf-array-item-add", onClick: d, disabled: r || p, uiSchema: s, registry: m })] });
}
function kNe(e) {
  const { fieldPathId: t, title: n, schema: r, uiSchema: a, required: s, registry: l, optionalDataControl: c } = e, d = ht(a, l.globalUiOptions), { label: p = !0 } = d;
  if (!n || !p)
    return null;
  const m = bt("TitleFieldTemplate", l, d);
  return E.jsx(m, { id: fE(t), title: n, required: s, schema: r, uiSchema: a, registry: l, optionalDataControl: c });
}
function _Ne(e) {
  const {
    id: t,
    name: n,
    // remove this from ...rest
    htmlName: r,
    value: a,
    readonly: s,
    disabled: l,
    autofocus: c,
    onBlur: d,
    onFocus: p,
    onChange: m,
    onChangeOverride: h,
    options: v,
    schema: y,
    uiSchema: w,
    registry: x,
    rawErrors: b,
    type: k,
    hideLabel: C,
    // remove this from ...rest
    hideError: _,
    // remove this from ...rest
    ...O
  } = e;
  if (!t)
    throw console.log("No id for", e), new Error(`no id for props ${JSON.stringify(e)}`);
  const N = {
    ...O,
    ...qH(y, k, v)
  };
  let R;
  N.type === "number" || N.type === "integer" ? R = a || a === 0 ? a : "" : R = a ?? "";
  const j = M.useCallback(({ target: { value: z } }) => m(z === "" ? v.emptyValue : z), [m, v]), D = M.useCallback(({ target: z }) => d(t, z && z.value), [d, t]), $ = M.useCallback(({ target: z }) => p(t, z && z.value), [p, t]);
  return E.jsxs(E.Fragment, { children: [E.jsx("input", { id: t, name: r || t, className: "form-control", readOnly: s, disabled: l, autoFocus: c, value: R, ...N, list: y.examples ? Fx(t) : void 0, onChange: h || j, onBlur: D, onFocus: $, "aria-describedby": _i(t, !!y.examples) }), Array.isArray(y.examples) && E.jsx("datalist", { id: Fx(t), children: y.examples.concat(y.default && !y.examples.includes(y.default) ? [y.default] : []).map((z) => E.jsx("option", { value: z }, z)) }, `datalist_${t}`)] });
}
function ENe({ uiSchema: e }) {
  const { submitText: t, norender: n, props: r = {} } = WH(e);
  return n ? null : E.jsx("div", { children: E.jsx("button", { type: "submit", ...r, className: `btn btn-info ${r.className || ""}`, children: t }) });
}
function bm(e) {
  const { iconType: t = "default", icon: n, className: r, uiSchema: a, registry: s, ...l } = e;
  return E.jsx("button", { type: "button", className: `btn btn-${t} ${r}`, ...l, children: E.jsx("i", { className: `glyphicon glyphicon-${n}` }) });
}
function CNe(e) {
  const { registry: { translateString: t } } = e;
  return E.jsx(bm, { title: t(Gt.CopyButton), ...e, icon: "copy" });
}
function ONe(e) {
  const { registry: { translateString: t } } = e;
  return E.jsx(bm, { title: t(Gt.MoveDownButton), ...e, icon: "arrow-down" });
}
function MNe(e) {
  const { registry: { translateString: t } } = e;
  return E.jsx(bm, { title: t(Gt.MoveUpButton), ...e, icon: "arrow-up" });
}
function NNe(e) {
  const { registry: { translateString: t } } = e;
  return E.jsx(bm, { title: t(Gt.RemoveButton), ...e, iconType: "danger", icon: "remove" });
}
function RNe({ id: e, className: t, onClick: n, disabled: r, registry: a }) {
  const { translateString: s } = a;
  return E.jsx("div", { className: "row", children: E.jsx("p", { className: `col-xs-4 col-sm-2 col-lg-1 col-xs-offset-8 col-sm-offset-10 col-lg-offset-11 text-right ${t}`, children: E.jsx(bm, { id: e, iconType: "info", icon: "plus", className: "btn-add col-xs-12", title: s(Gt.AddButton), onClick: n, disabled: r, registry: a }) }) });
}
function ANe() {
  return {
    SubmitButton: ENe,
    AddButton: RNe,
    CopyButton: CNe,
    MoveDownButton: ONe,
    MoveUpButton: MNe,
    RemoveButton: NNe
  };
}
const bq = ZA();
function f4({ description: e, registry: t, uiSchema: n = {} }) {
  const { globalUiOptions: r } = t;
  return ht(n, r).enableMarkdownInDescription && typeof e == "string" ? E.jsx(AS, { options: { disableParsingRawHTML: !0 }, "data-testid": bq.markdown, children: e }) : e;
}
f4.TEST_IDS = bq;
function jNe(e) {
  const { id: t, description: n, registry: r, uiSchema: a } = e;
  return n ? E.jsx("div", { id: t, className: "field-description", children: E.jsx(f4, { description: n, registry: r, uiSchema: a }) }) : null;
}
function PNe({ errors: e, registry: t }) {
  const { translateString: n } = t;
  return E.jsxs("div", { className: "panel panel-danger errors", children: [E.jsx("div", { className: "panel-heading", children: E.jsx("h3", { className: "panel-title", children: n(Gt.ErrorsLabel) }) }), E.jsx("ul", { className: "list-group", children: e.map((r, a) => E.jsx("li", { className: "list-group-item text-danger", children: r.stack }, a)) })] });
}
function DNe(e) {
  const { schema: t, registry: n, typeSelector: r, schemaField: a } = e, s = bt("MultiSchemaFieldTemplate", n);
  return E.jsx(s, { selector: r, optionSchemaField: a, schema: t, registry: n });
}
const $Ne = "*";
function wq(e) {
  const { label: t, required: n, id: r } = e;
  return t ? E.jsxs("label", { className: "control-label", htmlFor: r, children: [t, n && E.jsx("span", { className: "required", children: $Ne })] }) : null;
}
function TNe(e) {
  const { id: t, label: n, children: r, errors: a, help: s, description: l, hidden: c, required: d, displayLabel: p, registry: m, uiSchema: h } = e, v = ht(h), y = bt("WrapIfAdditionalTemplate", m, v);
  if (c)
    return E.jsx("div", { className: "hidden", children: r });
  const w = v.widget === "checkbox";
  return E.jsxs(y, { ...e, children: [p && !w && E.jsx(wq, { label: n, required: d, id: t }), p && l ? l : null, r, a, s] });
}
function LNe(e) {
  const { errors: t = [], fieldPathId: n } = e;
  if (t.length === 0)
    return null;
  const r = e4(n);
  return E.jsx("div", { children: E.jsx("ul", { id: r, className: "error-detail bs-callout bs-callout-info", children: t.filter((a) => !!a).map((a, s) => E.jsx("li", { className: "text-danger", children: a }, s)) }) });
}
const xq = ZA();
function p4({ help: e, registry: t, uiSchema: n = {} }) {
  const { globalUiOptions: r } = t;
  return ht(n, r).enableMarkdownInHelp && typeof e == "string" ? E.jsx(AS, { options: { disableParsingRawHTML: !0 }, "data-testid": xq.markdown, children: e }) : e;
}
p4.TEST_IDS = xq;
function INe(e) {
  const { fieldPathId: t, help: n, uiSchema: r, registry: a } = e;
  return n ? E.jsx("div", { id: t4(t), className: "help-block", children: E.jsx(p4, { help: n, registry: a, uiSchema: r }) }) : null;
}
function zNe(e) {
  const { children: t, column: n, className: r, ...a } = e;
  return E.jsx("div", { className: r, ...a, children: t });
}
function FNe(e) {
  const { selector: t, optionSchemaField: n } = e;
  return E.jsxs("div", { className: "panel panel-default panel-body", children: [E.jsx("div", { className: "form-group", children: t }), n] });
}
function BNe(e) {
  const { className: t, description: n, disabled: r, formData: a, fieldPathId: s, onAddProperty: l, optionalDataControl: c, properties: d, readonly: p, registry: m, required: h, schema: v, title: y, uiSchema: w } = e, x = ht(w), b = bt("TitleFieldTemplate", m, x), k = bt("DescriptionFieldTemplate", m, x), C = !p && !r, { ButtonTemplates: { AddButton: _ } } = m.templates;
  return E.jsxs("fieldset", { className: t, id: s.$id, children: [y && E.jsx(b, { id: fE(s), title: y, required: h, schema: v, uiSchema: w, registry: m, optionalDataControl: C ? c : void 0 }), n && E.jsx(k, { id: Rm(s), description: n, schema: v, uiSchema: w, registry: m }), C ? void 0 : c, d.map((O) => O.content), NV(v, w, a) && E.jsx(_, { id: vl(s, "add"), className: "rjsf-object-property-expand", onClick: l, disabled: r || p, uiSchema: w, registry: m })] });
}
function UNe(e) {
  const { id: t, registry: n, label: r, onAddClick: a, onRemoveClick: s } = e;
  return a ? E.jsx(bm, { id: t, registry: n, icon: "plus", className: "rjsf-add-optional-data btn-sm", onClick: a, title: r }) : s ? E.jsx(bm, { id: t, registry: n, icon: "remove", className: "rjsf-remove-optional-data btn-sm", onClick: s, title: r }) : E.jsx("em", { id: t, children: r });
}
const VNe = "*";
function HNe(e) {
  const { id: t, title: n, required: r, optionalDataControl: a } = e;
  return E.jsxs("legend", { id: t, children: [n, r && E.jsx("span", { className: "required", children: VNe }), a && E.jsx("span", { className: "pull-right", style: { marginBottom: "2px" }, children: a })] });
}
function qNe(e) {
  const { schema: t, fieldPathId: n, reason: r, registry: a } = e, { translateString: s } = a;
  let l = Gt.UnsupportedField;
  const c = [];
  return n && n.$id && (l = Gt.UnsupportedFieldWithId, c.push(n.$id)), r && (l = l === Gt.UnsupportedField ? Gt.UnsupportedFieldWithReason : Gt.UnsupportedFieldWithIdAndReason, c.push(r)), E.jsxs("div", { className: "unsupported-field", children: [E.jsx("p", { children: E.jsx(AS, { options: { disableParsingRawHTML: !0 }, children: s(l, c) }) }), t && E.jsx("pre", { children: JSON.stringify(t, null, 2) })] });
}
function WNe(e) {
  const { id: t, classNames: n, style: r, disabled: a, displayLabel: s, label: l, onKeyRenameBlur: c, onRemoveProperty: d, rawDescription: p, readonly: m, required: h, schema: v, hideError: y, rawErrors: w, children: x, uiSchema: b, registry: k } = e, { templates: C, translateString: _ } = k, { RemoveButton: O } = C.ButtonTemplates, N = _(Gt.KeyLabel, [l]), R = hc in v, j = !!p, D = ["form-group", n];
  !y && w && w.length > 0 && D.push("has-error has-danger");
  const $ = D.join(" ").trim();
  if (!R)
    return E.jsx("div", { className: $, style: r, children: x });
  const z = j ? 46 : 26;
  return E.jsx("div", { className: $, style: r, children: E.jsxs("div", { className: "row", children: [E.jsx("div", { className: "col-xs-5 form-additional", children: E.jsxs("div", { className: "form-group", children: [s && E.jsx(wq, { label: N, required: h, id: `${t}-key` }), s && p && E.jsx("div", { children: "" }), E.jsx("input", { className: "form-control", type: "text", id: `${t}-key`, onBlur: c, defaultValue: l })] }) }), E.jsx("div", { className: "form-additional form-group col-xs-5", children: x }), E.jsx("div", { className: "col-xs-2", style: { marginTop: s ? `${z}px` : void 0 }, children: E.jsx(O, { id: vl(t, "remove"), className: "rjsf-object-property-remove btn-block", style: { border: "0" }, disabled: a || m, onClick: d, uiSchema: b, registry: k }) })] }) });
}
function GNe() {
  return {
    ArrayFieldDescriptionTemplate: bNe,
    ArrayFieldItemTemplate: wNe,
    ArrayFieldItemButtonsTemplate: xNe,
    ArrayFieldTemplate: SNe,
    ArrayFieldTitleTemplate: kNe,
    ButtonTemplates: ANe(),
    BaseInputTemplate: _Ne,
    DescriptionFieldTemplate: jNe,
    ErrorListTemplate: PNe,
    FallbackFieldTemplate: DNe,
    FieldTemplate: TNe,
    FieldErrorTemplate: LNe,
    FieldHelpTemplate: INe,
    GridTemplate: zNe,
    MultiSchemaFieldTemplate: FNe,
    ObjectFieldTemplate: BNe,
    OptionalDataControlsTemplate: UNe,
    TitleFieldTemplate: HNe,
    UnsupportedFieldTemplate: qNe,
    WrapIfAdditionalTemplate: WNe
  };
}
function KNe(e) {
  const { disabled: t = !1, readonly: n = !1, autofocus: r = !1, options: a, id: s, name: l, registry: c, onBlur: d, onFocus: p } = e, { translateString: m } = c, { elements: h, handleChange: v, handleClear: y, handleSetNow: w } = FEe(e);
  return E.jsxs("ul", { className: "list-inline", children: [h.map((x, b) => E.jsx("li", { className: "list-inline-item", children: E.jsx(zEe, { rootId: s, name: l, select: v, ...x, disabled: t, readonly: n, registry: c, onBlur: d, onFocus: p, autofocus: r && b === 0 }) }, b)), (a.hideNowButton !== "undefined" ? !a.hideNowButton : !0) && E.jsx("li", { className: "list-inline-item", children: E.jsx("a", { href: "#", className: "btn btn-info btn-now", onClick: w, children: m(Gt.NowLabel) }) }), (a.hideClearButton !== "undefined" ? !a.hideClearButton : !0) && E.jsx("li", { className: "list-inline-item", children: E.jsx("a", { href: "#", className: "btn btn-warning btn-clear", onClick: y, children: m(Gt.ClearLabel) }) })] });
}
function XNe({ time: e = !0, ...t }) {
  const { AltDateWidget: n } = t.registry.widgets;
  return E.jsx(n, { time: e, ...t });
}
function YNe({ schema: e, uiSchema: t, options: n, id: r, value: a, disabled: s, readonly: l, label: c, hideLabel: d, autofocus: p = !1, onBlur: m, onFocus: h, onChange: v, registry: y, htmlName: w }) {
  const x = bt("DescriptionFieldTemplate", y, n), b = Zw(e), k = M.useCallback((N) => v(N.target.checked), [v]), C = M.useCallback((N) => m(r, N.target.checked), [m, r]), _ = M.useCallback((N) => h(r, N.target.checked), [h, r]), O = ht(t).widget === "checkbox" ? void 0 : n.description ?? e.description;
  return E.jsxs("div", { className: `checkbox ${s || l ? "disabled" : ""}`, children: [!d && O && E.jsx(x, { id: Rm(r), description: O, schema: e, uiSchema: t, registry: y }), E.jsxs("label", { children: [E.jsx("input", { type: "checkbox", id: r, name: w || r, checked: typeof a > "u" ? !1 : a, required: b, disabled: s || l, autoFocus: p, onChange: k, onBlur: C, onFocus: _, "aria-describedby": _i(r) }), Am(E.jsx("span", { children: c }), d)] })] });
}
function QNe({ id: e, disabled: t, options: { inline: n = !1, enumOptions: r, enumDisabled: a, emptyValue: s }, value: l, autofocus: c = !1, readonly: d, onChange: p, onBlur: m, onFocus: h, htmlName: v }) {
  const y = Array.isArray(l) ? l : [l], w = M.useCallback(({ target: b }) => m(e, to(b && b.value, r, s)), [m, e, r, s]), x = M.useCallback(({ target: b }) => h(e, to(b && b.value, r, s)), [h, e, r, s]);
  return E.jsx("div", { className: "checkboxes", id: e, children: Array.isArray(r) && r.map((b, k) => {
    const C = dE(b.value, y), _ = Array.isArray(a) && a.indexOf(b.value) !== -1, O = t || _ || d ? "disabled" : "", N = (j) => {
      j.target.checked ? p(BH(k, y, r)) : p(FH(k, y, r));
    }, R = E.jsxs("span", { children: [E.jsx("input", { type: "checkbox", id: pE(e, k), name: v || e, checked: C, value: String(k), disabled: t || _ || d, autoFocus: c && k === 0, onChange: N, onBlur: w, onFocus: x, "aria-describedby": _i(e) }), E.jsx("span", { children: b.label })] });
    return n ? E.jsx("label", { className: `checkbox-inline ${O}`, children: R }, k) : E.jsx("div", { className: `checkbox ${O}`, children: E.jsx("label", { children: R }) }, k);
  }) });
}
function JNe(e) {
  const { disabled: t, readonly: n, options: r, registry: a } = e, s = bt("BaseInputTemplate", a, r);
  return E.jsx(s, { type: "color", ...e, disabled: t || n });
}
function ZNe(e) {
  const { onChange: t, options: n, registry: r } = e, a = bt("BaseInputTemplate", r, n), s = M.useCallback((l) => t(l || void 0), [t]);
  return E.jsx(a, { type: "date", ...e, onChange: s });
}
function e5e(e) {
  const { onChange: t, value: n, options: r, registry: a } = e, s = bt("BaseInputTemplate", a, r);
  return E.jsx(s, { type: "datetime-local", ...e, value: qEe(n), onChange: (l) => t($Ee(l)) });
}
function t5e(e) {
  const { options: t, registry: n } = e, r = bt("BaseInputTemplate", n, t);
  return E.jsx(r, { type: "email", ...e });
}
function n5e({ fileInfo: e, registry: t }) {
  const { translateString: n } = t, { dataURL: r, type: a, name: s } = e;
  return r ? ["image/jpeg", "image/png"].includes(a) ? E.jsx("img", { src: r, style: { maxWidth: "100%" }, className: "file-preview" }) : E.jsxs(E.Fragment, { children: [" ", E.jsx("a", { download: `preview-${s}`, href: r, className: "file-download", children: n(Gt.PreviewLabel) })] }) : null;
}
function r5e({ filesInfo: e, registry: t, preview: n, onRemove: r, options: a }) {
  if (e.length === 0)
    return null;
  const { translateString: s } = t, { RemoveButton: l } = bt("ButtonTemplates", t, a);
  return E.jsx("ul", { className: "file-info", children: e.map((c, d) => {
    const { name: p, size: m, type: h } = c, v = () => r(d);
    return E.jsxs("li", { children: [E.jsx(AS, { children: s(Gt.FilesInfo, [p, h, String(m)]) }), n && E.jsx(n5e, { fileInfo: c, registry: t }), E.jsx(l, { onClick: v, registry: t })] }, d);
  }) });
}
function o5e(e) {
  const { disabled: t, readonly: n, required: r, multiple: a, onChange: s, value: l, options: c, registry: d } = e, { filesInfo: p, handleChange: m, handleRemove: h } = HEe(l, s, a), v = bt("BaseInputTemplate", d, c), y = (w) => {
    w.target.files && m(w.target.files);
  };
  return E.jsxs("div", { children: [E.jsx(v, { ...e, disabled: t || n, type: "file", required: l ? !1 : r, onChangeOverride: y, value: "", accept: c.accept ? String(c.accept) : void 0 }), E.jsx(r5e, { filesInfo: p, onRemove: h, registry: d, preview: c.filePreview, options: c })] });
}
function a5e({ id: e, value: t, htmlName: n }) {
  return E.jsx("input", { type: "hidden", id: e, name: n || e, value: typeof t > "u" ? "" : t });
}
function i5e(e) {
  const { options: t, registry: n } = e, r = bt("BaseInputTemplate", n, t);
  return E.jsx(r, { type: "password", ...e });
}
function s5e({ options: e, value: t, required: n, disabled: r, readonly: a, autofocus: s = !1, onBlur: l, onFocus: c, onChange: d, id: p, htmlName: m }) {
  const { enumOptions: h, enumDisabled: v, inline: y, emptyValue: w } = e, x = M.useCallback(({ target: k }) => l(p, to(k && k.value, h, w)), [l, h, w, p]), b = M.useCallback(({ target: k }) => c(p, to(k && k.value, h, w)), [c, h, w, p]);
  return E.jsx("div", { className: "field-radio-group", id: p, role: "radiogroup", children: Array.isArray(h) && h.map((k, C) => {
    const _ = dE(k.value, t), O = Array.isArray(v) && v.indexOf(k.value) !== -1, N = r || O || a ? "disabled" : "", R = () => d(k.value), j = E.jsxs("span", { children: [E.jsx("input", { type: "radio", id: pE(p, C), checked: _, name: m || p, required: n, value: String(C), disabled: r || O || a, autoFocus: s && C === 0, onChange: R, onBlur: x, onFocus: b, "aria-describedby": _i(p) }), E.jsx("span", { children: k.label })] });
    return y ? E.jsx("label", { className: `radio-inline ${N}`, children: j }, C) : E.jsx("div", { className: `radio ${N}`, children: E.jsx("label", { children: j }) }, C);
  }) });
}
function l5e(e) {
  const { value: t, registry: { templates: { BaseInputTemplate: n } } } = e;
  return E.jsxs("div", { className: "field-range-wrapper", children: [E.jsx(n, { type: "range", ...e }), E.jsx("span", { className: "range-view", children: t })] });
}
function u5e({ id: e, value: t, required: n, disabled: r, readonly: a, autofocus: s, onChange: l, onFocus: c, onBlur: d, schema: p, options: m, htmlName: h }) {
  const { stars: v = 5, shape: y = "star" } = m, w = p.maximum ? Math.min(p.maximum, 5) : Math.min(Math.max(v, 1), 5), x = p.minimum || 0, b = M.useCallback((O) => {
    !r && !a && l(O);
  }, [l, r, a]), k = M.useCallback((O) => {
    if (c) {
      const N = Number(O.target.dataset.value);
      c(e, N);
    }
  }, [c, e]), C = M.useCallback((O) => {
    if (d) {
      const N = Number(O.target.dataset.value);
      d(e, N);
    }
  }, [d, e]), _ = (O) => y === "heart" ? O ? "" : "" : O ? "" : "";
  return E.jsx(E.Fragment, { children: E.jsxs("div", { className: "rating-widget", style: {
    display: "inline-flex",
    fontSize: "1.5rem",
    cursor: r || a ? "default" : "pointer"
  }, children: [[...Array(w)].map((O, N) => {
    const R = x + N, j = R <= t;
    return E.jsx("span", { onClick: () => b(R), onFocus: k, onBlur: C, "data-value": R, tabIndex: r || a ? -1 : 0, role: "radio", "aria-checked": R === t, "aria-label": `${R} ${y === "heart" ? "heart" : "star"}${R === 1 ? "" : "s"}`, style: {
      color: j ? "#FFD700" : "#ccc",
      padding: "0 0.2rem",
      transition: "color 0.2s",
      userSelect: "none"
    }, children: _(j) }, N);
  }), E.jsx("input", { type: "hidden", id: e, name: h || e, value: t || "", required: n, disabled: r || a, "aria-hidden": "true" })] }) });
}
function vN(e, t) {
  return t ? Array.from(e.target.options).slice().filter((n) => n.selected).map((n) => n.value) : e.target.value;
}
function c5e({ schema: e, id: t, options: n, value: r, required: a, disabled: s, readonly: l, multiple: c = !1, autofocus: d = !1, onChange: p, onBlur: m, onFocus: h, placeholder: v, htmlName: y }) {
  const { enumOptions: w, enumDisabled: x, emptyValue: b } = n, k = c ? [] : "", C = M.useCallback((j) => {
    const D = vN(j, c);
    return h(t, to(D, w, b));
  }, [h, t, c, w, b]), _ = M.useCallback((j) => {
    const D = vN(j, c);
    return m(t, to(D, w, b));
  }, [m, t, c, w, b]), O = M.useCallback((j) => {
    const D = vN(j, c);
    return p(to(D, w, b));
  }, [p, c, w, b]), N = QA(r, w, c), R = !c && e.default === void 0;
  return E.jsxs("select", { id: t, name: y || t, multiple: c, role: "combobox", className: "form-control", value: typeof N > "u" ? k : N, required: a, disabled: s || l, autoFocus: d, onBlur: _, onFocus: C, onChange: O, "aria-describedby": _i(t), children: [R && E.jsx("option", { value: "", children: v }), Array.isArray(w) && w.map(({ value: j, label: D }, $) => {
    const z = x && x.indexOf(j) !== -1;
    return E.jsx("option", { value: String($), disabled: z, children: D }, $);
  })] });
}
function Sq({ id: e, options: t = {}, placeholder: n, value: r, required: a, disabled: s, readonly: l, autofocus: c = !1, onChange: d, onBlur: p, onFocus: m, htmlName: h }) {
  const v = M.useCallback(({ target: { value: x } }) => d(x === "" ? t.emptyValue : x), [d, t.emptyValue]), y = M.useCallback(({ target: x }) => p(e, x && x.value), [p, e]), w = M.useCallback(({ target: x }) => m(e, x && x.value), [e, m]);
  return E.jsx("textarea", { id: e, name: h || e, className: "form-control", value: r || "", placeholder: n, required: a, disabled: s, readOnly: l, autoFocus: c, rows: t.rows, onBlur: y, onFocus: w, onChange: v, "aria-describedby": _i(e) });
}
Sq.defaultProps = {
  autofocus: !1,
  options: {}
};
function d5e(e) {
  const { options: t, registry: n } = e, r = bt("BaseInputTemplate", n, t);
  return E.jsx(r, { ...e });
}
function f5e(e) {
  const { onChange: t, options: n, registry: r } = e, a = bt("BaseInputTemplate", r, n), s = M.useCallback((l) => t(l ? `${l}:00` : void 0), [t]);
  return E.jsx(a, { type: "time", ...e, onChange: s });
}
function p5e(e) {
  const { options: t, registry: n } = e, r = bt("BaseInputTemplate", n, t);
  return E.jsx(r, { type: "url", ...e });
}
function m5e(e) {
  const { options: t, registry: n } = e, r = bt("BaseInputTemplate", n, t);
  return E.jsx(r, { type: "number", ...e });
}
function h5e() {
  return {
    AltDateWidget: KNe,
    AltDateTimeWidget: XNe,
    CheckboxWidget: YNe,
    CheckboxesWidget: QNe,
    ColorWidget: JNe,
    DateWidget: ZNe,
    DateTimeWidget: e5e,
    EmailWidget: t5e,
    FileWidget: o5e,
    HiddenWidget: a5e,
    PasswordWidget: i5e,
    RadioWidget: s5e,
    RangeWidget: l5e,
    RatingWidget: u5e,
    SelectWidget: c5e,
    TextWidget: d5e,
    TextareaWidget: Sq,
    TimeWidget: f5e,
    UpDownWidget: m5e,
    URLWidget: p5e
  };
}
function g5e() {
  return {
    fields: yNe(),
    templates: GNe(),
    widgets: h5e(),
    rootSchema: {},
    formContext: {},
    translateString: gEe,
    globalFormOptions: {
      idPrefix: CV,
      idSeparator: OV,
      useFallbackUiForUnsupportedType: !1
    }
  };
}
function eh(e, t) {
  return {
    ...oq(e, ["schema", "uiSchema", "fieldPathId", "schemaUtils", "formData", "edit", "errors", "errorSchema"]),
    ...t !== void 0 && { status: t }
  };
}
let v5e = class extends M.Component {
  /** Constructs the `Form` from the `props`. Will setup the initial state from the props. It will also call the
   * `onChange` handler if the initially provided `formData` is modified to add missing default values as part of the
   * state construction.
   *
   * @param props - The initial props for the `Form`
   */
  constructor(t) {
    super(t);
    /** The ref used to hold the `form` element, this needs to be `any` because `tagName` or `_internalFormWrapper` can
     * provide any possible type here
     */
    Jr(this, "formElement");
    /** The list of pending changes
     */
    Jr(this, "pendingChanges", []);
    /** Returns the `formData` with only the elements specified in the `fields` list
     *
     * @param formData - The data for the `Form`
     * @param fields - The fields to keep while filtering
     */
    Jr(this, "getUsedFormData", (t, n) => {
      if (n.length === 0 && typeof t != "object")
        return t;
      const r = oq(t, n);
      return Array.isArray(t) ? Object.keys(r).map((a) => r[a]) : r;
    });
    /** Returns the list of field names from inspecting the `pathSchema` as well as using the `formData`
     *
     * @param pathSchema - The `PathSchema` object for the form
     * @param [formData] - The form data to use while checking for empty objects/arrays
     */
    Jr(this, "getFieldNames", (t, n) => {
      const r = (s, l) => typeof s != "object" || jr(s) || l && !jr(s), a = (s, l = [], c = [[]]) => {
        const d = Object.keys(s);
        return d.forEach((p) => {
          const m = s[p];
          if (typeof m == "object") {
            const h = c.map((v) => [...v, p]);
            m[CA] && m[T0] !== "" ? l.push(m[T0]) : a(m, l, h);
          } else p === T0 && m !== "" && c.forEach((h) => {
            const v = Ae(n, h), y = d.length === 1;
            (r(v, y) || Array.isArray(v) && v.every((w) => r(w, y))) && l.push(h);
          });
        }), l;
      };
      return a(t);
    });
    /** Returns the `formData` after filtering to remove any extra data not in a form field
     *
     * @param formData - The data for the `Form`
     * @returns The `formData` after omitting extra data
     */
    Jr(this, "omitExtraData", (t) => {
      const { schema: n, schemaUtils: r } = this.state, a = r.retrieveSchema(n, t), s = r.toPathSchema(a, "", t), l = this.getFieldNames(s, t);
      return this.getUsedFormData(t, l);
    });
    /** Allows a user to set a value for the provided `fieldPath`, which must be either a dotted path to the field OR a
     * `FieldPathList`. To set the root element, used either `''` or `[]` for the path. Passing undefined will clear the
     * value in the field.
     *
     * @param fieldPath - Either a dotted path to the field or the `FieldPathList` to the field
     * @param [newValue] - The new value for the field
     */
    Jr(this, "setFieldValue", (t, n) => {
      const { registry: r } = this.state, a = Array.isArray(t) ? t : t.split("."), s = Li("", r.globalFormOptions, a);
      this.onChange(n, a, void 0, s[$n]);
    });
    /** Pushes the given change information into the `pendingChanges` array and then calls `processPendingChanges()` if
     * the array only contains a single pending change.
     *
     * @param newValue - The new form data from a change to a field
     * @param path - The path to the change into which to set the formData
     * @param [newErrorSchema] - The new `ErrorSchema` based on the field change
     * @param [id] - The id of the field that caused the change
     */
    Jr(this, "onChange", (t, n, r, a) => {
      this.pendingChanges.push({ newValue: t, path: n, newErrorSchema: r, id: a }), this.pendingChanges.length === 1 && this.processPendingChange();
    });
    /**
     * Callback function to handle reset form data.
     * - Reset all fields with default values.
     * - Reset validations and errors
     *
     */
    Jr(this, "reset", () => {
      const { formData: t, initialFormData: n = TI, onChange: r } = this.props, a = {
        formData: this.getStateFromProps(this.props, t ?? n, void 0, void 0, void 0, !0).formData,
        errorSchema: {},
        errors: [],
        schemaValidationErrors: [],
        schemaValidationErrorSchema: {},
        initialDefaultsGenerated: !1,
        customErrors: void 0
      };
      this.setState(a, () => r && r(eh({ ...this.state, ...a })));
    });
    /** Callback function to handle when a field on the form is blurred. Calls the `onBlur` callback for the `Form` if it
     * was provided. Also runs any live validation and/or live omit operations if the flags indicate they should happen
     * during `onBlur`.
     *
     * @param id - The unique `id` of the field that was blurred
     * @param data - The data associated with the field that was blurred
     */
    Jr(this, "onBlur", (t, n) => {
      const { onBlur: r, omitExtraData: a, liveOmit: s, liveValidate: l } = this.props;
      if (r && r(t, n), a === !0 && s === "onBlur" || l === "onBlur") {
        const { onChange: c, extraErrors: d } = this.props, { formData: p } = this.state;
        let m = p, h = { formData: m };
        if (a === !0 && s === "onBlur" && (m = this.omitExtraData(p), h = { formData: m }), l === "onBlur") {
          const { schema: y, schemaUtils: w, errorSchema: x, customErrors: b, retrievedSchema: k } = this.state, C = this.liveValidate(y, w, x, m, d, b, k);
          h = { formData: m, ...C, customErrors: b };
        }
        const v = Object.keys(h).filter((y) => !y.startsWith("schemaValidation")).some((y) => {
          const w = Ae(this.state, y), x = Ae(h, y);
          return !Yn(w, x);
        });
        this.setState(h, () => {
          c && v && c(eh({ ...this.state, ...h }), t);
        });
      }
    });
    /** Callback function to handle when a field on the form is focused. Calls the `onFocus` callback for the `Form` if it
     * was provided.
     *
     * @param id - The unique `id` of the field that was focused
     * @param data - The data associated with the field that was focused
     */
    Jr(this, "onFocus", (t, n) => {
      const { onFocus: r } = this.props;
      r && r(t, n);
    });
    /** Callback function to handle when the form is submitted. First, it prevents the default event behavior. Nothing
     * happens if the target and currentTarget of the event are not the same. It will omit any extra data in the
     * `formData` in the state if `omitExtraData` is true. It will validate the resulting `formData`, reporting errors
     * via the `onError()` callback unless validation is disabled. Finally, it will add in any `extraErrors` and then call
     * back the `onSubmit` callback if it was provided.
     *
     * @param event - The submit HTML form event
     */
    Jr(this, "onSubmit", (t) => {
      if (t.preventDefault(), t.target !== t.currentTarget)
        return;
      t.persist();
      const { omitExtraData: n, extraErrors: r, noValidate: a, onSubmit: s } = this.props;
      let { formData: l } = this.state;
      if (n === !0 && (l = this.omitExtraData(l)), a || this.validateFormWithFormData(l)) {
        const c = r || {}, d = r ? r4(r) : [];
        this.setState({
          formData: l,
          errors: d,
          errorSchema: c,
          schemaValidationErrors: [],
          schemaValidationErrorSchema: {}
        }, () => {
          s && s(eh({ ...this.state, formData: l }, "submitted"), t);
        });
      }
    });
    /** Provides a function that can be used to programmatically submit the `Form` */
    Jr(this, "submit", () => {
      if (this.formElement.current) {
        const t = new CustomEvent("submit", {
          cancelable: !0
        });
        t.preventDefault(), this.formElement.current.dispatchEvent(t), this.formElement.current.requestSubmit();
      }
    });
    /** Validates the form using the given `formData`. For use on form submission or on programmatic validation.
     * If `onError` is provided, then it will be called with the list of errors.
     *
     * @param formData - The form data to validate
     * @returns - True if the form is valid, false otherwise.
     */
    Jr(this, "validateFormWithFormData", (t) => {
      const { extraErrors: n, extraErrorsBlockSubmit: r, focusOnFirstError: a, onError: s } = this.props, { errors: l } = this.state, c = this.validate(t);
      let d = c.errors, p = c.errorSchema;
      const m = d, h = p, v = d.length > 0 || n && r;
      if (v) {
        if (n) {
          const y = B0(c, n);
          p = y.errorSchema, d = y.errors;
        }
        a && (typeof a == "function" ? a(d[0]) : this.focusOnError(d[0])), this.setState({
          errors: d,
          errorSchema: p,
          schemaValidationErrors: m,
          schemaValidationErrorSchema: h
        }, () => {
          s ? s(d) : console.error("Form validation failed", d);
        });
      } else l.length > 0 && this.setState({
        errors: [],
        errorSchema: {},
        schemaValidationErrors: [],
        schemaValidationErrorSchema: {}
      });
      return !v;
    });
    if (!t.validator)
      throw new Error("A validator is required for Form functionality to work");
    const { formData: n, initialFormData: r, onChange: a } = t, s = n ?? r;
    this.state = this.getStateFromProps(t, s, void 0, void 0, void 0, !0), a && !Yn(this.state.formData, s) && a(eh(this.state)), this.formElement = M.createRef();
  }
  /**
   * `getSnapshotBeforeUpdate` is a React lifecycle method that is invoked right before the most recently rendered
   * output is committed to the DOM. It enables your component to capture current values (e.g., scroll position) before
   * they are potentially changed.
   *
   * In this case, it checks if the props have changed since the last render. If they have, it computes the next state
   * of the component using `getStateFromProps` method and returns it along with a `shouldUpdate` flag set to `true` IF
   * the `nextState` and `prevState` are different, otherwise `false`. This ensures that we have the most up-to-date
   * state ready to be applied in `componentDidUpdate`.
   *
   * If `formData` hasn't changed, it simply returns an object with `shouldUpdate` set to `false`, indicating that a
   * state update is not necessary.
   *
   * @param prevProps - The previous set of props before the update.
   * @param prevState - The previous state before the update.
   * @returns Either an object containing the next state and a flag indicating that an update should occur, or an object
   *        with a flag indicating that an update is not necessary.
   */
  getSnapshotBeforeUpdate(t, n) {
    if (!Yn(this.props, t)) {
      const r = RT(this.props.formData, t.formData), a = RT(this.props.formData, this.state.formData), s = !Yn(t.schema, this.props.schema), l = r.length > 0 || !Yn(t.formData, this.props.formData), c = a.length > 0 || !Yn(this.state.formData, this.props.formData), d = this.getStateFromProps(
        this.props,
        this.props.formData,
        // If the `schema` has changed, we need to update the retrieved schema.
        // Or if the `formData` changes, for example in the case of a schema with dependencies that need to
        //  match one of the subSchemas, the retrieved schema must be updated.
        s || l ? void 0 : this.state.retrievedSchema,
        s,
        r,
        // Skip live validation for this request if no form data has changed from the last state
        !c
      ), p = !Yn(d, n);
      return { nextState: d, shouldUpdate: p };
    }
    return { shouldUpdate: !1 };
  }
  /**
   * `componentDidUpdate` is a React lifecycle method that is invoked immediately after updating occurs. This method is
   * not called for the initial render.
   *
   * Here, it checks if an update is necessary based on the `shouldUpdate` flag received from `getSnapshotBeforeUpdate`.
   * If an update is required, it applies the next state and, if needed, triggers the `onChange` handler to inform about
   * changes.
   *
   * @param _ - The previous set of props.
   * @param prevState - The previous state of the component before the update.
   * @param snapshot - The value returned from `getSnapshotBeforeUpdate`.
   */
  componentDidUpdate(t, n, r) {
    if (r.shouldUpdate) {
      const { nextState: a } = r;
      !Yn(a.formData, this.props.formData) && !Yn(a.formData, n.formData) && this.props.onChange && this.props.onChange(eh(a)), this.setState(a);
    }
  }
  /** Extracts the updated state from the given `props` and `inputFormData`. As part of this process, the
   * `inputFormData` is first processed to add any missing required defaults. After that, the data is run through the
   * validation process IF required by the `props`.
   *
   * @param props - The props passed to the `Form`
   * @param inputFormData - The new or current data for the `Form`
   * @param retrievedSchema - An expanded schema, if not provided, it will be retrieved from the `schema` and `formData`.
   * @param isSchemaChanged - A flag indicating whether the schema has changed.
   * @param formDataChangedFields - The changed fields of `formData`
   * @param skipLiveValidate - Optional flag, if true, means that we are not running live validation
   * @returns - The new state for the `Form`
   */
  getStateFromProps(t, n, r, a = !1, s = [], l = !1) {
    const c = this.state || {}, d = "schema" in t ? t.schema : this.props.schema, p = "validator" in t ? t.validator : this.props.validator, m = ("uiSchema" in t ? t.uiSchema : this.props.uiSchema) || {}, h = t.formData === void 0 && this.props.formData === void 0, v = typeof n < "u", y = "liveValidate" in t ? t.liveValidate : this.props.liveValidate, w = v && !t.noValidate && y, x = "experimental_defaultFormStateBehavior" in t ? t.experimental_defaultFormStateBehavior : this.props.experimental_defaultFormStateBehavior, b = "experimental_customMergeAllOf" in t ? t.experimental_customMergeAllOf : this.props.experimental_customMergeAllOf;
    let k = c.schemaUtils;
    (!k || k.doesSchemaUtilsDiffer(p, d, x, b)) && (k = pEe(p, d, x, b));
    const C = k.getRootSchema();
    let _ = n;
    n === TI ? _ = void 0 : n === void 0 && h && (_ = c.formData);
    const O = k.getDefaultFormState(C, _, !1, c.initialDefaultsGenerated), N = this.updateRetrievedSchema(r ?? k.retrieveSchema(C, O)), R = () => t.noValidate || a ? { errors: [], errorSchema: {} } : t.liveValidate ? {
      errors: c.errors || [],
      errorSchema: c.errorSchema || {}
    } : {
      errors: c.schemaValidationErrors || [],
      errorSchema: c.schemaValidationErrorSchema || {}
    };
    let j, D, $ = c.schemaValidationErrors, z = c.schemaValidationErrorSchema;
    if (w && !l) {
      const I = this.liveValidate(
        C,
        k,
        c.errorSchema,
        O,
        void 0,
        c.customErrors,
        r,
        // If retrievedSchema is undefined which means the schema or formData has changed, we do not merge state.
        // Else in the case where it hasn't changed,
        r !== void 0
      );
      j = I.errors, D = I.errorSchema, $ = I.schemaValidationErrors, z = I.schemaValidationErrorSchema;
    } else {
      const I = R();
      if (j = I.errors, D = I.errorSchema, s.length > 0 && !w) {
        const L = s.reduce((K, q) => (K[q] = void 0, K), {});
        D = z = zx(I.errorSchema, L, "preventDuplicates");
      }
      const G = this.mergeErrors({ errorSchema: D, errors: j }, t.extraErrors, c.customErrors);
      j = G.errors, D = G.errorSchema;
    }
    const B = this.getRegistry(t, C, k), P = Yn(c.registry, B) ? c.registry : B, W = c.fieldPathId && c.fieldPathId?.[$n] === P.globalFormOptions.idPrefix ? c.fieldPathId : Li("", P.globalFormOptions);
    return {
      schemaUtils: k,
      schema: C,
      uiSchema: m,
      fieldPathId: W,
      formData: O,
      edit: v,
      errors: j,
      errorSchema: D,
      schemaValidationErrors: $,
      schemaValidationErrorSchema: z,
      retrievedSchema: N,
      initialDefaultsGenerated: !0,
      registry: P
    };
  }
  /** React lifecycle method that is used to determine whether component should be updated.
   *
   * @param nextProps - The next version of the props
   * @param nextState - The next version of the state
   * @returns - True if the component should be updated, false otherwise
   */
  shouldComponentUpdate(t, n) {
    const { experimental_componentUpdateStrategy: r = "customDeep" } = this.props;
    return KH(this, t, n, r);
  }
  /** Validates the `formData` against the `schema` using the `altSchemaUtils` (if provided otherwise it uses the
   * `schemaUtils` in the state), returning the results.
   *
   * @param formData - The new form data to validate
   * @param schema - The schema used to validate against
   * @param [altSchemaUtils] - The alternate schemaUtils to use for validation
   * @param [retrievedSchema] - An optionally retrieved schema for per
   */
  validate(t, n = this.state.schema, r, a) {
    const s = r || this.state.schemaUtils, { customValidate: l, transformErrors: c, uiSchema: d } = this.props, p = a ?? s.retrieveSchema(n, t);
    return s.getValidator().validateFormData(t, p, l, c, d);
  }
  /** Renders any errors contained in the `state` in using the `ErrorList`, if not disabled by `showErrorList`. */
  renderErrors(t) {
    const { errors: n, errorSchema: r, schema: a, uiSchema: s } = this.state, l = ht(s), c = bt("ErrorListTemplate", t, l);
    return n && n.length ? E.jsx(c, { errors: n, errorSchema: r || {}, schema: a, uiSchema: s, registry: t }) : null;
  }
  /** Merges any `extraErrors` or `customErrors` into the given `schemaValidation` object, returning the result
   *
   * @param schemaValidation - The `ValidationData` object into which additional errors are merged
   * @param [extraErrors] - The extra errors from the props
   * @param [customErrors] - The customErrors from custom components
   * @return - The `extraErrors` and `customErrors` merged into the `schemaValidation`
   * @private
   */
  mergeErrors(t, n, r) {
    let a = t.errorSchema, s = t.errors;
    if (n) {
      const l = B0(t, n);
      a = l.errorSchema, s = l.errors;
    }
    if (r) {
      const l = B0(t, r.ErrorSchema, !0);
      a = l.errorSchema, s = l.errors;
    }
    return { errors: s, errorSchema: a };
  }
  /** Performs live validation and then updates and returns the errors and error schemas by potentially merging in
   * `extraErrors` and `customErrors`.
   *
   * @param rootSchema - The `rootSchema` from the state
   * @param schemaUtils - The `SchemaUtilsType` from the state
   * @param originalErrorSchema - The original `ErrorSchema` from the state
   * @param [formData] - The new form data to validate
   * @param [extraErrors] - The extra errors from the props
   * @param [customErrors] - The customErrors from custom components
   * @param [retrievedSchema] - An expanded schema, if not provided, it will be retrieved from the `schema` and `formData`
   * @param [mergeIntoOriginalErrorSchema=false] - Optional flag indicating whether we merge into original schema
   * @returns - An object containing `errorSchema`, `errors`, `schemaValidationErrors` and `schemaValidationErrorSchema`
   * @private
   */
  liveValidate(t, n, r, a, s, l, c, d = !1) {
    const p = this.validate(a, t, n, c), m = p.errors;
    let h = p.errorSchema;
    d && (h = zx(r, p.errorSchema, "preventDuplicates"));
    const v = m, y = h;
    return { ...this.mergeErrors({ errorSchema: h, errors: m }, s, l), schemaValidationErrors: v, schemaValidationErrorSchema: y };
  }
  /** Function to handle changes made to a field in the `Form`. This handler gets the first change from the
   * `pendingChanges` list, containing the `newValue` for the `formData` and the `path` at which the `newValue` is to be
   * updated, along with a new, optional `ErrorSchema` for that same `path` and potentially the `id` of the field being
   * changed. It will first update the `formData` with any missing default fields and then, if `omitExtraData` and
   * `liveOmit` are turned on, the `formData` will be filtered to remove any extra data not in a form field. Then, the
   * resulting `formData` will be validated if required. The state will be updated with the new updated (potentially
   * filtered) `formData`, any errors that resulted from validation. Finally the `onChange` callback will be called, if
   * specified, with the updated state and the `processPendingChange()` function is called again.
   */
  processPendingChange() {
    if (this.pendingChanges.length === 0)
      return;
    const { newValue: t, path: n, id: r } = this.pendingChanges[0], { newErrorSchema: a } = this.pendingChanges[0], { extraErrors: s, omitExtraData: l, liveOmit: c, noValidate: d, liveValidate: p, onChange: m } = this.props, { formData: h, schemaUtils: v, schema: y, fieldPathId: w, schemaValidationErrorSchema: x, errors: b } = this.state;
    let { customErrors: k, errorSchema: C } = this.state;
    const _ = w.path[0] || "", O = !n || n.length === 0 || n.length === 1 && n[0] === _;
    let N = this.state.retrievedSchema, R = O ? t : JA(h);
    if (on(R) || Array.isArray(R)) {
      t === yq ? vOe(R, n) : O || Pn(R, n, t);
      const z = this.getStateFromProps(this.props, R, void 0, void 0, void 0, !0);
      R = z.formData, N = z.retrievedSchema;
    }
    const j = !d && (p === !0 || p === "onChange");
    let D = { formData: R, schema: y }, $ = R;
    if (l === !0 && (c === !0 || c === "onChange") && ($ = this.omitExtraData(R), D = {
      formData: $
    }), a) {
      const z = O ? x : Ae(x, n);
      if (!jr(z))
        O ? C = a : Pn(C, n, a);
      else if (k || (k = new UH()), O) {
        const B = Ae(a, Po);
        B && k.setErrors(B);
      } else
        Pn(k.ErrorSchema, n, a);
    } else k && Ae(k.ErrorSchema, [...n, Po]) && k.clearErrors(n);
    if (j && this.pendingChanges.length === 1) {
      const z = this.liveValidate(y, v, C, $, s, k, N);
      D = { formData: $, ...z, customErrors: k };
    } else if (!d && a) {
      const z = this.mergeErrors({ errorSchema: C, errors: b }, s, k);
      D = {
        formData: $,
        ...z,
        customErrors: k
      };
    }
    this.setState(D, () => {
      m && m(eh({ ...this.state, ...D }), r), this.pendingChanges.shift(), this.processPendingChange();
    });
  }
  /**
   * If the retrievedSchema has changed the new retrievedSchema is returned.
   * Otherwise, the old retrievedSchema is returned to persist reference.
   * -  This ensures that AJV retrieves the schema from the cache when it has not changed,
   *    avoiding the performance cost of recompiling the schema.
   *
   * @param retrievedSchema The new retrieved schema.
   * @returns The new retrieved schema if it has changed, else the old retrieved schema.
   */
  updateRetrievedSchema(t) {
    return Yn(t, this.state?.retrievedSchema) ? this.state.retrievedSchema : t;
  }
  /** Extracts the `GlobalFormOptions` from the given Form `props`
   *
   * @param props - The form props to extract the global form options from
   * @returns - The `GlobalFormOptions` from the props
   * @private
   */
  getGlobalFormOptions(t) {
    const { uiSchema: n = {}, experimental_componentUpdateStrategy: r, idSeparator: a = OV, idPrefix: s = CV, nameGenerator: l, useFallbackUiForUnsupportedType: c = !1 } = t;
    return {
      idPrefix: n["ui:rootFieldId"] || s,
      idSeparator: a,
      useFallbackUiForUnsupportedType: c,
      ...r !== void 0 && { experimental_componentUpdateStrategy: r },
      ...l !== void 0 && { nameGenerator: l }
    };
  }
  /** Computed the registry for the form using the given `props`, `schema` and `schemaUtils` */
  getRegistry(t, n, r) {
    const { translateString: a, uiSchema: s = {} } = t, { fields: l, templates: c, widgets: d, formContext: p, translateString: m } = g5e();
    return {
      fields: { ...l, ...t.fields },
      templates: {
        ...c,
        ...t.templates,
        ButtonTemplates: {
          ...c.ButtonTemplates,
          ...t.templates?.ButtonTemplates
        }
      },
      widgets: { ...d, ...t.widgets },
      rootSchema: n,
      formContext: t.formContext || p,
      schemaUtils: r,
      translateString: a || m,
      globalUiOptions: s[Y5],
      globalFormOptions: this.getGlobalFormOptions(t)
    };
  }
  /** Attempts to focus on the field associated with the `error`. Uses the `property` field to compute path of the error
   * field, then, using the `idPrefix` and `idSeparator` converts that path into an id. Then the input element with that
   * id is attempted to be found using the `formElement` ref. If it is located, then it is focused.
   *
   * @param error - The error on which to focus
   */
  focusOnError(t) {
    const { idPrefix: n = "root", idSeparator: r = "_" } = this.props, { property: a } = t, s = XH(a);
    s[0] === "" ? s[0] = n : s.unshift(n);
    const l = s.join(r);
    let c = this.formElement.current.elements[l];
    c || (c = this.formElement.current.querySelector(`input[id^="${l}"`)), c && c.length && (c = c[0]), c && c.focus();
  }
  /** Programmatically validate the form.  If `omitExtraData` is true, the `formData` will first be filtered to remove
   * any extra data not in a form field. If `onError` is provided, then it will be called with the list of errors the
   * same way as would happen on form submission.
   *
   * @returns - True if the form is valid, false otherwise.
   */
  validateForm() {
    const { omitExtraData: t } = this.props;
    let { formData: n } = this.state;
    return t === !0 && (n = this.omitExtraData(n)), this.validateFormWithFormData(n);
  }
  /** Renders the `Form` fields inside the <form> | `tagName` or `_internalFormWrapper`, rendering any errors if
   * needed along with the submit button or any children of the form.
   */
  render() {
    const { children: t, id: n, className: r = "", tagName: a, name: s, method: l, target: c, action: d, autoComplete: p, enctype: m, acceptCharset: h, noHtml5Validate: v = !1, disabled: y, readonly: w, showErrorList: x = "top", _internalFormWrapper: b } = this.props, { schema: k, uiSchema: C, formData: _, errorSchema: O, fieldPathId: N, registry: R } = this.state, { SchemaField: j } = R.fields, { SubmitButton: D } = R.templates.ButtonTemplates, $ = b ? a : void 0, z = b || a || "form";
    let { [M_]: B = {} } = ht(C);
    y && (B = { ...B, props: { ...B.props, disabled: !0 } });
    const P = { [Zc]: { [M_]: B } };
    return E.jsxs(z, { className: r || "rjsf", id: n, name: s, method: l, target: c, action: d, autoComplete: p, encType: m, acceptCharset: h, noValidate: v, onSubmit: this.onSubmit, as: $, ref: this.formElement, children: [x === "top" && this.renderErrors(R), E.jsx(j, { name: "", schema: k, uiSchema: C, errorSchema: O, fieldPathId: N, formData: _, onChange: this.onChange, onBlur: this.onBlur, onFocus: this.onFocus, registry: R, disabled: y, readonly: w }), t || E.jsx(D, { uiSchema: P, registry: R }), x === "bottom" && this.renderErrors(R)] });
  }
};
function kq(e) {
  return M.forwardRef(({ fields: t, widgets: n, templates: r, ...a }, s) => (t = { ...e?.fields, ...t }, n = { ...e?.widgets, ...n }, r = {
    ...e?.templates,
    ...r,
    ButtonTemplates: {
      ...e?.templates?.ButtonTemplates,
      ...r?.ButtonTemplates
    }
  }, E.jsx(v5e, { ...e, ...a, fields: t, widgets: n, templates: r, ref: s })));
}
function d3(...e) {
  return e.reduce((t, n) => n == null ? t : function(...r) {
    t.apply(this, r), n.apply(this, r);
  }, () => {
  });
}
function _q(e, t = 166) {
  let n;
  function r(...a) {
    const s = () => {
      e.apply(this, a);
    };
    clearTimeout(n), n = setTimeout(s, t);
  }
  return r.clear = () => {
    clearTimeout(n);
  }, r;
}
function wa(e) {
  return e && e.ownerDocument || document;
}
function Cc(e) {
  return wa(e).defaultView || window;
}
function LI(e, t) {
  typeof e == "function" ? e(t) : e && (e.current = t);
}
function Bx(e) {
  const {
    controlled: t,
    default: n,
    name: r,
    state: a = "value"
  } = e, {
    current: s
  } = M.useRef(t !== void 0), [l, c] = M.useState(n), d = s ? t : l, p = M.useCallback((m) => {
    s || c(m);
  }, []);
  return [d, p];
}
function y5e(e, t) {
  const n = e.charCodeAt(2);
  return e[0] === "o" && e[1] === "n" && n >= 65 && n <= 90 && typeof t == "function";
}
function Eq(e, t) {
  if (!e)
    return t;
  function n(l, c) {
    const d = {};
    return Object.keys(c).forEach((p) => {
      y5e(p, c[p]) && typeof l[p] == "function" && (d[p] = (...m) => {
        l[p](...m), c[p](...m);
      });
    }), d;
  }
  if (typeof e == "function" || typeof t == "function")
    return (l) => {
      const c = typeof t == "function" ? t(l) : t, d = typeof e == "function" ? e({
        ...l,
        ...c
      }) : e, p = Ke(l?.className, c?.className, d?.className), m = n(d, c);
      return {
        ...c,
        ...d,
        ...m,
        ...!!p && {
          className: p
        },
        ...c?.style && d?.style && {
          style: {
            ...c.style,
            ...d.style
          }
        },
        ...c?.sx && d?.sx && {
          sx: [...Array.isArray(c.sx) ? c.sx : [c.sx], ...Array.isArray(d.sx) ? d.sx : [d.sx]]
        }
      };
    };
  const r = t, a = n(e, r), s = Ke(r?.className, e?.className);
  return {
    ...t,
    ...e,
    ...a,
    ...!!s && {
      className: s
    },
    ...r?.style && e?.style && {
      style: {
        ...r.style,
        ...e.style
      }
    },
    ...r?.sx && e?.sx && {
      sx: [...Array.isArray(r.sx) ? r.sx : [r.sx], ...Array.isArray(e.sx) ? e.sx : [e.sx]]
    }
  };
}
const Cq = xi(/* @__PURE__ */ E.jsx("path", {
  d: "M19 13h-6v6h-2v-6H5v-2h6V5h2v6h6z"
}));
function b5e(e) {
  return typeof e.main == "string";
}
function w5e(e, t = []) {
  if (!b5e(e))
    return !1;
  for (const n of t)
    if (!e.hasOwnProperty(n) || typeof e[n] != "string")
      return !1;
  return !0;
}
function Ko(e = []) {
  return ([, t]) => t && w5e(t, e);
}
function x5e(e) {
  return _t("MuiCircularProgress", e);
}
wt("MuiCircularProgress", ["root", "determinate", "indeterminate", "colorPrimary", "colorSecondary", "svg", "track", "circle", "circleDeterminate", "circleIndeterminate", "circleDisableShrink"]);
const Rs = 44, f3 = Zh`
  0% {
    transform: rotate(0deg);
  }

  100% {
    transform: rotate(360deg);
  }
`, p3 = Zh`
  0% {
    stroke-dasharray: 1px, 200px;
    stroke-dashoffset: 0;
  }

  50% {
    stroke-dasharray: 100px, 200px;
    stroke-dashoffset: -15px;
  }

  100% {
    stroke-dasharray: 1px, 200px;
    stroke-dashoffset: -126px;
  }
`, S5e = typeof f3 != "string" ? eS`
        animation: ${f3} 1.4s linear infinite;
      ` : null, k5e = typeof p3 != "string" ? eS`
        animation: ${p3} 1.4s ease-in-out infinite;
      ` : null, _5e = (e) => {
  const {
    classes: t,
    variant: n,
    color: r,
    disableShrink: a
  } = e, s = {
    root: ["root", n, `color${qe(r)}`],
    svg: ["svg"],
    track: ["track"],
    circle: ["circle", `circle${qe(n)}`, a && "circleDisableShrink"]
  };
  return kt(s, x5e, t);
}, E5e = $e("span", {
  name: "MuiCircularProgress",
  slot: "Root",
  overridesResolver: (e, t) => {
    const {
      ownerState: n
    } = e;
    return [t.root, t[n.variant], t[`color${qe(n.color)}`]];
  }
})(Ct(({
  theme: e
}) => ({
  display: "inline-block",
  variants: [{
    props: {
      variant: "determinate"
    },
    style: {
      transition: e.transitions.create("transform")
    }
  }, {
    props: {
      variant: "indeterminate"
    },
    style: S5e || {
      animation: `${f3} 1.4s linear infinite`
    }
  }, ...Object.entries(e.palette).filter(Ko()).map(([t]) => ({
    props: {
      color: t
    },
    style: {
      color: (e.vars || e).palette[t].main
    }
  }))]
}))), C5e = $e("svg", {
  name: "MuiCircularProgress",
  slot: "Svg"
})({
  display: "block"
  // Keeps the progress centered
}), O5e = $e("circle", {
  name: "MuiCircularProgress",
  slot: "Circle",
  overridesResolver: (e, t) => {
    const {
      ownerState: n
    } = e;
    return [t.circle, t[`circle${qe(n.variant)}`], n.disableShrink && t.circleDisableShrink];
  }
})(Ct(({
  theme: e
}) => ({
  stroke: "currentColor",
  variants: [{
    props: {
      variant: "determinate"
    },
    style: {
      transition: e.transitions.create("stroke-dashoffset")
    }
  }, {
    props: {
      variant: "indeterminate"
    },
    style: {
      // Some default value that looks fine waiting for the animation to kicks in.
      strokeDasharray: "80px, 200px",
      strokeDashoffset: 0
      // Add the unit to fix a Edge 16 and below bug.
    }
  }, {
    props: ({
      ownerState: t
    }) => t.variant === "indeterminate" && !t.disableShrink,
    style: k5e || {
      // At runtime for Pigment CSS, `bufferAnimation` will be null and the generated keyframe will be used.
      animation: `${p3} 1.4s ease-in-out infinite`
    }
  }]
}))), M5e = $e("circle", {
  name: "MuiCircularProgress",
  slot: "Track"
})(Ct(({
  theme: e
}) => ({
  stroke: "currentColor",
  opacity: (e.vars || e).palette.action.activatedOpacity
}))), Oq = /* @__PURE__ */ M.forwardRef(function(e, t) {
  const n = At({
    props: e,
    name: "MuiCircularProgress"
  }), {
    className: r,
    color: a = "primary",
    disableShrink: s = !1,
    enableTrackSlot: l = !1,
    size: c = 40,
    style: d,
    thickness: p = 3.6,
    value: m = 0,
    variant: h = "indeterminate",
    ...v
  } = n, y = {
    ...n,
    color: a,
    disableShrink: s,
    size: c,
    thickness: p,
    value: m,
    variant: h,
    enableTrackSlot: l
  }, w = _5e(y), x = {}, b = {}, k = {};
  if (h === "determinate") {
    const C = 2 * Math.PI * ((Rs - p) / 2);
    x.strokeDasharray = C.toFixed(3), k["aria-valuenow"] = Math.round(m), x.strokeDashoffset = `${((100 - m) / 100 * C).toFixed(3)}px`, b.transform = "rotate(-90deg)";
  }
  return /* @__PURE__ */ E.jsx(E5e, {
    className: Ke(w.root, r),
    style: {
      width: c,
      height: c,
      ...b,
      ...d
    },
    ownerState: y,
    ref: t,
    role: "progressbar",
    ...k,
    ...v,
    children: /* @__PURE__ */ E.jsxs(C5e, {
      className: w.svg,
      ownerState: y,
      viewBox: `${Rs / 2} ${Rs / 2} ${Rs} ${Rs}`,
      children: [l ? /* @__PURE__ */ E.jsx(M5e, {
        className: w.track,
        ownerState: y,
        cx: Rs,
        cy: Rs,
        r: (Rs - p) / 2,
        fill: "none",
        strokeWidth: p,
        "aria-hidden": "true"
      }) : null, /* @__PURE__ */ E.jsx(O5e, {
        className: w.circle,
        style: x,
        ownerState: y,
        cx: Rs,
        cy: Rs,
        r: (Rs - p) / 2,
        fill: "none",
        strokeWidth: p
      })]
    })
  });
});
function N5e(e) {
  return _t("MuiIconButton", e);
}
const II = wt("MuiIconButton", ["root", "disabled", "colorInherit", "colorPrimary", "colorSecondary", "colorError", "colorInfo", "colorSuccess", "colorWarning", "edgeStart", "edgeEnd", "sizeSmall", "sizeMedium", "sizeLarge", "loading", "loadingIndicator", "loadingWrapper"]), R5e = (e) => {
  const {
    classes: t,
    disabled: n,
    color: r,
    edge: a,
    size: s,
    loading: l
  } = e, c = {
    root: ["root", l && "loading", n && "disabled", r !== "default" && `color${qe(r)}`, a && `edge${qe(a)}`, `size${qe(s)}`],
    loadingIndicator: ["loadingIndicator"],
    loadingWrapper: ["loadingWrapper"]
  };
  return kt(c, N5e, t);
}, A5e = $e(nS, {
  name: "MuiIconButton",
  slot: "Root",
  overridesResolver: (e, t) => {
    const {
      ownerState: n
    } = e;
    return [t.root, n.loading && t.loading, n.color !== "default" && t[`color${qe(n.color)}`], n.edge && t[`edge${qe(n.edge)}`], t[`size${qe(n.size)}`]];
  }
})(Ct(({
  theme: e
}) => ({
  textAlign: "center",
  flex: "0 0 auto",
  fontSize: e.typography.pxToRem(24),
  padding: 8,
  borderRadius: "50%",
  color: (e.vars || e).palette.action.active,
  transition: e.transitions.create("background-color", {
    duration: e.transitions.duration.shortest
  }),
  variants: [{
    props: (t) => !t.disableRipple,
    style: {
      "--IconButton-hoverBg": e.alpha((e.vars || e).palette.action.active, (e.vars || e).palette.action.hoverOpacity),
      "&:hover": {
        backgroundColor: "var(--IconButton-hoverBg)",
        // Reset on touch devices, it doesn't add specificity
        "@media (hover: none)": {
          backgroundColor: "transparent"
        }
      }
    }
  }, {
    props: {
      edge: "start"
    },
    style: {
      marginLeft: -12
    }
  }, {
    props: {
      edge: "start",
      size: "small"
    },
    style: {
      marginLeft: -3
    }
  }, {
    props: {
      edge: "end"
    },
    style: {
      marginRight: -12
    }
  }, {
    props: {
      edge: "end",
      size: "small"
    },
    style: {
      marginRight: -3
    }
  }]
})), Ct(({
  theme: e
}) => ({
  variants: [{
    props: {
      color: "inherit"
    },
    style: {
      color: "inherit"
    }
  }, ...Object.entries(e.palette).filter(Ko()).map(([t]) => ({
    props: {
      color: t
    },
    style: {
      color: (e.vars || e).palette[t].main
    }
  })), ...Object.entries(e.palette).filter(Ko()).map(([t]) => ({
    props: {
      color: t
    },
    style: {
      "--IconButton-hoverBg": e.alpha((e.vars || e).palette[t].main, (e.vars || e).palette.action.hoverOpacity)
    }
  })), {
    props: {
      size: "small"
    },
    style: {
      padding: 5,
      fontSize: e.typography.pxToRem(18)
    }
  }, {
    props: {
      size: "large"
    },
    style: {
      padding: 12,
      fontSize: e.typography.pxToRem(28)
    }
  }],
  [`&.${II.disabled}`]: {
    backgroundColor: "transparent",
    color: (e.vars || e).palette.action.disabled
  },
  [`&.${II.loading}`]: {
    color: "transparent"
  }
}))), j5e = $e("span", {
  name: "MuiIconButton",
  slot: "LoadingIndicator"
})(({
  theme: e
}) => ({
  display: "none",
  position: "absolute",
  visibility: "visible",
  top: "50%",
  left: "50%",
  transform: "translate(-50%, -50%)",
  color: (e.vars || e).palette.action.disabled,
  variants: [{
    props: {
      loading: !0
    },
    style: {
      display: "flex"
    }
  }]
})), Mq = /* @__PURE__ */ M.forwardRef(function(e, t) {
  const n = At({
    props: e,
    name: "MuiIconButton"
  }), {
    edge: r = !1,
    children: a,
    className: s,
    color: l = "default",
    disabled: c = !1,
    disableFocusRipple: d = !1,
    size: p = "medium",
    id: m,
    loading: h = null,
    loadingIndicator: v,
    ...y
  } = n, w = eg(m), x = v ?? /* @__PURE__ */ E.jsx(Oq, {
    "aria-labelledby": w,
    color: "inherit",
    size: 16
  }), b = {
    ...n,
    edge: r,
    color: l,
    disabled: c,
    disableFocusRipple: d,
    loading: h,
    loadingIndicator: x,
    size: p
  }, k = R5e(b);
  return /* @__PURE__ */ E.jsxs(A5e, {
    id: h ? w : m,
    className: Ke(k.root, s),
    centerRipple: !0,
    focusRipple: !d,
    disabled: c || h,
    ref: t,
    ...y,
    ownerState: b,
    children: [typeof h == "boolean" && // use plain HTML span to minimize the runtime overhead
    /* @__PURE__ */ E.jsx("span", {
      className: k.loadingWrapper,
      style: {
        display: "contents"
      },
      children: /* @__PURE__ */ E.jsx(j5e, {
        className: k.loadingIndicator,
        ownerState: b,
        children: h && x
      })
    }), a]
  });
});
function P5e({ uiSchema: e, registry: t, ...n }) {
  const { translateString: r } = t;
  return E.jsx(Mq, { title: r(Gt.AddItemButton), ...n, color: "primary", children: E.jsx(Cq, {}) });
}
function D5e({
  theme: e,
  ...t
}) {
  const n = xl in e ? e[xl] : void 0;
  return /* @__PURE__ */ E.jsx(t9, {
    ...t,
    themeId: n ? xl : void 0,
    theme: n || e
  });
}
const r0 = {
  colorSchemeStorageKey: "mui-color-scheme",
  defaultLightColorScheme: "light",
  defaultDarkColorScheme: "dark",
  modeStorageKey: "mui-mode"
}, {
  CssVarsProvider: $5e
} = _Q({
  themeId: xl,
  // @ts-ignore ignore module augmentation tests
  theme: () => l2({
    cssVariables: !0
  }),
  colorSchemeStorageKey: r0.colorSchemeStorageKey,
  modeStorageKey: r0.modeStorageKey,
  defaultColorScheme: {
    light: r0.defaultLightColorScheme,
    dark: r0.defaultDarkColorScheme
  },
  resolveTheme: (e) => {
    const t = {
      ...e,
      typography: i9(e.palette, e.typography)
    };
    return t.unstable_sx = function(n) {
      return od({
        sx: n,
        theme: this
      });
    }, t;
  }
}), T5e = $5e;
function L5e({
  theme: e,
  ...t
}) {
  const n = M.useMemo(() => {
    if (typeof e == "function")
      return e;
    const r = xl in e ? e[xl] : e;
    return "colorSchemes" in r ? null : "vars" in r ? e : {
      ...e,
      vars: null
    };
  }, [e]);
  return n ? /* @__PURE__ */ E.jsx(D5e, {
    theme: n,
    ...t
  }) : /* @__PURE__ */ E.jsx(T5e, {
    theme: e,
    ...t
  });
}
const I5e = wt("MuiBox", ["root"]), z5e = l2(), hd = VY({
  themeId: xl,
  defaultTheme: z5e,
  defaultClassName: I5e.root,
  generateClassName: W1.generate
}), Do = qQ({
  createStyledComponent: $e("div", {
    name: "MuiGrid",
    slot: "Root",
    overridesResolver: (e, t) => {
      const {
        ownerState: n
      } = e;
      return [t.root, n.container && t.container];
    }
  }),
  componentName: "MuiGrid",
  useThemeProps: (e) => At({
    props: e,
    name: "MuiGrid"
  }),
  useTheme: u2
});
function zI() {
  return null;
}
zI.isRequired = zI;
function F5e(e) {
  return _t("MuiPaper", e);
}
wt("MuiPaper", ["root", "rounded", "outlined", "elevation", "elevation0", "elevation1", "elevation2", "elevation3", "elevation4", "elevation5", "elevation6", "elevation7", "elevation8", "elevation9", "elevation10", "elevation11", "elevation12", "elevation13", "elevation14", "elevation15", "elevation16", "elevation17", "elevation18", "elevation19", "elevation20", "elevation21", "elevation22", "elevation23", "elevation24"]);
const B5e = (e) => {
  const {
    square: t,
    elevation: n,
    variant: r,
    classes: a
  } = e, s = {
    root: ["root", r, !t && "rounded", r === "elevation" && `elevation${n}`]
  };
  return kt(s, F5e, a);
}, U5e = $e("div", {
  name: "MuiPaper",
  slot: "Root",
  overridesResolver: (e, t) => {
    const {
      ownerState: n
    } = e;
    return [t.root, t[n.variant], !n.square && t.rounded, n.variant === "elevation" && t[`elevation${n.elevation}`]];
  }
})(Ct(({
  theme: e
}) => ({
  backgroundColor: (e.vars || e).palette.background.paper,
  color: (e.vars || e).palette.text.primary,
  transition: e.transitions.create("box-shadow"),
  variants: [{
    props: ({
      ownerState: t
    }) => !t.square,
    style: {
      borderRadius: e.shape.borderRadius
    }
  }, {
    props: {
      variant: "outlined"
    },
    style: {
      border: `1px solid ${(e.vars || e).palette.divider}`
    }
  }, {
    props: {
      variant: "elevation"
    },
    style: {
      boxShadow: "var(--Paper-shadow)",
      backgroundImage: "var(--Paper-overlay)"
    }
  }]
}))), wE = /* @__PURE__ */ M.forwardRef(function(e, t) {
  const n = At({
    props: e,
    name: "MuiPaper"
  }), r = u2(), {
    className: a,
    component: s = "div",
    elevation: l = 1,
    square: c = !1,
    variant: d = "elevation",
    ...p
  } = n, m = {
    ...n,
    component: s,
    elevation: l,
    square: c,
    variant: d
  }, h = B5e(m);
  return /* @__PURE__ */ E.jsx(U5e, {
    as: s,
    ownerState: m,
    className: Ke(h.root, a),
    ref: t,
    ...p,
    style: {
      ...d === "elevation" && {
        "--Paper-shadow": (r.vars || r).shadows[l],
        ...r.vars && {
          "--Paper-overlay": r.vars.overlays?.[l]
        },
        ...!r.vars && r.palette.mode === "dark" && {
          "--Paper-overlay": `linear-gradient(${W0("#fff", QN(l))}, ${W0("#fff", QN(l))})`
        }
      },
      ...p.style
    }
  });
});
function V5e(e) {
  const { children: t, buttonsProps: n, hasDescription: r, hasToolbar: a, uiSchema: s, registry: l } = e, c = ht(s), d = bt("ArrayFieldItemButtonsTemplate", l, c), p = {
    flex: 1,
    paddingLeft: 6,
    paddingRight: 6,
    fontWeight: "bold",
    minWidth: 0
  };
  return E.jsxs(Do, { container: !0, alignItems: "center", children: [E.jsx(Do, { size: { xs: 8, sm: 9, md: 10, lg: 11, xl: 11.25 }, style: { overflow: "auto" }, children: E.jsx(hd, { mb: 2, children: E.jsx(wE, { elevation: 2, children: E.jsx(hd, { p: 2, children: t }) }) }) }), a && E.jsx(Do, { sx: { mt: r ? -5 : -1.5 }, children: E.jsx(d, { ...n, style: p }) })] });
}
function H5e(e) {
  const { canAdd: t, disabled: n, fieldPathId: r, uiSchema: a, items: s, optionalDataControl: l, onAddClick: c, readonly: d, registry: p, required: m, schema: h, title: v } = e, y = ht(a), w = bt("ArrayFieldDescriptionTemplate", p, y), x = bt("ArrayFieldTitleTemplate", p, y), b = !d && !n, { ButtonTemplates: { AddButton: k } } = p.templates;
  return E.jsx(wE, { elevation: 2, children: E.jsxs(hd, { p: 2, children: [E.jsx(x, { fieldPathId: r, title: y.title || v, schema: h, uiSchema: a, required: m, registry: p, optionalDataControl: b ? l : void 0 }), E.jsx(w, { fieldPathId: r, description: y.description || h.description, schema: h, uiSchema: a, registry: p }), b ? void 0 : l, s, t && E.jsx(Do, { container: !0, justifyContent: "flex-end", children: E.jsx(Do, { children: E.jsx(hd, { mt: 2, children: E.jsx(k, { id: vl(r, "add"), className: "rjsf-array-item-add", onClick: c, disabled: n || d, uiSchema: a, registry: p }) }) }) })] }) });
}
function o0(e) {
  return parseInt(e, 10) || 0;
}
const q5e = {
  shadow: {
    // Visibility needed to hide the extra text area on iPads
    visibility: "hidden",
    // Remove from the content flow
    position: "absolute",
    // Ignore the scrollbar width
    overflow: "hidden",
    height: 0,
    top: 0,
    left: 0,
    // Create a new layer, increase the isolation of the computed values
    transform: "translateZ(0)"
  }
};
function W5e(e) {
  for (const t in e)
    return !1;
  return !0;
}
function FI(e) {
  return W5e(e) || e.outerHeightStyle === 0 && !e.overflowing;
}
const G5e = /* @__PURE__ */ M.forwardRef(function(e, t) {
  const {
    onChange: n,
    maxRows: r,
    minRows: a = 1,
    style: s,
    value: l,
    ...c
  } = e, {
    current: d
  } = M.useRef(l != null), p = M.useRef(null), m = no(t, p), h = M.useRef(null), v = M.useRef(null), y = M.useCallback(() => {
    const C = p.current, _ = v.current;
    if (!C || !_)
      return;
    const O = Cc(C).getComputedStyle(C);
    if (O.width === "0px")
      return {
        outerHeightStyle: 0,
        overflowing: !1
      };
    _.style.width = O.width, _.value = C.value || e.placeholder || "x", _.value.slice(-1) === `
` && (_.value += " ");
    const N = O.boxSizing, R = o0(O.paddingBottom) + o0(O.paddingTop), j = o0(O.borderBottomWidth) + o0(O.borderTopWidth), D = _.scrollHeight;
    _.value = "x";
    const $ = _.scrollHeight;
    let z = D;
    a && (z = Math.max(Number(a) * $, z)), r && (z = Math.min(Number(r) * $, z)), z = Math.max(z, $);
    const B = z + (N === "border-box" ? R + j : 0), P = Math.abs(z - D) <= 1;
    return {
      outerHeightStyle: B,
      overflowing: P
    };
  }, [r, a, e.placeholder]), w = Sl(() => {
    const C = p.current, _ = y();
    if (!C || !_ || FI(_))
      return !1;
    const O = _.outerHeightStyle;
    return h.current != null && h.current !== O;
  }), x = M.useCallback(() => {
    const C = p.current, _ = y();
    if (!C || !_ || FI(_))
      return;
    const O = _.outerHeightStyle;
    h.current !== O && (h.current = O, C.style.height = `${O}px`), C.style.overflow = _.overflowing ? "hidden" : "";
  }, [y]), b = M.useRef(-1);
  zs(() => {
    const C = _q(x), _ = p?.current;
    if (!_)
      return;
    const O = Cc(_);
    O.addEventListener("resize", C);
    let N;
    return typeof ResizeObserver < "u" && (N = new ResizeObserver(() => {
      w() && (N.unobserve(_), cancelAnimationFrame(b.current), x(), b.current = requestAnimationFrame(() => {
        N.observe(_);
      }));
    }), N.observe(_)), () => {
      C.clear(), cancelAnimationFrame(b.current), O.removeEventListener("resize", C), N && N.disconnect();
    };
  }, [y, x, w]), zs(() => {
    x();
  });
  const k = (C) => {
    d || x();
    const _ = C.target, O = _.value.length, N = _.value.endsWith(`
`), R = _.selectionStart === O;
    N && R && _.setSelectionRange(O, O), n && n(C);
  };
  return /* @__PURE__ */ E.jsxs(M.Fragment, {
    children: [/* @__PURE__ */ E.jsx("textarea", {
      value: l,
      onChange: k,
      ref: m,
      rows: a,
      style: s,
      ...c
    }), /* @__PURE__ */ E.jsx("textarea", {
      "aria-hidden": !0,
      className: e.className,
      readOnly: !0,
      ref: v,
      tabIndex: -1,
      style: {
        ...q5e.shadow,
        ...s,
        paddingTop: 0,
        paddingBottom: 0
      }
    })]
  });
});
function bd({
  props: e,
  states: t,
  muiFormControl: n
}) {
  return t.reduce((r, a) => (r[a] = e[a], n && typeof e[a] > "u" && (r[a] = n[a]), r), {});
}
const m4 = /* @__PURE__ */ M.createContext(void 0);
function Ll() {
  return M.useContext(m4);
}
function BI(e) {
  return e != null && !(Array.isArray(e) && e.length === 0);
}
function $_(e, t = !1) {
  return e && (BI(e.value) && e.value !== "" || t && BI(e.defaultValue) && e.defaultValue !== "");
}
function K5e(e) {
  return e.startAdornment;
}
function X5e(e) {
  return _t("MuiInputBase", e);
}
const Xh = wt("MuiInputBase", ["root", "formControl", "focused", "disabled", "adornedStart", "adornedEnd", "error", "sizeSmall", "multiline", "colorSecondary", "fullWidth", "hiddenLabel", "readOnly", "input", "inputSizeSmall", "inputMultiline", "inputTypeSearch", "inputAdornedStart", "inputAdornedEnd", "inputHiddenLabel"]);
var UI;
const xE = (e, t) => {
  const {
    ownerState: n
  } = e;
  return [t.root, n.formControl && t.formControl, n.startAdornment && t.adornedStart, n.endAdornment && t.adornedEnd, n.error && t.error, n.size === "small" && t.sizeSmall, n.multiline && t.multiline, n.color && t[`color${qe(n.color)}`], n.fullWidth && t.fullWidth, n.hiddenLabel && t.hiddenLabel];
}, SE = (e, t) => {
  const {
    ownerState: n
  } = e;
  return [t.input, n.size === "small" && t.inputSizeSmall, n.multiline && t.inputMultiline, n.type === "search" && t.inputTypeSearch, n.startAdornment && t.inputAdornedStart, n.endAdornment && t.inputAdornedEnd, n.hiddenLabel && t.inputHiddenLabel];
}, Y5e = (e) => {
  const {
    classes: t,
    color: n,
    disabled: r,
    error: a,
    endAdornment: s,
    focused: l,
    formControl: c,
    fullWidth: d,
    hiddenLabel: p,
    multiline: m,
    readOnly: h,
    size: v,
    startAdornment: y,
    type: w
  } = e, x = {
    root: ["root", `color${qe(n)}`, r && "disabled", a && "error", d && "fullWidth", l && "focused", c && "formControl", v && v !== "medium" && `size${qe(v)}`, m && "multiline", y && "adornedStart", s && "adornedEnd", p && "hiddenLabel", h && "readOnly"],
    input: ["input", r && "disabled", w === "search" && "inputTypeSearch", m && "inputMultiline", v === "small" && "inputSizeSmall", p && "inputHiddenLabel", y && "inputAdornedStart", s && "inputAdornedEnd", h && "readOnly"]
  };
  return kt(x, X5e, t);
}, kE = $e("div", {
  name: "MuiInputBase",
  slot: "Root",
  overridesResolver: xE
})(Ct(({
  theme: e
}) => ({
  ...e.typography.body1,
  color: (e.vars || e).palette.text.primary,
  lineHeight: "1.4375em",
  // 23px
  boxSizing: "border-box",
  // Prevent padding issue with fullWidth.
  position: "relative",
  cursor: "text",
  display: "inline-flex",
  alignItems: "center",
  [`&.${Xh.disabled}`]: {
    color: (e.vars || e).palette.text.disabled,
    cursor: "default"
  },
  variants: [{
    props: ({
      ownerState: t
    }) => t.multiline,
    style: {
      padding: "4px 0 5px"
    }
  }, {
    props: ({
      ownerState: t,
      size: n
    }) => t.multiline && n === "small",
    style: {
      paddingTop: 1
    }
  }, {
    props: ({
      ownerState: t
    }) => t.fullWidth,
    style: {
      width: "100%"
    }
  }]
}))), _E = $e("input", {
  name: "MuiInputBase",
  slot: "Input",
  overridesResolver: SE
})(Ct(({
  theme: e
}) => {
  const t = e.palette.mode === "light", n = {
    color: "currentColor",
    ...e.vars ? {
      opacity: e.vars.opacity.inputPlaceholder
    } : {
      opacity: t ? 0.42 : 0.5
    },
    transition: e.transitions.create("opacity", {
      duration: e.transitions.duration.shorter
    })
  }, r = {
    opacity: "0 !important"
  }, a = e.vars ? {
    opacity: e.vars.opacity.inputPlaceholder
  } : {
    opacity: t ? 0.42 : 0.5
  };
  return {
    font: "inherit",
    letterSpacing: "inherit",
    color: "currentColor",
    padding: "4px 0 5px",
    border: 0,
    boxSizing: "content-box",
    background: "none",
    height: "1.4375em",
    // Reset 23pxthe native input line-height
    margin: 0,
    // Reset for Safari
    WebkitTapHighlightColor: "transparent",
    display: "block",
    // Make the flex item shrink with Firefox
    minWidth: 0,
    width: "100%",
    "&::-webkit-input-placeholder": n,
    "&::-moz-placeholder": n,
    // Firefox 19+
    "&::-ms-input-placeholder": n,
    // Edge
    "&:focus": {
      outline: 0
    },
    // Reset Firefox invalid required input style
    "&:invalid": {
      boxShadow: "none"
    },
    "&::-webkit-search-decoration": {
      // Remove the padding when type=search.
      WebkitAppearance: "none"
    },
    // Show and hide the placeholder logic
    [`label[data-shrink=false] + .${Xh.formControl} &`]: {
      "&::-webkit-input-placeholder": r,
      "&::-moz-placeholder": r,
      // Firefox 19+
      "&::-ms-input-placeholder": r,
      // Edge
      "&:focus::-webkit-input-placeholder": a,
      "&:focus::-moz-placeholder": a,
      // Firefox 19+
      "&:focus::-ms-input-placeholder": a
      // Edge
    },
    [`&.${Xh.disabled}`]: {
      opacity: 1,
      // Reset iOS opacity
      WebkitTextFillColor: (e.vars || e).palette.text.disabled
      // Fix opacity Safari bug
    },
    variants: [{
      props: ({
        ownerState: s
      }) => !s.disableInjectingGlobalStyles,
      style: {
        animationName: "mui-auto-fill-cancel",
        animationDuration: "10ms",
        "&:-webkit-autofill": {
          animationDuration: "5000s",
          animationName: "mui-auto-fill"
        }
      }
    }, {
      props: {
        size: "small"
      },
      style: {
        paddingTop: 1
      }
    }, {
      props: ({
        ownerState: s
      }) => s.multiline,
      style: {
        height: "auto",
        resize: "none",
        padding: 0,
        paddingTop: 0
      }
    }, {
      props: {
        type: "search"
      },
      style: {
        MozAppearance: "textfield"
        // Improve type search style.
      }
    }]
  };
})), VI = EJ({
  "@keyframes mui-auto-fill": {
    from: {
      display: "block"
    }
  },
  "@keyframes mui-auto-fill-cancel": {
    from: {
      display: "block"
    }
  }
}), h4 = /* @__PURE__ */ M.forwardRef(function(e, t) {
  const n = At({
    props: e,
    name: "MuiInputBase"
  }), {
    "aria-describedby": r,
    autoComplete: a,
    autoFocus: s,
    className: l,
    color: c,
    components: d = {},
    componentsProps: p = {},
    defaultValue: m,
    disabled: h,
    disableInjectingGlobalStyles: v,
    endAdornment: y,
    error: w,
    fullWidth: x = !1,
    id: b,
    inputComponent: k = "input",
    inputProps: C = {},
    inputRef: _,
    margin: O,
    maxRows: N,
    minRows: R,
    multiline: j = !1,
    name: D,
    onBlur: $,
    onChange: z,
    onClick: B,
    onFocus: P,
    onKeyDown: W,
    onKeyUp: I,
    placeholder: G,
    readOnly: L,
    renderSuffix: K,
    rows: q,
    size: Z,
    slotProps: V = {},
    slots: F = {},
    startAdornment: X,
    type: U = "text",
    value: H,
    ...Q
  } = n, re = C.value != null ? C.value : H, {
    current: de
  } = M.useRef(re != null), le = M.useRef(), me = M.useCallback((ze) => {
  }, []), ve = no(le, _, C.ref, me), [ae, se] = M.useState(!1), pe = Ll(), ge = bd({
    props: n,
    muiFormControl: pe,
    states: ["color", "disabled", "error", "hiddenLabel", "size", "required", "filled"]
  });
  ge.focused = pe ? pe.focused : ae, M.useEffect(() => {
    !pe && h && ae && (se(!1), $ && $());
  }, [pe, h, ae, $]);
  const xe = pe && pe.onFilled, _e = pe && pe.onEmpty, We = M.useCallback((ze) => {
    $_(ze) ? xe && xe() : _e && _e();
  }, [xe, _e]);
  zs(() => {
    de && We({
      value: re
    });
  }, [re, We, de]);
  const Xe = (ze) => {
    P && P(ze), C.onFocus && C.onFocus(ze), pe && pe.onFocus ? pe.onFocus(ze) : se(!0);
  }, et = (ze) => {
    $ && $(ze), C.onBlur && C.onBlur(ze), pe && pe.onBlur ? pe.onBlur(ze) : se(!1);
  }, tt = (ze, ...It) => {
    if (!de) {
      const zt = ze.target || le.current;
      if (zt == null)
        throw new Error(vc(1));
      We({
        value: zt.value
      });
    }
    C.onChange && C.onChange(ze, ...It), z && z(ze, ...It);
  };
  M.useEffect(() => {
    We(le.current);
  }, []);
  const je = (ze) => {
    le.current && ze.currentTarget === ze.target && le.current.focus(), B && B(ze);
  };
  let an = k, dt = C;
  j && an === "input" && (q ? dt = {
    type: void 0,
    minRows: q,
    maxRows: q,
    ...dt
  } : dt = {
    type: void 0,
    maxRows: N,
    minRows: R,
    ...dt
  }, an = G5e);
  const Ce = (ze) => {
    We(ze.animationName === "mui-auto-fill-cancel" ? le.current : {
      value: "x"
    });
  };
  M.useEffect(() => {
    pe && pe.setAdornedStart(!!X);
  }, [pe, X]);
  const Me = {
    ...n,
    color: ge.color || "primary",
    disabled: ge.disabled,
    endAdornment: y,
    error: ge.error,
    focused: ge.focused,
    formControl: pe,
    fullWidth: x,
    hiddenLabel: ge.hiddenLabel,
    multiline: j,
    size: ge.size,
    startAdornment: X,
    type: U
  }, he = Y5e(Me), ye = F.root || d.Root || kE, Ee = V.root || p.root || {}, Le = F.input || d.Input || _E;
  return dt = {
    ...dt,
    ...V.input ?? p.input
  }, /* @__PURE__ */ E.jsxs(M.Fragment, {
    children: [!v && typeof VI == "function" && // For Emotion/Styled-components, InputGlobalStyles will be a function
    // For Pigment CSS, this has no effect because the InputGlobalStyles will be null.
    (UI || (UI = /* @__PURE__ */ E.jsx(VI, {}))), /* @__PURE__ */ E.jsxs(ye, {
      ...Ee,
      ref: t,
      onClick: je,
      ...Q,
      ...!kl(ye) && {
        ownerState: {
          ...Me,
          ...Ee.ownerState
        }
      },
      className: Ke(he.root, Ee.className, l, L && "MuiInputBase-readOnly"),
      children: [X, /* @__PURE__ */ E.jsx(m4.Provider, {
        value: null,
        children: /* @__PURE__ */ E.jsx(Le, {
          "aria-invalid": ge.error,
          "aria-describedby": r,
          autoComplete: a,
          autoFocus: s,
          defaultValue: m,
          disabled: ge.disabled,
          id: b,
          onAnimationStart: Ce,
          name: D,
          placeholder: G,
          readOnly: L,
          required: ge.required,
          rows: q,
          value: re,
          onKeyDown: W,
          onKeyUp: I,
          type: U,
          ...dt,
          ...!kl(Le) && {
            as: an,
            ownerState: {
              ...Me,
              ...dt.ownerState
            }
          },
          ref: ve,
          className: Ke(he.input, dt.className, L && "MuiInputBase-readOnly"),
          onBlur: et,
          onChange: tt,
          onFocus: Xe
        })
      }), y, K ? K({
        ...ge,
        startAdornment: X
      }) : null]
    })]
  });
});
function Q5e(e) {
  return _t("MuiInput", e);
}
const ww = {
  ...Xh,
  ...wt("MuiInput", ["root", "underline", "input"])
}, J5e = (e) => {
  const {
    classes: t,
    disableUnderline: n
  } = e, r = kt({
    root: ["root", !n && "underline"],
    input: ["input"]
  }, Q5e, t);
  return {
    ...t,
    // forward classes to the InputBase
    ...r
  };
}, Z5e = $e(kE, {
  shouldForwardProp: (e) => Xo(e) || e === "classes",
  name: "MuiInput",
  slot: "Root",
  overridesResolver: (e, t) => {
    const {
      ownerState: n
    } = e;
    return [...xE(e, t), !n.disableUnderline && t.underline];
  }
})(Ct(({
  theme: e
}) => {
  let t = e.palette.mode === "light" ? "rgba(0, 0, 0, 0.42)" : "rgba(255, 255, 255, 0.7)";
  return e.vars && (t = e.alpha(e.vars.palette.common.onBackground, e.vars.opacity.inputUnderline)), {
    position: "relative",
    variants: [{
      props: ({
        ownerState: n
      }) => n.formControl,
      style: {
        "label + &": {
          marginTop: 16
        }
      }
    }, {
      props: ({
        ownerState: n
      }) => !n.disableUnderline,
      style: {
        "&::after": {
          left: 0,
          bottom: 0,
          content: '""',
          position: "absolute",
          right: 0,
          transform: "scaleX(0)",
          transition: e.transitions.create("transform", {
            duration: e.transitions.duration.shorter,
            easing: e.transitions.easing.easeOut
          }),
          pointerEvents: "none"
          // Transparent to the hover style.
        },
        [`&.${ww.focused}:after`]: {
          // translateX(0) is a workaround for Safari transform scale bug
          // See https://github.com/mui/material-ui/issues/31766
          transform: "scaleX(1) translateX(0)"
        },
        [`&.${ww.error}`]: {
          "&::before, &::after": {
            borderBottomColor: (e.vars || e).palette.error.main
          }
        },
        "&::before": {
          borderBottom: `1px solid ${t}`,
          left: 0,
          bottom: 0,
          content: '"\\00a0"',
          position: "absolute",
          right: 0,
          transition: e.transitions.create("border-bottom-color", {
            duration: e.transitions.duration.shorter
          }),
          pointerEvents: "none"
          // Transparent to the hover style.
        },
        [`&:hover:not(.${ww.disabled}, .${ww.error}):before`]: {
          borderBottom: `2px solid ${(e.vars || e).palette.text.primary}`,
          // Reset on touch devices, it doesn't add specificity
          "@media (hover: none)": {
            borderBottom: `1px solid ${t}`
          }
        },
        [`&.${ww.disabled}:before`]: {
          borderBottomStyle: "dotted"
        }
      }
    }, ...Object.entries(e.palette).filter(Ko()).map(([n]) => ({
      props: {
        color: n,
        disableUnderline: !1
      },
      style: {
        "&::after": {
          borderBottom: `2px solid ${(e.vars || e).palette[n].main}`
        }
      }
    }))]
  };
})), e3e = $e(_E, {
  name: "MuiInput",
  slot: "Input",
  overridesResolver: SE
})({}), g4 = /* @__PURE__ */ M.forwardRef(function(e, t) {
  const n = At({
    props: e,
    name: "MuiInput"
  }), {
    disableUnderline: r = !1,
    components: a = {},
    componentsProps: s,
    fullWidth: l = !1,
    inputComponent: c = "input",
    multiline: d = !1,
    slotProps: p,
    slots: m = {},
    type: h = "text",
    ...v
  } = n, y = J5e(n), w = {
    root: {
      ownerState: {
        disableUnderline: r
      }
    }
  }, x = p ?? s ? Go(p ?? s, w) : w, b = m.root ?? a.Root ?? Z5e, k = m.input ?? a.Input ?? e3e;
  return /* @__PURE__ */ E.jsx(h4, {
    slots: {
      root: b,
      input: k
    },
    slotProps: x,
    fullWidth: l,
    inputComponent: c,
    multiline: d,
    ref: t,
    type: h,
    ...v,
    classes: y
  });
});
g4.muiName = "Input";
function t3e(e) {
  return _t("MuiFilledInput", e);
}
const Hp = {
  ...Xh,
  ...wt("MuiFilledInput", ["root", "underline", "input", "adornedStart", "adornedEnd", "sizeSmall", "multiline", "hiddenLabel"])
}, n3e = (e) => {
  const {
    classes: t,
    disableUnderline: n,
    startAdornment: r,
    endAdornment: a,
    size: s,
    hiddenLabel: l,
    multiline: c
  } = e, d = {
    root: ["root", !n && "underline", r && "adornedStart", a && "adornedEnd", s === "small" && `size${qe(s)}`, l && "hiddenLabel", c && "multiline"],
    input: ["input"]
  }, p = kt(d, t3e, t);
  return {
    ...t,
    // forward classes to the InputBase
    ...p
  };
}, r3e = $e(kE, {
  shouldForwardProp: (e) => Xo(e) || e === "classes",
  name: "MuiFilledInput",
  slot: "Root",
  overridesResolver: (e, t) => {
    const {
      ownerState: n
    } = e;
    return [...xE(e, t), !n.disableUnderline && t.underline];
  }
})(Ct(({
  theme: e
}) => {
  const t = e.palette.mode === "light", n = t ? "rgba(0, 0, 0, 0.42)" : "rgba(255, 255, 255, 0.7)", r = t ? "rgba(0, 0, 0, 0.06)" : "rgba(255, 255, 255, 0.09)", a = t ? "rgba(0, 0, 0, 0.09)" : "rgba(255, 255, 255, 0.13)", s = t ? "rgba(0, 0, 0, 0.12)" : "rgba(255, 255, 255, 0.12)";
  return {
    position: "relative",
    backgroundColor: e.vars ? e.vars.palette.FilledInput.bg : r,
    borderTopLeftRadius: (e.vars || e).shape.borderRadius,
    borderTopRightRadius: (e.vars || e).shape.borderRadius,
    transition: e.transitions.create("background-color", {
      duration: e.transitions.duration.shorter,
      easing: e.transitions.easing.easeOut
    }),
    "&:hover": {
      backgroundColor: e.vars ? e.vars.palette.FilledInput.hoverBg : a,
      // Reset on touch devices, it doesn't add specificity
      "@media (hover: none)": {
        backgroundColor: e.vars ? e.vars.palette.FilledInput.bg : r
      }
    },
    [`&.${Hp.focused}`]: {
      backgroundColor: e.vars ? e.vars.palette.FilledInput.bg : r
    },
    [`&.${Hp.disabled}`]: {
      backgroundColor: e.vars ? e.vars.palette.FilledInput.disabledBg : s
    },
    variants: [{
      props: ({
        ownerState: l
      }) => !l.disableUnderline,
      style: {
        "&::after": {
          left: 0,
          bottom: 0,
          content: '""',
          position: "absolute",
          right: 0,
          transform: "scaleX(0)",
          transition: e.transitions.create("transform", {
            duration: e.transitions.duration.shorter,
            easing: e.transitions.easing.easeOut
          }),
          pointerEvents: "none"
          // Transparent to the hover style.
        },
        [`&.${Hp.focused}:after`]: {
          // translateX(0) is a workaround for Safari transform scale bug
          // See https://github.com/mui/material-ui/issues/31766
          transform: "scaleX(1) translateX(0)"
        },
        [`&.${Hp.error}`]: {
          "&::before, &::after": {
            borderBottomColor: (e.vars || e).palette.error.main
          }
        },
        "&::before": {
          borderBottom: `1px solid ${e.vars ? e.alpha(e.vars.palette.common.onBackground, e.vars.opacity.inputUnderline) : n}`,
          left: 0,
          bottom: 0,
          content: '"\\00a0"',
          position: "absolute",
          right: 0,
          transition: e.transitions.create("border-bottom-color", {
            duration: e.transitions.duration.shorter
          }),
          pointerEvents: "none"
          // Transparent to the hover style.
        },
        [`&:hover:not(.${Hp.disabled}, .${Hp.error}):before`]: {
          borderBottom: `1px solid ${(e.vars || e).palette.text.primary}`
        },
        [`&.${Hp.disabled}:before`]: {
          borderBottomStyle: "dotted"
        }
      }
    }, ...Object.entries(e.palette).filter(Ko()).map(([l]) => ({
      props: {
        disableUnderline: !1,
        color: l
      },
      style: {
        "&::after": {
          borderBottom: `2px solid ${(e.vars || e).palette[l]?.main}`
        }
      }
    })), {
      props: ({
        ownerState: l
      }) => l.startAdornment,
      style: {
        paddingLeft: 12
      }
    }, {
      props: ({
        ownerState: l
      }) => l.endAdornment,
      style: {
        paddingRight: 12
      }
    }, {
      props: ({
        ownerState: l
      }) => l.multiline,
      style: {
        padding: "25px 12px 8px"
      }
    }, {
      props: ({
        ownerState: l,
        size: c
      }) => l.multiline && c === "small",
      style: {
        paddingTop: 21,
        paddingBottom: 4
      }
    }, {
      props: ({
        ownerState: l
      }) => l.multiline && l.hiddenLabel,
      style: {
        paddingTop: 16,
        paddingBottom: 17
      }
    }, {
      props: ({
        ownerState: l
      }) => l.multiline && l.hiddenLabel && l.size === "small",
      style: {
        paddingTop: 8,
        paddingBottom: 9
      }
    }]
  };
})), o3e = $e(_E, {
  name: "MuiFilledInput",
  slot: "Input",
  overridesResolver: SE
})(Ct(({
  theme: e
}) => ({
  paddingTop: 25,
  paddingRight: 12,
  paddingBottom: 8,
  paddingLeft: 12,
  ...!e.vars && {
    "&:-webkit-autofill": {
      WebkitBoxShadow: e.palette.mode === "light" ? null : "0 0 0 100px #266798 inset",
      WebkitTextFillColor: e.palette.mode === "light" ? null : "#fff",
      caretColor: e.palette.mode === "light" ? null : "#fff",
      borderTopLeftRadius: "inherit",
      borderTopRightRadius: "inherit"
    }
  },
  ...e.vars && {
    "&:-webkit-autofill": {
      borderTopLeftRadius: "inherit",
      borderTopRightRadius: "inherit"
    },
    [e.getColorSchemeSelector("dark")]: {
      "&:-webkit-autofill": {
        WebkitBoxShadow: "0 0 0 100px #266798 inset",
        WebkitTextFillColor: "#fff",
        caretColor: "#fff"
      }
    }
  },
  variants: [{
    props: {
      size: "small"
    },
    style: {
      paddingTop: 21,
      paddingBottom: 4
    }
  }, {
    props: ({
      ownerState: t
    }) => t.hiddenLabel,
    style: {
      paddingTop: 16,
      paddingBottom: 17
    }
  }, {
    props: ({
      ownerState: t
    }) => t.startAdornment,
    style: {
      paddingLeft: 0
    }
  }, {
    props: ({
      ownerState: t
    }) => t.endAdornment,
    style: {
      paddingRight: 0
    }
  }, {
    props: ({
      ownerState: t
    }) => t.hiddenLabel && t.size === "small",
    style: {
      paddingTop: 8,
      paddingBottom: 9
    }
  }, {
    props: ({
      ownerState: t
    }) => t.multiline,
    style: {
      paddingTop: 0,
      paddingBottom: 0,
      paddingLeft: 0,
      paddingRight: 0
    }
  }]
}))), v4 = /* @__PURE__ */ M.forwardRef(function(e, t) {
  const n = At({
    props: e,
    name: "MuiFilledInput"
  }), {
    disableUnderline: r = !1,
    components: a = {},
    componentsProps: s,
    fullWidth: l = !1,
    hiddenLabel: c,
    // declare here to prevent spreading to DOM
    inputComponent: d = "input",
    multiline: p = !1,
    slotProps: m,
    slots: h = {},
    type: v = "text",
    ...y
  } = n, w = {
    ...n,
    disableUnderline: r,
    fullWidth: l,
    inputComponent: d,
    multiline: p,
    type: v
  }, x = n3e(n), b = {
    root: {
      ownerState: w
    },
    input: {
      ownerState: w
    }
  }, k = m ?? s ? Go(b, m ?? s) : b, C = h.root ?? a.Root ?? r3e, _ = h.input ?? a.Input ?? o3e;
  return /* @__PURE__ */ E.jsx(h4, {
    slots: {
      root: C,
      input: _
    },
    slotProps: k,
    fullWidth: l,
    inputComponent: d,
    multiline: p,
    ref: t,
    type: v,
    ...y,
    classes: x
  });
});
v4.muiName = "Input";
var HI;
const a3e = $e("fieldset", {
  name: "MuiNotchedOutlined",
  shouldForwardProp: Xo
})({
  textAlign: "left",
  position: "absolute",
  bottom: 0,
  right: 0,
  top: -5,
  left: 0,
  margin: 0,
  padding: "0 8px",
  pointerEvents: "none",
  borderRadius: "inherit",
  borderStyle: "solid",
  borderWidth: 1,
  overflow: "hidden",
  minWidth: "0%"
}), i3e = $e("legend", {
  name: "MuiNotchedOutlined",
  shouldForwardProp: Xo
})(Ct(({
  theme: e
}) => ({
  float: "unset",
  // Fix conflict with bootstrap
  width: "auto",
  // Fix conflict with bootstrap
  overflow: "hidden",
  // Fix Horizontal scroll when label too long
  variants: [{
    props: ({
      ownerState: t
    }) => !t.withLabel,
    style: {
      padding: 0,
      lineHeight: "11px",
      // sync with `height` in `legend` styles
      transition: e.transitions.create("width", {
        duration: 150,
        easing: e.transitions.easing.easeOut
      })
    }
  }, {
    props: ({
      ownerState: t
    }) => t.withLabel,
    style: {
      display: "block",
      // Fix conflict with normalize.css and sanitize.css
      padding: 0,
      height: 11,
      // sync with `lineHeight` in `legend` styles
      fontSize: "0.75em",
      visibility: "hidden",
      maxWidth: 0.01,
      transition: e.transitions.create("max-width", {
        duration: 50,
        easing: e.transitions.easing.easeOut
      }),
      whiteSpace: "nowrap",
      "& > span": {
        paddingLeft: 5,
        paddingRight: 5,
        display: "inline-block",
        opacity: 0,
        visibility: "visible"
      }
    }
  }, {
    props: ({
      ownerState: t
    }) => t.withLabel && t.notched,
    style: {
      maxWidth: "100%",
      transition: e.transitions.create("max-width", {
        duration: 100,
        easing: e.transitions.easing.easeOut,
        delay: 50
      })
    }
  }]
})));
function s3e(e) {
  const {
    children: t,
    classes: n,
    className: r,
    label: a,
    notched: s,
    ...l
  } = e, c = a != null && a !== "", d = {
    ...e,
    notched: s,
    withLabel: c
  };
  return /* @__PURE__ */ E.jsx(a3e, {
    "aria-hidden": !0,
    className: r,
    ownerState: d,
    ...l,
    children: /* @__PURE__ */ E.jsx(i3e, {
      ownerState: d,
      children: c ? /* @__PURE__ */ E.jsx("span", {
        children: a
      }) : (
        // notranslate needed while Google Translate will not fix zero-width space issue
        HI || (HI = /* @__PURE__ */ E.jsx("span", {
          className: "notranslate",
          "aria-hidden": !0,
          children: ""
        }))
      )
    })
  });
}
function l3e(e) {
  return _t("MuiOutlinedInput", e);
}
const el = {
  ...Xh,
  ...wt("MuiOutlinedInput", ["root", "notchedOutline", "input"])
}, u3e = (e) => {
  const {
    classes: t
  } = e, n = kt({
    root: ["root"],
    notchedOutline: ["notchedOutline"],
    input: ["input"]
  }, l3e, t);
  return {
    ...t,
    // forward classes to the InputBase
    ...n
  };
}, c3e = $e(kE, {
  shouldForwardProp: (e) => Xo(e) || e === "classes",
  name: "MuiOutlinedInput",
  slot: "Root",
  overridesResolver: xE
})(Ct(({
  theme: e
}) => {
  const t = e.palette.mode === "light" ? "rgba(0, 0, 0, 0.23)" : "rgba(255, 255, 255, 0.23)";
  return {
    position: "relative",
    borderRadius: (e.vars || e).shape.borderRadius,
    [`&:hover .${el.notchedOutline}`]: {
      borderColor: (e.vars || e).palette.text.primary
    },
    // Reset on touch devices, it doesn't add specificity
    "@media (hover: none)": {
      [`&:hover .${el.notchedOutline}`]: {
        borderColor: e.vars ? e.alpha(e.vars.palette.common.onBackground, 0.23) : t
      }
    },
    [`&.${el.focused} .${el.notchedOutline}`]: {
      borderWidth: 2
    },
    variants: [...Object.entries(e.palette).filter(Ko()).map(([n]) => ({
      props: {
        color: n
      },
      style: {
        [`&.${el.focused} .${el.notchedOutline}`]: {
          borderColor: (e.vars || e).palette[n].main
        }
      }
    })), {
      props: {},
      // to override the above style
      style: {
        [`&.${el.error} .${el.notchedOutline}`]: {
          borderColor: (e.vars || e).palette.error.main
        },
        [`&.${el.disabled} .${el.notchedOutline}`]: {
          borderColor: (e.vars || e).palette.action.disabled
        }
      }
    }, {
      props: ({
        ownerState: n
      }) => n.startAdornment,
      style: {
        paddingLeft: 14
      }
    }, {
      props: ({
        ownerState: n
      }) => n.endAdornment,
      style: {
        paddingRight: 14
      }
    }, {
      props: ({
        ownerState: n
      }) => n.multiline,
      style: {
        padding: "16.5px 14px"
      }
    }, {
      props: ({
        ownerState: n,
        size: r
      }) => n.multiline && r === "small",
      style: {
        padding: "8.5px 14px"
      }
    }]
  };
})), d3e = $e(s3e, {
  name: "MuiOutlinedInput",
  slot: "NotchedOutline"
})(Ct(({
  theme: e
}) => {
  const t = e.palette.mode === "light" ? "rgba(0, 0, 0, 0.23)" : "rgba(255, 255, 255, 0.23)";
  return {
    borderColor: e.vars ? e.alpha(e.vars.palette.common.onBackground, 0.23) : t
  };
})), f3e = $e(_E, {
  name: "MuiOutlinedInput",
  slot: "Input",
  overridesResolver: SE
})(Ct(({
  theme: e
}) => ({
  padding: "16.5px 14px",
  ...!e.vars && {
    "&:-webkit-autofill": {
      WebkitBoxShadow: e.palette.mode === "light" ? null : "0 0 0 100px #266798 inset",
      WebkitTextFillColor: e.palette.mode === "light" ? null : "#fff",
      caretColor: e.palette.mode === "light" ? null : "#fff",
      borderRadius: "inherit"
    }
  },
  ...e.vars && {
    "&:-webkit-autofill": {
      borderRadius: "inherit"
    },
    [e.getColorSchemeSelector("dark")]: {
      "&:-webkit-autofill": {
        WebkitBoxShadow: "0 0 0 100px #266798 inset",
        WebkitTextFillColor: "#fff",
        caretColor: "#fff"
      }
    }
  },
  variants: [{
    props: {
      size: "small"
    },
    style: {
      padding: "8.5px 14px"
    }
  }, {
    props: ({
      ownerState: t
    }) => t.multiline,
    style: {
      padding: 0
    }
  }, {
    props: ({
      ownerState: t
    }) => t.startAdornment,
    style: {
      paddingLeft: 0
    }
  }, {
    props: ({
      ownerState: t
    }) => t.endAdornment,
    style: {
      paddingRight: 0
    }
  }]
}))), y4 = /* @__PURE__ */ M.forwardRef(function(e, t) {
  const n = At({
    props: e,
    name: "MuiOutlinedInput"
  }), {
    components: r = {},
    fullWidth: a = !1,
    inputComponent: s = "input",
    label: l,
    multiline: c = !1,
    notched: d,
    slots: p = {},
    slotProps: m = {},
    type: h = "text",
    ...v
  } = n, y = u3e(n), w = Ll(), x = bd({
    props: n,
    muiFormControl: w,
    states: ["color", "disabled", "error", "focused", "hiddenLabel", "size", "required"]
  }), b = {
    ...n,
    color: x.color || "primary",
    disabled: x.disabled,
    error: x.error,
    focused: x.focused,
    formControl: w,
    fullWidth: a,
    hiddenLabel: x.hiddenLabel,
    multiline: c,
    size: x.size,
    type: h
  }, k = p.root ?? r.Root ?? c3e, C = p.input ?? r.Input ?? f3e, [_, O] = Hn("notchedOutline", {
    elementType: d3e,
    className: y.notchedOutline,
    shouldForwardComponentProp: !0,
    ownerState: b,
    externalForwardedProps: {
      slots: p,
      slotProps: m
    },
    additionalProps: {
      label: l != null && l !== "" && x.required ? /* @__PURE__ */ E.jsxs(M.Fragment, {
        children: [l, "", "*"]
      }) : l
    }
  });
  return /* @__PURE__ */ E.jsx(h4, {
    slots: {
      root: k,
      input: C
    },
    slotProps: m,
    renderSuffix: (N) => /* @__PURE__ */ E.jsx(_, {
      ...O,
      notched: typeof d < "u" ? d : !!(N.startAdornment || N.filled || N.focused)
    }),
    fullWidth: a,
    inputComponent: s,
    multiline: c,
    ref: t,
    type: h,
    ...v,
    classes: {
      ...y,
      notchedOutline: null
    }
  });
});
y4.muiName = "Input";
function p3e(e) {
  return _t("MuiFormLabel", e);
}
const nx = wt("MuiFormLabel", ["root", "colorSecondary", "focused", "disabled", "error", "filled", "required", "asterisk"]), m3e = (e) => {
  const {
    classes: t,
    color: n,
    focused: r,
    disabled: a,
    error: s,
    filled: l,
    required: c
  } = e, d = {
    root: ["root", `color${qe(n)}`, a && "disabled", s && "error", l && "filled", r && "focused", c && "required"],
    asterisk: ["asterisk", s && "error"]
  };
  return kt(d, p3e, t);
}, h3e = $e("label", {
  name: "MuiFormLabel",
  slot: "Root",
  overridesResolver: (e, t) => {
    const {
      ownerState: n
    } = e;
    return [t.root, n.color === "secondary" && t.colorSecondary, n.filled && t.filled];
  }
})(Ct(({
  theme: e
}) => ({
  color: (e.vars || e).palette.text.secondary,
  ...e.typography.body1,
  lineHeight: "1.4375em",
  padding: 0,
  position: "relative",
  variants: [...Object.entries(e.palette).filter(Ko()).map(([t]) => ({
    props: {
      color: t
    },
    style: {
      [`&.${nx.focused}`]: {
        color: (e.vars || e).palette[t].main
      }
    }
  })), {
    props: {},
    style: {
      [`&.${nx.disabled}`]: {
        color: (e.vars || e).palette.text.disabled
      },
      [`&.${nx.error}`]: {
        color: (e.vars || e).palette.error.main
      }
    }
  }]
}))), g3e = $e("span", {
  name: "MuiFormLabel",
  slot: "Asterisk"
})(Ct(({
  theme: e
}) => ({
  [`&.${nx.error}`]: {
    color: (e.vars || e).palette.error.main
  }
}))), EE = /* @__PURE__ */ M.forwardRef(function(e, t) {
  const n = At({
    props: e,
    name: "MuiFormLabel"
  }), {
    children: r,
    className: a,
    color: s,
    component: l = "label",
    disabled: c,
    error: d,
    filled: p,
    focused: m,
    required: h,
    ...v
  } = n, y = Ll(), w = bd({
    props: n,
    muiFormControl: y,
    states: ["color", "required", "focused", "disabled", "error", "filled"]
  }), x = {
    ...n,
    color: w.color || "primary",
    component: l,
    disabled: w.disabled,
    error: w.error,
    filled: w.filled,
    focused: w.focused,
    required: w.required
  }, b = m3e(x);
  return /* @__PURE__ */ E.jsxs(h3e, {
    as: l,
    ownerState: x,
    className: Ke(b.root, a),
    ref: t,
    ...v,
    children: [r, w.required && /* @__PURE__ */ E.jsxs(g3e, {
      ownerState: x,
      "aria-hidden": !0,
      className: b.asterisk,
      children: ["", "*"]
    })]
  });
});
function v3e(e) {
  return _t("MuiInputLabel", e);
}
wt("MuiInputLabel", ["root", "focused", "disabled", "error", "required", "asterisk", "formControl", "sizeSmall", "shrink", "animated", "standard", "filled", "outlined"]);
const y3e = (e) => {
  const {
    classes: t,
    formControl: n,
    size: r,
    shrink: a,
    disableAnimation: s,
    variant: l,
    required: c
  } = e, d = {
    root: ["root", n && "formControl", !s && "animated", a && "shrink", r && r !== "medium" && `size${qe(r)}`, l],
    asterisk: [c && "asterisk"]
  }, p = kt(d, v3e, t);
  return {
    ...t,
    // forward the focused, disabled, etc. classes to the FormLabel
    ...p
  };
}, b3e = $e(EE, {
  shouldForwardProp: (e) => Xo(e) || e === "classes",
  name: "MuiInputLabel",
  slot: "Root",
  overridesResolver: (e, t) => {
    const {
      ownerState: n
    } = e;
    return [{
      [`& .${nx.asterisk}`]: t.asterisk
    }, t.root, n.formControl && t.formControl, n.size === "small" && t.sizeSmall, n.shrink && t.shrink, !n.disableAnimation && t.animated, n.focused && t.focused, t[n.variant]];
  }
})(Ct(({
  theme: e
}) => ({
  display: "block",
  transformOrigin: "top left",
  whiteSpace: "nowrap",
  overflow: "hidden",
  textOverflow: "ellipsis",
  maxWidth: "100%",
  variants: [{
    props: ({
      ownerState: t
    }) => t.formControl,
    style: {
      position: "absolute",
      left: 0,
      top: 0,
      // slight alteration to spec spacing to match visual spec result
      transform: "translate(0, 20px) scale(1)"
    }
  }, {
    props: {
      size: "small"
    },
    style: {
      // Compensation for the `Input.inputSizeSmall` style.
      transform: "translate(0, 17px) scale(1)"
    }
  }, {
    props: ({
      ownerState: t
    }) => t.shrink,
    style: {
      transform: "translate(0, -1.5px) scale(0.75)",
      transformOrigin: "top left",
      maxWidth: "133%"
    }
  }, {
    props: ({
      ownerState: t
    }) => !t.disableAnimation,
    style: {
      transition: e.transitions.create(["color", "transform", "max-width"], {
        duration: e.transitions.duration.shorter,
        easing: e.transitions.easing.easeOut
      })
    }
  }, {
    props: {
      variant: "filled"
    },
    style: {
      // Chrome's autofill feature gives the input field a yellow background.
      // Since the input field is behind the label in the HTML tree,
      // the input field is drawn last and hides the label with an opaque background color.
      // zIndex: 1 will raise the label above opaque background-colors of input.
      zIndex: 1,
      pointerEvents: "none",
      transform: "translate(12px, 16px) scale(1)",
      maxWidth: "calc(100% - 24px)"
    }
  }, {
    props: {
      variant: "filled",
      size: "small"
    },
    style: {
      transform: "translate(12px, 13px) scale(1)"
    }
  }, {
    props: ({
      variant: t,
      ownerState: n
    }) => t === "filled" && n.shrink,
    style: {
      userSelect: "none",
      pointerEvents: "auto",
      transform: "translate(12px, 7px) scale(0.75)",
      maxWidth: "calc(133% - 24px)"
    }
  }, {
    props: ({
      variant: t,
      ownerState: n,
      size: r
    }) => t === "filled" && n.shrink && r === "small",
    style: {
      transform: "translate(12px, 4px) scale(0.75)"
    }
  }, {
    props: {
      variant: "outlined"
    },
    style: {
      // see comment above on filled.zIndex
      zIndex: 1,
      pointerEvents: "none",
      transform: "translate(14px, 16px) scale(1)",
      maxWidth: "calc(100% - 24px)"
    }
  }, {
    props: {
      variant: "outlined",
      size: "small"
    },
    style: {
      transform: "translate(14px, 9px) scale(1)"
    }
  }, {
    props: ({
      variant: t,
      ownerState: n
    }) => t === "outlined" && n.shrink,
    style: {
      userSelect: "none",
      pointerEvents: "auto",
      // Theoretically, we should have (8+5)*2/0.75 = 34px
      // but it feels a better when it bleeds a bit on the left, so 32px.
      maxWidth: "calc(133% - 32px)",
      transform: "translate(14px, -9px) scale(0.75)"
    }
  }]
}))), w3e = /* @__PURE__ */ M.forwardRef(function(e, t) {
  const n = At({
    name: "MuiInputLabel",
    props: e
  }), {
    disableAnimation: r = !1,
    margin: a,
    shrink: s,
    variant: l,
    className: c,
    ...d
  } = n, p = Ll();
  let m = s;
  typeof m > "u" && p && (m = p.filled || p.focused || p.adornedStart);
  const h = bd({
    props: n,
    muiFormControl: p,
    states: ["size", "variant", "required", "focused"]
  }), v = {
    ...n,
    disableAnimation: r,
    formControl: p,
    shrink: m,
    size: h.size,
    variant: h.variant,
    required: h.required,
    focused: h.focused
  }, y = y3e(v);
  return /* @__PURE__ */ E.jsx(b3e, {
    "data-shrink": m,
    ref: t,
    className: Ke(y.root, c),
    ...d,
    ownerState: v,
    classes: y
  });
});
function x3e(e) {
  return _t("MuiFormControl", e);
}
wt("MuiFormControl", ["root", "marginNone", "marginNormal", "marginDense", "fullWidth", "disabled"]);
const S3e = (e) => {
  const {
    classes: t,
    margin: n,
    fullWidth: r
  } = e, a = {
    root: ["root", n !== "none" && `margin${qe(n)}`, r && "fullWidth"]
  };
  return kt(a, x3e, t);
}, k3e = $e("div", {
  name: "MuiFormControl",
  slot: "Root",
  overridesResolver: (e, t) => {
    const {
      ownerState: n
    } = e;
    return [t.root, t[`margin${qe(n.margin)}`], n.fullWidth && t.fullWidth];
  }
})({
  display: "inline-flex",
  flexDirection: "column",
  position: "relative",
  // Reset fieldset default style.
  minWidth: 0,
  padding: 0,
  margin: 0,
  border: 0,
  verticalAlign: "top",
  // Fix alignment issue on Safari.
  variants: [{
    props: {
      margin: "normal"
    },
    style: {
      marginTop: 16,
      marginBottom: 8
    }
  }, {
    props: {
      margin: "dense"
    },
    style: {
      marginTop: 8,
      marginBottom: 4
    }
  }, {
    props: {
      fullWidth: !0
    },
    style: {
      width: "100%"
    }
  }]
}), b4 = /* @__PURE__ */ M.forwardRef(function(e, t) {
  const n = At({
    props: e,
    name: "MuiFormControl"
  }), {
    children: r,
    className: a,
    color: s = "primary",
    component: l = "div",
    disabled: c = !1,
    error: d = !1,
    focused: p,
    fullWidth: m = !1,
    hiddenLabel: h = !1,
    margin: v = "none",
    required: y = !1,
    size: w = "medium",
    variant: x = "outlined",
    ...b
  } = n, k = {
    ...n,
    color: s,
    component: l,
    disabled: c,
    error: d,
    fullWidth: m,
    hiddenLabel: h,
    margin: v,
    required: y,
    size: w,
    variant: x
  }, C = S3e(k), [_, O] = M.useState(() => {
    let I = !1;
    return r && M.Children.forEach(r, (G) => {
      if (!Hw(G, ["Input", "Select"]))
        return;
      const L = Hw(G, ["Select"]) ? G.props.input : G;
      L && K5e(L.props) && (I = !0);
    }), I;
  }), [N, R] = M.useState(() => {
    let I = !1;
    return r && M.Children.forEach(r, (G) => {
      Hw(G, ["Input", "Select"]) && ($_(G.props, !0) || $_(G.props.inputProps, !0)) && (I = !0);
    }), I;
  }), [j, D] = M.useState(!1);
  c && j && D(!1);
  const $ = p !== void 0 && !c ? p : j;
  let z;
  M.useRef(!1);
  const B = M.useCallback(() => {
    R(!0);
  }, []), P = M.useCallback(() => {
    R(!1);
  }, []), W = M.useMemo(() => ({
    adornedStart: _,
    setAdornedStart: O,
    color: s,
    disabled: c,
    error: d,
    filled: N,
    focused: $,
    fullWidth: m,
    hiddenLabel: h,
    size: w,
    onBlur: () => {
      D(!1);
    },
    onFocus: () => {
      D(!0);
    },
    onEmpty: P,
    onFilled: B,
    registerEffect: z,
    required: y,
    variant: x
  }), [_, s, c, d, N, $, m, h, z, P, B, y, w, x]);
  return /* @__PURE__ */ E.jsx(m4.Provider, {
    value: W,
    children: /* @__PURE__ */ E.jsx(k3e, {
      as: l,
      ownerState: k,
      className: Ke(C.root, a),
      ref: t,
      ...b,
      children: r
    })
  });
});
function _3e(e) {
  return _t("MuiFormHelperText", e);
}
const qI = wt("MuiFormHelperText", ["root", "error", "disabled", "sizeSmall", "sizeMedium", "contained", "focused", "filled", "required"]);
var WI;
const E3e = (e) => {
  const {
    classes: t,
    contained: n,
    size: r,
    disabled: a,
    error: s,
    filled: l,
    focused: c,
    required: d
  } = e, p = {
    root: ["root", a && "disabled", s && "error", r && `size${qe(r)}`, n && "contained", c && "focused", l && "filled", d && "required"]
  };
  return kt(p, _3e, t);
}, C3e = $e("p", {
  name: "MuiFormHelperText",
  slot: "Root",
  overridesResolver: (e, t) => {
    const {
      ownerState: n
    } = e;
    return [t.root, n.size && t[`size${qe(n.size)}`], n.contained && t.contained, n.filled && t.filled];
  }
})(Ct(({
  theme: e
}) => ({
  color: (e.vars || e).palette.text.secondary,
  ...e.typography.caption,
  textAlign: "left",
  marginTop: 3,
  marginRight: 0,
  marginBottom: 0,
  marginLeft: 0,
  [`&.${qI.disabled}`]: {
    color: (e.vars || e).palette.text.disabled
  },
  [`&.${qI.error}`]: {
    color: (e.vars || e).palette.error.main
  },
  variants: [{
    props: {
      size: "small"
    },
    style: {
      marginTop: 4
    }
  }, {
    props: ({
      ownerState: t
    }) => t.contained,
    style: {
      marginLeft: 14,
      marginRight: 14
    }
  }]
}))), w4 = /* @__PURE__ */ M.forwardRef(function(e, t) {
  const n = At({
    props: e,
    name: "MuiFormHelperText"
  }), {
    children: r,
    className: a,
    component: s = "p",
    disabled: l,
    error: c,
    filled: d,
    focused: p,
    margin: m,
    required: h,
    variant: v,
    ...y
  } = n, w = Ll(), x = bd({
    props: n,
    muiFormControl: w,
    states: ["variant", "size", "disabled", "error", "filled", "focused", "required"]
  }), b = {
    ...n,
    component: s,
    contained: x.variant === "filled" || x.variant === "outlined",
    variant: x.variant,
    size: x.size,
    disabled: x.disabled,
    error: x.error,
    filled: x.filled,
    focused: x.focused,
    required: x.required
  };
  delete b.ownerState;
  const k = E3e(b);
  return /* @__PURE__ */ E.jsx(C3e, {
    as: s,
    className: Ke(k.root, a),
    ref: t,
    ...y,
    ownerState: b,
    children: r === " " ? (
      // notranslate needed while Google Translate will not fix zero-width space issue
      WI || (WI = /* @__PURE__ */ E.jsx("span", {
        className: "notranslate",
        "aria-hidden": !0,
        children: ""
      }))
    ) : r
  });
});
function jS(e) {
  return parseInt(M.version, 10) >= 19 ? e?.props?.ref || null : e?.ref || null;
}
function lc(e) {
  const {
    elementType: t,
    externalSlotProps: n,
    ownerState: r,
    skipResolvingSlotProps: a = !1,
    ...s
  } = e, l = a ? {} : m9(n, r), {
    props: c,
    internalRef: d
  } = h9({
    ...s,
    externalSlotProps: l
  }), p = no(d, l?.ref, e.additionalProps?.ref);
  return p9(t, {
    ...c,
    ref: p
  }, r);
}
const gc = /* @__PURE__ */ M.createContext({});
function O3e(e) {
  return _t("MuiList", e);
}
wt("MuiList", ["root", "padding", "dense", "subheader"]);
const M3e = (e) => {
  const {
    classes: t,
    disablePadding: n,
    dense: r,
    subheader: a
  } = e;
  return kt({
    root: ["root", !n && "padding", r && "dense", a && "subheader"]
  }, O3e, t);
}, N3e = $e("ul", {
  name: "MuiList",
  slot: "Root",
  overridesResolver: (e, t) => {
    const {
      ownerState: n
    } = e;
    return [t.root, !n.disablePadding && t.padding, n.dense && t.dense, n.subheader && t.subheader];
  }
})({
  listStyle: "none",
  margin: 0,
  padding: 0,
  position: "relative",
  variants: [{
    props: ({
      ownerState: e
    }) => !e.disablePadding,
    style: {
      paddingTop: 8,
      paddingBottom: 8
    }
  }, {
    props: ({
      ownerState: e
    }) => e.subheader,
    style: {
      paddingTop: 0
    }
  }]
}), x4 = /* @__PURE__ */ M.forwardRef(function(e, t) {
  const n = At({
    props: e,
    name: "MuiList"
  }), {
    children: r,
    className: a,
    component: s = "ul",
    dense: l = !1,
    disablePadding: c = !1,
    subheader: d,
    ...p
  } = n, m = M.useMemo(() => ({
    dense: l
  }), [l]), h = {
    ...n,
    component: s,
    dense: l,
    disablePadding: c
  }, v = M3e(h);
  return /* @__PURE__ */ E.jsx(gc.Provider, {
    value: m,
    children: /* @__PURE__ */ E.jsxs(N3e, {
      as: s,
      className: Ke(v.root, a),
      ref: t,
      ownerState: h,
      ...p,
      children: [d, r]
    })
  });
});
function Fw(e) {
  let t = e.activeElement;
  for (; t?.shadowRoot?.activeElement != null; )
    t = t.shadowRoot.activeElement;
  return t;
}
function Nq(e = window) {
  const t = e.document.documentElement.clientWidth;
  return e.innerWidth - t;
}
function yN(e, t, n) {
  return e === t ? e.firstChild : t && t.nextElementSibling ? t.nextElementSibling : n ? null : e.firstChild;
}
function GI(e, t, n) {
  return e === t ? n ? e.firstChild : e.lastChild : t && t.previousElementSibling ? t.previousElementSibling : n ? null : e.lastChild;
}
function Rq(e, t) {
  if (t === void 0)
    return !0;
  let n = e.innerText;
  return n === void 0 && (n = e.textContent), n = n.trim().toLowerCase(), n.length === 0 ? !1 : t.repeating ? n[0] === t.keys[0] : n.startsWith(t.keys.join(""));
}
function xw(e, t, n, r, a, s) {
  let l = !1, c = a(e, t, t ? n : !1);
  for (; c; ) {
    if (c === e.firstChild) {
      if (l)
        return !1;
      l = !0;
    }
    const d = r ? !1 : c.disabled || c.getAttribute("aria-disabled") === "true";
    if (!c.hasAttribute("tabindex") || !Rq(c, s) || d)
      c = a(e, c, n);
    else
      return c.focus(), !0;
  }
  return !1;
}
const R3e = /* @__PURE__ */ M.forwardRef(function(e, t) {
  const {
    // private
    // eslint-disable-next-line react/prop-types
    actions: n,
    autoFocus: r = !1,
    autoFocusItem: a = !1,
    children: s,
    className: l,
    disabledItemsFocusable: c = !1,
    disableListWrap: d = !1,
    onKeyDown: p,
    variant: m = "selectedMenu",
    ...h
  } = e, v = M.useRef(null), y = M.useRef({
    keys: [],
    repeating: !0,
    previousKeyMatched: !0,
    lastTime: null
  });
  zs(() => {
    r && v.current.focus();
  }, [r]), M.useImperativeHandle(n, () => ({
    adjustStyleForScrollbar: (C, {
      direction: _
    }) => {
      const O = !v.current.style.width;
      if (C.clientHeight < v.current.clientHeight && O) {
        const N = `${Nq(Cc(C))}px`;
        v.current.style[_ === "rtl" ? "paddingLeft" : "paddingRight"] = N, v.current.style.width = `calc(100% + ${N})`;
      }
      return v.current;
    }
  }), []);
  const w = (C) => {
    const _ = v.current, O = C.key;
    if (C.ctrlKey || C.metaKey || C.altKey) {
      p && p(C);
      return;
    }
    const N = Fw(wa(_));
    if (O === "ArrowDown")
      C.preventDefault(), xw(_, N, d, c, yN);
    else if (O === "ArrowUp")
      C.preventDefault(), xw(_, N, d, c, GI);
    else if (O === "Home")
      C.preventDefault(), xw(_, null, d, c, yN);
    else if (O === "End")
      C.preventDefault(), xw(_, null, d, c, GI);
    else if (O.length === 1) {
      const R = y.current, j = O.toLowerCase(), D = performance.now();
      R.keys.length > 0 && (D - R.lastTime > 500 ? (R.keys = [], R.repeating = !0, R.previousKeyMatched = !0) : R.repeating && j !== R.keys[0] && (R.repeating = !1)), R.lastTime = D, R.keys.push(j);
      const $ = N && !R.repeating && Rq(N, R);
      R.previousKeyMatched && ($ || xw(_, N, !1, c, yN, R)) ? C.preventDefault() : R.previousKeyMatched = !1;
    }
    p && p(C);
  }, x = no(v, t);
  let b = -1;
  M.Children.forEach(s, (C, _) => {
    if (!/* @__PURE__ */ M.isValidElement(C)) {
      b === _ && (b += 1, b >= s.length && (b = -1));
      return;
    }
    C.props.disabled || (m === "selectedMenu" && C.props.selected || b === -1) && (b = _), b === _ && (C.props.disabled || C.props.muiSkipListHighlight || C.type.muiSkipListHighlight) && (b += 1, b >= s.length && (b = -1));
  });
  const k = M.Children.map(s, (C, _) => {
    if (_ === b) {
      const O = {};
      return a && (O.autoFocus = !0), C.props.tabIndex === void 0 && m === "selectedMenu" && (O.tabIndex = 0), /* @__PURE__ */ M.cloneElement(C, O);
    }
    return C;
  });
  return /* @__PURE__ */ E.jsx(x4, {
    role: "menu",
    ref: x,
    className: l,
    onKeyDown: w,
    tabIndex: r ? 0 : -1,
    ...h,
    children: k
  });
}), A3e = rR(gh.element);
A3e.isRequired = rR(gh.element.isRequired);
const Aq = (e) => e.scrollTop;
function T_(e, t) {
  const {
    timeout: n,
    easing: r,
    style: a = {}
  } = e;
  return {
    duration: a.transitionDuration ?? (typeof n == "number" ? n : n[t.mode] || 0),
    easing: a.transitionTimingFunction ?? (typeof r == "object" ? r[t.mode] : r),
    delay: a.transitionDelay
  };
}
function m3(e) {
  return `scale(${e}, ${e ** 2})`;
}
const j3e = {
  entering: {
    opacity: 1,
    transform: m3(1)
  },
  entered: {
    opacity: 1,
    transform: "none"
  }
}, bN = typeof navigator < "u" && /^((?!chrome|android).)*(safari|mobile)/i.test(navigator.userAgent) && /(os |version\/)15(.|_)4/i.test(navigator.userAgent), h3 = /* @__PURE__ */ M.forwardRef(function(e, t) {
  const {
    addEndListener: n,
    appear: r = !0,
    children: a,
    easing: s,
    in: l,
    onEnter: c,
    onEntered: d,
    onEntering: p,
    onExit: m,
    onExited: h,
    onExiting: v,
    style: y,
    timeout: w = "auto",
    // eslint-disable-next-line react/prop-types
    TransitionComponent: x = Al,
    ...b
  } = e, k = f9(), C = M.useRef(), _ = u2(), O = M.useRef(null), N = no(O, jS(a), t), R = (I) => (G) => {
    if (I) {
      const L = O.current;
      G === void 0 ? I(L) : I(L, G);
    }
  }, j = R(p), D = R((I, G) => {
    Aq(I);
    const {
      duration: L,
      delay: K,
      easing: q
    } = T_({
      style: y,
      timeout: w,
      easing: s
    }, {
      mode: "enter"
    });
    let Z;
    w === "auto" ? (Z = _.transitions.getAutoHeightDuration(I.clientHeight), C.current = Z) : Z = L, I.style.transition = [_.transitions.create("opacity", {
      duration: Z,
      delay: K
    }), _.transitions.create("transform", {
      duration: bN ? Z : Z * 0.666,
      delay: K,
      easing: q
    })].join(","), c && c(I, G);
  }), $ = R(d), z = R(v), B = R((I) => {
    const {
      duration: G,
      delay: L,
      easing: K
    } = T_({
      style: y,
      timeout: w,
      easing: s
    }, {
      mode: "exit"
    });
    let q;
    w === "auto" ? (q = _.transitions.getAutoHeightDuration(I.clientHeight), C.current = q) : q = G, I.style.transition = [_.transitions.create("opacity", {
      duration: q,
      delay: L
    }), _.transitions.create("transform", {
      duration: bN ? q : q * 0.666,
      delay: bN ? L : L || q * 0.333,
      easing: K
    })].join(","), I.style.opacity = 0, I.style.transform = m3(0.75), m && m(I);
  }), P = R(h), W = (I) => {
    w === "auto" && k.start(C.current || 0, I), n && n(O.current, I);
  };
  return /* @__PURE__ */ E.jsx(x, {
    appear: r,
    in: l,
    nodeRef: O,
    onEnter: D,
    onEntered: $,
    onEntering: j,
    onExit: B,
    onExited: P,
    onExiting: z,
    addEndListener: W,
    timeout: w === "auto" ? null : w,
    ...b,
    children: (I, {
      ownerState: G,
      ...L
    }) => /* @__PURE__ */ M.cloneElement(a, {
      style: {
        opacity: 0,
        transform: m3(0.75),
        visibility: I === "exited" && !l ? "hidden" : void 0,
        ...j3e[I],
        ...y,
        ...a.props.style
      },
      ref: N,
      ...L
    })
  });
});
h3 && (h3.muiSupportAuto = !0);
function P3e(e) {
  const t = wa(e);
  return t.body === e ? Cc(e).innerWidth > t.documentElement.clientWidth : e.scrollHeight > e.clientHeight;
}
function rx(e, t) {
  t ? e.setAttribute("aria-hidden", "true") : e.removeAttribute("aria-hidden");
}
function KI(e) {
  return parseInt(Cc(e).getComputedStyle(e).paddingRight, 10) || 0;
}
function D3e(e) {
  const t = ["TEMPLATE", "SCRIPT", "STYLE", "LINK", "MAP", "META", "NOSCRIPT", "PICTURE", "COL", "COLGROUP", "PARAM", "SLOT", "SOURCE", "TRACK"].includes(e.tagName), n = e.tagName === "INPUT" && e.getAttribute("type") === "hidden";
  return t || n;
}
function XI(e, t, n, r, a) {
  const s = [t, n, ...r];
  [].forEach.call(e.children, (l) => {
    const c = !s.includes(l), d = !D3e(l);
    c && d && rx(l, a);
  });
}
function wN(e, t) {
  let n = -1;
  return e.some((r, a) => t(r) ? (n = a, !0) : !1), n;
}
function $3e(e, t) {
  const n = [], r = e.container;
  if (!t.disableScrollLock) {
    if (P3e(r)) {
      const s = Nq(Cc(r));
      n.push({
        value: r.style.paddingRight,
        property: "padding-right",
        el: r
      }), r.style.paddingRight = `${KI(r) + s}px`;
      const l = wa(r).querySelectorAll(".mui-fixed");
      [].forEach.call(l, (c) => {
        n.push({
          value: c.style.paddingRight,
          property: "padding-right",
          el: c
        }), c.style.paddingRight = `${KI(c) + s}px`;
      });
    }
    let a;
    if (r.parentNode instanceof DocumentFragment)
      a = wa(r).body;
    else {
      const s = r.parentElement, l = Cc(r);
      a = s?.nodeName === "HTML" && l.getComputedStyle(s).overflowY === "scroll" ? s : r;
    }
    n.push({
      value: a.style.overflow,
      property: "overflow",
      el: a
    }, {
      value: a.style.overflowX,
      property: "overflow-x",
      el: a
    }, {
      value: a.style.overflowY,
      property: "overflow-y",
      el: a
    }), a.style.overflow = "hidden";
  }
  return () => {
    n.forEach(({
      value: a,
      el: s,
      property: l
    }) => {
      a ? s.style.setProperty(l, a) : s.style.removeProperty(l);
    });
  };
}
function T3e(e) {
  const t = [];
  return [].forEach.call(e.children, (n) => {
    n.getAttribute("aria-hidden") === "true" && t.push(n);
  }), t;
}
class L3e {
  constructor() {
    this.modals = [], this.containers = [];
  }
  add(t, n) {
    let r = this.modals.indexOf(t);
    if (r !== -1)
      return r;
    r = this.modals.length, this.modals.push(t), t.modalRef && rx(t.modalRef, !1);
    const a = T3e(n);
    XI(n, t.mount, t.modalRef, a, !0);
    const s = wN(this.containers, (l) => l.container === n);
    return s !== -1 ? (this.containers[s].modals.push(t), r) : (this.containers.push({
      modals: [t],
      container: n,
      restore: null,
      hiddenSiblings: a
    }), r);
  }
  mount(t, n) {
    const r = wN(this.containers, (s) => s.modals.includes(t)), a = this.containers[r];
    a.restore || (a.restore = $3e(a, n));
  }
  remove(t, n = !0) {
    const r = this.modals.indexOf(t);
    if (r === -1)
      return r;
    const a = wN(this.containers, (l) => l.modals.includes(t)), s = this.containers[a];
    if (s.modals.splice(s.modals.indexOf(t), 1), this.modals.splice(r, 1), s.modals.length === 0)
      s.restore && s.restore(), t.modalRef && rx(t.modalRef, n), XI(s.container, t.mount, t.modalRef, s.hiddenSiblings, !1), this.containers.splice(a, 1);
    else {
      const l = s.modals[s.modals.length - 1];
      l.modalRef && rx(l.modalRef, !1);
    }
    return r;
  }
  isTopModal(t) {
    return this.modals.length > 0 && this.modals[this.modals.length - 1] === t;
  }
}
const I3e = ["input", "select", "textarea", "a[href]", "button", "[tabindex]", "audio[controls]", "video[controls]", '[contenteditable]:not([contenteditable="false"])'].join(",");
function z3e(e) {
  const t = parseInt(e.getAttribute("tabindex") || "", 10);
  return Number.isNaN(t) ? e.contentEditable === "true" || (e.nodeName === "AUDIO" || e.nodeName === "VIDEO" || e.nodeName === "DETAILS") && e.getAttribute("tabindex") === null ? 0 : e.tabIndex : t;
}
function F3e(e) {
  if (e.tagName !== "INPUT" || e.type !== "radio" || !e.name)
    return !1;
  const t = (r) => e.ownerDocument.querySelector(`input[type="radio"]${r}`);
  let n = t(`[name="${e.name}"]:checked`);
  return n || (n = t(`[name="${e.name}"]`)), n !== e;
}
function B3e(e) {
  return !(e.disabled || e.tagName === "INPUT" && e.type === "hidden" || F3e(e));
}
function U3e(e) {
  const t = [], n = [];
  return Array.from(e.querySelectorAll(I3e)).forEach((r, a) => {
    const s = z3e(r);
    s === -1 || !B3e(r) || (s === 0 ? t.push(r) : n.push({
      documentOrder: a,
      tabIndex: s,
      node: r
    }));
  }), n.sort((r, a) => r.tabIndex === a.tabIndex ? r.documentOrder - a.documentOrder : r.tabIndex - a.tabIndex).map((r) => r.node).concat(t);
}
function V3e() {
  return !0;
}
function H3e(e) {
  const {
    children: t,
    disableAutoFocus: n = !1,
    disableEnforceFocus: r = !1,
    disableRestoreFocus: a = !1,
    getTabbable: s = U3e,
    isEnabled: l = V3e,
    open: c
  } = e, d = M.useRef(!1), p = M.useRef(null), m = M.useRef(null), h = M.useRef(null), v = M.useRef(null), y = M.useRef(!1), w = M.useRef(null), x = no(jS(t), w), b = M.useRef(null);
  M.useEffect(() => {
    !c || !w.current || (y.current = !n);
  }, [n, c]), M.useEffect(() => {
    if (!c || !w.current)
      return;
    const _ = wa(w.current), O = Fw(_);
    return w.current.contains(O) || (w.current.hasAttribute("tabIndex") || w.current.setAttribute("tabIndex", "-1"), y.current && w.current.focus()), () => {
      a || (h.current && h.current.focus && (d.current = !0, h.current.focus()), h.current = null);
    };
  }, [c]), M.useEffect(() => {
    if (!c || !w.current)
      return;
    const _ = wa(w.current), O = Fw(_), N = (D) => {
      b.current = D, !(r || !l() || D.key !== "Tab") && O === w.current && D.shiftKey && (d.current = !0, m.current && m.current.focus());
    }, R = () => {
      const D = w.current;
      if (D === null)
        return;
      const $ = Fw(_);
      if (!_.hasFocus() || !l() || d.current) {
        d.current = !1;
        return;
      }
      if (D.contains($) || r && $ !== p.current && $ !== m.current)
        return;
      if ($ !== v.current)
        v.current = null;
      else if (v.current !== null)
        return;
      if (!y.current)
        return;
      let z = [];
      if (($ === p.current || $ === m.current) && (z = s(w.current)), z.length > 0) {
        const B = !!(b.current?.shiftKey && b.current?.key === "Tab"), P = z[0], W = z[z.length - 1];
        typeof P != "string" && typeof W != "string" && (B ? W.focus() : P.focus());
      } else
        D.focus();
    };
    _.addEventListener("focusin", R), _.addEventListener("keydown", N, !0);
    const j = setInterval(() => {
      const D = Fw(_);
      D && D.tagName === "BODY" && R();
    }, 50);
    return () => {
      clearInterval(j), _.removeEventListener("focusin", R), _.removeEventListener("keydown", N, !0);
    };
  }, [n, r, a, l, c, s]);
  const k = (_) => {
    h.current === null && (h.current = _.relatedTarget), y.current = !0, v.current = _.target;
    const O = t.props.onFocus;
    O && O(_);
  }, C = (_) => {
    h.current === null && (h.current = _.relatedTarget), y.current = !0;
  };
  return /* @__PURE__ */ E.jsxs(M.Fragment, {
    children: [/* @__PURE__ */ E.jsx("div", {
      tabIndex: c ? 0 : -1,
      onFocus: C,
      ref: p,
      "data-testid": "sentinelStart"
    }), /* @__PURE__ */ M.cloneElement(t, {
      ref: x,
      onFocus: k
    }), /* @__PURE__ */ E.jsx("div", {
      tabIndex: c ? 0 : -1,
      onFocus: C,
      ref: m,
      "data-testid": "sentinelEnd"
    })]
  });
}
function q3e(e) {
  return typeof e == "function" ? e() : e;
}
const W3e = /* @__PURE__ */ M.forwardRef(function(e, t) {
  const {
    children: n,
    container: r,
    disablePortal: a = !1
  } = e, [s, l] = M.useState(null), c = no(/* @__PURE__ */ M.isValidElement(n) ? jS(n) : null, t);
  if (zs(() => {
    a || l(q3e(r) || document.body);
  }, [r, a]), zs(() => {
    if (s && !a)
      return LI(t, s), () => {
        LI(t, null);
      };
  }, [t, s, a]), a) {
    if (/* @__PURE__ */ M.isValidElement(n)) {
      const d = {
        ref: c
      };
      return /* @__PURE__ */ M.cloneElement(n, d);
    }
    return n;
  }
  return s && /* @__PURE__ */ xm.createPortal(n, s);
}), G3e = {
  entering: {
    opacity: 1
  },
  entered: {
    opacity: 1
  }
}, K3e = /* @__PURE__ */ M.forwardRef(function(e, t) {
  const n = u2(), r = {
    enter: n.transitions.duration.enteringScreen,
    exit: n.transitions.duration.leavingScreen
  }, {
    addEndListener: a,
    appear: s = !0,
    children: l,
    easing: c,
    in: d,
    onEnter: p,
    onEntered: m,
    onEntering: h,
    onExit: v,
    onExited: y,
    onExiting: w,
    style: x,
    timeout: b = r,
    // eslint-disable-next-line react/prop-types
    TransitionComponent: k = Al,
    ...C
  } = e, _ = M.useRef(null), O = no(_, jS(l), t), N = (W) => (I) => {
    if (W) {
      const G = _.current;
      I === void 0 ? W(G) : W(G, I);
    }
  }, R = N(h), j = N((W, I) => {
    Aq(W);
    const G = T_({
      style: x,
      timeout: b,
      easing: c
    }, {
      mode: "enter"
    });
    W.style.webkitTransition = n.transitions.create("opacity", G), W.style.transition = n.transitions.create("opacity", G), p && p(W, I);
  }), D = N(m), $ = N(w), z = N((W) => {
    const I = T_({
      style: x,
      timeout: b,
      easing: c
    }, {
      mode: "exit"
    });
    W.style.webkitTransition = n.transitions.create("opacity", I), W.style.transition = n.transitions.create("opacity", I), v && v(W);
  }), B = N(y), P = (W) => {
    a && a(_.current, W);
  };
  return /* @__PURE__ */ E.jsx(k, {
    appear: s,
    in: d,
    nodeRef: _,
    onEnter: j,
    onEntered: D,
    onEntering: R,
    onExit: z,
    onExited: B,
    onExiting: $,
    addEndListener: P,
    timeout: b,
    ...C,
    children: (W, {
      ownerState: I,
      ...G
    }) => /* @__PURE__ */ M.cloneElement(l, {
      style: {
        opacity: 0,
        visibility: W === "exited" && !d ? "hidden" : void 0,
        ...G3e[W],
        ...x,
        ...l.props.style
      },
      ref: O,
      ...G
    })
  });
});
function X3e(e) {
  return _t("MuiBackdrop", e);
}
wt("MuiBackdrop", ["root", "invisible"]);
const Y3e = (e) => {
  const {
    classes: t,
    invisible: n
  } = e;
  return kt({
    root: ["root", n && "invisible"]
  }, X3e, t);
}, Q3e = $e("div", {
  name: "MuiBackdrop",
  slot: "Root",
  overridesResolver: (e, t) => {
    const {
      ownerState: n
    } = e;
    return [t.root, n.invisible && t.invisible];
  }
})({
  position: "fixed",
  display: "flex",
  alignItems: "center",
  justifyContent: "center",
  right: 0,
  bottom: 0,
  top: 0,
  left: 0,
  backgroundColor: "rgba(0, 0, 0, 0.5)",
  WebkitTapHighlightColor: "transparent",
  variants: [{
    props: {
      invisible: !0
    },
    style: {
      backgroundColor: "transparent"
    }
  }]
}), J3e = /* @__PURE__ */ M.forwardRef(function(e, t) {
  const n = At({
    props: e,
    name: "MuiBackdrop"
  }), {
    children: r,
    className: a,
    component: s = "div",
    invisible: l = !1,
    open: c,
    components: d = {},
    componentsProps: p = {},
    slotProps: m = {},
    slots: h = {},
    TransitionComponent: v,
    transitionDuration: y,
    ...w
  } = n, x = {
    ...n,
    component: s,
    invisible: l
  }, b = Y3e(x), k = {
    transition: v,
    root: d.Root,
    ...h
  }, C = {
    ...p,
    ...m
  }, _ = {
    component: s,
    slots: k,
    slotProps: C
  }, [O, N] = Hn("root", {
    elementType: Q3e,
    externalForwardedProps: _,
    className: Ke(b.root, a),
    ownerState: x
  }), [R, j] = Hn("transition", {
    elementType: K3e,
    externalForwardedProps: _,
    ownerState: x
  });
  return /* @__PURE__ */ E.jsx(R, {
    in: c,
    timeout: y,
    ...w,
    ...j,
    children: /* @__PURE__ */ E.jsx(O, {
      "aria-hidden": !0,
      ...N,
      classes: b,
      ref: t,
      children: r
    })
  });
});
function Z3e(e) {
  return typeof e == "function" ? e() : e;
}
function eRe(e) {
  return e ? e.props.hasOwnProperty("in") : !1;
}
const YI = () => {
}, a0 = new L3e();
function tRe(e) {
  const {
    container: t,
    disableEscapeKeyDown: n = !1,
    disableScrollLock: r = !1,
    closeAfterTransition: a = !1,
    onTransitionEnter: s,
    onTransitionExited: l,
    children: c,
    onClose: d,
    open: p,
    rootRef: m
  } = e, h = M.useRef({}), v = M.useRef(null), y = M.useRef(null), w = no(y, m), [x, b] = M.useState(!p), k = eRe(c);
  let C = !0;
  (e["aria-hidden"] === "false" || e["aria-hidden"] === !1) && (C = !1);
  const _ = () => wa(v.current), O = () => (h.current.modalRef = y.current, h.current.mount = v.current, h.current), N = () => {
    a0.mount(O(), {
      disableScrollLock: r
    }), y.current && (y.current.scrollTop = 0);
  }, R = Sl(() => {
    const P = Z3e(t) || _().body;
    a0.add(O(), P), y.current && N();
  }), j = () => a0.isTopModal(O()), D = Sl((P) => {
    v.current = P, P && (p && j() ? N() : y.current && rx(y.current, C));
  }), $ = M.useCallback(() => {
    a0.remove(O(), C);
  }, [C]);
  M.useEffect(() => () => {
    $();
  }, [$]), M.useEffect(() => {
    p ? R() : (!k || !a) && $();
  }, [p, $, k, a, R]);
  const z = (P) => (W) => {
    P.onKeyDown?.(W), !(W.key !== "Escape" || W.which === 229 || // Wait until IME is settled.
    !j()) && (n || (W.stopPropagation(), d && d(W, "escapeKeyDown")));
  }, B = (P) => (W) => {
    P.onClick?.(W), W.target === W.currentTarget && d && d(W, "backdropClick");
  };
  return {
    getRootProps: (P = {}) => {
      const W = qw(e);
      delete W.onTransitionEnter, delete W.onTransitionExited;
      const I = {
        ...W,
        ...P
      };
      return {
        /*
         * Marking an element with the role presentation indicates to assistive technology
         * that this element should be ignored; it exists to support the web application and
         * is not meant for humans to interact with directly.
         * https://github.com/evcohen/eslint-plugin-jsx-a11y/blob/master/docs/rules/no-static-element-interactions.md
         */
        role: "presentation",
        ...I,
        onKeyDown: z(I),
        ref: w
      };
    },
    getBackdropProps: (P = {}) => {
      const W = P;
      return {
        "aria-hidden": !0,
        ...W,
        onClick: B(W),
        open: p
      };
    },
    getTransitionProps: () => {
      const P = () => {
        b(!1), s && s();
      }, W = () => {
        b(!0), l && l(), a && $();
      };
      return {
        onEnter: d3(P, c?.props.onEnter ?? YI),
        onExited: d3(W, c?.props.onExited ?? YI)
      };
    },
    rootRef: w,
    portalRef: D,
    isTopModal: j,
    exited: x,
    hasTransition: k
  };
}
function nRe(e) {
  return _t("MuiModal", e);
}
wt("MuiModal", ["root", "hidden", "backdrop"]);
const rRe = (e) => {
  const {
    open: t,
    exited: n,
    classes: r
  } = e;
  return kt({
    root: ["root", !t && n && "hidden"],
    backdrop: ["backdrop"]
  }, nRe, r);
}, oRe = $e("div", {
  name: "MuiModal",
  slot: "Root",
  overridesResolver: (e, t) => {
    const {
      ownerState: n
    } = e;
    return [t.root, !n.open && n.exited && t.hidden];
  }
})(Ct(({
  theme: e
}) => ({
  position: "fixed",
  zIndex: (e.vars || e).zIndex.modal,
  right: 0,
  bottom: 0,
  top: 0,
  left: 0,
  variants: [{
    props: ({
      ownerState: t
    }) => !t.open && t.exited,
    style: {
      visibility: "hidden"
    }
  }]
}))), aRe = $e(J3e, {
  name: "MuiModal",
  slot: "Backdrop"
})({
  zIndex: -1
}), iRe = /* @__PURE__ */ M.forwardRef(function(e, t) {
  const n = At({
    name: "MuiModal",
    props: e
  }), {
    BackdropComponent: r = aRe,
    BackdropProps: a,
    classes: s,
    className: l,
    closeAfterTransition: c = !1,
    children: d,
    container: p,
    component: m,
    components: h = {},
    componentsProps: v = {},
    disableAutoFocus: y = !1,
    disableEnforceFocus: w = !1,
    disableEscapeKeyDown: x = !1,
    disablePortal: b = !1,
    disableRestoreFocus: k = !1,
    disableScrollLock: C = !1,
    hideBackdrop: _ = !1,
    keepMounted: O = !1,
    onClose: N,
    onTransitionEnter: R,
    onTransitionExited: j,
    open: D,
    slotProps: $ = {},
    slots: z = {},
    // eslint-disable-next-line react/prop-types
    theme: B,
    ...P
  } = n, W = {
    ...n,
    closeAfterTransition: c,
    disableAutoFocus: y,
    disableEnforceFocus: w,
    disableEscapeKeyDown: x,
    disablePortal: b,
    disableRestoreFocus: k,
    disableScrollLock: C,
    hideBackdrop: _,
    keepMounted: O
  }, {
    getRootProps: I,
    getBackdropProps: G,
    getTransitionProps: L,
    portalRef: K,
    isTopModal: q,
    exited: Z,
    hasTransition: V
  } = tRe({
    ...W,
    rootRef: t
  }), F = {
    ...W,
    exited: Z
  }, X = rRe(F), U = {};
  if (d.props.tabIndex === void 0 && (U.tabIndex = "-1"), V) {
    const {
      onEnter: me,
      onExited: ve
    } = L();
    U.onEnter = me, U.onExited = ve;
  }
  const H = {
    slots: {
      root: h.Root,
      backdrop: h.Backdrop,
      ...z
    },
    slotProps: {
      ...v,
      ...$
    }
  }, [Q, re] = Hn("root", {
    ref: t,
    elementType: oRe,
    externalForwardedProps: {
      ...H,
      ...P,
      component: m
    },
    getSlotProps: I,
    ownerState: F,
    className: Ke(l, X?.root, !F.open && F.exited && X?.hidden)
  }), [de, le] = Hn("backdrop", {
    ref: a?.ref,
    elementType: r,
    externalForwardedProps: H,
    shouldForwardComponentProp: !0,
    additionalProps: a,
    getSlotProps: (me) => G({
      ...me,
      onClick: (ve) => {
        me?.onClick && me.onClick(ve);
      }
    }),
    className: Ke(a?.className, X?.backdrop),
    ownerState: F
  });
  return !O && !D && (!V || Z) ? null : /* @__PURE__ */ E.jsx(W3e, {
    ref: K,
    container: p,
    disablePortal: b,
    children: /* @__PURE__ */ E.jsxs(Q, {
      ...re,
      children: [!_ && r ? /* @__PURE__ */ E.jsx(de, {
        ...le
      }) : null, /* @__PURE__ */ E.jsx(H3e, {
        disableEnforceFocus: w,
        disableAutoFocus: y,
        disableRestoreFocus: k,
        isEnabled: q,
        open: D,
        children: /* @__PURE__ */ M.cloneElement(d, U)
      })]
    })
  });
});
function sRe(e) {
  return _t("MuiPopover", e);
}
wt("MuiPopover", ["root", "paper"]);
function QI(e, t) {
  let n = 0;
  return typeof t == "number" ? n = t : t === "center" ? n = e.height / 2 : t === "bottom" && (n = e.height), n;
}
function JI(e, t) {
  let n = 0;
  return typeof t == "number" ? n = t : t === "center" ? n = e.width / 2 : t === "right" && (n = e.width), n;
}
function ZI(e) {
  return [e.horizontal, e.vertical].map((t) => typeof t == "number" ? `${t}px` : t).join(" ");
}
function i0(e) {
  return typeof e == "function" ? e() : e;
}
const lRe = (e) => {
  const {
    classes: t
  } = e;
  return kt({
    root: ["root"],
    paper: ["paper"]
  }, sRe, t);
}, uRe = $e(iRe, {
  name: "MuiPopover",
  slot: "Root"
})({}), jq = $e(wE, {
  name: "MuiPopover",
  slot: "Paper"
})({
  position: "absolute",
  overflowY: "auto",
  overflowX: "hidden",
  // So we see the popover when it's empty.
  // It's most likely on issue on userland.
  minWidth: 16,
  minHeight: 16,
  maxWidth: "calc(100% - 32px)",
  maxHeight: "calc(100% - 32px)",
  // We disable the focus ring for mouse, touch and keyboard users.
  outline: 0
}), cRe = /* @__PURE__ */ M.forwardRef(function(e, t) {
  const n = At({
    props: e,
    name: "MuiPopover"
  }), {
    action: r,
    anchorEl: a,
    anchorOrigin: s = {
      vertical: "top",
      horizontal: "left"
    },
    anchorPosition: l,
    anchorReference: c = "anchorEl",
    children: d,
    className: p,
    container: m,
    elevation: h = 8,
    marginThreshold: v = 16,
    open: y,
    PaperProps: w = {},
    // TODO: remove in v7
    slots: x = {},
    slotProps: b = {},
    transformOrigin: k = {
      vertical: "top",
      horizontal: "left"
    },
    TransitionComponent: C,
    // TODO: remove in v7
    transitionDuration: _ = "auto",
    TransitionProps: O = {},
    // TODO: remove in v7
    disableScrollLock: N = !1,
    ...R
  } = n, j = M.useRef(), D = {
    ...n,
    anchorOrigin: s,
    anchorReference: c,
    elevation: h,
    marginThreshold: v,
    transformOrigin: k,
    TransitionComponent: C,
    transitionDuration: _,
    TransitionProps: O
  }, $ = lRe(D), z = M.useCallback(() => {
    if (c === "anchorPosition")
      return l;
    const me = i0(a), ve = me && me.nodeType === 1 ? me : wa(j.current).body, ae = ve.getBoundingClientRect();
    return {
      top: ae.top + QI(ae, s.vertical),
      left: ae.left + JI(ae, s.horizontal)
    };
  }, [a, s.horizontal, s.vertical, l, c]), B = M.useCallback((me) => ({
    vertical: QI(me, k.vertical),
    horizontal: JI(me, k.horizontal)
  }), [k.horizontal, k.vertical]), P = M.useCallback((me) => {
    const ve = {
      width: me.offsetWidth,
      height: me.offsetHeight
    }, ae = B(ve);
    if (c === "none")
      return {
        top: null,
        left: null,
        transformOrigin: ZI(ae)
      };
    const se = z();
    let pe = se.top - ae.vertical, ge = se.left - ae.horizontal;
    const xe = pe + ve.height, _e = ge + ve.width, We = Cc(i0(a)), Xe = We.innerHeight - v, et = We.innerWidth - v;
    if (v !== null && pe < v) {
      const tt = pe - v;
      pe -= tt, ae.vertical += tt;
    } else if (v !== null && xe > Xe) {
      const tt = xe - Xe;
      pe -= tt, ae.vertical += tt;
    }
    if (v !== null && ge < v) {
      const tt = ge - v;
      ge -= tt, ae.horizontal += tt;
    } else if (_e > et) {
      const tt = _e - et;
      ge -= tt, ae.horizontal += tt;
    }
    return {
      top: `${Math.round(pe)}px`,
      left: `${Math.round(ge)}px`,
      transformOrigin: ZI(ae)
    };
  }, [a, c, z, B, v]), [W, I] = M.useState(y), G = M.useCallback(() => {
    const me = j.current;
    if (!me)
      return;
    const ve = P(me);
    ve.top !== null && me.style.setProperty("top", ve.top), ve.left !== null && (me.style.left = ve.left), me.style.transformOrigin = ve.transformOrigin, I(!0);
  }, [P]);
  M.useEffect(() => (N && window.addEventListener("scroll", G), () => window.removeEventListener("scroll", G)), [a, N, G]);
  const L = () => {
    G();
  }, K = () => {
    I(!1);
  };
  M.useEffect(() => {
    y && G();
  }), M.useImperativeHandle(r, () => y ? {
    updatePosition: () => {
      G();
    }
  } : null, [y, G]), M.useEffect(() => {
    if (!y)
      return;
    const me = _q(() => {
      G();
    }), ve = Cc(i0(a));
    return ve.addEventListener("resize", me), () => {
      me.clear(), ve.removeEventListener("resize", me);
    };
  }, [a, y, G]);
  let q = _;
  const Z = {
    slots: {
      transition: C,
      ...x
    },
    slotProps: {
      transition: O,
      paper: w,
      ...b
    }
  }, [V, F] = Hn("transition", {
    elementType: h3,
    externalForwardedProps: Z,
    ownerState: D,
    getSlotProps: (me) => ({
      ...me,
      onEntering: (ve, ae) => {
        me.onEntering?.(ve, ae), L();
      },
      onExited: (ve) => {
        me.onExited?.(ve), K();
      }
    }),
    additionalProps: {
      appear: !0,
      in: y
    }
  });
  _ === "auto" && !V.muiSupportAuto && (q = void 0);
  const X = m || (a ? wa(i0(a)).body : void 0), [U, {
    slots: H,
    slotProps: Q,
    ...re
  }] = Hn("root", {
    ref: t,
    elementType: uRe,
    externalForwardedProps: {
      ...Z,
      ...R
    },
    shouldForwardComponentProp: !0,
    additionalProps: {
      slots: {
        backdrop: x.backdrop
      },
      slotProps: {
        backdrop: Eq(typeof b.backdrop == "function" ? b.backdrop(D) : b.backdrop, {
          invisible: !0
        })
      },
      container: X,
      open: y
    },
    ownerState: D,
    className: Ke($.root, p)
  }), [de, le] = Hn("paper", {
    ref: j,
    className: $.paper,
    elementType: jq,
    externalForwardedProps: Z,
    shouldForwardComponentProp: !0,
    additionalProps: {
      elevation: h,
      style: W ? void 0 : {
        opacity: 0
      }
    },
    ownerState: D
  });
  return /* @__PURE__ */ E.jsx(U, {
    ...re,
    ...!kl(U) && {
      slots: H,
      slotProps: Q,
      disableScrollLock: N
    },
    children: /* @__PURE__ */ E.jsx(V, {
      ...F,
      timeout: q,
      children: /* @__PURE__ */ E.jsx(de, {
        ...le,
        children: d
      })
    })
  });
});
function dRe(e) {
  return _t("MuiMenu", e);
}
wt("MuiMenu", ["root", "paper", "list"]);
const fRe = {
  vertical: "top",
  horizontal: "right"
}, pRe = {
  vertical: "top",
  horizontal: "left"
}, mRe = (e) => {
  const {
    classes: t
  } = e;
  return kt({
    root: ["root"],
    paper: ["paper"],
    list: ["list"]
  }, dRe, t);
}, hRe = $e(cRe, {
  shouldForwardProp: (e) => Xo(e) || e === "classes",
  name: "MuiMenu",
  slot: "Root"
})({}), gRe = $e(jq, {
  name: "MuiMenu",
  slot: "Paper"
})({
  // specZ: The maximum height of a simple menu should be one or more rows less than the view
  // height. This ensures a tappable area outside of the simple menu with which to dismiss
  // the menu.
  maxHeight: "calc(100% - 96px)",
  // Add iOS momentum scrolling for iOS < 13.0
  WebkitOverflowScrolling: "touch"
}), vRe = $e(R3e, {
  name: "MuiMenu",
  slot: "List"
})({
  // We disable the focus ring for mouse, touch and keyboard users.
  outline: 0
}), yRe = /* @__PURE__ */ M.forwardRef(function(e, t) {
  const n = At({
    props: e,
    name: "MuiMenu"
  }), {
    autoFocus: r = !0,
    children: a,
    className: s,
    disableAutoFocusItem: l = !1,
    MenuListProps: c = {},
    onClose: d,
    open: p,
    PaperProps: m = {},
    PopoverClasses: h,
    transitionDuration: v = "auto",
    TransitionProps: {
      onEntering: y,
      ...w
    } = {},
    variant: x = "selectedMenu",
    slots: b = {},
    slotProps: k = {},
    ...C
  } = n, _ = Z1(), O = {
    ...n,
    autoFocus: r,
    disableAutoFocusItem: l,
    MenuListProps: c,
    onEntering: y,
    PaperProps: m,
    transitionDuration: v,
    TransitionProps: w,
    variant: x
  }, N = mRe(O), R = r && !l && p, j = M.useRef(null), D = (q, Z) => {
    j.current && j.current.adjustStyleForScrollbar(q, {
      direction: _ ? "rtl" : "ltr"
    }), y && y(q, Z);
  }, $ = (q) => {
    q.key === "Tab" && (q.preventDefault(), d && d(q, "tabKeyDown"));
  };
  let z = -1;
  M.Children.map(a, (q, Z) => {
    /* @__PURE__ */ M.isValidElement(q) && (q.props.disabled || (x === "selectedMenu" && q.props.selected || z === -1) && (z = Z));
  });
  const B = {
    slots: b,
    slotProps: {
      list: c,
      transition: w,
      paper: m,
      ...k
    }
  }, P = lc({
    elementType: b.root,
    externalSlotProps: k.root,
    ownerState: O,
    className: [N.root, s]
  }), [W, I] = Hn("paper", {
    className: N.paper,
    elementType: gRe,
    externalForwardedProps: B,
    shouldForwardComponentProp: !0,
    ownerState: O
  }), [G, L] = Hn("list", {
    className: Ke(N.list, c.className),
    elementType: vRe,
    shouldForwardComponentProp: !0,
    externalForwardedProps: B,
    getSlotProps: (q) => ({
      ...q,
      onKeyDown: (Z) => {
        $(Z), q.onKeyDown?.(Z);
      }
    }),
    ownerState: O
  }), K = typeof B.slotProps.transition == "function" ? B.slotProps.transition(O) : B.slotProps.transition;
  return /* @__PURE__ */ E.jsx(hRe, {
    onClose: d,
    anchorOrigin: {
      vertical: "bottom",
      horizontal: _ ? "right" : "left"
    },
    transformOrigin: _ ? fRe : pRe,
    slots: {
      root: b.root,
      paper: W,
      backdrop: b.backdrop,
      ...b.transition && {
        // TODO: pass `slots.transition` directly once `TransitionComponent` is removed from Popover
        transition: b.transition
      }
    },
    slotProps: {
      root: P,
      paper: I,
      backdrop: typeof k.backdrop == "function" ? k.backdrop(O) : k.backdrop,
      transition: {
        ...K,
        onEntering: (...q) => {
          D(...q), K?.onEntering?.(...q);
        }
      }
    },
    open: p,
    ref: t,
    transitionDuration: v,
    ownerState: O,
    ...C,
    classes: h,
    children: /* @__PURE__ */ E.jsx(G, {
      actions: j,
      autoFocus: r && (z === -1 || l),
      autoFocusItem: R,
      variant: x,
      ...L,
      children: a
    })
  });
});
function bRe(e) {
  return _t("MuiNativeSelect", e);
}
const S4 = wt("MuiNativeSelect", ["root", "select", "multiple", "filled", "outlined", "standard", "disabled", "icon", "iconOpen", "iconFilled", "iconOutlined", "iconStandard", "nativeInput", "error"]), wRe = (e) => {
  const {
    classes: t,
    variant: n,
    disabled: r,
    multiple: a,
    open: s,
    error: l
  } = e, c = {
    select: ["select", n, r && "disabled", a && "multiple", l && "error"],
    icon: ["icon", `icon${qe(n)}`, s && "iconOpen", r && "disabled"]
  };
  return kt(c, bRe, t);
}, Pq = $e("select", {
  name: "MuiNativeSelect"
})(({
  theme: e
}) => ({
  // Reset
  MozAppearance: "none",
  // Reset
  WebkitAppearance: "none",
  // When interacting quickly, the text can end up selected.
  // Native select can't be selected either.
  userSelect: "none",
  // Reset
  borderRadius: 0,
  cursor: "pointer",
  "&:focus": {
    // Reset Chrome style
    borderRadius: 0
  },
  [`&.${S4.disabled}`]: {
    cursor: "default"
  },
  "&[multiple]": {
    height: "auto"
  },
  "&:not([multiple]) option, &:not([multiple]) optgroup": {
    backgroundColor: (e.vars || e).palette.background.paper
  },
  variants: [{
    props: ({
      ownerState: t
    }) => t.variant !== "filled" && t.variant !== "outlined",
    style: {
      // Bump specificity to allow extending custom inputs
      "&&&": {
        paddingRight: 24,
        minWidth: 16
        // So it doesn't collapse.
      }
    }
  }, {
    props: {
      variant: "filled"
    },
    style: {
      "&&&": {
        paddingRight: 32
      }
    }
  }, {
    props: {
      variant: "outlined"
    },
    style: {
      borderRadius: (e.vars || e).shape.borderRadius,
      "&:focus": {
        borderRadius: (e.vars || e).shape.borderRadius
        // Reset the reset for Chrome style
      },
      "&&&": {
        paddingRight: 32
      }
    }
  }]
})), xRe = $e(Pq, {
  name: "MuiNativeSelect",
  slot: "Select",
  shouldForwardProp: Xo,
  overridesResolver: (e, t) => {
    const {
      ownerState: n
    } = e;
    return [t.select, t[n.variant], n.error && t.error, {
      [`&.${S4.multiple}`]: t.multiple
    }];
  }
})({}), Dq = $e("svg", {
  name: "MuiNativeSelect"
})(({
  theme: e
}) => ({
  // We use a position absolute over a flexbox in order to forward the pointer events
  // to the input and to support wrapping tags..
  position: "absolute",
  right: 0,
  // Center vertically, height is 1em
  top: "calc(50% - .5em)",
  // Don't block pointer events on the select under the icon.
  pointerEvents: "none",
  color: (e.vars || e).palette.action.active,
  [`&.${S4.disabled}`]: {
    color: (e.vars || e).palette.action.disabled
  },
  variants: [{
    props: ({
      ownerState: t
    }) => t.open,
    style: {
      transform: "rotate(180deg)"
    }
  }, {
    props: {
      variant: "filled"
    },
    style: {
      right: 7
    }
  }, {
    props: {
      variant: "outlined"
    },
    style: {
      right: 7
    }
  }]
})), SRe = $e(Dq, {
  name: "MuiNativeSelect",
  slot: "Icon",
  overridesResolver: (e, t) => {
    const {
      ownerState: n
    } = e;
    return [t.icon, n.variant && t[`icon${qe(n.variant)}`], n.open && t.iconOpen];
  }
})({}), kRe = /* @__PURE__ */ M.forwardRef(function(e, t) {
  const {
    className: n,
    disabled: r,
    error: a,
    IconComponent: s,
    inputRef: l,
    variant: c = "standard",
    ...d
  } = e, p = {
    ...e,
    disabled: r,
    variant: c,
    error: a
  }, m = wRe(p);
  return /* @__PURE__ */ E.jsxs(M.Fragment, {
    children: [/* @__PURE__ */ E.jsx(xRe, {
      ownerState: p,
      className: Ke(m.select, n),
      disabled: r,
      ref: l || t,
      ...d
    }), e.multiple ? null : /* @__PURE__ */ E.jsx(SRe, {
      as: s,
      ownerState: p,
      className: m.icon
    })]
  });
});
function $q(e) {
  return _t("MuiSelect", e);
}
const Sw = wt("MuiSelect", ["root", "select", "multiple", "filled", "outlined", "standard", "disabled", "focused", "icon", "iconOpen", "iconFilled", "iconOutlined", "iconStandard", "nativeInput", "error"]);
var ez;
const _Re = $e(Pq, {
  name: "MuiSelect",
  slot: "Select",
  overridesResolver: (e, t) => {
    const {
      ownerState: n
    } = e;
    return [
      // Win specificity over the input base
      {
        [`&.${Sw.select}`]: t.select
      },
      {
        [`&.${Sw.select}`]: t[n.variant]
      },
      {
        [`&.${Sw.error}`]: t.error
      },
      {
        [`&.${Sw.multiple}`]: t.multiple
      }
    ];
  }
})({
  // Win specificity over the input base
  [`&.${Sw.select}`]: {
    height: "auto",
    // Resets for multiple select with chips
    minHeight: "1.4375em",
    // Required for select\text-field height consistency
    textOverflow: "ellipsis",
    whiteSpace: "nowrap",
    overflow: "hidden"
  }
}), ERe = $e(Dq, {
  name: "MuiSelect",
  slot: "Icon",
  overridesResolver: (e, t) => {
    const {
      ownerState: n
    } = e;
    return [t.icon, n.variant && t[`icon${qe(n.variant)}`], n.open && t.iconOpen];
  }
})({}), CRe = $e("input", {
  shouldForwardProp: (e) => c2(e) && e !== "classes",
  name: "MuiSelect",
  slot: "NativeInput"
})({
  bottom: 0,
  left: 0,
  position: "absolute",
  opacity: 0,
  pointerEvents: "none",
  width: "100%",
  boxSizing: "border-box"
});
function tz(e, t) {
  return typeof t == "object" && t !== null ? e === t : String(e) === String(t);
}
function ORe(e) {
  return e == null || typeof e == "string" && !e.trim();
}
const MRe = (e) => {
  const {
    classes: t,
    variant: n,
    disabled: r,
    multiple: a,
    open: s,
    error: l
  } = e, c = {
    select: ["select", n, r && "disabled", a && "multiple", l && "error"],
    icon: ["icon", `icon${qe(n)}`, s && "iconOpen", r && "disabled"],
    nativeInput: ["nativeInput"]
  };
  return kt(c, $q, t);
}, NRe = /* @__PURE__ */ M.forwardRef(function(e, t) {
  const {
    "aria-describedby": n,
    "aria-label": r,
    autoFocus: a,
    autoWidth: s,
    children: l,
    className: c,
    defaultOpen: d,
    defaultValue: p,
    disabled: m,
    displayEmpty: h,
    error: v = !1,
    IconComponent: y,
    inputRef: w,
    labelId: x,
    MenuProps: b = {},
    multiple: k,
    name: C,
    onBlur: _,
    onChange: O,
    onClose: N,
    onFocus: R,
    // eslint-disable-next-line react/prop-types
    onKeyDown: j,
    // eslint-disable-next-line react/prop-types
    onMouseDown: D,
    onOpen: $,
    open: z,
    readOnly: B,
    renderValue: P,
    required: W,
    SelectDisplayProps: I = {},
    tabIndex: G,
    // catching `type` from Input which makes no sense for SelectInput
    type: L,
    value: K,
    variant: q = "standard",
    ...Z
  } = e, [V, F] = Bx({
    controlled: K,
    default: p,
    name: "Select"
  }), [X, U] = Bx({
    controlled: z,
    default: d,
    name: "Select"
  }), H = M.useRef(null), Q = M.useRef(null), [re, de] = M.useState(null), {
    current: le
  } = M.useRef(z != null), [me, ve] = M.useState(), ae = no(t, w), se = M.useCallback((Re) => {
    Q.current = Re, Re && de(Re);
  }, []), pe = re?.parentNode;
  M.useImperativeHandle(ae, () => ({
    focus: () => {
      Q.current.focus();
    },
    node: H.current,
    value: V
  }), [V]), M.useEffect(() => {
    d && X && re && !le && (ve(s ? null : pe.clientWidth), Q.current.focus());
  }, [re, s]), M.useEffect(() => {
    a && Q.current.focus();
  }, [a]), M.useEffect(() => {
    if (!x)
      return;
    const Re = wa(Q.current).getElementById(x);
    if (Re) {
      const Ft = () => {
        getSelection().isCollapsed && Q.current.focus();
      };
      return Re.addEventListener("click", Ft), () => {
        Re.removeEventListener("click", Ft);
      };
    }
  }, [x]);
  const ge = (Re, Ft) => {
    Re ? $ && $(Ft) : N && N(Ft), le || (ve(s ? null : pe.clientWidth), U(Re));
  }, xe = (Re) => {
    D?.(Re), Re.button === 0 && (Re.preventDefault(), Q.current.focus(), ge(!0, Re));
  }, _e = (Re) => {
    ge(!1, Re);
  }, We = M.Children.toArray(l), Xe = (Re) => {
    const Ft = We.find((Xt) => Xt.props.value === Re.target.value);
    Ft !== void 0 && (F(Ft.props.value), O && O(Re, Ft));
  }, et = (Re) => (Ft) => {
    let Xt;
    if (Ft.currentTarget.hasAttribute("tabindex")) {
      if (k) {
        Xt = Array.isArray(V) ? V.slice() : [];
        const To = V.indexOf(Re.props.value);
        To === -1 ? Xt.push(Re.props.value) : Xt.splice(To, 1);
      } else
        Xt = Re.props.value;
      if (Re.props.onClick && Re.props.onClick(Ft), V !== Xt && (F(Xt), O)) {
        const To = Ft.nativeEvent || Ft, Lo = new To.constructor(To.type, To);
        Object.defineProperty(Lo, "target", {
          writable: !0,
          value: {
            value: Xt,
            name: C
          }
        }), O(Lo, Re);
      }
      k || ge(!1, Ft);
    }
  }, tt = (Re) => {
    B || ([
      " ",
      "ArrowUp",
      "ArrowDown",
      // The native select doesn't respond to enter on macOS, but it's recommended by
      // https://www.w3.org/WAI/ARIA/apg/patterns/combobox/examples/combobox-select-only/
      "Enter"
    ].includes(Re.key) && (Re.preventDefault(), ge(!0, Re)), j?.(Re));
  }, je = re !== null && X, an = (Re) => {
    !je && _ && (Object.defineProperty(Re, "target", {
      writable: !0,
      value: {
        value: V,
        name: C
      }
    }), _(Re));
  };
  delete Z["aria-invalid"];
  let dt, Ce;
  const Me = [];
  let he = !1;
  ($_({
    value: V
  }) || h) && (P ? dt = P(V) : he = !0);
  const ye = We.map((Re) => {
    if (!/* @__PURE__ */ M.isValidElement(Re))
      return null;
    let Ft;
    if (k) {
      if (!Array.isArray(V))
        throw new Error(vc(2));
      Ft = V.some((Xt) => tz(Xt, Re.props.value)), Ft && he && Me.push(Re.props.children);
    } else
      Ft = tz(V, Re.props.value), Ft && he && (Ce = Re.props.children);
    return /* @__PURE__ */ M.cloneElement(Re, {
      "aria-selected": Ft ? "true" : "false",
      onClick: et(Re),
      onKeyUp: (Xt) => {
        Xt.key === " " && Xt.preventDefault(), Re.props.onKeyUp && Re.props.onKeyUp(Xt);
      },
      role: "option",
      selected: Ft,
      value: void 0,
      // The value is most likely not a valid HTML attribute.
      "data-value": Re.props.value
      // Instead, we provide it as a data attribute.
    });
  });
  he && (k ? Me.length === 0 ? dt = null : dt = Me.reduce((Re, Ft, Xt) => (Re.push(Ft), Xt < Me.length - 1 && Re.push(", "), Re), []) : dt = Ce);
  let Ee = me;
  !s && le && re && (Ee = pe.clientWidth);
  let Le;
  typeof G < "u" ? Le = G : Le = m ? null : 0;
  const ze = I.id || (C ? `mui-component-select-${C}` : void 0), It = {
    ...e,
    variant: q,
    value: V,
    open: je,
    error: v
  }, zt = MRe(It), Wt = {
    ...b.PaperProps,
    ...typeof b.slotProps?.paper == "function" ? b.slotProps.paper(It) : b.slotProps?.paper
  }, Ot = {
    ...b.MenuListProps,
    ...typeof b.slotProps?.list == "function" ? b.slotProps.list(It) : b.slotProps?.list
  }, bn = eg();
  return /* @__PURE__ */ E.jsxs(M.Fragment, {
    children: [/* @__PURE__ */ E.jsx(_Re, {
      as: "div",
      ref: se,
      tabIndex: Le,
      role: "combobox",
      "aria-controls": je ? bn : void 0,
      "aria-disabled": m ? "true" : void 0,
      "aria-expanded": je ? "true" : "false",
      "aria-haspopup": "listbox",
      "aria-label": r,
      "aria-labelledby": [x, ze].filter(Boolean).join(" ") || void 0,
      "aria-describedby": n,
      "aria-required": W ? "true" : void 0,
      "aria-invalid": v ? "true" : void 0,
      onKeyDown: tt,
      onMouseDown: m || B ? null : xe,
      onBlur: an,
      onFocus: R,
      ...I,
      ownerState: It,
      className: Ke(I.className, zt.select, c),
      id: ze,
      children: ORe(dt) ? (
        // notranslate needed while Google Translate will not fix zero-width space issue
        ez || (ez = /* @__PURE__ */ E.jsx("span", {
          className: "notranslate",
          "aria-hidden": !0,
          children: ""
        }))
      ) : dt
    }), /* @__PURE__ */ E.jsx(CRe, {
      "aria-invalid": v,
      value: Array.isArray(V) ? V.join(",") : V,
      name: C,
      ref: H,
      "aria-hidden": !0,
      onChange: Xe,
      tabIndex: -1,
      disabled: m,
      className: zt.nativeInput,
      autoFocus: a,
      required: W,
      ...Z,
      ownerState: It
    }), /* @__PURE__ */ E.jsx(ERe, {
      as: y,
      className: zt.icon,
      ownerState: It
    }), /* @__PURE__ */ E.jsx(yRe, {
      id: `menu-${C || ""}`,
      anchorEl: pe,
      open: je,
      onClose: _e,
      anchorOrigin: {
        vertical: "bottom",
        horizontal: "center"
      },
      transformOrigin: {
        vertical: "top",
        horizontal: "center"
      },
      ...b,
      slotProps: {
        ...b.slotProps,
        list: {
          "aria-labelledby": x,
          role: "listbox",
          "aria-multiselectable": k ? "true" : void 0,
          disableListWrap: !0,
          id: bn,
          ...Ot
        },
        paper: {
          ...Wt,
          style: {
            minWidth: Ee,
            ...Wt != null ? Wt.style : null
          }
        }
      },
      children: ye
    })]
  });
}), RRe = xi(/* @__PURE__ */ E.jsx("path", {
  d: "M7 10l5 5 5-5z"
})), ARe = (e) => {
  const {
    classes: t
  } = e, n = kt({
    root: ["root"]
  }, $q, t);
  return {
    ...t,
    ...n
  };
}, k4 = {
  name: "MuiSelect",
  slot: "Root",
  shouldForwardProp: (e) => Xo(e) && e !== "variant"
}, jRe = $e(g4, k4)(""), PRe = $e(y4, k4)(""), DRe = $e(v4, k4)(""), Tq = /* @__PURE__ */ M.forwardRef(function(e, t) {
  const n = At({
    name: "MuiSelect",
    props: e
  }), {
    autoWidth: r = !1,
    children: a,
    classes: s = {},
    className: l,
    defaultOpen: c = !1,
    displayEmpty: d = !1,
    IconComponent: p = RRe,
    id: m,
    input: h,
    inputProps: v,
    label: y,
    labelId: w,
    MenuProps: x,
    multiple: b = !1,
    native: k = !1,
    onClose: C,
    onOpen: _,
    open: O,
    renderValue: N,
    SelectDisplayProps: R,
    variant: j = "outlined",
    ...D
  } = n, $ = k ? kRe : NRe, z = Ll(), B = bd({
    props: n,
    muiFormControl: z,
    states: ["variant", "error"]
  }), P = B.variant || j, W = {
    ...n,
    variant: P,
    classes: s
  }, I = ARe(W), {
    root: G,
    ...L
  } = I, K = h || {
    standard: /* @__PURE__ */ E.jsx(jRe, {
      ownerState: W
    }),
    outlined: /* @__PURE__ */ E.jsx(PRe, {
      label: y,
      ownerState: W
    }),
    filled: /* @__PURE__ */ E.jsx(DRe, {
      ownerState: W
    })
  }[P], q = no(t, jS(K));
  return /* @__PURE__ */ E.jsx(M.Fragment, {
    children: /* @__PURE__ */ M.cloneElement(K, {
      // Most of the logic is implemented in `SelectInput`.
      // The `Select` component is a simple API wrapper to expose something better to play with.
      inputComponent: $,
      inputProps: {
        children: a,
        error: B.error,
        IconComponent: p,
        variant: P,
        type: void 0,
        // We render a select. We can ignore the type provided by the `Input`.
        multiple: b,
        ...k ? {
          id: m
        } : {
          autoWidth: r,
          defaultOpen: c,
          displayEmpty: d,
          labelId: w,
          MenuProps: x,
          onClose: C,
          onOpen: _,
          open: O,
          renderValue: N,
          SelectDisplayProps: {
            id: m,
            ...R
          }
        },
        ...v,
        classes: v ? Go(L, v.classes) : L,
        ...h ? h.props.inputProps : {}
      },
      ...(b && k || d) && P === "outlined" ? {
        notched: !0
      } : {},
      ref: q,
      className: Ke(K.props.className, l, I.root),
      // If a custom input is provided via 'input' prop, do not allow 'variant' to be propagated to it's root element. See https://github.com/mui/material-ui/issues/33894.
      ...!h && {
        variant: P
      },
      ...D
    })
  });
});
Tq.muiName = "Select";
function $Re(e) {
  return _t("MuiTextField", e);
}
wt("MuiTextField", ["root"]);
const TRe = {
  standard: g4,
  filled: v4,
  outlined: y4
}, LRe = (e) => {
  const {
    classes: t
  } = e;
  return kt({
    root: ["root"]
  }, $Re, t);
}, IRe = $e(b4, {
  name: "MuiTextField",
  slot: "Root"
})({}), _4 = /* @__PURE__ */ M.forwardRef(function(e, t) {
  const n = At({
    props: e,
    name: "MuiTextField"
  }), {
    autoComplete: r,
    autoFocus: a = !1,
    children: s,
    className: l,
    color: c = "primary",
    defaultValue: d,
    disabled: p = !1,
    error: m = !1,
    FormHelperTextProps: h,
    fullWidth: v = !1,
    helperText: y,
    id: w,
    InputLabelProps: x,
    inputProps: b,
    InputProps: k,
    inputRef: C,
    label: _,
    maxRows: O,
    minRows: N,
    multiline: R = !1,
    name: j,
    onBlur: D,
    onChange: $,
    onFocus: z,
    placeholder: B,
    required: P = !1,
    rows: W,
    select: I = !1,
    SelectProps: G,
    slots: L = {},
    slotProps: K = {},
    type: q,
    value: Z,
    variant: V = "outlined",
    ...F
  } = n, X = {
    ...n,
    autoFocus: a,
    color: c,
    disabled: p,
    error: m,
    fullWidth: v,
    multiline: R,
    required: P,
    select: I,
    variant: V
  }, U = LRe(X), H = eg(w), Q = y && H ? `${H}-helper-text` : void 0, re = _ && H ? `${H}-label` : void 0, de = TRe[V], le = {
    slots: L,
    slotProps: {
      input: k,
      inputLabel: x,
      htmlInput: b,
      formHelperText: h,
      select: G,
      ...K
    }
  }, me = {}, ve = le.slotProps.inputLabel;
  V === "outlined" && (ve && typeof ve.shrink < "u" && (me.notched = ve.shrink), me.label = _), I && ((!G || !G.native) && (me.id = void 0), me["aria-describedby"] = void 0);
  const [ae, se] = Hn("root", {
    elementType: IRe,
    shouldForwardComponentProp: !0,
    externalForwardedProps: {
      ...le,
      ...F
    },
    ownerState: X,
    className: Ke(U.root, l),
    ref: t,
    additionalProps: {
      disabled: p,
      error: m,
      fullWidth: v,
      required: P,
      color: c,
      variant: V
    }
  }), [pe, ge] = Hn("input", {
    elementType: de,
    externalForwardedProps: le,
    additionalProps: me,
    ownerState: X
  }), [xe, _e] = Hn("inputLabel", {
    elementType: w3e,
    externalForwardedProps: le,
    ownerState: X
  }), [We, Xe] = Hn("htmlInput", {
    elementType: "input",
    externalForwardedProps: le,
    ownerState: X
  }), [et, tt] = Hn("formHelperText", {
    elementType: w4,
    externalForwardedProps: le,
    ownerState: X
  }), [je, an] = Hn("select", {
    elementType: Tq,
    externalForwardedProps: le,
    ownerState: X
  }), dt = /* @__PURE__ */ E.jsx(pe, {
    "aria-describedby": Q,
    autoComplete: r,
    autoFocus: a,
    defaultValue: d,
    fullWidth: v,
    multiline: R,
    name: j,
    rows: W,
    maxRows: O,
    minRows: N,
    type: q,
    value: Z,
    id: H,
    inputRef: C,
    onBlur: D,
    onChange: $,
    onFocus: z,
    placeholder: B,
    inputProps: Xe,
    slots: {
      input: L.htmlInput ? We : void 0
    },
    ...ge
  });
  return /* @__PURE__ */ E.jsxs(ae, {
    ...se,
    children: [_ != null && _ !== "" && /* @__PURE__ */ E.jsx(xe, {
      htmlFor: H,
      id: re,
      ..._e,
      children: _
    }), I ? /* @__PURE__ */ E.jsx(je, {
      "aria-describedby": Q,
      id: H,
      labelId: re,
      value: Z,
      input: dt,
      ...an,
      children: s
    }) : dt, y && /* @__PURE__ */ E.jsx(et, {
      id: Q,
      ...tt,
      children: y
    })]
  });
}), zRe = ["date", "datetime-local", "file", "time"];
function FRe(e) {
  const {
    id: t,
    name: n,
    // remove this from textFieldProps
    htmlName: r,
    placeholder: a,
    required: s,
    readonly: l,
    disabled: c,
    type: d,
    label: p,
    hideLabel: m,
    hideError: h,
    value: v,
    onChange: y,
    onChangeOverride: w,
    onBlur: x,
    onFocus: b,
    autofocus: k,
    options: C,
    schema: _,
    uiSchema: O,
    rawErrors: N = [],
    errorSchema: R,
    registry: j,
    InputLabelProps: D,
    ...$
  } = e, z = qH(_, d, C), { step: B, min: P, max: W, accept: I, ...G } = z, L = { step: B, min: P, max: W, accept: I, ..._.examples ? { list: Fx(t) } : void 0 }, K = ({ target: { value: F } }) => y(F === "" ? C.emptyValue : F), q = ({ target: F }) => x(t, F && F.value), Z = ({ target: F }) => b(t, F && F.value), V = zRe.includes(d) ? {
    ...D,
    shrink: !0
  } : D;
  return E.jsxs(E.Fragment, { children: [E.jsx(_4, { id: t, name: r || t, placeholder: a, label: Am(p || void 0, m, void 0), autoFocus: k, required: s, disabled: c || l, slotProps: { htmlInput: L, inputLabel: V }, ...G, value: v || v === 0 ? v : "", error: N.length > 0, onChange: w || K, onBlur: q, onFocus: Z, ...$, "aria-describedby": _i(t, !!_.examples) }), Array.isArray(_.examples) && E.jsx("datalist", { id: Fx(t), children: _.examples.concat(_.default && !_.examples.includes(_.default) ? [_.default] : []).map((F) => E.jsx("option", { value: F }, F)) })] });
}
function BRe(e) {
  return _t("MuiTypography", e);
}
const nz = wt("MuiTypography", ["root", "h1", "h2", "h3", "h4", "h5", "h6", "subtitle1", "subtitle2", "body1", "body2", "inherit", "button", "caption", "overline", "alignLeft", "alignRight", "alignCenter", "alignJustify", "noWrap", "gutterBottom", "paragraph"]), URe = {
  primary: !0,
  secondary: !0,
  error: !0,
  info: !0,
  success: !0,
  warning: !0,
  textPrimary: !0,
  textSecondary: !0,
  textDisabled: !0
}, VRe = CJ(), HRe = (e) => {
  const {
    align: t,
    gutterBottom: n,
    noWrap: r,
    paragraph: a,
    variant: s,
    classes: l
  } = e, c = {
    root: ["root", s, e.align !== "inherit" && `align${qe(t)}`, n && "gutterBottom", r && "noWrap", a && "paragraph"]
  };
  return kt(c, BRe, l);
}, qRe = $e("span", {
  name: "MuiTypography",
  slot: "Root",
  overridesResolver: (e, t) => {
    const {
      ownerState: n
    } = e;
    return [t.root, n.variant && t[n.variant], n.align !== "inherit" && t[`align${qe(n.align)}`], n.noWrap && t.noWrap, n.gutterBottom && t.gutterBottom, n.paragraph && t.paragraph];
  }
})(Ct(({
  theme: e
}) => ({
  margin: 0,
  variants: [{
    props: {
      variant: "inherit"
    },
    style: {
      // Some elements, like <button> on Chrome have default font that doesn't inherit, reset this.
      font: "inherit",
      lineHeight: "inherit",
      letterSpacing: "inherit"
    }
  }, ...Object.entries(e.typography).filter(([t, n]) => t !== "inherit" && n && typeof n == "object").map(([t, n]) => ({
    props: {
      variant: t
    },
    style: n
  })), ...Object.entries(e.palette).filter(Ko()).map(([t]) => ({
    props: {
      color: t
    },
    style: {
      color: (e.vars || e).palette[t].main
    }
  })), ...Object.entries(e.palette?.text || {}).filter(([, t]) => typeof t == "string").map(([t]) => ({
    props: {
      color: `text${qe(t)}`
    },
    style: {
      color: (e.vars || e).palette.text[t]
    }
  })), {
    props: ({
      ownerState: t
    }) => t.align !== "inherit",
    style: {
      textAlign: "var(--Typography-textAlign)"
    }
  }, {
    props: ({
      ownerState: t
    }) => t.noWrap,
    style: {
      overflow: "hidden",
      textOverflow: "ellipsis",
      whiteSpace: "nowrap"
    }
  }, {
    props: ({
      ownerState: t
    }) => t.gutterBottom,
    style: {
      marginBottom: "0.35em"
    }
  }, {
    props: ({
      ownerState: t
    }) => t.paragraph,
    style: {
      marginBottom: 16
    }
  }]
}))), rz = {
  h1: "h1",
  h2: "h2",
  h3: "h3",
  h4: "h4",
  h5: "h5",
  h6: "h6",
  subtitle1: "h6",
  subtitle2: "h6",
  body1: "p",
  body2: "p",
  inherit: "p"
}, bl = /* @__PURE__ */ M.forwardRef(function(e, t) {
  const {
    color: n,
    ...r
  } = At({
    props: e,
    name: "MuiTypography"
  }), a = !URe[n], s = VRe({
    ...r,
    ...a && {
      color: n
    }
  }), {
    align: l = "inherit",
    className: c,
    component: d,
    gutterBottom: p = !1,
    noWrap: m = !1,
    paragraph: h = !1,
    variant: v = "body1",
    variantMapping: y = rz,
    ...w
  } = s, x = {
    ...s,
    align: l,
    color: n,
    className: c,
    component: d,
    gutterBottom: p,
    noWrap: m,
    paragraph: h,
    variant: v,
    variantMapping: y
  }, b = d || (h ? "p" : y[v] || rz[v]) || "span", k = HRe(x);
  return /* @__PURE__ */ E.jsx(qRe, {
    as: b,
    ref: t,
    className: Ke(k.root, c),
    ...w,
    ownerState: x,
    style: {
      ...l !== "inherit" && {
        "--Typography-textAlign": l
      },
      ...w.style
    }
  });
});
function WRe(e) {
  const { id: t, description: n, registry: r, uiSchema: a } = e;
  return n ? E.jsx(bl, { id: t, variant: "subtitle2", style: { marginTop: "5px" }, children: E.jsx(f4, { description: n, registry: r, uiSchema: a }) }) : null;
}
const GRe = xi(/* @__PURE__ */ E.jsx("path", {
  d: "M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2m1 15h-2v-2h2zm0-4h-2V7h2z"
}));
function KRe(e) {
  return _t("MuiListItem", e);
}
wt("MuiListItem", ["root", "container", "dense", "alignItemsFlexStart", "divider", "gutters", "padding", "secondaryAction"]);
const XRe = wt("MuiListItemButton", ["root", "focusVisible", "dense", "alignItemsFlexStart", "disabled", "divider", "gutters", "selected"]);
function YRe(e) {
  return _t("MuiListItemSecondaryAction", e);
}
wt("MuiListItemSecondaryAction", ["root", "disableGutters"]);
const QRe = (e) => {
  const {
    disableGutters: t,
    classes: n
  } = e;
  return kt({
    root: ["root", t && "disableGutters"]
  }, YRe, n);
}, JRe = $e("div", {
  name: "MuiListItemSecondaryAction",
  slot: "Root",
  overridesResolver: (e, t) => {
    const {
      ownerState: n
    } = e;
    return [t.root, n.disableGutters && t.disableGutters];
  }
})({
  position: "absolute",
  right: 16,
  top: "50%",
  transform: "translateY(-50%)",
  variants: [{
    props: ({
      ownerState: e
    }) => e.disableGutters,
    style: {
      right: 0
    }
  }]
}), Lq = /* @__PURE__ */ M.forwardRef(function(e, t) {
  const n = At({
    props: e,
    name: "MuiListItemSecondaryAction"
  }), {
    className: r,
    ...a
  } = n, s = M.useContext(gc), l = {
    ...n,
    disableGutters: s.disableGutters
  }, c = QRe(l);
  return /* @__PURE__ */ E.jsx(JRe, {
    className: Ke(c.root, r),
    ownerState: l,
    ref: t,
    ...a
  });
});
Lq.muiName = "ListItemSecondaryAction";
const ZRe = (e, t) => {
  const {
    ownerState: n
  } = e;
  return [t.root, n.dense && t.dense, n.alignItems === "flex-start" && t.alignItemsFlexStart, n.divider && t.divider, !n.disableGutters && t.gutters, !n.disablePadding && t.padding, n.hasSecondaryAction && t.secondaryAction];
}, eAe = (e) => {
  const {
    alignItems: t,
    classes: n,
    dense: r,
    disableGutters: a,
    disablePadding: s,
    divider: l,
    hasSecondaryAction: c
  } = e;
  return kt({
    root: ["root", r && "dense", !a && "gutters", !s && "padding", l && "divider", t === "flex-start" && "alignItemsFlexStart", c && "secondaryAction"],
    container: ["container"],
    secondaryAction: ["secondaryAction"]
  }, KRe, n);
}, tAe = $e("div", {
  name: "MuiListItem",
  slot: "Root",
  overridesResolver: ZRe
})(Ct(({
  theme: e
}) => ({
  display: "flex",
  justifyContent: "flex-start",
  alignItems: "center",
  position: "relative",
  textDecoration: "none",
  width: "100%",
  boxSizing: "border-box",
  textAlign: "left",
  variants: [{
    props: ({
      ownerState: t
    }) => !t.disablePadding,
    style: {
      paddingTop: 8,
      paddingBottom: 8
    }
  }, {
    props: ({
      ownerState: t
    }) => !t.disablePadding && t.dense,
    style: {
      paddingTop: 4,
      paddingBottom: 4
    }
  }, {
    props: ({
      ownerState: t
    }) => !t.disablePadding && !t.disableGutters,
    style: {
      paddingLeft: 16,
      paddingRight: 16
    }
  }, {
    props: ({
      ownerState: t
    }) => !t.disablePadding && !!t.secondaryAction,
    style: {
      // Add some space to avoid collision as `ListItemSecondaryAction`
      // is absolutely positioned.
      paddingRight: 48
    }
  }, {
    props: ({
      ownerState: t
    }) => !!t.secondaryAction,
    style: {
      [`& > .${XRe.root}`]: {
        paddingRight: 48
      }
    }
  }, {
    props: {
      alignItems: "flex-start"
    },
    style: {
      alignItems: "flex-start"
    }
  }, {
    props: ({
      ownerState: t
    }) => t.divider,
    style: {
      borderBottom: `1px solid ${(e.vars || e).palette.divider}`,
      backgroundClip: "padding-box"
    }
  }, {
    props: ({
      ownerState: t
    }) => t.button,
    style: {
      transition: e.transitions.create("background-color", {
        duration: e.transitions.duration.shortest
      }),
      "&:hover": {
        textDecoration: "none",
        backgroundColor: (e.vars || e).palette.action.hover,
        // Reset on touch devices, it doesn't add specificity
        "@media (hover: none)": {
          backgroundColor: "transparent"
        }
      }
    }
  }, {
    props: ({
      ownerState: t
    }) => t.hasSecondaryAction,
    style: {
      // Add some space to avoid collision as `ListItemSecondaryAction`
      // is absolutely positioned.
      paddingRight: 48
    }
  }]
}))), nAe = $e("li", {
  name: "MuiListItem",
  slot: "Container"
})({
  position: "relative"
}), Iq = /* @__PURE__ */ M.forwardRef(function(e, t) {
  const n = At({
    props: e,
    name: "MuiListItem"
  }), {
    alignItems: r = "center",
    children: a,
    className: s,
    component: l,
    components: c = {},
    componentsProps: d = {},
    ContainerComponent: p = "li",
    ContainerProps: {
      className: m,
      ...h
    } = {},
    dense: v = !1,
    disableGutters: y = !1,
    disablePadding: w = !1,
    divider: x = !1,
    secondaryAction: b,
    slotProps: k = {},
    slots: C = {},
    ..._
  } = n, O = M.useContext(gc), N = M.useMemo(() => ({
    dense: v || O.dense || !1,
    alignItems: r,
    disableGutters: y
  }), [r, O.dense, v, y]), R = M.useRef(null), j = M.Children.toArray(a), D = j.length && Hw(j[j.length - 1], ["ListItemSecondaryAction"]), $ = {
    ...n,
    alignItems: r,
    dense: N.dense,
    disableGutters: y,
    disablePadding: w,
    divider: x,
    hasSecondaryAction: D
  }, z = eAe($), B = no(R, t), P = {
    slots: C,
    slotProps: k
  }, [W, I] = Hn("secondaryAction", {
    elementType: Lq,
    externalForwardedProps: P,
    ownerState: $,
    className: z.secondaryAction
  }), G = C.root || c.Root || tAe, L = k.root || d.root || {}, K = {
    className: Ke(z.root, L.className, s),
    ..._
  };
  let q = l || "li";
  return D ? (q = !K.component && !l ? "div" : q, p === "li" && (q === "li" ? q = "div" : K.component === "li" && (K.component = "div")), /* @__PURE__ */ E.jsx(gc.Provider, {
    value: N,
    children: /* @__PURE__ */ E.jsxs(nAe, {
      as: p,
      className: Ke(z.container, m),
      ref: B,
      ownerState: $,
      ...h,
      children: [/* @__PURE__ */ E.jsx(G, {
        ...L,
        ...!kl(G) && {
          as: q,
          ownerState: {
            ...$,
            ...L.ownerState
          }
        },
        ...K,
        children: j
      }), j.pop()]
    })
  })) : /* @__PURE__ */ E.jsx(gc.Provider, {
    value: N,
    children: /* @__PURE__ */ E.jsxs(G, {
      ...L,
      as: q,
      ref: B,
      ...!kl(G) && {
        ownerState: {
          ...$,
          ...L.ownerState
        }
      },
      ...K,
      children: [j, b && /* @__PURE__ */ E.jsx(W, {
        ...I,
        children: b
      })]
    })
  });
});
function rAe(e) {
  return _t("MuiListItemIcon", e);
}
const oz = wt("MuiListItemIcon", ["root", "alignItemsFlexStart"]), oAe = (e) => {
  const {
    alignItems: t,
    classes: n
  } = e;
  return kt({
    root: ["root", t === "flex-start" && "alignItemsFlexStart"]
  }, rAe, n);
}, aAe = $e("div", {
  name: "MuiListItemIcon",
  slot: "Root",
  overridesResolver: (e, t) => {
    const {
      ownerState: n
    } = e;
    return [t.root, n.alignItems === "flex-start" && t.alignItemsFlexStart];
  }
})(Ct(({
  theme: e
}) => ({
  minWidth: 56,
  color: (e.vars || e).palette.action.active,
  flexShrink: 0,
  display: "inline-flex",
  variants: [{
    props: {
      alignItems: "flex-start"
    },
    style: {
      marginTop: 8
    }
  }]
}))), iAe = /* @__PURE__ */ M.forwardRef(function(e, t) {
  const n = At({
    props: e,
    name: "MuiListItemIcon"
  }), {
    className: r,
    ...a
  } = n, s = M.useContext(gc), l = {
    ...n,
    alignItems: s.alignItems
  }, c = oAe(l);
  return /* @__PURE__ */ E.jsx(aAe, {
    className: Ke(c.root, r),
    ownerState: l,
    ref: t,
    ...a
  });
});
function sAe(e) {
  return _t("MuiListItemText", e);
}
const hh = wt("MuiListItemText", ["root", "multiline", "dense", "inset", "primary", "secondary"]), lAe = (e) => {
  const {
    classes: t,
    inset: n,
    primary: r,
    secondary: a,
    dense: s
  } = e;
  return kt({
    root: ["root", n && "inset", s && "dense", r && a && "multiline"],
    primary: ["primary"],
    secondary: ["secondary"]
  }, sAe, t);
}, uAe = $e("div", {
  name: "MuiListItemText",
  slot: "Root",
  overridesResolver: (e, t) => {
    const {
      ownerState: n
    } = e;
    return [{
      [`& .${hh.primary}`]: t.primary
    }, {
      [`& .${hh.secondary}`]: t.secondary
    }, t.root, n.inset && t.inset, n.primary && n.secondary && t.multiline, n.dense && t.dense];
  }
})({
  flex: "1 1 auto",
  minWidth: 0,
  marginTop: 4,
  marginBottom: 4,
  [`.${nz.root}:where(& .${hh.primary})`]: {
    display: "block"
  },
  [`.${nz.root}:where(& .${hh.secondary})`]: {
    display: "block"
  },
  variants: [{
    props: ({
      ownerState: e
    }) => e.primary && e.secondary,
    style: {
      marginTop: 6,
      marginBottom: 6
    }
  }, {
    props: ({
      ownerState: e
    }) => e.inset,
    style: {
      paddingLeft: 56
    }
  }]
}), cAe = /* @__PURE__ */ M.forwardRef(function(e, t) {
  const n = At({
    props: e,
    name: "MuiListItemText"
  }), {
    children: r,
    className: a,
    disableTypography: s = !1,
    inset: l = !1,
    primary: c,
    primaryTypographyProps: d,
    secondary: p,
    secondaryTypographyProps: m,
    slots: h = {},
    slotProps: v = {},
    ...y
  } = n, {
    dense: w
  } = M.useContext(gc);
  let x = c ?? r, b = p;
  const k = {
    ...n,
    disableTypography: s,
    inset: l,
    primary: !!x,
    secondary: !!b,
    dense: w
  }, C = lAe(k), _ = {
    slots: h,
    slotProps: {
      primary: d,
      secondary: m,
      ...v
    }
  }, [O, N] = Hn("root", {
    className: Ke(C.root, a),
    elementType: uAe,
    externalForwardedProps: {
      ..._,
      ...y
    },
    ownerState: k,
    ref: t
  }), [R, j] = Hn("primary", {
    className: C.primary,
    elementType: bl,
    externalForwardedProps: _,
    ownerState: k
  }), [D, $] = Hn("secondary", {
    className: C.secondary,
    elementType: bl,
    externalForwardedProps: _,
    ownerState: k
  });
  return x != null && x.type !== bl && !s && (x = /* @__PURE__ */ E.jsx(R, {
    variant: w ? "body2" : "body1",
    component: j?.variant ? void 0 : "span",
    ...j,
    children: x
  })), b != null && b.type !== bl && !s && (b = /* @__PURE__ */ E.jsx(D, {
    variant: "body2",
    color: "textSecondary",
    ...$,
    children: b
  })), /* @__PURE__ */ E.jsxs(O, {
    ...N,
    children: [x, b]
  });
});
function dAe({ errors: e, registry: t }) {
  const { translateString: n } = t;
  return E.jsx(wE, { elevation: 2, children: E.jsxs(hd, { mb: 2, p: 2, children: [E.jsx(bl, { variant: "h6", children: n(Gt.ErrorsLabel) }), E.jsx(x4, { dense: !0, children: e.map((r, a) => E.jsxs(Iq, { children: [E.jsx(iAe, { children: E.jsx(GRe, { color: "error" }) }), E.jsx(cAe, { primary: r.stack })] }, a)) })] }) });
}
const fAe = xi(/* @__PURE__ */ E.jsx("path", {
  d: "m20 12-1.41-1.41L13 16.17V4h-2v12.17l-5.58-5.59L4 12l8 8z"
})), pAe = xi(/* @__PURE__ */ E.jsx("path", {
  d: "m4 12 1.41 1.41L11 7.83V20h2V7.83l5.58 5.59L20 12l-8-8z"
})), mAe = xi(/* @__PURE__ */ E.jsx("path", {
  d: "M16 1H4c-1.1 0-2 .9-2 2v14h2V3h12zm3 4H8c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h11c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2m0 16H8V7h11z"
})), hAe = xi(/* @__PURE__ */ E.jsx("path", {
  d: "M19 13H5v-2h14z"
}));
function PS(e) {
  const { icon: t, color: n, uiSchema: r, registry: a, ...s } = e;
  return E.jsx(Mq, { ...s, size: "small", color: n, children: t });
}
function gAe(e) {
  const { registry: { translateString: t } } = e;
  return E.jsx(PS, { title: t(Gt.CopyButton), ...e, icon: E.jsx(mAe, { fontSize: "small" }) });
}
function vAe(e) {
  const { registry: { translateString: t } } = e;
  return E.jsx(PS, { title: t(Gt.MoveDownButton), ...e, icon: E.jsx(fAe, { fontSize: "small" }) });
}
function yAe(e) {
  const { registry: { translateString: t } } = e;
  return E.jsx(PS, { title: t(Gt.MoveUpButton), ...e, icon: E.jsx(pAe, { fontSize: "small" }) });
}
function zq(e) {
  const { iconType: t, ...n } = e, { registry: { translateString: r } } = n;
  return E.jsx(PS, { title: r(Gt.RemoveButton), ...n, color: "error", icon: E.jsx(hAe, { fontSize: t === "default" ? void 0 : "small" }) });
}
function bAe(e) {
  const { errors: t = [], fieldPathId: n } = e;
  if (t.length === 0)
    return null;
  const r = e4(n);
  return E.jsx(x4, { id: r, dense: !0, disablePadding: !0, children: t.map((a, s) => E.jsx(Iq, { disableGutters: !0, children: E.jsx(w4, { component: "div", id: `${r}-${s}`, children: a }) }, s)) });
}
function wAe(e) {
  const { fieldPathId: t, help: n, uiSchema: r, registry: a } = e;
  return n ? E.jsx(w4, { component: "div", id: t4(t), style: { marginTop: "5px" }, children: E.jsx(p4, { help: n, registry: a, uiSchema: r }) }) : null;
}
function xAe(e) {
  const { id: t, children: n, classNames: r, style: a, disabled: s, displayLabel: l, hidden: c, label: d, onKeyRename: p, onKeyRenameBlur: m, onRemoveProperty: h, readonly: v, required: y, rawErrors: w = [], errors: x, help: b, description: k, rawDescription: C, schema: _, uiSchema: O, registry: N } = e, R = ht(O), j = bt("WrapIfAdditionalTemplate", N, R);
  if (c)
    return E.jsx("div", { style: { display: "none" }, children: n });
  const D = R.widget === "checkbox";
  return E.jsx(j, { classNames: r, style: a, disabled: s, id: t, label: d, displayLabel: l, rawDescription: C, onKeyRename: p, onKeyRenameBlur: m, onRemoveProperty: h, readonly: v, required: y, schema: _, uiSchema: O, registry: N, children: E.jsxs(b4, { fullWidth: !0, error: !!w.length, required: y, children: [n, l && !D && C ? E.jsx(bl, { variant: "caption", color: "textSecondary", children: k }) : null, x, b] }) });
}
function SAe(e) {
  const { children: t, column: n, ...r } = e;
  return E.jsx(Do, { container: !n, ...r, children: t });
}
function kAe(e) {
  const { optionSchemaField: t, selector: n } = e;
  return E.jsxs(hd, { sx: { mb: 2 }, children: [E.jsx(b4, { fullWidth: !0, sx: { mb: 2 }, children: n }), t] });
}
function _Ae(e) {
  const { description: t, title: n, properties: r, required: a, disabled: s, readonly: l, uiSchema: c, fieldPathId: d, schema: p, formData: m, optionalDataControl: h, onAddProperty: v, registry: y } = e, w = ht(c), x = bt("TitleFieldTemplate", y, w), b = bt("DescriptionFieldTemplate", y, w), k = !l && !s, { ButtonTemplates: { AddButton: C } } = y.templates;
  return E.jsxs(E.Fragment, { children: [n && E.jsx(x, { id: fE(d), title: n, required: a, schema: p, uiSchema: c, registry: y, optionalDataControl: k ? h : void 0 }), t && E.jsx(b, { id: Rm(d), description: t, schema: p, uiSchema: c, registry: y }), E.jsxs(Do, { container: !0, spacing: 2, style: { marginTop: "10px" }, children: [k ? void 0 : h, r.map((_, O) => (
    // Remove the <Grid> if the inner element is hidden as the <Grid>
    // itself would otherwise still take up space.
    _.hidden ? _.content : E.jsx(Do, { size: { xs: 12 }, style: { marginBottom: "10px" }, children: _.content }, O)
  ))] }), NV(p, c, m) && E.jsx(Do, { container: !0, justifyContent: "flex-end", children: E.jsx(Do, { children: E.jsx(C, { id: vl(d, "add"), className: "rjsf-object-property-expand", onClick: v, disabled: s || l, uiSchema: c, registry: y }) }) })] });
}
function EAe(e) {
  const { id: t, registry: n, label: r, onAddClick: a, onRemoveClick: s } = e;
  return a ? E.jsx(PS, { id: t, registry: n, className: "rjsf-add-optional-data", onClick: a, title: r, icon: E.jsx(Cq, { fontSize: "small" }) }) : s ? E.jsx(zq, { id: t, registry: n, className: "rjsf-remove-optional-data", onClick: s, title: r }) : E.jsx("em", { id: t, children: r });
}
function CAe(e) {
  return _t("MuiButton", e);
}
const qp = wt("MuiButton", ["root", "text", "textInherit", "textPrimary", "textSecondary", "textSuccess", "textError", "textInfo", "textWarning", "outlined", "outlinedInherit", "outlinedPrimary", "outlinedSecondary", "outlinedSuccess", "outlinedError", "outlinedInfo", "outlinedWarning", "contained", "containedInherit", "containedPrimary", "containedSecondary", "containedSuccess", "containedError", "containedInfo", "containedWarning", "disableElevation", "focusVisible", "disabled", "colorInherit", "colorPrimary", "colorSecondary", "colorSuccess", "colorError", "colorInfo", "colorWarning", "textSizeSmall", "textSizeMedium", "textSizeLarge", "outlinedSizeSmall", "outlinedSizeMedium", "outlinedSizeLarge", "containedSizeSmall", "containedSizeMedium", "containedSizeLarge", "sizeMedium", "sizeSmall", "sizeLarge", "fullWidth", "startIcon", "endIcon", "icon", "iconSizeSmall", "iconSizeMedium", "iconSizeLarge", "loading", "loadingWrapper", "loadingIconPlaceholder", "loadingIndicator", "loadingPositionCenter", "loadingPositionStart", "loadingPositionEnd"]), OAe = /* @__PURE__ */ M.createContext({}), MAe = /* @__PURE__ */ M.createContext(void 0), NAe = (e) => {
  const {
    color: t,
    disableElevation: n,
    fullWidth: r,
    size: a,
    variant: s,
    loading: l,
    loadingPosition: c,
    classes: d
  } = e, p = {
    root: ["root", l && "loading", s, `${s}${qe(t)}`, `size${qe(a)}`, `${s}Size${qe(a)}`, `color${qe(t)}`, n && "disableElevation", r && "fullWidth", l && `loadingPosition${qe(c)}`],
    startIcon: ["icon", "startIcon", `iconSize${qe(a)}`],
    endIcon: ["icon", "endIcon", `iconSize${qe(a)}`],
    loadingIndicator: ["loadingIndicator"],
    loadingWrapper: ["loadingWrapper"]
  }, m = kt(p, CAe, d);
  return {
    ...d,
    // forward the focused, disabled, etc. classes to the ButtonBase
    ...m
  };
}, Fq = [{
  props: {
    size: "small"
  },
  style: {
    "& > *:nth-of-type(1)": {
      fontSize: 18
    }
  }
}, {
  props: {
    size: "medium"
  },
  style: {
    "& > *:nth-of-type(1)": {
      fontSize: 20
    }
  }
}, {
  props: {
    size: "large"
  },
  style: {
    "& > *:nth-of-type(1)": {
      fontSize: 22
    }
  }
}], RAe = $e(nS, {
  shouldForwardProp: (e) => Xo(e) || e === "classes",
  name: "MuiButton",
  slot: "Root",
  overridesResolver: (e, t) => {
    const {
      ownerState: n
    } = e;
    return [t.root, t[n.variant], t[`${n.variant}${qe(n.color)}`], t[`size${qe(n.size)}`], t[`${n.variant}Size${qe(n.size)}`], n.color === "inherit" && t.colorInherit, n.disableElevation && t.disableElevation, n.fullWidth && t.fullWidth, n.loading && t.loading];
  }
})(Ct(({
  theme: e
}) => {
  const t = e.palette.mode === "light" ? e.palette.grey[300] : e.palette.grey[800], n = e.palette.mode === "light" ? e.palette.grey.A100 : e.palette.grey[700];
  return {
    ...e.typography.button,
    minWidth: 64,
    padding: "6px 16px",
    border: 0,
    borderRadius: (e.vars || e).shape.borderRadius,
    transition: e.transitions.create(["background-color", "box-shadow", "border-color", "color"], {
      duration: e.transitions.duration.short
    }),
    "&:hover": {
      textDecoration: "none"
    },
    [`&.${qp.disabled}`]: {
      color: (e.vars || e).palette.action.disabled
    },
    variants: [{
      props: {
        variant: "contained"
      },
      style: {
        color: "var(--variant-containedColor)",
        backgroundColor: "var(--variant-containedBg)",
        boxShadow: (e.vars || e).shadows[2],
        "&:hover": {
          boxShadow: (e.vars || e).shadows[4],
          // Reset on touch devices, it doesn't add specificity
          "@media (hover: none)": {
            boxShadow: (e.vars || e).shadows[2]
          }
        },
        "&:active": {
          boxShadow: (e.vars || e).shadows[8]
        },
        [`&.${qp.focusVisible}`]: {
          boxShadow: (e.vars || e).shadows[6]
        },
        [`&.${qp.disabled}`]: {
          color: (e.vars || e).palette.action.disabled,
          boxShadow: (e.vars || e).shadows[0],
          backgroundColor: (e.vars || e).palette.action.disabledBackground
        }
      }
    }, {
      props: {
        variant: "outlined"
      },
      style: {
        padding: "5px 15px",
        border: "1px solid currentColor",
        borderColor: "var(--variant-outlinedBorder, currentColor)",
        backgroundColor: "var(--variant-outlinedBg)",
        color: "var(--variant-outlinedColor)",
        [`&.${qp.disabled}`]: {
          border: `1px solid ${(e.vars || e).palette.action.disabledBackground}`
        }
      }
    }, {
      props: {
        variant: "text"
      },
      style: {
        padding: "6px 8px",
        color: "var(--variant-textColor)",
        backgroundColor: "var(--variant-textBg)"
      }
    }, ...Object.entries(e.palette).filter(Ko()).map(([r]) => ({
      props: {
        color: r
      },
      style: {
        "--variant-textColor": (e.vars || e).palette[r].main,
        "--variant-outlinedColor": (e.vars || e).palette[r].main,
        "--variant-outlinedBorder": e.alpha((e.vars || e).palette[r].main, 0.5),
        "--variant-containedColor": (e.vars || e).palette[r].contrastText,
        "--variant-containedBg": (e.vars || e).palette[r].main,
        "@media (hover: hover)": {
          "&:hover": {
            "--variant-containedBg": (e.vars || e).palette[r].dark,
            "--variant-textBg": e.alpha((e.vars || e).palette[r].main, (e.vars || e).palette.action.hoverOpacity),
            "--variant-outlinedBorder": (e.vars || e).palette[r].main,
            "--variant-outlinedBg": e.alpha((e.vars || e).palette[r].main, (e.vars || e).palette.action.hoverOpacity)
          }
        }
      }
    })), {
      props: {
        color: "inherit"
      },
      style: {
        color: "inherit",
        borderColor: "currentColor",
        "--variant-containedBg": e.vars ? e.vars.palette.Button.inheritContainedBg : t,
        "@media (hover: hover)": {
          "&:hover": {
            "--variant-containedBg": e.vars ? e.vars.palette.Button.inheritContainedHoverBg : n,
            "--variant-textBg": e.alpha((e.vars || e).palette.text.primary, (e.vars || e).palette.action.hoverOpacity),
            "--variant-outlinedBg": e.alpha((e.vars || e).palette.text.primary, (e.vars || e).palette.action.hoverOpacity)
          }
        }
      }
    }, {
      props: {
        size: "small",
        variant: "text"
      },
      style: {
        padding: "4px 5px",
        fontSize: e.typography.pxToRem(13)
      }
    }, {
      props: {
        size: "large",
        variant: "text"
      },
      style: {
        padding: "8px 11px",
        fontSize: e.typography.pxToRem(15)
      }
    }, {
      props: {
        size: "small",
        variant: "outlined"
      },
      style: {
        padding: "3px 9px",
        fontSize: e.typography.pxToRem(13)
      }
    }, {
      props: {
        size: "large",
        variant: "outlined"
      },
      style: {
        padding: "7px 21px",
        fontSize: e.typography.pxToRem(15)
      }
    }, {
      props: {
        size: "small",
        variant: "contained"
      },
      style: {
        padding: "4px 10px",
        fontSize: e.typography.pxToRem(13)
      }
    }, {
      props: {
        size: "large",
        variant: "contained"
      },
      style: {
        padding: "8px 22px",
        fontSize: e.typography.pxToRem(15)
      }
    }, {
      props: {
        disableElevation: !0
      },
      style: {
        boxShadow: "none",
        "&:hover": {
          boxShadow: "none"
        },
        [`&.${qp.focusVisible}`]: {
          boxShadow: "none"
        },
        "&:active": {
          boxShadow: "none"
        },
        [`&.${qp.disabled}`]: {
          boxShadow: "none"
        }
      }
    }, {
      props: {
        fullWidth: !0
      },
      style: {
        width: "100%"
      }
    }, {
      props: {
        loadingPosition: "center"
      },
      style: {
        transition: e.transitions.create(["background-color", "box-shadow", "border-color"], {
          duration: e.transitions.duration.short
        }),
        [`&.${qp.loading}`]: {
          color: "transparent"
        }
      }
    }]
  };
})), AAe = $e("span", {
  name: "MuiButton",
  slot: "StartIcon",
  overridesResolver: (e, t) => {
    const {
      ownerState: n
    } = e;
    return [t.startIcon, n.loading && t.startIconLoadingStart, t[`iconSize${qe(n.size)}`]];
  }
})(({
  theme: e
}) => ({
  display: "inherit",
  marginRight: 8,
  marginLeft: -4,
  variants: [{
    props: {
      size: "small"
    },
    style: {
      marginLeft: -2
    }
  }, {
    props: {
      loadingPosition: "start",
      loading: !0
    },
    style: {
      transition: e.transitions.create(["opacity"], {
        duration: e.transitions.duration.short
      }),
      opacity: 0
    }
  }, {
    props: {
      loadingPosition: "start",
      loading: !0,
      fullWidth: !0
    },
    style: {
      marginRight: -8
    }
  }, ...Fq]
})), jAe = $e("span", {
  name: "MuiButton",
  slot: "EndIcon",
  overridesResolver: (e, t) => {
    const {
      ownerState: n
    } = e;
    return [t.endIcon, n.loading && t.endIconLoadingEnd, t[`iconSize${qe(n.size)}`]];
  }
})(({
  theme: e
}) => ({
  display: "inherit",
  marginRight: -4,
  marginLeft: 8,
  variants: [{
    props: {
      size: "small"
    },
    style: {
      marginRight: -2
    }
  }, {
    props: {
      loadingPosition: "end",
      loading: !0
    },
    style: {
      transition: e.transitions.create(["opacity"], {
        duration: e.transitions.duration.short
      }),
      opacity: 0
    }
  }, {
    props: {
      loadingPosition: "end",
      loading: !0,
      fullWidth: !0
    },
    style: {
      marginLeft: -8
    }
  }, ...Fq]
})), PAe = $e("span", {
  name: "MuiButton",
  slot: "LoadingIndicator"
})(({
  theme: e
}) => ({
  display: "none",
  position: "absolute",
  visibility: "visible",
  variants: [{
    props: {
      loading: !0
    },
    style: {
      display: "flex"
    }
  }, {
    props: {
      loadingPosition: "start"
    },
    style: {
      left: 14
    }
  }, {
    props: {
      loadingPosition: "start",
      size: "small"
    },
    style: {
      left: 10
    }
  }, {
    props: {
      variant: "text",
      loadingPosition: "start"
    },
    style: {
      left: 6
    }
  }, {
    props: {
      loadingPosition: "center"
    },
    style: {
      left: "50%",
      transform: "translate(-50%)",
      color: (e.vars || e).palette.action.disabled
    }
  }, {
    props: {
      loadingPosition: "end"
    },
    style: {
      right: 14
    }
  }, {
    props: {
      loadingPosition: "end",
      size: "small"
    },
    style: {
      right: 10
    }
  }, {
    props: {
      variant: "text",
      loadingPosition: "end"
    },
    style: {
      right: 6
    }
  }, {
    props: {
      loadingPosition: "start",
      fullWidth: !0
    },
    style: {
      position: "relative",
      left: -10
    }
  }, {
    props: {
      loadingPosition: "end",
      fullWidth: !0
    },
    style: {
      position: "relative",
      right: -10
    }
  }]
})), az = $e("span", {
  name: "MuiButton",
  slot: "LoadingIconPlaceholder"
})({
  display: "inline-block",
  width: "1em",
  height: "1em"
}), DAe = /* @__PURE__ */ M.forwardRef(function(e, t) {
  const n = M.useContext(OAe), r = M.useContext(MAe), a = fx(n, e), s = At({
    props: a,
    name: "MuiButton"
  }), {
    children: l,
    color: c = "primary",
    component: d = "button",
    className: p,
    disabled: m = !1,
    disableElevation: h = !1,
    disableFocusRipple: v = !1,
    endIcon: y,
    focusVisibleClassName: w,
    fullWidth: x = !1,
    id: b,
    loading: k = null,
    loadingIndicator: C,
    loadingPosition: _ = "center",
    size: O = "medium",
    startIcon: N,
    type: R,
    variant: j = "text",
    ...D
  } = s, $ = eg(b), z = C ?? /* @__PURE__ */ E.jsx(Oq, {
    "aria-labelledby": $,
    color: "inherit",
    size: 16
  }), B = {
    ...s,
    color: c,
    component: d,
    disabled: m,
    disableElevation: h,
    disableFocusRipple: v,
    fullWidth: x,
    loading: k,
    loadingIndicator: z,
    loadingPosition: _,
    size: O,
    type: R,
    variant: j
  }, P = NAe(B), W = (N || k && _ === "start") && /* @__PURE__ */ E.jsx(AAe, {
    className: P.startIcon,
    ownerState: B,
    children: N || /* @__PURE__ */ E.jsx(az, {
      className: P.loadingIconPlaceholder,
      ownerState: B
    })
  }), I = (y || k && _ === "end") && /* @__PURE__ */ E.jsx(jAe, {
    className: P.endIcon,
    ownerState: B,
    children: y || /* @__PURE__ */ E.jsx(az, {
      className: P.loadingIconPlaceholder,
      ownerState: B
    })
  }), G = r || "", L = typeof k == "boolean" ? (
    // use plain HTML span to minimize the runtime overhead
    /* @__PURE__ */ E.jsx("span", {
      className: P.loadingWrapper,
      style: {
        display: "contents"
      },
      children: k && /* @__PURE__ */ E.jsx(PAe, {
        className: P.loadingIndicator,
        ownerState: B,
        children: z
      })
    })
  ) : null;
  return /* @__PURE__ */ E.jsxs(RAe, {
    ownerState: B,
    className: Ke(n.className, P.root, p, G),
    component: d,
    disabled: m || k,
    focusRipple: !v,
    focusVisibleClassName: Ke(P.focusVisible, w),
    ref: t,
    type: R,
    id: k ? $ : b,
    ...D,
    classes: P,
    children: [W, _ !== "end" && L, l, _ === "end" && L, I]
  });
});
function $Ae({ uiSchema: e }) {
  const { submitText: t, norender: n, props: r = {} } = WH(e);
  return n ? null : E.jsx(hd, { marginTop: 3, children: E.jsx(DAe, { type: "submit", variant: "contained", color: "primary", ...r, children: t }) });
}
function TAe(e) {
  return _t("MuiDivider", e);
}
const iz = wt("MuiDivider", ["root", "absolute", "fullWidth", "inset", "middle", "flexItem", "light", "vertical", "withChildren", "withChildrenVertical", "textAlignRight", "textAlignLeft", "wrapper", "wrapperVertical"]), LAe = (e) => {
  const {
    absolute: t,
    children: n,
    classes: r,
    flexItem: a,
    light: s,
    orientation: l,
    textAlign: c,
    variant: d
  } = e;
  return kt({
    root: ["root", t && "absolute", d, s && "light", l === "vertical" && "vertical", a && "flexItem", n && "withChildren", n && l === "vertical" && "withChildrenVertical", c === "right" && l !== "vertical" && "textAlignRight", c === "left" && l !== "vertical" && "textAlignLeft"],
    wrapper: ["wrapper", l === "vertical" && "wrapperVertical"]
  }, TAe, r);
}, IAe = $e("div", {
  name: "MuiDivider",
  slot: "Root",
  overridesResolver: (e, t) => {
    const {
      ownerState: n
    } = e;
    return [t.root, n.absolute && t.absolute, t[n.variant], n.light && t.light, n.orientation === "vertical" && t.vertical, n.flexItem && t.flexItem, n.children && t.withChildren, n.children && n.orientation === "vertical" && t.withChildrenVertical, n.textAlign === "right" && n.orientation !== "vertical" && t.textAlignRight, n.textAlign === "left" && n.orientation !== "vertical" && t.textAlignLeft];
  }
})(Ct(({
  theme: e
}) => ({
  margin: 0,
  // Reset browser default style.
  flexShrink: 0,
  borderWidth: 0,
  borderStyle: "solid",
  borderColor: (e.vars || e).palette.divider,
  borderBottomWidth: "thin",
  variants: [{
    props: {
      absolute: !0
    },
    style: {
      position: "absolute",
      bottom: 0,
      left: 0,
      width: "100%"
    }
  }, {
    props: {
      light: !0
    },
    style: {
      borderColor: e.alpha((e.vars || e).palette.divider, 0.08)
    }
  }, {
    props: {
      variant: "inset"
    },
    style: {
      marginLeft: 72
    }
  }, {
    props: {
      variant: "middle",
      orientation: "horizontal"
    },
    style: {
      marginLeft: e.spacing(2),
      marginRight: e.spacing(2)
    }
  }, {
    props: {
      variant: "middle",
      orientation: "vertical"
    },
    style: {
      marginTop: e.spacing(1),
      marginBottom: e.spacing(1)
    }
  }, {
    props: {
      orientation: "vertical"
    },
    style: {
      height: "100%",
      borderBottomWidth: 0,
      borderRightWidth: "thin"
    }
  }, {
    props: {
      flexItem: !0
    },
    style: {
      alignSelf: "stretch",
      height: "auto"
    }
  }, {
    props: ({
      ownerState: t
    }) => !!t.children,
    style: {
      display: "flex",
      textAlign: "center",
      border: 0,
      borderTopStyle: "solid",
      borderLeftStyle: "solid",
      "&::before, &::after": {
        content: '""',
        alignSelf: "center"
      }
    }
  }, {
    props: ({
      ownerState: t
    }) => t.children && t.orientation !== "vertical",
    style: {
      "&::before, &::after": {
        width: "100%",
        borderTop: `thin solid ${(e.vars || e).palette.divider}`,
        borderTopStyle: "inherit"
      }
    }
  }, {
    props: ({
      ownerState: t
    }) => t.orientation === "vertical" && t.children,
    style: {
      flexDirection: "column",
      "&::before, &::after": {
        height: "100%",
        borderLeft: `thin solid ${(e.vars || e).palette.divider}`,
        borderLeftStyle: "inherit"
      }
    }
  }, {
    props: ({
      ownerState: t
    }) => t.textAlign === "right" && t.orientation !== "vertical",
    style: {
      "&::before": {
        width: "90%"
      },
      "&::after": {
        width: "10%"
      }
    }
  }, {
    props: ({
      ownerState: t
    }) => t.textAlign === "left" && t.orientation !== "vertical",
    style: {
      "&::before": {
        width: "10%"
      },
      "&::after": {
        width: "90%"
      }
    }
  }]
}))), zAe = $e("span", {
  name: "MuiDivider",
  slot: "Wrapper",
  overridesResolver: (e, t) => {
    const {
      ownerState: n
    } = e;
    return [t.wrapper, n.orientation === "vertical" && t.wrapperVertical];
  }
})(Ct(({
  theme: e
}) => ({
  display: "inline-block",
  paddingLeft: `calc(${e.spacing(1)} * 1.2)`,
  paddingRight: `calc(${e.spacing(1)} * 1.2)`,
  whiteSpace: "nowrap",
  variants: [{
    props: {
      orientation: "vertical"
    },
    style: {
      paddingTop: `calc(${e.spacing(1)} * 1.2)`,
      paddingBottom: `calc(${e.spacing(1)} * 1.2)`
    }
  }]
}))), g3 = /* @__PURE__ */ M.forwardRef(function(e, t) {
  const n = At({
    props: e,
    name: "MuiDivider"
  }), {
    absolute: r = !1,
    children: a,
    className: s,
    orientation: l = "horizontal",
    component: c = a || l === "vertical" ? "div" : "hr",
    flexItem: d = !1,
    light: p = !1,
    role: m = c !== "hr" ? "separator" : void 0,
    textAlign: h = "center",
    variant: v = "fullWidth",
    ...y
  } = n, w = {
    ...n,
    absolute: r,
    component: c,
    flexItem: d,
    light: p,
    orientation: l,
    role: m,
    textAlign: h,
    variant: v
  }, x = LAe(w);
  return /* @__PURE__ */ E.jsx(IAe, {
    as: c,
    className: Ke(x.root, s),
    role: m,
    ref: t,
    ownerState: w,
    "aria-orientation": m === "separator" && (c !== "hr" || l === "vertical") ? l : void 0,
    ...y,
    children: a ? /* @__PURE__ */ E.jsx(zAe, {
      className: x.wrapper,
      ownerState: w,
      children: a
    }) : null
  });
});
g3 && (g3.muiSkipListHighlight = !0);
function FAe({ id: e, title: t, optionalDataControl: n }) {
  let r = E.jsx(bl, { variant: "h5", children: t });
  return n && (r = E.jsxs(Do, { container: !0, spacing: 0, children: [E.jsx(Do, { size: "grow", children: r }), E.jsx(Do, { justifyContent: "flex-end", children: n })] })), E.jsxs(hd, { id: e, mb: 1, mt: 1, children: [r, E.jsx(g3, {})] });
}
function BAe(e) {
  const { children: t, classNames: n, style: r, disabled: a, id: s, label: l, displayLabel: c, onKeyRenameBlur: d, onRemoveProperty: p, readonly: m, required: h, schema: v, uiSchema: y, registry: w } = e, { templates: x, translateString: b } = w, { RemoveButton: k } = x.ButtonTemplates, C = b(Gt.KeyLabel, [l]), _ = hc in v, O = {
    flex: 1,
    paddingLeft: 6,
    paddingRight: 6,
    fontWeight: "bold"
  };
  return _ ? E.jsxs(Do, { container: !0, alignItems: "flex-start", spacing: 2, className: n, style: r, children: [E.jsx(Do, { size: 5.5, children: E.jsx(_4, { fullWidth: !0, required: h, label: c ? C : void 0, defaultValue: l, disabled: a || m, id: `${s}-key`, name: `${s}-key`, onBlur: m ? void 0 : d, type: "text" }) }), E.jsx(Do, { size: 5.5, children: t }), E.jsx(Do, { sx: { mt: 1.5 }, children: E.jsx(k, { id: vl(s, "remove"), className: "rjsf-object-property-remove", iconType: "default", style: O, disabled: a || m, onClick: p, uiSchema: y, registry: w }) })] }, `${s}-key`) : E.jsx("div", { className: n, style: r, children: t });
}
function UAe() {
  return {
    ArrayFieldItemTemplate: V5e,
    ArrayFieldTemplate: H5e,
    BaseInputTemplate: FRe,
    ButtonTemplates: {
      AddButton: P5e,
      CopyButton: gAe,
      MoveDownButton: vAe,
      MoveUpButton: yAe,
      RemoveButton: zq,
      SubmitButton: $Ae
    },
    DescriptionFieldTemplate: WRe,
    ErrorListTemplate: dAe,
    FieldErrorTemplate: bAe,
    FieldHelpTemplate: wAe,
    FieldTemplate: xAe,
    GridTemplate: SAe,
    MultiSchemaFieldTemplate: kAe,
    ObjectFieldTemplate: _Ae,
    OptionalDataControlsTemplate: EAe,
    TitleFieldTemplate: FAe,
    WrapIfAdditionalTemplate: BAe
  };
}
function VAe(e) {
  return _t("PrivateSwitchBase", e);
}
wt("PrivateSwitchBase", ["root", "checked", "disabled", "input", "edgeStart", "edgeEnd"]);
const HAe = (e) => {
  const {
    classes: t,
    checked: n,
    disabled: r,
    edge: a
  } = e, s = {
    root: ["root", n && "checked", r && "disabled", a && `edge${qe(a)}`],
    input: ["input"]
  };
  return kt(s, VAe, t);
}, qAe = $e(nS, {
  name: "MuiSwitchBase"
})({
  padding: 9,
  borderRadius: "50%",
  variants: [{
    props: {
      edge: "start",
      size: "small"
    },
    style: {
      marginLeft: -3
    }
  }, {
    props: ({
      edge: e,
      ownerState: t
    }) => e === "start" && t.size !== "small",
    style: {
      marginLeft: -12
    }
  }, {
    props: {
      edge: "end",
      size: "small"
    },
    style: {
      marginRight: -3
    }
  }, {
    props: ({
      edge: e,
      ownerState: t
    }) => e === "end" && t.size !== "small",
    style: {
      marginRight: -12
    }
  }]
}), WAe = $e("input", {
  name: "MuiSwitchBase",
  shouldForwardProp: Xo
})({
  cursor: "inherit",
  position: "absolute",
  opacity: 0,
  width: "100%",
  height: "100%",
  top: 0,
  left: 0,
  margin: 0,
  padding: 0,
  zIndex: 1
}), Bq = /* @__PURE__ */ M.forwardRef(function(e, t) {
  const {
    autoFocus: n,
    checked: r,
    checkedIcon: a,
    defaultChecked: s,
    disabled: l,
    disableFocusRipple: c = !1,
    edge: d = !1,
    icon: p,
    id: m,
    inputProps: h,
    inputRef: v,
    name: y,
    onBlur: w,
    onChange: x,
    onFocus: b,
    readOnly: k,
    required: C = !1,
    tabIndex: _,
    type: O,
    value: N,
    slots: R = {},
    slotProps: j = {},
    ...D
  } = e, [$, z] = Bx({
    controlled: r,
    default: !!s,
    name: "SwitchBase",
    state: "checked"
  }), B = Ll(), P = (H) => {
    b && b(H), B && B.onFocus && B.onFocus(H);
  }, W = (H) => {
    w && w(H), B && B.onBlur && B.onBlur(H);
  }, I = (H) => {
    if (H.nativeEvent.defaultPrevented)
      return;
    const Q = H.target.checked;
    z(Q), x && x(H, Q);
  };
  let G = l;
  B && typeof G > "u" && (G = B.disabled);
  const L = O === "checkbox" || O === "radio", K = {
    ...e,
    checked: $,
    disabled: G,
    disableFocusRipple: c,
    edge: d
  }, q = HAe(K), Z = {
    slots: R,
    slotProps: {
      input: h,
      ...j
    }
  }, [V, F] = Hn("root", {
    ref: t,
    elementType: qAe,
    className: q.root,
    shouldForwardComponentProp: !0,
    externalForwardedProps: {
      ...Z,
      component: "span",
      ...D
    },
    getSlotProps: (H) => ({
      ...H,
      onFocus: (Q) => {
        H.onFocus?.(Q), P(Q);
      },
      onBlur: (Q) => {
        H.onBlur?.(Q), W(Q);
      }
    }),
    ownerState: K,
    additionalProps: {
      centerRipple: !0,
      focusRipple: !c,
      disabled: G,
      role: void 0,
      tabIndex: null
    }
  }), [X, U] = Hn("input", {
    ref: v,
    elementType: WAe,
    className: q.input,
    externalForwardedProps: Z,
    getSlotProps: (H) => ({
      ...H,
      onChange: (Q) => {
        H.onChange?.(Q), I(Q);
      }
    }),
    ownerState: K,
    additionalProps: {
      autoFocus: n,
      checked: r,
      defaultChecked: s,
      disabled: G,
      id: L ? m : void 0,
      name: y,
      readOnly: k,
      required: C,
      tabIndex: _,
      type: O,
      ...O === "checkbox" && N === void 0 ? {} : {
        value: N
      }
    }
  });
  return /* @__PURE__ */ E.jsxs(V, {
    ...F,
    children: [/* @__PURE__ */ E.jsx(X, {
      ...U
    }), $ ? a : p]
  });
}), GAe = xi(/* @__PURE__ */ E.jsx("path", {
  d: "M19 5v14H5V5h14m0-2H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2z"
})), KAe = xi(/* @__PURE__ */ E.jsx("path", {
  d: "M19 3H5c-1.11 0-2 .9-2 2v14c0 1.1.89 2 2 2h14c1.11 0 2-.9 2-2V5c0-1.1-.89-2-2-2zm-9 14l-5-5 1.41-1.41L10 14.17l7.59-7.59L19 8l-9 9z"
})), XAe = xi(/* @__PURE__ */ E.jsx("path", {
  d: "M19 3H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm-2 10H7v-2h10v2z"
}));
function YAe(e) {
  return _t("MuiCheckbox", e);
}
const xN = wt("MuiCheckbox", ["root", "checked", "disabled", "indeterminate", "colorPrimary", "colorSecondary", "sizeSmall", "sizeMedium"]), QAe = (e) => {
  const {
    classes: t,
    indeterminate: n,
    color: r,
    size: a
  } = e, s = {
    root: ["root", n && "indeterminate", `color${qe(r)}`, `size${qe(a)}`]
  }, l = kt(s, YAe, t);
  return {
    ...t,
    // forward the disabled and checked classes to the SwitchBase
    ...l
  };
}, JAe = $e(Bq, {
  shouldForwardProp: (e) => Xo(e) || e === "classes",
  name: "MuiCheckbox",
  slot: "Root",
  overridesResolver: (e, t) => {
    const {
      ownerState: n
    } = e;
    return [t.root, n.indeterminate && t.indeterminate, t[`size${qe(n.size)}`], n.color !== "default" && t[`color${qe(n.color)}`]];
  }
})(Ct(({
  theme: e
}) => ({
  color: (e.vars || e).palette.text.secondary,
  variants: [{
    props: {
      color: "default",
      disableRipple: !1
    },
    style: {
      "&:hover": {
        backgroundColor: e.alpha((e.vars || e).palette.action.active, (e.vars || e).palette.action.hoverOpacity)
      }
    }
  }, ...Object.entries(e.palette).filter(Ko()).map(([t]) => ({
    props: {
      color: t,
      disableRipple: !1
    },
    style: {
      "&:hover": {
        backgroundColor: e.alpha((e.vars || e).palette[t].main, (e.vars || e).palette.action.hoverOpacity)
      }
    }
  })), ...Object.entries(e.palette).filter(Ko()).map(([t]) => ({
    props: {
      color: t
    },
    style: {
      [`&.${xN.checked}, &.${xN.indeterminate}`]: {
        color: (e.vars || e).palette[t].main
      },
      [`&.${xN.disabled}`]: {
        color: (e.vars || e).palette.action.disabled
      }
    }
  })), {
    // Should be last to override other colors
    props: {
      disableRipple: !1
    },
    style: {
      // Reset on touch devices, it doesn't add specificity
      "&:hover": {
        "@media (hover: none)": {
          backgroundColor: "transparent"
        }
      }
    }
  }]
}))), ZAe = /* @__PURE__ */ E.jsx(KAe, {}), e4e = /* @__PURE__ */ E.jsx(GAe, {}), t4e = /* @__PURE__ */ E.jsx(XAe, {}), Uq = /* @__PURE__ */ M.forwardRef(function(e, t) {
  const n = At({
    props: e,
    name: "MuiCheckbox"
  }), {
    checkedIcon: r = ZAe,
    color: a = "primary",
    icon: s = e4e,
    indeterminate: l = !1,
    indeterminateIcon: c = t4e,
    inputProps: d,
    size: p = "medium",
    disableRipple: m = !1,
    className: h,
    slots: v = {},
    slotProps: y = {},
    ...w
  } = n, x = l ? c : s, b = l ? c : r, k = {
    ...n,
    disableRipple: m,
    color: a,
    indeterminate: l,
    size: p
  }, C = QAe(k), _ = y.input ?? d, [O, N] = Hn("root", {
    ref: t,
    elementType: JAe,
    className: Ke(C.root, h),
    shouldForwardComponentProp: !0,
    externalForwardedProps: {
      slots: v,
      slotProps: y,
      ...w
    },
    ownerState: k,
    additionalProps: {
      type: "checkbox",
      icon: /* @__PURE__ */ M.cloneElement(x, {
        fontSize: x.props.fontSize ?? p
      }),
      checkedIcon: /* @__PURE__ */ M.cloneElement(b, {
        fontSize: b.props.fontSize ?? p
      }),
      disableRipple: m,
      slots: v,
      slotProps: {
        input: Eq(typeof _ == "function" ? _(k) : _, {
          "data-indeterminate": l
        })
      }
    }
  });
  return /* @__PURE__ */ E.jsx(O, {
    ...N,
    classes: C
  });
});
function n4e(e) {
  return _t("MuiFormControlLabel", e);
}
const Bw = wt("MuiFormControlLabel", ["root", "labelPlacementStart", "labelPlacementTop", "labelPlacementBottom", "disabled", "label", "error", "required", "asterisk"]), r4e = (e) => {
  const {
    classes: t,
    disabled: n,
    labelPlacement: r,
    error: a,
    required: s
  } = e, l = {
    root: ["root", n && "disabled", `labelPlacement${qe(r)}`, a && "error", s && "required"],
    label: ["label", n && "disabled"],
    asterisk: ["asterisk", a && "error"]
  };
  return kt(l, n4e, t);
}, o4e = $e("label", {
  name: "MuiFormControlLabel",
  slot: "Root",
  overridesResolver: (e, t) => {
    const {
      ownerState: n
    } = e;
    return [{
      [`& .${Bw.label}`]: t.label
    }, t.root, t[`labelPlacement${qe(n.labelPlacement)}`]];
  }
})(Ct(({
  theme: e
}) => ({
  display: "inline-flex",
  alignItems: "center",
  cursor: "pointer",
  // For correct alignment with the text.
  verticalAlign: "middle",
  WebkitTapHighlightColor: "transparent",
  marginLeft: -11,
  marginRight: 16,
  // used for row presentation of radio/checkbox
  [`&.${Bw.disabled}`]: {
    cursor: "default"
  },
  [`& .${Bw.label}`]: {
    [`&.${Bw.disabled}`]: {
      color: (e.vars || e).palette.text.disabled
    }
  },
  variants: [{
    props: {
      labelPlacement: "start"
    },
    style: {
      flexDirection: "row-reverse",
      marginRight: -11
    }
  }, {
    props: {
      labelPlacement: "top"
    },
    style: {
      flexDirection: "column-reverse"
    }
  }, {
    props: {
      labelPlacement: "bottom"
    },
    style: {
      flexDirection: "column"
    }
  }, {
    props: ({
      labelPlacement: t
    }) => t === "start" || t === "top" || t === "bottom",
    style: {
      marginLeft: 16
      // used for row presentation of radio/checkbox
    }
  }]
}))), a4e = $e("span", {
  name: "MuiFormControlLabel",
  slot: "Asterisk"
})(Ct(({
  theme: e
}) => ({
  [`&.${Bw.error}`]: {
    color: (e.vars || e).palette.error.main
  }
}))), E4 = /* @__PURE__ */ M.forwardRef(function(e, t) {
  const n = At({
    props: e,
    name: "MuiFormControlLabel"
  }), {
    checked: r,
    className: a,
    componentsProps: s = {},
    control: l,
    disabled: c,
    disableTypography: d,
    inputRef: p,
    label: m,
    labelPlacement: h = "end",
    name: v,
    onChange: y,
    required: w,
    slots: x = {},
    slotProps: b = {},
    value: k,
    ...C
  } = n, _ = Ll(), O = c ?? l.props.disabled ?? _?.disabled, N = w ?? l.props.required, R = {
    disabled: O,
    required: N
  };
  ["checked", "name", "onChange", "value", "inputRef"].forEach((I) => {
    typeof l.props[I] > "u" && typeof n[I] < "u" && (R[I] = n[I]);
  });
  const j = bd({
    props: n,
    muiFormControl: _,
    states: ["error"]
  }), D = {
    ...n,
    disabled: O,
    labelPlacement: h,
    required: N,
    error: j.error
  }, $ = r4e(D), z = {
    slots: x,
    slotProps: {
      ...s,
      ...b
    }
  }, [B, P] = Hn("typography", {
    elementType: bl,
    externalForwardedProps: z,
    ownerState: D
  });
  let W = m;
  return W != null && W.type !== bl && !d && (W = /* @__PURE__ */ E.jsx(B, {
    component: "span",
    ...P,
    className: Ke($.label, P?.className),
    children: W
  })), /* @__PURE__ */ E.jsxs(o4e, {
    className: Ke($.root, a),
    ownerState: D,
    ref: t,
    ...C,
    children: [/* @__PURE__ */ M.cloneElement(l, R), N ? /* @__PURE__ */ E.jsxs("div", {
      children: [W, /* @__PURE__ */ E.jsxs(a4e, {
        ownerState: D,
        "aria-hidden": !0,
        className: $.asterisk,
        children: ["", "*"]
      })]
    }) : W]
  });
});
function i4e(e) {
  var t;
  const { schema: n, id: r, htmlName: a, value: s, disabled: l, readonly: c, label: d = "", hideLabel: p, autofocus: m, onChange: h, onBlur: v, onFocus: y, registry: w, options: x, uiSchema: b } = e, k = bt("DescriptionFieldTemplate", w, x), C = Zw(n), _ = (j, D) => h(D), O = () => v(r, s), N = () => y(r, s), R = (t = x.description) !== null && t !== void 0 ? t : n.description;
  return E.jsxs(E.Fragment, { children: [!p && R && E.jsx(k, { id: Rm(r), description: R, schema: n, uiSchema: b, registry: w }), E.jsx(E4, { control: E.jsx(Uq, { id: r, name: a || r, checked: typeof s > "u" ? !1 : !!s, required: C, disabled: l || c, autoFocus: m, onChange: _, onBlur: O, onFocus: N, "aria-describedby": _i(r) }), label: Am(d, p, !1) })] });
}
function s4e(e) {
  return _t("MuiFormGroup", e);
}
wt("MuiFormGroup", ["root", "row", "error"]);
const l4e = (e) => {
  const {
    classes: t,
    row: n,
    error: r
  } = e;
  return kt({
    root: ["root", n && "row", r && "error"]
  }, s4e, t);
}, u4e = $e("div", {
  name: "MuiFormGroup",
  slot: "Root",
  overridesResolver: (e, t) => {
    const {
      ownerState: n
    } = e;
    return [t.root, n.row && t.row];
  }
})({
  display: "flex",
  flexDirection: "column",
  flexWrap: "wrap",
  variants: [{
    props: {
      row: !0
    },
    style: {
      flexDirection: "row"
    }
  }]
}), Vq = /* @__PURE__ */ M.forwardRef(function(e, t) {
  const n = At({
    props: e,
    name: "MuiFormGroup"
  }), {
    className: r,
    row: a = !1,
    ...s
  } = n, l = Ll(), c = bd({
    props: n,
    muiFormControl: l,
    states: ["error"]
  }), d = {
    ...n,
    row: a,
    error: c.error
  }, p = l4e(d);
  return /* @__PURE__ */ E.jsx(u4e, {
    className: Ke(p.root, r),
    ownerState: d,
    ref: t,
    ...s
  });
});
function c4e({ label: e, hideLabel: t, id: n, htmlName: r, disabled: a, options: s, value: l, autofocus: c, readonly: d, required: p, onChange: m, onBlur: h, onFocus: v }) {
  const { enumOptions: y, enumDisabled: w, inline: x, emptyValue: b } = s, k = Array.isArray(l) ? l : [l], C = (N) => ({ target: { checked: R } }) => {
    m(R ? BH(N, k, y) : FH(N, k, y));
  }, _ = ({ target: N }) => h(n, to(N && N.value, y, b)), O = ({ target: N }) => v(n, to(N && N.value, y, b));
  return E.jsxs(E.Fragment, { children: [Am(E.jsx(EE, { required: p, htmlFor: n, children: e || void 0 }), t), E.jsx(Vq, { id: n, row: !!x, children: Array.isArray(y) && y.map((N, R) => {
    const j = dE(N.value, k), D = Array.isArray(w) && w.indexOf(N.value) !== -1, $ = E.jsx(Uq, { id: pE(n, R), name: r || n, checked: j, disabled: a || D || d, autoFocus: c && R === 0, onChange: C(R), onBlur: _, onFocus: O, "aria-describedby": _i(n) });
    return E.jsx(E4, { control: $, label: N.label }, R);
  }) })] });
}
const d4e = xi(/* @__PURE__ */ E.jsx("path", {
  d: "M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.42 0-8-3.58-8-8s3.58-8 8-8 8 3.58 8 8-3.58 8-8 8z"
})), f4e = xi(/* @__PURE__ */ E.jsx("path", {
  d: "M8.465 8.465C9.37 7.56 10.62 7 12 7C14.76 7 17 9.24 17 12C17 13.38 16.44 14.63 15.535 15.535C14.63 16.44 13.38 17 12 17C9.24 17 7 14.76 7 12C7 10.62 7.56 9.37 8.465 8.465Z"
})), p4e = $e("span", {
  name: "MuiRadioButtonIcon",
  shouldForwardProp: Xo
})({
  position: "relative",
  display: "flex"
}), m4e = $e(d4e, {
  name: "MuiRadioButtonIcon"
})({
  // Scale applied to prevent dot misalignment in Safari
  transform: "scale(1)"
}), h4e = $e(f4e, {
  name: "MuiRadioButtonIcon"
})(Ct(({
  theme: e
}) => ({
  left: 0,
  position: "absolute",
  transform: "scale(0)",
  transition: e.transitions.create("transform", {
    easing: e.transitions.easing.easeIn,
    duration: e.transitions.duration.shortest
  }),
  variants: [{
    props: {
      checked: !0
    },
    style: {
      transform: "scale(1)",
      transition: e.transitions.create("transform", {
        easing: e.transitions.easing.easeOut,
        duration: e.transitions.duration.shortest
      })
    }
  }]
})));
function Hq(e) {
  const {
    checked: t = !1,
    classes: n = {},
    fontSize: r
  } = e, a = {
    ...e,
    checked: t
  };
  return /* @__PURE__ */ E.jsxs(p4e, {
    className: n.root,
    ownerState: a,
    children: [/* @__PURE__ */ E.jsx(m4e, {
      fontSize: r,
      className: n.background,
      ownerState: a
    }), /* @__PURE__ */ E.jsx(h4e, {
      fontSize: r,
      className: n.dot,
      ownerState: a
    })]
  });
}
const qq = /* @__PURE__ */ M.createContext(void 0);
function g4e() {
  return M.useContext(qq);
}
function v4e(e) {
  return _t("MuiRadio", e);
}
const sz = wt("MuiRadio", ["root", "checked", "disabled", "colorPrimary", "colorSecondary", "sizeSmall"]), y4e = (e) => {
  const {
    classes: t,
    color: n,
    size: r
  } = e, a = {
    root: ["root", `color${qe(n)}`, r !== "medium" && `size${qe(r)}`]
  };
  return {
    ...t,
    ...kt(a, v4e, t)
  };
}, b4e = $e(Bq, {
  shouldForwardProp: (e) => Xo(e) || e === "classes",
  name: "MuiRadio",
  slot: "Root",
  overridesResolver: (e, t) => {
    const {
      ownerState: n
    } = e;
    return [t.root, n.size !== "medium" && t[`size${qe(n.size)}`], t[`color${qe(n.color)}`]];
  }
})(Ct(({
  theme: e
}) => ({
  color: (e.vars || e).palette.text.secondary,
  [`&.${sz.disabled}`]: {
    color: (e.vars || e).palette.action.disabled
  },
  variants: [{
    props: {
      color: "default",
      disabled: !1,
      disableRipple: !1
    },
    style: {
      "&:hover": {
        backgroundColor: e.alpha((e.vars || e).palette.action.active, (e.vars || e).palette.action.hoverOpacity)
      }
    }
  }, ...Object.entries(e.palette).filter(Ko()).map(([t]) => ({
    props: {
      color: t,
      disabled: !1,
      disableRipple: !1
    },
    style: {
      "&:hover": {
        backgroundColor: e.alpha((e.vars || e).palette[t].main, (e.vars || e).palette.action.hoverOpacity)
      }
    }
  })), ...Object.entries(e.palette).filter(Ko()).map(([t]) => ({
    props: {
      color: t,
      disabled: !1
    },
    style: {
      [`&.${sz.checked}`]: {
        color: (e.vars || e).palette[t].main
      }
    }
  })), {
    // Should be last to override other colors
    props: {
      disableRipple: !1
    },
    style: {
      // Reset on touch devices, it doesn't add specificity
      "&:hover": {
        "@media (hover: none)": {
          backgroundColor: "transparent"
        }
      }
    }
  }]
})));
function w4e(e, t) {
  return typeof t == "object" && t !== null ? e === t : String(e) === String(t);
}
const x4e = /* @__PURE__ */ E.jsx(Hq, {
  checked: !0
}), S4e = /* @__PURE__ */ E.jsx(Hq, {}), k4e = /* @__PURE__ */ M.forwardRef(function(e, t) {
  const n = At({
    props: e,
    name: "MuiRadio"
  }), {
    checked: r,
    checkedIcon: a = x4e,
    color: s = "primary",
    icon: l = S4e,
    name: c,
    onChange: d,
    size: p = "medium",
    className: m,
    disabled: h,
    disableRipple: v = !1,
    slots: y = {},
    slotProps: w = {},
    inputProps: x,
    ...b
  } = n, k = Ll();
  let C = h;
  k && typeof C > "u" && (C = k.disabled), C ?? (C = !1);
  const _ = {
    ...n,
    disabled: C,
    disableRipple: v,
    color: s,
    size: p
  }, O = y4e(_), N = g4e();
  let R = r;
  const j = d3(d, N && N.onChange);
  let D = c;
  N && (typeof R > "u" && (R = w4e(N.value, n.value)), typeof D > "u" && (D = N.name));
  const $ = w.input ?? x, [z, B] = Hn("root", {
    ref: t,
    elementType: b4e,
    className: Ke(O.root, m),
    shouldForwardComponentProp: !0,
    externalForwardedProps: {
      slots: y,
      slotProps: w,
      ...b
    },
    getSlotProps: (P) => ({
      ...P,
      onChange: (W, ...I) => {
        P.onChange?.(W, ...I), j(W, ...I);
      }
    }),
    ownerState: _,
    additionalProps: {
      type: "radio",
      icon: /* @__PURE__ */ M.cloneElement(l, {
        fontSize: l.props.fontSize ?? p
      }),
      checkedIcon: /* @__PURE__ */ M.cloneElement(a, {
        fontSize: a.props.fontSize ?? p
      }),
      disabled: C,
      name: D,
      checked: R,
      slots: y,
      slotProps: {
        // Do not forward `slotProps.root` again because it's already handled by the `RootSlot` in this file.
        input: typeof $ == "function" ? $(_) : $
      }
    }
  });
  return /* @__PURE__ */ E.jsx(z, {
    ...B,
    classes: O
  });
});
function _4e(e) {
  return _t("MuiRadioGroup", e);
}
wt("MuiRadioGroup", ["root", "row", "error"]);
const E4e = (e) => {
  const {
    classes: t,
    row: n,
    error: r
  } = e;
  return kt({
    root: ["root", n && "row", r && "error"]
  }, _4e, t);
}, C4e = /* @__PURE__ */ M.forwardRef(function(e, t) {
  const {
    // private
    // eslint-disable-next-line react/prop-types
    actions: n,
    children: r,
    className: a,
    defaultValue: s,
    name: l,
    onChange: c,
    value: d,
    ...p
  } = e, m = M.useRef(null), h = E4e(e), [v, y] = Bx({
    controlled: d,
    default: s,
    name: "RadioGroup"
  });
  M.useImperativeHandle(n, () => ({
    focus: () => {
      let k = m.current.querySelector("input:not(:disabled):checked");
      k || (k = m.current.querySelector("input:not(:disabled)")), k && k.focus();
    }
  }), []);
  const w = no(t, m), x = eg(l), b = M.useMemo(() => ({
    name: x,
    onChange(k) {
      y(k.target.value), c && c(k, k.target.value);
    },
    value: v
  }), [x, c, y, v]);
  return /* @__PURE__ */ E.jsx(qq.Provider, {
    value: b,
    children: /* @__PURE__ */ E.jsx(Vq, {
      role: "radiogroup",
      ref: w,
      className: Ke(h.root, a),
      ...p,
      children: r
    })
  });
});
function O4e({ id: e, htmlName: t, options: n, value: r, required: a, disabled: s, readonly: l, label: c, hideLabel: d, onChange: p, onBlur: m, onFocus: h }) {
  var v;
  const { enumOptions: y, enumDisabled: w, emptyValue: x } = n, b = (N, R) => p(to(R, y, x)), k = ({ target: N }) => m(e, to(N && N.value, y, x)), C = ({ target: N }) => h(e, to(N && N.value, y, x)), _ = n ? n.inline : !1, O = (v = QA(r, y)) !== null && v !== void 0 ? v : null;
  return E.jsxs(E.Fragment, { children: [Am(E.jsx(EE, { required: a, htmlFor: e, children: c || void 0 }), d), E.jsx(C4e, { id: e, name: t || e, value: O, row: _, onChange: b, onBlur: k, onFocus: C, "aria-describedby": _i(e), children: Array.isArray(y) && y.map((N, R) => {
    const j = Array.isArray(w) && w.indexOf(N.value) !== -1;
    return E.jsx(E4, { control: E.jsx(k4e, { name: t || e, id: pE(e, R), color: "primary" }), label: N.label, value: String(R), disabled: s || j || l }, R);
  }) })] });
}
const M4e = {
  border: 0,
  clip: "rect(0 0 0 0)",
  height: "1px",
  margin: "-1px",
  overflow: "hidden",
  padding: 0,
  position: "absolute",
  whiteSpace: "nowrap",
  width: "1px"
};
function N4e(e, t, n = (r, a) => r === a) {
  return e.length === t.length && e.every((r, a) => n(r, t[a]));
}
const R4e = 2;
function th(e, t, n, r, a) {
  return n === 1 ? Math.min(e + t, a) : Math.max(e - t, r);
}
function Wq(e, t) {
  return e - t;
}
function lz(e, t) {
  const {
    index: n
  } = e.reduce((r, a, s) => {
    const l = Math.abs(t - a);
    return r === null || l < r.distance || l === r.distance ? {
      distance: l,
      index: s
    } : r;
  }, null) ?? {};
  return n;
}
function s0(e, t) {
  if (t.current !== void 0 && e.changedTouches) {
    const n = e;
    for (let r = 0; r < n.changedTouches.length; r += 1) {
      const a = n.changedTouches[r];
      if (a.identifier === t.current)
        return {
          x: a.clientX,
          y: a.clientY
        };
    }
    return !1;
  }
  return {
    x: e.clientX,
    y: e.clientY
  };
}
function L_(e, t, n) {
  return (e - t) * 100 / (n - t);
}
function A4e(e, t, n) {
  return (n - t) * e + t;
}
function j4e(e) {
  if (Math.abs(e) < 1) {
    const n = e.toExponential().split("e-"), r = n[0].split(".")[1];
    return (r ? r.length : 0) + parseInt(n[1], 10);
  }
  const t = e.toString().split(".")[1];
  return t ? t.length : 0;
}
function P4e(e, t, n) {
  const r = Math.round((e - n) / t) * t + n;
  return Number(r.toFixed(j4e(t)));
}
function uz({
  values: e,
  newValue: t,
  index: n
}) {
  const r = e.slice();
  return r[n] = t, r.sort(Wq);
}
function l0({
  sliderRef: e,
  activeIndex: t,
  setActive: n
}) {
  const r = wa(e.current);
  (!e.current?.contains(r.activeElement) || Number(r?.activeElement?.getAttribute("data-index")) !== t) && e.current?.querySelector(`[type="range"][data-index="${t}"]`).focus(), n && n(t);
}
function u0(e, t) {
  return typeof e == "number" && typeof t == "number" ? e === t : typeof e == "object" && typeof t == "object" ? N4e(e, t) : !1;
}
const D4e = {
  horizontal: {
    offset: (e) => ({
      left: `${e}%`
    }),
    leap: (e) => ({
      width: `${e}%`
    })
  },
  "horizontal-reverse": {
    offset: (e) => ({
      right: `${e}%`
    }),
    leap: (e) => ({
      width: `${e}%`
    })
  },
  vertical: {
    offset: (e) => ({
      bottom: `${e}%`
    }),
    leap: (e) => ({
      height: `${e}%`
    })
  }
}, $4e = (e) => e;
let c0;
function cz() {
  return c0 === void 0 && (typeof CSS < "u" && typeof CSS.supports == "function" ? c0 = CSS.supports("touch-action", "none") : c0 = !0), c0;
}
function T4e(e) {
  const {
    "aria-labelledby": t,
    defaultValue: n,
    disabled: r = !1,
    disableSwap: a = !1,
    isRtl: s = !1,
    marks: l = !1,
    max: c = 100,
    min: d = 0,
    name: p,
    onChange: m,
    onChangeCommitted: h,
    orientation: v = "horizontal",
    rootRef: y,
    scale: w = $4e,
    step: x = 1,
    shiftStep: b = 10,
    tabIndex: k,
    value: C
  } = e, _ = M.useRef(void 0), [O, N] = M.useState(-1), [R, j] = M.useState(-1), [D, $] = M.useState(!1), z = M.useRef(0), B = M.useRef(null), [P, W] = Bx({
    controlled: C,
    default: n ?? d,
    name: "Slider"
  }), I = m && ((Ce, Me, he) => {
    const ye = Ce.nativeEvent || Ce, Ee = new ye.constructor(ye.type, ye);
    Object.defineProperty(Ee, "target", {
      writable: !0,
      value: {
        value: Me,
        name: p
      }
    }), B.current = Me, m(Ee, Me, he);
  }), G = Array.isArray(P);
  let L = G ? P.slice().sort(Wq) : [P];
  L = L.map((Ce) => Ce == null ? d : oh(Ce, d, c));
  const K = l === !0 && x !== null ? [...Array(Math.floor((c - d) / x) + 1)].map((Ce, Me) => ({
    value: d + x * Me
  })) : l || [], q = K.map((Ce) => Ce.value), [Z, V] = M.useState(-1), F = M.useRef(null), X = no(y, F), U = (Ce) => (Me) => {
    const he = Number(Me.currentTarget.getAttribute("data-index"));
    K0(Me.target) && V(he), j(he), Ce?.onFocus?.(Me);
  }, H = (Ce) => (Me) => {
    K0(Me.target) || V(-1), j(-1), Ce?.onBlur?.(Me);
  }, Q = (Ce, Me) => {
    const he = Number(Ce.currentTarget.getAttribute("data-index")), ye = L[he], Ee = q.indexOf(ye);
    let Le = Me;
    if (K && x == null) {
      const ze = q[q.length - 1];
      Le >= ze ? Le = ze : Le <= q[0] ? Le = q[0] : Le = Le < ye ? q[Ee - 1] : q[Ee + 1];
    }
    if (Le = oh(Le, d, c), G) {
      a && (Le = oh(Le, L[he - 1] || -1 / 0, L[he + 1] || 1 / 0));
      const ze = Le;
      Le = uz({
        values: L,
        newValue: Le,
        index: he
      });
      let It = he;
      a || (It = Le.indexOf(ze)), l0({
        sliderRef: F,
        activeIndex: It
      });
    }
    W(Le), V(he), I && !u0(Le, P) && I(Ce, Le, he), h && h(Ce, B.current ?? Le);
  }, re = (Ce) => (Me) => {
    if (["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight", "PageUp", "PageDown", "Home", "End"].includes(Me.key)) {
      Me.preventDefault();
      const he = Number(Me.currentTarget.getAttribute("data-index")), ye = L[he];
      let Ee = null;
      if (x != null) {
        const Le = Me.shiftKey ? b : x;
        switch (Me.key) {
          case "ArrowUp":
            Ee = th(ye, Le, 1, d, c);
            break;
          case "ArrowRight":
            Ee = th(ye, Le, s ? -1 : 1, d, c);
            break;
          case "ArrowDown":
            Ee = th(ye, Le, -1, d, c);
            break;
          case "ArrowLeft":
            Ee = th(ye, Le, s ? 1 : -1, d, c);
            break;
          case "PageUp":
            Ee = th(ye, b, 1, d, c);
            break;
          case "PageDown":
            Ee = th(ye, b, -1, d, c);
            break;
          case "Home":
            Ee = d;
            break;
          case "End":
            Ee = c;
            break;
        }
      } else if (K) {
        const Le = q[q.length - 1], ze = q.indexOf(ye), It = [s ? "ArrowRight" : "ArrowLeft", "ArrowDown", "PageDown", "Home"], zt = [s ? "ArrowLeft" : "ArrowRight", "ArrowUp", "PageUp", "End"];
        It.includes(Me.key) ? ze === 0 ? Ee = q[0] : Ee = q[ze - 1] : zt.includes(Me.key) && (ze === q.length - 1 ? Ee = Le : Ee = q[ze + 1]);
      }
      Ee != null && Q(Me, Ee);
    }
    Ce?.onKeyDown?.(Me);
  };
  zs(() => {
    r && F.current.contains(document.activeElement) && document.activeElement?.blur();
  }, [r]), r && O !== -1 && N(-1), r && Z !== -1 && V(-1);
  const de = (Ce) => (Me) => {
    Ce.onChange?.(Me), Q(Me, Me.target.valueAsNumber);
  }, le = M.useRef(void 0);
  let me = v;
  s && v === "horizontal" && (me += "-reverse");
  const ve = ({
    finger: Ce,
    move: Me = !1
  }) => {
    const {
      current: he
    } = F, {
      width: ye,
      height: Ee,
      bottom: Le,
      left: ze
    } = he.getBoundingClientRect();
    let It;
    me.startsWith("vertical") ? It = (Le - Ce.y) / Ee : It = (Ce.x - ze) / ye, me.includes("-reverse") && (It = 1 - It);
    let zt;
    if (zt = A4e(It, d, c), x)
      zt = P4e(zt, x, d);
    else {
      const Ot = lz(q, zt);
      zt = q[Ot];
    }
    zt = oh(zt, d, c);
    let Wt = 0;
    if (G) {
      Me ? Wt = le.current : Wt = lz(L, zt), a && (zt = oh(zt, L[Wt - 1] || -1 / 0, L[Wt + 1] || 1 / 0));
      const Ot = zt;
      zt = uz({
        values: L,
        newValue: zt,
        index: Wt
      }), a && Me || (Wt = zt.indexOf(Ot), le.current = Wt);
    }
    return {
      newValue: zt,
      activeIndex: Wt
    };
  }, ae = Sl((Ce) => {
    const Me = s0(Ce, _);
    if (!Me)
      return;
    if (z.current += 1, Ce.type === "mousemove" && Ce.buttons === 0) {
      se(Ce);
      return;
    }
    const {
      newValue: he,
      activeIndex: ye
    } = ve({
      finger: Me,
      move: !0
    });
    l0({
      sliderRef: F,
      activeIndex: ye,
      setActive: N
    }), W(he), !D && z.current > R4e && $(!0), I && !u0(he, P) && I(Ce, he, ye);
  }), se = Sl((Ce) => {
    const Me = s0(Ce, _);
    if ($(!1), !Me)
      return;
    const {
      newValue: he
    } = ve({
      finger: Me,
      move: !0
    });
    N(-1), Ce.type === "touchend" && j(-1), h && h(Ce, B.current ?? he), _.current = void 0, ge();
  }), pe = Sl((Ce) => {
    if (r)
      return;
    cz() || Ce.preventDefault();
    const Me = Ce.changedTouches[0];
    Me != null && (_.current = Me.identifier);
    const he = s0(Ce, _);
    if (he !== !1) {
      const {
        newValue: Ee,
        activeIndex: Le
      } = ve({
        finger: he
      });
      l0({
        sliderRef: F,
        activeIndex: Le,
        setActive: N
      }), W(Ee), I && !u0(Ee, P) && I(Ce, Ee, Le);
    }
    z.current = 0;
    const ye = wa(F.current);
    ye.addEventListener("touchmove", ae, {
      passive: !0
    }), ye.addEventListener("touchend", se, {
      passive: !0
    });
  }), ge = M.useCallback(() => {
    const Ce = wa(F.current);
    Ce.removeEventListener("mousemove", ae), Ce.removeEventListener("mouseup", se), Ce.removeEventListener("touchmove", ae), Ce.removeEventListener("touchend", se);
  }, [se, ae]);
  M.useEffect(() => {
    const {
      current: Ce
    } = F;
    return Ce.addEventListener("touchstart", pe, {
      passive: cz()
    }), () => {
      Ce.removeEventListener("touchstart", pe), ge();
    };
  }, [ge, pe]), M.useEffect(() => {
    r && ge();
  }, [r, ge]);
  const xe = (Ce) => (Me) => {
    if (Ce.onMouseDown?.(Me), r || Me.defaultPrevented || Me.button !== 0)
      return;
    Me.preventDefault();
    const he = s0(Me, _);
    if (he !== !1) {
      const {
        newValue: Ee,
        activeIndex: Le
      } = ve({
        finger: he
      });
      l0({
        sliderRef: F,
        activeIndex: Le,
        setActive: N
      }), W(Ee), I && !u0(Ee, P) && I(Me, Ee, Le);
    }
    z.current = 0;
    const ye = wa(F.current);
    ye.addEventListener("mousemove", ae, {
      passive: !0
    }), ye.addEventListener("mouseup", se);
  }, _e = L_(G ? L[0] : d, d, c), We = L_(L[L.length - 1], d, c) - _e, Xe = (Ce = {}) => {
    const Me = qw(Ce), he = {
      onMouseDown: xe(Me || {})
    }, ye = {
      ...Me,
      ...he
    };
    return {
      ...Ce,
      ref: X,
      ...ye
    };
  }, et = (Ce) => (Me) => {
    Ce.onMouseOver?.(Me);
    const he = Number(Me.currentTarget.getAttribute("data-index"));
    j(he);
  }, tt = (Ce) => (Me) => {
    Ce.onMouseLeave?.(Me), j(-1);
  }, je = (Ce = {}) => {
    const Me = qw(Ce), he = {
      onMouseOver: et(Me || {}),
      onMouseLeave: tt(Me || {})
    };
    return {
      ...Ce,
      ...Me,
      ...he
    };
  }, an = (Ce) => ({
    // So the non active thumb doesn't show its label on hover.
    pointerEvents: O !== -1 && O !== Ce ? "none" : void 0
  });
  let dt;
  return v === "vertical" && (dt = s ? "vertical-rl" : "vertical-lr"), {
    active: O,
    axis: me,
    axisProps: D4e,
    dragging: D,
    focusedThumbIndex: Z,
    getHiddenInputProps: (Ce = {}) => {
      const Me = qw(Ce), he = {
        onChange: de(Me || {}),
        onFocus: U(Me || {}),
        onBlur: H(Me || {}),
        onKeyDown: re(Me || {})
      }, ye = {
        ...Me,
        ...he
      };
      return {
        tabIndex: k,
        "aria-labelledby": t,
        "aria-orientation": v,
        "aria-valuemax": w(c),
        "aria-valuemin": w(d),
        name: p,
        type: "range",
        min: e.min,
        max: e.max,
        step: e.step === null && e.marks ? "any" : e.step ?? void 0,
        disabled: r,
        ...Ce,
        ...ye,
        style: {
          ...M4e,
          direction: s ? "rtl" : "ltr",
          // So that VoiceOver's focus indicator matches the thumb's dimensions
          width: "100%",
          height: "100%",
          writingMode: dt
        }
      };
    },
    getRootProps: Xe,
    getThumbProps: je,
    marks: K,
    open: R,
    range: G,
    rootRef: X,
    trackLeap: We,
    trackOffset: _e,
    values: L,
    getThumbStyle: an
  };
}
const L4e = (e) => !e || !kl(e);
function I4e(e) {
  return _t("MuiSlider", e);
}
const Ai = wt("MuiSlider", ["root", "active", "colorPrimary", "colorSecondary", "colorError", "colorInfo", "colorSuccess", "colorWarning", "disabled", "dragging", "focusVisible", "mark", "markActive", "marked", "markLabel", "markLabelActive", "rail", "sizeSmall", "thumb", "thumbColorPrimary", "thumbColorSecondary", "thumbColorError", "thumbColorSuccess", "thumbColorInfo", "thumbColorWarning", "track", "trackInverted", "trackFalse", "thumbSizeSmall", "valueLabel", "valueLabelOpen", "valueLabelCircle", "valueLabelLabel", "vertical"]), z4e = (e) => {
  const {
    open: t
  } = e;
  return {
    offset: Ke(t && Ai.valueLabelOpen),
    circle: Ai.valueLabelCircle,
    label: Ai.valueLabelLabel
  };
};
function F4e(e) {
  const {
    children: t,
    className: n,
    value: r
  } = e, a = z4e(e);
  return t ? /* @__PURE__ */ M.cloneElement(t, {
    className: t.props.className
  }, /* @__PURE__ */ E.jsxs(M.Fragment, {
    children: [t.props.children, /* @__PURE__ */ E.jsx("span", {
      className: Ke(a.offset, n),
      "aria-hidden": !0,
      children: /* @__PURE__ */ E.jsx("span", {
        className: a.circle,
        children: /* @__PURE__ */ E.jsx("span", {
          className: a.label,
          children: r
        })
      })
    })]
  })) : null;
}
function dz(e) {
  return e;
}
const B4e = $e("span", {
  name: "MuiSlider",
  slot: "Root",
  overridesResolver: (e, t) => {
    const {
      ownerState: n
    } = e;
    return [t.root, t[`color${qe(n.color)}`], n.size !== "medium" && t[`size${qe(n.size)}`], n.marked && t.marked, n.orientation === "vertical" && t.vertical, n.track === "inverted" && t.trackInverted, n.track === !1 && t.trackFalse];
  }
})(Ct(({
  theme: e
}) => ({
  borderRadius: 12,
  boxSizing: "content-box",
  display: "inline-block",
  position: "relative",
  cursor: "pointer",
  touchAction: "none",
  WebkitTapHighlightColor: "transparent",
  "@media print": {
    colorAdjust: "exact"
  },
  [`&.${Ai.disabled}`]: {
    pointerEvents: "none",
    cursor: "default",
    color: (e.vars || e).palette.grey[400]
  },
  [`&.${Ai.dragging}`]: {
    [`& .${Ai.thumb}, & .${Ai.track}`]: {
      transition: "none"
    }
  },
  variants: [...Object.entries(e.palette).filter(Ko()).map(([t]) => ({
    props: {
      color: t
    },
    style: {
      color: (e.vars || e).palette[t].main
    }
  })), {
    props: {
      orientation: "horizontal"
    },
    style: {
      height: 4,
      width: "100%",
      padding: "13px 0",
      // The primary input mechanism of the device includes a pointing device of limited accuracy.
      "@media (pointer: coarse)": {
        // Reach 42px touch target, about ~8mm on screen.
        padding: "20px 0"
      }
    }
  }, {
    props: {
      orientation: "horizontal",
      size: "small"
    },
    style: {
      height: 2
    }
  }, {
    props: {
      orientation: "horizontal",
      marked: !0
    },
    style: {
      marginBottom: 20
    }
  }, {
    props: {
      orientation: "vertical"
    },
    style: {
      height: "100%",
      width: 4,
      padding: "0 13px",
      // The primary input mechanism of the device includes a pointing device of limited accuracy.
      "@media (pointer: coarse)": {
        // Reach 42px touch target, about ~8mm on screen.
        padding: "0 20px"
      }
    }
  }, {
    props: {
      orientation: "vertical",
      size: "small"
    },
    style: {
      width: 2
    }
  }, {
    props: {
      orientation: "vertical",
      marked: !0
    },
    style: {
      marginRight: 44
    }
  }]
}))), U4e = $e("span", {
  name: "MuiSlider",
  slot: "Rail"
})({
  display: "block",
  position: "absolute",
  borderRadius: "inherit",
  backgroundColor: "currentColor",
  opacity: 0.38,
  variants: [{
    props: {
      orientation: "horizontal"
    },
    style: {
      width: "100%",
      height: "inherit",
      top: "50%",
      transform: "translateY(-50%)"
    }
  }, {
    props: {
      orientation: "vertical"
    },
    style: {
      height: "100%",
      width: "inherit",
      left: "50%",
      transform: "translateX(-50%)"
    }
  }, {
    props: {
      track: "inverted"
    },
    style: {
      opacity: 1
    }
  }]
}), V4e = $e("span", {
  name: "MuiSlider",
  slot: "Track"
})(Ct(({
  theme: e
}) => ({
  display: "block",
  position: "absolute",
  borderRadius: "inherit",
  border: "1px solid currentColor",
  backgroundColor: "currentColor",
  transition: e.transitions.create(["left", "width", "bottom", "height"], {
    duration: e.transitions.duration.shortest
  }),
  variants: [{
    props: {
      size: "small"
    },
    style: {
      border: "none"
    }
  }, {
    props: {
      orientation: "horizontal"
    },
    style: {
      height: "inherit",
      top: "50%",
      transform: "translateY(-50%)"
    }
  }, {
    props: {
      orientation: "vertical"
    },
    style: {
      width: "inherit",
      left: "50%",
      transform: "translateX(-50%)"
    }
  }, {
    props: {
      track: !1
    },
    style: {
      display: "none"
    }
  }, ...Object.entries(e.palette).filter(Ko()).map(([t]) => ({
    props: {
      color: t,
      track: "inverted"
    },
    style: {
      ...e.vars ? {
        backgroundColor: e.vars.palette.Slider[`${t}Track`],
        borderColor: e.vars.palette.Slider[`${t}Track`]
      } : {
        backgroundColor: e.lighten(e.palette[t].main, 0.62),
        borderColor: e.lighten(e.palette[t].main, 0.62),
        ...e.applyStyles("dark", {
          backgroundColor: e.darken(e.palette[t].main, 0.5)
        }),
        ...e.applyStyles("dark", {
          borderColor: e.darken(e.palette[t].main, 0.5)
        })
      }
    }
  }))]
}))), H4e = $e("span", {
  name: "MuiSlider",
  slot: "Thumb",
  overridesResolver: (e, t) => {
    const {
      ownerState: n
    } = e;
    return [t.thumb, t[`thumbColor${qe(n.color)}`], n.size !== "medium" && t[`thumbSize${qe(n.size)}`]];
  }
})(Ct(({
  theme: e
}) => ({
  position: "absolute",
  width: 20,
  height: 20,
  boxSizing: "border-box",
  borderRadius: "50%",
  outline: 0,
  backgroundColor: "currentColor",
  display: "flex",
  alignItems: "center",
  justifyContent: "center",
  transition: e.transitions.create(["box-shadow", "left", "bottom"], {
    duration: e.transitions.duration.shortest
  }),
  "&::before": {
    position: "absolute",
    content: '""',
    borderRadius: "inherit",
    width: "100%",
    height: "100%",
    boxShadow: (e.vars || e).shadows[2]
  },
  "&::after": {
    position: "absolute",
    content: '""',
    borderRadius: "50%",
    // 42px is the hit target
    width: 42,
    height: 42,
    top: "50%",
    left: "50%",
    transform: "translate(-50%, -50%)"
  },
  [`&.${Ai.disabled}`]: {
    "&:hover": {
      boxShadow: "none"
    }
  },
  variants: [{
    props: {
      size: "small"
    },
    style: {
      width: 12,
      height: 12,
      "&::before": {
        boxShadow: "none"
      }
    }
  }, {
    props: {
      orientation: "horizontal"
    },
    style: {
      top: "50%",
      transform: "translate(-50%, -50%)"
    }
  }, {
    props: {
      orientation: "vertical"
    },
    style: {
      left: "50%",
      transform: "translate(-50%, 50%)"
    }
  }, ...Object.entries(e.palette).filter(Ko()).map(([t]) => ({
    props: {
      color: t
    },
    style: {
      [`&:hover, &.${Ai.focusVisible}`]: {
        boxShadow: `0px 0px 0px 8px ${e.alpha((e.vars || e).palette[t].main, 0.16)}`,
        "@media (hover: none)": {
          boxShadow: "none"
        }
      },
      [`&.${Ai.active}`]: {
        boxShadow: `0px 0px 0px 14px ${e.alpha((e.vars || e).palette[t].main, 0.16)}`
      }
    }
  }))]
}))), q4e = $e(F4e, {
  name: "MuiSlider",
  slot: "ValueLabel"
})(Ct(({
  theme: e
}) => ({
  zIndex: 1,
  whiteSpace: "nowrap",
  ...e.typography.body2,
  fontWeight: 500,
  transition: e.transitions.create(["transform"], {
    duration: e.transitions.duration.shortest
  }),
  position: "absolute",
  backgroundColor: (e.vars || e).palette.grey[600],
  borderRadius: 2,
  color: (e.vars || e).palette.common.white,
  display: "flex",
  alignItems: "center",
  justifyContent: "center",
  padding: "0.25rem 0.75rem",
  variants: [{
    props: {
      orientation: "horizontal"
    },
    style: {
      transform: "translateY(-100%) scale(0)",
      top: "-10px",
      transformOrigin: "bottom center",
      "&::before": {
        position: "absolute",
        content: '""',
        width: 8,
        height: 8,
        transform: "translate(-50%, 50%) rotate(45deg)",
        backgroundColor: "inherit",
        bottom: 0,
        left: "50%"
      },
      [`&.${Ai.valueLabelOpen}`]: {
        transform: "translateY(-100%) scale(1)"
      }
    }
  }, {
    props: {
      orientation: "vertical"
    },
    style: {
      transform: "translateY(-50%) scale(0)",
      right: "30px",
      top: "50%",
      transformOrigin: "right center",
      "&::before": {
        position: "absolute",
        content: '""',
        width: 8,
        height: 8,
        transform: "translate(-50%, -50%) rotate(45deg)",
        backgroundColor: "inherit",
        right: -8,
        top: "50%"
      },
      [`&.${Ai.valueLabelOpen}`]: {
        transform: "translateY(-50%) scale(1)"
      }
    }
  }, {
    props: {
      size: "small"
    },
    style: {
      fontSize: e.typography.pxToRem(12),
      padding: "0.25rem 0.5rem"
    }
  }, {
    props: {
      orientation: "vertical",
      size: "small"
    },
    style: {
      right: "20px"
    }
  }]
}))), W4e = $e("span", {
  name: "MuiSlider",
  slot: "Mark",
  shouldForwardProp: (e) => c2(e) && e !== "markActive",
  overridesResolver: (e, t) => {
    const {
      markActive: n
    } = e;
    return [t.mark, n && t.markActive];
  }
})(Ct(({
  theme: e
}) => ({
  position: "absolute",
  width: 2,
  height: 2,
  borderRadius: 1,
  backgroundColor: "currentColor",
  variants: [{
    props: {
      orientation: "horizontal"
    },
    style: {
      top: "50%",
      transform: "translate(-1px, -50%)"
    }
  }, {
    props: {
      orientation: "vertical"
    },
    style: {
      left: "50%",
      transform: "translate(-50%, 1px)"
    }
  }, {
    props: {
      markActive: !0
    },
    style: {
      backgroundColor: (e.vars || e).palette.background.paper,
      opacity: 0.8
    }
  }]
}))), G4e = $e("span", {
  name: "MuiSlider",
  slot: "MarkLabel",
  shouldForwardProp: (e) => c2(e) && e !== "markLabelActive"
})(Ct(({
  theme: e
}) => ({
  ...e.typography.body2,
  color: (e.vars || e).palette.text.secondary,
  position: "absolute",
  whiteSpace: "nowrap",
  variants: [{
    props: {
      orientation: "horizontal"
    },
    style: {
      top: 30,
      transform: "translateX(-50%)",
      "@media (pointer: coarse)": {
        top: 40
      }
    }
  }, {
    props: {
      orientation: "vertical"
    },
    style: {
      left: 36,
      transform: "translateY(50%)",
      "@media (pointer: coarse)": {
        left: 44
      }
    }
  }, {
    props: {
      markLabelActive: !0
    },
    style: {
      color: (e.vars || e).palette.text.primary
    }
  }]
}))), K4e = (e) => {
  const {
    disabled: t,
    dragging: n,
    marked: r,
    orientation: a,
    track: s,
    classes: l,
    color: c,
    size: d
  } = e, p = {
    root: ["root", t && "disabled", n && "dragging", r && "marked", a === "vertical" && "vertical", s === "inverted" && "trackInverted", s === !1 && "trackFalse", c && `color${qe(c)}`, d && `size${qe(d)}`],
    rail: ["rail"],
    track: ["track"],
    mark: ["mark"],
    markActive: ["markActive"],
    markLabel: ["markLabel"],
    markLabelActive: ["markLabelActive"],
    valueLabel: ["valueLabel"],
    thumb: ["thumb", t && "disabled", d && `thumbSize${qe(d)}`, c && `thumbColor${qe(c)}`],
    active: ["active"],
    disabled: ["disabled"],
    focusVisible: ["focusVisible"]
  };
  return kt(p, I4e, l);
}, X4e = ({
  children: e
}) => e, Y4e = /* @__PURE__ */ M.forwardRef(function(e, t) {
  const n = At({
    props: e,
    name: "MuiSlider"
  }), r = Z1(), {
    "aria-label": a,
    "aria-valuetext": s,
    "aria-labelledby": l,
    // eslint-disable-next-line react/prop-types
    component: c = "span",
    components: d = {},
    componentsProps: p = {},
    color: m = "primary",
    classes: h,
    className: v,
    disableSwap: y = !1,
    disabled: w = !1,
    getAriaLabel: x,
    getAriaValueText: b,
    marks: k = !1,
    max: C = 100,
    min: _ = 0,
    name: O,
    onChange: N,
    onChangeCommitted: R,
    orientation: j = "horizontal",
    shiftStep: D = 10,
    size: $ = "medium",
    step: z = 1,
    scale: B = dz,
    slotProps: P,
    slots: W,
    tabIndex: I,
    track: G = "normal",
    value: L,
    valueLabelDisplay: K = "off",
    valueLabelFormat: q = dz,
    ...Z
  } = n, V = {
    ...n,
    isRtl: r,
    max: C,
    min: _,
    classes: h,
    disabled: w,
    disableSwap: y,
    orientation: j,
    marks: k,
    color: m,
    size: $,
    step: z,
    shiftStep: D,
    scale: B,
    track: G,
    valueLabelDisplay: K,
    valueLabelFormat: q
  }, {
    axisProps: F,
    getRootProps: X,
    getHiddenInputProps: U,
    getThumbProps: H,
    open: Q,
    active: re,
    axis: de,
    focusedThumbIndex: le,
    range: me,
    dragging: ve,
    marks: ae,
    values: se,
    trackOffset: pe,
    trackLeap: ge,
    getThumbStyle: xe
  } = T4e({
    ...V,
    rootRef: t
  });
  V.marked = ae.length > 0 && ae.some((dn) => dn.label), V.dragging = ve, V.focusedThumbIndex = le;
  const _e = K4e(V), We = W?.root ?? d.Root ?? B4e, Xe = W?.rail ?? d.Rail ?? U4e, et = W?.track ?? d.Track ?? V4e, tt = W?.thumb ?? d.Thumb ?? H4e, je = W?.valueLabel ?? d.ValueLabel ?? q4e, an = W?.mark ?? d.Mark ?? W4e, dt = W?.markLabel ?? d.MarkLabel ?? G4e, Ce = W?.input ?? d.Input ?? "input", Me = P?.root ?? p.root, he = P?.rail ?? p.rail, ye = P?.track ?? p.track, Ee = P?.thumb ?? p.thumb, Le = P?.valueLabel ?? p.valueLabel, ze = P?.mark ?? p.mark, It = P?.markLabel ?? p.markLabel, zt = P?.input ?? p.input, Wt = lc({
    elementType: We,
    getSlotProps: X,
    externalSlotProps: Me,
    externalForwardedProps: Z,
    additionalProps: {
      ...L4e(We) && {
        as: c
      }
    },
    ownerState: {
      ...V,
      ...Me?.ownerState
    },
    className: [_e.root, v]
  }), Ot = lc({
    elementType: Xe,
    externalSlotProps: he,
    ownerState: V,
    className: _e.rail
  }), bn = lc({
    elementType: et,
    externalSlotProps: ye,
    additionalProps: {
      style: {
        ...F[de].offset(pe),
        ...F[de].leap(ge)
      }
    },
    ownerState: {
      ...V,
      ...ye?.ownerState
    },
    className: _e.track
  }), Re = lc({
    elementType: tt,
    getSlotProps: H,
    externalSlotProps: Ee,
    ownerState: {
      ...V,
      ...Ee?.ownerState
    },
    className: _e.thumb
  }), Ft = lc({
    elementType: je,
    externalSlotProps: Le,
    ownerState: {
      ...V,
      ...Le?.ownerState
    },
    className: _e.valueLabel
  }), Xt = lc({
    elementType: an,
    externalSlotProps: ze,
    ownerState: V,
    className: _e.mark
  }), To = lc({
    elementType: dt,
    externalSlotProps: It,
    ownerState: V,
    className: _e.markLabel
  }), Lo = lc({
    elementType: Ce,
    getSlotProps: U,
    externalSlotProps: zt,
    ownerState: V
  });
  return /* @__PURE__ */ E.jsxs(We, {
    ...Wt,
    children: [/* @__PURE__ */ E.jsx(Xe, {
      ...Ot
    }), /* @__PURE__ */ E.jsx(et, {
      ...bn
    }), ae.filter((dn) => dn.value >= _ && dn.value <= C).map((dn, kn) => {
      const wr = L_(dn.value, _, C), Io = F[de].offset(wr);
      let pr;
      return G === !1 ? pr = se.includes(dn.value) : pr = G === "normal" && (me ? dn.value >= se[0] && dn.value <= se[se.length - 1] : dn.value <= se[0]) || G === "inverted" && (me ? dn.value <= se[0] || dn.value >= se[se.length - 1] : dn.value >= se[0]), /* @__PURE__ */ E.jsxs(M.Fragment, {
        children: [/* @__PURE__ */ E.jsx(an, {
          "data-index": kn,
          ...Xt,
          ...!kl(an) && {
            markActive: pr
          },
          style: {
            ...Io,
            ...Xt.style
          },
          className: Ke(Xt.className, pr && _e.markActive)
        }), dn.label != null ? /* @__PURE__ */ E.jsx(dt, {
          "aria-hidden": !0,
          "data-index": kn,
          ...To,
          ...!kl(dt) && {
            markLabelActive: pr
          },
          style: {
            ...Io,
            ...To.style
          },
          className: Ke(_e.markLabel, To.className, pr && _e.markLabelActive),
          children: dn.label
        }) : null]
      }, kn);
    }), se.map((dn, kn) => {
      const wr = L_(dn, _, C), Io = F[de].offset(wr), pr = K === "off" ? X4e : je;
      return (
        /* TODO v6: Change component structure. It will help in avoiding the complicated React.cloneElement API added in SliderValueLabel component. Should be: Thumb -> Input, ValueLabel. Follow Joy UI's Slider structure. */
        /* @__PURE__ */ E.jsx(pr, {
          ...!kl(pr) && {
            valueLabelFormat: q,
            valueLabelDisplay: K,
            value: typeof q == "function" ? q(B(dn), kn) : q,
            index: kn,
            open: Q === kn || re === kn || K === "on",
            disabled: w
          },
          ...Ft,
          children: /* @__PURE__ */ E.jsx(tt, {
            "data-index": kn,
            ...Re,
            className: Ke(_e.thumb, Re.className, re === kn && _e.active, le === kn && _e.focusVisible),
            style: {
              ...Io,
              ...xe(kn),
              ...Re.style
            },
            children: /* @__PURE__ */ E.jsx(Ce, {
              "data-index": kn,
              "aria-label": x ? x(kn) : a,
              "aria-valuenow": B(dn),
              "aria-labelledby": l,
              "aria-valuetext": b ? b(B(dn), kn) : s,
              value: se[kn],
              ...Lo
            })
          })
        }, kn)
      );
    })]
  });
});
function Q4e(e) {
  const { value: t, readonly: n, disabled: r, onBlur: a, onFocus: s, options: l, schema: c, onChange: d, required: p, label: m, hideLabel: h, id: v } = e, y = { value: t, label: m, id: v, name: v, ...HH(c) }, w = (k, C) => {
    d(C ?? l.emptyValue);
  }, x = ({ target: k }) => a(v, k && k.value), b = ({ target: k }) => s(v, k && k.value);
  return E.jsxs(E.Fragment, { children: [Am(E.jsx(EE, { required: p, htmlFor: v, children: m || void 0 }), h), E.jsx(Y4e, { disabled: r || n, onChange: w, onBlur: x, onFocus: b, valueLabelDisplay: "auto", ...y, "aria-describedby": _i(v) })] });
}
function J4e(e) {
  return _t("MuiMenuItem", e);
}
const kw = wt("MuiMenuItem", ["root", "focusVisible", "dense", "disabled", "divider", "gutters", "selected"]), Z4e = (e, t) => {
  const {
    ownerState: n
  } = e;
  return [t.root, n.dense && t.dense, n.divider && t.divider, !n.disableGutters && t.gutters];
}, eje = (e) => {
  const {
    disabled: t,
    dense: n,
    divider: r,
    disableGutters: a,
    selected: s,
    classes: l
  } = e, c = kt({
    root: ["root", n && "dense", t && "disabled", !a && "gutters", r && "divider", s && "selected"]
  }, J4e, l);
  return {
    ...l,
    ...c
  };
}, tje = $e(nS, {
  shouldForwardProp: (e) => Xo(e) || e === "classes",
  name: "MuiMenuItem",
  slot: "Root",
  overridesResolver: Z4e
})(Ct(({
  theme: e
}) => ({
  ...e.typography.body1,
  display: "flex",
  justifyContent: "flex-start",
  alignItems: "center",
  position: "relative",
  textDecoration: "none",
  minHeight: 48,
  paddingTop: 6,
  paddingBottom: 6,
  boxSizing: "border-box",
  whiteSpace: "nowrap",
  "&:hover": {
    textDecoration: "none",
    backgroundColor: (e.vars || e).palette.action.hover,
    // Reset on touch devices, it doesn't add specificity
    "@media (hover: none)": {
      backgroundColor: "transparent"
    }
  },
  [`&.${kw.selected}`]: {
    backgroundColor: e.alpha((e.vars || e).palette.primary.main, (e.vars || e).palette.action.selectedOpacity),
    [`&.${kw.focusVisible}`]: {
      backgroundColor: e.alpha((e.vars || e).palette.primary.main, `${(e.vars || e).palette.action.selectedOpacity} + ${(e.vars || e).palette.action.focusOpacity}`)
    }
  },
  [`&.${kw.selected}:hover`]: {
    backgroundColor: e.alpha((e.vars || e).palette.primary.main, `${(e.vars || e).palette.action.selectedOpacity} + ${(e.vars || e).palette.action.hoverOpacity}`),
    // Reset on touch devices, it doesn't add specificity
    "@media (hover: none)": {
      backgroundColor: e.alpha((e.vars || e).palette.primary.main, (e.vars || e).palette.action.selectedOpacity)
    }
  },
  [`&.${kw.focusVisible}`]: {
    backgroundColor: (e.vars || e).palette.action.focus
  },
  [`&.${kw.disabled}`]: {
    opacity: (e.vars || e).palette.action.disabledOpacity
  },
  [`& + .${iz.root}`]: {
    marginTop: e.spacing(1),
    marginBottom: e.spacing(1)
  },
  [`& + .${iz.inset}`]: {
    marginLeft: 52
  },
  [`& .${hh.root}`]: {
    marginTop: 0,
    marginBottom: 0
  },
  [`& .${hh.inset}`]: {
    paddingLeft: 36
  },
  [`& .${oz.root}`]: {
    minWidth: 36
  },
  variants: [{
    props: ({
      ownerState: t
    }) => !t.disableGutters,
    style: {
      paddingLeft: 16,
      paddingRight: 16
    }
  }, {
    props: ({
      ownerState: t
    }) => t.divider,
    style: {
      borderBottom: `1px solid ${(e.vars || e).palette.divider}`,
      backgroundClip: "padding-box"
    }
  }, {
    props: ({
      ownerState: t
    }) => !t.dense,
    style: {
      [e.breakpoints.up("sm")]: {
        minHeight: "auto"
      }
    }
  }, {
    props: ({
      ownerState: t
    }) => t.dense,
    style: {
      minHeight: 32,
      // https://m2.material.io/components/menus#specs > Dense
      paddingTop: 4,
      paddingBottom: 4,
      ...e.typography.body2,
      [`& .${oz.root} svg`]: {
        fontSize: "1.25rem"
      }
    }
  }]
}))), fz = /* @__PURE__ */ M.forwardRef(function(e, t) {
  const n = At({
    props: e,
    name: "MuiMenuItem"
  }), {
    autoFocus: r = !1,
    component: a = "li",
    dense: s = !1,
    divider: l = !1,
    disableGutters: c = !1,
    focusVisibleClassName: d,
    role: p = "menuitem",
    tabIndex: m,
    className: h,
    ...v
  } = n, y = M.useContext(gc), w = M.useMemo(() => ({
    dense: s || y.dense || !1,
    disableGutters: c
  }), [y.dense, s, c]), x = M.useRef(null);
  zs(() => {
    r && (x.current && x.current.focus());
  }, [r]);
  const b = {
    ...n,
    dense: w.dense,
    divider: l,
    disableGutters: c
  }, k = eje(n), C = no(x, t);
  let _;
  return n.disabled || (_ = m !== void 0 ? m : -1), /* @__PURE__ */ E.jsx(gc.Provider, {
    value: w,
    children: /* @__PURE__ */ E.jsx(tje, {
      ref: C,
      role: p,
      tabIndex: _,
      component: a,
      focusVisibleClassName: Ke(k.focusVisible, d),
      className: Ke(k.root, h),
      ...v,
      ownerState: b,
      classes: k
    })
  });
});
function nje({
  schema: e,
  id: t,
  name: n,
  // remove this from textFieldProps
  htmlName: r,
  options: a,
  label: s,
  hideLabel: l,
  required: c,
  disabled: d,
  placeholder: p,
  readonly: m,
  value: h,
  multiple: v,
  autofocus: y,
  onChange: w,
  onBlur: x,
  onFocus: b,
  errorSchema: k,
  rawErrors: C = [],
  registry: _,
  uiSchema: O,
  hideError: N,
  ...R
}) {
  const { enumOptions: j, enumDisabled: D, emptyValue: $ } = a;
  v = typeof v > "u" ? !1 : !!v;
  const z = v ? [] : "", B = typeof h > "u" || v && h.length < 1 || !v && h === z, P = ({ target: { value: F } }) => w(to(F, j, $)), W = ({ target: F }) => x(t, to(F && F.value, j, $)), I = ({ target: F }) => b(t, to(F && F.value, j, $)), G = QA(h, j, v), { InputLabelProps: L, SelectProps: K, autocomplete: q, ...Z } = R, V = !v && e.default === void 0;
  return E.jsxs(_4, { id: t, name: r || t, label: Am(s || void 0, l, void 0), value: !B && typeof G < "u" ? G : z, required: c, disabled: d || m, autoFocus: y, autoComplete: q, placeholder: p, error: C.length > 0, onChange: P, onBlur: W, onFocus: I, ...Z, select: !0, InputLabelProps: {
    ...L,
    shrink: !B
  }, SelectProps: {
    ...K,
    multiple: v
  }, "aria-describedby": _i(t), children: [V && E.jsx(fz, { value: "", children: p }), Array.isArray(j) && j.map(({ value: F, label: X }, U) => {
    const H = Array.isArray(D) && D.indexOf(F) !== -1;
    return E.jsx(fz, { value: String(U), disabled: H, children: X }, U);
  })] });
}
function rje(e) {
  const { options: t, registry: n } = e, r = bt("BaseInputTemplate", n, t);
  let a = 5;
  return (typeof t.rows == "string" || typeof t.rows == "number") && (a = t.rows), E.jsx(r, { ...e, multiline: !0, rows: a });
}
function oje() {
  return {
    CheckboxWidget: i4e,
    CheckboxesWidget: c4e,
    RadioWidget: O4e,
    RangeWidget: Q4e,
    SelectWidget: nje,
    TextareaWidget: rje
  };
}
function Gq() {
  return {
    templates: UAe(),
    widgets: oje()
  };
}
const aje = Gq();
function ije() {
  return kq(Gq());
}
ije();
const sje = kq(aje), lje = l2({
  cssVariables: { nativeColor: !0 },
  palette: {
    primary: {
      main: "var(--fn-primary-color)",
      contrastText: "var(--fn-app-background)"
    },
    text: {
      primary: "var(--fn-text-color-neutral)",
      secondary: "var(--fn-text-color-neutral)",
      disabled: "var(--fn-text-color-neutral)",
      primaryChannel: "var(--fn-text-color-neutral-channel)",
      secondaryChannel: "var(--fn-text-color-neutral-channel)"
    },
    common: {
      black: "var(--fn-primary-color)",
      white: "var(--fn-app-background)"
    },
    background: {
      default: "var(--fn-app-background)",
      paper: "var(--fn-app-background)",
      defaultChannel: "var(--fn-app-background-channel)",
      paperChannel: "var(--fn-app-background-channel)"
    }
  },
  shape: {
    borderRadius: "var(--fn-border-radius-s)"
  }
}), Kq = ({
  getter: e,
  setter: t,
  setter_calls_getter: n = !1,
  disabled: r = !1,
  readonly: a = !1
}) => {
  const [s, l] = M.useState(null), [c, d] = M.useState(void 0), [p, m] = M.useState(void 0), h = M.useCallback(async () => {
    const y = await e();
    l(y.jsonSchema), d(y.uiSchema), m(y.formData);
  }, [e]), v = M.useCallback(
    async (y) => {
      await t(y), n && await h();
    },
    [t, n, h]
  );
  return M.useEffect(() => {
    h();
  }, [h]), s ? /* @__PURE__ */ E.jsx(L5e, { theme: lje, children: /* @__PURE__ */ E.jsx(
    sje,
    {
      schema: s,
      uiSchema: c || void 0,
      formData: p || void 0,
      validator: hOe,
      liveValidate: "onChange",
      onChange: ({ formData: y }) => m(y),
      onSubmit: ({ formData: y }) => v(y),
      disabled: r,
      readonly: a
    }
  ) }) : /* @__PURE__ */ E.jsx("div", { children: "Loading" });
}, uje = ({
  jsonSchema: e,
  uiSchema: t,
  full: n,
  readonly: r
}) => {
  const a = {
    jsonSchema: e,
    uiSchema: t,
    formData: {}
  };
  r && (a.uiSchema = {
    ...a.uiSchema,
    "ui:readonly": !0,
    "ui:disabled": !0,
    "ui:submitButtonOptions": {
      norender: !0,
      props: {
        disabled: r,
        className: "btn btn-info"
      }
    }
  });
  const s = n?.value;
  return s && (typeof s == "object" && s !== null && "schema" in s && "data" in s ? (a.jsonSchema = s.schema, a.formData = s.data ?? {}) : a.formData = s), a;
}, cje = ({ inputconverter: e }) => {
  const t = dr(), { preview: n, full: r } = t.valuestore(), a = t.use(), [s, l] = M.useState(!1), c = SS(), d = _m(a), p = a.render_options.schema, m = a.render_options.uiSchema, h = M.useMemo(() => {
    if (!p)
      throw new Error("No jsonSchema provided");
    return uje({
      jsonSchema: p,
      uiSchema: m,
      full: r,
      readonly: a.connected
    });
  }, [p, m, r, n, a.connected]), v = M.useCallback(
    async () => h,
    [h]
  ), y = M.useCallback(
    async (w) => {
      d(w), l(!1);
    },
    [d]
  );
  return /* @__PURE__ */ E.jsx(
    Pl,
    {
      title: a.name,
      description: "Edit " + a.name,
      open: s,
      setOpen: l,
      trigger: /* @__PURE__ */ E.jsx("button", { className: "nodedatainput styledinput", children: "Edit" }),
      onOpenChange: (w) => {
        w && !r && c?.();
      },
      children: /* @__PURE__ */ E.jsx(
        Kq,
        {
          getter: v,
          setter: y,
          setter_calls_getter: !1,
          disabled: a.connected,
          readonly: a.connected
        }
      )
    }
  );
}, dje = {
  float: zwe,
  int: Fwe,
  bool: hwe,
  string: D$,
  str: D$,
  color: gwe,
  select: Nx,
  enum: Nx,
  json_schema: cje,
  bytes: sV(xA, "")
}, fje = {}, pje = {}, nl = {
  Inputrenderer: dje,
  Outputrenderer: fwe,
  HandlePreviewRenderer: cwe,
  DataOverlayRenderer: uwe,
  DataPreviewViewRenderer: lV,
  DataViewRenderer: SA,
  InLineRenderer: lwe,
  NodeRenderer: fje,
  NodeHooks: pje
}, mje = (e, t) => {
  const n = t.options || {}, r = n.overwrite === void 0 ? !0 : n.overwrite;
  switch (t.type) {
    case "EXTEND_INPUT_RENDER":
      return !r && e.Inputrenderer[t.payload.type] ? e : {
        ...e,
        Inputrenderer: {
          ...e.Inputrenderer,
          [t.payload.type]: t.payload.component
        }
      };
    case "EXTEND_FROM_PLUGIN": {
      let s = !1;
      const l = [
        [t.payload.plugin.input_renderers || {}, e.Inputrenderer],
        [t.payload.plugin.output_renderers || {}, e.Outputrenderer],
        [
          t.payload.plugin.handle_preview_renderers || {},
          e.HandlePreviewRenderer
        ],
        [
          t.payload.plugin.data_overlay_renderers || {},
          e.DataOverlayRenderer
        ],
        [
          t.payload.plugin.data_preview_renderers || {},
          e.DataPreviewViewRenderer
        ],
        [
          t.payload.plugin.data_view_renderers || {},
          e.DataViewRenderer
        ],
        [t.payload.plugin.node_renderers || {}, e.NodeRenderer],
        [t.payload.plugin.node_hooks || {}, e.NodeHooks]
      ];
      for (const [d, p] of l) {
        if (Object.keys(d).length > 0) {
          if (r)
            s = !0;
          else
            for (const m in d)
              if (!p[m]) {
                s = !0;
                break;
              }
        }
        if (s) break;
      }
      if (!s)
        return e;
      const c = { ...e };
      return l.forEach(([d, p]) => {
        Object.assign(p, d);
      }), c;
    }
    default:
      const a = {
        EXTEND_OUTPUT_RENDER: "Outputrenderer",
        EXTEND_HANDLE_PREVIEW_RENDER: "HandlePreviewRenderer",
        EXTEND_DATA_OVERLAY_RENDER: "DataOverlayRenderer",
        EXTEND_DATA_PREVIEW_RENDER: "DataPreviewViewRenderer",
        EXTEND_DATA_VIEW_RENDER: "DataViewRenderer",
        EXTEND_NODE_CONTEXT_EXTENDER: "NodeContextExtenders",
        EXTEND_NODE_RENDERER: "NodeRenderer",
        EXTEND_NODE_HOOKS: "NodeHooks"
      }[t.type];
      if (a) {
        const s = e[a];
        return !r && s[t.payload.type] ? e : {
          ...e,
          [a]: {
            ...s,
            [t.payload.type]: t.payload.component
          }
        };
      }
      return e;
  }
}, hje = ({
  children: e,
  plugins: t,
  fnrf_zst: n
}) => {
  const [r, a] = M.useReducer(
    mje,
    nl
  ), s = M.useCallback(
    (w, x, b) => {
      a({
        type: "EXTEND_INPUT_RENDER",
        payload: { type: w, component: x },
        options: b
      });
    },
    []
  ), l = M.useCallback(
    (w, x, b) => {
      a({
        type: "EXTEND_OUTPUT_RENDER",
        payload: { type: w, component: x },
        options: b
      });
    },
    []
  ), c = M.useCallback(
    (w, x, b) => {
      a({
        type: "EXTEND_HANDLE_PREVIEW_RENDER",
        payload: { type: w, component: x },
        options: b
      });
    },
    []
  ), d = M.useCallback(
    (w, x, b) => {
      a({
        type: "EXTEND_DATA_OVERLAY_RENDER",
        payload: { type: w, component: x },
        options: b
      });
    },
    []
  ), p = M.useCallback(
    (w, x, b) => {
      a({
        type: "EXTEND_DATA_PREVIEW_RENDER",
        payload: { type: w, component: x },
        options: b
      });
    },
    []
  ), m = M.useCallback(
    (w, x, b) => {
      a({
        type: "EXTEND_DATA_VIEW_RENDER",
        payload: { type: w, component: x },
        options: b
      });
    },
    []
  ), h = M.useCallback(
    (w, x, b) => {
      a({
        type: "EXTEND_NODE_RENDERER",
        payload: { type: w, component: x },
        options: b
      });
    },
    []
  ), v = M.useCallback(
    (w, x, b) => {
      a({
        type: "EXTEND_NODE_HOOKS",
        payload: { type: w, component: x },
        options: b
      });
    },
    []
  ), y = M.useCallback(
    (w, x) => {
      a({
        type: "EXTEND_FROM_PLUGIN",
        payload: { plugin: w },
        options: x
      });
    },
    []
  );
  return M.useEffect(() => {
    for (const w in t) {
      const x = t[w];
      if (!x) continue;
      const b = x.renderpluginfactory;
      b && y(b({ React: Gx, fnrf_zst: n, NodeContext: Q2 }));
    }
  }, [t, y, n]), /* @__PURE__ */ E.jsx(
    $c.Provider,
    {
      value: {
        Inputrenderer: r.Inputrenderer,
        Outputrenderer: r.Outputrenderer,
        HandlePreviewRenderer: r.HandlePreviewRenderer,
        DataOverlayRenderer: r.DataOverlayRenderer,
        DataPreviewViewRenderer: r.DataPreviewViewRenderer,
        DataViewRenderer: r.DataViewRenderer,
        InLineRenderer: r.InLineRenderer,
        NodeRenderer: r.NodeRenderer,
        NodeHooks: r.NodeHooks,
        extendNodeRenderer: h,
        extendInputRenderMapping: s,
        extendOutputRenderMapping: l,
        extendHandlePreviewRenderMapping: c,
        extendDataOverlayRenderMapping: d,
        extendDataPreviewRenderMapping: p,
        extendDataViewRenderMapping: m,
        extendNodeHooks: v,
        extendFromPlugin: y
      },
      children: e
    }
  );
}, $c = M.createContext({
  Inputrenderer: nl.Inputrenderer,
  Outputrenderer: nl.Outputrenderer,
  HandlePreviewRenderer: nl.HandlePreviewRenderer,
  DataOverlayRenderer: nl.DataOverlayRenderer,
  DataPreviewViewRenderer: nl.DataPreviewViewRenderer,
  DataViewRenderer: nl.DataViewRenderer,
  InLineRenderer: nl.InLineRenderer,
  NodeRenderer: nl.NodeRenderer,
  NodeHooks: nl.NodeHooks,
  extendInputRenderMapping: (e, t, n) => {
  },
  extendOutputRenderMapping: (e, t, n) => {
  },
  extendHandlePreviewRenderMapping: (e, t, n) => {
  },
  extendDataOverlayRenderMapping: (e, t, n) => {
  },
  extendDataPreviewRenderMapping: (e, t, n) => {
  },
  extendDataViewRenderMapping: (e, t, n) => {
  },
  extendNodeRenderer: (e, t, n) => {
  },
  extendNodeHooks: (e, t, n) => {
  },
  extendFromPlugin: (e, t) => {
  }
}), Xq = (e) => {
  const t = yn(), { DataOverlayRenderer: n, DataViewRenderer: r } = M.useContext($c);
  if (e === void 0) return;
  const a = t.render_options(), [s] = km(e, a.typemap || {});
  return s ? n[s] ? n[s] : r[s] ? J2(r[s]) : P$ : P$;
}, gje = (e) => {
  const t = yn(), n = Xq(e), { DataPreviewViewRenderer: r, DataViewRenderer: a } = M.useContext($c), s = t.render_options();
  if (e === void 0) return [void 0, n];
  const [l] = km(e, s.typemap || {});
  return l ? r[l] ? [r[l], n] : a[l] ? [
    Ea(a[l]),
    n
  ] : [
    Ea(C_),
    n
  ] : [
    Ea(C_),
    n
  ];
}, vje = (e) => {
  const t = yn().render_options(), { HandlePreviewRenderer: n, DataPreviewViewRenderer: r } = M.useContext($c), a = Xq(e);
  let s;
  if (e) {
    const [l] = km(e, t.typemap || {});
    l ? n[l] ? s = n[l] : r[l] ? s = r[l] : s = Ea(
      C_
    ) : s = Ea(
      C_
    );
  }
  return [s, a];
}, yje = (e) => {
  const [t, n] = M.useState(!1), r = e.use((a) => a.in_trigger);
  return M.useEffect(() => {
    let a;
    return r && !t ? n(!0) : t && (a = setTimeout(() => n(!1), 200)), () => clearTimeout(a);
  }, [r, t]), { visualTrigger: t, nodestore: e };
}, Yq = ({
  iostore: e,
  Component: t
}) => {
  const [n, r] = M.useState(void 0), [a, s] = M.useState(void 0), { full: l } = e.valuestore(), c = SS();
  M.useEffect(() => {
    l === void 0 ? c?.() : s(l.value);
  }, [l, c]);
  const d = () => {
    a !== void 0 && r(a);
  };
  return /* @__PURE__ */ E.jsx(
    t,
    {
      value: a,
      preValue: n,
      onLoaded: d
    }
  );
}, Qq = ({
  Component: e
}) => /* @__PURE__ */ E.jsx(e, {}), v3 = ({
  typestring: e,
  preview: t,
  ...n
}) => {
  const [r, a] = M.useState(!1), [s, l] = M.useState(!1), c = yn(), d = dr(), p = d.use(), m = SS(), [h, v] = vje(p), y = c.local_state(() => c.reactflowRef);
  return (
    // <Tooltip.Provider>
    /* @__PURE__ */ E.jsxs(F8, { open: r || s, onOpenChange: l, children: [
      /* @__PURE__ */ E.jsx(B8, { asChild: !0, children: /* @__PURE__ */ E.jsx(Mx, { id: p.id, "data-type": e, ...n }) }),
      /* @__PURE__ */ E.jsx(U8, { container: y, children: /* @__PURE__ */ E.jsxs(
        V8,
        {
          className: "iotooltipcontent",
          sideOffset: 5,
          avoidCollisions: !0,
          collisionBoundary: y,
          collisionPadding: 10,
          onOpenAutoFocus: (w) => w.preventDefault(),
          onCloseAutoFocus: (w) => w.preventDefault(),
          children: [
            /* @__PURE__ */ E.jsxs("div", { className: "iotooltip_container", children: [
              /* @__PURE__ */ E.jsxs("div", { className: "iotooltip_header", children: [
                p.name,
                r ? /* @__PURE__ */ E.jsx(mae, { onClick: () => a(!1) }) : /* @__PURE__ */ E.jsx(pae, { onClick: () => a(!0) }),
                v && /* @__PURE__ */ E.jsx(
                  Pl,
                  {
                    title: p.full_id,
                    trigger: /* @__PURE__ */ E.jsx(JF, {}),
                    onOpenChange: (w) => {
                      w && m?.(), a(w);
                    },
                    children: /* @__PURE__ */ E.jsx(
                      Yq,
                      {
                        Component: v,
                        iostore: d
                      }
                    )
                  }
                )
              ] }),
              h ? /* @__PURE__ */ E.jsx(Qq, { Component: h }) : `no preview available for "${e}"`
            ] }),
            /* @__PURE__ */ E.jsx(Xie, { className: "iotooltipcontentarrow" })
          ]
        }
      ) })
    ] })
  );
}, Yh = {
  "": [(e) => e, (e) => e],
  str_to_json: [
    (e) => JSON.parse(e),
    (e) => typeof e == "string" ? e : JSON.stringify(e)
  ],
  str_to_list: [
    (e) => {
      try {
        const t = JSON.parse(e);
        return Array.isArray(t) ? t : [t];
      } catch {
        try {
          return JSON.parse("[" + e + "]");
        } catch {
        }
      }
      throw new Error("Invalid list");
    },
    (e) => JSON.stringify(e)
  ]
}, bje = ({
  setNodeSettingsPath: e,
  setShowSettings: t
}) => {
  const n = yn().render_options(), r = dr().use(), [a, s] = km(r, n.typemap || {}), { Inputrenderer: l } = M.useContext($c), c = a ? r.value_options?.options ? Nx : l[a] : void 0, d = Yh[(s && n.inputconverter?.[s]) ?? ""] || Yh[""], { keys: p } = OR(), m = (h) => {
    p.has("s") && (e && e("inputs/" + r.id), t && t(!0), h.stopPropagation());
  };
  return r.hidden ? null : /* @__PURE__ */ E.jsxs(
    "div",
    {
      className: "nodeinput",
      "data-type": a,
      onClick: m,
      children: [
        /* @__PURE__ */ E.jsx(
          v3,
          {
            typestring: a,
            position: st.Left,
            type: "target"
          }
        ),
        /* @__PURE__ */ E.jsxs("div", { className: "inner_nodeio", children: [
          c && /* @__PURE__ */ E.jsx("div", { className: "iovaluefield nodrag", "data-type": a, children: /* @__PURE__ */ E.jsx(c, { inputconverter: d }) }),
          /* @__PURE__ */ E.jsx("div", { className: "ioname", children: r.name })
        ] }),
        /* @__PURE__ */ E.jsx(
          v3,
          {
            typestring: a,
            position: st.Right,
            type: "source"
          }
        )
      ]
    }
  );
}, wje = ({
  setNodeSettingsPath: e,
  setShowSettings: t
}) => {
  const n = yn().render_options(), r = dr().use(), [a] = km(r, n.typemap || {}), { Outputrenderer: s } = M.useContext($c), { keys: l } = OR(), c = a ? s[a] : void 0, d = (p) => {
    l.has("s") && (e && e("outputs/" + r.id), t && t(!0), p.stopPropagation());
  };
  return r.hidden ? null : /* @__PURE__ */ E.jsxs(
    "div",
    {
      className: "nodeoutput",
      "data-type": a,
      onClick: d,
      children: [
        /* @__PURE__ */ E.jsx(
          v3,
          {
            typestring: a,
            position: st.Right,
            type: "source"
          }
        ),
        /* @__PURE__ */ E.jsxs("div", { className: "inner_nodeio", children: [
          /* @__PURE__ */ E.jsx("div", { className: "ioname", children: r.name }),
          c ? /* @__PURE__ */ E.jsx("div", { className: "iovaluefield nodrag", children: /* @__PURE__ */ E.jsx(c, {}) }) : /* @__PURE__ */ E.jsx("div", { className: "iovaluefield", children: /* @__PURE__ */ E.jsx(dwe, {}) })
        ] })
      ]
    }
  );
}, xje = () => {
  const e = yn().render_options(), t = dr().use(), n = kA(), [r, a] = km(t, e.typemap || {}), { Inputrenderer: s } = M.useContext($c), l = r ? t.value_options?.options ? Nx : s[r] : void 0, c = Yh[(a && e.inputconverter?.[a]) ?? ""] || Yh[""];
  return /* @__PURE__ */ E.jsxs("div", { className: "nodesettings_component", children: [
    /* @__PURE__ */ E.jsx("div", { children: t.name }),
    l && /* @__PURE__ */ E.jsx(l, { inputconverter: c }),
    /* @__PURE__ */ E.jsx("div", { children: /* @__PURE__ */ E.jsxs("label", { children: [
      "hidden:",
      /* @__PURE__ */ E.jsx(
        "input",
        {
          className: "styledcheckbox",
          type: "checkbox",
          disabled: t.connected,
          onChange: (d) => {
            n?.(d.target.checked);
          },
          checked: t.hidden
        }
      )
    ] }) })
  ] });
}, Sje = () => {
  const e = dr().use(), t = kA();
  return /* @__PURE__ */ E.jsxs("div", { className: "nodesettings_component", children: [
    /* @__PURE__ */ E.jsx("div", { children: e.name }),
    /* @__PURE__ */ E.jsx("div", { children: /* @__PURE__ */ E.jsxs("label", { children: [
      "hidden:",
      /* @__PURE__ */ E.jsx(
        "input",
        {
          className: "styledcheckbox",
          type: "checkbox",
          disabled: e.connected,
          onChange: (n) => {
            t?.(n.target.checked);
          },
          checked: e.hidden
        }
      )
    ] }) })
  ] });
}, Jq = ({}) => {
  const e = yn(), { node: t } = xa(), n = dr().use(), r = e.render_options(), a = kA(), [s, l] = M.useState(n.name);
  M.useEffect(() => l(n.name), [n.name]);
  const c = M.useCallback(
    (w) => l(w.target.value),
    []
  ), d = M.useCallback(() => {
    s !== n.name && t?.update_io_options({
      nid: n.node,
      ioid: n.id,
      options: { name: s }
    });
  }, [n, t, s]), [p, m] = km(
    n,
    r.typemap || {}
  ), h = Yh[(m && r.inputconverter?.[m]) ?? ""] || Yh[""], { Inputrenderer: v } = M.useContext($c), y = p ? n.value_options?.options ? Nx : v[p] : void 0;
  return /* @__PURE__ */ E.jsxs("div", { className: "nodesettings-io-entry funcnodes-control-group", children: [
    /* @__PURE__ */ E.jsxs("div", { className: "funcnodes-control-row", children: [
      /* @__PURE__ */ E.jsx("label", { htmlFor: `io-name-${n.id}`, children: "Name:" }),
      /* @__PURE__ */ E.jsx(
        "input",
        {
          id: `io-name-${n.id}`,
          type: "text",
          value: s,
          onChange: c,
          onBlur: d,
          className: "styledinput"
        }
      )
    ] }),
    /* @__PURE__ */ E.jsxs("div", { className: "funcnodes-control-row", children: [
      /* @__PURE__ */ E.jsx("label", { children: "ID:" }),
      /* @__PURE__ */ E.jsx("span", { children: n.id })
    ] }),
    /* @__PURE__ */ E.jsxs("div", { className: "funcnodes-control-row", children: [
      /* @__PURE__ */ E.jsx("label", { children: "Value:" }),
      y && /* @__PURE__ */ E.jsx(y, { inputconverter: h })
    ] }),
    /* @__PURE__ */ E.jsxs("div", { className: "funcnodes-control-row", children: [
      /* @__PURE__ */ E.jsx("label", { children: "Type:" }),
      /* @__PURE__ */ E.jsx("pre", { children: JSON.stringify(n.type, null, 2) })
    ] }),
    /* @__PURE__ */ E.jsxs("div", { className: "funcnodes-control-row", children: [
      /* @__PURE__ */ E.jsx("label", { htmlFor: `io-hidden-${n.id}`, children: "Hidden:" }),
      /* @__PURE__ */ E.jsx(
        "input",
        {
          id: `io-hidden-${n.id}`,
          type: "checkbox",
          checked: n.hidden,
          onChange: (w) => a?.(w.target.checked),
          className: "styledcheckbox",
          disabled: n.connected && n.is_input
        }
      )
    ] }),
    /* @__PURE__ */ E.jsxs("div", { className: "funcnodes-control-row", children: [
      /* @__PURE__ */ E.jsx("label", { children: "Value Options:" }),
      /* @__PURE__ */ E.jsx("pre", { children: JSON.stringify(n.value_options, null, 2) })
    ] }),
    /* @__PURE__ */ E.jsxs("div", { className: "funcnodes-control-row", children: [
      /* @__PURE__ */ E.jsx("label", { children: "Render Options:" }),
      /* @__PURE__ */ E.jsx("pre", { className: "code-display", children: JSON.stringify(n.render_options, null, 2) })
    ] }),
    n.is_input && /* @__PURE__ */ E.jsxs(E.Fragment, { children: [
      /* @__PURE__ */ E.jsxs("div", { className: "funcnodes-control-row", children: [
        /* @__PURE__ */ E.jsx("label", { children: "Does Trigger:" }),
        /* @__PURE__ */ E.jsx("span", { children: String(n.does_trigger) })
      ] }),
      /* @__PURE__ */ E.jsxs("div", { className: "funcnodes-control-row", children: [
        /* @__PURE__ */ E.jsx("label", { children: "Required:" }),
        /* @__PURE__ */ E.jsx("span", { children: String(n.required) })
      ] })
    ] }),
    /* @__PURE__ */ E.jsxs("div", { className: "funcnodes-control-row", children: [
      /* @__PURE__ */ E.jsx("label", { children: "Emit Value Set:" }),
      /* @__PURE__ */ E.jsx("span", { children: String(n.emit_value_set) })
    ] }),
    /* @__PURE__ */ E.jsx("hr", {})
  ] });
}, y3 = {
  xxs: 0,
  xs: 320,
  s: 480,
  m: 768,
  l: 960,
  xl: 1280,
  xxl: 1920
}, kje = Object.entries(y3).sort(
  ([, e], [, t]) => t - e
), Zq = M.createContext(void 0), _je = (e, t) => {
  let n;
  return ((...r) => {
    clearTimeout(n), n = setTimeout(() => e(...r), t);
  });
}, Eje = (e) => {
  for (const [t, n] of kje)
    if (e >= n)
      return t;
  return "xxs";
}, eW = M.memo(
  M.forwardRef(
    (e, t) => {
      const { className: n, children: r, ...a } = e, [s, l] = M.useState(
        {
          wKey: "m",
          w: 0,
          h: 0
        }
      ), c = M.useRef(null);
      M.useImperativeHandle(
        t,
        () => c.current,
        []
      );
      const d = M.useCallback((m) => {
        const h = m.width, v = m.height, y = Eje(h);
        l((w) => w.wKey === y && w.w === h && w.h === v ? w : { wKey: y, w: h, h: v });
      }, []), p = M.useMemo(
        () => _je(d, 16),
        [d]
      );
      return M.useEffect(() => {
        const m = c.current;
        if (!m)
          return;
        const h = new ResizeObserver((v) => {
          const y = v[0];
          y && p(y.contentRect);
        });
        return d(m.getBoundingClientRect()), h.observe(m), () => {
          h.disconnect();
        };
      }, [d, p]), /* @__PURE__ */ E.jsx(Zq.Provider, { value: s, children: /* @__PURE__ */ E.jsx(
        "div",
        {
          ref: c,
          className: `size-context w-${s.wKey} ${n || ""}`.trim(),
          ...a,
          children: r
        }
      ) });
    }
  )
);
eW.displayName = "SizeContextContainer";
const Cje = () => {
  const e = M.useContext(Zq);
  if (!e)
    throw new Error(
      "useSizeContext must be used within a SizeContextContainerContext"
    );
  return e;
}, Oje = (e, t) => e === t ? !1 : e === "" ? !0 : y3[e] < y3[t], Mje = (e) => {
  const { wKey: t } = Cje();
  return Oje(t, e);
}, pz = (e, t, n = "", r = "") => {
  const a = [];
  return typeof e == "string" ? a.push(`${t}-${e}`) : typeof e == "boolean" ? a.push(e ? n : r) : e && typeof e == "object" && Object.entries(e).forEach(([s, l]) => {
    if (typeof l == "string")
      a.push(
        s === "" ? `${t}-${l}` : `${s}-${t}-${l}`
      );
    else if (typeof l == "boolean") {
      const c = l ? n : r;
      c && a.push(s === "" ? c : `${s}-${c}`);
    }
  }), a.filter(Boolean).join(" ");
}, nd = M.memo(
  ({
    direction: e,
    className: t = "",
    children: n,
    wrap: r = !1,
    grow: a = !1,
    ...s
  }) => {
    const l = "float-container", c = pz(e, "direction"), d = pz(a, "", "grow", "no-grow"), p = [
      l,
      c,
      d,
      typeof r == "boolean" && r ? "flex-wrap" : "",
      t
    ].filter(Boolean).join(" ");
    return /* @__PURE__ */ E.jsx("div", { className: p, ...s, children: n });
  }
);
nd.displayName = "FloatContainer";
const Nje = {
  up: (e) => /* @__PURE__ */ E.jsx(E.Fragment, { children: "" }),
  down: (e) => /* @__PURE__ */ E.jsx(E.Fragment, { children: "" }),
  left: (e) => /* @__PURE__ */ E.jsx(E.Fragment, { children: "" }),
  right: (e) => /* @__PURE__ */ E.jsx(E.Fragment, { children: "" })
}, Rje = {
  up: (e) => /* @__PURE__ */ E.jsx(E.Fragment, { children: "" }),
  down: (e) => /* @__PURE__ */ E.jsx(E.Fragment, { children: "" }),
  left: (e) => /* @__PURE__ */ E.jsx(E.Fragment, { children: "" }),
  right: (e) => /* @__PURE__ */ E.jsx(E.Fragment, { children: "" })
}, C4 = M.memo(
  ({
    direction: e,
    expanded: t = !0,
    children: n,
    className: r,
    maxSize: a = "18.75rem",
    expanderSize: s = "2rem",
    containerStyle: l,
    style: c,
    containerClassName: d,
    expandIcons: p,
    collapseIcons: m,
    onExpandChange: h,
    ...v
  }) => {
    const [y, w] = M.useState(t);
    M.useEffect(() => {
      w(t);
    }, [t]);
    const x = M.useCallback(() => {
      w((z) => {
        const B = !z;
        return h?.(B), B;
      });
    }, [h]), b = M.useCallback(
      (z) => {
        (z.key === "Enter" || z.key === " ") && (z.preventDefault(), x());
      },
      [x]
    ), k = e === "right" || e === "left", C = e === "left" || e === "up", _ = y ? m?.[e] || Rje[e] : p?.[e] || Nje[e], O = `${e} ${y ? "expanded" : "collapsed"}`, N = M.useMemo(
      () => ({
        [k ? "width" : "height"]: y ? a : s
      }),
      [k, y, a, s]
    ), R = M.useMemo(
      () => ({
        [k ? "width" : "height"]: y ? a : 0
      }),
      [k, y, a]
    ), j = M.useMemo(
      () => ({
        [k ? "width" : "height"]: s
      }),
      [k, s]
    ), D = /* @__PURE__ */ E.jsx(
      "div",
      {
        className: `expanding_container_content ${O} ${r || ""}`.trim(),
        style: { ...c, ...R },
        ...v,
        children: n
      }
    ), $ = /* @__PURE__ */ E.jsx(
      "div",
      {
        className: `expanding_container_expander ${O}`,
        onClick: x,
        onKeyDown: b,
        style: j,
        role: "button",
        tabIndex: 0,
        "aria-label": `${y ? "Collapse" : "Expand"} ${e}`,
        children: /* @__PURE__ */ E.jsx(_, {})
      }
    );
    return /* @__PURE__ */ E.jsxs(
      "div",
      {
        className: `expanding_container ${O} ${d || ""}`,
        style: { ...l, ...N },
        children: [
          C ? $ : D,
          C ? D : $
        ]
      }
    );
  }
);
C4.displayName = "ExpandingContainer";
const Aje = ({ nodestore: e }) => {
  const t = e.use();
  return /* @__PURE__ */ E.jsx(Q2.Provider, { value: e, children: /* @__PURE__ */ E.jsxs("div", { className: "nodesettings_content", children: [
    /* @__PURE__ */ E.jsx("div", { className: "nodesettings_section", children: /* @__PURE__ */ E.jsxs("div", { className: "nodesettings_component", children: [
      /* @__PURE__ */ E.jsx("div", { children: "Name" }),
      /* @__PURE__ */ E.jsx("div", { children: /* @__PURE__ */ E.jsx(R4, {}) })
    ] }) }),
    /* @__PURE__ */ E.jsxs("div", { className: "nodesettings_section", children: [
      /* @__PURE__ */ E.jsx("div", { children: "Inputs" }),
      t.inputs.map((n) => {
        const r = e.io_stores.get(n);
        if (r)
          return /* @__PURE__ */ E.jsx(dd.Provider, { value: r, children: /* @__PURE__ */ E.jsx(xje, {}) }, n);
      })
    ] }),
    /* @__PURE__ */ E.jsxs("div", { className: "nodesettings_section", children: [
      /* @__PURE__ */ E.jsx("div", { children: "Outputs" }),
      t.outputs.map((n) => {
        const r = e.io_stores.get(n);
        if (r)
          return /* @__PURE__ */ E.jsx(dd.Provider, { value: r, children: /* @__PURE__ */ E.jsx(Sje, {}) }, n);
      })
    ] })
  ] }) });
}, jje = () => {
  const e = yn(), t = e.local_state((r) => r.selected_nodes);
  if (t.length === 0)
    return /* @__PURE__ */ E.jsx("div", { children: "Node Settings" });
  if (t.length > 1)
    return /* @__PURE__ */ E.jsx("div", { children: "Multiple Nodes Selected" });
  const n = e.nodespace.get_node(t[0]);
  return n ? /* @__PURE__ */ E.jsx(Aje, { nodestore: n }) : /* @__PURE__ */ E.jsx("div", { children: "Node not found" });
}, Pje = () => {
  const e = yn(), t = e.local_settings(
    (r) => r.view_settings.expand_node_props
  ), n = (r) => {
    e.update_view_settings({ expand_node_props: r });
  };
  return /* @__PURE__ */ E.jsx(
    C4,
    {
      direction: "left",
      expanded: t === void 0 ? !1 : t,
      containerClassName: "pos-right pos-top bg1 h-12",
      className: "nodesettings_content",
      onExpandChange: n,
      collapseIcons: {
        up: r_,
        down: gx,
        left: hx,
        right: n_
      },
      expandIcons: {
        up: gx,
        down: r_,
        left: n_,
        right: hx
      },
      children: /* @__PURE__ */ E.jsx(jje, {})
    }
  );
};
var SN = "rovingFocusGroup.onEntryFocus", Dje = { bubbles: !1, cancelable: !0 }, DS = "RovingFocusGroup", [b3, tW, $je] = A2(DS), [Tje, CE] = jl(
  DS,
  [$je]
), [Lje, Ije] = Tje(DS), nW = M.forwardRef(
  (e, t) => /* @__PURE__ */ E.jsx(b3.Provider, { scope: e.__scopeRovingFocusGroup, children: /* @__PURE__ */ E.jsx(b3.Slot, { scope: e.__scopeRovingFocusGroup, children: /* @__PURE__ */ E.jsx(zje, { ...e, ref: t }) }) })
);
nW.displayName = DS;
var zje = M.forwardRef((e, t) => {
  const {
    __scopeRovingFocusGroup: n,
    orientation: r,
    loop: a = !1,
    dir: s,
    currentTabStopId: l,
    defaultCurrentTabStopId: c,
    onCurrentTabStopIdChange: d,
    onEntryFocus: p,
    preventScrollOnEntryFocus: m = !1,
    ...h
  } = e, v = M.useRef(null), y = Wn(t, v), w = Z2(s), [x, b] = gd({
    prop: l,
    defaultProp: c ?? null,
    onChange: d,
    caller: DS
  }), [k, C] = M.useState(!1), _ = Ra(p), O = tW(n), N = M.useRef(!1), [R, j] = M.useState(0);
  return M.useEffect(() => {
    const D = v.current;
    if (D)
      return D.addEventListener(SN, _), () => D.removeEventListener(SN, _);
  }, [_]), /* @__PURE__ */ E.jsx(
    Lje,
    {
      scope: n,
      orientation: r,
      dir: w,
      loop: a,
      currentTabStopId: x,
      onItemFocus: M.useCallback(
        (D) => b(D),
        [b]
      ),
      onItemShiftTab: M.useCallback(() => C(!0), []),
      onFocusableItemAdd: M.useCallback(
        () => j((D) => D + 1),
        []
      ),
      onFocusableItemRemove: M.useCallback(
        () => j((D) => D - 1),
        []
      ),
      children: /* @__PURE__ */ E.jsx(
        Kt.div,
        {
          tabIndex: k || R === 0 ? -1 : 0,
          "data-orientation": r,
          ...h,
          ref: y,
          style: { outline: "none", ...e.style },
          onMouseDown: Ze(e.onMouseDown, () => {
            N.current = !0;
          }),
          onFocus: Ze(e.onFocus, (D) => {
            const $ = !N.current;
            if (D.target === D.currentTarget && $ && !k) {
              const z = new CustomEvent(SN, Dje);
              if (D.currentTarget.dispatchEvent(z), !z.defaultPrevented) {
                const B = O().filter((G) => G.focusable), P = B.find((G) => G.active), W = B.find((G) => G.id === x), I = [P, W, ...B].filter(
                  Boolean
                ).map((G) => G.ref.current);
                aW(I, m);
              }
            }
            N.current = !1;
          }),
          onBlur: Ze(e.onBlur, () => C(!1))
        }
      )
    }
  );
}), rW = "RovingFocusGroupItem", oW = M.forwardRef(
  (e, t) => {
    const {
      __scopeRovingFocusGroup: n,
      focusable: r = !0,
      active: a = !1,
      tabStopId: s,
      children: l,
      ...c
    } = e, d = _l(), p = s || d, m = Ije(rW, n), h = m.currentTabStopId === p, v = tW(n), { onFocusableItemAdd: y, onFocusableItemRemove: w, currentTabStopId: x } = m;
    return M.useEffect(() => {
      if (r)
        return y(), () => w();
    }, [r, y, w]), /* @__PURE__ */ E.jsx(
      b3.ItemSlot,
      {
        scope: n,
        id: p,
        focusable: r,
        active: a,
        children: /* @__PURE__ */ E.jsx(
          Kt.span,
          {
            tabIndex: h ? 0 : -1,
            "data-orientation": m.orientation,
            ...c,
            ref: t,
            onMouseDown: Ze(e.onMouseDown, (b) => {
              r ? m.onItemFocus(p) : b.preventDefault();
            }),
            onFocus: Ze(e.onFocus, () => m.onItemFocus(p)),
            onKeyDown: Ze(e.onKeyDown, (b) => {
              if (b.key === "Tab" && b.shiftKey) {
                m.onItemShiftTab();
                return;
              }
              if (b.target !== b.currentTarget) return;
              const k = Uje(b, m.orientation, m.dir);
              if (k !== void 0) {
                if (b.metaKey || b.ctrlKey || b.altKey || b.shiftKey) return;
                b.preventDefault();
                let C = v().filter((_) => _.focusable).map((_) => _.ref.current);
                if (k === "last") C.reverse();
                else if (k === "prev" || k === "next") {
                  k === "prev" && C.reverse();
                  const _ = C.indexOf(b.currentTarget);
                  C = m.loop ? Vje(C, _ + 1) : C.slice(_ + 1);
                }
                setTimeout(() => aW(C));
              }
            }),
            children: typeof l == "function" ? l({ isCurrentTabStop: h, hasTabStop: x != null }) : l
          }
        )
      }
    );
  }
);
oW.displayName = rW;
var Fje = {
  ArrowLeft: "prev",
  ArrowUp: "prev",
  ArrowRight: "next",
  ArrowDown: "next",
  PageUp: "first",
  Home: "first",
  PageDown: "last",
  End: "last"
};
function Bje(e, t) {
  return t !== "rtl" ? e : e === "ArrowLeft" ? "ArrowRight" : e === "ArrowRight" ? "ArrowLeft" : e;
}
function Uje(e, t, n) {
  const r = Bje(e.key, n);
  if (!(t === "vertical" && ["ArrowLeft", "ArrowRight"].includes(r)) && !(t === "horizontal" && ["ArrowUp", "ArrowDown"].includes(r)))
    return Fje[r];
}
function aW(e, t = !1) {
  const n = document.activeElement;
  for (const r of e)
    if (r === n || (r.focus({ preventScroll: t }), document.activeElement !== n)) return;
}
function Vje(e, t) {
  return e.map((n, r) => e[(t + r) % e.length]);
}
var iW = nW, sW = oW, OE = "Tabs", [Hje] = jl(OE, [
  CE
]), lW = CE(), [qje, O4] = Hje(OE), uW = M.forwardRef(
  (e, t) => {
    const {
      __scopeTabs: n,
      value: r,
      onValueChange: a,
      defaultValue: s,
      orientation: l = "horizontal",
      dir: c,
      activationMode: d = "automatic",
      ...p
    } = e, m = Z2(c), [h, v] = gd({
      prop: r,
      onChange: a,
      defaultProp: s ?? "",
      caller: OE
    });
    return /* @__PURE__ */ E.jsx(
      qje,
      {
        scope: n,
        baseId: _l(),
        value: h,
        onValueChange: v,
        orientation: l,
        dir: m,
        activationMode: d,
        children: /* @__PURE__ */ E.jsx(
          Kt.div,
          {
            dir: m,
            "data-orientation": l,
            ...p,
            ref: t
          }
        )
      }
    );
  }
);
uW.displayName = OE;
var cW = "TabsList", dW = M.forwardRef(
  (e, t) => {
    const { __scopeTabs: n, loop: r = !0, ...a } = e, s = O4(cW, n), l = lW(n);
    return /* @__PURE__ */ E.jsx(
      iW,
      {
        asChild: !0,
        ...l,
        orientation: s.orientation,
        dir: s.dir,
        loop: r,
        children: /* @__PURE__ */ E.jsx(
          Kt.div,
          {
            role: "tablist",
            "aria-orientation": s.orientation,
            ...a,
            ref: t
          }
        )
      }
    );
  }
);
dW.displayName = cW;
var fW = "TabsTrigger", pW = M.forwardRef(
  (e, t) => {
    const { __scopeTabs: n, value: r, disabled: a = !1, ...s } = e, l = O4(fW, n), c = lW(n), d = gW(l.baseId, r), p = vW(l.baseId, r), m = r === l.value;
    return /* @__PURE__ */ E.jsx(
      sW,
      {
        asChild: !0,
        ...c,
        focusable: !a,
        active: m,
        children: /* @__PURE__ */ E.jsx(
          Kt.button,
          {
            type: "button",
            role: "tab",
            "aria-selected": m,
            "aria-controls": p,
            "data-state": m ? "active" : "inactive",
            "data-disabled": a ? "" : void 0,
            disabled: a,
            id: d,
            ...s,
            ref: t,
            onMouseDown: Ze(e.onMouseDown, (h) => {
              !a && h.button === 0 && h.ctrlKey === !1 ? l.onValueChange(r) : h.preventDefault();
            }),
            onKeyDown: Ze(e.onKeyDown, (h) => {
              [" ", "Enter"].includes(h.key) && l.onValueChange(r);
            }),
            onFocus: Ze(e.onFocus, () => {
              const h = l.activationMode !== "manual";
              !m && !a && h && l.onValueChange(r);
            })
          }
        )
      }
    );
  }
);
pW.displayName = fW;
var mW = "TabsContent", hW = M.forwardRef(
  (e, t) => {
    const { __scopeTabs: n, value: r, forceMount: a, children: s, ...l } = e, c = O4(mW, n), d = gW(c.baseId, r), p = vW(c.baseId, r), m = r === c.value, h = M.useRef(m);
    return M.useEffect(() => {
      const v = requestAnimationFrame(() => h.current = !1);
      return () => cancelAnimationFrame(v);
    }, []), /* @__PURE__ */ E.jsx(Hs, { present: a || m, children: ({ present: v }) => /* @__PURE__ */ E.jsx(
      Kt.div,
      {
        "data-state": m ? "active" : "inactive",
        "data-orientation": c.orientation,
        role: "tabpanel",
        "aria-labelledby": d,
        hidden: !v,
        id: p,
        tabIndex: 0,
        ...l,
        ref: t,
        style: {
          ...e.style,
          animationDuration: h.current ? "0s" : void 0
        },
        children: v && s
      }
    ) });
  }
);
hW.displayName = mW;
function gW(e, t) {
  return `${e}-trigger-${t}`;
}
function vW(e, t) {
  return `${e}-content-${t}`;
}
var M4 = uW, N4 = dW, ox = pW, ax = hW;
const Wje = ({}) => {
  const e = yn(), t = ki(), { description: n, id: r, node_id: a, node_name: s, reset_inputs_on_trigger: l } = t.useShallow((h) => ({
    description: h.description,
    id: h.id,
    node_id: h.node_id,
    node_name: h.node_name,
    reset_inputs_on_trigger: h.reset_inputs_on_trigger
  })), [c, d] = M.useState(
    n || ""
  );
  M.useEffect(() => d(n || ""), [n]);
  const p = (h) => d(h.target.value), m = () => {
    c !== (n || "") && e.on_node_action({
      type: "update",
      from_remote: !1,
      id: r,
      node: { description: c }
    });
  };
  return /* @__PURE__ */ E.jsxs("div", { className: "nodesettings-section funcnodes-control-group", children: [
    /* @__PURE__ */ E.jsxs("div", { className: "funcnodes-control-row", children: [
      /* @__PURE__ */ E.jsx("label", { htmlFor: `node-name-${r}`, children: "Name:" }),
      /* @__PURE__ */ E.jsx(R4, {})
    ] }),
    /* @__PURE__ */ E.jsxs("div", { className: "funcnodes-control-row", children: [
      /* @__PURE__ */ E.jsx("label", { children: "Instance ID:" }),
      /* @__PURE__ */ E.jsx("span", { children: r })
    ] }),
    /* @__PURE__ */ E.jsxs("div", { className: "funcnodes-control-row", children: [
      /* @__PURE__ */ E.jsx("label", { children: "Node Type ID:" }),
      /* @__PURE__ */ E.jsx("span", { children: a })
    ] }),
    /* @__PURE__ */ E.jsxs("div", { className: "funcnodes-control-row", children: [
      /* @__PURE__ */ E.jsx("label", { children: "Node Type Name:" }),
      /* @__PURE__ */ E.jsx("span", { children: s })
    ] }),
    /* @__PURE__ */ E.jsxs("div", { className: "funcnodes-control-row", children: [
      /* @__PURE__ */ E.jsx("label", { htmlFor: `node-desc-${r}`, children: "Description:" }),
      /* @__PURE__ */ E.jsx(
        "textarea",
        {
          id: `node-desc-${r}`,
          value: c,
          onChange: p,
          onBlur: m,
          className: "styledinput",
          rows: 3
        }
      )
    ] }),
    /* @__PURE__ */ E.jsxs("div", { className: "funcnodes-control-row", children: [
      /* @__PURE__ */ E.jsx("label", { children: "Reset Inputs on Trigger:" }),
      /* @__PURE__ */ E.jsx(
        "input",
        {
          type: "checkbox",
          checked: l,
          onChange: (h) => {
            e.on_node_action({
              type: "update",
              from_remote: !1,
              id: r,
              node: { reset_inputs_on_trigger: h.target.checked }
            });
          },
          className: "styledcheckbox"
        }
      )
    ] })
  ] });
}, Gje = ({ splitnodesettingsPath: e = [] }) => {
  const t = ki(), n = t.use((r) => r.inputs);
  return /* @__PURE__ */ E.jsxs(
    M4,
    {
      defaultValue: e[0] || n[0],
      className: "nodesettings-tabs funcnodes-control-root",
      children: [
        /* @__PURE__ */ E.jsx(
          N4,
          {
            className: "nodesettings-tabs-list",
            "aria-label": "Manage node inputs",
            children: n.map((r) => /* @__PURE__ */ E.jsx(
              ox,
              {
                value: r,
                className: "nodesettings-tabs-trigger",
                children: r
              },
              r
            ))
          }
        ),
        n.map((r) => {
          const a = t.io_stores.get(r);
          return /* @__PURE__ */ E.jsx(
            ax,
            {
              value: r,
              className: "nodesettings-tabs-content nodesettings-io-list",
              children: a && /* @__PURE__ */ E.jsx(dd.Provider, { value: a, children: /* @__PURE__ */ E.jsx(Jq, {}) })
            },
            r
          );
        })
      ]
    }
  );
}, Kje = ({ splitnodesettingsPath: e = [] }) => {
  const t = ki(), n = t.use((r) => r.outputs);
  return /* @__PURE__ */ E.jsxs(
    M4,
    {
      defaultValue: e[0] || n[0],
      className: "nodesettings-tabs funcnodes-control-root",
      children: [
        /* @__PURE__ */ E.jsx(
          N4,
          {
            className: "nodesettings-tabs-list",
            "aria-label": "Manage node outputs",
            children: n.map((r) => /* @__PURE__ */ E.jsx(
              ox,
              {
                value: r,
                className: "nodesettings-tabs-trigger",
                children: r
              },
              r
            ))
          }
        ),
        n.map((r) => {
          const a = t.io_stores.get(r);
          return /* @__PURE__ */ E.jsx(
            ax,
            {
              value: r,
              className: "nodesettings-tabs-content nodesettings-io-list",
              children: a && /* @__PURE__ */ E.jsx(dd.Provider, { value: a, children: /* @__PURE__ */ E.jsx(Jq, {}) })
            },
            r
          );
        })
      ]
    }
  );
}, Xje = ({
  nodeSettingsPath: e
}) => {
  const t = e.split("/") || ["general"];
  return /* @__PURE__ */ E.jsxs(
    M4,
    {
      defaultValue: t[0] || "general",
      className: "nodesettings-tabs funcnodes-control-root",
      children: [
        /* @__PURE__ */ E.jsxs(
          N4,
          {
            className: "nodesettings-tabs-list",
            "aria-label": "Manage node settings",
            children: [
              /* @__PURE__ */ E.jsx(ox, { value: "general", className: "nodesettings-tabs-trigger", children: "General" }),
              /* @__PURE__ */ E.jsx(ox, { value: "inputs", className: "nodesettings-tabs-trigger", children: "Inputs" }),
              /* @__PURE__ */ E.jsx(ox, { value: "outputs", className: "nodesettings-tabs-trigger", children: "Outputs" })
            ]
          }
        ),
        /* @__PURE__ */ E.jsx(ax, { value: "general", className: "nodesettings-tabs-content", children: /* @__PURE__ */ E.jsx(Wje, {}) }),
        /* @__PURE__ */ E.jsx(
          ax,
          {
            value: "inputs",
            className: "nodesettings-tabs-content nodesettings-io-list",
            children: /* @__PURE__ */ E.jsx(
              Gje,
              {
                splitnodesettingsPath: (
                  // all but first element
                  t.slice(1)
                )
              }
            )
          }
        ),
        /* @__PURE__ */ E.jsx(
          ax,
          {
            value: "outputs",
            className: "nodesettings-tabs-content nodesettings-io-list",
            children: /* @__PURE__ */ E.jsx(
              Kje,
              {
                splitnodesettingsPath: (
                  // all but first element
                  t.slice(1)
                )
              }
            )
          }
        )
      ]
    }
  );
}, Yje = M.memo(
  ({ isOpen: e, onOpenChange: t, nodeSettingsPath: n }) => {
    const r = ki().use((a) => a.id);
    return /* @__PURE__ */ E.jsx(
      Pl,
      {
        title: `Node Settings: ${r}`,
        open: e,
        onOpenChange: t,
        dialogClassName: "nodesettings-dialog",
        children: /* @__PURE__ */ E.jsx(Xje, { nodeSettingsPath: n })
      }
    );
  }
), Qje = M.memo(({ toogleShowSettings: e }) => {
  const t = yn(), { node: n } = xa(), r = ki(), { id: a, description: s, node_name: l } = r.useShallow((d) => ({
    id: d.id,
    description: d.description,
    node_name: d.node_name
  })), c = M.useCallback(() => {
    t.on_node_action({
      type: "trigger",
      from_remote: !1,
      id: a
    });
  }, [t, a]);
  return /* @__PURE__ */ E.jsxs("div", { className: "nodeheader", title: s || l, children: [
    /* @__PURE__ */ E.jsxs("div", { className: "nodeheader_element", children: [
      /* @__PURE__ */ E.jsx(
        gae,
        {
          fontSize: "inherit",
          className: "triggerbutton nodeheaderbutton ",
          onClick: c
        }
      ),
      /* @__PURE__ */ E.jsx(
        hae,
        {
          fontSize: "inherit",
          className: "nodestatusbutton nodeheaderbutton",
          onClick: async () => {
            n && console.log("nodestatus", await n.get_node_status(a));
          }
        }
      ),
      /* @__PURE__ */ E.jsx(
        yae,
        {
          fontSize: "inherit",
          className: "nodesettingsbutton nodeheaderbutton",
          onClick: () => {
            e?.();
          }
        }
      )
    ] }),
    /* @__PURE__ */ E.jsx("div", { className: "nodeheader_element nodeheader_title", children: /* @__PURE__ */ E.jsx("div", { className: "nodeheader_title_text", children: l }) }),
    /* @__PURE__ */ E.jsx("div", { className: "nodeheader_element", children: /* @__PURE__ */ E.jsx(sS, { fontSize: "inherit" }) })
  ] });
}), Jje = M.memo(({ iostore: e }) => {
  const t = e.use(), n = ki().use((l) => l.render_options), r = SS(t.id), [a, s] = gje(t);
  return /* @__PURE__ */ E.jsx(
    "div",
    {
      className: "nodrag nodedatabody",
      "data-src": n?.data?.src || "",
      children: a && t && /* @__PURE__ */ E.jsx(dd.Provider, { value: e, children: /* @__PURE__ */ E.jsx(
        Pl,
        {
          title: t.full_id,
          trigger: /* @__PURE__ */ E.jsx("div", { className: "nodedatabutton", children: /* @__PURE__ */ E.jsx(Qq, { Component: a }) }),
          onOpenChange: (l) => {
            l && r?.();
          },
          children: s && /* @__PURE__ */ E.jsx(Yq, { Component: s, iostore: e })
        }
      ) })
    }
  );
}), Zje = M.memo(
  ({ setShowSettings: e, setNodeSettingsPath: t }) => {
    const n = ki(), { render_options: r, outputs: a, inputs: s } = n.useShallow(
      (c) => ({
        render_options: c.render_options,
        outputs: c.outputs,
        inputs: c.inputs
      })
    ), l = r?.data?.src ? n.io_stores.get(r?.data?.src) : void 0;
    return /* @__PURE__ */ E.jsxs("div", { className: "nodebody nowheel ", children: [
      a.map((c) => {
        const d = n.io_stores.get(c);
        if (d)
          return /* @__PURE__ */ E.jsx(dd.Provider, { value: d, children: /* @__PURE__ */ E.jsx(
            wje,
            {
              setNodeSettingsPath: t,
              setShowSettings: e
            }
          ) }, c);
      }),
      l && /* @__PURE__ */ E.jsx(Jje, { iostore: l }),
      s.map((c) => {
        const d = n.io_stores.get(c);
        if (d)
          return /* @__PURE__ */ E.jsx(dd.Provider, { value: d, children: /* @__PURE__ */ E.jsx(
            bje,
            {
              setNodeSettingsPath: t,
              setShowSettings: e
            }
          ) }, c);
      })
    ] });
  }
), R4 = () => {
  const e = ki(), { original_name: t, id: n } = e.useShallow((d) => ({
    original_name: d.name,
    id: d.id
  })), [r, a] = M.useState(t);
  M.useEffect(() => {
    a(t);
  }, [t]);
  const s = yn(), l = (d) => {
    a(d.target.value);
  }, c = (d) => {
    const p = d.target.value;
    p !== t && s.on_node_action({
      type: "update",
      from_remote: !1,
      id: n,
      node: { name: p }
    });
  };
  return /* @__PURE__ */ E.jsx(
    "input",
    {
      className: "nodename_input",
      value: r,
      onChange: l,
      onBlur: c
    }
  );
}, ePe = () => {
  const e = ki().use((t) => t.progress);
  return e ? /* @__PURE__ */ E.jsx(
    ice,
    {
      state: e,
      className: "nodeprogress"
    }
  ) : null;
}, tPe = M.memo(() => {
  const e = ki().use((t) => t.error);
  return /* @__PURE__ */ E.jsxs("div", { className: "nodefooter", children: [
    e && /* @__PURE__ */ E.jsx("div", { className: "nodeerror", children: e }),
    /* @__PURE__ */ E.jsx(ePe, {})
  ] });
}), nPe = () => {
  const e = ki(), { collapsed: t, error: n, node_id: r } = e.useShallow((y) => ({
    collapsed: y.properties["frontend:collapsed"] || !1,
    error: y.error,
    node_id: y.node_id
  })), { visualTrigger: a } = yje(e), [s, l] = M.useState(!1), [c, d] = M.useState(""), { keys: p } = OR(), m = M.useContext($c).NodeHooks[r] ?? [], h = M.useCallback(() => {
    l((y) => !y);
  }, []), v = (y) => {
    p.has("s") && !s && (d(""), l(!0), y.stopPropagation());
  };
  return /* @__PURE__ */ E.jsxs(
    "div",
    {
      className: "innernode" + (a ? " intrigger" : "") + (n ? " error" : ""),
      onClick: v,
      children: [
        /* @__PURE__ */ E.jsx(Qje, { toogleShowSettings: h }),
        /* @__PURE__ */ E.jsx(R4, {}),
        t ? null : /* @__PURE__ */ E.jsx(
          Zje,
          {
            setNodeSettingsPath: d,
            setShowSettings: l
          }
        ),
        /* @__PURE__ */ E.jsx(tPe, {}),
        /* @__PURE__ */ E.jsx(
          Yje,
          {
            isOpen: s,
            onOpenChange: l,
            nodeSettingsPath: c
          }
        ),
        m.map((y, w) => /* @__PURE__ */ E.jsx(M.Fragment, { children: /* @__PURE__ */ E.jsx(y, {}) }, w))
      ]
    }
  );
}, rPe = M.memo(
  ({ data: e }) => /* @__PURE__ */ E.jsx(Q2.Provider, { value: e.nodestore, children: /* @__PURE__ */ E.jsx(nPe, {}) }),
  (e, t) => e.data.nodestore === t.data.nodestore
), oPe = ({
  id: e,
  sourceX: t,
  sourceY: n,
  targetX: r,
  targetY: a,
  sourcePosition: s,
  targetPosition: l,
  data: c,
  ...d
}) => {
  const [p] = fA({
    sourceX: t,
    sourceY: n,
    sourcePosition: s,
    targetX: r,
    targetY: a,
    targetPosition: l
  });
  return /* @__PURE__ */ E.jsx(E.Fragment, { children: /* @__PURE__ */ E.jsx(xS, { id: e, path: p, ...d }) });
}, aPe = {
  default: rPe,
  group: awe
}, iPe = {
  default: oPe
}, sPe = (e) => ({
  nodes: e.getNodes(),
  edges: e.getEdges(),
  onNodesChange: e.onNodesChange,
  onEdgesChange: e.onEdgesChange,
  onConnect: e.onConnect
}), A4 = (e) => {
  const t = /* @__PURE__ */ new Set(), n = e.filter(
    (a) => a.type === "group"
  );
  n.forEach((a) => {
    t.add(a.id);
  });
  const r = e.filter(
    (a) => !t.has(a.id)
  );
  return { group_nodes: n, default_nodes: r };
};
function j4(e) {
  const t = new Map(e.map((l) => [l.id, l])), n = /* @__PURE__ */ new Map(), r = [];
  for (const l of e)
    if (n.has(l.id) || n.set(l.id, []), l.parentId && t.has(l.parentId)) {
      const c = t.get(l.parentId);
      if (c) {
        const d = n.get(c.id) || [];
        d.push(l), n.set(c.id, d);
      } else
        r.push(l);
    } else
      r.push(l);
  const a = [];
  function s(l) {
    a.push(l);
    const c = n.get(l.id) || [];
    for (const d of c)
      s(d);
  }
  for (const l of r)
    s(l);
  if (a.length !== e.length) {
    console.warn(
      "Sorting mismatch: Not all nodes could be placed. Check for circular dependencies or missing parents."
    );
    const l = new Set(a.map((c) => c.id));
    e.forEach((c) => {
      l.has(c.id) || a.push(c);
    });
  }
  return a;
}
const yW = () => {
  const { getNodes: e } = Sm();
  return {
    getNodes: e,
    getSelectedNodes: (t) => (t === void 0 && (t = e()), t.filter((n) => n.selected)),
    getSplitNodes: (t) => {
      t === void 0 && (t = e());
      const { group_nodes: n, default_nodes: r } = A4(t);
      return { group_nodes: n, default_nodes: r };
    },
    getSortedNodes: (t) => (t === void 0 && (t = e()), j4(t))
  };
}, bW = (e, t) => {
  const n = e.getState(), { new_obj: r, change: a } = rd(n, t);
  a && e.setState(r);
}, wW = (e) => ji(e);
function mz(e) {
  return e != null && typeof e == "object" && "id" in e && typeof e.id == "string";
}
const xW = (e) => {
  let t = e.io ?? {}, n = e.io_order, r = [];
  const a = {};
  if (n === void 0)
    if (Array.isArray(t)) {
      const s = t.filter(mz);
      r = s.map((l) => l.id);
      for (const l of s)
        a[l.id] = l;
    } else {
      r = Object.keys(t);
      for (const s in t)
        t[s] !== void 0 && (a[s] = t[s]);
    }
  else if (r = n, Array.isArray(t)) {
    const s = t.filter(mz);
    for (const l of s)
      a[l.id] = l, r.includes(l.id) || r.push(l.id);
  } else
    for (const s in t)
      t[s] !== void 0 && (a[s] = t[s]), r.includes(s) || r.push(s);
  return { ...e, io_order: r, io: a };
}, lPe = {
  id: "dummy",
  node_id: "dummy",
  node_name: "dummy",
  properties: {
    "frontend:size": [200, 100],
    "frontend:pos": [NaN, NaN],
    "frontend:collapsed": !1
  },
  io: {},
  io_order: [],
  name: "dummy",
  in_trigger: !1,
  reset_inputs_on_trigger: !1,
  progress: {
    ascii: !1,
    elapsed: 0,
    initial: 0,
    n: 0,
    prefix: "idle",
    unit: "it",
    unit_divisor: 1e3,
    unit_scale: !1
  }
}, uPe = {
  id: "dummy",
  name: "dummy",
  node: "dummy",
  full_id: "dummy",
  type: "any",
  value: void 0,
  is_input: !1,
  connected: !1,
  does_trigger: !0,
  fullvalue: void 0,
  render_options: {
    set_default: !0,
    type: "any"
  },
  hidden: !1,
  emit_value_set: !0,
  required: !1
}, cPe = H_(lPe), dPe = H_(uPe), fPe = (e) => {
  const t = e.io_order;
  if (t === void 0)
    throw new Error("Node must have io_order");
  return {
    ...e,
    inputs: Object.keys(e.io).filter((n) => e.io[n].is_input),
    outputs: Object.keys(e.io).filter((n) => !e.io[n].is_input),
    io_order: t
  };
}, pPe = (e) => (e.value === "<NoValue>" && (e.value = void 0), e.fullvalue === "<NoValue>" && (e.fullvalue = void 0), e.hidden === void 0 && (e.hidden = !1), [{
  ...e
}, e.value, e.fullvalue]), mPe = (e) => {
  if (!e.id)
    throw new Error("Node must have an id");
  const t = cPe(e);
  return fPe(t);
}, hPe = (e, t) => {
  const n = e.getState(), r = {}, a = xW(t), s = Object.keys(a);
  for (const l of s)
    switch (l) {
      case "id": {
        const [c, d] = Oi(
          n[l],
          a[l]
        );
        d && (r[l] = c);
        break;
      }
      case "node_id": {
        const [c, d] = Oi(
          n[l],
          a[l]
        );
        d && (r[l] = c);
        break;
      }
      case "node_name": {
        const [c, d] = Oi(
          n[l],
          a[l]
        );
        d && (r[l] = c);
        break;
      }
      case "name": {
        const [c, d] = Oi(
          n[l],
          a[l]
        );
        d && (r[l] = c);
        break;
      }
      case "in_trigger": {
        const [c, d] = Oi(
          n[l],
          a[l]
        );
        d && (r[l] = c);
        break;
      }
      case "error": {
        a[l] !== n[l] && (r[l] = a[l]);
        break;
      }
      case "render_options": {
        const [c, d] = ch(
          n[l],
          a[l]
        );
        d && (r[l] = c);
        break;
      }
      case "io_order": {
        const [c, d] = ((p, m) => m === void 0 ? [p, !1] : [m, !T3(p, m)])(n[l], a[l]);
        d && (r[l] = c.filter((p) => p !== void 0));
        break;
      }
      case "io": {
        const c = a[l];
        if (c === void 0) break;
        for (const d in c) {
          const p = e.io_stores.get(d);
          if (!p) {
            console.error("io key not found in oldvalue:", d);
            continue;
          }
          p.update(c[d]);
        }
        break;
      }
      case "progress": {
        const [c, d] = ch(
          n[l],
          a[l]
        );
        d && (r[l] = c);
        break;
      }
      case "description": {
        r[l] = a[l];
        break;
      }
      case "properties": {
        const [c, d] = ch(
          n[l],
          a[l]
        );
        d && (r[l] = c);
        break;
      }
      case "status": {
        const [c, d] = ch(
          n[l],
          a[l]
        );
        d && (r[l] = c);
        break;
      }
      case "reset_inputs_on_trigger": {
        const [c, d] = Oi(
          n[l],
          a[l]
        );
        d && (r[l] = c);
        break;
      }
      default:
        try {
          k1(l, a[l]);
        } catch (c) {
          console.error(c);
        }
    }
  Object.keys(r).length > 0 && e.setState(r);
}, gPe = (e, t) => {
  const n = e.getState(), r = {}, a = {}, s = Object.keys(t);
  for (const l of s)
    switch (l) {
      case "name": {
        const [c, d] = Oi(
          n[l],
          t[l]
        );
        d && (r[l] = c);
        break;
      }
      case "id": {
        const [c, d] = Oi(
          n[l],
          t[l]
        );
        d && (r[l] = c);
        break;
      }
      case "connected": {
        const [c, d] = Oi(
          n[l],
          t[l]
        );
        d && (r[l] = c);
        break;
      }
      case "does_trigger": {
        const [c, d] = Oi(
          n[l],
          t[l]
        );
        d && (r[l] = c);
        break;
      }
      case "hidden": {
        const [c, d] = Oi(
          n[l],
          t[l]
        );
        d && (r[l] = c);
        break;
      }
      case "full_id": {
        const [c, d] = Oi(
          n[l],
          t[l]
        );
        d && (r[l] = c);
        break;
      }
      case "is_input":
        break;
      case "node":
        break;
      case "type":
        break;
      case "value": {
        a.preview = t[l];
        break;
      }
      case "fullvalue": {
        a.full = t[l];
        break;
      }
      case "render_options": {
        const [c, d] = ch(
          n[l],
          t[l]
        );
        d && (r[l] = c);
        break;
      }
      case "value_options": {
        const [c, d] = ch(
          n[l],
          t[l]
        );
        d && (r[l] = c);
        break;
      }
      case "valuepreview_type": {
        r[l] = t[l];
        break;
      }
      case "emit_value_set": {
        r[l] = t[l];
        break;
      }
      case "default": {
        r[l] = t[l];
        break;
      }
      case "required": {
        r[l] = t[l];
        break;
      }
      default:
        try {
          k1(l, t[l]);
        } catch (c) {
          console.error(c);
        }
    }
  Object.keys(a).length > 0 && e.updateValueStore(a), Object.keys(r).length > 0 && e.setState(r);
}, vPe = (e) => {
  if (!e.id)
    throw new Error(
      "IO must have an id but is missing for " + JSON.stringify(e)
    );
  e.name === void 0 && (e.name = e.id);
  const t = dPe(e);
  return (t.render_options.type === "any" || t.render_options.type === void 0) && (t.render_options.type = t.type), pPe(t);
}, yPe = (e, t) => {
  let n;
  const [r, a, s] = vPe(t);
  return n = {
    io_state: wW((l, c) => r),
    use: (l) => l ? n.io_state(l) : n.io_state(),
    useShallow: (l) => n.io_state(wA(l)),
    getState: () => n.io_state.getState(),
    setState: (l) => {
      n.io_state.setState(l);
    },
    update: (l) => {
      gPe(n, l);
    },
    valuestore: ji((l, c) => {
      let d = a;
      d === "<NoValue>" && (d = void 0), !(d instanceof ml) && d !== void 0 && (d = Yc.fromObject(d));
      let p = s;
      return p === "<NoValue>" && (p = void 0), !(p instanceof ml) && p !== void 0 && (p = Yc.fromObject(p)), {
        preview: d,
        full: p
      };
    }),
    updateValueStore: (l) => {
      n.valuestore.setState((c) => (c.preview && typeof c.preview.dispose == "function" && c.preview.dispose(), c.full && typeof c.full.dispose == "function" && c.full.dispose(), l.preview !== void 0 && l.full === void 0 && (l.full = void 0, c.full = void 0), l.preview !== void 0 && !(l.preview instanceof ml) && (l.preview = Yc.fromObject(l.preview)), l.full !== void 0 && !(l.full instanceof ml) && (l.full = Yc.fromObject(l.full)), { ...c, ...l }));
    },
    node: e,
    serialize: () => {
      const l = n.io_state.getState(), c = n.valuestore.getState();
      return {
        ...l,
        value: c.preview,
        fullvalue: c.full,
        render_options: l.render_options,
        valuepreview_type: l.valuepreview_type,
        emit_value_set: l.emit_value_set
      };
    }
  }, n;
}, bPe = (e) => {
  const t = {
    use: (s) => s ? r.node_state(s) : r.node_state(),
    useShallow: (s) => r.node_state(wA(s)),
    io_stores: /* @__PURE__ */ new Map(),
    getState: () => r.node_state.getState(),
    setState: (s) => {
      r.node_state.setState(s);
    },
    update: (s) => {
      hPe(r, s);
    },
    serialize: () => ({
      ...r.node_state.getState(),
      io: Object.fromEntries(
        Array.from(r.io_stores.entries()).map(([s, l]) => [
          s,
          l.serialize()
        ])
      )
    })
  }, n = xW(e), r = {
    ...t,
    node_state: wW((s, l) => mPe(n))
  }, a = n.io;
  return Object.entries(a).forEach(([s, l]) => {
    l !== void 0 && r.io_stores.set(s, yPe(n.id, l));
  }), r;
}, wPe = () => {
  const e = yn();
  return {
    onSelectionChange: M.useCallback(
      ({ nodes: t, edges: n }) => {
        const { group_nodes: r, default_nodes: a } = A4(t), s = e.local_state.getState();
        e.local_state.setState({
          ...s,
          selected_nodes: a.map((l) => l.id),
          selected_edges: n.map((l) => l.id),
          selected_groups: r.map((l) => l.id)
        });
      },
      [e]
    )
  };
}, xPe = () => {
  const e = Sm(), t = yn();
  return t.rf_instance = e, /* @__PURE__ */ E.jsx(E.Fragment, {});
}, SPe = () => {
  const e = yn(), { getEdges: t } = Sm(), { getSelectedNodes: n } = yW();
  return {
    copySelectedNodes: M.useCallback(() => {
      const r = t(), a = n();
      if (a.length === 0) return;
      const s = { nodes: [], edges: [] };
      for (const d of a) {
        const p = e.nodespace.get_node(d.id, !1);
        p && s.nodes.push(p.serialize());
      }
      const l = new Set(a.map((d) => d.id)), c = r.filter(
        (d) => l.has(d.source) && l.has(d.target)
      );
      for (const d of c)
        !d.sourceHandle || !d.targetHandle || s.edges.push({
          src_nid: d.source,
          src_ioid: d.sourceHandle,
          trg_nid: d.target,
          trg_ioid: d.targetHandle
        });
      navigator.clipboard.writeText(JSON.stringify(s));
    }, [n, t, e])
  };
}, kPe = () => {
  const e = fc("Delete"), t = fc(["Meta+c", "Control+c", "Strg+c"]), n = fc(["Control+g", "Meta+g"]), r = fc(["Control+Alt+g", "Meta+Alt+g"]), a = rwe(), { getEdges: s } = Sm(), { getNodes: l, getSelectedNodes: c, getSplitNodes: d } = yW(), { copySelectedNodes: p } = SPe(), { node: m, group: h, edge: v } = xa();
  return M.useEffect(() => {
    if (e) {
      const y = s().filter((k) => k.selected);
      for (const k of y)
        !k.source || !k.target || !k.sourceHandle || !k.targetHandle || v?.remove_edge({
          src_nid: k.source,
          src_ioid: k.sourceHandle,
          trg_nid: k.target,
          trg_ioid: k.targetHandle
        });
      const w = c(), { group_nodes: x, default_nodes: b } = d(w);
      for (const k of b)
        m?.remove_node(k.id);
      for (const k of x)
        h?.remove_group(k.id);
    }
  }, [e, l, s, m, h, v]), M.useEffect(() => {
    t && p();
  }, [t, p]), M.useEffect(() => {
    if (n) {
      const y = c(), { group_nodes: w, default_nodes: x } = d(y);
      y.length > 0 && a(
        x.map((b) => b.id),
        w.map((b) => b.id)
      );
    }
  }, [n, l]), M.useEffect(() => {
    if (r) {
      const y = c(), { group_nodes: w } = d(y);
      w.forEach((x) => {
        h?.remove_group(x.id);
      });
    }
  }, [r, l]), /* @__PURE__ */ E.jsx(E.Fragment, {});
}, _Pe = () => {
  const { node: e, edge: t } = xa(), n = yn();
  return M.useCallback(
    async (r, a) => {
      try {
        if (!r || !e || !t) return;
        const s = JSON.parse(r);
        if (!s || !n.worker || !s.nodes) return;
        const l = [0, 0];
        for (const d of s.nodes)
          l[0] += d.properties["frontend:pos"][0], l[1] += d.properties["frontend:pos"][1];
        l[0] /= s.nodes.length, l[1] /= s.nodes.length;
        const c = [];
        for (const d of s.nodes) {
          const p = {
            id: d.node_id,
            src_id: d.id,
            position: [
              d.properties["frontend:pos"][0] - l[0],
              d.properties["frontend:pos"][1] - l[1]
            ]
          };
          c.push(p);
        }
        for (const d of c) {
          const p = await e.add_node(d.id);
          !p || !n.nodespace.get_node(p.id, !1) || (d.new_id = p.id, a([
            {
              id: p.id,
              type: "position",
              position: {
                x: d.position[0] + p.properties["frontend:pos"][0],
                y: d.position[1] + p.properties["frontend:pos"][1]
              }
            }
          ]));
        }
        for (const d of s.edges) {
          const p = c.find(
            (h) => h.src_id === d.src_nid
          ), m = c.find(
            (h) => h.src_id === d.trg_nid
          );
          !p || !m || !p.new_id || !m.new_id || t.add_edge({
            src_nid: p.new_id,
            src_ioid: d.src_ioid,
            trg_nid: m.new_id,
            trg_ioid: d.trg_ioid
          });
        }
      } catch (s) {
        console.error("Failed to process pasted data:", s);
      }
    },
    [e, t, n]
  );
}, EPe = (e, t) => {
  const n = e.properties || {};
  n["frontend:size"] || (n["frontend:size"] = [200, 100]);
  const r = n["frontend:pos"];
  if (!r || r.length !== 2 || isNaN(r[0]) || r[0] === null || isNaN(r[1]) || r[1] === null)
    if (!t || !t.rf_instance || t.reactflowRef === null)
      n["frontend:pos"] = [0, 0];
    else {
      const a = t.reactflowRef.getBoundingClientRect(), s = a.left + a.width / 2, l = a.top + a.height / 2, c = t.rf_instance.screenToFlowPosition({
        x: s,
        y: l
      });
      n["frontend:pos"] = [
        c.x - n["frontend:size"][0] / 2,
        c.y - n["frontend:size"][0] / 2
      ];
    }
  n["frontend:collapsed"] || (n["frontend:collapsed"] = !1), e.properties = n;
}, CPe = (e, t) => {
  const n = e.getState();
  if (EPe(n, t), n.id === void 0)
    throw new Error("Node must have an id");
  const r = {
    nodestore: e
  };
  return {
    position: {
      x: n.properties["frontend:pos"][0],
      y: n.properties["frontend:pos"][1]
    },
    data: r,
    type: "default",
    zIndex: 1003,
    // expandParent: true,
    ...n
  };
}, hz = {
  default: ya.Dots,
  metal: ya.Cross,
  light: ya.Dots,
  solarized: ya.Dots,
  midnight: ya.Dots,
  forest: ya.Dots,
  scientific: ya.Lines
}, OPe = (e) => {
  const t = yn(), n = M.useRef(null), { colorTheme: r } = n8(), { onSelectionChange: a } = wPe(), s = tde();
  M.useEffect(() => {
    t.getStateManager().toaster = s;
  }, []), M.useEffect(() => {
    t.reactflowRef = n.current;
  }, [n]);
  const { nodes: l, edges: c, onNodesChange: d, onEdgesChange: p, onConnect: m } = t.useReactFlowStore(wA(sPe)), h = _Pe(), v = M.useCallback(
    (y) => {
      const w = n.current;
      if (!w) return;
      let x = y.target, b = 0;
      for (; x && x.parentElement && x !== w; )
        b++, x = x.parentElement;
      t.logger.debug(`onPasteCapture: ${b} steps to reactflow`), b <= 2 && h(
        y.clipboardData.getData("text/plain"),
        d
      );
    },
    [h, d, t.logger]
  );
  return /* @__PURE__ */ E.jsx("div", { className: "reactflowlayer", children: /* @__PURE__ */ E.jsxs(
    Obe,
    {
      onPasteCapture: v,
      nodes: l,
      edges: c,
      onNodesChange: d,
      onEdgesChange: p,
      onConnect: m,
      nodeTypes: aPe,
      edgeTypes: iPe,
      minZoom: e.minZoom,
      maxZoom: e.maxZoom,
      fitView: !0,
      onSelectionChange: a,
      ref: n,
      panOnDrag: !e.static,
      children: [
        /* @__PURE__ */ E.jsx(xPe, {}),
        /* @__PURE__ */ E.jsx(kPe, {}),
        /* @__PURE__ */ E.jsx(
          jbe,
          {
            color: "#888",
            gap: 24,
            size: 2,
            variant: hz[r] || hz.default,
            patternClassName: "fn-background-pattern"
          }
        ),
        e.minimap && /* @__PURE__ */ E.jsx(
          Qbe,
          {
            nodeStrokeWidth: 3,
            pannable: !e.static,
            zoomable: !e.static,
            zoomStep: 3
          }
        )
      ]
    }
  ) });
}, MPe = ({
  on_node_change: e,
  on_edge_change: t,
  on_connect: n
}) => {
  const r = e || ((l) => {
  }), a = t || ((l) => {
  }), s = n || ((l) => {
  });
  return ji((l, c) => ({
    _nodes: [],
    _edges: [],
    _nodes_map: /* @__PURE__ */ new Map(),
    update_nodes: (d) => {
      d = j4(d), l({
        _nodes: d,
        _nodes_map: new Map(d.map((p) => [p.id, p]))
      });
    },
    partial_update_nodes: (d) => {
      const p = c(), m = p._nodes, h = new Map(
        m.map((v) => [v.id, v])
      );
      for (const v of d)
        h.set(v.id, v);
      p.update_nodes(Array.from(h.values()));
    },
    update_edges: (d) => {
      l({
        _edges: d
      });
    },
    onNodesChange: (d) => {
      const p = c();
      p.update_nodes(yA(d, p._nodes)), r(d);
    },
    onEdgesChange: (d) => {
      l({
        _edges: MU(d, c()._edges)
      }), a(d);
    },
    onConnect: (d) => {
      d.source == null || d.target == null || s(d);
    },
    getNode: (d) => c()._nodes_map.get(d),
    getNodes: () => c()._nodes,
    getEdges: () => c()._edges
  }));
}, NPe = () => {
  const e = yn().progress_state();
  return /* @__PURE__ */ E.jsxs("div", { className: "statusbar", children: [
    /* @__PURE__ */ E.jsx(
      "span",
      {
        className: "statusbar-progressbar",
        style: { width: Math.min(100, 100 * e.progress) + "%" }
      }
    ),
    /* @__PURE__ */ E.jsx("span", { className: "statusbar-message", children: e.message })
  ] });
}, Ux = () => window?._FUNCNODES_DEV ?? !1;
var w3 = ["Enter", " "], RPe = ["ArrowDown", "PageUp", "Home"], SW = ["ArrowUp", "PageDown", "End"], APe = [...RPe, ...SW], jPe = {
  ltr: [...w3, "ArrowRight"],
  rtl: [...w3, "ArrowLeft"]
}, PPe = {
  ltr: ["ArrowLeft"],
  rtl: ["ArrowRight"]
}, $S = "Menu", [Vx, DPe, $Pe] = A2($S), [Pm, kW] = jl($S, [
  $Pe,
  M2,
  CE
]), TS = M2(), _W = CE(), [EW, Dm] = Pm($S), [TPe, LS] = Pm($S), CW = (e) => {
  const { __scopeMenu: t, open: n = !1, children: r, dir: a, onOpenChange: s, modal: l = !0 } = e, c = TS(t), [d, p] = M.useState(null), m = M.useRef(!1), h = Ra(s), v = Z2(a);
  return M.useEffect(() => {
    const y = () => {
      m.current = !0, document.addEventListener("pointerdown", w, { capture: !0, once: !0 }), document.addEventListener("pointermove", w, { capture: !0, once: !0 });
    }, w = () => m.current = !1;
    return document.addEventListener("keydown", y, { capture: !0 }), () => {
      document.removeEventListener("keydown", y, { capture: !0 }), document.removeEventListener("pointerdown", w, { capture: !0 }), document.removeEventListener("pointermove", w, { capture: !0 });
    };
  }, []), /* @__PURE__ */ E.jsx(LR, { ...c, children: /* @__PURE__ */ E.jsx(
    EW,
    {
      scope: t,
      open: n,
      onOpenChange: h,
      content: d,
      onContentChange: p,
      children: /* @__PURE__ */ E.jsx(
        TPe,
        {
          scope: t,
          onClose: M.useCallback(() => h(!1), [h]),
          isUsingKeyboardRef: m,
          dir: v,
          modal: l,
          children: r
        }
      )
    }
  ) });
};
CW.displayName = $S;
var LPe = "MenuAnchor", P4 = M.forwardRef(
  (e, t) => {
    const { __scopeMenu: n, ...r } = e, a = TS(n);
    return /* @__PURE__ */ E.jsx(IR, { ...a, ...r, ref: t });
  }
);
P4.displayName = LPe;
var IPe = "MenuPortal", [j9e, OW] = Pm(IPe, {
  forceMount: void 0
}), Pi = "MenuContent", [zPe, D4] = Pm(Pi), MW = M.forwardRef(
  (e, t) => {
    const n = OW(Pi, e.__scopeMenu), { forceMount: r = n.forceMount, ...a } = e, s = Dm(Pi, e.__scopeMenu), l = LS(Pi, e.__scopeMenu);
    return /* @__PURE__ */ E.jsx(Vx.Provider, { scope: e.__scopeMenu, children: /* @__PURE__ */ E.jsx(Hs, { present: r || s.open, children: /* @__PURE__ */ E.jsx(Vx.Slot, { scope: e.__scopeMenu, children: l.modal ? /* @__PURE__ */ E.jsx(FPe, { ...a, ref: t }) : /* @__PURE__ */ E.jsx(BPe, { ...a, ref: t }) }) }) });
  }
), FPe = M.forwardRef(
  (e, t) => {
    const n = Dm(Pi, e.__scopeMenu), r = M.useRef(null), a = Wn(t, r);
    return M.useEffect(() => {
      const s = r.current;
      if (s) return cR(s);
    }, []), /* @__PURE__ */ E.jsx(
      $4,
      {
        ...e,
        ref: a,
        trapFocus: n.open,
        disableOutsidePointerEvents: n.open,
        disableOutsideScroll: !0,
        onFocusOutside: Ze(
          e.onFocusOutside,
          (s) => s.preventDefault(),
          { checkForDefaultPrevented: !1 }
        ),
        onDismiss: () => n.onOpenChange(!1)
      }
    );
  }
), BPe = M.forwardRef((e, t) => {
  const n = Dm(Pi, e.__scopeMenu);
  return /* @__PURE__ */ E.jsx(
    $4,
    {
      ...e,
      ref: t,
      trapFocus: !1,
      disableOutsidePointerEvents: !1,
      disableOutsideScroll: !1,
      onDismiss: () => n.onOpenChange(!1)
    }
  );
}), UPe = /* @__PURE__ */ Ah("MenuContent.ScrollLock"), $4 = M.forwardRef(
  (e, t) => {
    const {
      __scopeMenu: n,
      loop: r = !1,
      trapFocus: a,
      onOpenAutoFocus: s,
      onCloseAutoFocus: l,
      disableOutsidePointerEvents: c,
      onEntryFocus: d,
      onEscapeKeyDown: p,
      onPointerDownOutside: m,
      onFocusOutside: h,
      onInteractOutside: v,
      onDismiss: y,
      disableOutsideScroll: w,
      ...x
    } = e, b = Dm(Pi, n), k = LS(Pi, n), C = TS(n), _ = _W(n), O = DPe(n), [N, R] = M.useState(null), j = M.useRef(null), D = Wn(t, j, b.onContentChange), $ = M.useRef(0), z = M.useRef(""), B = M.useRef(0), P = M.useRef(null), W = M.useRef("right"), I = M.useRef(0), G = w ? v2 : M.Fragment, L = w ? { as: UPe, allowPinchZoom: !0 } : void 0, K = (Z) => {
      const V = z.current + Z, F = O().filter((de) => !de.disabled), X = document.activeElement, U = F.find((de) => de.ref.current === X)?.textValue, H = F.map((de) => de.textValue), Q = eDe(H, V, U), re = F.find((de) => de.textValue === Q)?.ref.current;
      (function de(le) {
        z.current = le, window.clearTimeout($.current), le !== "" && ($.current = window.setTimeout(() => de(""), 1e3));
      })(V), re && setTimeout(() => re.focus());
    };
    M.useEffect(() => () => window.clearTimeout($.current), []), uR();
    const q = M.useCallback((Z) => W.current === P.current?.side && nDe(Z, P.current?.area), []);
    return /* @__PURE__ */ E.jsx(
      zPe,
      {
        scope: n,
        searchRef: z,
        onItemEnter: M.useCallback(
          (Z) => {
            q(Z) && Z.preventDefault();
          },
          [q]
        ),
        onItemLeave: M.useCallback(
          (Z) => {
            q(Z) || (j.current?.focus(), R(null));
          },
          [q]
        ),
        onTriggerLeave: M.useCallback(
          (Z) => {
            q(Z) && Z.preventDefault();
          },
          [q]
        ),
        pointerGraceTimerRef: B,
        onPointerGraceIntentChange: M.useCallback((Z) => {
          P.current = Z;
        }, []),
        children: /* @__PURE__ */ E.jsx(G, { ...L, children: /* @__PURE__ */ E.jsx(
          m2,
          {
            asChild: !0,
            trapped: a,
            onMountAutoFocus: Ze(s, (Z) => {
              Z.preventDefault(), j.current?.focus({ preventScroll: !0 });
            }),
            onUnmountAutoFocus: l,
            children: /* @__PURE__ */ E.jsx(
              rS,
              {
                asChild: !0,
                disableOutsidePointerEvents: c,
                onEscapeKeyDown: p,
                onPointerDownOutside: m,
                onFocusOutside: h,
                onInteractOutside: v,
                onDismiss: y,
                children: /* @__PURE__ */ E.jsx(
                  iW,
                  {
                    asChild: !0,
                    ..._,
                    dir: k.dir,
                    orientation: "vertical",
                    loop: r,
                    currentTabStopId: N,
                    onCurrentTabStopIdChange: R,
                    onEntryFocus: Ze(d, (Z) => {
                      k.isUsingKeyboardRef.current || Z.preventDefault();
                    }),
                    preventScrollOnEntryFocus: !0,
                    children: /* @__PURE__ */ E.jsx(
                      O8,
                      {
                        role: "menu",
                        "aria-orientation": "vertical",
                        "data-state": qW(b.open),
                        "data-radix-menu-content": "",
                        dir: k.dir,
                        ...C,
                        ...x,
                        ref: D,
                        style: { outline: "none", ...x.style },
                        onKeyDown: Ze(x.onKeyDown, (Z) => {
                          const V = Z.target.closest("[data-radix-menu-content]") === Z.currentTarget, F = Z.ctrlKey || Z.altKey || Z.metaKey, X = Z.key.length === 1;
                          V && (Z.key === "Tab" && Z.preventDefault(), !F && X && K(Z.key));
                          const U = j.current;
                          if (Z.target !== U || !APe.includes(Z.key)) return;
                          Z.preventDefault();
                          const H = O().filter((Q) => !Q.disabled).map((Q) => Q.ref.current);
                          SW.includes(Z.key) && H.reverse(), JPe(H);
                        }),
                        onBlur: Ze(e.onBlur, (Z) => {
                          Z.currentTarget.contains(Z.target) || (window.clearTimeout($.current), z.current = "");
                        }),
                        onPointerMove: Ze(
                          e.onPointerMove,
                          Hx((Z) => {
                            const V = Z.target, F = I.current !== Z.clientX;
                            if (Z.currentTarget.contains(V) && F) {
                              const X = Z.clientX > I.current ? "right" : "left";
                              W.current = X, I.current = Z.clientX;
                            }
                          })
                        )
                      }
                    )
                  }
                )
              }
            )
          }
        ) })
      }
    );
  }
);
MW.displayName = Pi;
var VPe = "MenuGroup", T4 = M.forwardRef(
  (e, t) => {
    const { __scopeMenu: n, ...r } = e;
    return /* @__PURE__ */ E.jsx(Kt.div, { role: "group", ...r, ref: t });
  }
);
T4.displayName = VPe;
var HPe = "MenuLabel", NW = M.forwardRef(
  (e, t) => {
    const { __scopeMenu: n, ...r } = e;
    return /* @__PURE__ */ E.jsx(Kt.div, { ...r, ref: t });
  }
);
NW.displayName = HPe;
var I_ = "MenuItem", gz = "menu.itemSelect", ME = M.forwardRef(
  (e, t) => {
    const { disabled: n = !1, onSelect: r, ...a } = e, s = M.useRef(null), l = LS(I_, e.__scopeMenu), c = D4(I_, e.__scopeMenu), d = Wn(t, s), p = M.useRef(!1), m = () => {
      const h = s.current;
      if (!n && h) {
        const v = new CustomEvent(gz, { bubbles: !0, cancelable: !0 });
        h.addEventListener(gz, (y) => r?.(y), { once: !0 }), lR(h, v), v.defaultPrevented ? p.current = !1 : l.onClose();
      }
    };
    return /* @__PURE__ */ E.jsx(
      RW,
      {
        ...a,
        ref: d,
        disabled: n,
        onClick: Ze(e.onClick, m),
        onPointerDown: (h) => {
          e.onPointerDown?.(h), p.current = !0;
        },
        onPointerUp: Ze(e.onPointerUp, (h) => {
          p.current || h.currentTarget?.click();
        }),
        onKeyDown: Ze(e.onKeyDown, (h) => {
          const v = c.searchRef.current !== "";
          n || v && h.key === " " || w3.includes(h.key) && (h.currentTarget.click(), h.preventDefault());
        })
      }
    );
  }
);
ME.displayName = I_;
var RW = M.forwardRef(
  (e, t) => {
    const { __scopeMenu: n, disabled: r = !1, textValue: a, ...s } = e, l = D4(I_, n), c = _W(n), d = M.useRef(null), p = Wn(t, d), [m, h] = M.useState(!1), [v, y] = M.useState("");
    return M.useEffect(() => {
      const w = d.current;
      w && y((w.textContent ?? "").trim());
    }, [s.children]), /* @__PURE__ */ E.jsx(
      Vx.ItemSlot,
      {
        scope: n,
        disabled: r,
        textValue: a ?? v,
        children: /* @__PURE__ */ E.jsx(sW, { asChild: !0, ...c, focusable: !r, children: /* @__PURE__ */ E.jsx(
          Kt.div,
          {
            role: "menuitem",
            "data-highlighted": m ? "" : void 0,
            "aria-disabled": r || void 0,
            "data-disabled": r ? "" : void 0,
            ...s,
            ref: p,
            onPointerMove: Ze(
              e.onPointerMove,
              Hx((w) => {
                r ? l.onItemLeave(w) : (l.onItemEnter(w), w.defaultPrevented || w.currentTarget.focus({ preventScroll: !0 }));
              })
            ),
            onPointerLeave: Ze(
              e.onPointerLeave,
              Hx((w) => l.onItemLeave(w))
            ),
            onFocus: Ze(e.onFocus, () => h(!0)),
            onBlur: Ze(e.onBlur, () => h(!1))
          }
        ) })
      }
    );
  }
), qPe = "MenuCheckboxItem", AW = M.forwardRef(
  (e, t) => {
    const { checked: n = !1, onCheckedChange: r, ...a } = e;
    return /* @__PURE__ */ E.jsx(TW, { scope: e.__scopeMenu, checked: n, children: /* @__PURE__ */ E.jsx(
      ME,
      {
        role: "menuitemcheckbox",
        "aria-checked": z_(n) ? "mixed" : n,
        ...a,
        ref: t,
        "data-state": z4(n),
        onSelect: Ze(
          a.onSelect,
          () => r?.(z_(n) ? !0 : !n),
          { checkForDefaultPrevented: !1 }
        )
      }
    ) });
  }
);
AW.displayName = qPe;
var jW = "MenuRadioGroup", [WPe, GPe] = Pm(
  jW,
  { value: void 0, onValueChange: () => {
  } }
), PW = M.forwardRef(
  (e, t) => {
    const { value: n, onValueChange: r, ...a } = e, s = Ra(r);
    return /* @__PURE__ */ E.jsx(WPe, { scope: e.__scopeMenu, value: n, onValueChange: s, children: /* @__PURE__ */ E.jsx(T4, { ...a, ref: t }) });
  }
);
PW.displayName = jW;
var DW = "MenuRadioItem", $W = M.forwardRef(
  (e, t) => {
    const { value: n, ...r } = e, a = GPe(DW, e.__scopeMenu), s = n === a.value;
    return /* @__PURE__ */ E.jsx(TW, { scope: e.__scopeMenu, checked: s, children: /* @__PURE__ */ E.jsx(
      ME,
      {
        role: "menuitemradio",
        "aria-checked": s,
        ...r,
        ref: t,
        "data-state": z4(s),
        onSelect: Ze(
          r.onSelect,
          () => a.onValueChange?.(n),
          { checkForDefaultPrevented: !1 }
        )
      }
    ) });
  }
);
$W.displayName = DW;
var L4 = "MenuItemIndicator", [TW, KPe] = Pm(
  L4,
  { checked: !1 }
), LW = M.forwardRef(
  (e, t) => {
    const { __scopeMenu: n, forceMount: r, ...a } = e, s = KPe(L4, n);
    return /* @__PURE__ */ E.jsx(
      Hs,
      {
        present: r || z_(s.checked) || s.checked === !0,
        children: /* @__PURE__ */ E.jsx(
          Kt.span,
          {
            ...a,
            ref: t,
            "data-state": z4(s.checked)
          }
        )
      }
    );
  }
);
LW.displayName = L4;
var XPe = "MenuSeparator", IW = M.forwardRef(
  (e, t) => {
    const { __scopeMenu: n, ...r } = e;
    return /* @__PURE__ */ E.jsx(
      Kt.div,
      {
        role: "separator",
        "aria-orientation": "horizontal",
        ...r,
        ref: t
      }
    );
  }
);
IW.displayName = XPe;
var YPe = "MenuArrow", zW = M.forwardRef(
  (e, t) => {
    const { __scopeMenu: n, ...r } = e, a = TS(n);
    return /* @__PURE__ */ E.jsx(M8, { ...a, ...r, ref: t });
  }
);
zW.displayName = YPe;
var I4 = "MenuSub", [QPe, FW] = Pm(I4), BW = (e) => {
  const { __scopeMenu: t, children: n, open: r = !1, onOpenChange: a } = e, s = Dm(I4, t), l = TS(t), [c, d] = M.useState(null), [p, m] = M.useState(null), h = Ra(a);
  return M.useEffect(() => (s.open === !1 && h(!1), () => h(!1)), [s.open, h]), /* @__PURE__ */ E.jsx(LR, { ...l, children: /* @__PURE__ */ E.jsx(
    EW,
    {
      scope: t,
      open: r,
      onOpenChange: h,
      content: p,
      onContentChange: m,
      children: /* @__PURE__ */ E.jsx(
        QPe,
        {
          scope: t,
          contentId: _l(),
          triggerId: _l(),
          trigger: c,
          onTriggerChange: d,
          children: n
        }
      )
    }
  ) });
};
BW.displayName = I4;
var Uw = "MenuSubTrigger", UW = M.forwardRef(
  (e, t) => {
    const n = Dm(Uw, e.__scopeMenu), r = LS(Uw, e.__scopeMenu), a = FW(Uw, e.__scopeMenu), s = D4(Uw, e.__scopeMenu), l = M.useRef(null), { pointerGraceTimerRef: c, onPointerGraceIntentChange: d } = s, p = { __scopeMenu: e.__scopeMenu }, m = M.useCallback(() => {
      l.current && window.clearTimeout(l.current), l.current = null;
    }, []);
    return M.useEffect(() => m, [m]), M.useEffect(() => {
      const h = c.current;
      return () => {
        window.clearTimeout(h), d(null);
      };
    }, [c, d]), /* @__PURE__ */ E.jsx(P4, { asChild: !0, ...p, children: /* @__PURE__ */ E.jsx(
      RW,
      {
        id: a.triggerId,
        "aria-haspopup": "menu",
        "aria-expanded": n.open,
        "aria-controls": a.contentId,
        "data-state": qW(n.open),
        ...e,
        ref: p2(t, a.onTriggerChange),
        onClick: (h) => {
          e.onClick?.(h), !(e.disabled || h.defaultPrevented) && (h.currentTarget.focus(), n.open || n.onOpenChange(!0));
        },
        onPointerMove: Ze(
          e.onPointerMove,
          Hx((h) => {
            s.onItemEnter(h), !h.defaultPrevented && !e.disabled && !n.open && !l.current && (s.onPointerGraceIntentChange(null), l.current = window.setTimeout(() => {
              n.onOpenChange(!0), m();
            }, 100));
          })
        ),
        onPointerLeave: Ze(
          e.onPointerLeave,
          Hx((h) => {
            m();
            const v = n.content?.getBoundingClientRect();
            if (v) {
              const y = n.content?.dataset.side, w = y === "right", x = w ? -5 : 5, b = v[w ? "left" : "right"], k = v[w ? "right" : "left"];
              s.onPointerGraceIntentChange({
                area: [
                  // Apply a bleed on clientX to ensure that our exit point is
                  // consistently within polygon bounds
                  { x: h.clientX + x, y: h.clientY },
                  { x: b, y: v.top },
                  { x: k, y: v.top },
                  { x: k, y: v.bottom },
                  { x: b, y: v.bottom }
                ],
                side: y
              }), window.clearTimeout(c.current), c.current = window.setTimeout(
                () => s.onPointerGraceIntentChange(null),
                300
              );
            } else {
              if (s.onTriggerLeave(h), h.defaultPrevented) return;
              s.onPointerGraceIntentChange(null);
            }
          })
        ),
        onKeyDown: Ze(e.onKeyDown, (h) => {
          const v = s.searchRef.current !== "";
          e.disabled || v && h.key === " " || jPe[r.dir].includes(h.key) && (n.onOpenChange(!0), n.content?.focus(), h.preventDefault());
        })
      }
    ) });
  }
);
UW.displayName = Uw;
var VW = "MenuSubContent", HW = M.forwardRef(
  (e, t) => {
    const n = OW(Pi, e.__scopeMenu), { forceMount: r = n.forceMount, ...a } = e, s = Dm(Pi, e.__scopeMenu), l = LS(Pi, e.__scopeMenu), c = FW(VW, e.__scopeMenu), d = M.useRef(null), p = Wn(t, d);
    return /* @__PURE__ */ E.jsx(Vx.Provider, { scope: e.__scopeMenu, children: /* @__PURE__ */ E.jsx(Hs, { present: r || s.open, children: /* @__PURE__ */ E.jsx(Vx.Slot, { scope: e.__scopeMenu, children: /* @__PURE__ */ E.jsx(
      $4,
      {
        id: c.contentId,
        "aria-labelledby": c.triggerId,
        ...a,
        ref: p,
        align: "start",
        side: l.dir === "rtl" ? "left" : "right",
        disableOutsidePointerEvents: !1,
        disableOutsideScroll: !1,
        trapFocus: !1,
        onOpenAutoFocus: (m) => {
          l.isUsingKeyboardRef.current && d.current?.focus(), m.preventDefault();
        },
        onCloseAutoFocus: (m) => m.preventDefault(),
        onFocusOutside: Ze(e.onFocusOutside, (m) => {
          m.target !== c.trigger && s.onOpenChange(!1);
        }),
        onEscapeKeyDown: Ze(e.onEscapeKeyDown, (m) => {
          l.onClose(), m.preventDefault();
        }),
        onKeyDown: Ze(e.onKeyDown, (m) => {
          const h = m.currentTarget.contains(m.target), v = PPe[l.dir].includes(m.key);
          h && v && (s.onOpenChange(!1), c.trigger?.focus(), m.preventDefault());
        })
      }
    ) }) }) });
  }
);
HW.displayName = VW;
function qW(e) {
  return e ? "open" : "closed";
}
function z_(e) {
  return e === "indeterminate";
}
function z4(e) {
  return z_(e) ? "indeterminate" : e ? "checked" : "unchecked";
}
function JPe(e) {
  const t = document.activeElement;
  for (const n of e)
    if (n === t || (n.focus(), document.activeElement !== t)) return;
}
function ZPe(e, t) {
  return e.map((n, r) => e[(t + r) % e.length]);
}
function eDe(e, t, n) {
  const r = t.length > 1 && Array.from(t).every((c) => c === t[0]) ? t[0] : t, a = n ? e.indexOf(n) : -1;
  let s = ZPe(e, Math.max(a, 0));
  r.length === 1 && (s = s.filter((c) => c !== n));
  const l = s.find(
    (c) => c.toLowerCase().startsWith(r.toLowerCase())
  );
  return l !== n ? l : void 0;
}
function tDe(e, t) {
  const { x: n, y: r } = e;
  let a = !1;
  for (let s = 0, l = t.length - 1; s < t.length; l = s++) {
    const c = t[s], d = t[l], p = c.x, m = c.y, h = d.x, v = d.y;
    m > r != v > r && n < (h - p) * (r - m) / (v - m) + p && (a = !a);
  }
  return a;
}
function nDe(e, t) {
  if (!t) return !1;
  const n = { x: e.clientX, y: e.clientY };
  return tDe(n, t);
}
function Hx(e) {
  return (t) => t.pointerType === "mouse" ? e(t) : void 0;
}
var rDe = CW, oDe = P4, aDe = MW, iDe = T4, sDe = NW, lDe = ME, uDe = AW, cDe = PW, dDe = $W, fDe = LW, pDe = IW, mDe = zW, hDe = BW, gDe = UW, vDe = HW, NE = "DropdownMenu", [yDe] = jl(
  NE,
  [kW]
), Sa = kW(), [bDe, WW] = yDe(NE), GW = (e) => {
  const {
    __scopeDropdownMenu: t,
    children: n,
    dir: r,
    open: a,
    defaultOpen: s,
    onOpenChange: l,
    modal: c = !0
  } = e, d = Sa(t), p = M.useRef(null), [m, h] = gd({
    prop: a,
    defaultProp: s ?? !1,
    onChange: l,
    caller: NE
  });
  return /* @__PURE__ */ E.jsx(
    bDe,
    {
      scope: t,
      triggerId: _l(),
      triggerRef: p,
      contentId: _l(),
      open: m,
      onOpenChange: h,
      onOpenToggle: M.useCallback(() => h((v) => !v), [h]),
      modal: c,
      children: /* @__PURE__ */ E.jsx(rDe, { ...d, open: m, onOpenChange: h, dir: r, modal: c, children: n })
    }
  );
};
GW.displayName = NE;
var KW = "DropdownMenuTrigger", XW = M.forwardRef(
  (e, t) => {
    const { __scopeDropdownMenu: n, disabled: r = !1, ...a } = e, s = WW(KW, n), l = Sa(n);
    return /* @__PURE__ */ E.jsx(oDe, { asChild: !0, ...l, children: /* @__PURE__ */ E.jsx(
      Kt.button,
      {
        type: "button",
        id: s.triggerId,
        "aria-haspopup": "menu",
        "aria-expanded": s.open,
        "aria-controls": s.open ? s.contentId : void 0,
        "data-state": s.open ? "open" : "closed",
        "data-disabled": r ? "" : void 0,
        disabled: r,
        ...a,
        ref: p2(t, s.triggerRef),
        onPointerDown: Ze(e.onPointerDown, (c) => {
          !r && c.button === 0 && c.ctrlKey === !1 && (s.onOpenToggle(), s.open || c.preventDefault());
        }),
        onKeyDown: Ze(e.onKeyDown, (c) => {
          r || (["Enter", " "].includes(c.key) && s.onOpenToggle(), c.key === "ArrowDown" && s.onOpenChange(!0), ["Enter", " ", "ArrowDown"].includes(c.key) && c.preventDefault());
        })
      }
    ) });
  }
);
XW.displayName = KW;
var YW = "DropdownMenuContent", QW = M.forwardRef(
  (e, t) => {
    const { __scopeDropdownMenu: n, ...r } = e, a = WW(YW, n), s = Sa(n), l = M.useRef(!1);
    return /* @__PURE__ */ E.jsx(
      aDe,
      {
        id: a.contentId,
        "aria-labelledby": a.triggerId,
        ...s,
        ...r,
        ref: t,
        onCloseAutoFocus: Ze(e.onCloseAutoFocus, (c) => {
          l.current || a.triggerRef.current?.focus(), l.current = !1, c.preventDefault();
        }),
        onInteractOutside: Ze(e.onInteractOutside, (c) => {
          const d = c.detail.originalEvent, p = d.button === 0 && d.ctrlKey === !0, m = d.button === 2 || p;
          (!a.modal || m) && (l.current = !0);
        }),
        style: {
          ...e.style,
          "--radix-dropdown-menu-content-transform-origin": "var(--radix-popper-transform-origin)",
          "--radix-dropdown-menu-content-available-width": "var(--radix-popper-available-width)",
          "--radix-dropdown-menu-content-available-height": "var(--radix-popper-available-height)",
          "--radix-dropdown-menu-trigger-width": "var(--radix-popper-anchor-width)",
          "--radix-dropdown-menu-trigger-height": "var(--radix-popper-anchor-height)"
        }
      }
    );
  }
);
QW.displayName = YW;
var wDe = "DropdownMenuGroup", JW = M.forwardRef(
  (e, t) => {
    const { __scopeDropdownMenu: n, ...r } = e, a = Sa(n);
    return /* @__PURE__ */ E.jsx(iDe, { ...a, ...r, ref: t });
  }
);
JW.displayName = wDe;
var xDe = "DropdownMenuLabel", SDe = M.forwardRef(
  (e, t) => {
    const { __scopeDropdownMenu: n, ...r } = e, a = Sa(n);
    return /* @__PURE__ */ E.jsx(sDe, { ...a, ...r, ref: t });
  }
);
SDe.displayName = xDe;
var kDe = "DropdownMenuItem", ZW = M.forwardRef(
  (e, t) => {
    const { __scopeDropdownMenu: n, ...r } = e, a = Sa(n);
    return /* @__PURE__ */ E.jsx(lDe, { ...a, ...r, ref: t });
  }
);
ZW.displayName = kDe;
var _De = "DropdownMenuCheckboxItem", EDe = M.forwardRef((e, t) => {
  const { __scopeDropdownMenu: n, ...r } = e, a = Sa(n);
  return /* @__PURE__ */ E.jsx(uDe, { ...a, ...r, ref: t });
});
EDe.displayName = _De;
var CDe = "DropdownMenuRadioGroup", eG = M.forwardRef((e, t) => {
  const { __scopeDropdownMenu: n, ...r } = e, a = Sa(n);
  return /* @__PURE__ */ E.jsx(cDe, { ...a, ...r, ref: t });
});
eG.displayName = CDe;
var ODe = "DropdownMenuRadioItem", tG = M.forwardRef((e, t) => {
  const { __scopeDropdownMenu: n, ...r } = e, a = Sa(n);
  return /* @__PURE__ */ E.jsx(dDe, { ...a, ...r, ref: t });
});
tG.displayName = ODe;
var MDe = "DropdownMenuItemIndicator", NDe = M.forwardRef((e, t) => {
  const { __scopeDropdownMenu: n, ...r } = e, a = Sa(n);
  return /* @__PURE__ */ E.jsx(fDe, { ...a, ...r, ref: t });
});
NDe.displayName = MDe;
var RDe = "DropdownMenuSeparator", ADe = M.forwardRef((e, t) => {
  const { __scopeDropdownMenu: n, ...r } = e, a = Sa(n);
  return /* @__PURE__ */ E.jsx(pDe, { ...a, ...r, ref: t });
});
ADe.displayName = RDe;
var jDe = "DropdownMenuArrow", PDe = M.forwardRef(
  (e, t) => {
    const { __scopeDropdownMenu: n, ...r } = e, a = Sa(n);
    return /* @__PURE__ */ E.jsx(mDe, { ...a, ...r, ref: t });
  }
);
PDe.displayName = jDe;
var DDe = (e) => {
  const { __scopeDropdownMenu: t, children: n, open: r, onOpenChange: a, defaultOpen: s } = e, l = Sa(t), [c, d] = gd({
    prop: r,
    defaultProp: s ?? !1,
    onChange: a,
    caller: "DropdownMenuSub"
  });
  return /* @__PURE__ */ E.jsx(hDe, { ...l, open: c, onOpenChange: d, children: n });
}, $De = "DropdownMenuSubTrigger", nG = M.forwardRef((e, t) => {
  const { __scopeDropdownMenu: n, ...r } = e, a = Sa(n);
  return /* @__PURE__ */ E.jsx(gDe, { ...a, ...r, ref: t });
});
nG.displayName = $De;
var TDe = "DropdownMenuSubContent", rG = M.forwardRef((e, t) => {
  const { __scopeDropdownMenu: n, ...r } = e, a = Sa(n);
  return /* @__PURE__ */ E.jsx(
    vDe,
    {
      ...a,
      ...r,
      ref: t,
      style: {
        ...e.style,
        "--radix-dropdown-menu-content-transform-origin": "var(--radix-popper-transform-origin)",
        "--radix-dropdown-menu-content-available-width": "var(--radix-popper-available-width)",
        "--radix-dropdown-menu-content-available-height": "var(--radix-popper-available-height)",
        "--radix-dropdown-menu-trigger-width": "var(--radix-popper-anchor-width)",
        "--radix-dropdown-menu-trigger-height": "var(--radix-popper-anchor-height)"
      }
    }
  );
});
rG.displayName = TDe;
var F4 = GW, B4 = XW, U4 = QW, V4 = JW, cc = ZW, LDe = eG, IDe = tG, zDe = DDe, FDe = nG, BDe = rG;
const UDe = ({
  trigger: e,
  setOpen: t,
  open: n
}) => {
  const [r, a] = M.useState(""), [s, l] = M.useState(!0), c = yn();
  return c.options.useWorkerManager ? /* @__PURE__ */ E.jsxs(
    Pl,
    {
      setOpen: t,
      open: n,
      trigger: e,
      title: "New Worker",
      description: "Create a new worker",
      children: [
        /* @__PURE__ */ E.jsxs("div", { children: [
          "Name:",
          /* @__PURE__ */ E.jsx("br", {}),
          /* @__PURE__ */ E.jsx(
            "input",
            {
              className: "styledinput",
              onChange: (d) => {
                a(d.currentTarget.value);
              },
              value: r
            }
          ),
          /* @__PURE__ */ E.jsxs("div", { style: { marginTop: 8 }, children: [
            /* @__PURE__ */ E.jsx(
              "input",
              {
                type: "checkbox",
                id: "inVenvCheckbox",
                checked: s,
                onChange: (d) => l(d.currentTarget.checked)
              }
            ),
            /* @__PURE__ */ E.jsx("label", { htmlFor: "inVenvCheckbox", style: { marginLeft: 4 }, children: "Create in new virtual environment" })
          ] })
        ] }),
        /* @__PURE__ */ E.jsx("div", { children: r && /* @__PURE__ */ E.jsx("div", { children: /* @__PURE__ */ E.jsx(
          "button",
          {
            className: "styledbtn",
            onClick: () => {
              c.workermanager?.new_worker({
                name: r,
                in_venv: s
                // reference: reference.uuid,
                // copyLib,
                // copyNS,
              }), t(!1);
            },
            children: "Create"
          }
        ) }) })
      ]
    }
  ) : null;
}, VDe = ({
  trigger: e,
  setOpen: t,
  open: n
}) => {
  const r = yn(), [a, s] = M.useState(!1), l = r.workers(), c = r.worker?.uuid, d = (c ? l[c]?.name : void 0) || c || "worker", p = async () => {
    if (!r.worker) return;
    const m = await r.worker.export({ withFiles: a });
    $K(m, d + ".fnw", "application/zip"), t(!1);
  };
  return /* @__PURE__ */ E.jsx(
    Pl,
    {
      setOpen: t,
      open: n,
      trigger: e,
      title: "Export Worker",
      description: "Export the worker as a .fnw file",
      children: /* @__PURE__ */ E.jsxs("div", { children: [
        /* @__PURE__ */ E.jsxs("div", { children: [
          /* @__PURE__ */ E.jsx(
            "input",
            {
              type: "checkbox",
              className: "styledcheckbox",
              checked: a,
              onChange: (m) => {
                s(m.currentTarget.checked);
              }
            }
          ),
          "Include Files"
        ] }),
        /* @__PURE__ */ E.jsx("button", { className: "styledbtn", onClick: p, children: "Export" })
      ] })
    }
  );
}, HDe = () => {
  const e = yn(), t = e.workers(), [n, r] = M.useState(!1), [a, s] = M.useState(!1), l = (v) => {
    v !== "__select__" && e.workers && e.workermanager && t[v] && (!t[v].active && !window.confirm(
      "this is an inactive worker, selecting it will start it, continue?"
    ) || e.workermanager.set_active(v));
  }, c = async () => {
    if (!e.worker || !window.confirm(
      "Updateing the worker might replace the current nodespace, continue?"
    )) return;
    const v = await IK(".fnw");
    e.worker.update_from_export(v);
  }, d = e.options.useWorkerManager && e.workermanager && e.workermanager.open || Ux(), p = d && Object.keys(t).length > 0, m = e.worker && e.worker.is_open, h = m && d;
  return d || m ? /* @__PURE__ */ E.jsxs(E.Fragment, { children: [
    /* @__PURE__ */ E.jsxs(F4, { children: [
      /* @__PURE__ */ E.jsx(B4, { asChild: !0, children: /* @__PURE__ */ E.jsx("button", { className: "styledbtn", children: /* @__PURE__ */ E.jsxs(nd, { direction: "row", children: [
        "Worker ",
        /* @__PURE__ */ E.jsx(CR, { className: "m-x-s" })
      ] }) }) }),
      /* @__PURE__ */ E.jsx(U4, { className: "headermenucontent funcnodescontainer", children: /* @__PURE__ */ E.jsxs(V4, { children: [
        p && /* @__PURE__ */ E.jsxs(zDe, { children: [
          /* @__PURE__ */ E.jsx(FDe, { className: "headermenuitem submenuitem", children: /* @__PURE__ */ E.jsxs(nd, { direction: "row", children: [
            "Select",
            /* @__PURE__ */ E.jsx(hx, {})
          ] }) }),
          /* @__PURE__ */ E.jsx(
            BDe,
            {
              className: "headermenucontent funcnodescontainer",
              sideOffset: 2,
              alignOffset: -5,
              children: /* @__PURE__ */ E.jsx(
                LDe,
                {
                  value: e.worker?.uuid,
                  onValueChange: (v) => {
                    l(v);
                  },
                  children: Object.keys(t).sort((v, y) => {
                    if (t[v].active && !t[y].active)
                      return -1;
                    if (!t[v].active && t[y].active)
                      return 1;
                    const w = t[v].name || v, x = t[y].name || y;
                    return w.localeCompare(x);
                  }).map((v) => /* @__PURE__ */ E.jsx(
                    IDe,
                    {
                      className: "headermenuitem workerselectoption" + (t[v]?.active ? " active" : " inactive") + " headermenuitem",
                      value: v,
                      disabled: v === e.worker?.uuid,
                      children: t[v]?.name || v
                    },
                    v
                  ))
                }
              )
            }
          )
        ] }),
        m && /* @__PURE__ */ E.jsxs(E.Fragment, { children: [
          h && /* @__PURE__ */ E.jsx(
            cc,
            {
              className: "headermenuitem",
              onClick: () => {
                if (e.worker) {
                  if (!e.workermanager)
                    return e.logger.error("no workermanager");
                  e.workermanager?.restart_worker(
                    e.worker.uuid
                  );
                }
              },
              children: "Restart"
            }
          ),
          /* @__PURE__ */ E.jsx(
            cc,
            {
              className: "headermenuitem",
              onClick: () => {
                e.worker && e.worker.stop();
              },
              children: "Stop"
            }
          ),
          /* @__PURE__ */ E.jsx(
            cc,
            {
              className: "headermenuitem",
              onClick: () => s(!0),
              children: "Export"
            }
          ),
          /* @__PURE__ */ E.jsx(
            cc,
            {
              className: "headermenuitem",
              onClick: c,
              children: "Update"
            }
          )
        ] }),
        d && /* @__PURE__ */ E.jsx(E.Fragment, { children: /* @__PURE__ */ E.jsx(
          cc,
          {
            className: "headermenuitem",
            onClick: () => r(!0),
            children: "New"
          }
        ) })
      ] }) })
    ] }),
    /* @__PURE__ */ E.jsx(
      UDe,
      {
        open: n,
        setOpen: r
      }
    ),
    /* @__PURE__ */ E.jsx(
      VDe,
      {
        open: a,
        setOpen: s
      }
    )
  ] }) : null;
}, qDe = () => {
  const e = yn(), t = () => {
    window.confirm("Are you sure you want to start a new flow?") && e.worker?.clear();
  }, n = async () => {
    const a = await e.worker?.save();
    if (!a) return;
    const s = new Blob([JSON.stringify(a)], {
      type: "application/json"
    }), l = URL.createObjectURL(s), c = document.createElement("a");
    c.href = l, c.download = "flow.json", c.click(), URL.revokeObjectURL(l), c.remove();
  }, r = async () => {
    const a = document.createElement("input");
    a.type = "file", a.accept = ".json", a.onchange = async (s) => {
      const l = s.target.files?.[0];
      if (!l) return;
      const c = new FileReader();
      c.onload = async (d) => {
        const p = d.target?.result;
        if (!p) return;
        const m = JSON.parse(p);
        await e.worker?.load(m);
      }, c.readAsText(l);
    }, a.click();
  };
  return /* @__PURE__ */ E.jsx(E.Fragment, { children: /* @__PURE__ */ E.jsxs(F4, { children: [
    /* @__PURE__ */ E.jsx(B4, { asChild: !0, children: /* @__PURE__ */ E.jsx("button", { className: "styledbtn", children: /* @__PURE__ */ E.jsxs(nd, { direction: "row", children: [
      "Nodespace ",
      /* @__PURE__ */ E.jsx(CR, { className: "m-x-s" })
    ] }) }) }),
    /* @__PURE__ */ E.jsx(U4, { className: "headermenucontent funcnodescontainer", children: /* @__PURE__ */ E.jsxs(V4, { children: [
      /* @__PURE__ */ E.jsx(cc, { className: "headermenuitem", onClick: t, children: "New" }),
      /* @__PURE__ */ E.jsx(cc, { className: "headermenuitem", onClick: n, children: "Save" }),
      /* @__PURE__ */ E.jsx(cc, { className: "headermenuitem", onClick: r, children: "Load" })
    ] }) })
  ] }) });
}, WDe = ({ theme: e, selected: t }) => /* @__PURE__ */ E.jsxs(
  "div",
  {
    style: {
      width: 80,
      height: 54,
      borderRadius: "var(--fn-border-radius-s, 8px)",
      border: t ? "2.5px solid #1976d2" : "1.5px solid #bbb",
      boxShadow: t ? "0 0 0 2px #1976d2" : "0 1px 4px #0002",
      background: "var(--fn-app-background)",
      display: "flex",
      flexDirection: "column",
      alignItems: "stretch",
      justifyContent: "flex-start",
      position: "relative",
      overflow: "hidden",
      transition: "border 0.2s, box-shadow 0.2s"
    },
    "fn-data-color-theme": e,
    children: [
      /* @__PURE__ */ E.jsx(
        "div",
        {
          style: {
            height: 10,
            background: "var(--fn-primary-color)",
            borderBottom: "1px solid var(--fn-neutral-element-border)"
          }
        }
      ),
      /* @__PURE__ */ E.jsxs("div", { style: { display: "flex", flex: 1 }, children: [
        /* @__PURE__ */ E.jsx(
          "div",
          {
            style: {
              width: 12,
              background: "var(--fn-surface-elevation-low, var(--fn-container-background))",
              borderRight: "1px solid var(--fn-neutral-element-border)"
            }
          }
        ),
        /* @__PURE__ */ E.jsx(
          "div",
          {
            style: {
              flex: 1,
              display: "flex",
              alignItems: "center",
              justifyContent: "center",
              background: "var(--fn-container-background)"
            },
            children: /* @__PURE__ */ E.jsxs(
              "div",
              {
                style: {
                  width: 22,
                  height: 14,
                  borderRadius: "var(--fn-border-radius-xs, 4px)",
                  background: "var(--fn-node-background)",
                  border: "1px solid var(--fn-node-header-color)",
                  boxShadow: "0 1px 2px #0002",
                  display: "flex",
                  flexDirection: "column"
                },
                children: [
                  /* @__PURE__ */ E.jsx(
                    "div",
                    {
                      style: {
                        height: 5,
                        background: "var(--fn-node-header-color)",
                        borderTopLeftRadius: "var(--fn-border-radius-xs, 4px)",
                        borderTopRightRadius: "var(--fn-border-radius-xs, 4px)"
                      }
                    }
                  ),
                  /* @__PURE__ */ E.jsx(
                    "div",
                    {
                      style: {
                        flex: 1,
                        background: "transparent"
                      }
                    }
                  )
                ]
              }
            )
          }
        )
      ] }),
      /* @__PURE__ */ E.jsx(
        "span",
        {
          style: {
            position: "absolute",
            bottom: 2,
            right: 4,
            fontSize: 9,
            color: "var(--fn-text-color-neutral)",
            opacity: 0.7,
            textTransform: "capitalize",
            fontWeight: 600,
            pointerEvents: "none"
          },
          children: e
        }
      ),
      t && /* @__PURE__ */ E.jsx(
        "span",
        {
          style: {
            position: "absolute",
            top: 2,
            left: 6,
            fontSize: 14,
            color: "#1976d2",
            fontWeight: 900,
            pointerEvents: "none"
          },
          "aria-label": "Selected",
          children: ""
        }
      )
    ]
  }
), GDe = () => {
  const { colorTheme: e, setColorTheme: t } = n8(), [n, r] = M.useState(null), [a, s] = M.useState(null), l = (d) => {
    d !== e && (s(e), t(d), r(d));
  }, c = (d) => {
    n === d && a && a !== d && t(a), r(null), s(null);
  };
  return /* @__PURE__ */ E.jsxs("div", { style: { display: "flex", flexDirection: "column", gap: "1em" }, children: [
    /* @__PURE__ */ E.jsx("div", { style: { marginBottom: 8, fontWeight: 500 }, children: "Theme:" }),
    /* @__PURE__ */ E.jsx("div", { style: {
      display: "grid",
      gridTemplateColumns: "repeat(auto-fill, minmax(80px, 1fr))",
      gap: 16,
      justifyItems: "center"
    }, children: gB.map((d) => /* @__PURE__ */ E.jsx(
      "button",
      {
        onClick: () => {
          t(d), r(null), s(null);
        },
        onMouseEnter: () => l(d),
        onMouseLeave: () => c(d),
        style: {
          background: "none",
          border: "none",
          padding: 0,
          cursor: "pointer",
          outline: "none",
          borderRadius: 8
        },
        "aria-label": `Select ${d} theme`,
        children: /* @__PURE__ */ E.jsx(
          WDe,
          {
            theme: d,
            selected: e === d
          }
        )
      },
      d
    )) })
  ] });
}, KDe = () => {
  const [e, t] = M.useState(!1), n = () => {
    t(!0);
  };
  return /* @__PURE__ */ E.jsxs(E.Fragment, { children: [
    /* @__PURE__ */ E.jsxs(F4, { children: [
      /* @__PURE__ */ E.jsx(B4, { asChild: !0, children: /* @__PURE__ */ E.jsx("button", { className: "styledbtn", children: /* @__PURE__ */ E.jsxs(nd, { direction: "row", children: [
        "Settings ",
        /* @__PURE__ */ E.jsx(CR, { className: "m-x-s" })
      ] }) }) }),
      /* @__PURE__ */ E.jsx(U4, { className: "headermenucontent funcnodescontainer", children: /* @__PURE__ */ E.jsx(V4, { children: /* @__PURE__ */ E.jsx(
        cc,
        {
          className: "headermenuitem",
          onClick: n,
          children: "Appearance"
        }
      ) }) })
    ] }),
    /* @__PURE__ */ E.jsx(
      Pl,
      {
        open: e,
        setOpen: t,
        title: "Appearance",
        description: "Change the color theme.",
        closebutton: !0,
        children: /* @__PURE__ */ E.jsx(GDe, {})
      }
    )
  ] });
}, XDe = ({
  ...e
}) => {
  const t = yn(), n = t.workerstate();
  return Object.keys(e).length > 0 && t.logger.debug("headerprops", e), /* @__PURE__ */ E.jsxs(nd, { className: "funcnodesreactflowheader", direction: "row", wrap: !0, children: [
    /* @__PURE__ */ E.jsx(
      nd,
      {
        className: "headerelement m-w-6",
        grow: {
          "": !0,
          m: !1
        },
        children: /* @__PURE__ */ E.jsx(NPe, {})
      }
    ),
    (e.showmenu || Ux()) && /* @__PURE__ */ E.jsxs(nd, { direction: "row", wrap: !0, children: [
      /* @__PURE__ */ E.jsx("div", { className: "headerelement", children: /* @__PURE__ */ E.jsx(HDe, {}) }),
      (t.worker && n.is_open || Ux()) && /* @__PURE__ */ E.jsx("div", { className: "headerelement", children: /* @__PURE__ */ E.jsx(qDe, {}) }),
      /* @__PURE__ */ E.jsx("div", { className: "headerelement", children: /* @__PURE__ */ E.jsx(KDe, {}) })
    ] })
  ] });
}, oG = ({ item: e }) => {
  const { node: t } = xa(), n = M.useCallback(() => {
    t?.add_node(e.node_id);
  }, [e.node_id, t]), r = M.useCallback(
    (a) => {
      a.detail === 2 && n();
    },
    [n]
  );
  return /* @__PURE__ */ E.jsx("div", { className: "libnodeentry", onClick: r, title: e.description, children: e.node_name || e.node_id });
}, aG = (e, t) => {
  const n = e.nodes?.some(
    (a) => a.node_id.toLowerCase().includes(t.toLowerCase())
  ) ?? !1, r = e.subshelves?.some((a) => aG(a, t)) ?? !1;
  return n || r;
}, H4 = ({
  item: e,
  filter: t,
  parentkey: n
}) => {
  const [r, a] = M.useState(!1), s = () => a(!r), l = e.nodes?.filter(
    (d) => d.node_id.toLowerCase().includes(t.toLowerCase())
  ), c = r || t.length > 0;
  return aG(e, t) ? /* @__PURE__ */ E.jsxs("div", { className: "shelfcontainer", children: [
    /* @__PURE__ */ E.jsxs(
      "div",
      {
        className: "shelftitle",
        onClick: s,
        style: { cursor: "pointer" },
        title: e.description,
        children: [
          /* @__PURE__ */ E.jsx("div", { className: "shelftitle_text", children: e.name }),
          /* @__PURE__ */ E.jsx("div", { className: "expandicon " + (c ? "open" : "close"), children: /* @__PURE__ */ E.jsx(sS, {}) })
        ]
      }
    ),
    /* @__PURE__ */ E.jsx("div", { className: "libnodecontainer " + (c ? "open" : "close"), children: /* @__PURE__ */ E.jsxs("div", { className: "libnodecontainer_inner", children: [
      l && /* @__PURE__ */ E.jsx(E.Fragment, { children: l.map((d) => /* @__PURE__ */ E.jsx(oG, { item: d }, d.node_id)) }),
      e.subshelves && /* @__PURE__ */ E.jsx(E.Fragment, { children: e.subshelves.map((d) => /* @__PURE__ */ E.jsx(
        H4,
        {
          item: d,
          filter: t,
          parentkey: n + d.name
        },
        n + d.name
      )) })
    ] }) }),
    /* @__PURE__ */ E.jsx("hr", {})
  ] }) : /* @__PURE__ */ E.jsx(E.Fragment, {});
}, YDe = ({
  filter: e,
  setFilter: t
}) => /* @__PURE__ */ E.jsxs("div", { className: "libfilter", children: [
  /* @__PURE__ */ E.jsx(vae, { fontSize: "inherit" }),
  /* @__PURE__ */ E.jsx(
    "input",
    {
      type: "text",
      placeholder: "Filter",
      value: e,
      onChange: (n) => {
        t(n.target.value);
      }
    }
  ),
  e && /* @__PURE__ */ E.jsx(
    _2,
    {
      fontSize: "inherit",
      onClick: () => {
        t("");
      }
    }
  )
] }), QDe = ({
  children: e
}) => {
  const [t, n] = M.useState(""), r = yn(), [a, s] = M.useState(!0), [l, c] = M.useState(!0), [d, p] = M.useState(!0), [m, h] = M.useState({
    installed: [],
    available: [],
    active: []
  }), [v, y] = M.useState(!1), { lib: w } = xa(), x = (D) => {
    D && (r.worker === void 0 || !r.worker.is_open || w?.get_available_modules({
      on_load: ($) => {
        h($);
      }
    }).then(($) => {
      h($);
    }));
  };
  if (!r.worker)
    return /* @__PURE__ */ E.jsx(E.Fragment, {});
  const b = M.useCallback(
    (D, $) => {
      y(!1), w?.add_lib(D.name, $);
    },
    [w]
  ), k = M.useCallback(
    (D, $) => {
      y(!1), w?.add_lib(D.name, $);
    },
    [w]
  ), C = M.useCallback(
    (D) => {
      y(!1), w?.remove_lib(D.name);
    },
    [w]
  ), _ = M.useCallback(
    (D, $) => {
      y(!1), w?.add_lib(D.name, $);
    },
    [w]
  ), O = M.useCallback(
    (D) => D.filter(
      ($) => $.name.toLowerCase().includes(t.toLowerCase()) || $.description.toLowerCase().includes(t.toLowerCase())
    ),
    [t]
  ), N = O(m.available), R = O(m.installed), j = O(m.active);
  return /* @__PURE__ */ E.jsxs(
    Pl,
    {
      title: "Manage Library",
      trigger: e,
      description: "Add or remove libraries to the current worker.",
      onOpenChange: x,
      open: v,
      setOpen: y,
      children: [
        /* @__PURE__ */ E.jsx(
          "input",
          {
            className: "filter-input styledinput",
            type: "text",
            placeholder: "Filter modules...",
            value: t,
            onChange: (D) => n(D.target.value)
          }
        ),
        /* @__PURE__ */ E.jsxs(
          "div",
          {
            className: "packagelist",
            style: { maxHeight: "70%", overflow: "auto" },
            children: [
              R.length > 0 && /* @__PURE__ */ E.jsx(
                "h3",
                {
                  onClick: () => {
                    p(!d);
                  },
                  children: "Installed"
                }
              ),
              d && R.map((D) => /* @__PURE__ */ E.jsx(
                k1e,
                {
                  availableModule: D,
                  on_add: b
                },
                D.name + D.source
              )),
              N.length > 0 && /* @__PURE__ */ E.jsx(
                "h3",
                {
                  onClick: () => {
                    c(!l);
                  },
                  children: "Available"
                }
              ),
              l && N.map((D) => /* @__PURE__ */ E.jsx(
                _1e,
                {
                  availableModule: D,
                  on_add: k
                },
                D.name + D.source
              )),
              j.length > 0 && /* @__PURE__ */ E.jsx(
                "h3",
                {
                  onClick: () => {
                    s(!a);
                  },
                  children: "Active"
                }
              ),
              a && j.map((D) => /* @__PURE__ */ E.jsx(
                S1e,
                {
                  availableModule: D,
                  on_remove: C,
                  on_update: _
                },
                D.name + D.source
              ))
            ]
          }
        )
      ]
    }
  );
}, q4 = ({
  availableModule: e
}) => /* @__PURE__ */ E.jsxs("div", { className: "module-links", children: [
  e.homepage && /* @__PURE__ */ E.jsx(E.Fragment, { children: /* @__PURE__ */ E.jsx(
    "a",
    {
      href: e.homepage,
      target: "_blank",
      rel: "noopener noreferrer",
      children: "Homepage"
    }
  ) }),
  e.source && e.homepage && " | ",
  e.source && /* @__PURE__ */ E.jsx(E.Fragment, { children: /* @__PURE__ */ E.jsx(
    "a",
    {
      href: e.source,
      target: "_blank",
      rel: "noopener noreferrer",
      children: "Source"
    }
  ) })
] });
function JDe(e, t) {
  const n = {};
  return (e[e.length - 1] === "" ? [...e, ""] : e).join(
    (n.padRight ? " " : "") + "," + (n.padLeft === !1 ? "" : " ")
  ).trim();
}
const ZDe = /^[$_\p{ID_Start}][$_\u{200C}\u{200D}\p{ID_Continue}]*$/u, e6e = /^[$_\p{ID_Start}][-$_\u{200C}\u{200D}\p{ID_Continue}]*$/u, t6e = {};
function vz(e, t) {
  return (t6e.jsx ? e6e : ZDe).test(e);
}
const n6e = /[ \t\n\f\r]/g;
function r6e(e) {
  return typeof e == "object" ? e.type === "text" ? yz(e.value) : !1 : yz(e);
}
function yz(e) {
  return e.replace(n6e, "") === "";
}
class IS {
  /**
   * @param {SchemaType['property']} property
   *   Property.
   * @param {SchemaType['normal']} normal
   *   Normal.
   * @param {Space | undefined} [space]
   *   Space.
   * @returns
   *   Schema.
   */
  constructor(t, n, r) {
    this.normal = n, this.property = t, r && (this.space = r);
  }
}
IS.prototype.normal = {};
IS.prototype.property = {};
IS.prototype.space = void 0;
function iG(e, t) {
  const n = {}, r = {};
  for (const a of e)
    Object.assign(n, a.property), Object.assign(r, a.normal);
  return new IS(n, r, t);
}
function x3(e) {
  return e.toLowerCase();
}
class Aa {
  /**
   * @param {string} property
   *   Property.
   * @param {string} attribute
   *   Attribute.
   * @returns
   *   Info.
   */
  constructor(t, n) {
    this.attribute = n, this.property = t;
  }
}
Aa.prototype.attribute = "";
Aa.prototype.booleanish = !1;
Aa.prototype.boolean = !1;
Aa.prototype.commaOrSpaceSeparated = !1;
Aa.prototype.commaSeparated = !1;
Aa.prototype.defined = !1;
Aa.prototype.mustUseProperty = !1;
Aa.prototype.number = !1;
Aa.prototype.overloadedBoolean = !1;
Aa.prototype.property = "";
Aa.prototype.spaceSeparated = !1;
Aa.prototype.space = void 0;
let o6e = 0;
const Tt = $m(), Rr = $m(), S3 = $m(), Pe = $m(), Xn = $m(), Nh = $m(), pi = $m();
function $m() {
  return 2 ** ++o6e;
}
const k3 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  boolean: Tt,
  booleanish: Rr,
  commaOrSpaceSeparated: pi,
  commaSeparated: Nh,
  number: Pe,
  overloadedBoolean: S3,
  spaceSeparated: Xn
}, Symbol.toStringTag, { value: "Module" })), kN = (
  /** @type {ReadonlyArray<keyof typeof types>} */
  Object.keys(k3)
);
class W4 extends Aa {
  /**
   * @constructor
   * @param {string} property
   *   Property.
   * @param {string} attribute
   *   Attribute.
   * @param {number | null | undefined} [mask]
   *   Mask.
   * @param {Space | undefined} [space]
   *   Space.
   * @returns
   *   Info.
   */
  constructor(t, n, r, a) {
    let s = -1;
    if (super(t, n), bz(this, "space", a), typeof r == "number")
      for (; ++s < kN.length; ) {
        const l = kN[s];
        bz(this, kN[s], (r & k3[l]) === k3[l]);
      }
  }
}
W4.prototype.defined = !0;
function bz(e, t, n) {
  n && (e[t] = n);
}
function fg(e) {
  const t = {}, n = {};
  for (const [r, a] of Object.entries(e.properties)) {
    const s = new W4(
      r,
      e.transform(e.attributes || {}, r),
      a,
      e.space
    );
    e.mustUseProperty && e.mustUseProperty.includes(r) && (s.mustUseProperty = !0), t[r] = s, n[x3(r)] = r, n[x3(s.attribute)] = r;
  }
  return new IS(t, n, e.space);
}
const sG = fg({
  properties: {
    ariaActiveDescendant: null,
    ariaAtomic: Rr,
    ariaAutoComplete: null,
    ariaBusy: Rr,
    ariaChecked: Rr,
    ariaColCount: Pe,
    ariaColIndex: Pe,
    ariaColSpan: Pe,
    ariaControls: Xn,
    ariaCurrent: null,
    ariaDescribedBy: Xn,
    ariaDetails: null,
    ariaDisabled: Rr,
    ariaDropEffect: Xn,
    ariaErrorMessage: null,
    ariaExpanded: Rr,
    ariaFlowTo: Xn,
    ariaGrabbed: Rr,
    ariaHasPopup: null,
    ariaHidden: Rr,
    ariaInvalid: null,
    ariaKeyShortcuts: null,
    ariaLabel: null,
    ariaLabelledBy: Xn,
    ariaLevel: Pe,
    ariaLive: null,
    ariaModal: Rr,
    ariaMultiLine: Rr,
    ariaMultiSelectable: Rr,
    ariaOrientation: null,
    ariaOwns: Xn,
    ariaPlaceholder: null,
    ariaPosInSet: Pe,
    ariaPressed: Rr,
    ariaReadOnly: Rr,
    ariaRelevant: null,
    ariaRequired: Rr,
    ariaRoleDescription: Xn,
    ariaRowCount: Pe,
    ariaRowIndex: Pe,
    ariaRowSpan: Pe,
    ariaSelected: Rr,
    ariaSetSize: Pe,
    ariaSort: null,
    ariaValueMax: Pe,
    ariaValueMin: Pe,
    ariaValueNow: Pe,
    ariaValueText: null,
    role: null
  },
  transform(e, t) {
    return t === "role" ? t : "aria-" + t.slice(4).toLowerCase();
  }
});
function lG(e, t) {
  return t in e ? e[t] : t;
}
function uG(e, t) {
  return lG(e, t.toLowerCase());
}
const a6e = fg({
  attributes: {
    acceptcharset: "accept-charset",
    classname: "class",
    htmlfor: "for",
    httpequiv: "http-equiv"
  },
  mustUseProperty: ["checked", "multiple", "muted", "selected"],
  properties: {
    // Standard Properties.
    abbr: null,
    accept: Nh,
    acceptCharset: Xn,
    accessKey: Xn,
    action: null,
    allow: null,
    allowFullScreen: Tt,
    allowPaymentRequest: Tt,
    allowUserMedia: Tt,
    alt: null,
    as: null,
    async: Tt,
    autoCapitalize: null,
    autoComplete: Xn,
    autoFocus: Tt,
    autoPlay: Tt,
    blocking: Xn,
    capture: null,
    charSet: null,
    checked: Tt,
    cite: null,
    className: Xn,
    cols: Pe,
    colSpan: null,
    content: null,
    contentEditable: Rr,
    controls: Tt,
    controlsList: Xn,
    coords: Pe | Nh,
    crossOrigin: null,
    data: null,
    dateTime: null,
    decoding: null,
    default: Tt,
    defer: Tt,
    dir: null,
    dirName: null,
    disabled: Tt,
    download: S3,
    draggable: Rr,
    encType: null,
    enterKeyHint: null,
    fetchPriority: null,
    form: null,
    formAction: null,
    formEncType: null,
    formMethod: null,
    formNoValidate: Tt,
    formTarget: null,
    headers: Xn,
    height: Pe,
    hidden: S3,
    high: Pe,
    href: null,
    hrefLang: null,
    htmlFor: Xn,
    httpEquiv: Xn,
    id: null,
    imageSizes: null,
    imageSrcSet: null,
    inert: Tt,
    inputMode: null,
    integrity: null,
    is: null,
    isMap: Tt,
    itemId: null,
    itemProp: Xn,
    itemRef: Xn,
    itemScope: Tt,
    itemType: Xn,
    kind: null,
    label: null,
    lang: null,
    language: null,
    list: null,
    loading: null,
    loop: Tt,
    low: Pe,
    manifest: null,
    max: null,
    maxLength: Pe,
    media: null,
    method: null,
    min: null,
    minLength: Pe,
    multiple: Tt,
    muted: Tt,
    name: null,
    nonce: null,
    noModule: Tt,
    noValidate: Tt,
    onAbort: null,
    onAfterPrint: null,
    onAuxClick: null,
    onBeforeMatch: null,
    onBeforePrint: null,
    onBeforeToggle: null,
    onBeforeUnload: null,
    onBlur: null,
    onCancel: null,
    onCanPlay: null,
    onCanPlayThrough: null,
    onChange: null,
    onClick: null,
    onClose: null,
    onContextLost: null,
    onContextMenu: null,
    onContextRestored: null,
    onCopy: null,
    onCueChange: null,
    onCut: null,
    onDblClick: null,
    onDrag: null,
    onDragEnd: null,
    onDragEnter: null,
    onDragExit: null,
    onDragLeave: null,
    onDragOver: null,
    onDragStart: null,
    onDrop: null,
    onDurationChange: null,
    onEmptied: null,
    onEnded: null,
    onError: null,
    onFocus: null,
    onFormData: null,
    onHashChange: null,
    onInput: null,
    onInvalid: null,
    onKeyDown: null,
    onKeyPress: null,
    onKeyUp: null,
    onLanguageChange: null,
    onLoad: null,
    onLoadedData: null,
    onLoadedMetadata: null,
    onLoadEnd: null,
    onLoadStart: null,
    onMessage: null,
    onMessageError: null,
    onMouseDown: null,
    onMouseEnter: null,
    onMouseLeave: null,
    onMouseMove: null,
    onMouseOut: null,
    onMouseOver: null,
    onMouseUp: null,
    onOffline: null,
    onOnline: null,
    onPageHide: null,
    onPageShow: null,
    onPaste: null,
    onPause: null,
    onPlay: null,
    onPlaying: null,
    onPopState: null,
    onProgress: null,
    onRateChange: null,
    onRejectionHandled: null,
    onReset: null,
    onResize: null,
    onScroll: null,
    onScrollEnd: null,
    onSecurityPolicyViolation: null,
    onSeeked: null,
    onSeeking: null,
    onSelect: null,
    onSlotChange: null,
    onStalled: null,
    onStorage: null,
    onSubmit: null,
    onSuspend: null,
    onTimeUpdate: null,
    onToggle: null,
    onUnhandledRejection: null,
    onUnload: null,
    onVolumeChange: null,
    onWaiting: null,
    onWheel: null,
    open: Tt,
    optimum: Pe,
    pattern: null,
    ping: Xn,
    placeholder: null,
    playsInline: Tt,
    popover: null,
    popoverTarget: null,
    popoverTargetAction: null,
    poster: null,
    preload: null,
    readOnly: Tt,
    referrerPolicy: null,
    rel: Xn,
    required: Tt,
    reversed: Tt,
    rows: Pe,
    rowSpan: Pe,
    sandbox: Xn,
    scope: null,
    scoped: Tt,
    seamless: Tt,
    selected: Tt,
    shadowRootClonable: Tt,
    shadowRootDelegatesFocus: Tt,
    shadowRootMode: null,
    shape: null,
    size: Pe,
    sizes: null,
    slot: null,
    span: Pe,
    spellCheck: Rr,
    src: null,
    srcDoc: null,
    srcLang: null,
    srcSet: null,
    start: Pe,
    step: null,
    style: null,
    tabIndex: Pe,
    target: null,
    title: null,
    translate: null,
    type: null,
    typeMustMatch: Tt,
    useMap: null,
    value: Rr,
    width: Pe,
    wrap: null,
    writingSuggestions: null,
    // Legacy.
    // See: https://html.spec.whatwg.org/#other-elements,-attributes-and-apis
    align: null,
    // Several. Use CSS `text-align` instead,
    aLink: null,
    // `<body>`. Use CSS `a:active {color}` instead
    archive: Xn,
    // `<object>`. List of URIs to archives
    axis: null,
    // `<td>` and `<th>`. Use `scope` on `<th>`
    background: null,
    // `<body>`. Use CSS `background-image` instead
    bgColor: null,
    // `<body>` and table elements. Use CSS `background-color` instead
    border: Pe,
    // `<table>`. Use CSS `border-width` instead,
    borderColor: null,
    // `<table>`. Use CSS `border-color` instead,
    bottomMargin: Pe,
    // `<body>`
    cellPadding: null,
    // `<table>`
    cellSpacing: null,
    // `<table>`
    char: null,
    // Several table elements. When `align=char`, sets the character to align on
    charOff: null,
    // Several table elements. When `char`, offsets the alignment
    classId: null,
    // `<object>`
    clear: null,
    // `<br>`. Use CSS `clear` instead
    code: null,
    // `<object>`
    codeBase: null,
    // `<object>`
    codeType: null,
    // `<object>`
    color: null,
    // `<font>` and `<hr>`. Use CSS instead
    compact: Tt,
    // Lists. Use CSS to reduce space between items instead
    declare: Tt,
    // `<object>`
    event: null,
    // `<script>`
    face: null,
    // `<font>`. Use CSS instead
    frame: null,
    // `<table>`
    frameBorder: null,
    // `<iframe>`. Use CSS `border` instead
    hSpace: Pe,
    // `<img>` and `<object>`
    leftMargin: Pe,
    // `<body>`
    link: null,
    // `<body>`. Use CSS `a:link {color: *}` instead
    longDesc: null,
    // `<frame>`, `<iframe>`, and `<img>`. Use an `<a>`
    lowSrc: null,
    // `<img>`. Use a `<picture>`
    marginHeight: Pe,
    // `<body>`
    marginWidth: Pe,
    // `<body>`
    noResize: Tt,
    // `<frame>`
    noHref: Tt,
    // `<area>`. Use no href instead of an explicit `nohref`
    noShade: Tt,
    // `<hr>`. Use background-color and height instead of borders
    noWrap: Tt,
    // `<td>` and `<th>`
    object: null,
    // `<applet>`
    profile: null,
    // `<head>`
    prompt: null,
    // `<isindex>`
    rev: null,
    // `<link>`
    rightMargin: Pe,
    // `<body>`
    rules: null,
    // `<table>`
    scheme: null,
    // `<meta>`
    scrolling: Rr,
    // `<frame>`. Use overflow in the child context
    standby: null,
    // `<object>`
    summary: null,
    // `<table>`
    text: null,
    // `<body>`. Use CSS `color` instead
    topMargin: Pe,
    // `<body>`
    valueType: null,
    // `<param>`
    version: null,
    // `<html>`. Use a doctype.
    vAlign: null,
    // Several. Use CSS `vertical-align` instead
    vLink: null,
    // `<body>`. Use CSS `a:visited {color}` instead
    vSpace: Pe,
    // `<img>` and `<object>`
    // Non-standard Properties.
    allowTransparency: null,
    autoCorrect: null,
    autoSave: null,
    disablePictureInPicture: Tt,
    disableRemotePlayback: Tt,
    prefix: null,
    property: null,
    results: Pe,
    security: null,
    unselectable: null
  },
  space: "html",
  transform: uG
}), i6e = fg({
  attributes: {
    accentHeight: "accent-height",
    alignmentBaseline: "alignment-baseline",
    arabicForm: "arabic-form",
    baselineShift: "baseline-shift",
    capHeight: "cap-height",
    className: "class",
    clipPath: "clip-path",
    clipRule: "clip-rule",
    colorInterpolation: "color-interpolation",
    colorInterpolationFilters: "color-interpolation-filters",
    colorProfile: "color-profile",
    colorRendering: "color-rendering",
    crossOrigin: "crossorigin",
    dataType: "datatype",
    dominantBaseline: "dominant-baseline",
    enableBackground: "enable-background",
    fillOpacity: "fill-opacity",
    fillRule: "fill-rule",
    floodColor: "flood-color",
    floodOpacity: "flood-opacity",
    fontFamily: "font-family",
    fontSize: "font-size",
    fontSizeAdjust: "font-size-adjust",
    fontStretch: "font-stretch",
    fontStyle: "font-style",
    fontVariant: "font-variant",
    fontWeight: "font-weight",
    glyphName: "glyph-name",
    glyphOrientationHorizontal: "glyph-orientation-horizontal",
    glyphOrientationVertical: "glyph-orientation-vertical",
    hrefLang: "hreflang",
    horizAdvX: "horiz-adv-x",
    horizOriginX: "horiz-origin-x",
    horizOriginY: "horiz-origin-y",
    imageRendering: "image-rendering",
    letterSpacing: "letter-spacing",
    lightingColor: "lighting-color",
    markerEnd: "marker-end",
    markerMid: "marker-mid",
    markerStart: "marker-start",
    navDown: "nav-down",
    navDownLeft: "nav-down-left",
    navDownRight: "nav-down-right",
    navLeft: "nav-left",
    navNext: "nav-next",
    navPrev: "nav-prev",
    navRight: "nav-right",
    navUp: "nav-up",
    navUpLeft: "nav-up-left",
    navUpRight: "nav-up-right",
    onAbort: "onabort",
    onActivate: "onactivate",
    onAfterPrint: "onafterprint",
    onBeforePrint: "onbeforeprint",
    onBegin: "onbegin",
    onCancel: "oncancel",
    onCanPlay: "oncanplay",
    onCanPlayThrough: "oncanplaythrough",
    onChange: "onchange",
    onClick: "onclick",
    onClose: "onclose",
    onCopy: "oncopy",
    onCueChange: "oncuechange",
    onCut: "oncut",
    onDblClick: "ondblclick",
    onDrag: "ondrag",
    onDragEnd: "ondragend",
    onDragEnter: "ondragenter",
    onDragExit: "ondragexit",
    onDragLeave: "ondragleave",
    onDragOver: "ondragover",
    onDragStart: "ondragstart",
    onDrop: "ondrop",
    onDurationChange: "ondurationchange",
    onEmptied: "onemptied",
    onEnd: "onend",
    onEnded: "onended",
    onError: "onerror",
    onFocus: "onfocus",
    onFocusIn: "onfocusin",
    onFocusOut: "onfocusout",
    onHashChange: "onhashchange",
    onInput: "oninput",
    onInvalid: "oninvalid",
    onKeyDown: "onkeydown",
    onKeyPress: "onkeypress",
    onKeyUp: "onkeyup",
    onLoad: "onload",
    onLoadedData: "onloadeddata",
    onLoadedMetadata: "onloadedmetadata",
    onLoadStart: "onloadstart",
    onMessage: "onmessage",
    onMouseDown: "onmousedown",
    onMouseEnter: "onmouseenter",
    onMouseLeave: "onmouseleave",
    onMouseMove: "onmousemove",
    onMouseOut: "onmouseout",
    onMouseOver: "onmouseover",
    onMouseUp: "onmouseup",
    onMouseWheel: "onmousewheel",
    onOffline: "onoffline",
    onOnline: "ononline",
    onPageHide: "onpagehide",
    onPageShow: "onpageshow",
    onPaste: "onpaste",
    onPause: "onpause",
    onPlay: "onplay",
    onPlaying: "onplaying",
    onPopState: "onpopstate",
    onProgress: "onprogress",
    onRateChange: "onratechange",
    onRepeat: "onrepeat",
    onReset: "onreset",
    onResize: "onresize",
    onScroll: "onscroll",
    onSeeked: "onseeked",
    onSeeking: "onseeking",
    onSelect: "onselect",
    onShow: "onshow",
    onStalled: "onstalled",
    onStorage: "onstorage",
    onSubmit: "onsubmit",
    onSuspend: "onsuspend",
    onTimeUpdate: "ontimeupdate",
    onToggle: "ontoggle",
    onUnload: "onunload",
    onVolumeChange: "onvolumechange",
    onWaiting: "onwaiting",
    onZoom: "onzoom",
    overlinePosition: "overline-position",
    overlineThickness: "overline-thickness",
    paintOrder: "paint-order",
    panose1: "panose-1",
    pointerEvents: "pointer-events",
    referrerPolicy: "referrerpolicy",
    renderingIntent: "rendering-intent",
    shapeRendering: "shape-rendering",
    stopColor: "stop-color",
    stopOpacity: "stop-opacity",
    strikethroughPosition: "strikethrough-position",
    strikethroughThickness: "strikethrough-thickness",
    strokeDashArray: "stroke-dasharray",
    strokeDashOffset: "stroke-dashoffset",
    strokeLineCap: "stroke-linecap",
    strokeLineJoin: "stroke-linejoin",
    strokeMiterLimit: "stroke-miterlimit",
    strokeOpacity: "stroke-opacity",
    strokeWidth: "stroke-width",
    tabIndex: "tabindex",
    textAnchor: "text-anchor",
    textDecoration: "text-decoration",
    textRendering: "text-rendering",
    transformOrigin: "transform-origin",
    typeOf: "typeof",
    underlinePosition: "underline-position",
    underlineThickness: "underline-thickness",
    unicodeBidi: "unicode-bidi",
    unicodeRange: "unicode-range",
    unitsPerEm: "units-per-em",
    vAlphabetic: "v-alphabetic",
    vHanging: "v-hanging",
    vIdeographic: "v-ideographic",
    vMathematical: "v-mathematical",
    vectorEffect: "vector-effect",
    vertAdvY: "vert-adv-y",
    vertOriginX: "vert-origin-x",
    vertOriginY: "vert-origin-y",
    wordSpacing: "word-spacing",
    writingMode: "writing-mode",
    xHeight: "x-height",
    // These were camelcased in Tiny. Now lowercased in SVG 2
    playbackOrder: "playbackorder",
    timelineBegin: "timelinebegin"
  },
  properties: {
    about: pi,
    accentHeight: Pe,
    accumulate: null,
    additive: null,
    alignmentBaseline: null,
    alphabetic: Pe,
    amplitude: Pe,
    arabicForm: null,
    ascent: Pe,
    attributeName: null,
    attributeType: null,
    azimuth: Pe,
    bandwidth: null,
    baselineShift: null,
    baseFrequency: null,
    baseProfile: null,
    bbox: null,
    begin: null,
    bias: Pe,
    by: null,
    calcMode: null,
    capHeight: Pe,
    className: Xn,
    clip: null,
    clipPath: null,
    clipPathUnits: null,
    clipRule: null,
    color: null,
    colorInterpolation: null,
    colorInterpolationFilters: null,
    colorProfile: null,
    colorRendering: null,
    content: null,
    contentScriptType: null,
    contentStyleType: null,
    crossOrigin: null,
    cursor: null,
    cx: null,
    cy: null,
    d: null,
    dataType: null,
    defaultAction: null,
    descent: Pe,
    diffuseConstant: Pe,
    direction: null,
    display: null,
    dur: null,
    divisor: Pe,
    dominantBaseline: null,
    download: Tt,
    dx: null,
    dy: null,
    edgeMode: null,
    editable: null,
    elevation: Pe,
    enableBackground: null,
    end: null,
    event: null,
    exponent: Pe,
    externalResourcesRequired: null,
    fill: null,
    fillOpacity: Pe,
    fillRule: null,
    filter: null,
    filterRes: null,
    filterUnits: null,
    floodColor: null,
    floodOpacity: null,
    focusable: null,
    focusHighlight: null,
    fontFamily: null,
    fontSize: null,
    fontSizeAdjust: null,
    fontStretch: null,
    fontStyle: null,
    fontVariant: null,
    fontWeight: null,
    format: null,
    fr: null,
    from: null,
    fx: null,
    fy: null,
    g1: Nh,
    g2: Nh,
    glyphName: Nh,
    glyphOrientationHorizontal: null,
    glyphOrientationVertical: null,
    glyphRef: null,
    gradientTransform: null,
    gradientUnits: null,
    handler: null,
    hanging: Pe,
    hatchContentUnits: null,
    hatchUnits: null,
    height: null,
    href: null,
    hrefLang: null,
    horizAdvX: Pe,
    horizOriginX: Pe,
    horizOriginY: Pe,
    id: null,
    ideographic: Pe,
    imageRendering: null,
    initialVisibility: null,
    in: null,
    in2: null,
    intercept: Pe,
    k: Pe,
    k1: Pe,
    k2: Pe,
    k3: Pe,
    k4: Pe,
    kernelMatrix: pi,
    kernelUnitLength: null,
    keyPoints: null,
    // SEMI_COLON_SEPARATED
    keySplines: null,
    // SEMI_COLON_SEPARATED
    keyTimes: null,
    // SEMI_COLON_SEPARATED
    kerning: null,
    lang: null,
    lengthAdjust: null,
    letterSpacing: null,
    lightingColor: null,
    limitingConeAngle: Pe,
    local: null,
    markerEnd: null,
    markerMid: null,
    markerStart: null,
    markerHeight: null,
    markerUnits: null,
    markerWidth: null,
    mask: null,
    maskContentUnits: null,
    maskUnits: null,
    mathematical: null,
    max: null,
    media: null,
    mediaCharacterEncoding: null,
    mediaContentEncodings: null,
    mediaSize: Pe,
    mediaTime: null,
    method: null,
    min: null,
    mode: null,
    name: null,
    navDown: null,
    navDownLeft: null,
    navDownRight: null,
    navLeft: null,
    navNext: null,
    navPrev: null,
    navRight: null,
    navUp: null,
    navUpLeft: null,
    navUpRight: null,
    numOctaves: null,
    observer: null,
    offset: null,
    onAbort: null,
    onActivate: null,
    onAfterPrint: null,
    onBeforePrint: null,
    onBegin: null,
    onCancel: null,
    onCanPlay: null,
    onCanPlayThrough: null,
    onChange: null,
    onClick: null,
    onClose: null,
    onCopy: null,
    onCueChange: null,
    onCut: null,
    onDblClick: null,
    onDrag: null,
    onDragEnd: null,
    onDragEnter: null,
    onDragExit: null,
    onDragLeave: null,
    onDragOver: null,
    onDragStart: null,
    onDrop: null,
    onDurationChange: null,
    onEmptied: null,
    onEnd: null,
    onEnded: null,
    onError: null,
    onFocus: null,
    onFocusIn: null,
    onFocusOut: null,
    onHashChange: null,
    onInput: null,
    onInvalid: null,
    onKeyDown: null,
    onKeyPress: null,
    onKeyUp: null,
    onLoad: null,
    onLoadedData: null,
    onLoadedMetadata: null,
    onLoadStart: null,
    onMessage: null,
    onMouseDown: null,
    onMouseEnter: null,
    onMouseLeave: null,
    onMouseMove: null,
    onMouseOut: null,
    onMouseOver: null,
    onMouseUp: null,
    onMouseWheel: null,
    onOffline: null,
    onOnline: null,
    onPageHide: null,
    onPageShow: null,
    onPaste: null,
    onPause: null,
    onPlay: null,
    onPlaying: null,
    onPopState: null,
    onProgress: null,
    onRateChange: null,
    onRepeat: null,
    onReset: null,
    onResize: null,
    onScroll: null,
    onSeeked: null,
    onSeeking: null,
    onSelect: null,
    onShow: null,
    onStalled: null,
    onStorage: null,
    onSubmit: null,
    onSuspend: null,
    onTimeUpdate: null,
    onToggle: null,
    onUnload: null,
    onVolumeChange: null,
    onWaiting: null,
    onZoom: null,
    opacity: null,
    operator: null,
    order: null,
    orient: null,
    orientation: null,
    origin: null,
    overflow: null,
    overlay: null,
    overlinePosition: Pe,
    overlineThickness: Pe,
    paintOrder: null,
    panose1: null,
    path: null,
    pathLength: Pe,
    patternContentUnits: null,
    patternTransform: null,
    patternUnits: null,
    phase: null,
    ping: Xn,
    pitch: null,
    playbackOrder: null,
    pointerEvents: null,
    points: null,
    pointsAtX: Pe,
    pointsAtY: Pe,
    pointsAtZ: Pe,
    preserveAlpha: null,
    preserveAspectRatio: null,
    primitiveUnits: null,
    propagate: null,
    property: pi,
    r: null,
    radius: null,
    referrerPolicy: null,
    refX: null,
    refY: null,
    rel: pi,
    rev: pi,
    renderingIntent: null,
    repeatCount: null,
    repeatDur: null,
    requiredExtensions: pi,
    requiredFeatures: pi,
    requiredFonts: pi,
    requiredFormats: pi,
    resource: null,
    restart: null,
    result: null,
    rotate: null,
    rx: null,
    ry: null,
    scale: null,
    seed: null,
    shapeRendering: null,
    side: null,
    slope: null,
    snapshotTime: null,
    specularConstant: Pe,
    specularExponent: Pe,
    spreadMethod: null,
    spacing: null,
    startOffset: null,
    stdDeviation: null,
    stemh: null,
    stemv: null,
    stitchTiles: null,
    stopColor: null,
    stopOpacity: null,
    strikethroughPosition: Pe,
    strikethroughThickness: Pe,
    string: null,
    stroke: null,
    strokeDashArray: pi,
    strokeDashOffset: null,
    strokeLineCap: null,
    strokeLineJoin: null,
    strokeMiterLimit: Pe,
    strokeOpacity: Pe,
    strokeWidth: null,
    style: null,
    surfaceScale: Pe,
    syncBehavior: null,
    syncBehaviorDefault: null,
    syncMaster: null,
    syncTolerance: null,
    syncToleranceDefault: null,
    systemLanguage: pi,
    tabIndex: Pe,
    tableValues: null,
    target: null,
    targetX: Pe,
    targetY: Pe,
    textAnchor: null,
    textDecoration: null,
    textRendering: null,
    textLength: null,
    timelineBegin: null,
    title: null,
    transformBehavior: null,
    type: null,
    typeOf: pi,
    to: null,
    transform: null,
    transformOrigin: null,
    u1: null,
    u2: null,
    underlinePosition: Pe,
    underlineThickness: Pe,
    unicode: null,
    unicodeBidi: null,
    unicodeRange: null,
    unitsPerEm: Pe,
    values: null,
    vAlphabetic: Pe,
    vMathematical: Pe,
    vectorEffect: null,
    vHanging: Pe,
    vIdeographic: Pe,
    version: null,
    vertAdvY: Pe,
    vertOriginX: Pe,
    vertOriginY: Pe,
    viewBox: null,
    viewTarget: null,
    visibility: null,
    width: null,
    widths: null,
    wordSpacing: null,
    writingMode: null,
    x: null,
    x1: null,
    x2: null,
    xChannelSelector: null,
    xHeight: Pe,
    y: null,
    y1: null,
    y2: null,
    yChannelSelector: null,
    z: null,
    zoomAndPan: null
  },
  space: "svg",
  transform: lG
}), cG = fg({
  properties: {
    xLinkActuate: null,
    xLinkArcRole: null,
    xLinkHref: null,
    xLinkRole: null,
    xLinkShow: null,
    xLinkTitle: null,
    xLinkType: null
  },
  space: "xlink",
  transform(e, t) {
    return "xlink:" + t.slice(5).toLowerCase();
  }
}), dG = fg({
  attributes: { xmlnsxlink: "xmlns:xlink" },
  properties: { xmlnsXLink: null, xmlns: null },
  space: "xmlns",
  transform: uG
}), fG = fg({
  properties: { xmlBase: null, xmlLang: null, xmlSpace: null },
  space: "xml",
  transform(e, t) {
    return "xml:" + t.slice(3).toLowerCase();
  }
}), s6e = {
  classId: "classID",
  dataType: "datatype",
  itemId: "itemID",
  strokeDashArray: "strokeDasharray",
  strokeDashOffset: "strokeDashoffset",
  strokeLineCap: "strokeLinecap",
  strokeLineJoin: "strokeLinejoin",
  strokeMiterLimit: "strokeMiterlimit",
  typeOf: "typeof",
  xLinkActuate: "xlinkActuate",
  xLinkArcRole: "xlinkArcrole",
  xLinkHref: "xlinkHref",
  xLinkRole: "xlinkRole",
  xLinkShow: "xlinkShow",
  xLinkTitle: "xlinkTitle",
  xLinkType: "xlinkType",
  xmlnsXLink: "xmlnsXlink"
}, l6e = /[A-Z]/g, wz = /-[a-z]/g, u6e = /^data[-\w.:]+$/i;
function c6e(e, t) {
  const n = x3(t);
  let r = t, a = Aa;
  if (n in e.normal)
    return e.property[e.normal[n]];
  if (n.length > 4 && n.slice(0, 4) === "data" && u6e.test(t)) {
    if (t.charAt(4) === "-") {
      const s = t.slice(5).replace(wz, f6e);
      r = "data" + s.charAt(0).toUpperCase() + s.slice(1);
    } else {
      const s = t.slice(4);
      if (!wz.test(s)) {
        let l = s.replace(l6e, d6e);
        l.charAt(0) !== "-" && (l = "-" + l), t = "data" + l;
      }
    }
    a = W4;
  }
  return new a(r, t);
}
function d6e(e) {
  return "-" + e.toLowerCase();
}
function f6e(e) {
  return e.charAt(1).toUpperCase();
}
const p6e = iG([sG, a6e, cG, dG, fG], "html"), G4 = iG([sG, i6e, cG, dG, fG], "svg");
function m6e(e) {
  return e.join(" ").trim();
}
var nh = {}, _N, xz;
function h6e() {
  if (xz) return _N;
  xz = 1;
  var e = /\/\*[^*]*\*+([^/*][^*]*\*+)*\//g, t = /\n/g, n = /^\s*/, r = /^(\*?[-#/*\\\w]+(\[[0-9a-z_-]+\])?)\s*/, a = /^:\s*/, s = /^((?:'(?:\\'|.)*?'|"(?:\\"|.)*?"|\([^)]*?\)|[^};])+)/, l = /^[;\s]*/, c = /^\s+|\s+$/g, d = `
`, p = "/", m = "*", h = "", v = "comment", y = "declaration";
  _N = function(x, b) {
    if (typeof x != "string")
      throw new TypeError("First argument must be a string");
    if (!x) return [];
    b = b || {};
    var k = 1, C = 1;
    function _(W) {
      var I = W.match(t);
      I && (k += I.length);
      var G = W.lastIndexOf(d);
      C = ~G ? W.length - G : C + W.length;
    }
    function O() {
      var W = { line: k, column: C };
      return function(I) {
        return I.position = new N(W), D(), I;
      };
    }
    function N(W) {
      this.start = W, this.end = { line: k, column: C }, this.source = b.source;
    }
    N.prototype.content = x;
    function R(W) {
      var I = new Error(
        b.source + ":" + k + ":" + C + ": " + W
      );
      if (I.reason = W, I.filename = b.source, I.line = k, I.column = C, I.source = x, !b.silent) throw I;
    }
    function j(W) {
      var I = W.exec(x);
      if (I) {
        var G = I[0];
        return _(G), x = x.slice(G.length), I;
      }
    }
    function D() {
      j(n);
    }
    function $(W) {
      var I;
      for (W = W || []; I = z(); )
        I !== !1 && W.push(I);
      return W;
    }
    function z() {
      var W = O();
      if (!(p != x.charAt(0) || m != x.charAt(1))) {
        for (var I = 2; h != x.charAt(I) && (m != x.charAt(I) || p != x.charAt(I + 1)); )
          ++I;
        if (I += 2, h === x.charAt(I - 1))
          return R("End of comment missing");
        var G = x.slice(2, I - 2);
        return C += 2, _(G), x = x.slice(I), C += 2, W({
          type: v,
          comment: G
        });
      }
    }
    function B() {
      var W = O(), I = j(r);
      if (I) {
        if (z(), !j(a)) return R("property missing ':'");
        var G = j(s), L = W({
          type: y,
          property: w(I[0].replace(e, h)),
          value: G ? w(G[0].replace(e, h)) : h
        });
        return j(l), L;
      }
    }
    function P() {
      var W = [];
      $(W);
      for (var I; I = B(); )
        I !== !1 && (W.push(I), $(W));
      return W;
    }
    return D(), P();
  };
  function w(x) {
    return x ? x.replace(c, h) : h;
  }
  return _N;
}
var Sz;
function g6e() {
  if (Sz) return nh;
  Sz = 1;
  var e = nh && nh.__importDefault || function(r) {
    return r && r.__esModule ? r : { default: r };
  };
  Object.defineProperty(nh, "__esModule", { value: !0 }), nh.default = n;
  var t = e(h6e());
  function n(r, a) {
    var s = null;
    if (!r || typeof r != "string")
      return s;
    var l = (0, t.default)(r), c = typeof a == "function";
    return l.forEach(function(d) {
      if (d.type === "declaration") {
        var p = d.property, m = d.value;
        c ? a(p, m, d) : m && (s = s || {}, s[p] = m);
      }
    }), s;
  }
  return nh;
}
var _w = {}, kz;
function v6e() {
  if (kz) return _w;
  kz = 1, Object.defineProperty(_w, "__esModule", { value: !0 }), _w.camelCase = void 0;
  var e = /^--[a-zA-Z0-9_-]+$/, t = /-([a-z])/g, n = /^[^-]+$/, r = /^-(webkit|moz|ms|o|khtml)-/, a = /^-(ms)-/, s = function(p) {
    return !p || n.test(p) || e.test(p);
  }, l = function(p, m) {
    return m.toUpperCase();
  }, c = function(p, m) {
    return "".concat(m, "-");
  }, d = function(p, m) {
    return m === void 0 && (m = {}), s(p) ? p : (p = p.toLowerCase(), m.reactCompat ? p = p.replace(a, c) : p = p.replace(r, c), p.replace(t, l));
  };
  return _w.camelCase = d, _w;
}
var Ew, _z;
function y6e() {
  if (_z) return Ew;
  _z = 1;
  var e = Ew && Ew.__importDefault || function(a) {
    return a && a.__esModule ? a : { default: a };
  }, t = e(g6e()), n = v6e();
  function r(a, s) {
    var l = {};
    return !a || typeof a != "string" || (0, t.default)(a, function(c, d) {
      c && d && (l[(0, n.camelCase)(c, s)] = d);
    }), l;
  }
  return r.default = r, Ew = r, Ew;
}
var b6e = y6e();
const w6e = /* @__PURE__ */ Oc(b6e), pG = mG("end"), K4 = mG("start");
function mG(e) {
  return t;
  function t(n) {
    const r = n && n.position && n.position[e] || {};
    if (typeof r.line == "number" && r.line > 0 && typeof r.column == "number" && r.column > 0)
      return {
        line: r.line,
        column: r.column,
        offset: typeof r.offset == "number" && r.offset > -1 ? r.offset : void 0
      };
  }
}
function x6e(e) {
  const t = K4(e), n = pG(e);
  if (t && n)
    return { start: t, end: n };
}
function ix(e) {
  return !e || typeof e != "object" ? "" : "position" in e || "type" in e ? Ez(e.position) : "start" in e || "end" in e ? Ez(e) : "line" in e || "column" in e ? _3(e) : "";
}
function _3(e) {
  return Cz(e && e.line) + ":" + Cz(e && e.column);
}
function Ez(e) {
  return _3(e && e.start) + "-" + _3(e && e.end);
}
function Cz(e) {
  return e && typeof e == "number" ? e : 1;
}
class Yo extends Error {
  /**
   * Create a message for `reason`.
   *
   * >  **Note**: also has obsolete signatures.
   *
   * @overload
   * @param {string} reason
   * @param {Options | null | undefined} [options]
   * @returns
   *
   * @overload
   * @param {string} reason
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @overload
   * @param {string} reason
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @overload
   * @param {string} reason
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @param {Error | VFileMessage | string} causeOrReason
   *   Reason for message, should use markdown.
   * @param {Node | NodeLike | Options | Point | Position | string | null | undefined} [optionsOrParentOrPlace]
   *   Configuration (optional).
   * @param {string | null | undefined} [origin]
   *   Place in code where the message originates (example:
   *   `'my-package:my-rule'` or `'my-rule'`).
   * @returns
   *   Instance of `VFileMessage`.
   */
  // eslint-disable-next-line complexity
  constructor(t, n, r) {
    super(), typeof n == "string" && (r = n, n = void 0);
    let a = "", s = {}, l = !1;
    if (n && ("line" in n && "column" in n ? s = { place: n } : "start" in n && "end" in n ? s = { place: n } : "type" in n ? s = {
      ancestors: [n],
      place: n.position
    } : s = { ...n }), typeof t == "string" ? a = t : !s.cause && t && (l = !0, a = t.message, s.cause = t), !s.ruleId && !s.source && typeof r == "string") {
      const d = r.indexOf(":");
      d === -1 ? s.ruleId = r : (s.source = r.slice(0, d), s.ruleId = r.slice(d + 1));
    }
    if (!s.place && s.ancestors && s.ancestors) {
      const d = s.ancestors[s.ancestors.length - 1];
      d && (s.place = d.position);
    }
    const c = s.place && "start" in s.place ? s.place.start : s.place;
    this.ancestors = s.ancestors || void 0, this.cause = s.cause || void 0, this.column = c ? c.column : void 0, this.fatal = void 0, this.file, this.message = a, this.line = c ? c.line : void 0, this.name = ix(s.place) || "1:1", this.place = s.place || void 0, this.reason = this.message, this.ruleId = s.ruleId || void 0, this.source = s.source || void 0, this.stack = l && s.cause && typeof s.cause.stack == "string" ? s.cause.stack : "", this.actual, this.expected, this.note, this.url;
  }
}
Yo.prototype.file = "";
Yo.prototype.name = "";
Yo.prototype.reason = "";
Yo.prototype.message = "";
Yo.prototype.stack = "";
Yo.prototype.column = void 0;
Yo.prototype.line = void 0;
Yo.prototype.ancestors = void 0;
Yo.prototype.cause = void 0;
Yo.prototype.fatal = void 0;
Yo.prototype.place = void 0;
Yo.prototype.ruleId = void 0;
Yo.prototype.source = void 0;
const X4 = {}.hasOwnProperty, S6e = /* @__PURE__ */ new Map(), k6e = /[A-Z]/g, _6e = /* @__PURE__ */ new Set(["table", "tbody", "thead", "tfoot", "tr"]), E6e = /* @__PURE__ */ new Set(["td", "th"]), hG = "https://github.com/syntax-tree/hast-util-to-jsx-runtime";
function C6e(e, t) {
  if (!t || t.Fragment === void 0)
    throw new TypeError("Expected `Fragment` in options");
  const n = t.filePath || void 0;
  let r;
  if (t.development) {
    if (typeof t.jsxDEV != "function")
      throw new TypeError(
        "Expected `jsxDEV` in options when `development: true`"
      );
    r = D6e(n, t.jsxDEV);
  } else {
    if (typeof t.jsx != "function")
      throw new TypeError("Expected `jsx` in production options");
    if (typeof t.jsxs != "function")
      throw new TypeError("Expected `jsxs` in production options");
    r = P6e(n, t.jsx, t.jsxs);
  }
  const a = {
    Fragment: t.Fragment,
    ancestors: [],
    components: t.components || {},
    create: r,
    elementAttributeNameCase: t.elementAttributeNameCase || "react",
    evaluater: t.createEvaluater ? t.createEvaluater() : void 0,
    filePath: n,
    ignoreInvalidStyle: t.ignoreInvalidStyle || !1,
    passKeys: t.passKeys !== !1,
    passNode: t.passNode || !1,
    schema: t.space === "svg" ? G4 : p6e,
    stylePropertyNameCase: t.stylePropertyNameCase || "dom",
    tableCellAlignToStyle: t.tableCellAlignToStyle !== !1
  }, s = gG(a, e, void 0);
  return s && typeof s != "string" ? s : a.create(
    e,
    a.Fragment,
    { children: s || void 0 },
    void 0
  );
}
function gG(e, t, n) {
  if (t.type === "element")
    return O6e(e, t, n);
  if (t.type === "mdxFlowExpression" || t.type === "mdxTextExpression")
    return M6e(e, t);
  if (t.type === "mdxJsxFlowElement" || t.type === "mdxJsxTextElement")
    return R6e(e, t, n);
  if (t.type === "mdxjsEsm")
    return N6e(e, t);
  if (t.type === "root")
    return A6e(e, t, n);
  if (t.type === "text")
    return j6e(e, t);
}
function O6e(e, t, n) {
  const r = e.schema;
  let a = r;
  t.tagName.toLowerCase() === "svg" && r.space === "html" && (a = G4, e.schema = a), e.ancestors.push(t);
  const s = yG(e, t.tagName, !1), l = $6e(e, t);
  let c = Q4(e, t);
  return _6e.has(t.tagName) && (c = c.filter(function(d) {
    return typeof d == "string" ? !r6e(d) : !0;
  })), vG(e, l, s, t), Y4(l, c), e.ancestors.pop(), e.schema = r, e.create(t, s, l, n);
}
function M6e(e, t) {
  if (t.data && t.data.estree && e.evaluater) {
    const n = t.data.estree.body[0];
    return n.type, /** @type {Child | undefined} */
    e.evaluater.evaluateExpression(n.expression);
  }
  qx(e, t.position);
}
function N6e(e, t) {
  if (t.data && t.data.estree && e.evaluater)
    return (
      /** @type {Child | undefined} */
      e.evaluater.evaluateProgram(t.data.estree)
    );
  qx(e, t.position);
}
function R6e(e, t, n) {
  const r = e.schema;
  let a = r;
  t.name === "svg" && r.space === "html" && (a = G4, e.schema = a), e.ancestors.push(t);
  const s = t.name === null ? e.Fragment : yG(e, t.name, !0), l = T6e(e, t), c = Q4(e, t);
  return vG(e, l, s, t), Y4(l, c), e.ancestors.pop(), e.schema = r, e.create(t, s, l, n);
}
function A6e(e, t, n) {
  const r = {};
  return Y4(r, Q4(e, t)), e.create(t, e.Fragment, r, n);
}
function j6e(e, t) {
  return t.value;
}
function vG(e, t, n, r) {
  typeof n != "string" && n !== e.Fragment && e.passNode && (t.node = r);
}
function Y4(e, t) {
  if (t.length > 0) {
    const n = t.length > 1 ? t : t[0];
    n && (e.children = n);
  }
}
function P6e(e, t, n) {
  return r;
  function r(a, s, l, c) {
    const d = Array.isArray(l.children) ? n : t;
    return c ? d(s, l, c) : d(s, l);
  }
}
function D6e(e, t) {
  return n;
  function n(r, a, s, l) {
    const c = Array.isArray(s.children), d = K4(r);
    return t(
      a,
      s,
      l,
      c,
      {
        columnNumber: d ? d.column - 1 : void 0,
        fileName: e,
        lineNumber: d ? d.line : void 0
      },
      void 0
    );
  }
}
function $6e(e, t) {
  const n = {};
  let r, a;
  for (a in t.properties)
    if (a !== "children" && X4.call(t.properties, a)) {
      const s = L6e(e, a, t.properties[a]);
      if (s) {
        const [l, c] = s;
        e.tableCellAlignToStyle && l === "align" && typeof c == "string" && E6e.has(t.tagName) ? r = c : n[l] = c;
      }
    }
  if (r) {
    const s = (
      /** @type {Style} */
      n.style || (n.style = {})
    );
    s[e.stylePropertyNameCase === "css" ? "text-align" : "textAlign"] = r;
  }
  return n;
}
function T6e(e, t) {
  const n = {};
  for (const r of t.attributes)
    if (r.type === "mdxJsxExpressionAttribute")
      if (r.data && r.data.estree && e.evaluater) {
        const a = r.data.estree.body[0];
        a.type;
        const s = a.expression;
        s.type;
        const l = s.properties[0];
        l.type, Object.assign(
          n,
          e.evaluater.evaluateExpression(l.argument)
        );
      } else
        qx(e, t.position);
    else {
      const a = r.name;
      let s;
      if (r.value && typeof r.value == "object")
        if (r.value.data && r.value.data.estree && e.evaluater) {
          const l = r.value.data.estree.body[0];
          l.type, s = e.evaluater.evaluateExpression(l.expression);
        } else
          qx(e, t.position);
      else
        s = r.value === null ? !0 : r.value;
      n[a] = /** @type {Props[keyof Props]} */
      s;
    }
  return n;
}
function Q4(e, t) {
  const n = [];
  let r = -1;
  const a = e.passKeys ? /* @__PURE__ */ new Map() : S6e;
  for (; ++r < t.children.length; ) {
    const s = t.children[r];
    let l;
    if (e.passKeys) {
      const d = s.type === "element" ? s.tagName : s.type === "mdxJsxFlowElement" || s.type === "mdxJsxTextElement" ? s.name : void 0;
      if (d) {
        const p = a.get(d) || 0;
        l = d + "-" + p, a.set(d, p + 1);
      }
    }
    const c = gG(e, s, l);
    c !== void 0 && n.push(c);
  }
  return n;
}
function L6e(e, t, n) {
  const r = c6e(e.schema, t);
  if (!(n == null || typeof n == "number" && Number.isNaN(n))) {
    if (Array.isArray(n) && (n = r.commaSeparated ? JDe(n) : m6e(n)), r.property === "style") {
      let a = typeof n == "object" ? n : I6e(e, String(n));
      return e.stylePropertyNameCase === "css" && (a = z6e(a)), ["style", a];
    }
    return [
      e.elementAttributeNameCase === "react" && r.space ? s6e[r.property] || r.property : r.attribute,
      n
    ];
  }
}
function I6e(e, t) {
  try {
    return w6e(t, { reactCompat: !0 });
  } catch (n) {
    if (e.ignoreInvalidStyle)
      return {};
    const r = (
      /** @type {Error} */
      n
    ), a = new Yo("Cannot parse `style` attribute", {
      ancestors: e.ancestors,
      cause: r,
      ruleId: "style",
      source: "hast-util-to-jsx-runtime"
    });
    throw a.file = e.filePath || void 0, a.url = hG + "#cannot-parse-style-attribute", a;
  }
}
function yG(e, t, n) {
  let r;
  if (!n)
    r = { type: "Literal", value: t };
  else if (t.includes(".")) {
    const a = t.split(".");
    let s = -1, l;
    for (; ++s < a.length; ) {
      const c = vz(a[s]) ? { type: "Identifier", name: a[s] } : { type: "Literal", value: a[s] };
      l = l ? {
        type: "MemberExpression",
        object: l,
        property: c,
        computed: !!(s && c.type === "Literal"),
        optional: !1
      } : c;
    }
    r = l;
  } else
    r = vz(t) && !/^[a-z]/.test(t) ? { type: "Identifier", name: t } : { type: "Literal", value: t };
  if (r.type === "Literal") {
    const a = (
      /** @type {string | number} */
      r.value
    );
    return X4.call(e.components, a) ? e.components[a] : a;
  }
  if (e.evaluater)
    return e.evaluater.evaluateExpression(r);
  qx(e);
}
function qx(e, t) {
  const n = new Yo(
    "Cannot handle MDX estrees without `createEvaluater`",
    {
      ancestors: e.ancestors,
      place: t,
      ruleId: "mdx-estree",
      source: "hast-util-to-jsx-runtime"
    }
  );
  throw n.file = e.filePath || void 0, n.url = hG + "#cannot-handle-mdx-estrees-without-createevaluater", n;
}
function z6e(e) {
  const t = {};
  let n;
  for (n in e)
    X4.call(e, n) && (t[F6e(n)] = e[n]);
  return t;
}
function F6e(e) {
  let t = e.replace(k6e, B6e);
  return t.slice(0, 3) === "ms-" && (t = "-" + t), t;
}
function B6e(e) {
  return "-" + e.toLowerCase();
}
const EN = {
  action: ["form"],
  cite: ["blockquote", "del", "ins", "q"],
  data: ["object"],
  formAction: ["button", "input"],
  href: ["a", "area", "base", "link"],
  icon: ["menuitem"],
  itemId: null,
  manifest: ["html"],
  ping: ["a", "area"],
  poster: ["video"],
  src: [
    "audio",
    "embed",
    "iframe",
    "img",
    "input",
    "script",
    "source",
    "track",
    "video"
  ]
}, U6e = {};
function J4(e, t) {
  const n = U6e, r = typeof n.includeImageAlt == "boolean" ? n.includeImageAlt : !0, a = typeof n.includeHtml == "boolean" ? n.includeHtml : !0;
  return bG(e, r, a);
}
function bG(e, t, n) {
  if (V6e(e)) {
    if ("value" in e)
      return e.type === "html" && !n ? "" : e.value;
    if (t && "alt" in e && e.alt)
      return e.alt;
    if ("children" in e)
      return Oz(e.children, t, n);
  }
  return Array.isArray(e) ? Oz(e, t, n) : "";
}
function Oz(e, t, n) {
  const r = [];
  let a = -1;
  for (; ++a < e.length; )
    r[a] = bG(e[a], t, n);
  return r.join("");
}
function V6e(e) {
  return !!(e && typeof e == "object");
}
const Mz = document.createElement("i");
function Z4(e) {
  const t = "&" + e + ";";
  Mz.innerHTML = t;
  const n = Mz.textContent;
  return (
    // @ts-expect-error: TypeScript is wrong that `textContent` on elements can
    // yield `null`.
    n.charCodeAt(n.length - 1) === 59 && e !== "semi" || n === t ? !1 : n
  );
}
function bi(e, t, n, r) {
  const a = e.length;
  let s = 0, l;
  if (t < 0 ? t = -t > a ? 0 : a + t : t = t > a ? a : t, n = n > 0 ? n : 0, r.length < 1e4)
    l = Array.from(r), l.unshift(t, n), e.splice(...l);
  else
    for (n && e.splice(t, n); s < r.length; )
      l = r.slice(s, s + 1e4), l.unshift(t, 0), e.splice(...l), s += 1e4, t += 1e4;
}
function Ri(e, t) {
  return e.length > 0 ? (bi(e, e.length, 0, t), e) : t;
}
const Nz = {}.hasOwnProperty;
function wG(e) {
  const t = {};
  let n = -1;
  for (; ++n < e.length; )
    H6e(t, e[n]);
  return t;
}
function H6e(e, t) {
  let n;
  for (n in t) {
    const r = (Nz.call(e, n) ? e[n] : void 0) || (e[n] = {}), a = t[n];
    let s;
    if (a)
      for (s in a) {
        Nz.call(r, s) || (r[s] = []);
        const l = a[s];
        q6e(
          // @ts-expect-error Looks like a list.
          r[s],
          Array.isArray(l) ? l : l ? [l] : []
        );
      }
  }
}
function q6e(e, t) {
  let n = -1;
  const r = [];
  for (; ++n < t.length; )
    (t[n].add === "after" ? e : r).push(t[n]);
  bi(e, 0, 0, r);
}
function xG(e, t) {
  const n = Number.parseInt(e, t);
  return (
    // C0 except for HT, LF, FF, CR, space.
    n < 9 || n === 11 || n > 13 && n < 32 || // Control character (DEL) of C0, and C1 controls.
    n > 126 && n < 160 || // Lone high surrogates and low surrogates.
    n > 55295 && n < 57344 || // Noncharacters.
    n > 64975 && n < 65008 || /* eslint-disable no-bitwise */
    (n & 65535) === 65535 || (n & 65535) === 65534 || /* eslint-enable no-bitwise */
    // Out of range
    n > 1114111 ? "" : String.fromCodePoint(n)
  );
}
function Is(e) {
  return e.replace(/[\t\n\r ]+/g, " ").replace(/^ | $/g, "").toLowerCase().toUpperCase();
}
const ba = wd(/[A-Za-z]/), Wo = wd(/[\dA-Za-z]/), W6e = wd(/[#-'*+\--9=?A-Z^-~]/);
function F_(e) {
  return (
    // Special whitespace codes (which have negative values), C0 and Control
    // character DEL
    e !== null && (e < 32 || e === 127)
  );
}
const E3 = wd(/\d/), G6e = wd(/[\dA-Fa-f]/), K6e = wd(/[!-/:-@[-`{-~]/);
function mt(e) {
  return e !== null && e < -2;
}
function qn(e) {
  return e !== null && (e < 0 || e === 32);
}
function Jt(e) {
  return e === -2 || e === -1 || e === 32;
}
const RE = wd(new RegExp("\\p{P}|\\p{S}", "u")), wm = wd(/\s/);
function wd(e) {
  return t;
  function t(n) {
    return n !== null && n > -1 && e.test(String.fromCharCode(n));
  }
}
function pg(e) {
  const t = [];
  let n = -1, r = 0, a = 0;
  for (; ++n < e.length; ) {
    const s = e.charCodeAt(n);
    let l = "";
    if (s === 37 && Wo(e.charCodeAt(n + 1)) && Wo(e.charCodeAt(n + 2)))
      a = 2;
    else if (s < 128)
      /[!#$&-;=?-Z_a-z~]/.test(String.fromCharCode(s)) || (l = String.fromCharCode(s));
    else if (s > 55295 && s < 57344) {
      const c = e.charCodeAt(n + 1);
      s < 56320 && c > 56319 && c < 57344 ? (l = String.fromCharCode(s, c), a = 1) : l = "";
    } else
      l = String.fromCharCode(s);
    l && (t.push(e.slice(r, n), encodeURIComponent(l)), r = n + a + 1, l = ""), a && (n += a, a = 0);
  }
  return t.join("") + e.slice(r);
}
function ln(e, t, n, r) {
  const a = r ? r - 1 : Number.POSITIVE_INFINITY;
  let s = 0;
  return l;
  function l(d) {
    return Jt(d) ? (e.enter(n), c(d)) : t(d);
  }
  function c(d) {
    return Jt(d) && s++ < a ? (e.consume(d), c) : (e.exit(n), t(d));
  }
}
const X6e = {
  tokenize: Y6e
};
function Y6e(e) {
  const t = e.attempt(this.parser.constructs.contentInitial, r, a);
  let n;
  return t;
  function r(c) {
    if (c === null) {
      e.consume(c);
      return;
    }
    return e.enter("lineEnding"), e.consume(c), e.exit("lineEnding"), ln(e, t, "linePrefix");
  }
  function a(c) {
    return e.enter("paragraph"), s(c);
  }
  function s(c) {
    const d = e.enter("chunkText", {
      contentType: "text",
      previous: n
    });
    return n && (n.next = d), n = d, l(c);
  }
  function l(c) {
    if (c === null) {
      e.exit("chunkText"), e.exit("paragraph"), e.consume(c);
      return;
    }
    return mt(c) ? (e.consume(c), e.exit("chunkText"), s) : (e.consume(c), l);
  }
}
const Q6e = {
  tokenize: J6e
}, Rz = {
  tokenize: Z6e
};
function J6e(e) {
  const t = this, n = [];
  let r = 0, a, s, l;
  return c;
  function c(_) {
    if (r < n.length) {
      const O = n[r];
      return t.containerState = O[1], e.attempt(O[0].continuation, d, p)(_);
    }
    return p(_);
  }
  function d(_) {
    if (r++, t.containerState._closeFlow) {
      t.containerState._closeFlow = void 0, a && C();
      const O = t.events.length;
      let N = O, R;
      for (; N--; )
        if (t.events[N][0] === "exit" && t.events[N][1].type === "chunkFlow") {
          R = t.events[N][1].end;
          break;
        }
      k(r);
      let j = O;
      for (; j < t.events.length; )
        t.events[j][1].end = {
          ...R
        }, j++;
      return bi(t.events, N + 1, 0, t.events.slice(O)), t.events.length = j, p(_);
    }
    return c(_);
  }
  function p(_) {
    if (r === n.length) {
      if (!a)
        return v(_);
      if (a.currentConstruct && a.currentConstruct.concrete)
        return w(_);
      t.interrupt = !!(a.currentConstruct && !a._gfmTableDynamicInterruptHack);
    }
    return t.containerState = {}, e.check(Rz, m, h)(_);
  }
  function m(_) {
    return a && C(), k(r), v(_);
  }
  function h(_) {
    return t.parser.lazy[t.now().line] = r !== n.length, l = t.now().offset, w(_);
  }
  function v(_) {
    return t.containerState = {}, e.attempt(Rz, y, w)(_);
  }
  function y(_) {
    return r++, n.push([t.currentConstruct, t.containerState]), v(_);
  }
  function w(_) {
    if (_ === null) {
      a && C(), k(0), e.consume(_);
      return;
    }
    return a = a || t.parser.flow(t.now()), e.enter("chunkFlow", {
      _tokenizer: a,
      contentType: "flow",
      previous: s
    }), x(_);
  }
  function x(_) {
    if (_ === null) {
      b(e.exit("chunkFlow"), !0), k(0), e.consume(_);
      return;
    }
    return mt(_) ? (e.consume(_), b(e.exit("chunkFlow")), r = 0, t.interrupt = void 0, c) : (e.consume(_), x);
  }
  function b(_, O) {
    const N = t.sliceStream(_);
    if (O && N.push(null), _.previous = s, s && (s.next = _), s = _, a.defineSkip(_.start), a.write(N), t.parser.lazy[_.start.line]) {
      let R = a.events.length;
      for (; R--; )
        if (
          // The token starts before the line ending
          a.events[R][1].start.offset < l && // and either is not ended yet
          (!a.events[R][1].end || // or ends after it.
          a.events[R][1].end.offset > l)
        )
          return;
      const j = t.events.length;
      let D = j, $, z;
      for (; D--; )
        if (t.events[D][0] === "exit" && t.events[D][1].type === "chunkFlow") {
          if ($) {
            z = t.events[D][1].end;
            break;
          }
          $ = !0;
        }
      for (k(r), R = j; R < t.events.length; )
        t.events[R][1].end = {
          ...z
        }, R++;
      bi(t.events, D + 1, 0, t.events.slice(j)), t.events.length = R;
    }
  }
  function k(_) {
    let O = n.length;
    for (; O-- > _; ) {
      const N = n[O];
      t.containerState = N[1], N[0].exit.call(t, e);
    }
    n.length = _;
  }
  function C() {
    a.write([null]), s = void 0, a = void 0, t.containerState._closeFlow = void 0;
  }
}
function Z6e(e, t, n) {
  return ln(e, e.attempt(this.parser.constructs.document, t, n), "linePrefix", this.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4);
}
function Qh(e) {
  if (e === null || qn(e) || wm(e))
    return 1;
  if (RE(e))
    return 2;
}
function AE(e, t, n) {
  const r = [];
  let a = -1;
  for (; ++a < e.length; ) {
    const s = e[a].resolveAll;
    s && !r.includes(s) && (t = s(t, n), r.push(s));
  }
  return t;
}
const C3 = {
  name: "attention",
  resolveAll: e$e,
  tokenize: t$e
};
function e$e(e, t) {
  let n = -1, r, a, s, l, c, d, p, m;
  for (; ++n < e.length; )
    if (e[n][0] === "enter" && e[n][1].type === "attentionSequence" && e[n][1]._close) {
      for (r = n; r--; )
        if (e[r][0] === "exit" && e[r][1].type === "attentionSequence" && e[r][1]._open && // If the markers are the same:
        t.sliceSerialize(e[r][1]).charCodeAt(0) === t.sliceSerialize(e[n][1]).charCodeAt(0)) {
          if ((e[r][1]._close || e[n][1]._open) && (e[n][1].end.offset - e[n][1].start.offset) % 3 && !((e[r][1].end.offset - e[r][1].start.offset + e[n][1].end.offset - e[n][1].start.offset) % 3))
            continue;
          d = e[r][1].end.offset - e[r][1].start.offset > 1 && e[n][1].end.offset - e[n][1].start.offset > 1 ? 2 : 1;
          const h = {
            ...e[r][1].end
          }, v = {
            ...e[n][1].start
          };
          Az(h, -d), Az(v, d), l = {
            type: d > 1 ? "strongSequence" : "emphasisSequence",
            start: h,
            end: {
              ...e[r][1].end
            }
          }, c = {
            type: d > 1 ? "strongSequence" : "emphasisSequence",
            start: {
              ...e[n][1].start
            },
            end: v
          }, s = {
            type: d > 1 ? "strongText" : "emphasisText",
            start: {
              ...e[r][1].end
            },
            end: {
              ...e[n][1].start
            }
          }, a = {
            type: d > 1 ? "strong" : "emphasis",
            start: {
              ...l.start
            },
            end: {
              ...c.end
            }
          }, e[r][1].end = {
            ...l.start
          }, e[n][1].start = {
            ...c.end
          }, p = [], e[r][1].end.offset - e[r][1].start.offset && (p = Ri(p, [["enter", e[r][1], t], ["exit", e[r][1], t]])), p = Ri(p, [["enter", a, t], ["enter", l, t], ["exit", l, t], ["enter", s, t]]), p = Ri(p, AE(t.parser.constructs.insideSpan.null, e.slice(r + 1, n), t)), p = Ri(p, [["exit", s, t], ["enter", c, t], ["exit", c, t], ["exit", a, t]]), e[n][1].end.offset - e[n][1].start.offset ? (m = 2, p = Ri(p, [["enter", e[n][1], t], ["exit", e[n][1], t]])) : m = 0, bi(e, r - 1, n - r + 3, p), n = r + p.length - m - 2;
          break;
        }
    }
  for (n = -1; ++n < e.length; )
    e[n][1].type === "attentionSequence" && (e[n][1].type = "data");
  return e;
}
function t$e(e, t) {
  const n = this.parser.constructs.attentionMarkers.null, r = this.previous, a = Qh(r);
  let s;
  return l;
  function l(d) {
    return s = d, e.enter("attentionSequence"), c(d);
  }
  function c(d) {
    if (d === s)
      return e.consume(d), c;
    const p = e.exit("attentionSequence"), m = Qh(d), h = !m || m === 2 && a || n.includes(d), v = !a || a === 2 && m || n.includes(r);
    return p._open = !!(s === 42 ? h : h && (a || !v)), p._close = !!(s === 42 ? v : v && (m || !h)), t(d);
  }
}
function Az(e, t) {
  e.column += t, e.offset += t, e._bufferIndex += t;
}
const n$e = {
  name: "autolink",
  tokenize: r$e
};
function r$e(e, t, n) {
  let r = 0;
  return a;
  function a(y) {
    return e.enter("autolink"), e.enter("autolinkMarker"), e.consume(y), e.exit("autolinkMarker"), e.enter("autolinkProtocol"), s;
  }
  function s(y) {
    return ba(y) ? (e.consume(y), l) : y === 64 ? n(y) : p(y);
  }
  function l(y) {
    return y === 43 || y === 45 || y === 46 || Wo(y) ? (r = 1, c(y)) : p(y);
  }
  function c(y) {
    return y === 58 ? (e.consume(y), r = 0, d) : (y === 43 || y === 45 || y === 46 || Wo(y)) && r++ < 32 ? (e.consume(y), c) : (r = 0, p(y));
  }
  function d(y) {
    return y === 62 ? (e.exit("autolinkProtocol"), e.enter("autolinkMarker"), e.consume(y), e.exit("autolinkMarker"), e.exit("autolink"), t) : y === null || y === 32 || y === 60 || F_(y) ? n(y) : (e.consume(y), d);
  }
  function p(y) {
    return y === 64 ? (e.consume(y), m) : W6e(y) ? (e.consume(y), p) : n(y);
  }
  function m(y) {
    return Wo(y) ? h(y) : n(y);
  }
  function h(y) {
    return y === 46 ? (e.consume(y), r = 0, m) : y === 62 ? (e.exit("autolinkProtocol").type = "autolinkEmail", e.enter("autolinkMarker"), e.consume(y), e.exit("autolinkMarker"), e.exit("autolink"), t) : v(y);
  }
  function v(y) {
    if ((y === 45 || Wo(y)) && r++ < 63) {
      const w = y === 45 ? v : h;
      return e.consume(y), w;
    }
    return n(y);
  }
}
const zS = {
  partial: !0,
  tokenize: o$e
};
function o$e(e, t, n) {
  return r;
  function r(s) {
    return Jt(s) ? ln(e, a, "linePrefix")(s) : a(s);
  }
  function a(s) {
    return s === null || mt(s) ? t(s) : n(s);
  }
}
const SG = {
  continuation: {
    tokenize: i$e
  },
  exit: s$e,
  name: "blockQuote",
  tokenize: a$e
};
function a$e(e, t, n) {
  const r = this;
  return a;
  function a(l) {
    if (l === 62) {
      const c = r.containerState;
      return c.open || (e.enter("blockQuote", {
        _container: !0
      }), c.open = !0), e.enter("blockQuotePrefix"), e.enter("blockQuoteMarker"), e.consume(l), e.exit("blockQuoteMarker"), s;
    }
    return n(l);
  }
  function s(l) {
    return Jt(l) ? (e.enter("blockQuotePrefixWhitespace"), e.consume(l), e.exit("blockQuotePrefixWhitespace"), e.exit("blockQuotePrefix"), t) : (e.exit("blockQuotePrefix"), t(l));
  }
}
function i$e(e, t, n) {
  const r = this;
  return a;
  function a(l) {
    return Jt(l) ? ln(e, s, "linePrefix", r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(l) : s(l);
  }
  function s(l) {
    return e.attempt(SG, t, n)(l);
  }
}
function s$e(e) {
  e.exit("blockQuote");
}
const kG = {
  name: "characterEscape",
  tokenize: l$e
};
function l$e(e, t, n) {
  return r;
  function r(s) {
    return e.enter("characterEscape"), e.enter("escapeMarker"), e.consume(s), e.exit("escapeMarker"), a;
  }
  function a(s) {
    return K6e(s) ? (e.enter("characterEscapeValue"), e.consume(s), e.exit("characterEscapeValue"), e.exit("characterEscape"), t) : n(s);
  }
}
const _G = {
  name: "characterReference",
  tokenize: u$e
};
function u$e(e, t, n) {
  const r = this;
  let a = 0, s, l;
  return c;
  function c(h) {
    return e.enter("characterReference"), e.enter("characterReferenceMarker"), e.consume(h), e.exit("characterReferenceMarker"), d;
  }
  function d(h) {
    return h === 35 ? (e.enter("characterReferenceMarkerNumeric"), e.consume(h), e.exit("characterReferenceMarkerNumeric"), p) : (e.enter("characterReferenceValue"), s = 31, l = Wo, m(h));
  }
  function p(h) {
    return h === 88 || h === 120 ? (e.enter("characterReferenceMarkerHexadecimal"), e.consume(h), e.exit("characterReferenceMarkerHexadecimal"), e.enter("characterReferenceValue"), s = 6, l = G6e, m) : (e.enter("characterReferenceValue"), s = 7, l = E3, m(h));
  }
  function m(h) {
    if (h === 59 && a) {
      const v = e.exit("characterReferenceValue");
      return l === Wo && !Z4(r.sliceSerialize(v)) ? n(h) : (e.enter("characterReferenceMarker"), e.consume(h), e.exit("characterReferenceMarker"), e.exit("characterReference"), t);
    }
    return l(h) && a++ < s ? (e.consume(h), m) : n(h);
  }
}
const jz = {
  partial: !0,
  tokenize: d$e
}, Pz = {
  concrete: !0,
  name: "codeFenced",
  tokenize: c$e
};
function c$e(e, t, n) {
  const r = this, a = {
    partial: !0,
    tokenize: N
  };
  let s = 0, l = 0, c;
  return d;
  function d(R) {
    return p(R);
  }
  function p(R) {
    const j = r.events[r.events.length - 1];
    return s = j && j[1].type === "linePrefix" ? j[2].sliceSerialize(j[1], !0).length : 0, c = R, e.enter("codeFenced"), e.enter("codeFencedFence"), e.enter("codeFencedFenceSequence"), m(R);
  }
  function m(R) {
    return R === c ? (l++, e.consume(R), m) : l < 3 ? n(R) : (e.exit("codeFencedFenceSequence"), Jt(R) ? ln(e, h, "whitespace")(R) : h(R));
  }
  function h(R) {
    return R === null || mt(R) ? (e.exit("codeFencedFence"), r.interrupt ? t(R) : e.check(jz, x, O)(R)) : (e.enter("codeFencedFenceInfo"), e.enter("chunkString", {
      contentType: "string"
    }), v(R));
  }
  function v(R) {
    return R === null || mt(R) ? (e.exit("chunkString"), e.exit("codeFencedFenceInfo"), h(R)) : Jt(R) ? (e.exit("chunkString"), e.exit("codeFencedFenceInfo"), ln(e, y, "whitespace")(R)) : R === 96 && R === c ? n(R) : (e.consume(R), v);
  }
  function y(R) {
    return R === null || mt(R) ? h(R) : (e.enter("codeFencedFenceMeta"), e.enter("chunkString", {
      contentType: "string"
    }), w(R));
  }
  function w(R) {
    return R === null || mt(R) ? (e.exit("chunkString"), e.exit("codeFencedFenceMeta"), h(R)) : R === 96 && R === c ? n(R) : (e.consume(R), w);
  }
  function x(R) {
    return e.attempt(a, O, b)(R);
  }
  function b(R) {
    return e.enter("lineEnding"), e.consume(R), e.exit("lineEnding"), k;
  }
  function k(R) {
    return s > 0 && Jt(R) ? ln(e, C, "linePrefix", s + 1)(R) : C(R);
  }
  function C(R) {
    return R === null || mt(R) ? e.check(jz, x, O)(R) : (e.enter("codeFlowValue"), _(R));
  }
  function _(R) {
    return R === null || mt(R) ? (e.exit("codeFlowValue"), C(R)) : (e.consume(R), _);
  }
  function O(R) {
    return e.exit("codeFenced"), t(R);
  }
  function N(R, j, D) {
    let $ = 0;
    return z;
    function z(G) {
      return R.enter("lineEnding"), R.consume(G), R.exit("lineEnding"), B;
    }
    function B(G) {
      return R.enter("codeFencedFence"), Jt(G) ? ln(R, P, "linePrefix", r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(G) : P(G);
    }
    function P(G) {
      return G === c ? (R.enter("codeFencedFenceSequence"), W(G)) : D(G);
    }
    function W(G) {
      return G === c ? ($++, R.consume(G), W) : $ >= l ? (R.exit("codeFencedFenceSequence"), Jt(G) ? ln(R, I, "whitespace")(G) : I(G)) : D(G);
    }
    function I(G) {
      return G === null || mt(G) ? (R.exit("codeFencedFence"), j(G)) : D(G);
    }
  }
}
function d$e(e, t, n) {
  const r = this;
  return a;
  function a(l) {
    return l === null ? n(l) : (e.enter("lineEnding"), e.consume(l), e.exit("lineEnding"), s);
  }
  function s(l) {
    return r.parser.lazy[r.now().line] ? n(l) : t(l);
  }
}
const CN = {
  name: "codeIndented",
  tokenize: p$e
}, f$e = {
  partial: !0,
  tokenize: m$e
};
function p$e(e, t, n) {
  const r = this;
  return a;
  function a(p) {
    return e.enter("codeIndented"), ln(e, s, "linePrefix", 5)(p);
  }
  function s(p) {
    const m = r.events[r.events.length - 1];
    return m && m[1].type === "linePrefix" && m[2].sliceSerialize(m[1], !0).length >= 4 ? l(p) : n(p);
  }
  function l(p) {
    return p === null ? d(p) : mt(p) ? e.attempt(f$e, l, d)(p) : (e.enter("codeFlowValue"), c(p));
  }
  function c(p) {
    return p === null || mt(p) ? (e.exit("codeFlowValue"), l(p)) : (e.consume(p), c);
  }
  function d(p) {
    return e.exit("codeIndented"), t(p);
  }
}
function m$e(e, t, n) {
  const r = this;
  return a;
  function a(l) {
    return r.parser.lazy[r.now().line] ? n(l) : mt(l) ? (e.enter("lineEnding"), e.consume(l), e.exit("lineEnding"), a) : ln(e, s, "linePrefix", 5)(l);
  }
  function s(l) {
    const c = r.events[r.events.length - 1];
    return c && c[1].type === "linePrefix" && c[2].sliceSerialize(c[1], !0).length >= 4 ? t(l) : mt(l) ? a(l) : n(l);
  }
}
const h$e = {
  name: "codeText",
  previous: v$e,
  resolve: g$e,
  tokenize: y$e
};
function g$e(e) {
  let t = e.length - 4, n = 3, r, a;
  if ((e[n][1].type === "lineEnding" || e[n][1].type === "space") && (e[t][1].type === "lineEnding" || e[t][1].type === "space")) {
    for (r = n; ++r < t; )
      if (e[r][1].type === "codeTextData") {
        e[n][1].type = "codeTextPadding", e[t][1].type = "codeTextPadding", n += 2, t -= 2;
        break;
      }
  }
  for (r = n - 1, t++; ++r <= t; )
    a === void 0 ? r !== t && e[r][1].type !== "lineEnding" && (a = r) : (r === t || e[r][1].type === "lineEnding") && (e[a][1].type = "codeTextData", r !== a + 2 && (e[a][1].end = e[r - 1][1].end, e.splice(a + 2, r - a - 2), t -= r - a - 2, r = a + 2), a = void 0);
  return e;
}
function v$e(e) {
  return e !== 96 || this.events[this.events.length - 1][1].type === "characterEscape";
}
function y$e(e, t, n) {
  let r = 0, a, s;
  return l;
  function l(h) {
    return e.enter("codeText"), e.enter("codeTextSequence"), c(h);
  }
  function c(h) {
    return h === 96 ? (e.consume(h), r++, c) : (e.exit("codeTextSequence"), d(h));
  }
  function d(h) {
    return h === null ? n(h) : h === 32 ? (e.enter("space"), e.consume(h), e.exit("space"), d) : h === 96 ? (s = e.enter("codeTextSequence"), a = 0, m(h)) : mt(h) ? (e.enter("lineEnding"), e.consume(h), e.exit("lineEnding"), d) : (e.enter("codeTextData"), p(h));
  }
  function p(h) {
    return h === null || h === 32 || h === 96 || mt(h) ? (e.exit("codeTextData"), d(h)) : (e.consume(h), p);
  }
  function m(h) {
    return h === 96 ? (e.consume(h), a++, m) : a === r ? (e.exit("codeTextSequence"), e.exit("codeText"), t(h)) : (s.type = "codeTextData", p(h));
  }
}
class b$e {
  /**
   * @param {ReadonlyArray<T> | null | undefined} [initial]
   *   Initial items (optional).
   * @returns
   *   Splice buffer.
   */
  constructor(t) {
    this.left = t ? [...t] : [], this.right = [];
  }
  /**
   * Array access;
   * does not move the cursor.
   *
   * @param {number} index
   *   Index.
   * @return {T}
   *   Item.
   */
  get(t) {
    if (t < 0 || t >= this.left.length + this.right.length)
      throw new RangeError("Cannot access index `" + t + "` in a splice buffer of size `" + (this.left.length + this.right.length) + "`");
    return t < this.left.length ? this.left[t] : this.right[this.right.length - t + this.left.length - 1];
  }
  /**
   * The length of the splice buffer, one greater than the largest index in the
   * array.
   */
  get length() {
    return this.left.length + this.right.length;
  }
  /**
   * Remove and return `list[0]`;
   * moves the cursor to `0`.
   *
   * @returns {T | undefined}
   *   Item, optional.
   */
  shift() {
    return this.setCursor(0), this.right.pop();
  }
  /**
   * Slice the buffer to get an array;
   * does not move the cursor.
   *
   * @param {number} start
   *   Start.
   * @param {number | null | undefined} [end]
   *   End (optional).
   * @returns {Array<T>}
   *   Array of items.
   */
  slice(t, n) {
    const r = n ?? Number.POSITIVE_INFINITY;
    return r < this.left.length ? this.left.slice(t, r) : t > this.left.length ? this.right.slice(this.right.length - r + this.left.length, this.right.length - t + this.left.length).reverse() : this.left.slice(t).concat(this.right.slice(this.right.length - r + this.left.length).reverse());
  }
  /**
   * Mimics the behavior of Array.prototype.splice() except for the change of
   * interface necessary to avoid segfaults when patching in very large arrays.
   *
   * This operation moves cursor is moved to `start` and results in the cursor
   * placed after any inserted items.
   *
   * @param {number} start
   *   Start;
   *   zero-based index at which to start changing the array;
   *   negative numbers count backwards from the end of the array and values
   *   that are out-of bounds are clamped to the appropriate end of the array.
   * @param {number | null | undefined} [deleteCount=0]
   *   Delete count (default: `0`);
   *   maximum number of elements to delete, starting from start.
   * @param {Array<T> | null | undefined} [items=[]]
   *   Items to include in place of the deleted items (default: `[]`).
   * @return {Array<T>}
   *   Any removed items.
   */
  splice(t, n, r) {
    const a = n || 0;
    this.setCursor(Math.trunc(t));
    const s = this.right.splice(this.right.length - a, Number.POSITIVE_INFINITY);
    return r && Cw(this.left, r), s.reverse();
  }
  /**
   * Remove and return the highest-numbered item in the array, so
   * `list[list.length - 1]`;
   * Moves the cursor to `length`.
   *
   * @returns {T | undefined}
   *   Item, optional.
   */
  pop() {
    return this.setCursor(Number.POSITIVE_INFINITY), this.left.pop();
  }
  /**
   * Inserts a single item to the high-numbered side of the array;
   * moves the cursor to `length`.
   *
   * @param {T} item
   *   Item.
   * @returns {undefined}
   *   Nothing.
   */
  push(t) {
    this.setCursor(Number.POSITIVE_INFINITY), this.left.push(t);
  }
  /**
   * Inserts many items to the high-numbered side of the array.
   * Moves the cursor to `length`.
   *
   * @param {Array<T>} items
   *   Items.
   * @returns {undefined}
   *   Nothing.
   */
  pushMany(t) {
    this.setCursor(Number.POSITIVE_INFINITY), Cw(this.left, t);
  }
  /**
   * Inserts a single item to the low-numbered side of the array;
   * Moves the cursor to `0`.
   *
   * @param {T} item
   *   Item.
   * @returns {undefined}
   *   Nothing.
   */
  unshift(t) {
    this.setCursor(0), this.right.push(t);
  }
  /**
   * Inserts many items to the low-numbered side of the array;
   * moves the cursor to `0`.
   *
   * @param {Array<T>} items
   *   Items.
   * @returns {undefined}
   *   Nothing.
   */
  unshiftMany(t) {
    this.setCursor(0), Cw(this.right, t.reverse());
  }
  /**
   * Move the cursor to a specific position in the array. Requires
   * time proportional to the distance moved.
   *
   * If `n < 0`, the cursor will end up at the beginning.
   * If `n > length`, the cursor will end up at the end.
   *
   * @param {number} n
   *   Position.
   * @return {undefined}
   *   Nothing.
   */
  setCursor(t) {
    if (!(t === this.left.length || t > this.left.length && this.right.length === 0 || t < 0 && this.left.length === 0))
      if (t < this.left.length) {
        const n = this.left.splice(t, Number.POSITIVE_INFINITY);
        Cw(this.right, n.reverse());
      } else {
        const n = this.right.splice(this.left.length + this.right.length - t, Number.POSITIVE_INFINITY);
        Cw(this.left, n.reverse());
      }
  }
}
function Cw(e, t) {
  let n = 0;
  if (t.length < 1e4)
    e.push(...t);
  else
    for (; n < t.length; )
      e.push(...t.slice(n, n + 1e4)), n += 1e4;
}
function EG(e) {
  const t = {};
  let n = -1, r, a, s, l, c, d, p;
  const m = new b$e(e);
  for (; ++n < m.length; ) {
    for (; n in t; )
      n = t[n];
    if (r = m.get(n), n && r[1].type === "chunkFlow" && m.get(n - 1)[1].type === "listItemPrefix" && (d = r[1]._tokenizer.events, s = 0, s < d.length && d[s][1].type === "lineEndingBlank" && (s += 2), s < d.length && d[s][1].type === "content"))
      for (; ++s < d.length && d[s][1].type !== "content"; )
        d[s][1].type === "chunkText" && (d[s][1]._isInFirstContentOfListItem = !0, s++);
    if (r[0] === "enter")
      r[1].contentType && (Object.assign(t, w$e(m, n)), n = t[n], p = !0);
    else if (r[1]._container) {
      for (s = n, a = void 0; s--; )
        if (l = m.get(s), l[1].type === "lineEnding" || l[1].type === "lineEndingBlank")
          l[0] === "enter" && (a && (m.get(a)[1].type = "lineEndingBlank"), l[1].type = "lineEnding", a = s);
        else if (!(l[1].type === "linePrefix" || l[1].type === "listItemIndent")) break;
      a && (r[1].end = {
        ...m.get(a)[1].start
      }, c = m.slice(a, n), c.unshift(r), m.splice(a, n - a + 1, c));
    }
  }
  return bi(e, 0, Number.POSITIVE_INFINITY, m.slice(0)), !p;
}
function w$e(e, t) {
  const n = e.get(t)[1], r = e.get(t)[2];
  let a = t - 1;
  const s = [];
  let l = n._tokenizer;
  l || (l = r.parser[n.contentType](n.start), n._contentTypeTextTrailing && (l._contentTypeTextTrailing = !0));
  const c = l.events, d = [], p = {};
  let m, h, v = -1, y = n, w = 0, x = 0;
  const b = [x];
  for (; y; ) {
    for (; e.get(++a)[1] !== y; )
      ;
    s.push(a), y._tokenizer || (m = r.sliceStream(y), y.next || m.push(null), h && l.defineSkip(y.start), y._isInFirstContentOfListItem && (l._gfmTasklistFirstContentOfListItem = !0), l.write(m), y._isInFirstContentOfListItem && (l._gfmTasklistFirstContentOfListItem = void 0)), h = y, y = y.next;
  }
  for (y = n; ++v < c.length; )
    c[v][0] === "exit" && c[v - 1][0] === "enter" && c[v][1].type === c[v - 1][1].type && c[v][1].start.line !== c[v][1].end.line && (x = v + 1, b.push(x), y._tokenizer = void 0, y.previous = void 0, y = y.next);
  for (l.events = [], y ? (y._tokenizer = void 0, y.previous = void 0) : b.pop(), v = b.length; v--; ) {
    const k = c.slice(b[v], b[v + 1]), C = s.pop();
    d.push([C, C + k.length - 1]), e.splice(C, 2, k);
  }
  for (d.reverse(), v = -1; ++v < d.length; )
    p[w + d[v][0]] = w + d[v][1], w += d[v][1] - d[v][0] - 1;
  return p;
}
const x$e = {
  resolve: k$e,
  tokenize: _$e
}, S$e = {
  partial: !0,
  tokenize: E$e
};
function k$e(e) {
  return EG(e), e;
}
function _$e(e, t) {
  let n;
  return r;
  function r(c) {
    return e.enter("content"), n = e.enter("chunkContent", {
      contentType: "content"
    }), a(c);
  }
  function a(c) {
    return c === null ? s(c) : mt(c) ? e.check(S$e, l, s)(c) : (e.consume(c), a);
  }
  function s(c) {
    return e.exit("chunkContent"), e.exit("content"), t(c);
  }
  function l(c) {
    return e.consume(c), e.exit("chunkContent"), n.next = e.enter("chunkContent", {
      contentType: "content",
      previous: n
    }), n = n.next, a;
  }
}
function E$e(e, t, n) {
  const r = this;
  return a;
  function a(l) {
    return e.exit("chunkContent"), e.enter("lineEnding"), e.consume(l), e.exit("lineEnding"), ln(e, s, "linePrefix");
  }
  function s(l) {
    if (l === null || mt(l))
      return n(l);
    const c = r.events[r.events.length - 1];
    return !r.parser.constructs.disable.null.includes("codeIndented") && c && c[1].type === "linePrefix" && c[2].sliceSerialize(c[1], !0).length >= 4 ? t(l) : e.interrupt(r.parser.constructs.flow, n, t)(l);
  }
}
function CG(e, t, n, r, a, s, l, c, d) {
  const p = d || Number.POSITIVE_INFINITY;
  let m = 0;
  return h;
  function h(k) {
    return k === 60 ? (e.enter(r), e.enter(a), e.enter(s), e.consume(k), e.exit(s), v) : k === null || k === 32 || k === 41 || F_(k) ? n(k) : (e.enter(r), e.enter(l), e.enter(c), e.enter("chunkString", {
      contentType: "string"
    }), x(k));
  }
  function v(k) {
    return k === 62 ? (e.enter(s), e.consume(k), e.exit(s), e.exit(a), e.exit(r), t) : (e.enter(c), e.enter("chunkString", {
      contentType: "string"
    }), y(k));
  }
  function y(k) {
    return k === 62 ? (e.exit("chunkString"), e.exit(c), v(k)) : k === null || k === 60 || mt(k) ? n(k) : (e.consume(k), k === 92 ? w : y);
  }
  function w(k) {
    return k === 60 || k === 62 || k === 92 ? (e.consume(k), y) : y(k);
  }
  function x(k) {
    return !m && (k === null || k === 41 || qn(k)) ? (e.exit("chunkString"), e.exit(c), e.exit(l), e.exit(r), t(k)) : m < p && k === 40 ? (e.consume(k), m++, x) : k === 41 ? (e.consume(k), m--, x) : k === null || k === 32 || k === 40 || F_(k) ? n(k) : (e.consume(k), k === 92 ? b : x);
  }
  function b(k) {
    return k === 40 || k === 41 || k === 92 ? (e.consume(k), x) : x(k);
  }
}
function OG(e, t, n, r, a, s) {
  const l = this;
  let c = 0, d;
  return p;
  function p(y) {
    return e.enter(r), e.enter(a), e.consume(y), e.exit(a), e.enter(s), m;
  }
  function m(y) {
    return c > 999 || y === null || y === 91 || y === 93 && !d || // To do: remove in the future once weve switched from
    // `micromark-extension-footnote` to `micromark-extension-gfm-footnote`,
    // which doesnt need this.
    // Hidden footnotes hook.
    /* c8 ignore next 3 */
    y === 94 && !c && "_hiddenFootnoteSupport" in l.parser.constructs ? n(y) : y === 93 ? (e.exit(s), e.enter(a), e.consume(y), e.exit(a), e.exit(r), t) : mt(y) ? (e.enter("lineEnding"), e.consume(y), e.exit("lineEnding"), m) : (e.enter("chunkString", {
      contentType: "string"
    }), h(y));
  }
  function h(y) {
    return y === null || y === 91 || y === 93 || mt(y) || c++ > 999 ? (e.exit("chunkString"), m(y)) : (e.consume(y), d || (d = !Jt(y)), y === 92 ? v : h);
  }
  function v(y) {
    return y === 91 || y === 92 || y === 93 ? (e.consume(y), c++, h) : h(y);
  }
}
function MG(e, t, n, r, a, s) {
  let l;
  return c;
  function c(v) {
    return v === 34 || v === 39 || v === 40 ? (e.enter(r), e.enter(a), e.consume(v), e.exit(a), l = v === 40 ? 41 : v, d) : n(v);
  }
  function d(v) {
    return v === l ? (e.enter(a), e.consume(v), e.exit(a), e.exit(r), t) : (e.enter(s), p(v));
  }
  function p(v) {
    return v === l ? (e.exit(s), d(l)) : v === null ? n(v) : mt(v) ? (e.enter("lineEnding"), e.consume(v), e.exit("lineEnding"), ln(e, p, "linePrefix")) : (e.enter("chunkString", {
      contentType: "string"
    }), m(v));
  }
  function m(v) {
    return v === l || v === null || mt(v) ? (e.exit("chunkString"), p(v)) : (e.consume(v), v === 92 ? h : m);
  }
  function h(v) {
    return v === l || v === 92 ? (e.consume(v), m) : m(v);
  }
}
function sx(e, t) {
  let n;
  return r;
  function r(a) {
    return mt(a) ? (e.enter("lineEnding"), e.consume(a), e.exit("lineEnding"), n = !0, r) : Jt(a) ? ln(e, r, n ? "linePrefix" : "lineSuffix")(a) : t(a);
  }
}
const C$e = {
  name: "definition",
  tokenize: M$e
}, O$e = {
  partial: !0,
  tokenize: N$e
};
function M$e(e, t, n) {
  const r = this;
  let a;
  return s;
  function s(y) {
    return e.enter("definition"), l(y);
  }
  function l(y) {
    return OG.call(
      r,
      e,
      c,
      // Note: we dont need to reset the way `markdown-rs` does.
      n,
      "definitionLabel",
      "definitionLabelMarker",
      "definitionLabelString"
    )(y);
  }
  function c(y) {
    return a = Is(r.sliceSerialize(r.events[r.events.length - 1][1]).slice(1, -1)), y === 58 ? (e.enter("definitionMarker"), e.consume(y), e.exit("definitionMarker"), d) : n(y);
  }
  function d(y) {
    return qn(y) ? sx(e, p)(y) : p(y);
  }
  function p(y) {
    return CG(
      e,
      m,
      // Note: we dont need to reset the way `markdown-rs` does.
      n,
      "definitionDestination",
      "definitionDestinationLiteral",
      "definitionDestinationLiteralMarker",
      "definitionDestinationRaw",
      "definitionDestinationString"
    )(y);
  }
  function m(y) {
    return e.attempt(O$e, h, h)(y);
  }
  function h(y) {
    return Jt(y) ? ln(e, v, "whitespace")(y) : v(y);
  }
  function v(y) {
    return y === null || mt(y) ? (e.exit("definition"), r.parser.defined.push(a), t(y)) : n(y);
  }
}
function N$e(e, t, n) {
  return r;
  function r(c) {
    return qn(c) ? sx(e, a)(c) : n(c);
  }
  function a(c) {
    return MG(e, s, n, "definitionTitle", "definitionTitleMarker", "definitionTitleString")(c);
  }
  function s(c) {
    return Jt(c) ? ln(e, l, "whitespace")(c) : l(c);
  }
  function l(c) {
    return c === null || mt(c) ? t(c) : n(c);
  }
}
const R$e = {
  name: "hardBreakEscape",
  tokenize: A$e
};
function A$e(e, t, n) {
  return r;
  function r(s) {
    return e.enter("hardBreakEscape"), e.consume(s), a;
  }
  function a(s) {
    return mt(s) ? (e.exit("hardBreakEscape"), t(s)) : n(s);
  }
}
const j$e = {
  name: "headingAtx",
  resolve: P$e,
  tokenize: D$e
};
function P$e(e, t) {
  let n = e.length - 2, r = 3, a, s;
  return e[r][1].type === "whitespace" && (r += 2), n - 2 > r && e[n][1].type === "whitespace" && (n -= 2), e[n][1].type === "atxHeadingSequence" && (r === n - 1 || n - 4 > r && e[n - 2][1].type === "whitespace") && (n -= r + 1 === n ? 2 : 4), n > r && (a = {
    type: "atxHeadingText",
    start: e[r][1].start,
    end: e[n][1].end
  }, s = {
    type: "chunkText",
    start: e[r][1].start,
    end: e[n][1].end,
    contentType: "text"
  }, bi(e, r, n - r + 1, [["enter", a, t], ["enter", s, t], ["exit", s, t], ["exit", a, t]])), e;
}
function D$e(e, t, n) {
  let r = 0;
  return a;
  function a(m) {
    return e.enter("atxHeading"), s(m);
  }
  function s(m) {
    return e.enter("atxHeadingSequence"), l(m);
  }
  function l(m) {
    return m === 35 && r++ < 6 ? (e.consume(m), l) : m === null || qn(m) ? (e.exit("atxHeadingSequence"), c(m)) : n(m);
  }
  function c(m) {
    return m === 35 ? (e.enter("atxHeadingSequence"), d(m)) : m === null || mt(m) ? (e.exit("atxHeading"), t(m)) : Jt(m) ? ln(e, c, "whitespace")(m) : (e.enter("atxHeadingText"), p(m));
  }
  function d(m) {
    return m === 35 ? (e.consume(m), d) : (e.exit("atxHeadingSequence"), c(m));
  }
  function p(m) {
    return m === null || m === 35 || qn(m) ? (e.exit("atxHeadingText"), c(m)) : (e.consume(m), p);
  }
}
const $$e = [
  "address",
  "article",
  "aside",
  "base",
  "basefont",
  "blockquote",
  "body",
  "caption",
  "center",
  "col",
  "colgroup",
  "dd",
  "details",
  "dialog",
  "dir",
  "div",
  "dl",
  "dt",
  "fieldset",
  "figcaption",
  "figure",
  "footer",
  "form",
  "frame",
  "frameset",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "head",
  "header",
  "hr",
  "html",
  "iframe",
  "legend",
  "li",
  "link",
  "main",
  "menu",
  "menuitem",
  "nav",
  "noframes",
  "ol",
  "optgroup",
  "option",
  "p",
  "param",
  "search",
  "section",
  "summary",
  "table",
  "tbody",
  "td",
  "tfoot",
  "th",
  "thead",
  "title",
  "tr",
  "track",
  "ul"
], Dz = ["pre", "script", "style", "textarea"], T$e = {
  concrete: !0,
  name: "htmlFlow",
  resolveTo: z$e,
  tokenize: F$e
}, L$e = {
  partial: !0,
  tokenize: U$e
}, I$e = {
  partial: !0,
  tokenize: B$e
};
function z$e(e) {
  let t = e.length;
  for (; t-- && !(e[t][0] === "enter" && e[t][1].type === "htmlFlow"); )
    ;
  return t > 1 && e[t - 2][1].type === "linePrefix" && (e[t][1].start = e[t - 2][1].start, e[t + 1][1].start = e[t - 2][1].start, e.splice(t - 2, 2)), e;
}
function F$e(e, t, n) {
  const r = this;
  let a, s, l, c, d;
  return p;
  function p(U) {
    return m(U);
  }
  function m(U) {
    return e.enter("htmlFlow"), e.enter("htmlFlowData"), e.consume(U), h;
  }
  function h(U) {
    return U === 33 ? (e.consume(U), v) : U === 47 ? (e.consume(U), s = !0, x) : U === 63 ? (e.consume(U), a = 3, r.interrupt ? t : V) : ba(U) ? (e.consume(U), l = String.fromCharCode(U), b) : n(U);
  }
  function v(U) {
    return U === 45 ? (e.consume(U), a = 2, y) : U === 91 ? (e.consume(U), a = 5, c = 0, w) : ba(U) ? (e.consume(U), a = 4, r.interrupt ? t : V) : n(U);
  }
  function y(U) {
    return U === 45 ? (e.consume(U), r.interrupt ? t : V) : n(U);
  }
  function w(U) {
    const H = "CDATA[";
    return U === H.charCodeAt(c++) ? (e.consume(U), c === H.length ? r.interrupt ? t : P : w) : n(U);
  }
  function x(U) {
    return ba(U) ? (e.consume(U), l = String.fromCharCode(U), b) : n(U);
  }
  function b(U) {
    if (U === null || U === 47 || U === 62 || qn(U)) {
      const H = U === 47, Q = l.toLowerCase();
      return !H && !s && Dz.includes(Q) ? (a = 1, r.interrupt ? t(U) : P(U)) : $$e.includes(l.toLowerCase()) ? (a = 6, H ? (e.consume(U), k) : r.interrupt ? t(U) : P(U)) : (a = 7, r.interrupt && !r.parser.lazy[r.now().line] ? n(U) : s ? C(U) : _(U));
    }
    return U === 45 || Wo(U) ? (e.consume(U), l += String.fromCharCode(U), b) : n(U);
  }
  function k(U) {
    return U === 62 ? (e.consume(U), r.interrupt ? t : P) : n(U);
  }
  function C(U) {
    return Jt(U) ? (e.consume(U), C) : z(U);
  }
  function _(U) {
    return U === 47 ? (e.consume(U), z) : U === 58 || U === 95 || ba(U) ? (e.consume(U), O) : Jt(U) ? (e.consume(U), _) : z(U);
  }
  function O(U) {
    return U === 45 || U === 46 || U === 58 || U === 95 || Wo(U) ? (e.consume(U), O) : N(U);
  }
  function N(U) {
    return U === 61 ? (e.consume(U), R) : Jt(U) ? (e.consume(U), N) : _(U);
  }
  function R(U) {
    return U === null || U === 60 || U === 61 || U === 62 || U === 96 ? n(U) : U === 34 || U === 39 ? (e.consume(U), d = U, j) : Jt(U) ? (e.consume(U), R) : D(U);
  }
  function j(U) {
    return U === d ? (e.consume(U), d = null, $) : U === null || mt(U) ? n(U) : (e.consume(U), j);
  }
  function D(U) {
    return U === null || U === 34 || U === 39 || U === 47 || U === 60 || U === 61 || U === 62 || U === 96 || qn(U) ? N(U) : (e.consume(U), D);
  }
  function $(U) {
    return U === 47 || U === 62 || Jt(U) ? _(U) : n(U);
  }
  function z(U) {
    return U === 62 ? (e.consume(U), B) : n(U);
  }
  function B(U) {
    return U === null || mt(U) ? P(U) : Jt(U) ? (e.consume(U), B) : n(U);
  }
  function P(U) {
    return U === 45 && a === 2 ? (e.consume(U), L) : U === 60 && a === 1 ? (e.consume(U), K) : U === 62 && a === 4 ? (e.consume(U), F) : U === 63 && a === 3 ? (e.consume(U), V) : U === 93 && a === 5 ? (e.consume(U), Z) : mt(U) && (a === 6 || a === 7) ? (e.exit("htmlFlowData"), e.check(L$e, X, W)(U)) : U === null || mt(U) ? (e.exit("htmlFlowData"), W(U)) : (e.consume(U), P);
  }
  function W(U) {
    return e.check(I$e, I, X)(U);
  }
  function I(U) {
    return e.enter("lineEnding"), e.consume(U), e.exit("lineEnding"), G;
  }
  function G(U) {
    return U === null || mt(U) ? W(U) : (e.enter("htmlFlowData"), P(U));
  }
  function L(U) {
    return U === 45 ? (e.consume(U), V) : P(U);
  }
  function K(U) {
    return U === 47 ? (e.consume(U), l = "", q) : P(U);
  }
  function q(U) {
    if (U === 62) {
      const H = l.toLowerCase();
      return Dz.includes(H) ? (e.consume(U), F) : P(U);
    }
    return ba(U) && l.length < 8 ? (e.consume(U), l += String.fromCharCode(U), q) : P(U);
  }
  function Z(U) {
    return U === 93 ? (e.consume(U), V) : P(U);
  }
  function V(U) {
    return U === 62 ? (e.consume(U), F) : U === 45 && a === 2 ? (e.consume(U), V) : P(U);
  }
  function F(U) {
    return U === null || mt(U) ? (e.exit("htmlFlowData"), X(U)) : (e.consume(U), F);
  }
  function X(U) {
    return e.exit("htmlFlow"), t(U);
  }
}
function B$e(e, t, n) {
  const r = this;
  return a;
  function a(l) {
    return mt(l) ? (e.enter("lineEnding"), e.consume(l), e.exit("lineEnding"), s) : n(l);
  }
  function s(l) {
    return r.parser.lazy[r.now().line] ? n(l) : t(l);
  }
}
function U$e(e, t, n) {
  return r;
  function r(a) {
    return e.enter("lineEnding"), e.consume(a), e.exit("lineEnding"), e.attempt(zS, t, n);
  }
}
const V$e = {
  name: "htmlText",
  tokenize: H$e
};
function H$e(e, t, n) {
  const r = this;
  let a, s, l;
  return c;
  function c(V) {
    return e.enter("htmlText"), e.enter("htmlTextData"), e.consume(V), d;
  }
  function d(V) {
    return V === 33 ? (e.consume(V), p) : V === 47 ? (e.consume(V), N) : V === 63 ? (e.consume(V), _) : ba(V) ? (e.consume(V), D) : n(V);
  }
  function p(V) {
    return V === 45 ? (e.consume(V), m) : V === 91 ? (e.consume(V), s = 0, w) : ba(V) ? (e.consume(V), C) : n(V);
  }
  function m(V) {
    return V === 45 ? (e.consume(V), y) : n(V);
  }
  function h(V) {
    return V === null ? n(V) : V === 45 ? (e.consume(V), v) : mt(V) ? (l = h, K(V)) : (e.consume(V), h);
  }
  function v(V) {
    return V === 45 ? (e.consume(V), y) : h(V);
  }
  function y(V) {
    return V === 62 ? L(V) : V === 45 ? v(V) : h(V);
  }
  function w(V) {
    const F = "CDATA[";
    return V === F.charCodeAt(s++) ? (e.consume(V), s === F.length ? x : w) : n(V);
  }
  function x(V) {
    return V === null ? n(V) : V === 93 ? (e.consume(V), b) : mt(V) ? (l = x, K(V)) : (e.consume(V), x);
  }
  function b(V) {
    return V === 93 ? (e.consume(V), k) : x(V);
  }
  function k(V) {
    return V === 62 ? L(V) : V === 93 ? (e.consume(V), k) : x(V);
  }
  function C(V) {
    return V === null || V === 62 ? L(V) : mt(V) ? (l = C, K(V)) : (e.consume(V), C);
  }
  function _(V) {
    return V === null ? n(V) : V === 63 ? (e.consume(V), O) : mt(V) ? (l = _, K(V)) : (e.consume(V), _);
  }
  function O(V) {
    return V === 62 ? L(V) : _(V);
  }
  function N(V) {
    return ba(V) ? (e.consume(V), R) : n(V);
  }
  function R(V) {
    return V === 45 || Wo(V) ? (e.consume(V), R) : j(V);
  }
  function j(V) {
    return mt(V) ? (l = j, K(V)) : Jt(V) ? (e.consume(V), j) : L(V);
  }
  function D(V) {
    return V === 45 || Wo(V) ? (e.consume(V), D) : V === 47 || V === 62 || qn(V) ? $(V) : n(V);
  }
  function $(V) {
    return V === 47 ? (e.consume(V), L) : V === 58 || V === 95 || ba(V) ? (e.consume(V), z) : mt(V) ? (l = $, K(V)) : Jt(V) ? (e.consume(V), $) : L(V);
  }
  function z(V) {
    return V === 45 || V === 46 || V === 58 || V === 95 || Wo(V) ? (e.consume(V), z) : B(V);
  }
  function B(V) {
    return V === 61 ? (e.consume(V), P) : mt(V) ? (l = B, K(V)) : Jt(V) ? (e.consume(V), B) : $(V);
  }
  function P(V) {
    return V === null || V === 60 || V === 61 || V === 62 || V === 96 ? n(V) : V === 34 || V === 39 ? (e.consume(V), a = V, W) : mt(V) ? (l = P, K(V)) : Jt(V) ? (e.consume(V), P) : (e.consume(V), I);
  }
  function W(V) {
    return V === a ? (e.consume(V), a = void 0, G) : V === null ? n(V) : mt(V) ? (l = W, K(V)) : (e.consume(V), W);
  }
  function I(V) {
    return V === null || V === 34 || V === 39 || V === 60 || V === 61 || V === 96 ? n(V) : V === 47 || V === 62 || qn(V) ? $(V) : (e.consume(V), I);
  }
  function G(V) {
    return V === 47 || V === 62 || qn(V) ? $(V) : n(V);
  }
  function L(V) {
    return V === 62 ? (e.consume(V), e.exit("htmlTextData"), e.exit("htmlText"), t) : n(V);
  }
  function K(V) {
    return e.exit("htmlTextData"), e.enter("lineEnding"), e.consume(V), e.exit("lineEnding"), q;
  }
  function q(V) {
    return Jt(V) ? ln(e, Z, "linePrefix", r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(V) : Z(V);
  }
  function Z(V) {
    return e.enter("htmlTextData"), l(V);
  }
}
const ej = {
  name: "labelEnd",
  resolveAll: K$e,
  resolveTo: X$e,
  tokenize: Y$e
}, q$e = {
  tokenize: Q$e
}, W$e = {
  tokenize: J$e
}, G$e = {
  tokenize: Z$e
};
function K$e(e) {
  let t = -1;
  const n = [];
  for (; ++t < e.length; ) {
    const r = e[t][1];
    if (n.push(e[t]), r.type === "labelImage" || r.type === "labelLink" || r.type === "labelEnd") {
      const a = r.type === "labelImage" ? 4 : 2;
      r.type = "data", t += a;
    }
  }
  return e.length !== n.length && bi(e, 0, e.length, n), e;
}
function X$e(e, t) {
  let n = e.length, r = 0, a, s, l, c;
  for (; n--; )
    if (a = e[n][1], s) {
      if (a.type === "link" || a.type === "labelLink" && a._inactive)
        break;
      e[n][0] === "enter" && a.type === "labelLink" && (a._inactive = !0);
    } else if (l) {
      if (e[n][0] === "enter" && (a.type === "labelImage" || a.type === "labelLink") && !a._balanced && (s = n, a.type !== "labelLink")) {
        r = 2;
        break;
      }
    } else a.type === "labelEnd" && (l = n);
  const d = {
    type: e[s][1].type === "labelLink" ? "link" : "image",
    start: {
      ...e[s][1].start
    },
    end: {
      ...e[e.length - 1][1].end
    }
  }, p = {
    type: "label",
    start: {
      ...e[s][1].start
    },
    end: {
      ...e[l][1].end
    }
  }, m = {
    type: "labelText",
    start: {
      ...e[s + r + 2][1].end
    },
    end: {
      ...e[l - 2][1].start
    }
  };
  return c = [["enter", d, t], ["enter", p, t]], c = Ri(c, e.slice(s + 1, s + r + 3)), c = Ri(c, [["enter", m, t]]), c = Ri(c, AE(t.parser.constructs.insideSpan.null, e.slice(s + r + 4, l - 3), t)), c = Ri(c, [["exit", m, t], e[l - 2], e[l - 1], ["exit", p, t]]), c = Ri(c, e.slice(l + 1)), c = Ri(c, [["exit", d, t]]), bi(e, s, e.length, c), e;
}
function Y$e(e, t, n) {
  const r = this;
  let a = r.events.length, s, l;
  for (; a--; )
    if ((r.events[a][1].type === "labelImage" || r.events[a][1].type === "labelLink") && !r.events[a][1]._balanced) {
      s = r.events[a][1];
      break;
    }
  return c;
  function c(v) {
    return s ? s._inactive ? h(v) : (l = r.parser.defined.includes(Is(r.sliceSerialize({
      start: s.end,
      end: r.now()
    }))), e.enter("labelEnd"), e.enter("labelMarker"), e.consume(v), e.exit("labelMarker"), e.exit("labelEnd"), d) : n(v);
  }
  function d(v) {
    return v === 40 ? e.attempt(q$e, m, l ? m : h)(v) : v === 91 ? e.attempt(W$e, m, l ? p : h)(v) : l ? m(v) : h(v);
  }
  function p(v) {
    return e.attempt(G$e, m, h)(v);
  }
  function m(v) {
    return t(v);
  }
  function h(v) {
    return s._balanced = !0, n(v);
  }
}
function Q$e(e, t, n) {
  return r;
  function r(h) {
    return e.enter("resource"), e.enter("resourceMarker"), e.consume(h), e.exit("resourceMarker"), a;
  }
  function a(h) {
    return qn(h) ? sx(e, s)(h) : s(h);
  }
  function s(h) {
    return h === 41 ? m(h) : CG(e, l, c, "resourceDestination", "resourceDestinationLiteral", "resourceDestinationLiteralMarker", "resourceDestinationRaw", "resourceDestinationString", 32)(h);
  }
  function l(h) {
    return qn(h) ? sx(e, d)(h) : m(h);
  }
  function c(h) {
    return n(h);
  }
  function d(h) {
    return h === 34 || h === 39 || h === 40 ? MG(e, p, n, "resourceTitle", "resourceTitleMarker", "resourceTitleString")(h) : m(h);
  }
  function p(h) {
    return qn(h) ? sx(e, m)(h) : m(h);
  }
  function m(h) {
    return h === 41 ? (e.enter("resourceMarker"), e.consume(h), e.exit("resourceMarker"), e.exit("resource"), t) : n(h);
  }
}
function J$e(e, t, n) {
  const r = this;
  return a;
  function a(c) {
    return OG.call(r, e, s, l, "reference", "referenceMarker", "referenceString")(c);
  }
  function s(c) {
    return r.parser.defined.includes(Is(r.sliceSerialize(r.events[r.events.length - 1][1]).slice(1, -1))) ? t(c) : n(c);
  }
  function l(c) {
    return n(c);
  }
}
function Z$e(e, t, n) {
  return r;
  function r(s) {
    return e.enter("reference"), e.enter("referenceMarker"), e.consume(s), e.exit("referenceMarker"), a;
  }
  function a(s) {
    return s === 93 ? (e.enter("referenceMarker"), e.consume(s), e.exit("referenceMarker"), e.exit("reference"), t) : n(s);
  }
}
const eTe = {
  name: "labelStartImage",
  resolveAll: ej.resolveAll,
  tokenize: tTe
};
function tTe(e, t, n) {
  const r = this;
  return a;
  function a(c) {
    return e.enter("labelImage"), e.enter("labelImageMarker"), e.consume(c), e.exit("labelImageMarker"), s;
  }
  function s(c) {
    return c === 91 ? (e.enter("labelMarker"), e.consume(c), e.exit("labelMarker"), e.exit("labelImage"), l) : n(c);
  }
  function l(c) {
    return c === 94 && "_hiddenFootnoteSupport" in r.parser.constructs ? n(c) : t(c);
  }
}
const nTe = {
  name: "labelStartLink",
  resolveAll: ej.resolveAll,
  tokenize: rTe
};
function rTe(e, t, n) {
  const r = this;
  return a;
  function a(l) {
    return e.enter("labelLink"), e.enter("labelMarker"), e.consume(l), e.exit("labelMarker"), e.exit("labelLink"), s;
  }
  function s(l) {
    return l === 94 && "_hiddenFootnoteSupport" in r.parser.constructs ? n(l) : t(l);
  }
}
const ON = {
  name: "lineEnding",
  tokenize: oTe
};
function oTe(e, t) {
  return n;
  function n(r) {
    return e.enter("lineEnding"), e.consume(r), e.exit("lineEnding"), ln(e, t, "linePrefix");
  }
}
const V0 = {
  name: "thematicBreak",
  tokenize: aTe
};
function aTe(e, t, n) {
  let r = 0, a;
  return s;
  function s(p) {
    return e.enter("thematicBreak"), l(p);
  }
  function l(p) {
    return a = p, c(p);
  }
  function c(p) {
    return p === a ? (e.enter("thematicBreakSequence"), d(p)) : r >= 3 && (p === null || mt(p)) ? (e.exit("thematicBreak"), t(p)) : n(p);
  }
  function d(p) {
    return p === a ? (e.consume(p), r++, d) : (e.exit("thematicBreakSequence"), Jt(p) ? ln(e, c, "whitespace")(p) : c(p));
  }
}
const _a = {
  continuation: {
    tokenize: uTe
  },
  exit: dTe,
  name: "list",
  tokenize: lTe
}, iTe = {
  partial: !0,
  tokenize: fTe
}, sTe = {
  partial: !0,
  tokenize: cTe
};
function lTe(e, t, n) {
  const r = this, a = r.events[r.events.length - 1];
  let s = a && a[1].type === "linePrefix" ? a[2].sliceSerialize(a[1], !0).length : 0, l = 0;
  return c;
  function c(y) {
    const w = r.containerState.type || (y === 42 || y === 43 || y === 45 ? "listUnordered" : "listOrdered");
    if (w === "listUnordered" ? !r.containerState.marker || y === r.containerState.marker : E3(y)) {
      if (r.containerState.type || (r.containerState.type = w, e.enter(w, {
        _container: !0
      })), w === "listUnordered")
        return e.enter("listItemPrefix"), y === 42 || y === 45 ? e.check(V0, n, p)(y) : p(y);
      if (!r.interrupt || y === 49)
        return e.enter("listItemPrefix"), e.enter("listItemValue"), d(y);
    }
    return n(y);
  }
  function d(y) {
    return E3(y) && ++l < 10 ? (e.consume(y), d) : (!r.interrupt || l < 2) && (r.containerState.marker ? y === r.containerState.marker : y === 41 || y === 46) ? (e.exit("listItemValue"), p(y)) : n(y);
  }
  function p(y) {
    return e.enter("listItemMarker"), e.consume(y), e.exit("listItemMarker"), r.containerState.marker = r.containerState.marker || y, e.check(
      zS,
      // Cant be empty when interrupting.
      r.interrupt ? n : m,
      e.attempt(iTe, v, h)
    );
  }
  function m(y) {
    return r.containerState.initialBlankLine = !0, s++, v(y);
  }
  function h(y) {
    return Jt(y) ? (e.enter("listItemPrefixWhitespace"), e.consume(y), e.exit("listItemPrefixWhitespace"), v) : n(y);
  }
  function v(y) {
    return r.containerState.size = s + r.sliceSerialize(e.exit("listItemPrefix"), !0).length, t(y);
  }
}
function uTe(e, t, n) {
  const r = this;
  return r.containerState._closeFlow = void 0, e.check(zS, a, s);
  function a(c) {
    return r.containerState.furtherBlankLines = r.containerState.furtherBlankLines || r.containerState.initialBlankLine, ln(e, t, "listItemIndent", r.containerState.size + 1)(c);
  }
  function s(c) {
    return r.containerState.furtherBlankLines || !Jt(c) ? (r.containerState.furtherBlankLines = void 0, r.containerState.initialBlankLine = void 0, l(c)) : (r.containerState.furtherBlankLines = void 0, r.containerState.initialBlankLine = void 0, e.attempt(sTe, t, l)(c));
  }
  function l(c) {
    return r.containerState._closeFlow = !0, r.interrupt = void 0, ln(e, e.attempt(_a, t, n), "linePrefix", r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(c);
  }
}
function cTe(e, t, n) {
  const r = this;
  return ln(e, a, "listItemIndent", r.containerState.size + 1);
  function a(s) {
    const l = r.events[r.events.length - 1];
    return l && l[1].type === "listItemIndent" && l[2].sliceSerialize(l[1], !0).length === r.containerState.size ? t(s) : n(s);
  }
}
function dTe(e) {
  e.exit(this.containerState.type);
}
function fTe(e, t, n) {
  const r = this;
  return ln(e, a, "listItemPrefixWhitespace", r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 5);
  function a(s) {
    const l = r.events[r.events.length - 1];
    return !Jt(s) && l && l[1].type === "listItemPrefixWhitespace" ? t(s) : n(s);
  }
}
const $z = {
  name: "setextUnderline",
  resolveTo: pTe,
  tokenize: mTe
};
function pTe(e, t) {
  let n = e.length, r, a, s;
  for (; n--; )
    if (e[n][0] === "enter") {
      if (e[n][1].type === "content") {
        r = n;
        break;
      }
      e[n][1].type === "paragraph" && (a = n);
    } else
      e[n][1].type === "content" && e.splice(n, 1), !s && e[n][1].type === "definition" && (s = n);
  const l = {
    type: "setextHeading",
    start: {
      ...e[r][1].start
    },
    end: {
      ...e[e.length - 1][1].end
    }
  };
  return e[a][1].type = "setextHeadingText", s ? (e.splice(a, 0, ["enter", l, t]), e.splice(s + 1, 0, ["exit", e[r][1], t]), e[r][1].end = {
    ...e[s][1].end
  }) : e[r][1] = l, e.push(["exit", l, t]), e;
}
function mTe(e, t, n) {
  const r = this;
  let a;
  return s;
  function s(p) {
    let m = r.events.length, h;
    for (; m--; )
      if (r.events[m][1].type !== "lineEnding" && r.events[m][1].type !== "linePrefix" && r.events[m][1].type !== "content") {
        h = r.events[m][1].type === "paragraph";
        break;
      }
    return !r.parser.lazy[r.now().line] && (r.interrupt || h) ? (e.enter("setextHeadingLine"), a = p, l(p)) : n(p);
  }
  function l(p) {
    return e.enter("setextHeadingLineSequence"), c(p);
  }
  function c(p) {
    return p === a ? (e.consume(p), c) : (e.exit("setextHeadingLineSequence"), Jt(p) ? ln(e, d, "lineSuffix")(p) : d(p));
  }
  function d(p) {
    return p === null || mt(p) ? (e.exit("setextHeadingLine"), t(p)) : n(p);
  }
}
const hTe = {
  tokenize: gTe
};
function gTe(e) {
  const t = this, n = e.attempt(
    // Try to parse a blank line.
    zS,
    r,
    // Try to parse initial flow (essentially, only code).
    e.attempt(this.parser.constructs.flowInitial, a, ln(e, e.attempt(this.parser.constructs.flow, a, e.attempt(x$e, a)), "linePrefix"))
  );
  return n;
  function r(s) {
    if (s === null) {
      e.consume(s);
      return;
    }
    return e.enter("lineEndingBlank"), e.consume(s), e.exit("lineEndingBlank"), t.currentConstruct = void 0, n;
  }
  function a(s) {
    if (s === null) {
      e.consume(s);
      return;
    }
    return e.enter("lineEnding"), e.consume(s), e.exit("lineEnding"), t.currentConstruct = void 0, n;
  }
}
const vTe = {
  resolveAll: RG()
}, yTe = NG("string"), bTe = NG("text");
function NG(e) {
  return {
    resolveAll: RG(e === "text" ? wTe : void 0),
    tokenize: t
  };
  function t(n) {
    const r = this, a = this.parser.constructs[e], s = n.attempt(a, l, c);
    return l;
    function l(m) {
      return p(m) ? s(m) : c(m);
    }
    function c(m) {
      if (m === null) {
        n.consume(m);
        return;
      }
      return n.enter("data"), n.consume(m), d;
    }
    function d(m) {
      return p(m) ? (n.exit("data"), s(m)) : (n.consume(m), d);
    }
    function p(m) {
      if (m === null)
        return !0;
      const h = a[m];
      let v = -1;
      if (h)
        for (; ++v < h.length; ) {
          const y = h[v];
          if (!y.previous || y.previous.call(r, r.previous))
            return !0;
        }
      return !1;
    }
  }
}
function RG(e) {
  return t;
  function t(n, r) {
    let a = -1, s;
    for (; ++a <= n.length; )
      s === void 0 ? n[a] && n[a][1].type === "data" && (s = a, a++) : (!n[a] || n[a][1].type !== "data") && (a !== s + 2 && (n[s][1].end = n[a - 1][1].end, n.splice(s + 2, a - s - 2), a = s + 2), s = void 0);
    return e ? e(n, r) : n;
  }
}
function wTe(e, t) {
  let n = 0;
  for (; ++n <= e.length; )
    if ((n === e.length || e[n][1].type === "lineEnding") && e[n - 1][1].type === "data") {
      const r = e[n - 1][1], a = t.sliceStream(r);
      let s = a.length, l = -1, c = 0, d;
      for (; s--; ) {
        const p = a[s];
        if (typeof p == "string") {
          for (l = p.length; p.charCodeAt(l - 1) === 32; )
            c++, l--;
          if (l) break;
          l = -1;
        } else if (p === -2)
          d = !0, c++;
        else if (p !== -1) {
          s++;
          break;
        }
      }
      if (t._contentTypeTextTrailing && n === e.length && (c = 0), c) {
        const p = {
          type: n === e.length || d || c < 2 ? "lineSuffix" : "hardBreakTrailing",
          start: {
            _bufferIndex: s ? l : r.start._bufferIndex + l,
            _index: r.start._index + s,
            line: r.end.line,
            column: r.end.column - c,
            offset: r.end.offset - c
          },
          end: {
            ...r.end
          }
        };
        r.end = {
          ...p.start
        }, r.start.offset === r.end.offset ? Object.assign(r, p) : (e.splice(n, 0, ["enter", p, t], ["exit", p, t]), n += 2);
      }
      n++;
    }
  return e;
}
const xTe = {
  42: _a,
  43: _a,
  45: _a,
  48: _a,
  49: _a,
  50: _a,
  51: _a,
  52: _a,
  53: _a,
  54: _a,
  55: _a,
  56: _a,
  57: _a,
  62: SG
}, STe = {
  91: C$e
}, kTe = {
  [-2]: CN,
  [-1]: CN,
  32: CN
}, _Te = {
  35: j$e,
  42: V0,
  45: [$z, V0],
  60: T$e,
  61: $z,
  95: V0,
  96: Pz,
  126: Pz
}, ETe = {
  38: _G,
  92: kG
}, CTe = {
  [-5]: ON,
  [-4]: ON,
  [-3]: ON,
  33: eTe,
  38: _G,
  42: C3,
  60: [n$e, V$e],
  91: nTe,
  92: [R$e, kG],
  93: ej,
  95: C3,
  96: h$e
}, OTe = {
  null: [C3, vTe]
}, MTe = {
  null: [42, 95]
}, NTe = {
  null: []
}, RTe = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  attentionMarkers: MTe,
  contentInitial: STe,
  disable: NTe,
  document: xTe,
  flow: _Te,
  flowInitial: kTe,
  insideSpan: OTe,
  string: ETe,
  text: CTe
}, Symbol.toStringTag, { value: "Module" }));
function ATe(e, t, n) {
  let r = {
    _bufferIndex: -1,
    _index: 0,
    line: n && n.line || 1,
    column: n && n.column || 1,
    offset: n && n.offset || 0
  };
  const a = {}, s = [];
  let l = [], c = [];
  const d = {
    attempt: j(N),
    check: j(R),
    consume: C,
    enter: _,
    exit: O,
    interrupt: j(R, {
      interrupt: !0
    })
  }, p = {
    code: null,
    containerState: {},
    defineSkip: x,
    events: [],
    now: w,
    parser: e,
    previous: null,
    sliceSerialize: v,
    sliceStream: y,
    write: h
  };
  let m = t.tokenize.call(p, d);
  return t.resolveAll && s.push(t), p;
  function h(B) {
    return l = Ri(l, B), b(), l[l.length - 1] !== null ? [] : (D(t, 0), p.events = AE(s, p.events, p), p.events);
  }
  function v(B, P) {
    return PTe(y(B), P);
  }
  function y(B) {
    return jTe(l, B);
  }
  function w() {
    const {
      _bufferIndex: B,
      _index: P,
      line: W,
      column: I,
      offset: G
    } = r;
    return {
      _bufferIndex: B,
      _index: P,
      line: W,
      column: I,
      offset: G
    };
  }
  function x(B) {
    a[B.line] = B.column, z();
  }
  function b() {
    let B;
    for (; r._index < l.length; ) {
      const P = l[r._index];
      if (typeof P == "string")
        for (B = r._index, r._bufferIndex < 0 && (r._bufferIndex = 0); r._index === B && r._bufferIndex < P.length; )
          k(P.charCodeAt(r._bufferIndex));
      else
        k(P);
    }
  }
  function k(B) {
    m = m(B);
  }
  function C(B) {
    mt(B) ? (r.line++, r.column = 1, r.offset += B === -3 ? 2 : 1, z()) : B !== -1 && (r.column++, r.offset++), r._bufferIndex < 0 ? r._index++ : (r._bufferIndex++, r._bufferIndex === // Points w/ non-negative `_bufferIndex` reference
    // strings.
    /** @type {string} */
    l[r._index].length && (r._bufferIndex = -1, r._index++)), p.previous = B;
  }
  function _(B, P) {
    const W = P || {};
    return W.type = B, W.start = w(), p.events.push(["enter", W, p]), c.push(W), W;
  }
  function O(B) {
    const P = c.pop();
    return P.end = w(), p.events.push(["exit", P, p]), P;
  }
  function N(B, P) {
    D(B, P.from);
  }
  function R(B, P) {
    P.restore();
  }
  function j(B, P) {
    return W;
    function W(I, G, L) {
      let K, q, Z, V;
      return Array.isArray(I) ? (
        /* c8 ignore next 1 */
        X(I)
      ) : "tokenize" in I ? (
        // Looks like a construct.
        X([
          /** @type {Construct} */
          I
        ])
      ) : F(I);
      function F(re) {
        return de;
        function de(le) {
          const me = le !== null && re[le], ve = le !== null && re.null, ae = [
            // To do: add more extension tests.
            /* c8 ignore next 2 */
            ...Array.isArray(me) ? me : me ? [me] : [],
            ...Array.isArray(ve) ? ve : ve ? [ve] : []
          ];
          return X(ae)(le);
        }
      }
      function X(re) {
        return K = re, q = 0, re.length === 0 ? L : U(re[q]);
      }
      function U(re) {
        return de;
        function de(le) {
          return V = $(), Z = re, re.partial || (p.currentConstruct = re), re.name && p.parser.constructs.disable.null.includes(re.name) ? Q() : re.tokenize.call(
            // If we do have fields, create an object w/ `context` as its
            // prototype.
            // This allows a live binding, which is needed for `interrupt`.
            P ? Object.assign(Object.create(p), P) : p,
            d,
            H,
            Q
          )(le);
        }
      }
      function H(re) {
        return B(Z, V), G;
      }
      function Q(re) {
        return V.restore(), ++q < K.length ? U(K[q]) : L;
      }
    }
  }
  function D(B, P) {
    B.resolveAll && !s.includes(B) && s.push(B), B.resolve && bi(p.events, P, p.events.length - P, B.resolve(p.events.slice(P), p)), B.resolveTo && (p.events = B.resolveTo(p.events, p));
  }
  function $() {
    const B = w(), P = p.previous, W = p.currentConstruct, I = p.events.length, G = Array.from(c);
    return {
      from: I,
      restore: L
    };
    function L() {
      r = B, p.previous = P, p.currentConstruct = W, p.events.length = I, c = G, z();
    }
  }
  function z() {
    r.line in a && r.column < 2 && (r.column = a[r.line], r.offset += a[r.line] - 1);
  }
}
function jTe(e, t) {
  const n = t.start._index, r = t.start._bufferIndex, a = t.end._index, s = t.end._bufferIndex;
  let l;
  if (n === a)
    l = [e[n].slice(r, s)];
  else {
    if (l = e.slice(n, a), r > -1) {
      const c = l[0];
      typeof c == "string" ? l[0] = c.slice(r) : l.shift();
    }
    s > 0 && l.push(e[a].slice(0, s));
  }
  return l;
}
function PTe(e, t) {
  let n = -1;
  const r = [];
  let a;
  for (; ++n < e.length; ) {
    const s = e[n];
    let l;
    if (typeof s == "string")
      l = s;
    else switch (s) {
      case -5: {
        l = "\r";
        break;
      }
      case -4: {
        l = `
`;
        break;
      }
      case -3: {
        l = `\r
`;
        break;
      }
      case -2: {
        l = t ? " " : "	";
        break;
      }
      case -1: {
        if (!t && a) continue;
        l = " ";
        break;
      }
      default:
        l = String.fromCharCode(s);
    }
    a = s === -2, r.push(l);
  }
  return r.join("");
}
function DTe(e) {
  const t = {
    constructs: (
      /** @type {FullNormalizedExtension} */
      wG([RTe, ...(e || {}).extensions || []])
    ),
    content: n(X6e),
    defined: [],
    document: n(Q6e),
    flow: n(hTe),
    lazy: {},
    string: n(yTe),
    text: n(bTe)
  };
  return t;
  function n(r) {
    return a;
    function a(s) {
      return ATe(t, r, s);
    }
  }
}
function $Te(e) {
  for (; !EG(e); )
    ;
  return e;
}
const Tz = /[\0\t\n\r]/g;
function TTe() {
  let e = 1, t = "", n = !0, r;
  return a;
  function a(s, l, c) {
    const d = [];
    let p, m, h, v, y;
    for (s = t + (typeof s == "string" ? s.toString() : new TextDecoder(l || void 0).decode(s)), h = 0, t = "", n && (s.charCodeAt(0) === 65279 && h++, n = void 0); h < s.length; ) {
      if (Tz.lastIndex = h, p = Tz.exec(s), v = p && p.index !== void 0 ? p.index : s.length, y = s.charCodeAt(v), !p) {
        t = s.slice(h);
        break;
      }
      if (y === 10 && h === v && r)
        d.push(-3), r = void 0;
      else
        switch (r && (d.push(-5), r = void 0), h < v && (d.push(s.slice(h, v)), e += v - h), y) {
          case 0: {
            d.push(65533), e++;
            break;
          }
          case 9: {
            for (m = Math.ceil(e / 4) * 4, d.push(-2); e++ < m; ) d.push(-1);
            break;
          }
          case 10: {
            d.push(-4), e = 1;
            break;
          }
          default:
            r = !0, e = 1;
        }
      h = v + 1;
    }
    return c && (r && d.push(-5), t && d.push(t), d.push(null)), d;
  }
}
const LTe = /\\([!-/:-@[-`{-~])|&(#(?:\d{1,7}|x[\da-f]{1,6})|[\da-z]{1,31});/gi;
function ITe(e) {
  return e.replace(LTe, zTe);
}
function zTe(e, t, n) {
  if (t)
    return t;
  if (n.charCodeAt(0) === 35) {
    const r = n.charCodeAt(1), a = r === 120 || r === 88;
    return xG(n.slice(a ? 2 : 1), a ? 16 : 10);
  }
  return Z4(n) || e;
}
const AG = {}.hasOwnProperty;
function FTe(e, t, n) {
  return typeof t != "string" && (n = t, t = void 0), BTe(n)($Te(DTe(n).document().write(TTe()(e, t, !0))));
}
function BTe(e) {
  const t = {
    transforms: [],
    canContainEols: ["emphasis", "fragment", "heading", "paragraph", "strong"],
    enter: {
      autolink: s(et),
      autolinkProtocol: $,
      autolinkEmail: $,
      atxHeading: s(xe),
      blockQuote: s(ve),
      characterEscape: $,
      characterReference: $,
      codeFenced: s(ae),
      codeFencedFenceInfo: l,
      codeFencedFenceMeta: l,
      codeIndented: s(ae, l),
      codeText: s(se, l),
      codeTextData: $,
      data: $,
      codeFlowValue: $,
      definition: s(pe),
      definitionDestinationString: l,
      definitionLabelString: l,
      definitionTitleString: l,
      emphasis: s(ge),
      hardBreakEscape: s(_e),
      hardBreakTrailing: s(_e),
      htmlFlow: s(We, l),
      htmlFlowData: $,
      htmlText: s(We, l),
      htmlTextData: $,
      image: s(Xe),
      label: l,
      link: s(et),
      listItem: s(je),
      listItemValue: v,
      listOrdered: s(tt, h),
      listUnordered: s(tt),
      paragraph: s(an),
      reference: U,
      referenceString: l,
      resourceDestinationString: l,
      resourceTitleString: l,
      setextHeading: s(xe),
      strong: s(dt),
      thematicBreak: s(Me)
    },
    exit: {
      atxHeading: d(),
      atxHeadingSequence: N,
      autolink: d(),
      autolinkEmail: me,
      autolinkProtocol: le,
      blockQuote: d(),
      characterEscapeValue: z,
      characterReferenceMarkerHexadecimal: Q,
      characterReferenceMarkerNumeric: Q,
      characterReferenceValue: re,
      characterReference: de,
      codeFenced: d(b),
      codeFencedFence: x,
      codeFencedFenceInfo: y,
      codeFencedFenceMeta: w,
      codeFlowValue: z,
      codeIndented: d(k),
      codeText: d(G),
      codeTextData: z,
      data: z,
      definition: d(),
      definitionDestinationString: O,
      definitionLabelString: C,
      definitionTitleString: _,
      emphasis: d(),
      hardBreakEscape: d(P),
      hardBreakTrailing: d(P),
      htmlFlow: d(W),
      htmlFlowData: z,
      htmlText: d(I),
      htmlTextData: z,
      image: d(K),
      label: Z,
      labelText: q,
      lineEnding: B,
      link: d(L),
      listItem: d(),
      listOrdered: d(),
      listUnordered: d(),
      paragraph: d(),
      referenceString: H,
      resourceDestinationString: V,
      resourceTitleString: F,
      resource: X,
      setextHeading: d(D),
      setextHeadingLineSequence: j,
      setextHeadingText: R,
      strong: d(),
      thematicBreak: d()
    }
  };
  jG(t, (e || {}).mdastExtensions || []);
  const n = {};
  return r;
  function r(he) {
    let ye = {
      type: "root",
      children: []
    };
    const Ee = {
      stack: [ye],
      tokenStack: [],
      config: t,
      enter: c,
      exit: p,
      buffer: l,
      resume: m,
      data: n
    }, Le = [];
    let ze = -1;
    for (; ++ze < he.length; )
      if (he[ze][1].type === "listOrdered" || he[ze][1].type === "listUnordered")
        if (he[ze][0] === "enter")
          Le.push(ze);
        else {
          const It = Le.pop();
          ze = a(he, It, ze);
        }
    for (ze = -1; ++ze < he.length; ) {
      const It = t[he[ze][0]];
      AG.call(It, he[ze][1].type) && It[he[ze][1].type].call(Object.assign({
        sliceSerialize: he[ze][2].sliceSerialize
      }, Ee), he[ze][1]);
    }
    if (Ee.tokenStack.length > 0) {
      const It = Ee.tokenStack[Ee.tokenStack.length - 1];
      (It[1] || Lz).call(Ee, void 0, It[0]);
    }
    for (ye.position = {
      start: Uc(he.length > 0 ? he[0][1].start : {
        line: 1,
        column: 1,
        offset: 0
      }),
      end: Uc(he.length > 0 ? he[he.length - 2][1].end : {
        line: 1,
        column: 1,
        offset: 0
      })
    }, ze = -1; ++ze < t.transforms.length; )
      ye = t.transforms[ze](ye) || ye;
    return ye;
  }
  function a(he, ye, Ee) {
    let Le = ye - 1, ze = -1, It = !1, zt, Wt, Ot, bn;
    for (; ++Le <= Ee; ) {
      const Re = he[Le];
      switch (Re[1].type) {
        case "listUnordered":
        case "listOrdered":
        case "blockQuote": {
          Re[0] === "enter" ? ze++ : ze--, bn = void 0;
          break;
        }
        case "lineEndingBlank": {
          Re[0] === "enter" && (zt && !bn && !ze && !Ot && (Ot = Le), bn = void 0);
          break;
        }
        case "linePrefix":
        case "listItemValue":
        case "listItemMarker":
        case "listItemPrefix":
        case "listItemPrefixWhitespace":
          break;
        default:
          bn = void 0;
      }
      if (!ze && Re[0] === "enter" && Re[1].type === "listItemPrefix" || ze === -1 && Re[0] === "exit" && (Re[1].type === "listUnordered" || Re[1].type === "listOrdered")) {
        if (zt) {
          let Ft = Le;
          for (Wt = void 0; Ft--; ) {
            const Xt = he[Ft];
            if (Xt[1].type === "lineEnding" || Xt[1].type === "lineEndingBlank") {
              if (Xt[0] === "exit") continue;
              Wt && (he[Wt][1].type = "lineEndingBlank", It = !0), Xt[1].type = "lineEnding", Wt = Ft;
            } else if (!(Xt[1].type === "linePrefix" || Xt[1].type === "blockQuotePrefix" || Xt[1].type === "blockQuotePrefixWhitespace" || Xt[1].type === "blockQuoteMarker" || Xt[1].type === "listItemIndent")) break;
          }
          Ot && (!Wt || Ot < Wt) && (zt._spread = !0), zt.end = Object.assign({}, Wt ? he[Wt][1].start : Re[1].end), he.splice(Wt || Le, 0, ["exit", zt, Re[2]]), Le++, Ee++;
        }
        if (Re[1].type === "listItemPrefix") {
          const Ft = {
            type: "listItem",
            _spread: !1,
            start: Object.assign({}, Re[1].start),
            // @ts-expect-error: well add `end` in a second.
            end: void 0
          };
          zt = Ft, he.splice(Le, 0, ["enter", Ft, Re[2]]), Le++, Ee++, Ot = void 0, bn = !0;
        }
      }
    }
    return he[ye][1]._spread = It, Ee;
  }
  function s(he, ye) {
    return Ee;
    function Ee(Le) {
      c.call(this, he(Le), Le), ye && ye.call(this, Le);
    }
  }
  function l() {
    this.stack.push({
      type: "fragment",
      children: []
    });
  }
  function c(he, ye, Ee) {
    this.stack[this.stack.length - 1].children.push(he), this.stack.push(he), this.tokenStack.push([ye, Ee || void 0]), he.position = {
      start: Uc(ye.start),
      // @ts-expect-error: `end` will be patched later.
      end: void 0
    };
  }
  function d(he) {
    return ye;
    function ye(Ee) {
      he && he.call(this, Ee), p.call(this, Ee);
    }
  }
  function p(he, ye) {
    const Ee = this.stack.pop(), Le = this.tokenStack.pop();
    if (Le)
      Le[0].type !== he.type && (ye ? ye.call(this, he, Le[0]) : (Le[1] || Lz).call(this, he, Le[0]));
    else throw new Error("Cannot close `" + he.type + "` (" + ix({
      start: he.start,
      end: he.end
    }) + "): its not open");
    Ee.position.end = Uc(he.end);
  }
  function m() {
    return J4(this.stack.pop());
  }
  function h() {
    this.data.expectingFirstListItemValue = !0;
  }
  function v(he) {
    if (this.data.expectingFirstListItemValue) {
      const ye = this.stack[this.stack.length - 2];
      ye.start = Number.parseInt(this.sliceSerialize(he), 10), this.data.expectingFirstListItemValue = void 0;
    }
  }
  function y() {
    const he = this.resume(), ye = this.stack[this.stack.length - 1];
    ye.lang = he;
  }
  function w() {
    const he = this.resume(), ye = this.stack[this.stack.length - 1];
    ye.meta = he;
  }
  function x() {
    this.data.flowCodeInside || (this.buffer(), this.data.flowCodeInside = !0);
  }
  function b() {
    const he = this.resume(), ye = this.stack[this.stack.length - 1];
    ye.value = he.replace(/^(\r?\n|\r)|(\r?\n|\r)$/g, ""), this.data.flowCodeInside = void 0;
  }
  function k() {
    const he = this.resume(), ye = this.stack[this.stack.length - 1];
    ye.value = he.replace(/(\r?\n|\r)$/g, "");
  }
  function C(he) {
    const ye = this.resume(), Ee = this.stack[this.stack.length - 1];
    Ee.label = ye, Ee.identifier = Is(this.sliceSerialize(he)).toLowerCase();
  }
  function _() {
    const he = this.resume(), ye = this.stack[this.stack.length - 1];
    ye.title = he;
  }
  function O() {
    const he = this.resume(), ye = this.stack[this.stack.length - 1];
    ye.url = he;
  }
  function N(he) {
    const ye = this.stack[this.stack.length - 1];
    if (!ye.depth) {
      const Ee = this.sliceSerialize(he).length;
      ye.depth = Ee;
    }
  }
  function R() {
    this.data.setextHeadingSlurpLineEnding = !0;
  }
  function j(he) {
    const ye = this.stack[this.stack.length - 1];
    ye.depth = this.sliceSerialize(he).codePointAt(0) === 61 ? 1 : 2;
  }
  function D() {
    this.data.setextHeadingSlurpLineEnding = void 0;
  }
  function $(he) {
    const ye = this.stack[this.stack.length - 1].children;
    let Ee = ye[ye.length - 1];
    (!Ee || Ee.type !== "text") && (Ee = Ce(), Ee.position = {
      start: Uc(he.start),
      // @ts-expect-error: well add `end` later.
      end: void 0
    }, ye.push(Ee)), this.stack.push(Ee);
  }
  function z(he) {
    const ye = this.stack.pop();
    ye.value += this.sliceSerialize(he), ye.position.end = Uc(he.end);
  }
  function B(he) {
    const ye = this.stack[this.stack.length - 1];
    if (this.data.atHardBreak) {
      const Ee = ye.children[ye.children.length - 1];
      Ee.position.end = Uc(he.end), this.data.atHardBreak = void 0;
      return;
    }
    !this.data.setextHeadingSlurpLineEnding && t.canContainEols.includes(ye.type) && ($.call(this, he), z.call(this, he));
  }
  function P() {
    this.data.atHardBreak = !0;
  }
  function W() {
    const he = this.resume(), ye = this.stack[this.stack.length - 1];
    ye.value = he;
  }
  function I() {
    const he = this.resume(), ye = this.stack[this.stack.length - 1];
    ye.value = he;
  }
  function G() {
    const he = this.resume(), ye = this.stack[this.stack.length - 1];
    ye.value = he;
  }
  function L() {
    const he = this.stack[this.stack.length - 1];
    if (this.data.inReference) {
      const ye = this.data.referenceType || "shortcut";
      he.type += "Reference", he.referenceType = ye, delete he.url, delete he.title;
    } else
      delete he.identifier, delete he.label;
    this.data.referenceType = void 0;
  }
  function K() {
    const he = this.stack[this.stack.length - 1];
    if (this.data.inReference) {
      const ye = this.data.referenceType || "shortcut";
      he.type += "Reference", he.referenceType = ye, delete he.url, delete he.title;
    } else
      delete he.identifier, delete he.label;
    this.data.referenceType = void 0;
  }
  function q(he) {
    const ye = this.sliceSerialize(he), Ee = this.stack[this.stack.length - 2];
    Ee.label = ITe(ye), Ee.identifier = Is(ye).toLowerCase();
  }
  function Z() {
    const he = this.stack[this.stack.length - 1], ye = this.resume(), Ee = this.stack[this.stack.length - 1];
    if (this.data.inReference = !0, Ee.type === "link") {
      const Le = he.children;
      Ee.children = Le;
    } else
      Ee.alt = ye;
  }
  function V() {
    const he = this.resume(), ye = this.stack[this.stack.length - 1];
    ye.url = he;
  }
  function F() {
    const he = this.resume(), ye = this.stack[this.stack.length - 1];
    ye.title = he;
  }
  function X() {
    this.data.inReference = void 0;
  }
  function U() {
    this.data.referenceType = "collapsed";
  }
  function H(he) {
    const ye = this.resume(), Ee = this.stack[this.stack.length - 1];
    Ee.label = ye, Ee.identifier = Is(this.sliceSerialize(he)).toLowerCase(), this.data.referenceType = "full";
  }
  function Q(he) {
    this.data.characterReferenceType = he.type;
  }
  function re(he) {
    const ye = this.sliceSerialize(he), Ee = this.data.characterReferenceType;
    let Le;
    Ee ? (Le = xG(ye, Ee === "characterReferenceMarkerNumeric" ? 10 : 16), this.data.characterReferenceType = void 0) : Le = Z4(ye);
    const ze = this.stack[this.stack.length - 1];
    ze.value += Le;
  }
  function de(he) {
    const ye = this.stack.pop();
    ye.position.end = Uc(he.end);
  }
  function le(he) {
    z.call(this, he);
    const ye = this.stack[this.stack.length - 1];
    ye.url = this.sliceSerialize(he);
  }
  function me(he) {
    z.call(this, he);
    const ye = this.stack[this.stack.length - 1];
    ye.url = "mailto:" + this.sliceSerialize(he);
  }
  function ve() {
    return {
      type: "blockquote",
      children: []
    };
  }
  function ae() {
    return {
      type: "code",
      lang: null,
      meta: null,
      value: ""
    };
  }
  function se() {
    return {
      type: "inlineCode",
      value: ""
    };
  }
  function pe() {
    return {
      type: "definition",
      identifier: "",
      label: null,
      title: null,
      url: ""
    };
  }
  function ge() {
    return {
      type: "emphasis",
      children: []
    };
  }
  function xe() {
    return {
      type: "heading",
      // @ts-expect-error `depth` will be set later.
      depth: 0,
      children: []
    };
  }
  function _e() {
    return {
      type: "break"
    };
  }
  function We() {
    return {
      type: "html",
      value: ""
    };
  }
  function Xe() {
    return {
      type: "image",
      title: null,
      url: "",
      alt: null
    };
  }
  function et() {
    return {
      type: "link",
      title: null,
      url: "",
      children: []
    };
  }
  function tt(he) {
    return {
      type: "list",
      ordered: he.type === "listOrdered",
      start: null,
      spread: he._spread,
      children: []
    };
  }
  function je(he) {
    return {
      type: "listItem",
      spread: he._spread,
      checked: null,
      children: []
    };
  }
  function an() {
    return {
      type: "paragraph",
      children: []
    };
  }
  function dt() {
    return {
      type: "strong",
      children: []
    };
  }
  function Ce() {
    return {
      type: "text",
      value: ""
    };
  }
  function Me() {
    return {
      type: "thematicBreak"
    };
  }
}
function Uc(e) {
  return {
    line: e.line,
    column: e.column,
    offset: e.offset
  };
}
function jG(e, t) {
  let n = -1;
  for (; ++n < t.length; ) {
    const r = t[n];
    Array.isArray(r) ? jG(e, r) : UTe(e, r);
  }
}
function UTe(e, t) {
  let n;
  for (n in t)
    if (AG.call(t, n))
      switch (n) {
        case "canContainEols": {
          const r = t[n];
          r && e[n].push(...r);
          break;
        }
        case "transforms": {
          const r = t[n];
          r && e[n].push(...r);
          break;
        }
        case "enter":
        case "exit": {
          const r = t[n];
          r && Object.assign(e[n], r);
          break;
        }
      }
}
function Lz(e, t) {
  throw e ? new Error("Cannot close `" + e.type + "` (" + ix({
    start: e.start,
    end: e.end
  }) + "): a different token (`" + t.type + "`, " + ix({
    start: t.start,
    end: t.end
  }) + ") is open") : new Error("Cannot close document, a token (`" + t.type + "`, " + ix({
    start: t.start,
    end: t.end
  }) + ") is still open");
}
function VTe(e) {
  const t = this;
  t.parser = n;
  function n(r) {
    return FTe(r, {
      ...t.data("settings"),
      ...e,
      // Note: these options are not in the readme.
      // The goal is for them to be set by plugins on `data` instead of being
      // passed by users.
      extensions: t.data("micromarkExtensions") || [],
      mdastExtensions: t.data("fromMarkdownExtensions") || []
    });
  }
}
function HTe(e, t) {
  const n = {
    type: "element",
    tagName: "blockquote",
    properties: {},
    children: e.wrap(e.all(t), !0)
  };
  return e.patch(t, n), e.applyData(t, n);
}
function qTe(e, t) {
  const n = { type: "element", tagName: "br", properties: {}, children: [] };
  return e.patch(t, n), [e.applyData(t, n), { type: "text", value: `
` }];
}
function WTe(e, t) {
  const n = t.value ? t.value + `
` : "", r = {};
  t.lang && (r.className = ["language-" + t.lang]);
  let a = {
    type: "element",
    tagName: "code",
    properties: r,
    children: [{ type: "text", value: n }]
  };
  return t.meta && (a.data = { meta: t.meta }), e.patch(t, a), a = e.applyData(t, a), a = { type: "element", tagName: "pre", properties: {}, children: [a] }, e.patch(t, a), a;
}
function GTe(e, t) {
  const n = {
    type: "element",
    tagName: "del",
    properties: {},
    children: e.all(t)
  };
  return e.patch(t, n), e.applyData(t, n);
}
function KTe(e, t) {
  const n = {
    type: "element",
    tagName: "em",
    properties: {},
    children: e.all(t)
  };
  return e.patch(t, n), e.applyData(t, n);
}
function XTe(e, t) {
  const n = typeof e.options.clobberPrefix == "string" ? e.options.clobberPrefix : "user-content-", r = String(t.identifier).toUpperCase(), a = pg(r.toLowerCase()), s = e.footnoteOrder.indexOf(r);
  let l, c = e.footnoteCounts.get(r);
  c === void 0 ? (c = 0, e.footnoteOrder.push(r), l = e.footnoteOrder.length) : l = s + 1, c += 1, e.footnoteCounts.set(r, c);
  const d = {
    type: "element",
    tagName: "a",
    properties: {
      href: "#" + n + "fn-" + a,
      id: n + "fnref-" + a + (c > 1 ? "-" + c : ""),
      dataFootnoteRef: !0,
      ariaDescribedBy: ["footnote-label"]
    },
    children: [{ type: "text", value: String(l) }]
  };
  e.patch(t, d);
  const p = {
    type: "element",
    tagName: "sup",
    properties: {},
    children: [d]
  };
  return e.patch(t, p), e.applyData(t, p);
}
function YTe(e, t) {
  const n = {
    type: "element",
    tagName: "h" + t.depth,
    properties: {},
    children: e.all(t)
  };
  return e.patch(t, n), e.applyData(t, n);
}
function QTe(e, t) {
  if (e.options.allowDangerousHtml) {
    const n = { type: "raw", value: t.value };
    return e.patch(t, n), e.applyData(t, n);
  }
}
function PG(e, t) {
  const n = t.referenceType;
  let r = "]";
  if (n === "collapsed" ? r += "[]" : n === "full" && (r += "[" + (t.label || t.identifier) + "]"), t.type === "imageReference")
    return [{ type: "text", value: "![" + t.alt + r }];
  const a = e.all(t), s = a[0];
  s && s.type === "text" ? s.value = "[" + s.value : a.unshift({ type: "text", value: "[" });
  const l = a[a.length - 1];
  return l && l.type === "text" ? l.value += r : a.push({ type: "text", value: r }), a;
}
function JTe(e, t) {
  const n = String(t.identifier).toUpperCase(), r = e.definitionById.get(n);
  if (!r)
    return PG(e, t);
  const a = { src: pg(r.url || ""), alt: t.alt };
  r.title !== null && r.title !== void 0 && (a.title = r.title);
  const s = { type: "element", tagName: "img", properties: a, children: [] };
  return e.patch(t, s), e.applyData(t, s);
}
function ZTe(e, t) {
  const n = { src: pg(t.url) };
  t.alt !== null && t.alt !== void 0 && (n.alt = t.alt), t.title !== null && t.title !== void 0 && (n.title = t.title);
  const r = { type: "element", tagName: "img", properties: n, children: [] };
  return e.patch(t, r), e.applyData(t, r);
}
function eLe(e, t) {
  const n = { type: "text", value: t.value.replace(/\r?\n|\r/g, " ") };
  e.patch(t, n);
  const r = {
    type: "element",
    tagName: "code",
    properties: {},
    children: [n]
  };
  return e.patch(t, r), e.applyData(t, r);
}
function tLe(e, t) {
  const n = String(t.identifier).toUpperCase(), r = e.definitionById.get(n);
  if (!r)
    return PG(e, t);
  const a = { href: pg(r.url || "") };
  r.title !== null && r.title !== void 0 && (a.title = r.title);
  const s = {
    type: "element",
    tagName: "a",
    properties: a,
    children: e.all(t)
  };
  return e.patch(t, s), e.applyData(t, s);
}
function nLe(e, t) {
  const n = { href: pg(t.url) };
  t.title !== null && t.title !== void 0 && (n.title = t.title);
  const r = {
    type: "element",
    tagName: "a",
    properties: n,
    children: e.all(t)
  };
  return e.patch(t, r), e.applyData(t, r);
}
function rLe(e, t, n) {
  const r = e.all(t), a = n ? oLe(n) : DG(t), s = {}, l = [];
  if (typeof t.checked == "boolean") {
    const m = r[0];
    let h;
    m && m.type === "element" && m.tagName === "p" ? h = m : (h = { type: "element", tagName: "p", properties: {}, children: [] }, r.unshift(h)), h.children.length > 0 && h.children.unshift({ type: "text", value: " " }), h.children.unshift({
      type: "element",
      tagName: "input",
      properties: { type: "checkbox", checked: t.checked, disabled: !0 },
      children: []
    }), s.className = ["task-list-item"];
  }
  let c = -1;
  for (; ++c < r.length; ) {
    const m = r[c];
    (a || c !== 0 || m.type !== "element" || m.tagName !== "p") && l.push({ type: "text", value: `
` }), m.type === "element" && m.tagName === "p" && !a ? l.push(...m.children) : l.push(m);
  }
  const d = r[r.length - 1];
  d && (a || d.type !== "element" || d.tagName !== "p") && l.push({ type: "text", value: `
` });
  const p = { type: "element", tagName: "li", properties: s, children: l };
  return e.patch(t, p), e.applyData(t, p);
}
function oLe(e) {
  let t = !1;
  if (e.type === "list") {
    t = e.spread || !1;
    const n = e.children;
    let r = -1;
    for (; !t && ++r < n.length; )
      t = DG(n[r]);
  }
  return t;
}
function DG(e) {
  return e.spread ?? e.children.length > 1;
}
function aLe(e, t) {
  const n = {}, r = e.all(t);
  let a = -1;
  for (typeof t.start == "number" && t.start !== 1 && (n.start = t.start); ++a < r.length; ) {
    const l = r[a];
    if (l.type === "element" && l.tagName === "li" && l.properties && Array.isArray(l.properties.className) && l.properties.className.includes("task-list-item")) {
      n.className = ["contains-task-list"];
      break;
    }
  }
  const s = {
    type: "element",
    tagName: t.ordered ? "ol" : "ul",
    properties: n,
    children: e.wrap(r, !0)
  };
  return e.patch(t, s), e.applyData(t, s);
}
function iLe(e, t) {
  const n = {
    type: "element",
    tagName: "p",
    properties: {},
    children: e.all(t)
  };
  return e.patch(t, n), e.applyData(t, n);
}
function sLe(e, t) {
  const n = { type: "root", children: e.wrap(e.all(t)) };
  return e.patch(t, n), e.applyData(t, n);
}
function lLe(e, t) {
  const n = {
    type: "element",
    tagName: "strong",
    properties: {},
    children: e.all(t)
  };
  return e.patch(t, n), e.applyData(t, n);
}
function uLe(e, t) {
  const n = e.all(t), r = n.shift(), a = [];
  if (r) {
    const l = {
      type: "element",
      tagName: "thead",
      properties: {},
      children: e.wrap([r], !0)
    };
    e.patch(t.children[0], l), a.push(l);
  }
  if (n.length > 0) {
    const l = {
      type: "element",
      tagName: "tbody",
      properties: {},
      children: e.wrap(n, !0)
    }, c = K4(t.children[1]), d = pG(t.children[t.children.length - 1]);
    c && d && (l.position = { start: c, end: d }), a.push(l);
  }
  const s = {
    type: "element",
    tagName: "table",
    properties: {},
    children: e.wrap(a, !0)
  };
  return e.patch(t, s), e.applyData(t, s);
}
function cLe(e, t, n) {
  const r = n ? n.children : void 0, a = (r ? r.indexOf(t) : 1) === 0 ? "th" : "td", s = n && n.type === "table" ? n.align : void 0, l = s ? s.length : t.children.length;
  let c = -1;
  const d = [];
  for (; ++c < l; ) {
    const m = t.children[c], h = {}, v = s ? s[c] : void 0;
    v && (h.align = v);
    let y = { type: "element", tagName: a, properties: h, children: [] };
    m && (y.children = e.all(m), e.patch(m, y), y = e.applyData(m, y)), d.push(y);
  }
  const p = {
    type: "element",
    tagName: "tr",
    properties: {},
    children: e.wrap(d, !0)
  };
  return e.patch(t, p), e.applyData(t, p);
}
function dLe(e, t) {
  const n = {
    type: "element",
    tagName: "td",
    // Assume body cell.
    properties: {},
    children: e.all(t)
  };
  return e.patch(t, n), e.applyData(t, n);
}
const Iz = 9, zz = 32;
function fLe(e) {
  const t = String(e), n = /\r?\n|\r/g;
  let r = n.exec(t), a = 0;
  const s = [];
  for (; r; )
    s.push(
      Fz(t.slice(a, r.index), a > 0, !0),
      r[0]
    ), a = r.index + r[0].length, r = n.exec(t);
  return s.push(Fz(t.slice(a), a > 0, !1)), s.join("");
}
function Fz(e, t, n) {
  let r = 0, a = e.length;
  if (t) {
    let s = e.codePointAt(r);
    for (; s === Iz || s === zz; )
      r++, s = e.codePointAt(r);
  }
  if (n) {
    let s = e.codePointAt(a - 1);
    for (; s === Iz || s === zz; )
      a--, s = e.codePointAt(a - 1);
  }
  return a > r ? e.slice(r, a) : "";
}
function pLe(e, t) {
  const n = { type: "text", value: fLe(String(t.value)) };
  return e.patch(t, n), e.applyData(t, n);
}
function mLe(e, t) {
  const n = {
    type: "element",
    tagName: "hr",
    properties: {},
    children: []
  };
  return e.patch(t, n), e.applyData(t, n);
}
const hLe = {
  blockquote: HTe,
  break: qTe,
  code: WTe,
  delete: GTe,
  emphasis: KTe,
  footnoteReference: XTe,
  heading: YTe,
  html: QTe,
  imageReference: JTe,
  image: ZTe,
  inlineCode: eLe,
  linkReference: tLe,
  link: nLe,
  listItem: rLe,
  list: aLe,
  paragraph: iLe,
  // @ts-expect-error: root is different, but hard to type.
  root: sLe,
  strong: lLe,
  table: uLe,
  tableCell: dLe,
  tableRow: cLe,
  text: pLe,
  thematicBreak: mLe,
  toml: d0,
  yaml: d0,
  definition: d0,
  footnoteDefinition: d0
};
function d0() {
}
const $G = -1, jE = 0, lx = 1, B_ = 2, tj = 3, nj = 4, rj = 5, oj = 6, TG = 7, LG = 8, Bz = typeof self == "object" ? self : globalThis, gLe = (e, t) => {
  const n = (a, s) => (e.set(s, a), a), r = (a) => {
    if (e.has(a))
      return e.get(a);
    const [s, l] = t[a];
    switch (s) {
      case jE:
      case $G:
        return n(l, a);
      case lx: {
        const c = n([], a);
        for (const d of l)
          c.push(r(d));
        return c;
      }
      case B_: {
        const c = n({}, a);
        for (const [d, p] of l)
          c[r(d)] = r(p);
        return c;
      }
      case tj:
        return n(new Date(l), a);
      case nj: {
        const { source: c, flags: d } = l;
        return n(new RegExp(c, d), a);
      }
      case rj: {
        const c = n(/* @__PURE__ */ new Map(), a);
        for (const [d, p] of l)
          c.set(r(d), r(p));
        return c;
      }
      case oj: {
        const c = n(/* @__PURE__ */ new Set(), a);
        for (const d of l)
          c.add(r(d));
        return c;
      }
      case TG: {
        const { name: c, message: d } = l;
        return n(new Bz[c](d), a);
      }
      case LG:
        return n(BigInt(l), a);
      case "BigInt":
        return n(Object(BigInt(l)), a);
      case "ArrayBuffer":
        return n(new Uint8Array(l).buffer, l);
      case "DataView": {
        const { buffer: c } = new Uint8Array(l);
        return n(new DataView(c), l);
      }
    }
    return n(new Bz[s](l), a);
  };
  return r;
}, Uz = (e) => gLe(/* @__PURE__ */ new Map(), e)(0), rh = "", { toString: vLe } = {}, { keys: yLe } = Object, Ow = (e) => {
  const t = typeof e;
  if (t !== "object" || !e)
    return [jE, t];
  const n = vLe.call(e).slice(8, -1);
  switch (n) {
    case "Array":
      return [lx, rh];
    case "Object":
      return [B_, rh];
    case "Date":
      return [tj, rh];
    case "RegExp":
      return [nj, rh];
    case "Map":
      return [rj, rh];
    case "Set":
      return [oj, rh];
    case "DataView":
      return [lx, n];
  }
  return n.includes("Array") ? [lx, n] : n.includes("Error") ? [TG, n] : [B_, n];
}, f0 = ([e, t]) => e === jE && (t === "function" || t === "symbol"), bLe = (e, t, n, r) => {
  const a = (l, c) => {
    const d = r.push(l) - 1;
    return n.set(c, d), d;
  }, s = (l) => {
    if (n.has(l))
      return n.get(l);
    let [c, d] = Ow(l);
    switch (c) {
      case jE: {
        let m = l;
        switch (d) {
          case "bigint":
            c = LG, m = l.toString();
            break;
          case "function":
          case "symbol":
            if (e)
              throw new TypeError("unable to serialize " + d);
            m = null;
            break;
          case "undefined":
            return a([$G], l);
        }
        return a([c, m], l);
      }
      case lx: {
        if (d) {
          let v = l;
          return d === "DataView" ? v = new Uint8Array(l.buffer) : d === "ArrayBuffer" && (v = new Uint8Array(l)), a([d, [...v]], l);
        }
        const m = [], h = a([c, m], l);
        for (const v of l)
          m.push(s(v));
        return h;
      }
      case B_: {
        if (d)
          switch (d) {
            case "BigInt":
              return a([d, l.toString()], l);
            case "Boolean":
            case "Number":
            case "String":
              return a([d, l.valueOf()], l);
          }
        if (t && "toJSON" in l)
          return s(l.toJSON());
        const m = [], h = a([c, m], l);
        for (const v of yLe(l))
          (e || !f0(Ow(l[v]))) && m.push([s(v), s(l[v])]);
        return h;
      }
      case tj:
        return a([c, l.toISOString()], l);
      case nj: {
        const { source: m, flags: h } = l;
        return a([c, { source: m, flags: h }], l);
      }
      case rj: {
        const m = [], h = a([c, m], l);
        for (const [v, y] of l)
          (e || !(f0(Ow(v)) || f0(Ow(y)))) && m.push([s(v), s(y)]);
        return h;
      }
      case oj: {
        const m = [], h = a([c, m], l);
        for (const v of l)
          (e || !f0(Ow(v))) && m.push(s(v));
        return h;
      }
    }
    const { message: p } = l;
    return a([c, { name: d, message: p }], l);
  };
  return s;
}, Vz = (e, { json: t, lossy: n } = {}) => {
  const r = [];
  return bLe(!(t || n), !!t, /* @__PURE__ */ new Map(), r)(e), r;
}, U_ = typeof structuredClone == "function" ? (
  /* c8 ignore start */
  ((e, t) => t && ("json" in t || "lossy" in t) ? Uz(Vz(e, t)) : structuredClone(e))
) : (e, t) => Uz(Vz(e, t));
function wLe(e, t) {
  const n = [{ type: "text", value: "" }];
  return t > 1 && n.push({
    type: "element",
    tagName: "sup",
    properties: {},
    children: [{ type: "text", value: String(t) }]
  }), n;
}
function xLe(e, t) {
  return "Back to reference " + (e + 1) + (t > 1 ? "-" + t : "");
}
function SLe(e) {
  const t = typeof e.options.clobberPrefix == "string" ? e.options.clobberPrefix : "user-content-", n = e.options.footnoteBackContent || wLe, r = e.options.footnoteBackLabel || xLe, a = e.options.footnoteLabel || "Footnotes", s = e.options.footnoteLabelTagName || "h2", l = e.options.footnoteLabelProperties || {
    className: ["sr-only"]
  }, c = [];
  let d = -1;
  for (; ++d < e.footnoteOrder.length; ) {
    const p = e.footnoteById.get(
      e.footnoteOrder[d]
    );
    if (!p)
      continue;
    const m = e.all(p), h = String(p.identifier).toUpperCase(), v = pg(h.toLowerCase());
    let y = 0;
    const w = [], x = e.footnoteCounts.get(h);
    for (; x !== void 0 && ++y <= x; ) {
      w.length > 0 && w.push({ type: "text", value: " " });
      let C = typeof n == "string" ? n : n(d, y);
      typeof C == "string" && (C = { type: "text", value: C }), w.push({
        type: "element",
        tagName: "a",
        properties: {
          href: "#" + t + "fnref-" + v + (y > 1 ? "-" + y : ""),
          dataFootnoteBackref: "",
          ariaLabel: typeof r == "string" ? r : r(d, y),
          className: ["data-footnote-backref"]
        },
        children: Array.isArray(C) ? C : [C]
      });
    }
    const b = m[m.length - 1];
    if (b && b.type === "element" && b.tagName === "p") {
      const C = b.children[b.children.length - 1];
      C && C.type === "text" ? C.value += " " : b.children.push({ type: "text", value: " " }), b.children.push(...w);
    } else
      m.push(...w);
    const k = {
      type: "element",
      tagName: "li",
      properties: { id: t + "fn-" + v },
      children: e.wrap(m, !0)
    };
    e.patch(p, k), c.push(k);
  }
  if (c.length !== 0)
    return {
      type: "element",
      tagName: "section",
      properties: { dataFootnotes: !0, className: ["footnotes"] },
      children: [
        {
          type: "element",
          tagName: s,
          properties: {
            ...U_(l),
            id: "footnote-label"
          },
          children: [{ type: "text", value: a }]
        },
        { type: "text", value: `
` },
        {
          type: "element",
          tagName: "ol",
          properties: {},
          children: e.wrap(c, !0)
        },
        { type: "text", value: `
` }
      ]
    };
}
const PE = (
  // Note: overloads in JSDoc cant yet use different `@template`s.
  /**
   * @type {(
   *   (<Condition extends string>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & {type: Condition}) &
   *   (<Condition extends Props>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & Condition) &
   *   (<Condition extends TestFunction>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & Predicate<Condition, Node>) &
   *   ((test?: null | undefined) => (node?: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node) &
   *   ((test?: Test) => Check)
   * )}
   */
  /**
   * @param {Test} [test]
   * @returns {Check}
   */
  (function(e) {
    if (e == null)
      return CLe;
    if (typeof e == "function")
      return DE(e);
    if (typeof e == "object")
      return Array.isArray(e) ? kLe(e) : _Le(e);
    if (typeof e == "string")
      return ELe(e);
    throw new Error("Expected function, string, or object as test");
  })
);
function kLe(e) {
  const t = [];
  let n = -1;
  for (; ++n < e.length; )
    t[n] = PE(e[n]);
  return DE(r);
  function r(...a) {
    let s = -1;
    for (; ++s < t.length; )
      if (t[s].apply(this, a)) return !0;
    return !1;
  }
}
function _Le(e) {
  const t = (
    /** @type {Record<string, unknown>} */
    e
  );
  return DE(n);
  function n(r) {
    const a = (
      /** @type {Record<string, unknown>} */
      /** @type {unknown} */
      r
    );
    let s;
    for (s in e)
      if (a[s] !== t[s]) return !1;
    return !0;
  }
}
function ELe(e) {
  return DE(t);
  function t(n) {
    return n && n.type === e;
  }
}
function DE(e) {
  return t;
  function t(n, r, a) {
    return !!(OLe(n) && e.call(
      this,
      n,
      typeof r == "number" ? r : void 0,
      a || void 0
    ));
  }
}
function CLe() {
  return !0;
}
function OLe(e) {
  return e !== null && typeof e == "object" && "type" in e;
}
const IG = [], MLe = !0, O3 = !1, NLe = "skip";
function zG(e, t, n, r) {
  let a;
  typeof t == "function" && typeof n != "function" ? (r = n, n = t) : a = t;
  const s = PE(a), l = r ? -1 : 1;
  c(e, void 0, [])();
  function c(d, p, m) {
    const h = (
      /** @type {Record<string, unknown>} */
      d && typeof d == "object" ? d : {}
    );
    if (typeof h.type == "string") {
      const y = (
        // `hast`
        typeof h.tagName == "string" ? h.tagName : (
          // `xast`
          typeof h.name == "string" ? h.name : void 0
        )
      );
      Object.defineProperty(v, "name", {
        value: "node (" + (d.type + (y ? "<" + y + ">" : "")) + ")"
      });
    }
    return v;
    function v() {
      let y = IG, w, x, b;
      if ((!t || s(d, p, m[m.length - 1] || void 0)) && (y = RLe(n(d, m)), y[0] === O3))
        return y;
      if ("children" in d && d.children) {
        const k = (
          /** @type {UnistParent} */
          d
        );
        if (k.children && y[0] !== NLe)
          for (x = (r ? k.children.length : -1) + l, b = m.concat(k); x > -1 && x < k.children.length; ) {
            const C = k.children[x];
            if (w = c(C, x, b)(), w[0] === O3)
              return w;
            x = typeof w[1] == "number" ? w[1] : x + l;
          }
      }
      return y;
    }
  }
}
function RLe(e) {
  return Array.isArray(e) ? e : typeof e == "number" ? [MLe, e] : e == null ? IG : [e];
}
function aj(e, t, n, r) {
  let a, s, l;
  typeof t == "function" && typeof n != "function" ? (s = void 0, l = t, a = n) : (s = t, l = n, a = r), zG(e, s, c, a);
  function c(d, p) {
    const m = p[p.length - 1], h = m ? m.children.indexOf(d) : void 0;
    return l(d, h, m);
  }
}
const M3 = {}.hasOwnProperty, ALe = {};
function jLe(e, t) {
  const n = t || ALe, r = /* @__PURE__ */ new Map(), a = /* @__PURE__ */ new Map(), s = /* @__PURE__ */ new Map(), l = { ...hLe, ...n.handlers }, c = {
    all: p,
    applyData: DLe,
    definitionById: r,
    footnoteById: a,
    footnoteCounts: s,
    footnoteOrder: [],
    handlers: l,
    one: d,
    options: n,
    patch: PLe,
    wrap: TLe
  };
  return aj(e, function(m) {
    if (m.type === "definition" || m.type === "footnoteDefinition") {
      const h = m.type === "definition" ? r : a, v = String(m.identifier).toUpperCase();
      h.has(v) || h.set(v, m);
    }
  }), c;
  function d(m, h) {
    const v = m.type, y = c.handlers[v];
    if (M3.call(c.handlers, v) && y)
      return y(c, m, h);
    if (c.options.passThrough && c.options.passThrough.includes(v)) {
      if ("children" in m) {
        const { children: w, ...x } = m, b = U_(x);
        return b.children = c.all(m), b;
      }
      return U_(m);
    }
    return (c.options.unknownHandler || $Le)(c, m, h);
  }
  function p(m) {
    const h = [];
    if ("children" in m) {
      const v = m.children;
      let y = -1;
      for (; ++y < v.length; ) {
        const w = c.one(v[y], m);
        if (w) {
          if (y && v[y - 1].type === "break" && (!Array.isArray(w) && w.type === "text" && (w.value = Hz(w.value)), !Array.isArray(w) && w.type === "element")) {
            const x = w.children[0];
            x && x.type === "text" && (x.value = Hz(x.value));
          }
          Array.isArray(w) ? h.push(...w) : h.push(w);
        }
      }
    }
    return h;
  }
}
function PLe(e, t) {
  e.position && (t.position = x6e(e));
}
function DLe(e, t) {
  let n = t;
  if (e && e.data) {
    const r = e.data.hName, a = e.data.hChildren, s = e.data.hProperties;
    if (typeof r == "string")
      if (n.type === "element")
        n.tagName = r;
      else {
        const l = "children" in n ? n.children : [n];
        n = { type: "element", tagName: r, properties: {}, children: l };
      }
    n.type === "element" && s && Object.assign(n.properties, U_(s)), "children" in n && n.children && a !== null && a !== void 0 && (n.children = a);
  }
  return n;
}
function $Le(e, t) {
  const n = t.data || {}, r = "value" in t && !(M3.call(n, "hProperties") || M3.call(n, "hChildren")) ? { type: "text", value: t.value } : {
    type: "element",
    tagName: "div",
    properties: {},
    children: e.all(t)
  };
  return e.patch(t, r), e.applyData(t, r);
}
function TLe(e, t) {
  const n = [];
  let r = -1;
  for (t && n.push({ type: "text", value: `
` }); ++r < e.length; )
    r && n.push({ type: "text", value: `
` }), n.push(e[r]);
  return t && e.length > 0 && n.push({ type: "text", value: `
` }), n;
}
function Hz(e) {
  let t = 0, n = e.charCodeAt(t);
  for (; n === 9 || n === 32; )
    t++, n = e.charCodeAt(t);
  return e.slice(t);
}
function qz(e, t) {
  const n = jLe(e, t), r = n.one(e, void 0), a = SLe(n), s = Array.isArray(r) ? { type: "root", children: r } : r || { type: "root", children: [] };
  return a && s.children.push({ type: "text", value: `
` }, a), s;
}
function LLe(e, t) {
  return e && "run" in e ? async function(n, r) {
    const a = (
      /** @type {HastRoot} */
      qz(n, { file: r, ...t })
    );
    await e.run(a, r);
  } : function(n, r) {
    return (
      /** @type {HastRoot} */
      qz(n, { file: r, ...e || t })
    );
  };
}
function Wz(e) {
  if (e)
    throw e;
}
var MN, Gz;
function ILe() {
  if (Gz) return MN;
  Gz = 1;
  var e = Object.prototype.hasOwnProperty, t = Object.prototype.toString, n = Object.defineProperty, r = Object.getOwnPropertyDescriptor, a = function(d) {
    return typeof Array.isArray == "function" ? Array.isArray(d) : t.call(d) === "[object Array]";
  }, s = function(d) {
    if (!d || t.call(d) !== "[object Object]")
      return !1;
    var p = e.call(d, "constructor"), m = d.constructor && d.constructor.prototype && e.call(d.constructor.prototype, "isPrototypeOf");
    if (d.constructor && !p && !m)
      return !1;
    var h;
    for (h in d)
      ;
    return typeof h > "u" || e.call(d, h);
  }, l = function(d, p) {
    n && p.name === "__proto__" ? n(d, p.name, {
      enumerable: !0,
      configurable: !0,
      value: p.newValue,
      writable: !0
    }) : d[p.name] = p.newValue;
  }, c = function(d, p) {
    if (p === "__proto__")
      if (e.call(d, p)) {
        if (r)
          return r(d, p).value;
      } else return;
    return d[p];
  };
  return MN = function d() {
    var p, m, h, v, y, w, x = arguments[0], b = 1, k = arguments.length, C = !1;
    for (typeof x == "boolean" && (C = x, x = arguments[1] || {}, b = 2), (x == null || typeof x != "object" && typeof x != "function") && (x = {}); b < k; ++b)
      if (p = arguments[b], p != null)
        for (m in p)
          h = c(x, m), v = c(p, m), x !== v && (C && v && (s(v) || (y = a(v))) ? (y ? (y = !1, w = h && a(h) ? h : []) : w = h && s(h) ? h : {}, l(x, { name: m, newValue: d(C, w, v) })) : typeof v < "u" && l(x, { name: m, newValue: v }));
    return x;
  }, MN;
}
var zLe = ILe();
const NN = /* @__PURE__ */ Oc(zLe);
function N3(e) {
  if (typeof e != "object" || e === null)
    return !1;
  const t = Object.getPrototypeOf(e);
  return (t === null || t === Object.prototype || Object.getPrototypeOf(t) === null) && !(Symbol.toStringTag in e) && !(Symbol.iterator in e);
}
function FLe() {
  const e = [], t = { run: n, use: r };
  return t;
  function n(...a) {
    let s = -1;
    const l = a.pop();
    if (typeof l != "function")
      throw new TypeError("Expected function as last argument, not " + l);
    c(null, ...a);
    function c(d, ...p) {
      const m = e[++s];
      let h = -1;
      if (d) {
        l(d);
        return;
      }
      for (; ++h < a.length; )
        (p[h] === null || p[h] === void 0) && (p[h] = a[h]);
      a = p, m ? BLe(m, c)(...p) : l(null, ...p);
    }
  }
  function r(a) {
    if (typeof a != "function")
      throw new TypeError(
        "Expected `middelware` to be a function, not " + a
      );
    return e.push(a), t;
  }
}
function BLe(e, t) {
  let n;
  return r;
  function r(...l) {
    const c = e.length > l.length;
    let d;
    c && l.push(a);
    try {
      d = e.apply(this, l);
    } catch (p) {
      const m = (
        /** @type {Error} */
        p
      );
      if (c && n)
        throw m;
      return a(m);
    }
    c || (d && d.then && typeof d.then == "function" ? d.then(s, a) : d instanceof Error ? a(d) : s(d));
  }
  function a(l, ...c) {
    n || (n = !0, t(l, ...c));
  }
  function s(l) {
    a(null, l);
  }
}
const ol = { basename: ULe, dirname: VLe, extname: HLe, join: qLe, sep: "/" };
function ULe(e, t) {
  if (t !== void 0 && typeof t != "string")
    throw new TypeError('"ext" argument must be a string');
  FS(e);
  let n = 0, r = -1, a = e.length, s;
  if (t === void 0 || t.length === 0 || t.length > e.length) {
    for (; a--; )
      if (e.codePointAt(a) === 47) {
        if (s) {
          n = a + 1;
          break;
        }
      } else r < 0 && (s = !0, r = a + 1);
    return r < 0 ? "" : e.slice(n, r);
  }
  if (t === e)
    return "";
  let l = -1, c = t.length - 1;
  for (; a--; )
    if (e.codePointAt(a) === 47) {
      if (s) {
        n = a + 1;
        break;
      }
    } else
      l < 0 && (s = !0, l = a + 1), c > -1 && (e.codePointAt(a) === t.codePointAt(c--) ? c < 0 && (r = a) : (c = -1, r = l));
  return n === r ? r = l : r < 0 && (r = e.length), e.slice(n, r);
}
function VLe(e) {
  if (FS(e), e.length === 0)
    return ".";
  let t = -1, n = e.length, r;
  for (; --n; )
    if (e.codePointAt(n) === 47) {
      if (r) {
        t = n;
        break;
      }
    } else r || (r = !0);
  return t < 0 ? e.codePointAt(0) === 47 ? "/" : "." : t === 1 && e.codePointAt(0) === 47 ? "//" : e.slice(0, t);
}
function HLe(e) {
  FS(e);
  let t = e.length, n = -1, r = 0, a = -1, s = 0, l;
  for (; t--; ) {
    const c = e.codePointAt(t);
    if (c === 47) {
      if (l) {
        r = t + 1;
        break;
      }
      continue;
    }
    n < 0 && (l = !0, n = t + 1), c === 46 ? a < 0 ? a = t : s !== 1 && (s = 1) : a > -1 && (s = -1);
  }
  return a < 0 || n < 0 || // We saw a non-dot character immediately before the dot.
  s === 0 || // The (right-most) trimmed path component is exactly `..`.
  s === 1 && a === n - 1 && a === r + 1 ? "" : e.slice(a, n);
}
function qLe(...e) {
  let t = -1, n;
  for (; ++t < e.length; )
    FS(e[t]), e[t] && (n = n === void 0 ? e[t] : n + "/" + e[t]);
  return n === void 0 ? "." : WLe(n);
}
function WLe(e) {
  FS(e);
  const t = e.codePointAt(0) === 47;
  let n = GLe(e, !t);
  return n.length === 0 && !t && (n = "."), n.length > 0 && e.codePointAt(e.length - 1) === 47 && (n += "/"), t ? "/" + n : n;
}
function GLe(e, t) {
  let n = "", r = 0, a = -1, s = 0, l = -1, c, d;
  for (; ++l <= e.length; ) {
    if (l < e.length)
      c = e.codePointAt(l);
    else {
      if (c === 47)
        break;
      c = 47;
    }
    if (c === 47) {
      if (!(a === l - 1 || s === 1)) if (a !== l - 1 && s === 2) {
        if (n.length < 2 || r !== 2 || n.codePointAt(n.length - 1) !== 46 || n.codePointAt(n.length - 2) !== 46) {
          if (n.length > 2) {
            if (d = n.lastIndexOf("/"), d !== n.length - 1) {
              d < 0 ? (n = "", r = 0) : (n = n.slice(0, d), r = n.length - 1 - n.lastIndexOf("/")), a = l, s = 0;
              continue;
            }
          } else if (n.length > 0) {
            n = "", r = 0, a = l, s = 0;
            continue;
          }
        }
        t && (n = n.length > 0 ? n + "/.." : "..", r = 2);
      } else
        n.length > 0 ? n += "/" + e.slice(a + 1, l) : n = e.slice(a + 1, l), r = l - a - 1;
      a = l, s = 0;
    } else c === 46 && s > -1 ? s++ : s = -1;
  }
  return n;
}
function FS(e) {
  if (typeof e != "string")
    throw new TypeError(
      "Path must be a string. Received " + JSON.stringify(e)
    );
}
const KLe = { cwd: XLe };
function XLe() {
  return "/";
}
function R3(e) {
  return !!(e !== null && typeof e == "object" && "href" in e && e.href && "protocol" in e && e.protocol && // @ts-expect-error: indexing is fine.
  e.auth === void 0);
}
function YLe(e) {
  if (typeof e == "string")
    e = new URL(e);
  else if (!R3(e)) {
    const t = new TypeError(
      'The "path" argument must be of type string or an instance of URL. Received `' + e + "`"
    );
    throw t.code = "ERR_INVALID_ARG_TYPE", t;
  }
  if (e.protocol !== "file:") {
    const t = new TypeError("The URL must be of scheme file");
    throw t.code = "ERR_INVALID_URL_SCHEME", t;
  }
  return QLe(e);
}
function QLe(e) {
  if (e.hostname !== "") {
    const r = new TypeError(
      'File URL host must be "localhost" or empty on darwin'
    );
    throw r.code = "ERR_INVALID_FILE_URL_HOST", r;
  }
  const t = e.pathname;
  let n = -1;
  for (; ++n < t.length; )
    if (t.codePointAt(n) === 37 && t.codePointAt(n + 1) === 50) {
      const r = t.codePointAt(n + 2);
      if (r === 70 || r === 102) {
        const a = new TypeError(
          "File URL path must not include encoded / characters"
        );
        throw a.code = "ERR_INVALID_FILE_URL_PATH", a;
      }
    }
  return decodeURIComponent(t);
}
const RN = (
  /** @type {const} */
  [
    "history",
    "path",
    "basename",
    "stem",
    "extname",
    "dirname"
  ]
);
class FG {
  /**
   * Create a new virtual file.
   *
   * `options` is treated as:
   *
   * *   `string` or `Uint8Array`  `{value: options}`
   * *   `URL`  `{path: options}`
   * *   `VFile`  shallow copies its data over to the new file
   * *   `object`  all fields are shallow copied over to the new file
   *
   * Path related fields are set in the following order (least specific to
   * most specific): `history`, `path`, `basename`, `stem`, `extname`,
   * `dirname`.
   *
   * You cannot set `dirname` or `extname` without setting either `history`,
   * `path`, `basename`, or `stem` too.
   *
   * @param {Compatible | null | undefined} [value]
   *   File value.
   * @returns
   *   New instance.
   */
  constructor(t) {
    let n;
    t ? R3(t) ? n = { path: t } : typeof t == "string" || JLe(t) ? n = { value: t } : n = t : n = {}, this.cwd = "cwd" in n ? "" : KLe.cwd(), this.data = {}, this.history = [], this.messages = [], this.value, this.map, this.result, this.stored;
    let r = -1;
    for (; ++r < RN.length; ) {
      const s = RN[r];
      s in n && n[s] !== void 0 && n[s] !== null && (this[s] = s === "history" ? [...n[s]] : n[s]);
    }
    let a;
    for (a in n)
      RN.includes(a) || (this[a] = n[a]);
  }
  /**
   * Get the basename (including extname) (example: `'index.min.js'`).
   *
   * @returns {string | undefined}
   *   Basename.
   */
  get basename() {
    return typeof this.path == "string" ? ol.basename(this.path) : void 0;
  }
  /**
   * Set basename (including extname) (`'index.min.js'`).
   *
   * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\'`
   * on windows).
   * Cannot be nullified (use `file.path = file.dirname` instead).
   *
   * @param {string} basename
   *   Basename.
   * @returns {undefined}
   *   Nothing.
   */
  set basename(t) {
    jN(t, "basename"), AN(t, "basename"), this.path = ol.join(this.dirname || "", t);
  }
  /**
   * Get the parent path (example: `'~'`).
   *
   * @returns {string | undefined}
   *   Dirname.
   */
  get dirname() {
    return typeof this.path == "string" ? ol.dirname(this.path) : void 0;
  }
  /**
   * Set the parent path (example: `'~'`).
   *
   * Cannot be set if theres no `path` yet.
   *
   * @param {string | undefined} dirname
   *   Dirname.
   * @returns {undefined}
   *   Nothing.
   */
  set dirname(t) {
    Kz(this.basename, "dirname"), this.path = ol.join(t || "", this.basename);
  }
  /**
   * Get the extname (including dot) (example: `'.js'`).
   *
   * @returns {string | undefined}
   *   Extname.
   */
  get extname() {
    return typeof this.path == "string" ? ol.extname(this.path) : void 0;
  }
  /**
   * Set the extname (including dot) (example: `'.js'`).
   *
   * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\'`
   * on windows).
   * Cannot be set if theres no `path` yet.
   *
   * @param {string | undefined} extname
   *   Extname.
   * @returns {undefined}
   *   Nothing.
   */
  set extname(t) {
    if (AN(t, "extname"), Kz(this.dirname, "extname"), t) {
      if (t.codePointAt(0) !== 46)
        throw new Error("`extname` must start with `.`");
      if (t.includes(".", 1))
        throw new Error("`extname` cannot contain multiple dots");
    }
    this.path = ol.join(this.dirname, this.stem + (t || ""));
  }
  /**
   * Get the full path (example: `'~/index.min.js'`).
   *
   * @returns {string}
   *   Path.
   */
  get path() {
    return this.history[this.history.length - 1];
  }
  /**
   * Set the full path (example: `'~/index.min.js'`).
   *
   * Cannot be nullified.
   * You can set a file URL (a `URL` object with a `file:` protocol) which will
   * be turned into a path with `url.fileURLToPath`.
   *
   * @param {URL | string} path
   *   Path.
   * @returns {undefined}
   *   Nothing.
   */
  set path(t) {
    R3(t) && (t = YLe(t)), jN(t, "path"), this.path !== t && this.history.push(t);
  }
  /**
   * Get the stem (basename w/o extname) (example: `'index.min'`).
   *
   * @returns {string | undefined}
   *   Stem.
   */
  get stem() {
    return typeof this.path == "string" ? ol.basename(this.path, this.extname) : void 0;
  }
  /**
   * Set the stem (basename w/o extname) (example: `'index.min'`).
   *
   * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\'`
   * on windows).
   * Cannot be nullified (use `file.path = file.dirname` instead).
   *
   * @param {string} stem
   *   Stem.
   * @returns {undefined}
   *   Nothing.
   */
  set stem(t) {
    jN(t, "stem"), AN(t, "stem"), this.path = ol.join(this.dirname || "", t + (this.extname || ""));
  }
  // Normal prototypal methods.
  /**
   * Create a fatal message for `reason` associated with the file.
   *
   * The `fatal` field of the message is set to `true` (error; file not usable)
   * and the `file` field is set to the current file path.
   * The message is added to the `messages` field on `file`.
   *
   * >  **Note**: also has obsolete signatures.
   *
   * @overload
   * @param {string} reason
   * @param {MessageOptions | null | undefined} [options]
   * @returns {never}
   *
   * @overload
   * @param {string} reason
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @overload
   * @param {string} reason
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @overload
   * @param {string} reason
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @param {Error | VFileMessage | string} causeOrReason
   *   Reason for message, should use markdown.
   * @param {Node | NodeLike | MessageOptions | Point | Position | string | null | undefined} [optionsOrParentOrPlace]
   *   Configuration (optional).
   * @param {string | null | undefined} [origin]
   *   Place in code where the message originates (example:
   *   `'my-package:my-rule'` or `'my-rule'`).
   * @returns {never}
   *   Never.
   * @throws {VFileMessage}
   *   Message.
   */
  fail(t, n, r) {
    const a = this.message(t, n, r);
    throw a.fatal = !0, a;
  }
  /**
   * Create an info message for `reason` associated with the file.
   *
   * The `fatal` field of the message is set to `undefined` (info; change
   * likely not needed) and the `file` field is set to the current file path.
   * The message is added to the `messages` field on `file`.
   *
   * >  **Note**: also has obsolete signatures.
   *
   * @overload
   * @param {string} reason
   * @param {MessageOptions | null | undefined} [options]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @param {Error | VFileMessage | string} causeOrReason
   *   Reason for message, should use markdown.
   * @param {Node | NodeLike | MessageOptions | Point | Position | string | null | undefined} [optionsOrParentOrPlace]
   *   Configuration (optional).
   * @param {string | null | undefined} [origin]
   *   Place in code where the message originates (example:
   *   `'my-package:my-rule'` or `'my-rule'`).
   * @returns {VFileMessage}
   *   Message.
   */
  info(t, n, r) {
    const a = this.message(t, n, r);
    return a.fatal = void 0, a;
  }
  /**
   * Create a message for `reason` associated with the file.
   *
   * The `fatal` field of the message is set to `false` (warning; change may be
   * needed) and the `file` field is set to the current file path.
   * The message is added to the `messages` field on `file`.
   *
   * >  **Note**: also has obsolete signatures.
   *
   * @overload
   * @param {string} reason
   * @param {MessageOptions | null | undefined} [options]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @param {Error | VFileMessage | string} causeOrReason
   *   Reason for message, should use markdown.
   * @param {Node | NodeLike | MessageOptions | Point | Position | string | null | undefined} [optionsOrParentOrPlace]
   *   Configuration (optional).
   * @param {string | null | undefined} [origin]
   *   Place in code where the message originates (example:
   *   `'my-package:my-rule'` or `'my-rule'`).
   * @returns {VFileMessage}
   *   Message.
   */
  message(t, n, r) {
    const a = new Yo(
      // @ts-expect-error: the overloads are fine.
      t,
      n,
      r
    );
    return this.path && (a.name = this.path + ":" + a.name, a.file = this.path), a.fatal = !1, this.messages.push(a), a;
  }
  /**
   * Serialize the file.
   *
   * > **Note**: which encodings are supported depends on the engine.
   * > For info on Node.js, see:
   * > <https://nodejs.org/api/util.html#whatwg-supported-encodings>.
   *
   * @param {string | null | undefined} [encoding='utf8']
   *   Character encoding to understand `value` as when its a `Uint8Array`
   *   (default: `'utf-8'`).
   * @returns {string}
   *   Serialized file.
   */
  toString(t) {
    return this.value === void 0 ? "" : typeof this.value == "string" ? this.value : new TextDecoder(t || void 0).decode(this.value);
  }
}
function AN(e, t) {
  if (e && e.includes(ol.sep))
    throw new Error(
      "`" + t + "` cannot be a path: did not expect `" + ol.sep + "`"
    );
}
function jN(e, t) {
  if (!e)
    throw new Error("`" + t + "` cannot be empty");
}
function Kz(e, t) {
  if (!e)
    throw new Error("Setting `" + t + "` requires `path` to be set too");
}
function JLe(e) {
  return !!(e && typeof e == "object" && "byteLength" in e && "byteOffset" in e);
}
const ZLe = (
  /**
   * @type {new <Parameters extends Array<unknown>, Result>(property: string | symbol) => (...parameters: Parameters) => Result}
   */
  /** @type {unknown} */
  /**
   * @this {Function}
   * @param {string | symbol} property
   * @returns {(...parameters: Array<unknown>) => unknown}
   */
  (function(e) {
    const t = (
      /** @type {Record<string | symbol, Function>} */
      // Prototypes do exist.
      // type-coverage:ignore-next-line
      this.constructor.prototype
    ), n = t[e], r = function() {
      return n.apply(r, arguments);
    };
    return Object.setPrototypeOf(r, t), r;
  })
), eIe = {}.hasOwnProperty;
class ij extends ZLe {
  /**
   * Create a processor.
   */
  constructor() {
    super("copy"), this.Compiler = void 0, this.Parser = void 0, this.attachers = [], this.compiler = void 0, this.freezeIndex = -1, this.frozen = void 0, this.namespace = {}, this.parser = void 0, this.transformers = FLe();
  }
  /**
   * Copy a processor.
   *
   * @deprecated
   *   This is a private internal method and should not be used.
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *   New *unfrozen* processor ({@linkcode Processor}) that is
   *   configured to work the same as its ancestor.
   *   When the descendant processor is configured in the future it does not
   *   affect the ancestral processor.
   */
  copy() {
    const t = (
      /** @type {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>} */
      new ij()
    );
    let n = -1;
    for (; ++n < this.attachers.length; ) {
      const r = this.attachers[n];
      t.use(...r);
    }
    return t.data(NN(!0, {}, this.namespace)), t;
  }
  /**
   * Configure the processor with info available to all plugins.
   * Information is stored in an object.
   *
   * Typically, options can be given to a specific plugin, but sometimes it
   * makes sense to have information shared with several plugins.
   * For example, a list of HTML elements that are self-closing, which is
   * needed during all phases.
   *
   * > **Note**: setting information cannot occur on *frozen* processors.
   * > Call the processor first to create a new unfrozen processor.
   *
   * > **Note**: to register custom data in TypeScript, augment the
   * > {@linkcode Data} interface.
   *
   * @example
   *   This example show how to get and set info:
   *
   *   ```js
   *   import {unified} from 'unified'
   *
   *   const processor = unified().data('alpha', 'bravo')
   *
   *   processor.data('alpha') // => 'bravo'
   *
   *   processor.data() // => {alpha: 'bravo'}
   *
   *   processor.data({charlie: 'delta'})
   *
   *   processor.data() // => {charlie: 'delta'}
   *   ```
   *
   * @template {keyof Data} Key
   *
   * @overload
   * @returns {Data}
   *
   * @overload
   * @param {Data} dataset
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *
   * @overload
   * @param {Key} key
   * @returns {Data[Key]}
   *
   * @overload
   * @param {Key} key
   * @param {Data[Key]} value
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *
   * @param {Data | Key} [key]
   *   Key to get or set, or entire dataset to set, or nothing to get the
   *   entire dataset (optional).
   * @param {Data[Key]} [value]
   *   Value to set (optional).
   * @returns {unknown}
   *   The current processor when setting, the value at `key` when getting, or
   *   the entire dataset when getting without key.
   */
  data(t, n) {
    return typeof t == "string" ? arguments.length === 2 ? ($N("data", this.frozen), this.namespace[t] = n, this) : eIe.call(this.namespace, t) && this.namespace[t] || void 0 : t ? ($N("data", this.frozen), this.namespace = t, this) : this.namespace;
  }
  /**
   * Freeze a processor.
   *
   * Frozen processors are meant to be extended and not to be configured
   * directly.
   *
   * When a processor is frozen it cannot be unfrozen.
   * New processors working the same way can be created by calling the
   * processor.
   *
   * Its possible to freeze processors explicitly by calling `.freeze()`.
   * Processors freeze automatically when `.parse()`, `.run()`, `.runSync()`,
   * `.stringify()`, `.process()`, or `.processSync()` are called.
   *
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *   The current processor.
   */
  freeze() {
    if (this.frozen)
      return this;
    const t = (
      /** @type {Processor} */
      /** @type {unknown} */
      this
    );
    for (; ++this.freezeIndex < this.attachers.length; ) {
      const [n, ...r] = this.attachers[this.freezeIndex];
      if (r[0] === !1)
        continue;
      r[0] === !0 && (r[0] = void 0);
      const a = n.call(t, ...r);
      typeof a == "function" && this.transformers.use(a);
    }
    return this.frozen = !0, this.freezeIndex = Number.POSITIVE_INFINITY, this;
  }
  /**
   * Parse text to a syntax tree.
   *
   * > **Note**: `parse` freezes the processor if not already *frozen*.
   *
   * > **Note**: `parse` performs the parse phase, not the run phase or other
   * > phases.
   *
   * @param {Compatible | undefined} [file]
   *   file to parse (optional); typically `string` or `VFile`; any value
   *   accepted as `x` in `new VFile(x)`.
   * @returns {ParseTree extends undefined ? Node : ParseTree}
   *   Syntax tree representing `file`.
   */
  parse(t) {
    this.freeze();
    const n = p0(t), r = this.parser || this.Parser;
    return PN("parse", r), r(String(n), n);
  }
  /**
   * Process the given file as configured on the processor.
   *
   * > **Note**: `process` freezes the processor if not already *frozen*.
   *
   * > **Note**: `process` performs the parse, run, and stringify phases.
   *
   * @overload
   * @param {Compatible | undefined} file
   * @param {ProcessCallback<VFileWithOutput<CompileResult>>} done
   * @returns {undefined}
   *
   * @overload
   * @param {Compatible | undefined} [file]
   * @returns {Promise<VFileWithOutput<CompileResult>>}
   *
   * @param {Compatible | undefined} [file]
   *   File (optional); typically `string` or `VFile`]; any value accepted as
   *   `x` in `new VFile(x)`.
   * @param {ProcessCallback<VFileWithOutput<CompileResult>> | undefined} [done]
   *   Callback (optional).
   * @returns {Promise<VFile> | undefined}
   *   Nothing if `done` is given.
   *   Otherwise a promise, rejected with a fatal error or resolved with the
   *   processed file.
   *
   *   The parsed, transformed, and compiled value is available at
   *   `file.value` (see note).
   *
   *   > **Note**: unified typically compiles by serializing: most
   *   > compilers return `string` (or `Uint8Array`).
   *   > Some compilers, such as the one configured with
   *   > [`rehype-react`][rehype-react], return other values (in this case, a
   *   > React tree).
   *   > If youre using a compiler that doesnt serialize, expect different
   *   > result values.
   *   >
   *   > To register custom results in TypeScript, add them to
   *   > {@linkcode CompileResultMap}.
   *
   *   [rehype-react]: https://github.com/rehypejs/rehype-react
   */
  process(t, n) {
    const r = this;
    return this.freeze(), PN("process", this.parser || this.Parser), DN("process", this.compiler || this.Compiler), n ? a(void 0, n) : new Promise(a);
    function a(s, l) {
      const c = p0(t), d = (
        /** @type {HeadTree extends undefined ? Node : HeadTree} */
        /** @type {unknown} */
        r.parse(c)
      );
      r.run(d, c, function(m, h, v) {
        if (m || !h || !v)
          return p(m);
        const y = (
          /** @type {CompileTree extends undefined ? Node : CompileTree} */
          /** @type {unknown} */
          h
        ), w = r.stringify(y, v);
        rIe(w) ? v.value = w : v.result = w, p(
          m,
          /** @type {VFileWithOutput<CompileResult>} */
          v
        );
      });
      function p(m, h) {
        m || !h ? l(m) : s ? s(h) : n(void 0, h);
      }
    }
  }
  /**
   * Process the given file as configured on the processor.
   *
   * An error is thrown if asynchronous transforms are configured.
   *
   * > **Note**: `processSync` freezes the processor if not already *frozen*.
   *
   * > **Note**: `processSync` performs the parse, run, and stringify phases.
   *
   * @param {Compatible | undefined} [file]
   *   File (optional); typically `string` or `VFile`; any value accepted as
   *   `x` in `new VFile(x)`.
   * @returns {VFileWithOutput<CompileResult>}
   *   The processed file.
   *
   *   The parsed, transformed, and compiled value is available at
   *   `file.value` (see note).
   *
   *   > **Note**: unified typically compiles by serializing: most
   *   > compilers return `string` (or `Uint8Array`).
   *   > Some compilers, such as the one configured with
   *   > [`rehype-react`][rehype-react], return other values (in this case, a
   *   > React tree).
   *   > If youre using a compiler that doesnt serialize, expect different
   *   > result values.
   *   >
   *   > To register custom results in TypeScript, add them to
   *   > {@linkcode CompileResultMap}.
   *
   *   [rehype-react]: https://github.com/rehypejs/rehype-react
   */
  processSync(t) {
    let n = !1, r;
    return this.freeze(), PN("processSync", this.parser || this.Parser), DN("processSync", this.compiler || this.Compiler), this.process(t, a), Yz("processSync", "process", n), r;
    function a(s, l) {
      n = !0, Wz(s), r = l;
    }
  }
  /**
   * Run *transformers* on a syntax tree.
   *
   * > **Note**: `run` freezes the processor if not already *frozen*.
   *
   * > **Note**: `run` performs the run phase, not other phases.
   *
   * @overload
   * @param {HeadTree extends undefined ? Node : HeadTree} tree
   * @param {RunCallback<TailTree extends undefined ? Node : TailTree>} done
   * @returns {undefined}
   *
   * @overload
   * @param {HeadTree extends undefined ? Node : HeadTree} tree
   * @param {Compatible | undefined} file
   * @param {RunCallback<TailTree extends undefined ? Node : TailTree>} done
   * @returns {undefined}
   *
   * @overload
   * @param {HeadTree extends undefined ? Node : HeadTree} tree
   * @param {Compatible | undefined} [file]
   * @returns {Promise<TailTree extends undefined ? Node : TailTree>}
   *
   * @param {HeadTree extends undefined ? Node : HeadTree} tree
   *   Tree to transform and inspect.
   * @param {(
   *   RunCallback<TailTree extends undefined ? Node : TailTree> |
   *   Compatible
   * )} [file]
   *   File associated with `node` (optional); any value accepted as `x` in
   *   `new VFile(x)`.
   * @param {RunCallback<TailTree extends undefined ? Node : TailTree>} [done]
   *   Callback (optional).
   * @returns {Promise<TailTree extends undefined ? Node : TailTree> | undefined}
   *   Nothing if `done` is given.
   *   Otherwise, a promise rejected with a fatal error or resolved with the
   *   transformed tree.
   */
  run(t, n, r) {
    Xz(t), this.freeze();
    const a = this.transformers;
    return !r && typeof n == "function" && (r = n, n = void 0), r ? s(void 0, r) : new Promise(s);
    function s(l, c) {
      const d = p0(n);
      a.run(t, d, p);
      function p(m, h, v) {
        const y = (
          /** @type {TailTree extends undefined ? Node : TailTree} */
          h || t
        );
        m ? c(m) : l ? l(y) : r(void 0, y, v);
      }
    }
  }
  /**
   * Run *transformers* on a syntax tree.
   *
   * An error is thrown if asynchronous transforms are configured.
   *
   * > **Note**: `runSync` freezes the processor if not already *frozen*.
   *
   * > **Note**: `runSync` performs the run phase, not other phases.
   *
   * @param {HeadTree extends undefined ? Node : HeadTree} tree
   *   Tree to transform and inspect.
   * @param {Compatible | undefined} [file]
   *   File associated with `node` (optional); any value accepted as `x` in
   *   `new VFile(x)`.
   * @returns {TailTree extends undefined ? Node : TailTree}
   *   Transformed tree.
   */
  runSync(t, n) {
    let r = !1, a;
    return this.run(t, n, s), Yz("runSync", "run", r), a;
    function s(l, c) {
      Wz(l), a = c, r = !0;
    }
  }
  /**
   * Compile a syntax tree.
   *
   * > **Note**: `stringify` freezes the processor if not already *frozen*.
   *
   * > **Note**: `stringify` performs the stringify phase, not the run phase
   * > or other phases.
   *
   * @param {CompileTree extends undefined ? Node : CompileTree} tree
   *   Tree to compile.
   * @param {Compatible | undefined} [file]
   *   File associated with `node` (optional); any value accepted as `x` in
   *   `new VFile(x)`.
   * @returns {CompileResult extends undefined ? Value : CompileResult}
   *   Textual representation of the tree (see note).
   *
   *   > **Note**: unified typically compiles by serializing: most compilers
   *   > return `string` (or `Uint8Array`).
   *   > Some compilers, such as the one configured with
   *   > [`rehype-react`][rehype-react], return other values (in this case, a
   *   > React tree).
   *   > If youre using a compiler that doesnt serialize, expect different
   *   > result values.
   *   >
   *   > To register custom results in TypeScript, add them to
   *   > {@linkcode CompileResultMap}.
   *
   *   [rehype-react]: https://github.com/rehypejs/rehype-react
   */
  stringify(t, n) {
    this.freeze();
    const r = p0(n), a = this.compiler || this.Compiler;
    return DN("stringify", a), Xz(t), a(t, r);
  }
  /**
   * Configure the processor to use a plugin, a list of usable values, or a
   * preset.
   *
   * If the processor is already using a plugin, the previous plugin
   * configuration is changed based on the options that are passed in.
   * In other words, the plugin is not added a second time.
   *
   * > **Note**: `use` cannot be called on *frozen* processors.
   * > Call the processor first to create a new unfrozen processor.
   *
   * @example
   *   There are many ways to pass plugins to `.use()`.
   *   This example gives an overview:
   *
   *   ```js
   *   import {unified} from 'unified'
   *
   *   unified()
   *     // Plugin with options:
   *     .use(pluginA, {x: true, y: true})
   *     // Passing the same plugin again merges configuration (to `{x: true, y: false, z: true}`):
   *     .use(pluginA, {y: false, z: true})
   *     // Plugins:
   *     .use([pluginB, pluginC])
   *     // Two plugins, the second with options:
   *     .use([pluginD, [pluginE, {}]])
   *     // Preset with plugins and settings:
   *     .use({plugins: [pluginF, [pluginG, {}]], settings: {position: false}})
   *     // Settings only:
   *     .use({settings: {position: false}})
   *   ```
   *
   * @template {Array<unknown>} [Parameters=[]]
   * @template {Node | string | undefined} [Input=undefined]
   * @template [Output=Input]
   *
   * @overload
   * @param {Preset | null | undefined} [preset]
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *
   * @overload
   * @param {PluggableList} list
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *
   * @overload
   * @param {Plugin<Parameters, Input, Output>} plugin
   * @param {...(Parameters | [boolean])} parameters
   * @returns {UsePlugin<ParseTree, HeadTree, TailTree, CompileTree, CompileResult, Input, Output>}
   *
   * @param {PluggableList | Plugin | Preset | null | undefined} value
   *   Usable value.
   * @param {...unknown} parameters
   *   Parameters, when a plugin is given as a usable value.
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *   Current processor.
   */
  use(t, ...n) {
    const r = this.attachers, a = this.namespace;
    if ($N("use", this.frozen), t != null) if (typeof t == "function")
      d(t, n);
    else if (typeof t == "object")
      Array.isArray(t) ? c(t) : l(t);
    else
      throw new TypeError("Expected usable value, not `" + t + "`");
    return this;
    function s(p) {
      if (typeof p == "function")
        d(p, []);
      else if (typeof p == "object")
        if (Array.isArray(p)) {
          const [m, ...h] = (
            /** @type {PluginTuple<Array<unknown>>} */
            p
          );
          d(m, h);
        } else
          l(p);
      else
        throw new TypeError("Expected usable value, not `" + p + "`");
    }
    function l(p) {
      if (!("plugins" in p) && !("settings" in p))
        throw new Error(
          "Expected usable value but received an empty preset, which is probably a mistake: presets typically come with `plugins` and sometimes with `settings`, but this has neither"
        );
      c(p.plugins), p.settings && (a.settings = NN(!0, a.settings, p.settings));
    }
    function c(p) {
      let m = -1;
      if (p != null) if (Array.isArray(p))
        for (; ++m < p.length; ) {
          const h = p[m];
          s(h);
        }
      else
        throw new TypeError("Expected a list of plugins, not `" + p + "`");
    }
    function d(p, m) {
      let h = -1, v = -1;
      for (; ++h < r.length; )
        if (r[h][0] === p) {
          v = h;
          break;
        }
      if (v === -1)
        r.push([p, ...m]);
      else if (m.length > 0) {
        let [y, ...w] = m;
        const x = r[v][1];
        N3(x) && N3(y) && (y = NN(!0, x, y)), r[v] = [p, y, ...w];
      }
    }
  }
}
const tIe = new ij().freeze();
function PN(e, t) {
  if (typeof t != "function")
    throw new TypeError("Cannot `" + e + "` without `parser`");
}
function DN(e, t) {
  if (typeof t != "function")
    throw new TypeError("Cannot `" + e + "` without `compiler`");
}
function $N(e, t) {
  if (t)
    throw new Error(
      "Cannot call `" + e + "` on a frozen processor.\nCreate a new processor first, by calling it: use `processor()` instead of `processor`."
    );
}
function Xz(e) {
  if (!N3(e) || typeof e.type != "string")
    throw new TypeError("Expected node, got `" + e + "`");
}
function Yz(e, t, n) {
  if (!n)
    throw new Error(
      "`" + e + "` finished async. Use `" + t + "` instead"
    );
}
function p0(e) {
  return nIe(e) ? e : new FG(e);
}
function nIe(e) {
  return !!(e && typeof e == "object" && "message" in e && "messages" in e);
}
function rIe(e) {
  return typeof e == "string" || oIe(e);
}
function oIe(e) {
  return !!(e && typeof e == "object" && "byteLength" in e && "byteOffset" in e);
}
const aIe = "https://github.com/remarkjs/react-markdown/blob/main/changelog.md", Qz = [], Jz = { allowDangerousHtml: !0 }, iIe = /^(https?|ircs?|mailto|xmpp)$/i, sIe = [
  { from: "astPlugins", id: "remove-buggy-html-in-markdown-parser" },
  { from: "allowDangerousHtml", id: "remove-buggy-html-in-markdown-parser" },
  {
    from: "allowNode",
    id: "replace-allownode-allowedtypes-and-disallowedtypes",
    to: "allowElement"
  },
  {
    from: "allowedTypes",
    id: "replace-allownode-allowedtypes-and-disallowedtypes",
    to: "allowedElements"
  },
  { from: "className", id: "remove-classname" },
  {
    from: "disallowedTypes",
    id: "replace-allownode-allowedtypes-and-disallowedtypes",
    to: "disallowedElements"
  },
  { from: "escapeHtml", id: "remove-buggy-html-in-markdown-parser" },
  { from: "includeElementIndex", id: "#remove-includeelementindex" },
  {
    from: "includeNodeIndex",
    id: "change-includenodeindex-to-includeelementindex"
  },
  { from: "linkTarget", id: "remove-linktarget" },
  { from: "plugins", id: "change-plugins-to-remarkplugins", to: "remarkPlugins" },
  { from: "rawSourcePos", id: "#remove-rawsourcepos" },
  { from: "renderers", id: "change-renderers-to-components", to: "components" },
  { from: "source", id: "change-source-to-children", to: "children" },
  { from: "sourcePos", id: "#remove-sourcepos" },
  { from: "transformImageUri", id: "#add-urltransform", to: "urlTransform" },
  { from: "transformLinkUri", id: "#add-urltransform", to: "urlTransform" }
];
function lIe(e) {
  const t = uIe(e), n = cIe(e);
  return dIe(t.runSync(t.parse(n), n), e);
}
function uIe(e) {
  const t = e.rehypePlugins || Qz, n = e.remarkPlugins || Qz, r = e.remarkRehypeOptions ? { ...e.remarkRehypeOptions, ...Jz } : Jz;
  return tIe().use(VTe).use(n).use(LLe, r).use(t);
}
function cIe(e) {
  const t = e.children || "", n = new FG();
  return typeof t == "string" && (n.value = t), n;
}
function dIe(e, t) {
  const n = t.allowedElements, r = t.allowElement, a = t.components, s = t.disallowedElements, l = t.skipHtml, c = t.unwrapDisallowed, d = t.urlTransform || fIe;
  for (const m of sIe)
    Object.hasOwn(t, m.from) && "" + m.from + (m.to ? "use `" + m.to + "` instead" : "remove it") + aIe + m.id;
  return aj(e, p), C6e(e, {
    Fragment: E.Fragment,
    components: a,
    ignoreInvalidStyle: !0,
    jsx: E.jsx,
    jsxs: E.jsxs,
    passKeys: !0,
    passNode: !0
  });
  function p(m, h, v) {
    if (m.type === "raw" && v && typeof h == "number")
      return l ? v.children.splice(h, 1) : v.children[h] = { type: "text", value: m.value }, h;
    if (m.type === "element") {
      let y;
      for (y in EN)
        if (Object.hasOwn(EN, y) && Object.hasOwn(m.properties, y)) {
          const w = m.properties[y], x = EN[y];
          (x === null || x.includes(m.tagName)) && (m.properties[y] = d(String(w || ""), y, m));
        }
    }
    if (m.type === "element") {
      let y = n ? !n.includes(m.tagName) : s ? s.includes(m.tagName) : !1;
      if (!y && r && typeof h == "number" && (y = !r(m, h, v)), y && v && typeof h == "number")
        return c && m.children ? v.children.splice(h, 1, ...m.children) : v.children.splice(h, 1), h;
    }
  }
}
function fIe(e) {
  const t = e.indexOf(":"), n = e.indexOf("?"), r = e.indexOf("#"), a = e.indexOf("/");
  return (
    // If there is no protocol, its relative.
    t === -1 || // If the first colon is after a `?`, `#`, or `/`, its not a protocol.
    a !== -1 && t > a || n !== -1 && t > n || r !== -1 && t > r || // It is a protocol, it should be allowed.
    iIe.test(e.slice(0, t)) ? e : ""
  );
}
function Zz(e, t) {
  const n = String(e);
  if (typeof t != "string")
    throw new TypeError("Expected character");
  let r = 0, a = n.indexOf(t);
  for (; a !== -1; )
    r++, a = n.indexOf(t, a + t.length);
  return r;
}
function pIe(e) {
  if (typeof e != "string")
    throw new TypeError("Expected a string");
  return e.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d");
}
function mIe(e, t, n) {
  const r = PE((n || {}).ignore || []), a = hIe(t);
  let s = -1;
  for (; ++s < a.length; )
    zG(e, "text", l);
  function l(d, p) {
    let m = -1, h;
    for (; ++m < p.length; ) {
      const v = p[m], y = h ? h.children : void 0;
      if (r(
        v,
        y ? y.indexOf(v) : void 0,
        h
      ))
        return;
      h = v;
    }
    if (h)
      return c(d, p);
  }
  function c(d, p) {
    const m = p[p.length - 1], h = a[s][0], v = a[s][1];
    let y = 0;
    const w = m.children.indexOf(d);
    let x = !1, b = [];
    h.lastIndex = 0;
    let k = h.exec(d.value);
    for (; k; ) {
      const C = k.index, _ = {
        index: k.index,
        input: k.input,
        stack: [...p, d]
      };
      let O = v(...k, _);
      if (typeof O == "string" && (O = O.length > 0 ? { type: "text", value: O } : void 0), O === !1 ? h.lastIndex = C + 1 : (y !== C && b.push({
        type: "text",
        value: d.value.slice(y, C)
      }), Array.isArray(O) ? b.push(...O) : O && b.push(O), y = C + k[0].length, x = !0), !h.global)
        break;
      k = h.exec(d.value);
    }
    return x ? (y < d.value.length && b.push({ type: "text", value: d.value.slice(y) }), m.children.splice(w, 1, ...b)) : b = [d], w + b.length;
  }
}
function hIe(e) {
  const t = [];
  if (!Array.isArray(e))
    throw new TypeError("Expected find and replace tuple or list of tuples");
  const n = !e[0] || Array.isArray(e[0]) ? e : [e];
  let r = -1;
  for (; ++r < n.length; ) {
    const a = n[r];
    t.push([gIe(a[0]), vIe(a[1])]);
  }
  return t;
}
function gIe(e) {
  return typeof e == "string" ? new RegExp(pIe(e), "g") : e;
}
function vIe(e) {
  return typeof e == "function" ? e : function() {
    return e;
  };
}
const TN = "phrasing", LN = ["autolink", "link", "image", "label"];
function yIe() {
  return {
    transforms: [EIe],
    enter: {
      literalAutolink: wIe,
      literalAutolinkEmail: IN,
      literalAutolinkHttp: IN,
      literalAutolinkWww: IN
    },
    exit: {
      literalAutolink: _Ie,
      literalAutolinkEmail: kIe,
      literalAutolinkHttp: xIe,
      literalAutolinkWww: SIe
    }
  };
}
function bIe() {
  return {
    unsafe: [
      {
        character: "@",
        before: "[+\\-.\\w]",
        after: "[\\-.\\w]",
        inConstruct: TN,
        notInConstruct: LN
      },
      {
        character: ".",
        before: "[Ww]",
        after: "[\\-.\\w]",
        inConstruct: TN,
        notInConstruct: LN
      },
      {
        character: ":",
        before: "[ps]",
        after: "\\/",
        inConstruct: TN,
        notInConstruct: LN
      }
    ]
  };
}
function wIe(e) {
  this.enter({ type: "link", title: null, url: "", children: [] }, e);
}
function IN(e) {
  this.config.enter.autolinkProtocol.call(this, e);
}
function xIe(e) {
  this.config.exit.autolinkProtocol.call(this, e);
}
function SIe(e) {
  this.config.exit.data.call(this, e);
  const t = this.stack[this.stack.length - 1];
  t.type, t.url = "http://" + this.sliceSerialize(e);
}
function kIe(e) {
  this.config.exit.autolinkEmail.call(this, e);
}
function _Ie(e) {
  this.exit(e);
}
function EIe(e) {
  mIe(
    e,
    [
      [/(https?:\/\/|www(?=\.))([-.\w]+)([^ \t\r\n]*)/gi, CIe],
      [new RegExp("(?<=^|\\s|\\p{P}|\\p{S})([-.\\w+]+)@([-\\w]+(?:\\.[-\\w]+)+)", "gu"), OIe]
    ],
    { ignore: ["link", "linkReference"] }
  );
}
function CIe(e, t, n, r, a) {
  let s = "";
  if (!BG(a) || (/^w/i.test(t) && (n = t + n, t = "", s = "http://"), !MIe(n)))
    return !1;
  const l = NIe(n + r);
  if (!l[0]) return !1;
  const c = {
    type: "link",
    title: null,
    url: s + t + l[0],
    children: [{ type: "text", value: t + l[0] }]
  };
  return l[1] ? [c, { type: "text", value: l[1] }] : c;
}
function OIe(e, t, n, r) {
  return (
    // Not an expected previous character.
    !BG(r, !0) || // Label ends in not allowed character.
    /[-\d_]$/.test(n) ? !1 : {
      type: "link",
      title: null,
      url: "mailto:" + t + "@" + n,
      children: [{ type: "text", value: t + "@" + n }]
    }
  );
}
function MIe(e) {
  const t = e.split(".");
  return !(t.length < 2 || t[t.length - 1] && (/_/.test(t[t.length - 1]) || !/[a-zA-Z\d]/.test(t[t.length - 1])) || t[t.length - 2] && (/_/.test(t[t.length - 2]) || !/[a-zA-Z\d]/.test(t[t.length - 2])));
}
function NIe(e) {
  const t = /[!"&'),.:;<>?\]}]+$/.exec(e);
  if (!t)
    return [e, void 0];
  e = e.slice(0, t.index);
  let n = t[0], r = n.indexOf(")");
  const a = Zz(e, "(");
  let s = Zz(e, ")");
  for (; r !== -1 && a > s; )
    e += n.slice(0, r + 1), n = n.slice(r + 1), r = n.indexOf(")"), s++;
  return [e, n];
}
function BG(e, t) {
  const n = e.input.charCodeAt(e.index - 1);
  return (e.index === 0 || wm(n) || RE(n)) && // If its an email, the previous character should not be a slash.
  (!t || n !== 47);
}
UG.peek = IIe;
function RIe() {
  this.buffer();
}
function AIe(e) {
  this.enter({ type: "footnoteReference", identifier: "", label: "" }, e);
}
function jIe() {
  this.buffer();
}
function PIe(e) {
  this.enter(
    { type: "footnoteDefinition", identifier: "", label: "", children: [] },
    e
  );
}
function DIe(e) {
  const t = this.resume(), n = this.stack[this.stack.length - 1];
  n.type, n.identifier = Is(
    this.sliceSerialize(e)
  ).toLowerCase(), n.label = t;
}
function $Ie(e) {
  this.exit(e);
}
function TIe(e) {
  const t = this.resume(), n = this.stack[this.stack.length - 1];
  n.type, n.identifier = Is(
    this.sliceSerialize(e)
  ).toLowerCase(), n.label = t;
}
function LIe(e) {
  this.exit(e);
}
function IIe() {
  return "[";
}
function UG(e, t, n, r) {
  const a = n.createTracker(r);
  let s = a.move("[^");
  const l = n.enter("footnoteReference"), c = n.enter("reference");
  return s += a.move(
    n.safe(n.associationId(e), { after: "]", before: s })
  ), c(), l(), s += a.move("]"), s;
}
function zIe() {
  return {
    enter: {
      gfmFootnoteCallString: RIe,
      gfmFootnoteCall: AIe,
      gfmFootnoteDefinitionLabelString: jIe,
      gfmFootnoteDefinition: PIe
    },
    exit: {
      gfmFootnoteCallString: DIe,
      gfmFootnoteCall: $Ie,
      gfmFootnoteDefinitionLabelString: TIe,
      gfmFootnoteDefinition: LIe
    }
  };
}
function FIe(e) {
  let t = !1;
  return e && e.firstLineBlank && (t = !0), {
    handlers: { footnoteDefinition: n, footnoteReference: UG },
    // This is on by default already.
    unsafe: [{ character: "[", inConstruct: ["label", "phrasing", "reference"] }]
  };
  function n(r, a, s, l) {
    const c = s.createTracker(l);
    let d = c.move("[^");
    const p = s.enter("footnoteDefinition"), m = s.enter("label");
    return d += c.move(
      s.safe(s.associationId(r), { before: d, after: "]" })
    ), m(), d += c.move("]:"), r.children && r.children.length > 0 && (c.shift(4), d += c.move(
      (t ? `
` : " ") + s.indentLines(
        s.containerFlow(r, c.current()),
        t ? VG : BIe
      )
    )), p(), d;
  }
}
function BIe(e, t, n) {
  return t === 0 ? e : VG(e, t, n);
}
function VG(e, t, n) {
  return (n ? "" : "    ") + e;
}
const UIe = [
  "autolink",
  "destinationLiteral",
  "destinationRaw",
  "reference",
  "titleQuote",
  "titleApostrophe"
];
HG.peek = GIe;
function VIe() {
  return {
    canContainEols: ["delete"],
    enter: { strikethrough: qIe },
    exit: { strikethrough: WIe }
  };
}
function HIe() {
  return {
    unsafe: [
      {
        character: "~",
        inConstruct: "phrasing",
        notInConstruct: UIe
      }
    ],
    handlers: { delete: HG }
  };
}
function qIe(e) {
  this.enter({ type: "delete", children: [] }, e);
}
function WIe(e) {
  this.exit(e);
}
function HG(e, t, n, r) {
  const a = n.createTracker(r), s = n.enter("strikethrough");
  let l = a.move("~~");
  return l += n.containerPhrasing(e, {
    ...a.current(),
    before: l,
    after: "~"
  }), l += a.move("~~"), s(), l;
}
function GIe() {
  return "~";
}
function KIe(e) {
  return e.length;
}
function XIe(e, t) {
  const n = t || {}, r = (n.align || []).concat(), a = n.stringLength || KIe, s = [], l = [], c = [], d = [];
  let p = 0, m = -1;
  for (; ++m < e.length; ) {
    const x = [], b = [];
    let k = -1;
    for (e[m].length > p && (p = e[m].length); ++k < e[m].length; ) {
      const C = YIe(e[m][k]);
      if (n.alignDelimiters !== !1) {
        const _ = a(C);
        b[k] = _, (d[k] === void 0 || _ > d[k]) && (d[k] = _);
      }
      x.push(C);
    }
    l[m] = x, c[m] = b;
  }
  let h = -1;
  if (typeof r == "object" && "length" in r)
    for (; ++h < p; )
      s[h] = e1(r[h]);
  else {
    const x = e1(r);
    for (; ++h < p; )
      s[h] = x;
  }
  h = -1;
  const v = [], y = [];
  for (; ++h < p; ) {
    const x = s[h];
    let b = "", k = "";
    x === 99 ? (b = ":", k = ":") : x === 108 ? b = ":" : x === 114 && (k = ":");
    let C = n.alignDelimiters === !1 ? 1 : Math.max(
      1,
      d[h] - b.length - k.length
    );
    const _ = b + "-".repeat(C) + k;
    n.alignDelimiters !== !1 && (C = b.length + C + k.length, C > d[h] && (d[h] = C), y[h] = C), v[h] = _;
  }
  l.splice(1, 0, v), c.splice(1, 0, y), m = -1;
  const w = [];
  for (; ++m < l.length; ) {
    const x = l[m], b = c[m];
    h = -1;
    const k = [];
    for (; ++h < p; ) {
      const C = x[h] || "";
      let _ = "", O = "";
      if (n.alignDelimiters !== !1) {
        const N = d[h] - (b[h] || 0), R = s[h];
        R === 114 ? _ = " ".repeat(N) : R === 99 ? N % 2 ? (_ = " ".repeat(N / 2 + 0.5), O = " ".repeat(N / 2 - 0.5)) : (_ = " ".repeat(N / 2), O = _) : O = " ".repeat(N);
      }
      n.delimiterStart !== !1 && !h && k.push("|"), n.padding !== !1 && // Dont add the opening space if were not aligning and the cell is
      // empty: there will be a closing space.
      !(n.alignDelimiters === !1 && C === "") && (n.delimiterStart !== !1 || h) && k.push(" "), n.alignDelimiters !== !1 && k.push(_), k.push(C), n.alignDelimiters !== !1 && k.push(O), n.padding !== !1 && k.push(" "), (n.delimiterEnd !== !1 || h !== p - 1) && k.push("|");
    }
    w.push(
      n.delimiterEnd === !1 ? k.join("").replace(/ +$/, "") : k.join("")
    );
  }
  return w.join(`
`);
}
function YIe(e) {
  return e == null ? "" : String(e);
}
function e1(e) {
  const t = typeof e == "string" ? e.codePointAt(0) : 0;
  return t === 67 || t === 99 ? 99 : t === 76 || t === 108 ? 108 : t === 82 || t === 114 ? 114 : 0;
}
function QIe(e, t, n, r) {
  const a = n.enter("blockquote"), s = n.createTracker(r);
  s.move("> "), s.shift(2);
  const l = n.indentLines(
    n.containerFlow(e, s.current()),
    JIe
  );
  return a(), l;
}
function JIe(e, t, n) {
  return ">" + (n ? "" : " ") + e;
}
function ZIe(e, t) {
  return t1(e, t.inConstruct, !0) && !t1(e, t.notInConstruct, !1);
}
function t1(e, t, n) {
  if (typeof t == "string" && (t = [t]), !t || t.length === 0)
    return n;
  let r = -1;
  for (; ++r < t.length; )
    if (e.includes(t[r]))
      return !0;
  return !1;
}
function n1(e, t, n, r) {
  let a = -1;
  for (; ++a < n.unsafe.length; )
    if (n.unsafe[a].character === `
` && ZIe(n.stack, n.unsafe[a]))
      return /[ \t]/.test(r.before) ? "" : " ";
  return `\\
`;
}
function eze(e, t) {
  const n = String(e);
  let r = n.indexOf(t), a = r, s = 0, l = 0;
  if (typeof t != "string")
    throw new TypeError("Expected substring");
  for (; r !== -1; )
    r === a ? ++s > l && (l = s) : s = 1, a = r + t.length, r = n.indexOf(t, a);
  return l;
}
function tze(e, t) {
  return !!(t.options.fences === !1 && e.value && // If theres no info
  !e.lang && // And theres a non-whitespace character
  /[^ \r\n]/.test(e.value) && // And the value doesnt start or end in a blank
  !/^[\t ]*(?:[\r\n]|$)|(?:^|[\r\n])[\t ]*$/.test(e.value));
}
function nze(e) {
  const t = e.options.fence || "`";
  if (t !== "`" && t !== "~")
    throw new Error(
      "Cannot serialize code with `" + t + "` for `options.fence`, expected `` ` `` or `~`"
    );
  return t;
}
function rze(e, t, n, r) {
  const a = nze(n), s = e.value || "", l = a === "`" ? "GraveAccent" : "Tilde";
  if (tze(e, n)) {
    const h = n.enter("codeIndented"), v = n.indentLines(s, oze);
    return h(), v;
  }
  const c = n.createTracker(r), d = a.repeat(Math.max(eze(s, a) + 1, 3)), p = n.enter("codeFenced");
  let m = c.move(d);
  if (e.lang) {
    const h = n.enter(`codeFencedLang${l}`);
    m += c.move(
      n.safe(e.lang, {
        before: m,
        after: " ",
        encode: ["`"],
        ...c.current()
      })
    ), h();
  }
  if (e.lang && e.meta) {
    const h = n.enter(`codeFencedMeta${l}`);
    m += c.move(" "), m += c.move(
      n.safe(e.meta, {
        before: m,
        after: `
`,
        encode: ["`"],
        ...c.current()
      })
    ), h();
  }
  return m += c.move(`
`), s && (m += c.move(s + `
`)), m += c.move(d), p(), m;
}
function oze(e, t, n) {
  return (n ? "" : "    ") + e;
}
function sj(e) {
  const t = e.options.quote || '"';
  if (t !== '"' && t !== "'")
    throw new Error(
      "Cannot serialize title with `" + t + "` for `options.quote`, expected `\"`, or `'`"
    );
  return t;
}
function aze(e, t, n, r) {
  const a = sj(n), s = a === '"' ? "Quote" : "Apostrophe", l = n.enter("definition");
  let c = n.enter("label");
  const d = n.createTracker(r);
  let p = d.move("[");
  return p += d.move(
    n.safe(n.associationId(e), {
      before: p,
      after: "]",
      ...d.current()
    })
  ), p += d.move("]: "), c(), // If theres no url, or
  !e.url || // If there are control characters or whitespace.
  /[\0- \u007F]/.test(e.url) ? (c = n.enter("destinationLiteral"), p += d.move("<"), p += d.move(
    n.safe(e.url, { before: p, after: ">", ...d.current() })
  ), p += d.move(">")) : (c = n.enter("destinationRaw"), p += d.move(
    n.safe(e.url, {
      before: p,
      after: e.title ? " " : `
`,
      ...d.current()
    })
  )), c(), e.title && (c = n.enter(`title${s}`), p += d.move(" " + a), p += d.move(
    n.safe(e.title, {
      before: p,
      after: a,
      ...d.current()
    })
  ), p += d.move(a), c()), l(), p;
}
function ize(e) {
  const t = e.options.emphasis || "*";
  if (t !== "*" && t !== "_")
    throw new Error(
      "Cannot serialize emphasis with `" + t + "` for `options.emphasis`, expected `*`, or `_`"
    );
  return t;
}
function Wx(e) {
  return "&#x" + e.toString(16).toUpperCase() + ";";
}
function V_(e, t, n) {
  const r = Qh(e), a = Qh(t);
  return r === void 0 ? a === void 0 ? (
    // Letter inside:
    // we have to encode *both* letters for `_` as it is looser.
    // it already forms for `*` (and GFMs `~`).
    n === "_" ? { inside: !0, outside: !0 } : { inside: !1, outside: !1 }
  ) : a === 1 ? (
    // Whitespace inside: encode both (letter, whitespace).
    { inside: !0, outside: !0 }
  ) : (
    // Punctuation inside: encode outer (letter)
    { inside: !1, outside: !0 }
  ) : r === 1 ? a === void 0 ? (
    // Letter inside: already forms.
    { inside: !1, outside: !1 }
  ) : a === 1 ? (
    // Whitespace inside: encode both (whitespace).
    { inside: !0, outside: !0 }
  ) : (
    // Punctuation inside: already forms.
    { inside: !1, outside: !1 }
  ) : a === void 0 ? (
    // Letter inside: already forms.
    { inside: !1, outside: !1 }
  ) : a === 1 ? (
    // Whitespace inside: encode inner (whitespace).
    { inside: !0, outside: !1 }
  ) : (
    // Punctuation inside: already forms.
    { inside: !1, outside: !1 }
  );
}
qG.peek = sze;
function qG(e, t, n, r) {
  const a = ize(n), s = n.enter("emphasis"), l = n.createTracker(r), c = l.move(a);
  let d = l.move(
    n.containerPhrasing(e, {
      after: a,
      before: c,
      ...l.current()
    })
  );
  const p = d.charCodeAt(0), m = V_(
    r.before.charCodeAt(r.before.length - 1),
    p,
    a
  );
  m.inside && (d = Wx(p) + d.slice(1));
  const h = d.charCodeAt(d.length - 1), v = V_(r.after.charCodeAt(0), h, a);
  v.inside && (d = d.slice(0, -1) + Wx(h));
  const y = l.move(a);
  return s(), n.attentionEncodeSurroundingInfo = {
    after: v.outside,
    before: m.outside
  }, c + d + y;
}
function sze(e, t, n) {
  return n.options.emphasis || "*";
}
function lze(e, t) {
  let n = !1;
  return aj(e, function(r) {
    if ("value" in r && /\r?\n|\r/.test(r.value) || r.type === "break")
      return n = !0, O3;
  }), !!((!e.depth || e.depth < 3) && J4(e) && (t.options.setext || n));
}
function uze(e, t, n, r) {
  const a = Math.max(Math.min(6, e.depth || 1), 1), s = n.createTracker(r);
  if (lze(e, n)) {
    const m = n.enter("headingSetext"), h = n.enter("phrasing"), v = n.containerPhrasing(e, {
      ...s.current(),
      before: `
`,
      after: `
`
    });
    return h(), m(), v + `
` + (a === 1 ? "=" : "-").repeat(
      // The whole size
      v.length - // Minus the position of the character after the last EOL (or
      // 0 if there is none)
      (Math.max(v.lastIndexOf("\r"), v.lastIndexOf(`
`)) + 1)
    );
  }
  const l = "#".repeat(a), c = n.enter("headingAtx"), d = n.enter("phrasing");
  s.move(l + " ");
  let p = n.containerPhrasing(e, {
    before: "# ",
    after: `
`,
    ...s.current()
  });
  return /^[\t ]/.test(p) && (p = Wx(p.charCodeAt(0)) + p.slice(1)), p = p ? l + " " + p : l, n.options.closeAtx && (p += " " + l), d(), c(), p;
}
WG.peek = cze;
function WG(e) {
  return e.value || "";
}
function cze() {
  return "<";
}
GG.peek = dze;
function GG(e, t, n, r) {
  const a = sj(n), s = a === '"' ? "Quote" : "Apostrophe", l = n.enter("image");
  let c = n.enter("label");
  const d = n.createTracker(r);
  let p = d.move("![");
  return p += d.move(
    n.safe(e.alt, { before: p, after: "]", ...d.current() })
  ), p += d.move("]("), c(), // If theres no url but there is a title
  !e.url && e.title || // If there are control characters or whitespace.
  /[\0- \u007F]/.test(e.url) ? (c = n.enter("destinationLiteral"), p += d.move("<"), p += d.move(
    n.safe(e.url, { before: p, after: ">", ...d.current() })
  ), p += d.move(">")) : (c = n.enter("destinationRaw"), p += d.move(
    n.safe(e.url, {
      before: p,
      after: e.title ? " " : ")",
      ...d.current()
    })
  )), c(), e.title && (c = n.enter(`title${s}`), p += d.move(" " + a), p += d.move(
    n.safe(e.title, {
      before: p,
      after: a,
      ...d.current()
    })
  ), p += d.move(a), c()), p += d.move(")"), l(), p;
}
function dze() {
  return "!";
}
KG.peek = fze;
function KG(e, t, n, r) {
  const a = e.referenceType, s = n.enter("imageReference");
  let l = n.enter("label");
  const c = n.createTracker(r);
  let d = c.move("![");
  const p = n.safe(e.alt, {
    before: d,
    after: "]",
    ...c.current()
  });
  d += c.move(p + "]["), l();
  const m = n.stack;
  n.stack = [], l = n.enter("reference");
  const h = n.safe(n.associationId(e), {
    before: d,
    after: "]",
    ...c.current()
  });
  return l(), n.stack = m, s(), a === "full" || !p || p !== h ? d += c.move(h + "]") : a === "shortcut" ? d = d.slice(0, -1) : d += c.move("]"), d;
}
function fze() {
  return "!";
}
XG.peek = pze;
function XG(e, t, n) {
  let r = e.value || "", a = "`", s = -1;
  for (; new RegExp("(^|[^`])" + a + "([^`]|$)").test(r); )
    a += "`";
  for (/[^ \r\n]/.test(r) && (/^[ \r\n]/.test(r) && /[ \r\n]$/.test(r) || /^`|`$/.test(r)) && (r = " " + r + " "); ++s < n.unsafe.length; ) {
    const l = n.unsafe[s], c = n.compilePattern(l);
    let d;
    if (l.atBreak)
      for (; d = c.exec(r); ) {
        let p = d.index;
        r.charCodeAt(p) === 10 && r.charCodeAt(p - 1) === 13 && p--, r = r.slice(0, p) + " " + r.slice(d.index + 1);
      }
  }
  return a + r + a;
}
function pze() {
  return "`";
}
function YG(e, t) {
  const n = J4(e);
  return !!(!t.options.resourceLink && // If theres a url
  e.url && // And theres a no title
  !e.title && // And the content of `node` is a single text node
  e.children && e.children.length === 1 && e.children[0].type === "text" && // And if the url is the same as the content
  (n === e.url || "mailto:" + n === e.url) && // And that starts w/ a protocol
  /^[a-z][a-z+.-]+:/i.test(e.url) && // And that doesnt contain ASCII control codes (character escapes and
  // references dont work), space, or angle brackets
  !/[\0- <>\u007F]/.test(e.url));
}
QG.peek = mze;
function QG(e, t, n, r) {
  const a = sj(n), s = a === '"' ? "Quote" : "Apostrophe", l = n.createTracker(r);
  let c, d;
  if (YG(e, n)) {
    const m = n.stack;
    n.stack = [], c = n.enter("autolink");
    let h = l.move("<");
    return h += l.move(
      n.containerPhrasing(e, {
        before: h,
        after: ">",
        ...l.current()
      })
    ), h += l.move(">"), c(), n.stack = m, h;
  }
  c = n.enter("link"), d = n.enter("label");
  let p = l.move("[");
  return p += l.move(
    n.containerPhrasing(e, {
      before: p,
      after: "](",
      ...l.current()
    })
  ), p += l.move("]("), d(), // If theres no url but there is a title
  !e.url && e.title || // If there are control characters or whitespace.
  /[\0- \u007F]/.test(e.url) ? (d = n.enter("destinationLiteral"), p += l.move("<"), p += l.move(
    n.safe(e.url, { before: p, after: ">", ...l.current() })
  ), p += l.move(">")) : (d = n.enter("destinationRaw"), p += l.move(
    n.safe(e.url, {
      before: p,
      after: e.title ? " " : ")",
      ...l.current()
    })
  )), d(), e.title && (d = n.enter(`title${s}`), p += l.move(" " + a), p += l.move(
    n.safe(e.title, {
      before: p,
      after: a,
      ...l.current()
    })
  ), p += l.move(a), d()), p += l.move(")"), c(), p;
}
function mze(e, t, n) {
  return YG(e, n) ? "<" : "[";
}
JG.peek = hze;
function JG(e, t, n, r) {
  const a = e.referenceType, s = n.enter("linkReference");
  let l = n.enter("label");
  const c = n.createTracker(r);
  let d = c.move("[");
  const p = n.containerPhrasing(e, {
    before: d,
    after: "]",
    ...c.current()
  });
  d += c.move(p + "]["), l();
  const m = n.stack;
  n.stack = [], l = n.enter("reference");
  const h = n.safe(n.associationId(e), {
    before: d,
    after: "]",
    ...c.current()
  });
  return l(), n.stack = m, s(), a === "full" || !p || p !== h ? d += c.move(h + "]") : a === "shortcut" ? d = d.slice(0, -1) : d += c.move("]"), d;
}
function hze() {
  return "[";
}
function lj(e) {
  const t = e.options.bullet || "*";
  if (t !== "*" && t !== "+" && t !== "-")
    throw new Error(
      "Cannot serialize items with `" + t + "` for `options.bullet`, expected `*`, `+`, or `-`"
    );
  return t;
}
function gze(e) {
  const t = lj(e), n = e.options.bulletOther;
  if (!n)
    return t === "*" ? "-" : "*";
  if (n !== "*" && n !== "+" && n !== "-")
    throw new Error(
      "Cannot serialize items with `" + n + "` for `options.bulletOther`, expected `*`, `+`, or `-`"
    );
  if (n === t)
    throw new Error(
      "Expected `bullet` (`" + t + "`) and `bulletOther` (`" + n + "`) to be different"
    );
  return n;
}
function vze(e) {
  const t = e.options.bulletOrdered || ".";
  if (t !== "." && t !== ")")
    throw new Error(
      "Cannot serialize items with `" + t + "` for `options.bulletOrdered`, expected `.` or `)`"
    );
  return t;
}
function ZG(e) {
  const t = e.options.rule || "*";
  if (t !== "*" && t !== "-" && t !== "_")
    throw new Error(
      "Cannot serialize rules with `" + t + "` for `options.rule`, expected `*`, `-`, or `_`"
    );
  return t;
}
function yze(e, t, n, r) {
  const a = n.enter("list"), s = n.bulletCurrent;
  let l = e.ordered ? vze(n) : lj(n);
  const c = e.ordered ? l === "." ? ")" : "." : gze(n);
  let d = t && n.bulletLastUsed ? l === n.bulletLastUsed : !1;
  if (!e.ordered) {
    const m = e.children ? e.children[0] : void 0;
    if (
      // Bullet could be used as a thematic break marker:
      (l === "*" || l === "-") && // Empty first list item:
      m && (!m.children || !m.children[0]) && // Directly in two other list items:
      n.stack[n.stack.length - 1] === "list" && n.stack[n.stack.length - 2] === "listItem" && n.stack[n.stack.length - 3] === "list" && n.stack[n.stack.length - 4] === "listItem" && // That are each the first child.
      n.indexStack[n.indexStack.length - 1] === 0 && n.indexStack[n.indexStack.length - 2] === 0 && n.indexStack[n.indexStack.length - 3] === 0 && (d = !0), ZG(n) === l && m
    ) {
      let h = -1;
      for (; ++h < e.children.length; ) {
        const v = e.children[h];
        if (v && v.type === "listItem" && v.children && v.children[0] && v.children[0].type === "thematicBreak") {
          d = !0;
          break;
        }
      }
    }
  }
  d && (l = c), n.bulletCurrent = l;
  const p = n.containerFlow(e, r);
  return n.bulletLastUsed = l, n.bulletCurrent = s, a(), p;
}
function bze(e) {
  const t = e.options.listItemIndent || "one";
  if (t !== "tab" && t !== "one" && t !== "mixed")
    throw new Error(
      "Cannot serialize items with `" + t + "` for `options.listItemIndent`, expected `tab`, `one`, or `mixed`"
    );
  return t;
}
function wze(e, t, n, r) {
  const a = bze(n);
  let s = n.bulletCurrent || lj(n);
  t && t.type === "list" && t.ordered && (s = (typeof t.start == "number" && t.start > -1 ? t.start : 1) + (n.options.incrementListMarker === !1 ? 0 : t.children.indexOf(e)) + s);
  let l = s.length + 1;
  (a === "tab" || a === "mixed" && (t && t.type === "list" && t.spread || e.spread)) && (l = Math.ceil(l / 4) * 4);
  const c = n.createTracker(r);
  c.move(s + " ".repeat(l - s.length)), c.shift(l);
  const d = n.enter("listItem"), p = n.indentLines(
    n.containerFlow(e, c.current()),
    m
  );
  return d(), p;
  function m(h, v, y) {
    return v ? (y ? "" : " ".repeat(l)) + h : (y ? s : s + " ".repeat(l - s.length)) + h;
  }
}
function xze(e, t, n, r) {
  const a = n.enter("paragraph"), s = n.enter("phrasing"), l = n.containerPhrasing(e, r);
  return s(), a(), l;
}
const Sze = (
  /** @type {(node?: unknown) => node is Exclude<PhrasingContent, Html>} */
  PE([
    "break",
    "delete",
    "emphasis",
    // To do: next major: removed since footnotes were added to GFM.
    "footnote",
    "footnoteReference",
    "image",
    "imageReference",
    "inlineCode",
    // Enabled by `mdast-util-math`:
    "inlineMath",
    "link",
    "linkReference",
    // Enabled by `mdast-util-mdx`:
    "mdxJsxTextElement",
    // Enabled by `mdast-util-mdx`:
    "mdxTextExpression",
    "strong",
    "text",
    // Enabled by `mdast-util-directive`:
    "textDirective"
  ])
);
function kze(e, t, n, r) {
  return (e.children.some(function(a) {
    return Sze(a);
  }) ? n.containerPhrasing : n.containerFlow).call(n, e, r);
}
function _ze(e) {
  const t = e.options.strong || "*";
  if (t !== "*" && t !== "_")
    throw new Error(
      "Cannot serialize strong with `" + t + "` for `options.strong`, expected `*`, or `_`"
    );
  return t;
}
eK.peek = Eze;
function eK(e, t, n, r) {
  const a = _ze(n), s = n.enter("strong"), l = n.createTracker(r), c = l.move(a + a);
  let d = l.move(
    n.containerPhrasing(e, {
      after: a,
      before: c,
      ...l.current()
    })
  );
  const p = d.charCodeAt(0), m = V_(
    r.before.charCodeAt(r.before.length - 1),
    p,
    a
  );
  m.inside && (d = Wx(p) + d.slice(1));
  const h = d.charCodeAt(d.length - 1), v = V_(r.after.charCodeAt(0), h, a);
  v.inside && (d = d.slice(0, -1) + Wx(h));
  const y = l.move(a + a);
  return s(), n.attentionEncodeSurroundingInfo = {
    after: v.outside,
    before: m.outside
  }, c + d + y;
}
function Eze(e, t, n) {
  return n.options.strong || "*";
}
function Cze(e, t, n, r) {
  return n.safe(e.value, r);
}
function Oze(e) {
  const t = e.options.ruleRepetition || 3;
  if (t < 3)
    throw new Error(
      "Cannot serialize rules with repetition `" + t + "` for `options.ruleRepetition`, expected `3` or more"
    );
  return t;
}
function Mze(e, t, n) {
  const r = (ZG(n) + (n.options.ruleSpaces ? " " : "")).repeat(Oze(n));
  return n.options.ruleSpaces ? r.slice(0, -1) : r;
}
const tK = {
  blockquote: QIe,
  break: n1,
  code: rze,
  definition: aze,
  emphasis: qG,
  hardBreak: n1,
  heading: uze,
  html: WG,
  image: GG,
  imageReference: KG,
  inlineCode: XG,
  link: QG,
  linkReference: JG,
  list: yze,
  listItem: wze,
  paragraph: xze,
  root: kze,
  strong: eK,
  text: Cze,
  thematicBreak: Mze
};
function Nze() {
  return {
    enter: {
      table: Rze,
      tableData: r1,
      tableHeader: r1,
      tableRow: jze
    },
    exit: {
      codeText: Pze,
      table: Aze,
      tableData: zN,
      tableHeader: zN,
      tableRow: zN
    }
  };
}
function Rze(e) {
  const t = e._align;
  this.enter(
    {
      type: "table",
      align: t.map(function(n) {
        return n === "none" ? null : n;
      }),
      children: []
    },
    e
  ), this.data.inTable = !0;
}
function Aze(e) {
  this.exit(e), this.data.inTable = void 0;
}
function jze(e) {
  this.enter({ type: "tableRow", children: [] }, e);
}
function zN(e) {
  this.exit(e);
}
function r1(e) {
  this.enter({ type: "tableCell", children: [] }, e);
}
function Pze(e) {
  let t = this.resume();
  this.data.inTable && (t = t.replace(/\\([\\|])/g, Dze));
  const n = this.stack[this.stack.length - 1];
  n.type, n.value = t, this.exit(e);
}
function Dze(e, t) {
  return t === "|" ? t : e;
}
function $ze(e) {
  const t = e || {}, n = t.tableCellPadding, r = t.tablePipeAlign, a = t.stringLength, s = n ? " " : "|";
  return {
    unsafe: [
      { character: "\r", inConstruct: "tableCell" },
      { character: `
`, inConstruct: "tableCell" },
      // A pipe, when followed by a tab or space (padding), or a dash or colon
      // (unpadded delimiter row), could result in a table.
      { atBreak: !0, character: "|", after: "[	 :-]" },
      // A pipe in a cell must be encoded.
      { character: "|", inConstruct: "tableCell" },
      // A colon must be followed by a dash, in which case it could start a
      // delimiter row.
      { atBreak: !0, character: ":", after: "-" },
      // A delimiter row can also start with a dash, when followed by more
      // dashes, a colon, or a pipe.
      // This is a stricter version than the built in check for lists, thematic
      // breaks, and setex heading underlines though:
      // <https://github.com/syntax-tree/mdast-util-to-markdown/blob/51a2038/lib/unsafe.js#L57>
      { atBreak: !0, character: "-", after: "[:|-]" }
    ],
    handlers: {
      inlineCode: v,
      table: l,
      tableCell: d,
      tableRow: c
    }
  };
  function l(y, w, x, b) {
    return p(m(y, x, b), y.align);
  }
  function c(y, w, x, b) {
    const k = h(y, x, b), C = p([k]);
    return C.slice(0, C.indexOf(`
`));
  }
  function d(y, w, x, b) {
    const k = x.enter("tableCell"), C = x.enter("phrasing"), _ = x.containerPhrasing(y, {
      ...b,
      before: s,
      after: s
    });
    return C(), k(), _;
  }
  function p(y, w) {
    return XIe(y, {
      align: w,
      // @ts-expect-error: `markdown-table` types should support `null`.
      alignDelimiters: r,
      // @ts-expect-error: `markdown-table` types should support `null`.
      padding: n,
      // @ts-expect-error: `markdown-table` types should support `null`.
      stringLength: a
    });
  }
  function m(y, w, x) {
    const b = y.children;
    let k = -1;
    const C = [], _ = w.enter("table");
    for (; ++k < b.length; )
      C[k] = h(b[k], w, x);
    return _(), C;
  }
  function h(y, w, x) {
    const b = y.children;
    let k = -1;
    const C = [], _ = w.enter("tableRow");
    for (; ++k < b.length; )
      C[k] = d(b[k], y, w, x);
    return _(), C;
  }
  function v(y, w, x) {
    let b = tK.inlineCode(y, w, x);
    return x.stack.includes("tableCell") && (b = b.replace(/\|/g, "\\$&")), b;
  }
}
function Tze() {
  return {
    exit: {
      taskListCheckValueChecked: o1,
      taskListCheckValueUnchecked: o1,
      paragraph: Ize
    }
  };
}
function Lze() {
  return {
    unsafe: [{ atBreak: !0, character: "-", after: "[:|-]" }],
    handlers: { listItem: zze }
  };
}
function o1(e) {
  const t = this.stack[this.stack.length - 2];
  t.type, t.checked = e.type === "taskListCheckValueChecked";
}
function Ize(e) {
  const t = this.stack[this.stack.length - 2];
  if (t && t.type === "listItem" && typeof t.checked == "boolean") {
    const n = this.stack[this.stack.length - 1];
    n.type;
    const r = n.children[0];
    if (r && r.type === "text") {
      const a = t.children;
      let s = -1, l;
      for (; ++s < a.length; ) {
        const c = a[s];
        if (c.type === "paragraph") {
          l = c;
          break;
        }
      }
      l === n && (r.value = r.value.slice(1), r.value.length === 0 ? n.children.shift() : n.position && r.position && typeof r.position.start.offset == "number" && (r.position.start.column++, r.position.start.offset++, n.position.start = Object.assign({}, r.position.start)));
    }
  }
  this.exit(e);
}
function zze(e, t, n, r) {
  const a = e.children[0], s = typeof e.checked == "boolean" && a && a.type === "paragraph", l = "[" + (e.checked ? "x" : " ") + "] ", c = n.createTracker(r);
  s && c.move(l);
  let d = tK.listItem(e, t, n, {
    ...r,
    ...c.current()
  });
  return s && (d = d.replace(/^(?:[*+-]|\d+\.)([\r\n]| {1,3})/, p)), d;
  function p(m) {
    return m + l;
  }
}
function Fze() {
  return [
    yIe(),
    zIe(),
    VIe(),
    Nze(),
    Tze()
  ];
}
function Bze(e) {
  return {
    extensions: [
      bIe(),
      FIe(e),
      HIe(),
      $ze(e),
      Lze()
    ]
  };
}
const Uze = {
  tokenize: Kze,
  partial: !0
}, nK = {
  tokenize: Xze,
  partial: !0
}, rK = {
  tokenize: Yze,
  partial: !0
}, oK = {
  tokenize: Qze,
  partial: !0
}, Vze = {
  tokenize: Jze,
  partial: !0
}, aK = {
  name: "wwwAutolink",
  tokenize: Wze,
  previous: sK
}, iK = {
  name: "protocolAutolink",
  tokenize: Gze,
  previous: lK
}, Tc = {
  name: "emailAutolink",
  tokenize: qze,
  previous: uK
}, Il = {};
function Hze() {
  return {
    text: Il
  };
}
let Wp = 48;
for (; Wp < 123; )
  Il[Wp] = Tc, Wp++, Wp === 58 ? Wp = 65 : Wp === 91 && (Wp = 97);
Il[43] = Tc;
Il[45] = Tc;
Il[46] = Tc;
Il[95] = Tc;
Il[72] = [Tc, iK];
Il[104] = [Tc, iK];
Il[87] = [Tc, aK];
Il[119] = [Tc, aK];
function qze(e, t, n) {
  const r = this;
  let a, s;
  return l;
  function l(h) {
    return !A3(h) || !uK.call(r, r.previous) || uj(r.events) ? n(h) : (e.enter("literalAutolink"), e.enter("literalAutolinkEmail"), c(h));
  }
  function c(h) {
    return A3(h) ? (e.consume(h), c) : h === 64 ? (e.consume(h), d) : n(h);
  }
  function d(h) {
    return h === 46 ? e.check(Vze, m, p)(h) : h === 45 || h === 95 || Wo(h) ? (s = !0, e.consume(h), d) : m(h);
  }
  function p(h) {
    return e.consume(h), a = !0, d;
  }
  function m(h) {
    return s && a && ba(r.previous) ? (e.exit("literalAutolinkEmail"), e.exit("literalAutolink"), t(h)) : n(h);
  }
}
function Wze(e, t, n) {
  const r = this;
  return a;
  function a(l) {
    return l !== 87 && l !== 119 || !sK.call(r, r.previous) || uj(r.events) ? n(l) : (e.enter("literalAutolink"), e.enter("literalAutolinkWww"), e.check(Uze, e.attempt(nK, e.attempt(rK, s), n), n)(l));
  }
  function s(l) {
    return e.exit("literalAutolinkWww"), e.exit("literalAutolink"), t(l);
  }
}
function Gze(e, t, n) {
  const r = this;
  let a = "", s = !1;
  return l;
  function l(h) {
    return (h === 72 || h === 104) && lK.call(r, r.previous) && !uj(r.events) ? (e.enter("literalAutolink"), e.enter("literalAutolinkHttp"), a += String.fromCodePoint(h), e.consume(h), c) : n(h);
  }
  function c(h) {
    if (ba(h) && a.length < 5)
      return a += String.fromCodePoint(h), e.consume(h), c;
    if (h === 58) {
      const v = a.toLowerCase();
      if (v === "http" || v === "https")
        return e.consume(h), d;
    }
    return n(h);
  }
  function d(h) {
    return h === 47 ? (e.consume(h), s ? p : (s = !0, d)) : n(h);
  }
  function p(h) {
    return h === null || F_(h) || qn(h) || wm(h) || RE(h) ? n(h) : e.attempt(nK, e.attempt(rK, m), n)(h);
  }
  function m(h) {
    return e.exit("literalAutolinkHttp"), e.exit("literalAutolink"), t(h);
  }
}
function Kze(e, t, n) {
  let r = 0;
  return a;
  function a(l) {
    return (l === 87 || l === 119) && r < 3 ? (r++, e.consume(l), a) : l === 46 && r === 3 ? (e.consume(l), s) : n(l);
  }
  function s(l) {
    return l === null ? n(l) : t(l);
  }
}
function Xze(e, t, n) {
  let r, a, s;
  return l;
  function l(p) {
    return p === 46 || p === 95 ? e.check(oK, d, c)(p) : p === null || qn(p) || wm(p) || p !== 45 && RE(p) ? d(p) : (s = !0, e.consume(p), l);
  }
  function c(p) {
    return p === 95 ? r = !0 : (a = r, r = void 0), e.consume(p), l;
  }
  function d(p) {
    return a || r || !s ? n(p) : t(p);
  }
}
function Yze(e, t) {
  let n = 0, r = 0;
  return a;
  function a(l) {
    return l === 40 ? (n++, e.consume(l), a) : l === 41 && r < n ? s(l) : l === 33 || l === 34 || l === 38 || l === 39 || l === 41 || l === 42 || l === 44 || l === 46 || l === 58 || l === 59 || l === 60 || l === 63 || l === 93 || l === 95 || l === 126 ? e.check(oK, t, s)(l) : l === null || qn(l) || wm(l) ? t(l) : (e.consume(l), a);
  }
  function s(l) {
    return l === 41 && r++, e.consume(l), a;
  }
}
function Qze(e, t, n) {
  return r;
  function r(c) {
    return c === 33 || c === 34 || c === 39 || c === 41 || c === 42 || c === 44 || c === 46 || c === 58 || c === 59 || c === 63 || c === 95 || c === 126 ? (e.consume(c), r) : c === 38 ? (e.consume(c), s) : c === 93 ? (e.consume(c), a) : (
      // `<` is an end.
      c === 60 || // So is whitespace.
      c === null || qn(c) || wm(c) ? t(c) : n(c)
    );
  }
  function a(c) {
    return c === null || c === 40 || c === 91 || qn(c) || wm(c) ? t(c) : r(c);
  }
  function s(c) {
    return ba(c) ? l(c) : n(c);
  }
  function l(c) {
    return c === 59 ? (e.consume(c), r) : ba(c) ? (e.consume(c), l) : n(c);
  }
}
function Jze(e, t, n) {
  return r;
  function r(s) {
    return e.consume(s), a;
  }
  function a(s) {
    return Wo(s) ? n(s) : t(s);
  }
}
function sK(e) {
  return e === null || e === 40 || e === 42 || e === 95 || e === 91 || e === 93 || e === 126 || qn(e);
}
function lK(e) {
  return !ba(e);
}
function uK(e) {
  return !(e === 47 || A3(e));
}
function A3(e) {
  return e === 43 || e === 45 || e === 46 || e === 95 || Wo(e);
}
function uj(e) {
  let t = e.length, n = !1;
  for (; t--; ) {
    const r = e[t][1];
    if ((r.type === "labelLink" || r.type === "labelImage") && !r._balanced) {
      n = !0;
      break;
    }
    if (r._gfmAutolinkLiteralWalkedInto) {
      n = !1;
      break;
    }
  }
  return e.length > 0 && !n && (e[e.length - 1][1]._gfmAutolinkLiteralWalkedInto = !0), n;
}
const Zze = {
  tokenize: s1e,
  partial: !0
};
function e1e() {
  return {
    document: {
      91: {
        name: "gfmFootnoteDefinition",
        tokenize: o1e,
        continuation: {
          tokenize: a1e
        },
        exit: i1e
      }
    },
    text: {
      91: {
        name: "gfmFootnoteCall",
        tokenize: r1e
      },
      93: {
        name: "gfmPotentialFootnoteCall",
        add: "after",
        tokenize: t1e,
        resolveTo: n1e
      }
    }
  };
}
function t1e(e, t, n) {
  const r = this;
  let a = r.events.length;
  const s = r.parser.gfmFootnotes || (r.parser.gfmFootnotes = []);
  let l;
  for (; a--; ) {
    const d = r.events[a][1];
    if (d.type === "labelImage") {
      l = d;
      break;
    }
    if (d.type === "gfmFootnoteCall" || d.type === "labelLink" || d.type === "label" || d.type === "image" || d.type === "link")
      break;
  }
  return c;
  function c(d) {
    if (!l || !l._balanced)
      return n(d);
    const p = Is(r.sliceSerialize({
      start: l.end,
      end: r.now()
    }));
    return p.codePointAt(0) !== 94 || !s.includes(p.slice(1)) ? n(d) : (e.enter("gfmFootnoteCallLabelMarker"), e.consume(d), e.exit("gfmFootnoteCallLabelMarker"), t(d));
  }
}
function n1e(e, t) {
  let n = e.length;
  for (; n--; )
    if (e[n][1].type === "labelImage" && e[n][0] === "enter") {
      e[n][1];
      break;
    }
  e[n + 1][1].type = "data", e[n + 3][1].type = "gfmFootnoteCallLabelMarker";
  const r = {
    type: "gfmFootnoteCall",
    start: Object.assign({}, e[n + 3][1].start),
    end: Object.assign({}, e[e.length - 1][1].end)
  }, a = {
    type: "gfmFootnoteCallMarker",
    start: Object.assign({}, e[n + 3][1].end),
    end: Object.assign({}, e[n + 3][1].end)
  };
  a.end.column++, a.end.offset++, a.end._bufferIndex++;
  const s = {
    type: "gfmFootnoteCallString",
    start: Object.assign({}, a.end),
    end: Object.assign({}, e[e.length - 1][1].start)
  }, l = {
    type: "chunkString",
    contentType: "string",
    start: Object.assign({}, s.start),
    end: Object.assign({}, s.end)
  }, c = [
    // Take the `labelImageMarker` (now `data`, the `!`)
    e[n + 1],
    e[n + 2],
    ["enter", r, t],
    // The `[`
    e[n + 3],
    e[n + 4],
    // The `^`.
    ["enter", a, t],
    ["exit", a, t],
    // Everything in between.
    ["enter", s, t],
    ["enter", l, t],
    ["exit", l, t],
    ["exit", s, t],
    // The ending (`]`, properly parsed and labelled).
    e[e.length - 2],
    e[e.length - 1],
    ["exit", r, t]
  ];
  return e.splice(n, e.length - n + 1, ...c), e;
}
function r1e(e, t, n) {
  const r = this, a = r.parser.gfmFootnotes || (r.parser.gfmFootnotes = []);
  let s = 0, l;
  return c;
  function c(h) {
    return e.enter("gfmFootnoteCall"), e.enter("gfmFootnoteCallLabelMarker"), e.consume(h), e.exit("gfmFootnoteCallLabelMarker"), d;
  }
  function d(h) {
    return h !== 94 ? n(h) : (e.enter("gfmFootnoteCallMarker"), e.consume(h), e.exit("gfmFootnoteCallMarker"), e.enter("gfmFootnoteCallString"), e.enter("chunkString").contentType = "string", p);
  }
  function p(h) {
    if (
      // Too long.
      s > 999 || // Closing brace with nothing.
      h === 93 && !l || // Space or tab is not supported by GFM for some reason.
      // `\n` and `[` not being supported makes sense.
      h === null || h === 91 || qn(h)
    )
      return n(h);
    if (h === 93) {
      e.exit("chunkString");
      const v = e.exit("gfmFootnoteCallString");
      return a.includes(Is(r.sliceSerialize(v))) ? (e.enter("gfmFootnoteCallLabelMarker"), e.consume(h), e.exit("gfmFootnoteCallLabelMarker"), e.exit("gfmFootnoteCall"), t) : n(h);
    }
    return qn(h) || (l = !0), s++, e.consume(h), h === 92 ? m : p;
  }
  function m(h) {
    return h === 91 || h === 92 || h === 93 ? (e.consume(h), s++, p) : p(h);
  }
}
function o1e(e, t, n) {
  const r = this, a = r.parser.gfmFootnotes || (r.parser.gfmFootnotes = []);
  let s, l = 0, c;
  return d;
  function d(w) {
    return e.enter("gfmFootnoteDefinition")._container = !0, e.enter("gfmFootnoteDefinitionLabel"), e.enter("gfmFootnoteDefinitionLabelMarker"), e.consume(w), e.exit("gfmFootnoteDefinitionLabelMarker"), p;
  }
  function p(w) {
    return w === 94 ? (e.enter("gfmFootnoteDefinitionMarker"), e.consume(w), e.exit("gfmFootnoteDefinitionMarker"), e.enter("gfmFootnoteDefinitionLabelString"), e.enter("chunkString").contentType = "string", m) : n(w);
  }
  function m(w) {
    if (
      // Too long.
      l > 999 || // Closing brace with nothing.
      w === 93 && !c || // Space or tab is not supported by GFM for some reason.
      // `\n` and `[` not being supported makes sense.
      w === null || w === 91 || qn(w)
    )
      return n(w);
    if (w === 93) {
      e.exit("chunkString");
      const x = e.exit("gfmFootnoteDefinitionLabelString");
      return s = Is(r.sliceSerialize(x)), e.enter("gfmFootnoteDefinitionLabelMarker"), e.consume(w), e.exit("gfmFootnoteDefinitionLabelMarker"), e.exit("gfmFootnoteDefinitionLabel"), v;
    }
    return qn(w) || (c = !0), l++, e.consume(w), w === 92 ? h : m;
  }
  function h(w) {
    return w === 91 || w === 92 || w === 93 ? (e.consume(w), l++, m) : m(w);
  }
  function v(w) {
    return w === 58 ? (e.enter("definitionMarker"), e.consume(w), e.exit("definitionMarker"), a.includes(s) || a.push(s), ln(e, y, "gfmFootnoteDefinitionWhitespace")) : n(w);
  }
  function y(w) {
    return t(w);
  }
}
function a1e(e, t, n) {
  return e.check(zS, t, e.attempt(Zze, t, n));
}
function i1e(e) {
  e.exit("gfmFootnoteDefinition");
}
function s1e(e, t, n) {
  const r = this;
  return ln(e, a, "gfmFootnoteDefinitionIndent", 5);
  function a(s) {
    const l = r.events[r.events.length - 1];
    return l && l[1].type === "gfmFootnoteDefinitionIndent" && l[2].sliceSerialize(l[1], !0).length === 4 ? t(s) : n(s);
  }
}
function l1e(e) {
  let t = (e || {}).singleTilde;
  const n = {
    name: "strikethrough",
    tokenize: a,
    resolveAll: r
  };
  return t == null && (t = !0), {
    text: {
      126: n
    },
    insideSpan: {
      null: [n]
    },
    attentionMarkers: {
      null: [126]
    }
  };
  function r(s, l) {
    let c = -1;
    for (; ++c < s.length; )
      if (s[c][0] === "enter" && s[c][1].type === "strikethroughSequenceTemporary" && s[c][1]._close) {
        let d = c;
        for (; d--; )
          if (s[d][0] === "exit" && s[d][1].type === "strikethroughSequenceTemporary" && s[d][1]._open && // If the sizes are the same:
          s[c][1].end.offset - s[c][1].start.offset === s[d][1].end.offset - s[d][1].start.offset) {
            s[c][1].type = "strikethroughSequence", s[d][1].type = "strikethroughSequence";
            const p = {
              type: "strikethrough",
              start: Object.assign({}, s[d][1].start),
              end: Object.assign({}, s[c][1].end)
            }, m = {
              type: "strikethroughText",
              start: Object.assign({}, s[d][1].end),
              end: Object.assign({}, s[c][1].start)
            }, h = [["enter", p, l], ["enter", s[d][1], l], ["exit", s[d][1], l], ["enter", m, l]], v = l.parser.constructs.insideSpan.null;
            v && bi(h, h.length, 0, AE(v, s.slice(d + 1, c), l)), bi(h, h.length, 0, [["exit", m, l], ["enter", s[c][1], l], ["exit", s[c][1], l], ["exit", p, l]]), bi(s, d - 1, c - d + 3, h), c = d + h.length - 2;
            break;
          }
      }
    for (c = -1; ++c < s.length; )
      s[c][1].type === "strikethroughSequenceTemporary" && (s[c][1].type = "data");
    return s;
  }
  function a(s, l, c) {
    const d = this.previous, p = this.events;
    let m = 0;
    return h;
    function h(y) {
      return d === 126 && p[p.length - 1][1].type !== "characterEscape" ? c(y) : (s.enter("strikethroughSequenceTemporary"), v(y));
    }
    function v(y) {
      const w = Qh(d);
      if (y === 126)
        return m > 1 ? c(y) : (s.consume(y), m++, v);
      if (m < 2 && !t) return c(y);
      const x = s.exit("strikethroughSequenceTemporary"), b = Qh(y);
      return x._open = !b || b === 2 && !!w, x._close = !w || w === 2 && !!b, l(y);
    }
  }
}
class u1e {
  /**
   * Create a new edit map.
   */
  constructor() {
    this.map = [];
  }
  /**
   * Create an edit: a remove and/or add at a certain place.
   *
   * @param {number} index
   * @param {number} remove
   * @param {Array<Event>} add
   * @returns {undefined}
   */
  add(t, n, r) {
    c1e(this, t, n, r);
  }
  // To do: add this when moving to `micromark`.
  // /**
  //  * Create an edit: but insert `add` before existing additions.
  //  *
  //  * @param {number} index
  //  * @param {number} remove
  //  * @param {Array<Event>} add
  //  * @returns {undefined}
  //  */
  // addBefore(index, remove, add) {
  //   addImplementation(this, index, remove, add, true)
  // }
  /**
   * Done, change the events.
   *
   * @param {Array<Event>} events
   * @returns {undefined}
   */
  consume(t) {
    if (this.map.sort(function(s, l) {
      return s[0] - l[0];
    }), this.map.length === 0)
      return;
    let n = this.map.length;
    const r = [];
    for (; n > 0; )
      n -= 1, r.push(t.slice(this.map[n][0] + this.map[n][1]), this.map[n][2]), t.length = this.map[n][0];
    r.push(t.slice()), t.length = 0;
    let a = r.pop();
    for (; a; ) {
      for (const s of a)
        t.push(s);
      a = r.pop();
    }
    this.map.length = 0;
  }
}
function c1e(e, t, n, r) {
  let a = 0;
  if (!(n === 0 && r.length === 0)) {
    for (; a < e.map.length; ) {
      if (e.map[a][0] === t) {
        e.map[a][1] += n, e.map[a][2].push(...r);
        return;
      }
      a += 1;
    }
    e.map.push([t, n, r]);
  }
}
function d1e(e, t) {
  let n = !1;
  const r = [];
  for (; t < e.length; ) {
    const a = e[t];
    if (n) {
      if (a[0] === "enter")
        a[1].type === "tableContent" && r.push(e[t + 1][1].type === "tableDelimiterMarker" ? "left" : "none");
      else if (a[1].type === "tableContent") {
        if (e[t - 1][1].type === "tableDelimiterMarker") {
          const s = r.length - 1;
          r[s] = r[s] === "left" ? "center" : "right";
        }
      } else if (a[1].type === "tableDelimiterRow")
        break;
    } else a[0] === "enter" && a[1].type === "tableDelimiterRow" && (n = !0);
    t += 1;
  }
  return r;
}
function f1e() {
  return {
    flow: {
      null: {
        name: "table",
        tokenize: p1e,
        resolveAll: m1e
      }
    }
  };
}
function p1e(e, t, n) {
  const r = this;
  let a = 0, s = 0, l;
  return c;
  function c(z) {
    let B = r.events.length - 1;
    for (; B > -1; ) {
      const I = r.events[B][1].type;
      if (I === "lineEnding" || // Note: markdown-rs uses `whitespace` instead of `linePrefix`
      I === "linePrefix") B--;
      else break;
    }
    const P = B > -1 ? r.events[B][1].type : null, W = P === "tableHead" || P === "tableRow" ? R : d;
    return W === R && r.parser.lazy[r.now().line] ? n(z) : W(z);
  }
  function d(z) {
    return e.enter("tableHead"), e.enter("tableRow"), p(z);
  }
  function p(z) {
    return z === 124 || (l = !0, s += 1), m(z);
  }
  function m(z) {
    return z === null ? n(z) : mt(z) ? s > 1 ? (s = 0, r.interrupt = !0, e.exit("tableRow"), e.enter("lineEnding"), e.consume(z), e.exit("lineEnding"), y) : n(z) : Jt(z) ? ln(e, m, "whitespace")(z) : (s += 1, l && (l = !1, a += 1), z === 124 ? (e.enter("tableCellDivider"), e.consume(z), e.exit("tableCellDivider"), l = !0, m) : (e.enter("data"), h(z)));
  }
  function h(z) {
    return z === null || z === 124 || qn(z) ? (e.exit("data"), m(z)) : (e.consume(z), z === 92 ? v : h);
  }
  function v(z) {
    return z === 92 || z === 124 ? (e.consume(z), h) : h(z);
  }
  function y(z) {
    return r.interrupt = !1, r.parser.lazy[r.now().line] ? n(z) : (e.enter("tableDelimiterRow"), l = !1, Jt(z) ? ln(e, w, "linePrefix", r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(z) : w(z));
  }
  function w(z) {
    return z === 45 || z === 58 ? b(z) : z === 124 ? (l = !0, e.enter("tableCellDivider"), e.consume(z), e.exit("tableCellDivider"), x) : N(z);
  }
  function x(z) {
    return Jt(z) ? ln(e, b, "whitespace")(z) : b(z);
  }
  function b(z) {
    return z === 58 ? (s += 1, l = !0, e.enter("tableDelimiterMarker"), e.consume(z), e.exit("tableDelimiterMarker"), k) : z === 45 ? (s += 1, k(z)) : z === null || mt(z) ? O(z) : N(z);
  }
  function k(z) {
    return z === 45 ? (e.enter("tableDelimiterFiller"), C(z)) : N(z);
  }
  function C(z) {
    return z === 45 ? (e.consume(z), C) : z === 58 ? (l = !0, e.exit("tableDelimiterFiller"), e.enter("tableDelimiterMarker"), e.consume(z), e.exit("tableDelimiterMarker"), _) : (e.exit("tableDelimiterFiller"), _(z));
  }
  function _(z) {
    return Jt(z) ? ln(e, O, "whitespace")(z) : O(z);
  }
  function O(z) {
    return z === 124 ? w(z) : z === null || mt(z) ? !l || a !== s ? N(z) : (e.exit("tableDelimiterRow"), e.exit("tableHead"), t(z)) : N(z);
  }
  function N(z) {
    return n(z);
  }
  function R(z) {
    return e.enter("tableRow"), j(z);
  }
  function j(z) {
    return z === 124 ? (e.enter("tableCellDivider"), e.consume(z), e.exit("tableCellDivider"), j) : z === null || mt(z) ? (e.exit("tableRow"), t(z)) : Jt(z) ? ln(e, j, "whitespace")(z) : (e.enter("data"), D(z));
  }
  function D(z) {
    return z === null || z === 124 || qn(z) ? (e.exit("data"), j(z)) : (e.consume(z), z === 92 ? $ : D);
  }
  function $(z) {
    return z === 92 || z === 124 ? (e.consume(z), D) : D(z);
  }
}
function m1e(e, t) {
  let n = -1, r = !0, a = 0, s = [0, 0, 0, 0], l = [0, 0, 0, 0], c = !1, d = 0, p, m, h;
  const v = new u1e();
  for (; ++n < e.length; ) {
    const y = e[n], w = y[1];
    y[0] === "enter" ? w.type === "tableHead" ? (c = !1, d !== 0 && (a1(v, t, d, p, m), m = void 0, d = 0), p = {
      type: "table",
      start: Object.assign({}, w.start),
      // Note: correct end is set later.
      end: Object.assign({}, w.end)
    }, v.add(n, 0, [["enter", p, t]])) : w.type === "tableRow" || w.type === "tableDelimiterRow" ? (r = !0, h = void 0, s = [0, 0, 0, 0], l = [0, n + 1, 0, 0], c && (c = !1, m = {
      type: "tableBody",
      start: Object.assign({}, w.start),
      // Note: correct end is set later.
      end: Object.assign({}, w.end)
    }, v.add(n, 0, [["enter", m, t]])), a = w.type === "tableDelimiterRow" ? 2 : m ? 3 : 1) : a && (w.type === "data" || w.type === "tableDelimiterMarker" || w.type === "tableDelimiterFiller") ? (r = !1, l[2] === 0 && (s[1] !== 0 && (l[0] = l[1], h = m0(v, t, s, a, void 0, h), s = [0, 0, 0, 0]), l[2] = n)) : w.type === "tableCellDivider" && (r ? r = !1 : (s[1] !== 0 && (l[0] = l[1], h = m0(v, t, s, a, void 0, h)), s = l, l = [s[1], n, 0, 0])) : w.type === "tableHead" ? (c = !0, d = n) : w.type === "tableRow" || w.type === "tableDelimiterRow" ? (d = n, s[1] !== 0 ? (l[0] = l[1], h = m0(v, t, s, a, n, h)) : l[1] !== 0 && (h = m0(v, t, l, a, n, h)), a = 0) : a && (w.type === "data" || w.type === "tableDelimiterMarker" || w.type === "tableDelimiterFiller") && (l[3] = n);
  }
  for (d !== 0 && a1(v, t, d, p, m), v.consume(t.events), n = -1; ++n < t.events.length; ) {
    const y = t.events[n];
    y[0] === "enter" && y[1].type === "table" && (y[1]._align = d1e(t.events, n));
  }
  return e;
}
function m0(e, t, n, r, a, s) {
  const l = r === 1 ? "tableHeader" : r === 2 ? "tableDelimiter" : "tableData", c = "tableContent";
  n[0] !== 0 && (s.end = Object.assign({}, lh(t.events, n[0])), e.add(n[0], 0, [["exit", s, t]]));
  const d = lh(t.events, n[1]);
  if (s = {
    type: l,
    start: Object.assign({}, d),
    // Note: correct end is set later.
    end: Object.assign({}, d)
  }, e.add(n[1], 0, [["enter", s, t]]), n[2] !== 0) {
    const p = lh(t.events, n[2]), m = lh(t.events, n[3]), h = {
      type: c,
      start: Object.assign({}, p),
      end: Object.assign({}, m)
    };
    if (e.add(n[2], 0, [["enter", h, t]]), r !== 2) {
      const v = t.events[n[2]], y = t.events[n[3]];
      if (v[1].end = Object.assign({}, y[1].end), v[1].type = "chunkText", v[1].contentType = "text", n[3] > n[2] + 1) {
        const w = n[2] + 1, x = n[3] - n[2] - 1;
        e.add(w, x, []);
      }
    }
    e.add(n[3] + 1, 0, [["exit", h, t]]);
  }
  return a !== void 0 && (s.end = Object.assign({}, lh(t.events, a)), e.add(a, 0, [["exit", s, t]]), s = void 0), s;
}
function a1(e, t, n, r, a) {
  const s = [], l = lh(t.events, n);
  a && (a.end = Object.assign({}, l), s.push(["exit", a, t])), r.end = Object.assign({}, l), s.push(["exit", r, t]), e.add(n + 1, 0, s);
}
function lh(e, t) {
  const n = e[t], r = n[0] === "enter" ? "start" : "end";
  return n[1][r];
}
const h1e = {
  name: "tasklistCheck",
  tokenize: v1e
};
function g1e() {
  return {
    text: {
      91: h1e
    }
  };
}
function v1e(e, t, n) {
  const r = this;
  return a;
  function a(d) {
    return (
      // Exit if theres stuff before.
      r.previous !== null || // Exit if not in the first content that is the first child of a list
      // item.
      !r._gfmTasklistFirstContentOfListItem ? n(d) : (e.enter("taskListCheck"), e.enter("taskListCheckMarker"), e.consume(d), e.exit("taskListCheckMarker"), s)
    );
  }
  function s(d) {
    return qn(d) ? (e.enter("taskListCheckValueUnchecked"), e.consume(d), e.exit("taskListCheckValueUnchecked"), l) : d === 88 || d === 120 ? (e.enter("taskListCheckValueChecked"), e.consume(d), e.exit("taskListCheckValueChecked"), l) : n(d);
  }
  function l(d) {
    return d === 93 ? (e.enter("taskListCheckMarker"), e.consume(d), e.exit("taskListCheckMarker"), e.exit("taskListCheck"), c) : n(d);
  }
  function c(d) {
    return mt(d) ? t(d) : Jt(d) ? e.check({
      tokenize: y1e
    }, t, n)(d) : n(d);
  }
}
function y1e(e, t, n) {
  return ln(e, r, "whitespace");
  function r(a) {
    return a === null ? n(a) : t(a);
  }
}
function b1e(e) {
  return wG([
    Hze(),
    e1e(),
    l1e(e),
    f1e(),
    g1e()
  ]);
}
const w1e = {};
function x1e(e) {
  const t = (
    /** @type {Processor<Root>} */
    this
  ), n = e || w1e, r = t.data(), a = r.micromarkExtensions || (r.micromarkExtensions = []), s = r.fromMarkdownExtensions || (r.fromMarkdownExtensions = []), l = r.toMarkdownExtensions || (r.toMarkdownExtensions = []);
  a.push(b1e(n)), s.push(Fze()), l.push(Bze(n));
}
const cj = ({
  availableModule: e
}) => {
  const [t, n] = M.useState(!1), r = () => n(!t), a = 150, s = e.description.length > a ? e.description.substring(0, a) + "..." : e.description;
  return /* @__PURE__ */ E.jsxs("div", { className: "module-description", children: [
    /* @__PURE__ */ E.jsx(lIe, { remarkPlugins: [x1e], children: t ? e.description.replace(/\\n/g, `
`) : s.replace(/\\n/g, `
`) }),
    e.description.length > a && /* @__PURE__ */ E.jsx("button", { onClick: r, className: "toggle-description", children: t ? "Show less" : "Show more" })
  ] });
}, i1 = [
  ">=",
  "==",
  "<=",
  "<",
  ">"
], $E = ">=", dj = ({
  availableModule: e,
  on_change: t
}) => {
  const [n, r] = M.useState(
    e.version || "latest"
  ), [a, s] = M.useState($E), l = (d) => {
    const p = d.target.value;
    r(p), t(p !== "latest" ? a + p : p);
  }, c = (d) => {
    d.target.value !== a && i1.includes(d.target.value) && (s(d.target.value), n !== "latest" && t(d.target.value + n));
  };
  return e.releases && !e.releases.includes(n) && e.releases.unshift(n), /* @__PURE__ */ E.jsxs(E.Fragment, { children: [
    /* @__PURE__ */ E.jsx("select", { value: a, onChange: c, children: i1.map((d) => /* @__PURE__ */ E.jsx("option", { value: d, children: d }, d)) }),
    /* @__PURE__ */ E.jsx("select", { onChange: l, value: n, children: e.releases && e.releases.map((d) => /* @__PURE__ */ E.jsx("option", { value: d, children: d }, d)) })
  ] });
}, S1e = ({
  availableModule: e,
  on_remove: t,
  on_update: n
}) => {
  const [r, a] = M.useState(
    $E + e.version || "latest"
  );
  return /* @__PURE__ */ E.jsxs("div", { className: "addable-module", children: [
    /* @__PURE__ */ E.jsx("div", { className: "module-name", children: e.name + (e.version ? ` (${e.version})` : "") }),
    /* @__PURE__ */ E.jsx(q4, { availableModule: e }),
    /* @__PURE__ */ E.jsx(cj, { availableModule: e }),
    /* @__PURE__ */ E.jsxs("div", { children: [
      /* @__PURE__ */ E.jsx(
        dj,
        {
          availableModule: e,
          on_change: a
        }
      ),
      /* @__PURE__ */ E.jsx(
        "button",
        {
          className: "update-button",
          disabled: r === e.version,
          onClick: () => {
            n(e, r);
          },
          children: "Update"
        }
      ),
      /* @__PURE__ */ E.jsx(
        "button",
        {
          className: "remove-button",
          onClick: () => {
            t(e);
          },
          children: "Remove"
        }
      )
    ] })
  ] });
}, k1e = ({
  availableModule: e,
  on_add: t
}) => {
  const [n, r] = M.useState(
    $E + e.version || "latest"
  );
  return /* @__PURE__ */ E.jsxs("div", { className: "addable-module", children: [
    /* @__PURE__ */ E.jsx("div", { className: "module-name", children: e.name + (e.version ? ` (${e.version})` : "") }),
    /* @__PURE__ */ E.jsx(q4, { availableModule: e }),
    /* @__PURE__ */ E.jsx(cj, { availableModule: e }),
    /* @__PURE__ */ E.jsxs("div", { children: [
      /* @__PURE__ */ E.jsx(
        dj,
        {
          availableModule: e,
          on_change: r
        }
      ),
      /* @__PURE__ */ E.jsx(
        "button",
        {
          className: "add-button",
          onClick: () => {
            t(e, n);
          },
          children: "Add"
        }
      )
    ] })
  ] });
}, _1e = ({
  availableModule: e,
  on_add: t
}) => {
  const [n, r] = M.useState(
    $E + e.version || "latest"
  );
  return /* @__PURE__ */ E.jsxs("div", { className: "addable-module", children: [
    /* @__PURE__ */ E.jsx("div", { className: "module-name", children: e.name }),
    /* @__PURE__ */ E.jsx(q4, { availableModule: e }),
    /* @__PURE__ */ E.jsx(cj, { availableModule: e }),
    /* @__PURE__ */ E.jsxs("div", { children: [
      /* @__PURE__ */ E.jsx(
        dj,
        {
          availableModule: e,
          on_change: r
        }
      ),
      /* @__PURE__ */ E.jsx(
        "button",
        {
          className: "add-button",
          onClick: () => {
            t(e, n);
          },
          children: "Add"
        }
      )
    ] })
  ] });
}, E1e = ({
  ins: e
}) => {
  const [t, n] = M.useState(e.name), r = yn(), { lib: a } = xa(), s = () => {
    r.worker && a?.remove_external_worker(e.uuid, e.nodeclassid);
  }, l = () => {
    r.worker && (r.worker.update_external_worker(e.uuid, e.nodeclassid, {
      name: t
    }), e.name = t);
  };
  return /* @__PURE__ */ E.jsx(E.Fragment, { children: /* @__PURE__ */ E.jsx(
    Pl,
    {
      title: e.name,
      description: "Settings for " + e.name,
      trigger: /* @__PURE__ */ E.jsx("div", { children: "Settings" }),
      buttons: [
        {
          text: "Save",
          onClick: l,
          close: !0
        },
        {
          text: "Delete",
          onClick: s,
          close: !0
        }
      ],
      children: /* @__PURE__ */ E.jsxs("div", { children: [
        /* @__PURE__ */ E.jsxs("div", { children: [
          /* @__PURE__ */ E.jsx("label", { htmlFor: "name", children: "Name: " }),
          /* @__PURE__ */ E.jsx(
            "input",
            {
              type: "text",
              name: "name",
              value: t,
              onChange: (c) => n(c.target.value),
              className: "styledinput"
            }
          )
        ] }),
        a && /* @__PURE__ */ E.jsx(
          Kq,
          {
            getter: () => a.get_external_worker_config(e.uuid, e.nodeclassid),
            setter: async (c) => {
              if (r.worker)
                return await r.worker.update_external_worker(
                  e.uuid,
                  e.nodeclassid,
                  {
                    name: t,
                    config: c
                  }
                );
            },
            setter_calls_getter: !0
          }
        )
      ] })
    }
  ) });
}, C1e = ({
  ins: e,
  lib: t,
  filter: n = "",
  parentkey: r
}) => {
  const [a, s] = M.useState(!1), l = () => s(!a), c = t?.nodes?.filter(
    (d) => d.node_id.toLowerCase().includes(n.toLowerCase())
  );
  return /* @__PURE__ */ E.jsxs("div", { className: "shelfcontainer", children: [
    /* @__PURE__ */ E.jsxs(
      "div",
      {
        className: "shelftitle",
        onClick: l,
        style: { cursor: "pointer" },
        title: e.name,
        children: [
          /* @__PURE__ */ E.jsx("div", { className: "shelftitle_text", children: e.name }),
          /* @__PURE__ */ E.jsx("div", { className: "expandicon " + (a ? "open" : "close"), children: /* @__PURE__ */ E.jsx(sS, {}) })
        ]
      }
    ),
    /* @__PURE__ */ E.jsx("div", { className: "libnodecontainer " + (a ? "open" : "close"), children: /* @__PURE__ */ E.jsx("div", { className: "libnodecontainer_inner", children: a && /* @__PURE__ */ E.jsxs(E.Fragment, { children: [
      /* @__PURE__ */ E.jsx("div", { className: "libnodeentry", title: e.uuid, children: /* @__PURE__ */ E.jsx(E1e, { ins: e }) }),
      t && /* @__PURE__ */ E.jsxs(E.Fragment, { children: [
        c && /* @__PURE__ */ E.jsx(E.Fragment, { children: c.map((d) => /* @__PURE__ */ E.jsx(
          oG,
          {
            item: d
          },
          r + d.node_id
        )) }),
        t.subshelves.map((d) => /* @__PURE__ */ E.jsx(
          H4,
          {
            item: d,
            filter: n,
            parentkey: r + d.name
          },
          r + d.name
        ))
      ] })
    ] }) }) })
  ] });
}, O1e = ({
  item: e,
  mod: t,
  lib: n
}) => {
  const { lib: r } = xa(), [a, s] = M.useState(!1), l = () => s(!a), c = M.useCallback(() => {
    r?.add_external_worker({
      module: t,
      cls_module: e.module,
      cls_name: e.class_name
    });
  }, [r, t, e]), d = (m) => {
    m.detail === 2 && c();
  }, p = e.name || e.module + "." + e.class_name;
  return /* @__PURE__ */ E.jsxs("div", { className: "shelfcontainer", children: [
    /* @__PURE__ */ E.jsxs(
      "div",
      {
        className: "shelftitle",
        onClick: l,
        style: { cursor: "pointer" },
        title: p,
        children: [
          /* @__PURE__ */ E.jsx("div", { className: "shelftitle_text", children: p }),
          /* @__PURE__ */ E.jsx("div", { className: "expandicon " + (a ? "open" : "close"), children: /* @__PURE__ */ E.jsx(sS, {}) })
        ]
      }
    ),
    /* @__PURE__ */ E.jsx("div", { className: "libnodecontainer " + (a ? "open" : "close"), children: /* @__PURE__ */ E.jsx("div", { className: "libnodecontainer_inner", children: a && /* @__PURE__ */ E.jsxs(E.Fragment, { children: [
      /* @__PURE__ */ E.jsx(
        "div",
        {
          className: "libnodeentry",
          onClick: d,
          title: e.name,
          children: "New Instance"
        }
      ),
      e.instances.map((m) => /* @__PURE__ */ E.jsx(
        C1e,
        {
          ins: m,
          lib: n?.subshelves.find(
            (h) => h.name === m.uuid
          ),
          parentkey: m.uuid
        },
        m.uuid
      ))
    ] }) }) })
  ] });
}, M1e = ({
  externalworkermod: e,
  lib: t
}) => {
  const [n, r] = M.useState(!1), a = () => r(!n), s = n;
  return /* @__PURE__ */ E.jsxs("div", { className: "shelfcontainer", children: [
    /* @__PURE__ */ E.jsxs(
      "div",
      {
        className: "shelftitle",
        onClick: a,
        style: { cursor: "pointer" },
        title: e.module,
        children: [
          /* @__PURE__ */ E.jsx("div", { className: "shelftitle_text", children: e.module }),
          /* @__PURE__ */ E.jsx("div", { className: "expandicon " + (s ? "open" : "close"), children: /* @__PURE__ */ E.jsx(sS, {}) })
        ]
      }
    ),
    /* @__PURE__ */ E.jsx("div", { className: "libnodecontainer " + (s ? "open" : "close"), children: /* @__PURE__ */ E.jsx("div", { className: "libnodecontainer_inner", children: e.worker_classes.map((l) => /* @__PURE__ */ E.jsx(
      O1e,
      {
        item: l,
        mod: e.module,
        lib: t
      },
      l.module + l.class_name
    )) }) }),
    /* @__PURE__ */ E.jsx("hr", {})
  ] });
}, N1e = () => {
  const e = yn(), t = e.lib.libstate(), n = e.local_settings(
    (d) => d.view_settings.expand_lib
  ), r = (d) => {
    e.update_view_settings({ expand_lib: d });
  }, a = Mje("m"), [s, l] = M.useState(""), c = e.workerstate((d) => d.is_open);
  return /* @__PURE__ */ E.jsx(
    C4,
    {
      maxSize: a ? "100%" : "18.75rem",
      direction: a ? "down" : "right",
      containerClassName: "pos-left pos-top bg1 h-12",
      onExpandChange: r,
      expanded: n === void 0 ? !0 : n,
      collapseIcons: {
        up: r_,
        down: gx,
        left: hx,
        right: n_
      },
      expandIcons: {
        up: gx,
        down: r_,
        left: n_,
        right: hx
      },
      children: /* @__PURE__ */ E.jsxs("div", { className: "libcontainer", children: [
        /* @__PURE__ */ E.jsxs("div", { className: "library", children: [
          /* @__PURE__ */ E.jsx("div", { className: "libtitle", children: "Lib" }),
          /* @__PURE__ */ E.jsx("hr", { className: "hr_prominent" }),
          /* @__PURE__ */ E.jsx(YDe, { filter: s, setFilter: l }),
          /* @__PURE__ */ E.jsx("div", { className: "vscrollcontainer", children: t.lib.shelves.filter((d) => d.name !== "_external_worker").map((d) => /* @__PURE__ */ E.jsx(
            H4,
            {
              item: d,
              filter: s,
              parentkey: d.name
            },
            d.name
          )) }),
          /* @__PURE__ */ E.jsx("hr", {}),
          /* @__PURE__ */ E.jsx("div", { className: "libtitle", children: "External Worker" }),
          /* @__PURE__ */ E.jsx("hr", { className: "hr_prominent" }),
          /* @__PURE__ */ E.jsx("div", { className: "vscrollcontainer", children: t.external_worker?.map((d) => /* @__PURE__ */ E.jsx(
            M1e,
            {
              externalworkermod: d,
              lib: t.lib.shelves.find(
                (p) => p.name === "_external_worker"
              )
            },
            d.module
          )) }),
          /* @__PURE__ */ E.jsx("hr", {})
        ] }),
        c && /* @__PURE__ */ E.jsx("div", { className: "addlib", children: /* @__PURE__ */ E.jsx(QDe, { children: /* @__PURE__ */ E.jsx("button", { children: "Manage Libraries" }) }) })
      ] })
    }
  );
}, R1e = ({
  fnrf_zst: e,
  header: t,
  flow: n,
  library: r
}) => {
  const [a, s] = M.useState(
    e.options.worker || e.getWorkerManager().worker
  ), l = M.useRef(null);
  e.workermanager && (e.workermanager.on_setWorker = s), M.useEffect(() => {
    e.auto_progress();
  }, []), M.useEffect(() => {
    e.local_state.setState({ funcnodescontainerRef: l.current });
  }, [l]);
  const c = e.plugins();
  return /* @__PURE__ */ E.jsx(hje, { plugins: c, fnrf_zst: e, children: /* @__PURE__ */ E.jsx(xae, { children: /* @__PURE__ */ E.jsx(ZF.Provider, { value: e, children: /* @__PURE__ */ E.jsx(Xc, { asChild: !0, children: /* @__PURE__ */ E.jsx(uc, { asChild: !0, children: /* @__PURE__ */ E.jsx(
    eW,
    {
      style: {
        height: "100%",
        width: "100%",
        display: "flex",
        flexDirection: "column",
        flex: 1
      },
      children: /* @__PURE__ */ E.jsxs(
        "div",
        {
          ref: l,
          className: "funcnodesreactflowcontainer funcnodescontainer",
          children: [
            t.show && /* @__PURE__ */ E.jsx(XDe, { ...t }),
            /* @__PURE__ */ E.jsxs("div", { className: "funcnodesreactflowbody", children: [
              /* @__PURE__ */ E.jsx(OPe, { ...n }),
              a && r.show && /* @__PURE__ */ E.jsx(N1e, {}),
              a && n.showNodeSettings && /* @__PURE__ */ E.jsx(Pje, {})
            ] }),
            /* @__PURE__ */ E.jsxs("div", { className: "funcnodesflaotingmenu", children: [
              /* @__PURE__ */ E.jsx(uc.OutFullScreen, { children: n.allowExpand && /* @__PURE__ */ E.jsxs(Xc.Trigger, { children: [
                /* @__PURE__ */ E.jsx(Xc.Expanded, { children: /* @__PURE__ */ E.jsx(
                  dae,
                  {
                    size: "xl",
                    style: { padding: "4px" }
                  }
                ) }),
                /* @__PURE__ */ E.jsx(Xc.Collapsed, { children: /* @__PURE__ */ E.jsx(
                  fae,
                  {
                    size: "xl",
                    style: { padding: "4px" }
                  }
                ) })
              ] }) }),
              n.allowFullScreen && /* @__PURE__ */ E.jsxs(uc.Trigger, { children: [
                /* @__PURE__ */ E.jsx(uc.OutFullScreen, { children: /* @__PURE__ */ E.jsx(
                  JF,
                  {
                    size: "xl",
                    style: { padding: "4px" }
                  }
                ) }),
                /* @__PURE__ */ E.jsx(uc.InFullScreen, { children: /* @__PURE__ */ E.jsx(
                  cae,
                  {
                    size: "xl",
                    style: { padding: "4px" }
                  }
                ) })
              ] })
            ] })
          ]
        }
      )
    }
  ) }) }) }) }) });
};
class mg {
  constructor(t) {
    this.context = t;
  }
  get nodespaceManager() {
    return this.context.rf.getNodespaceManager();
  }
  get libManager() {
    return this.context.rf.getLibManager();
  }
  get workerManager() {
    return this.context.rf.getWorkerManager();
  }
  get stateManager() {
    return this.context.rf.getStateManager();
  }
  get pluginManager() {
    return this.context.rf.getPluginManager();
  }
  get reactFlowManager() {
    return this.context.rf.getReactFlowManager();
  }
}
const s1 = ({
  src_nid: e,
  src_ioid: t,
  trg_nid: n,
  trg_ioid: r
}) => [`${e}:${t}`, `${n}:${r}`].sort().join("--"), A1e = ({}) => {
  const e = /* @__PURE__ */ new Map();
  return {
    nodesstates: e,
    get_node: (t, n = !0) => {
      const r = e.get(t);
      if (!r && n) {
        const a = e.keys();
        throw new Error(
          `Node ${t} not found, available nodes: ${Array.from(a)}`
        );
      }
      return r;
    }
  };
};
class j1e extends mg {
  constructor(t) {
    super(t), this.on_node_action = (n) => {
      switch (n.type) {
        case "add":
          return this._add_node(n);
        case "update":
          return this._update_node(n);
        case "delete":
          return this._delete_node(n);
        case "error":
          return this._error_action(n);
        case "trigger":
          return this._trigger_action(n);
        default:
          this.context.rf.logger.error("Unknown node action", n);
          return;
      }
    }, this.on_edge_action = (n) => {
      const r = this.reactFlowManager.useReactFlowStore.getState();
      switch (n.type) {
        case "add":
          if (n.from_remote) {
            const a = r.getEdges(), s = s1(n);
            if (a.some((c) => c.id === s))
              return;
            const l = {
              id: s,
              source: n.src_nid,
              target: n.trg_nid,
              sourceHandle: n.src_ioid,
              targetHandle: n.trg_ioid,
              className: "funcnodes-edge animated",
              zIndex: 1003
              // just above elevated groups
            };
            this.context.rf.logger.info("Adding edge", l), r.update_edges([...a, l]), this.workerManager.worker?.api.node.get_remote_node_state(
              n.src_nid
            ), this.workerManager.worker?.api.node.get_remote_node_state(
              n.trg_nid
            );
          }
          break;
        case "delete":
          if (n.from_remote) {
            const a = r.getEdges(), s = s1(n);
            this.context.rf.logger.info("Deleting edge", s);
            const l = a.filter((c) => c.id !== s);
            r.update_edges(l), this.workerManager.worker?.api.node.get_remote_node_state(
              n.src_nid
            ), this.workerManager.worker?.api.node.get_remote_node_state(
              n.trg_nid
            );
          }
          break;
        default:
          this.context.rf.logger.error("Unknown edge action", n);
      }
    }, this.on_group_action = (n) => {
      switch (n.type) {
        case "set":
          return this._set_groups(n.groups);
        case "update":
          return this._update_group(n);
        default:
          this.context.rf.logger.error("Unknown group action", n);
      }
    }, this.clear_all = () => {
      this.context.rf.logger.debug("Clearing all nodespace"), this.workerManager.worker?.disconnect(), this.workerManager.set_worker(void 0), this.workerManager.workermanager?.setWorker(void 0), this.libManager.lib.libstate.getState().set({ lib: { shelves: [] }, external_worker: [] }), this.nodespace.nodesstates.clear(), this.reactFlowManager.useReactFlowStore.getState().update_nodes([]), this.reactFlowManager.useReactFlowStore.getState().update_edges([]), this.stateManager.auto_progress();
    }, this.center_node = (n) => {
      if (!this.reactFlowManager.rf_instance)
        return;
      n = Array.isArray(n) ? n : [n];
      const r = this.reactFlowManager.useReactFlowStore.getState().getNodes().filter((a) => n.includes(a.id));
      r.length > 0 && this.reactFlowManager.rf_instance?.fitView({ padding: 0.2, nodes: r });
    }, this.auto_resize_group = (n) => {
      const r = this.reactFlowManager.useReactFlowStore.getState(), a = r.getNode(n);
      if (a === void 0 || a.type !== "group")
        return;
      const s = a.data.group.node_ids.map((m) => r.getNode(m)).filter((m) => m !== void 0), l = a.data.group.child_groups.map((m) => r.getNode(m)).filter((m) => m !== void 0), c = [...s, ...l], d = this.reactFlowManager.rf_instance?.getNodesBounds(c);
      if (d === void 0)
        return;
      const p = {
        ...a,
        position: {
          x: d.x,
          y: d.y
        },
        height: d.height,
        width: d.width
      };
      p.data.group.position = [d.x, d.y], r.partial_update_nodes([p]);
    }, this.change_group_position = (n) => {
      if (n.position === void 0)
        return;
      const r = this.reactFlowManager.useReactFlowStore.getState(), a = r.getNode(n.id);
      if (a === void 0 || a.type !== "group")
        return;
      const s = [
        ...a.data.group.node_ids,
        ...a.data.group.child_groups
      ], l = this.reactFlowManager.rf_instance?.getNodesBounds(s);
      if (l === void 0)
        return;
      const c = n.position.x - l?.x, d = n.position.y - l?.y, p = [];
      for (const m of s) {
        const h = r.getNode(m);
        h !== void 0 && p.push({
          id: m,
          type: "position",
          position: {
            x: h.position.x + c,
            y: h.position.y + d
          }
        });
      }
      r.onNodesChange(p);
    }, this.change_fn_node_position = (n) => {
      n.position !== void 0 && this.on_node_action({
        type: "update",
        id: n.id,
        node: {
          properties: {
            "frontend:pos": [n.position.x, n.position.y]
          }
        },
        from_remote: !1
      });
    }, this.change_group_dimensions = (n) => {
      if (n.dimensions === void 0)
        return;
      const r = this.reactFlowManager.useReactFlowStore.getState().getNode(n.id);
      r !== void 0 && this.reactFlowManager.useReactFlowStore.getState().partial_update_nodes(yA([n], [r]));
    }, this.change_fn_node_dimensions = (n) => {
      n.dimensions !== void 0 && this.on_node_action({
        type: "update",
        id: n.id,
        node: {
          properties: {
            "frontend:size": [n.dimensions.width, n.dimensions.height]
          }
        },
        from_remote: !1
      });
    }, this._update_group = (n) => {
      if (n.from_remote) {
        const r = this.reactFlowManager.useReactFlowStore.getState(), a = r.getNode(n.id);
        if (a === void 0 || a.type !== "group")
          return;
        const { new_obj: s, change: l } = rd(a.data.group, n.group);
        l && (a.data.group = s), r.partial_update_nodes([a]);
      } else
        this.workerManager.worker && this.workerManager.worker.api.group.locally_update_group(n);
    }, this._set_groups = (n) => {
      const r = this.reactFlowManager.useReactFlowStore.getState(), { default_nodes: a } = A4(r.getNodes()), s = [...a], l = {};
      for (const d in n) {
        const p = n[d];
        for (const h of p.node_ids)
          l[h] = d;
        for (const h of p.child_groups)
          l[h] = d;
        p.position === void 0 && (p.position = [0, 0]);
        const m = {
          id: d,
          type: "group",
          data: { group: n[d], id: d },
          position: { x: p.position[0], y: p.position[1] },
          zIndex: 2
        };
        p.parent_group && (m.data.groupID = p.parent_group), s.push(m);
      }
      for (const d of s)
        d.id in l ? d.data.groupID = l[d.id] : d.data.groupID = void 0;
      const c = j4(s);
      r.update_nodes(c);
      for (const d of c.reverse())
        d.type === "group" && this.auto_resize_group(d.id);
    }, this._add_node = (n) => {
      this.context.rf.logger.info("add node", n);
      const r = this.reactFlowManager.useReactFlowStore.getState();
      if (n.from_remote) {
        let a = this.nodespace.get_node(n.node.id, !1);
        if (a)
          return;
        if (!a)
          try {
            a = bPe(n.node), this.nodespace.nodesstates.set(n.node.id, a);
          } catch (d) {
            this.context.rf.logger.error(`Failed to create node store ${d}`);
            return;
          }
        const s = a.getState();
        this.context.rf.logger.info("Add node", s.id, s.name);
        const l = CPe(a, this.context.rf), c = [...r.getNodes(), l];
        this.reactFlowManager.useReactFlowStore.getState().update_nodes(c);
        for (const d of l.io_order)
          this.workerManager.worker?.api.node.get_io_value({
            nid: l.id,
            ioid: d
          });
        return setTimeout(() => {
          this.workerManager.worker?.api.hooks.call_hooks("node_added", {
            node: s.id
          });
        }, 0), s;
      }
    }, this._update_node = (n) => {
      if (Object.keys(n.node).length === 0) {
        this.context.rf.logger.error(
          "Node update is empty",
          new Error(JSON.stringify(n))
        );
        return;
      }
      if (n.node.in_trigger && (n.node.error = void 0), n.from_remote) {
        const r = this.nodespace.get_node(n.id, !1);
        if (!r) {
          console.error("Node not found to update", n.id);
          return;
        }
        return r.update(n.node), r.getState();
      } else
        this.workerManager.worker && this.workerManager.worker.api.node.locally_update_node(n);
    }, this._sync_nodes = () => {
      const n = this.reactFlowManager.useReactFlowStore.getState().getNodes(), r = this.nodespace.nodesstates;
      for (const a of r.keys())
        n.some((s) => s.id === a) || r.delete(a);
    }, this._delete_node = (n) => {
      this.context.rf.logger.info("Deleting node", n.id), n.from_remote ? (this.reactFlowManager.useReactFlowStore.getState().onNodesChange([
        {
          type: "remove",
          id: n.id
        }
      ]), this._sync_nodes()) : this.workerManager.worker?.api.node.remove_node(n.id);
    }, this._error_action = (n) => (this.context.rf.logger.error("Error", new Error(JSON.stringify(n))), this.on_node_action({
      type: "update",
      id: n.id,
      node: {
        in_trigger: !1,
        error: n.error
      },
      from_remote: !0
    })), this._trigger_action = (n) => {
      if (n.from_remote)
        return this.on_node_action({
          type: "update",
          id: n.id,
          node: {
            in_trigger: !0,
            error: void 0
          },
          from_remote: !0
        });
      this.workerManager.worker?.api.node.trigger_node(n.id);
    }, this.nodespace = A1e({});
  }
  center_all() {
    this.reactFlowManager.rf_instance?.fitView({ padding: 0.2 });
  }
}
const P1e = () => ({
  libstate: ji((e, t) => ({
    lib: {
      shelves: []
    },
    external_worker: [],
    set: (n) => e((r) => ({ ...r, ...n })),
    get_lib: () => t().lib,
    get_external_worker: () => t().external_worker
  }))
});
class D1e extends mg {
  constructor(t) {
    super(t), this.lib = P1e();
  }
}
class $1e extends mg {
  constructor(t) {
    super(t), t.rf.logger.debug("Initializing worker manager handler"), this.workers = ji((n, r) => ({})), this.workerstate = ji((n, r) => ({
      is_open: !1
    }));
  }
  set_worker(t) {
    t !== this.worker && (this._unsubscribeFromWorker && (this._unsubscribeFromWorker(), this._unsubscribeFromWorker = void 0), t ? (this.context.rf.logger.debug("Setting worker in worker manager"), this._unsubscribeFromWorker = t.state.subscribe((n) => {
      this.workerstate.setState(n);
    }), this.workerstate.setState(t.state.getState())) : this.context.rf.logger.debug("Removing worker in worker manager"), this.worker = t, t?.set_zustand(this.context.rf));
  }
}
class T1e extends mg {
  constructor(t) {
    super(t), this.progress_state = ji((n, r) => ({
      message: "please select worker",
      status: "info",
      progress: 0,
      blocking: !1
    })), this.local_settings = ji(
      (n, r) => ({
        view_settings: {
          expand_node_props: !1,
          expand_lib: !1
        }
      })
    ), this.local_state = ji((n, r) => ({
      selected_nodes: [],
      selected_edges: [],
      selected_groups: [],
      funcnodescontainerRef: null
    }));
  }
  set_progress(t) {
    if (t.message === "")
      return this.auto_progress();
    const n = this.progress_state.getState(), { new_obj: r, change: a } = rd(n, t);
    a && this.progress_state.setState(r);
  }
  auto_progress() {
    const t = this.workerManager.workermanager, n = this.workerManager.worker;
    if (t !== void 0 && !t.open)
      return this.set_progress({
        progress: 0,
        message: "connecting to worker manager",
        status: "error",
        blocking: !1
      });
    if (n === void 0)
      return this.set_progress({
        progress: 0,
        message: "please select worker",
        status: "error",
        blocking: !1
      });
    if (!n.is_open)
      return this.set_progress({
        progress: 0,
        message: "connecting to worker",
        status: "info",
        blocking: !0
      });
    this.set_progress({
      progress: 1,
      message: "running",
      status: "info",
      blocking: !1
    });
  }
  update_view_settings(t) {
    bW(this.local_settings, { view_settings: t });
  }
}
const cK = "1.0.0", L1e = ["1"], I1e = (e) => {
  if (!e.v.toString().includes(".") || // old polugin version without "."
  !L1e.includes(e.v.toString().split(".")[0]))
    throw new Error(`Unsupported version: ${e.v}`);
  return { ...e, v: cK };
};
class z1e extends mg {
  constructor(t) {
    super(t), this.plugins = ji((n, r) => ({})), this.render_options = ji((n, r) => ({}));
  }
  add_plugin(t, n) {
    if (n !== void 0)
      try {
        const r = I1e(n);
        this.plugins.setState((a) => ({ ...a, [t]: r }));
      } catch (r) {
        r instanceof Error ? this.context.rf.logger.error(`Error loading plugin ${t}`, r) : this.context.rf.logger.error(
          `Error loading plugin ${t}`,
          new Error(String(r))
        ), this.stateManager.toaster?.error({
          title: "Error",
          description: `Error loading plugin ${t}: ${r instanceof Error ? r.message : String(r)}`,
          duration: 5e3
        });
      }
  }
  update_render_options(t) {
    bW(this.render_options, t);
  }
  async add_packed_plugin(t, n) {
    if (n.js)
      for (const r of n.js) {
        const a = document.createElement("script");
        a.text = atob(r), document.body.appendChild(a);
      }
    if (n.css)
      for (const r of n.css) {
        const a = document.createElement("style");
        a.innerHTML = atob(r), document.head.appendChild(a);
      }
    if (n.module !== void 0) {
      const r = atob(n.module);
      try {
        const a = await new Function(
          "React",
          "FuncNodesReactFlow",
          `
          return (async () => {
            ${r}
            return FuncNodesPlugin;
          })();
        `
        )(Gx, wK);
        this.add_plugin(t, a);
      } catch (a) {
        a instanceof Error ? this.context.rf.logger.error(`Error building plugin ${t}`, a) : this.context.rf.logger.error(
          `Error building plugin ${t}`,
          new Error(String(a))
        ), this.stateManager.toaster?.error({
          title: "Error",
          description: `Error building plugin ${t}: ${a}`,
          duration: 5e3
        });
      }
    }
  }
}
class F1e extends mg {
  constructor(t) {
    super(t), this.on_rf_node_change = (n) => {
      const r = this.useReactFlowStore.getState();
      for (const a of n)
        switch (a.type) {
          case "position":
            if (a.position) {
              const s = r.getNode(a.id);
              if (s === void 0)
                continue;
              s.type === "group" ? this.nodespaceManager.change_group_position(a) : this.nodespaceManager.change_fn_node_position(a), s.data.groupID && this.nodespaceManager.auto_resize_group(s.data.groupID);
            }
            break;
          case "dimensions":
            if (a.dimensions) {
              const s = r.getNode(a.id);
              if (s === void 0)
                continue;
              s.type === "group" ? this.nodespaceManager.change_group_dimensions(a) : this.nodespaceManager.change_fn_node_dimensions(a), s.data.groupID && this.nodespaceManager.auto_resize_group(
                s.data.groupID
              );
            }
            break;
        }
    }, this.on_rf_edge_change = (n) => {
    }, this.on_connect = (n) => {
      n.source === null || n.target === null || n.sourceHandle === null || n.targetHandle === null || !this.workerManager.worker || this.workerManager.worker.api.edge.add_edge({
        src_nid: n.source,
        src_ioid: n.sourceHandle,
        trg_nid: n.target,
        trg_ioid: n.targetHandle,
        replace: !0
      });
    }, this.useReactFlowStore = MPe({
      on_node_change: this.on_rf_node_change.bind(this),
      on_edge_change: this.on_rf_edge_change.bind(this),
      on_connect: this.on_connect.bind(this)
    });
  }
}
let B1e = class {
  constructor(e) {
    this.reactflowRef = null, this.dev_settings = {
      debug: Ux()
    }, this.options = e, this.logger = e.logger ?? new $3("fn", Ux() ? x1 : S1);
    const t = { rf: this };
    this._nodespaceManager = new j1e(t), this._libManager = new D1e(t), this._workerManager = new $1e(t), this._stateManager = new T1e(t), this._pluginManager = new z1e(t), this._reactFlowManager = new F1e(t);
  }
  // #region handlers
  getNodespaceManager() {
    return this._nodespaceManager;
  }
  getLibManager() {
    return this._libManager;
  }
  getWorkerManager() {
    return this._workerManager;
  }
  getStateManager() {
    return this._stateManager;
  }
  getPluginManager() {
    return this._pluginManager;
  }
  getReactFlowManager() {
    return this._reactFlowManager;
  }
  // #endregion handlers
  // #region nodespace manager
  get nodespace() {
    return this._nodespaceManager.nodespace;
  }
  get on_node_action() {
    return this._nodespaceManager.on_node_action.bind(this._nodespaceManager);
  }
  get on_edge_action() {
    return this._nodespaceManager.on_edge_action.bind(this._nodespaceManager);
  }
  get on_group_action() {
    return this._nodespaceManager.on_group_action.bind(this._nodespaceManager);
  }
  get clear_all() {
    return this._nodespaceManager.clear_all.bind(this._nodespaceManager);
  }
  get center_node() {
    return this._nodespaceManager.center_node.bind(this._nodespaceManager);
  }
  get center_all() {
    return this._nodespaceManager.center_all.bind(this._nodespaceManager);
  }
  // #endregion nodespace manager
  // #region lib manager
  get lib() {
    return this._libManager.lib;
  }
  // #endregion lib manager
  // #region worker manager
  get set_worker() {
    return this._workerManager.set_worker.bind(this._workerManager);
  }
  get workermanager() {
    return this._workerManager.workermanager;
  }
  set workermanager(e) {
    this._workerManager.workermanager = e;
  }
  get worker() {
    return this._workerManager.worker;
  }
  get workers() {
    return this._workerManager.workers;
  }
  get workerstate() {
    return this._workerManager.workerstate;
  }
  get _unsubscribeFromWorker() {
    return this._workerManager._unsubscribeFromWorker?.bind(
      this._workerManager
    );
  }
  // #endregion worker manager
  // #region statemanager
  get set_progress() {
    return this._stateManager.set_progress.bind(this._stateManager);
  }
  get auto_progress() {
    return this._stateManager.auto_progress.bind(this._stateManager);
  }
  get progress_state() {
    return this._stateManager.progress_state;
  }
  get local_settings() {
    return this._stateManager.local_settings;
  }
  get local_state() {
    return this._stateManager.local_state;
  }
  update_view_settings(e) {
    this._stateManager.update_view_settings(e);
  }
  // #endregion statemanager
  // #region plugis
  get plugins() {
    return this._pluginManager.plugins.bind(this._pluginManager);
  }
  get add_plugin() {
    return this._pluginManager.add_plugin.bind(this._pluginManager);
  }
  get add_packed_plugin() {
    return this._pluginManager.add_packed_plugin.bind(this._pluginManager);
  }
  get render_options() {
    return this._pluginManager.render_options.bind(this._pluginManager);
  }
  get update_render_options() {
    return this._pluginManager.update_render_options.bind(this._pluginManager);
  }
  // #endregion plugis
  // #region reactflow
  get useReactFlowStore() {
    return this._reactFlowManager.useReactFlowStore.bind(
      this._reactFlowManager
    );
  }
  get rf_instance() {
    return this._reactFlowManager.rf_instance;
  }
  set rf_instance(e) {
    this._reactFlowManager.rf_instance = e;
  }
  // #endregion reactflow
};
const U1e = H_(
  ope,
  (e) => (e.id = XR(), e)
), V1e = (e) => {
  if (!e.useWorkerManager && e.worker === void 0)
    throw new Error(
      "If you don't use a worker manager, you must provide a default worker."
    );
  if (e.useWorkerManager && e.workermanager_url === void 0)
    throw new Error(
      "Error: If you use a worker manager, you must provide a worker managerurl."
    );
}, j3 = {};
window.fnrf_zst === void 0 && (window.fnrf_zst = j3);
const fj = (e) => {
  const [t, n] = M.useState(void 0), [r, a] = M.useState(
    void 0
  ), [s, l] = M.useState(!1);
  if (M.useEffect(() => {
    const c = U1e(e);
    c.logger = c.logger || new $3("FuncNodes", c.debug ? "debug" : "info"), c.logger.debug("Initializing FuncNodes with props:", c), n(c), l(!1);
  }, [e]), M.useEffect(() => {
    if (!t) return;
    t.logger?.debug("Initializing/Getting Zustand store");
    const c = j3[t.id];
    if (c === void 0) {
      const d = new B1e(t);
      j3[t.id] = d, a(d);
    } else
      a(c), c.options.debug = t.debug;
  }, [t?.id, t?.debug]), M.useEffect(() => {
    if (!(!t || !r) && !(t.useWorkerManager || // a) a worker manager is used
    !t.worker_url && !t.worker))
      if (t.logger?.debug("Worker effect running"), !t.worker && t.worker_url) {
        t.logger?.debug("Creating WebSocket worker");
        const c = new hB({
          url: t.worker_url,
          uuid: t.id,
          on_sync_complete: t.on_sync_complete
        });
        return c.set_zustand(r), n(
          (d) => d && { ...d, worker: c, useWorkerManager: !1 }
        ), () => {
          t.logger?.debug("Disconnecting worker"), c.disconnect(), n((d) => d && { ...d, worker: void 0 });
        };
      } else {
        t.worker?.set_zustand(r);
        return;
      }
  }, [
    t?.worker_url,
    t?.id,
    t?.useWorkerManager,
    r,
    t?.on_sync_complete
  ]), M.useEffect(() => {
    if (!t?.fnw_url || !t.worker) return;
    t.logger?.debug("Loading fnw_url data");
    let c = !1;
    const d = t.worker.getSyncManager();
    let p;
    return (async () => {
      try {
        const m = await zK(t.fnw_url);
        if (c) return;
        p = async (h) => {
          c || await h.update_from_export(m);
        }, d.add_after_next_sync(p);
      } catch (m) {
        m instanceof Error ? t.logger?.error("Failed to load fnw_url:", m) : t.logger?.error(
          "Failed to load fnw_url:",
          new Error(String(m))
        );
      }
    })(), () => {
      c = !0, p && d.remove_after_next_sync(p);
    };
  }, [t?.fnw_url, t?.worker]), M.useEffect(() => {
    if (!t || !r || !t.useWorkerManager) return;
    if (!t.workermanager_url)
      throw new Error(
        "Error: If you use a worker manager, you must provide a worker manager url."
      );
    r.logger.info("Worker manager effect running");
    const c = !r.workermanager, d = r.workermanager && r.workermanager.wsuri !== t.workermanager_url;
    if (c || d) {
      r.workermanager && (r.logger.info("Removing existing worker manager"), r.workermanager.remove(), r.workermanager = void 0), r.logger.info("Creating new worker manager");
      const p = new epe(
        t.workermanager_url,
        r
      );
      return r.workermanager = p, n((m) => m && { ...m, workermanager: p }), () => {
        r.logger.info("Worker manager cleanup running"), r.workermanager === p ? (r.logger.info("Removing worker manager instance"), p.remove(), r.workermanager = void 0) : r.logger.info(
          "Worker manager instance mismatch, skipping cleanup"
        );
      };
    } else {
      r.logger.info(
        "Worker manager already initialized with correct URL"
      );
      return;
    }
  }, [
    t?.useWorkerManager,
    t?.workermanager_url,
    t?.id,
    r
  ]), M.useEffect(() => {
    !t || !r || s || (t.useWorkerManager ? r.workermanager !== void 0 : t.worker !== void 0) && t.on_ready && typeof t.on_ready == "function" && (t.logger?.debug("Firing on_ready callback"), t.on_ready({ fnrf_zst: r }), l(!0));
  }, [
    t,
    r,
    s,
    t?.useWorkerManager,
    r?.workermanager,
    t?.worker
  ]), t === void 0 || r === void 0)
    return /* @__PURE__ */ E.jsx("div", { children: "Loading..." });
  try {
    V1e(t);
  } catch (c) {
    return /* @__PURE__ */ E.jsx(FK, { error: c });
  }
  return /* @__PURE__ */ E.jsx("div", { className: "FuncnodesApp", children: /* @__PURE__ */ E.jsx(Sae, { available_themes: gB, children: /* @__PURE__ */ E.jsx(ede, { duration: 5e3, children: /* @__PURE__ */ E.jsx(
    R1e,
    {
      fnrf_zst: r,
      header: t.header,
      library: t.library,
      flow: t.flow
    }
  ) }) }) });
}, pj = (e, t) => {
  t === void 0 && (t = {});
  const { element: n, eleid: r } = typeof e == "string" ? {
    element: document.getElementById(e),
    eleid: e
  } : { element: e, eleid: e.id };
  OK.createRoot(n).render(
    /* @__PURE__ */ E.jsx(M.StrictMode, { children: /* @__PURE__ */ E.jsx(fj, { ...t, id: t.id || r }) })
  );
};
window.FuncNodes = pj;
window.FuncNodes.version = "2.2.1";
window.FuncNodes.utils = {
  logger: {
    ConsoleLogger: $3,
    DivLogger: AK,
    BaseLogger: D3,
    DEBUG: x1,
    INFO: S1,
    WARN: MK,
    ERROR: NK
  }
};
const Ao = [];
for (let e = 0; e < 256; ++e)
  Ao.push((e + 256).toString(16).slice(1));
function H1e(e, t = 0) {
  return (Ao[e[t + 0]] + Ao[e[t + 1]] + Ao[e[t + 2]] + Ao[e[t + 3]] + "-" + Ao[e[t + 4]] + Ao[e[t + 5]] + "-" + Ao[e[t + 6]] + Ao[e[t + 7]] + "-" + Ao[e[t + 8]] + Ao[e[t + 9]] + "-" + Ao[e[t + 10]] + Ao[e[t + 11]] + Ao[e[t + 12]] + Ao[e[t + 13]] + Ao[e[t + 14]] + Ao[e[t + 15]]).toLowerCase();
}
let FN;
const q1e = new Uint8Array(16);
function W1e() {
  if (!FN) {
    if (typeof crypto > "u" || !crypto.getRandomValues)
      throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
    FN = crypto.getRandomValues.bind(crypto);
  }
  return FN(q1e);
}
const G1e = typeof crypto < "u" && crypto.randomUUID && crypto.randomUUID.bind(crypto), l1 = { randomUUID: G1e };
function K1e(e, t, n) {
  e = e || {};
  const r = e.random ?? e.rng?.() ?? W1e();
  if (r.length < 16)
    throw new Error("Random bytes length must be >= 16");
  return r[6] = r[6] & 15 | 64, r[8] = r[8] & 63 | 128, H1e(r);
}
function X1e(e, t, n) {
  return l1.randomUUID && !e ? l1.randomUUID() : K1e(e);
}
const u1 = (e) => !!e && typeof e == "object" && "port" in e && !!e.port, c1 = (e) => !!e && typeof e == "object" && typeof e.postMessage == "function" && typeof e.addEventListener == "function" && !("port" in e);
class Y1e {
  constructor(t, n = {}) {
    if (this._disposed = !1, this._intervals = [], this._worker = t, this._worker_id = n.worker_id, n.onMessage)
      if (this._onmessage_bound = n.onMessage, u1(t))
        this._port = t.port, this._port.start(), this._port.addEventListener("message", this._onmessage_bound);
      else if (c1(t))
        t.addEventListener("message", this._onmessage_bound);
      else
        throw new Error("worker must be a DedicatedWorkerLike or SharedWorkerLike");
    else if (u1(t))
      this._port = t.port, this._port.start();
    else if (!c1(t))
      throw new Error("worker must be a DedicatedWorkerLike or SharedWorkerLike");
  }
  get disposed() {
    return this._disposed;
  }
  get shared() {
    return !!this._port;
  }
  _decorate(t) {
    return this._worker_id === void 0 ? t : { ...t, worker_id: this._worker_id };
  }
  postMessage(t) {
    this._disposed || this._postRaw(t);
  }
  _postRaw(t) {
    const n = this._decorate(t);
    this._port ? this._port.postMessage(n) : this._worker.postMessage(n);
  }
  startStatePolling({ intervalMs: t = 400 } = {}) {
    if (this._disposed) return;
    const n = setInterval(() => {
      this.postMessage({ cmd: "state" });
    }, t);
    this._intervals.push(n);
  }
  stopPolling() {
    for (const t of this._intervals) clearInterval(t);
    this._intervals = [];
  }
  dispose() {
    if (!this._disposed) {
      if (this._port)
        try {
          this._postRaw({ cmd: "disconnect" });
        } catch {
        }
      this._disposed = !0, this.stopPolling();
      try {
        this._port && this._onmessage_bound ? this._port.removeEventListener("message", this._onmessage_bound) : this._onmessage_bound && this._worker.removeEventListener?.(
          "message",
          this._onmessage_bound
        );
      } catch {
      }
      if (this._port) {
        try {
          this._port.close();
        } catch {
        }
        this._port = void 0;
      } else
        try {
          this._worker.terminate?.();
        } catch {
        }
    }
  }
}
const Q1e = ({
  pageOrigin: e,
  scriptUrl: t
}) => {
  if (!e || !t) return !1;
  try {
    return new URL(t).origin !== e;
  } catch {
    return !1;
  }
}, J1e = () => typeof URL < "u" && typeof URL.createObjectURL == "function" && typeof URL.revokeObjectURL == "function" && typeof Blob < "u", Z1e = (e) => {
  if (!J1e()) return;
  const t = `await import(${JSON.stringify(e)});`, n = new Blob([t], { type: "text/javascript" });
  return URL.createObjectURL(n);
}, h0 = (e, t) => {
  try {
    return e(t);
  } catch (n) {
    const r = Z1e(t);
    if (!r) throw n;
    try {
      return e(r);
    } finally {
      try {
        URL.revokeObjectURL(r);
      } catch {
      }
    }
  }
}, d1 = (e) => {
  if (e.worker) return e.worker;
  const t = e.uuid;
  if (!!e.shared_worker) {
    if (e.worker_url === void 0) {
      if (e.worker_classes?.Shared)
        return new e.worker_classes.Shared({ name: t });
      if (typeof SharedWorker > "u")
        throw new Error(
          "SharedWorker is not available; provide worker, worker_url or worker_classes.Shared"
        );
      try {
        return new SharedWorker(new URL(
          /* @vite-ignore */
          "" + new URL("assets/pyodideSharedWorker-B8dBCO6o.js", import.meta.url).href,
          import.meta.url
        ), {
          name: t,
          type: "module"
        });
      } catch {
        return h0(
          (a) => new SharedWorker(a, { name: t, type: "module" }),
          new URL("data:video/mp2t;base64,aW1wb3J0IHsgaW5pdFNoYXJlZFdvcmtlciB9IGZyb20gIi4vcHlvZGlkZVdlYldvcmtlci5tanMiOwppbml0U2hhcmVkV29ya2VyKHt9KTsK", import.meta.url).href
        );
      }
    }
    if (e.worker_classes?.Shared, typeof SharedWorker > "u")
      throw new Error(
        "SharedWorker is not available; provide worker or set shared_worker=false"
      );
    return h0(
      (r) => new SharedWorker(r, { name: t, type: "module" }),
      e.worker_url
    );
  }
  if (e.worker_url === void 0) {
    if (e.worker_classes?.Dedicated)
      return new e.worker_classes.Dedicated({ name: t });
    if (typeof Worker > "u")
      throw new Error(
        "Worker is not available; provide worker, worker_url or worker_classes.Dedicated"
      );
    try {
      return new Worker(new URL(
        /* @vite-ignore */
        "" + new URL("assets/pyodideDedicatedWorker-Bge9R9PO.js", import.meta.url).href,
        import.meta.url
      ), {
        name: t,
        type: "module"
      });
    } catch {
      return h0(
        (a) => new Worker(a, { name: t, type: "module" }),
        new URL("data:video/mp2t;base64,aW1wb3J0IHsgaW5pdERlZGljYXRlZFdvcmtlciB9IGZyb20gIi4vcHlvZGlkZVdlYldvcmtlci5tanMiOwppbml0RGVkaWNhdGVkV29ya2VyKHt9KTsK", import.meta.url).href
      );
    }
  }
  if (typeof Worker > "u")
    throw new Error(
      "Worker is not available; provide worker or set shared_worker=true"
    );
  return h0(
    (r) => new Worker(r, { name: t, type: "module" }),
    e.worker_url
  );
}, dK = '(function(){"use strict";const w="https://cdn.jsdelivr.net/pyodide/v0.29.0/full/pyodide.mjs",e=self;e.workerState={pyodide:null,pyodide_url:w,packages:[],state:{msg:"loading",loaded:!1,progress:0},micropip:null,worker:{},pyodideReady:!1,pyodideReadyPromise:null,debug:!1,interruptBuffer:null,receivepy:(r,t)=>{},receivepy_bytes:(r,t)=>{},handel_register:{},post_pyodide_ready:void 0},e.reset=async()=>{for(const r in e.list_workers())try{const t=await e.get_worker(r);t.worker&&t.worker.stop(),t.reject_promise?.("Worker reset")}catch{}e.workerState.pyodide&&e.interrupt(),e.workerState.pyodide=null,e.workerState.micropip=null,e.workerState.worker={},e.workerState.pyodideReady=!1;try{e.workerState.interruptBuffer=new Uint8Array(new SharedArrayBuffer(1)),e.workerState.interruptBuffer[0]=0}catch{}},e.initializePyodide=async()=>{if(!e.workerState.pyodide){console.log("initializePyodide with: Debug:",e.workerState.debug,"Pyodide URL:",e.workerState.pyodide_url,"Packages:",e.workerState.packages),console.debug("Loading Pyodide..."),e.workerState.state.msg="Loading Pyodide...",e.workerState.state.progress=0,await e.reset(),console.debug("Loading Pyodide module..."),e.workerState.state.msg="Loading Pyodide module...",e.workerState.state.progress=.1;const t=await import(e.workerState.pyodide_url);console.debug("Loading Pyodide instance..."),e.workerState.state.msg="Loading Pyodide instance...",e.workerState.state.progress=.2;const o=t.loadPyodide,s=new URL(e.workerState.pyodide_url),a=new URL(".",s).toString();e.workerState.debug&&console.debug("Pyodide indexURL:",a),e.workerState.pyodide=await o({packages:["micropip"],indexURL:a}),e.workerState.interruptBuffer&&e.workerState.pyodide.setInterruptBuffer(e.workerState.interruptBuffer)}e.workerState.micropip||(console.debug("Importing micropip..."),e.workerState.state.msg="Importing micropip...",e.workerState.state.progress=.3,e.workerState.micropip=e.workerState.pyodide.pyimport("micropip")),console.debug("Pyodide ready. Installing funcnodes...");for(const t of e.workerState.packages)console.log("Installing package:",t),e.workerState.state.msg=`Installing package: ${t}`,await e.workerState.micropip.install(t);return e.workerState.state.msg="Installing funcnodes",e.workerState.state.progress=.8,await e.workerState.micropip.install("funcnodes"),e.workerState.state.msg="Installing funcnodes-worker",await e.workerState.micropip.install("funcnodes-worker"),e.workerState.packages.some(t=>t.toLowerCase().endsWith(".whl")&&t.includes("funcnodes_pyodide"))?e.workerState.debug&&console.debug("Skipping PyPI funcnodes-pyodide install (wheel provided in packages)"):(e.workerState.state.msg="Installing funcnodes-pyodide",await e.workerState.micropip.install("funcnodes-pyodide")),e.workerState.state.msg="Installing funcnodes-react-flow",await e.workerState.micropip.install("funcnodes-react-flow"),e.workerState.state.msg="Importing funcnodes",console.debug("Importing funcnodes..."),await e.workerState.pyodide.runPythonAsync("import funcnodes_pyodide"),console.debug("Running post_pyodide_ready..."),await e.workerState.post_pyodide_ready?.(e.workerState),console.debug("Pyodide ready"),e.workerState.state.msg="ready",e.workerState.state.progress=.1,e.workerState.pyodideReady=!0,{pyodide:e.workerState.pyodide,micropip:e.workerState.micropip}},e.interrupt=()=>{e.workerState.interruptBuffer&&(e.workerState.interruptBuffer[0]=1)},e.list_workers=()=>Object.keys(e.workerState.worker),e.get_worker=async r=>{if(!r)throw new Error("Worker id is required");if(!e.workerState.worker[r])throw new Error(`Worker with id ${r} not found`);return await e.workerState.worker[r].make_promise,e.workerState.worker[r]},e.has_worker=r=>{if(!r)throw new Error("Worker id is required");return!!e.workerState.worker[r]},e.get_or_create_worker=async r=>{if(!r)throw new Error("Worker id is required");return e.workerState.worker[r]||(console.log("Creating worker with id",r),await e.initializeFuncNodesWorker(r)),e.get_worker(r)},e.initializeFuncNodesWorker=async r=>{try{if(!e.workerState.pyodideReadyPromise)throw new Error("Pyodide newer initialized");const{pyodide:t}=await e.workerState.pyodideReadyPromise;if(!e.has_worker(r)){e.workerState.worker[r]={worker:null,make_promise:void 0};const o=new Promise(async(s,a)=>{e.workerState.worker[r].reject_promise=a,console.debug(`Creating worker (${r})...`);const i=await t.runPythonAsync(`funcnodes_pyodide.new_worker(debug=${e.workerState.debug?1:0}, uuid="${r}")`);if(console.debug("Worker created:",i),typeof i.set_receiver=="function")i.set_receiver(self);else throw new Error("Worker does not expose a \'set_receiver\' method.");e.workerState.worker[r].worker=i,console.debug("Worker ready"),s(i)});e.workerState.worker[r].make_promise=o}return e.get_worker(r)}catch(t){throw console.error("Error during worker initialization:",t),t}},e.receivepy=(r,t)=>{try{let o={};if(typeof r=="string"?o.msg=r:o=r,o.msg===void 0)return;typeof o.msg!="string"&&(o.msg=JSON.stringify(o.msg)),t!==void 0&&(typeof t=="string"?o.worker_id||(o.worker_id=t):o={...t,...o});const s=o.worker_id;if(!s)throw new Error(`Worker id not provided in receivepy(${JSON.stringify(o)})`);if(!e.workerState.worker[s])throw new Error(`Worker with id ${s} not found in receivepy(${JSON.stringify(o)})`);e.workerState.receivepy(r,s)}catch(o){console.error("Error during receivepy:",o);return}},e.receivepy_bytes=(r,t)=>{let o=r;const s=r;if(s&&typeof s.toJs=="function")try{o=s.toJs({dict_converter:Object.fromEntries})}catch{o=s.toJs()}o instanceof Map&&(o=Object.fromEntries(o.entries()));try{let a={};if(o instanceof Uint8Array?a.msg=o:a=o,a.msg===void 0)return;let i=a.msg;const n=i;if(n&&typeof n.toJs=="function")try{i=n.toJs({dict_converter:Object.fromEntries})}catch{i=n.toJs()}if(i instanceof ArrayBuffer&&(i=new Uint8Array(i)),Array.isArray(i)&&(i=Uint8Array.from(i)),!(i instanceof Uint8Array))throw new Error(`receivepy_bytes expected Uint8Array payload, got ${typeof i}`);a.msg=i,t!==void 0&&(typeof t=="string"?a.worker_id||(a.worker_id=t):a={...t,...a});const d=a.worker_id;if(!d)throw new Error("Worker id not provided in receivepy_bytes");if(!e.workerState.worker[d])throw new Error(`Worker with id ${d} not found in receivepy_bytes`);e.workerState.receivepy_bytes(a.msg,d)}catch(a){console.error("Error during receivepy_bytes:",a);return}},e.startInitialization=({debug:r=!1,receivepy:t,receivepy_bytes:o,pyodide_url:s,post_pyodide_ready:a,packages:i})=>(e.workerState.debug=r,e.workerState.pyodide_url=s||w,e.workerState.packages=i,e.workerState.receivepy=t,e.workerState.receivepy_bytes=o,e.workerState.pyodideReadyPromise=null,e.workerState.post_pyodide_ready=a,e.workerState),e.register_cmd_message=(r,t)=>{if(e.workerState.handel_register[r])throw new Error(`Command ${r} already registered`);e.workerState.handel_register[r]=t},e.register_cmd_message("ping",async r=>"pong"),e.register_cmd_message("init",async r=>{if(e.workerState.pyodideReadyPromise)throw new Error("Pyodide is already initialized");r.data&&(r.data.pyodide_url&&(e.workerState.pyodide_url=r.data.pyodide_url),r.data.packages&&(e.workerState.packages=r.data.packages),r.data.debug&&(e.workerState.debug=r.data.debug)),e.workerState.pyodideReadyPromise=e.initializePyodide()}),e.register_cmd_message("_eval",async r=>{try{const t=await e.workerState.pyodide?.runPythonAsync(r.msg||"print(\'No code provided\')");return console.log("Eval result:",t),t}catch(t){console.error("Error during _eval:",t)}}),e.register_cmd_message("state",async r=>({state:{...e.workerState.state,loaded:e.workerState.pyodideReady}})),e.register_cmd_message("worker:state",async r=>({state:{loaded:!!(await e.get_or_create_worker(r.worker_id)).worker}})),e.register_cmd_message("worker:stop",async r=>{if(!e.has_worker(r.worker_id))return;const t=await e.get_or_create_worker(r.worker_id);return t.worker&&(t.worker.stop(),t.worker=null,t.reject_promise?.("Worker stopped")),delete e.workerState.worker[r.worker_id],{state:{loaded:!1}}}),e.register_cmd_message("worker:send",async r=>{const t=await e.get_or_create_worker(r.worker_id);if(!t.worker)throw new Error("Worker is not initialized");if(typeof t.worker.receivejs!="function")throw new Error(`Worker does not support receivejs: ${typeof t.worker.receivejs}`);t.worker.receivejs(r.msg)}),e.handleMessage=async r=>{const t={original:r};r.id&&(t.id=r.id),r.toJs===void 0&&(r.toJs=!0);try{if(r.cmd){const o=r;if(e.workerState.handel_register[o.cmd])t.result=await e.workerState.handel_register[o.cmd](o);else throw new Error("Unknown command: "+o.cmd)}else throw new Error("Unknown message format: "+JSON.stringify(r))}catch(o){t.error=o.message}return t},e.read_url_params=()=>{const r=new URLSearchParams(self.location.search),t=r.get("debug")?.toLowerCase()==="true",o=r.get("pyodide_url")||void 0,s=r.get("packages")?.split(",")||[];return{debug:t,pyodide_url:o,packages:s}};const k=r=>{const t=new Set;return{add:o=>{t.add(o)},disconnect:o=>{t.delete(o)&&t.size===0&&r()},forEach:o=>{t.forEach(o)},size:()=>t.size}},c=e;c.general_initalization=r=>{const t=c.read_url_params();c.startInitialization({...r,...t})};const l=c,p=c;p.init_dedicated_worker=r=>{const t=e;t.onmessage=async s=>{const a=s.data,i=await t.handleMessage(a);t.postMessage(i)};const o={...r,receivepy:(s,a)=>{t.postMessage({cmd:"receive",msg:s,worker_id:a})},receivepy_bytes(s,a){t.postMessage({cmd:"receive_bytes",msg:s,worker_id:a})}};t.general_initalization(o)},l.init_shared_worker=r=>{const t=e,o=k(()=>{try{t.close()}catch{}});t.connectedPorts=[],t.onconnect=a=>{const i=a.ports[0];t.connectedPorts.push(i),o.add(i),i.start(),console.debug("Port connected in shared worker"),i.onmessage=async n=>{const d=n.data;if(d?.cmd==="disconnect"){o.disconnect(i),t.connectedPorts=t.connectedPorts.filter(g=>g!==i);try{i.onmessage=null}catch{}try{i.close()}catch{}return}const y=await t.handleMessage(d);i.postMessage(y)}};const s={...r,receivepy:(a,i)=>{o.forEach(n=>{n.postMessage({cmd:"receive",msg:a,worker_id:i})})},receivepy_bytes(a,i){o.forEach(n=>{n.postMessage({cmd:"receive_bytes",msg:a,worker_id:i})})}};t.general_initalization(s)},(r=>{c.init_dedicated_worker(r)})({})})();\n', f1 = typeof self < "u" && self.Blob && new Blob(["(self.URL || self.webkitURL).revokeObjectURL(self.location.href);", dK], { type: "text/javascript;charset=utf-8" });
function p1(e) {
  let t;
  try {
    if (t = f1 && (self.URL || self.webkitURL).createObjectURL(f1), !t) throw "";
    const n = new Worker(t, {
      name: e?.name
    });
    return n.addEventListener("error", () => {
      (self.URL || self.webkitURL).revokeObjectURL(t);
    }), n;
  } catch {
    return new Worker(
      "data:text/javascript;charset=utf-8," + encodeURIComponent(dK),
      {
        name: e?.name
      }
    );
  }
}
const e9e = '(function(){"use strict";const w="https://cdn.jsdelivr.net/pyodide/v0.29.0/full/pyodide.mjs",e=self;e.workerState={pyodide:null,pyodide_url:w,packages:[],state:{msg:"loading",loaded:!1,progress:0},micropip:null,worker:{},pyodideReady:!1,pyodideReadyPromise:null,debug:!1,interruptBuffer:null,receivepy:(r,t)=>{},receivepy_bytes:(r,t)=>{},handel_register:{},post_pyodide_ready:void 0},e.reset=async()=>{for(const r in e.list_workers())try{const t=await e.get_worker(r);t.worker&&t.worker.stop(),t.reject_promise?.("Worker reset")}catch{}e.workerState.pyodide&&e.interrupt(),e.workerState.pyodide=null,e.workerState.micropip=null,e.workerState.worker={},e.workerState.pyodideReady=!1;try{e.workerState.interruptBuffer=new Uint8Array(new SharedArrayBuffer(1)),e.workerState.interruptBuffer[0]=0}catch{}},e.initializePyodide=async()=>{if(!e.workerState.pyodide){console.log("initializePyodide with: Debug:",e.workerState.debug,"Pyodide URL:",e.workerState.pyodide_url,"Packages:",e.workerState.packages),console.debug("Loading Pyodide..."),e.workerState.state.msg="Loading Pyodide...",e.workerState.state.progress=0,await e.reset(),console.debug("Loading Pyodide module..."),e.workerState.state.msg="Loading Pyodide module...",e.workerState.state.progress=.1;const t=await import(e.workerState.pyodide_url);console.debug("Loading Pyodide instance..."),e.workerState.state.msg="Loading Pyodide instance...",e.workerState.state.progress=.2;const o=t.loadPyodide,s=new URL(e.workerState.pyodide_url),a=new URL(".",s).toString();e.workerState.debug&&console.debug("Pyodide indexURL:",a),e.workerState.pyodide=await o({packages:["micropip"],indexURL:a}),e.workerState.interruptBuffer&&e.workerState.pyodide.setInterruptBuffer(e.workerState.interruptBuffer)}e.workerState.micropip||(console.debug("Importing micropip..."),e.workerState.state.msg="Importing micropip...",e.workerState.state.progress=.3,e.workerState.micropip=e.workerState.pyodide.pyimport("micropip")),console.debug("Pyodide ready. Installing funcnodes...");for(const t of e.workerState.packages)console.log("Installing package:",t),e.workerState.state.msg=`Installing package: ${t}`,await e.workerState.micropip.install(t);return e.workerState.state.msg="Installing funcnodes",e.workerState.state.progress=.8,await e.workerState.micropip.install("funcnodes"),e.workerState.state.msg="Installing funcnodes-worker",await e.workerState.micropip.install("funcnodes-worker"),e.workerState.packages.some(t=>t.toLowerCase().endsWith(".whl")&&t.includes("funcnodes_pyodide"))?e.workerState.debug&&console.debug("Skipping PyPI funcnodes-pyodide install (wheel provided in packages)"):(e.workerState.state.msg="Installing funcnodes-pyodide",await e.workerState.micropip.install("funcnodes-pyodide")),e.workerState.state.msg="Installing funcnodes-react-flow",await e.workerState.micropip.install("funcnodes-react-flow"),e.workerState.state.msg="Importing funcnodes",console.debug("Importing funcnodes..."),await e.workerState.pyodide.runPythonAsync("import funcnodes_pyodide"),console.debug("Running post_pyodide_ready..."),await e.workerState.post_pyodide_ready?.(e.workerState),console.debug("Pyodide ready"),e.workerState.state.msg="ready",e.workerState.state.progress=.1,e.workerState.pyodideReady=!0,{pyodide:e.workerState.pyodide,micropip:e.workerState.micropip}},e.interrupt=()=>{e.workerState.interruptBuffer&&(e.workerState.interruptBuffer[0]=1)},e.list_workers=()=>Object.keys(e.workerState.worker),e.get_worker=async r=>{if(!r)throw new Error("Worker id is required");if(!e.workerState.worker[r])throw new Error(`Worker with id ${r} not found`);return await e.workerState.worker[r].make_promise,e.workerState.worker[r]},e.has_worker=r=>{if(!r)throw new Error("Worker id is required");return!!e.workerState.worker[r]},e.get_or_create_worker=async r=>{if(!r)throw new Error("Worker id is required");return e.workerState.worker[r]||(console.log("Creating worker with id",r),await e.initializeFuncNodesWorker(r)),e.get_worker(r)},e.initializeFuncNodesWorker=async r=>{try{if(!e.workerState.pyodideReadyPromise)throw new Error("Pyodide newer initialized");const{pyodide:t}=await e.workerState.pyodideReadyPromise;if(!e.has_worker(r)){e.workerState.worker[r]={worker:null,make_promise:void 0};const o=new Promise(async(s,a)=>{e.workerState.worker[r].reject_promise=a,console.debug(`Creating worker (${r})...`);const i=await t.runPythonAsync(`funcnodes_pyodide.new_worker(debug=${e.workerState.debug?1:0}, uuid="${r}")`);if(console.debug("Worker created:",i),typeof i.set_receiver=="function")i.set_receiver(self);else throw new Error("Worker does not expose a \'set_receiver\' method.");e.workerState.worker[r].worker=i,console.debug("Worker ready"),s(i)});e.workerState.worker[r].make_promise=o}return e.get_worker(r)}catch(t){throw console.error("Error during worker initialization:",t),t}},e.receivepy=(r,t)=>{try{let o={};if(typeof r=="string"?o.msg=r:o=r,o.msg===void 0)return;typeof o.msg!="string"&&(o.msg=JSON.stringify(o.msg)),t!==void 0&&(typeof t=="string"?o.worker_id||(o.worker_id=t):o={...t,...o});const s=o.worker_id;if(!s)throw new Error(`Worker id not provided in receivepy(${JSON.stringify(o)})`);if(!e.workerState.worker[s])throw new Error(`Worker with id ${s} not found in receivepy(${JSON.stringify(o)})`);e.workerState.receivepy(r,s)}catch(o){console.error("Error during receivepy:",o);return}},e.receivepy_bytes=(r,t)=>{let o=r;const s=r;if(s&&typeof s.toJs=="function")try{o=s.toJs({dict_converter:Object.fromEntries})}catch{o=s.toJs()}o instanceof Map&&(o=Object.fromEntries(o.entries()));try{let a={};if(o instanceof Uint8Array?a.msg=o:a=o,a.msg===void 0)return;let i=a.msg;const n=i;if(n&&typeof n.toJs=="function")try{i=n.toJs({dict_converter:Object.fromEntries})}catch{i=n.toJs()}if(i instanceof ArrayBuffer&&(i=new Uint8Array(i)),Array.isArray(i)&&(i=Uint8Array.from(i)),!(i instanceof Uint8Array))throw new Error(`receivepy_bytes expected Uint8Array payload, got ${typeof i}`);a.msg=i,t!==void 0&&(typeof t=="string"?a.worker_id||(a.worker_id=t):a={...t,...a});const d=a.worker_id;if(!d)throw new Error("Worker id not provided in receivepy_bytes");if(!e.workerState.worker[d])throw new Error(`Worker with id ${d} not found in receivepy_bytes`);e.workerState.receivepy_bytes(a.msg,d)}catch(a){console.error("Error during receivepy_bytes:",a);return}},e.startInitialization=({debug:r=!1,receivepy:t,receivepy_bytes:o,pyodide_url:s,post_pyodide_ready:a,packages:i})=>(e.workerState.debug=r,e.workerState.pyodide_url=s||w,e.workerState.packages=i,e.workerState.receivepy=t,e.workerState.receivepy_bytes=o,e.workerState.pyodideReadyPromise=null,e.workerState.post_pyodide_ready=a,e.workerState),e.register_cmd_message=(r,t)=>{if(e.workerState.handel_register[r])throw new Error(`Command ${r} already registered`);e.workerState.handel_register[r]=t},e.register_cmd_message("ping",async r=>"pong"),e.register_cmd_message("init",async r=>{if(e.workerState.pyodideReadyPromise)throw new Error("Pyodide is already initialized");r.data&&(r.data.pyodide_url&&(e.workerState.pyodide_url=r.data.pyodide_url),r.data.packages&&(e.workerState.packages=r.data.packages),r.data.debug&&(e.workerState.debug=r.data.debug)),e.workerState.pyodideReadyPromise=e.initializePyodide()}),e.register_cmd_message("_eval",async r=>{try{const t=await e.workerState.pyodide?.runPythonAsync(r.msg||"print(\'No code provided\')");return console.log("Eval result:",t),t}catch(t){console.error("Error during _eval:",t)}}),e.register_cmd_message("state",async r=>({state:{...e.workerState.state,loaded:e.workerState.pyodideReady}})),e.register_cmd_message("worker:state",async r=>({state:{loaded:!!(await e.get_or_create_worker(r.worker_id)).worker}})),e.register_cmd_message("worker:stop",async r=>{if(!e.has_worker(r.worker_id))return;const t=await e.get_or_create_worker(r.worker_id);return t.worker&&(t.worker.stop(),t.worker=null,t.reject_promise?.("Worker stopped")),delete e.workerState.worker[r.worker_id],{state:{loaded:!1}}}),e.register_cmd_message("worker:send",async r=>{const t=await e.get_or_create_worker(r.worker_id);if(!t.worker)throw new Error("Worker is not initialized");if(typeof t.worker.receivejs!="function")throw new Error(`Worker does not support receivejs: ${typeof t.worker.receivejs}`);t.worker.receivejs(r.msg)}),e.handleMessage=async r=>{const t={original:r};r.id&&(t.id=r.id),r.toJs===void 0&&(r.toJs=!0);try{if(r.cmd){const o=r;if(e.workerState.handel_register[o.cmd])t.result=await e.workerState.handel_register[o.cmd](o);else throw new Error("Unknown command: "+o.cmd)}else throw new Error("Unknown message format: "+JSON.stringify(r))}catch(o){t.error=o.message}return t},e.read_url_params=()=>{const r=new URLSearchParams(self.location.search),t=r.get("debug")?.toLowerCase()==="true",o=r.get("pyodide_url")||void 0,s=r.get("packages")?.split(",")||[];return{debug:t,pyodide_url:o,packages:s}};const k=r=>{const t=new Set;return{add:o=>{t.add(o)},disconnect:o=>{t.delete(o)&&t.size===0&&r()},forEach:o=>{t.forEach(o)},size:()=>t.size}},c=e;c.general_initalization=r=>{const t=c.read_url_params();c.startInitialization({...r,...t})};const l=c,p=c;p.init_dedicated_worker=r=>{const t=e;t.onmessage=async s=>{const a=s.data,i=await t.handleMessage(a);t.postMessage(i)};const o={...r,receivepy:(s,a)=>{t.postMessage({cmd:"receive",msg:s,worker_id:a})},receivepy_bytes(s,a){t.postMessage({cmd:"receive_bytes",msg:s,worker_id:a})}};t.general_initalization(o)},l.init_shared_worker=r=>{const t=e,o=k(()=>{try{t.close()}catch{}});t.connectedPorts=[],t.onconnect=a=>{const i=a.ports[0];t.connectedPorts.push(i),o.add(i),i.start(),console.debug("Port connected in shared worker"),i.onmessage=async n=>{const d=n.data;if(d?.cmd==="disconnect"){o.disconnect(i),t.connectedPorts=t.connectedPorts.filter(g=>g!==i);try{i.onmessage=null}catch{}try{i.close()}catch{}return}const y=await t.handleMessage(d);i.postMessage(y)}};const s={...r,receivepy:(a,i)=>{o.forEach(n=>{n.postMessage({cmd:"receive",msg:a,worker_id:i})})},receivepy_bytes(a,i){o.forEach(n=>{n.postMessage({cmd:"receive_bytes",msg:a,worker_id:i})})}};t.general_initalization(s)},(r=>{c.init_shared_worker(r)})({})})();\n';
function m1(e) {
  return new SharedWorker(
    "data:text/javascript;charset=utf-8," + encodeURIComponent(e9e),
    {
      name: e?.name
    }
  );
}
const t9e = (e) => {
  if (e.worker) return e.worker;
  if (e.worker_url !== void 0 || e.worker_classes?.Dedicated || e.worker_classes?.Shared)
    return d1(e);
  const t = e.uuid, n = !!e.shared_worker, r = Q1e({
    pageOrigin: typeof window < "u" && window.location ? window.location.origin : void 0,
    scriptUrl: typeof import.meta < "u" ? import.meta.url : void 0
  });
  if (n) {
    if (typeof SharedWorker > "u")
      throw new Error(
        "SharedWorker is not available; provide worker, worker_url or worker_classes.Shared"
      );
    if (r) return new m1({ name: t });
    try {
      return new SharedWorker(
        new URL(
          /* @vite-ignore */
          "" + new URL("assets/pyodideSharedWorker-B8dBCO6o.js", import.meta.url).href,
          import.meta.url
        ),
        { name: t, type: "module" }
      );
    } catch {
      return new m1({ name: t });
    }
  }
  if (typeof Worker > "u")
    throw new Error(
      "Worker is not available; provide worker, worker_url or worker_classes.Dedicated"
    );
  if (r) return new p1({ name: t });
  try {
    return new Worker(new URL(
      /* @vite-ignore */
      "" + new URL("assets/pyodideDedicatedWorker-Bge9R9PO.js", import.meta.url).href,
      import.meta.url
    ), {
      name: t,
      type: "module"
    });
  } catch {
    return new p1({ name: t });
  }
}, n9e = (e, t) => {
  if (!e?.length) return e;
  const n = t ?? (typeof window < "u" && window.location ? window.location.href : void 0);
  return n ? e.map((r) => /^[a-zA-Z][a-zA-Z0-9+.-]*:/.test(r) ? r : r.startsWith("/") || r.startsWith("./") || r.startsWith("../") ? new URL(r, n).toString() : r) : e;
}, r9e = (e) => (e.worker = t9e({
  uuid: e.uuid,
  shared_worker: e.shared_worker,
  worker_url: e.worker_url,
  worker: e.worker,
  worker_classes: e.worker_classes
}), e.worker);
class fK extends YR {
  constructor(t) {
    const n = {
      uuid: X1e(),
      ...t
    };
    super(n), this._message_hooks = [], this._disposed = !1, this._worker = r9e(n), this._lifecycle = new Y1e(this._worker, {
      worker_id: this.uuid,
      onMessage: this.onmessage.bind(this)
    }), this.postMessage({
      cmd: "init",
      data: {
        debug: n.debug,
        pyodide_url: n.pyodide_url,
        packages: n9e(n.packages, n.worker_baseurl)
      }
    }), this._lifecycle.startStatePolling(), this._workerstate = { loaded: !1, msg: "loading", progress: 0 }, this.initPromise = new Promise(async (r) => {
      for (; !this._workerstate.loaded && !this._disposed; )
        this._zustand?.set_progress({
          message: this._workerstate.msg,
          status: "info",
          progress: this._workerstate.progress,
          blocking: !0
        }), await new Promise((a) => setTimeout(a, 100));
      this._lifecycle.stopPolling(), this._disposed || (this.is_open = !0, this._zustand?.auto_progress()), r();
    }), this.initPromise.then(async () => {
      if (!this._disposed) {
        if (n.restore_worker_state_on_load) {
          const r = typeof n.restore_worker_state_on_load == "string" ? n.restore_worker_state_on_load : this._storage_key();
          await this.restore_worker_state(r);
        }
        await this.getSyncManager().stepwise_fullsync(), n.post_worker_initialized && await n.post_worker_initialized(this);
      }
    });
  }
  async send(t) {
    await this.initPromise, this.postMessage({
      cmd: "worker:send",
      msg: JSON.stringify(t),
      worker_id: this.uuid
    });
  }
  postMessage(t) {
    this._lifecycle.postMessage(t);
  }
  dispose() {
    this._disposed || (this._disposed = !0, this.is_open = !1, this._lifecycle.dispose());
  }
  registerMessageHook(t) {
    return this._message_hooks.push(t), () => {
      this._message_hooks = this._message_hooks.filter((n) => n !== t);
    };
  }
  onmessage(t) {
    if (!this._disposed) {
      for (const n of this._message_hooks)
        n(t.data);
      if (t.data.result)
        t.data.result.state && (this._workerstate = {
          ...this._workerstate,
          ...t.data.result.state
        }, t.data.result.state.msg && t.data.result.state.msg !== "ready" && this._zustand?.set_progress({
          message: this._workerstate.msg,
          status: "info",
          progress: this._workerstate.progress,
          blocking: !0
        }));
      else if (t.data.cmd) {
        if (t.data.cmd === "receive") {
          if (t.data.worker_id === void 0)
            throw new Error("worker_id is undefined");
          t.data.worker_id === this.uuid && this.getCommunicationManager().receive(JSON.parse(t.data.msg));
        } else if (t.data.cmd === "receive_bytes") {
          if (t.data.worker_id === void 0)
            throw new Error("worker_id is undefined");
          t.data.worker_id === this.uuid && this.getCommunicationManager().onbytes(t.data.msg);
        }
      }
    }
  }
  async upload_file({
    files: t,
    onProgressCallback: n,
    root: r
  }) {
    const a = [], s = t.length;
    let l = 0;
    if (t.length === 0)
      return "";
    for (let p = 0; p < t.length; p++) {
      const m = t[p], h = new FileReader(), v = new Promise((y, w) => {
        h.onload = async (x) => {
          try {
            const b = x.target.result?.replace(/^data:.+;base64,/, ""), k = m.webkitRelativePath || m.name, C = r ? `${r}/${k}` : k, _ = await this._send_cmd({
              cmd: "upload",
              kwargs: { data: b, filename: C },
              wait_for_response: !0
            });
            l++, n && n(l, s), y(_);
          } catch (b) {
            w(b);
          }
        }, h.readAsDataURL(m);
      });
      a.push(v);
    }
    const c = await Promise.all(a);
    return c.reduce((p, m) => {
      const h = m.split("/"), v = p.split("/"), y = [];
      for (let w = 0; w < h.length && h[w] === v[w]; w++)
        y.push(h[w]);
      return y.join("/");
    }, c[0]);
  }
  get ready() {
    return this._workerstate.loaded;
  }
  _storage_key() {
    return `funcnodes_pyodide:worker_export:${this.uuid}`;
  }
  _has_local_storage() {
    try {
      return typeof globalThis < "u" && "localStorage" in globalThis;
    } catch {
      return !1;
    }
  }
  async save_worker_state({ withFiles: t = !0 } = {}) {
    const n = await this.export({ withFiles: t }), r = typeof n == "string" ? n : n?.data;
    if (typeof r != "string")
      throw new Error("export_worker did not return a string export");
    return this._has_local_storage() && globalThis.localStorage.setItem(this._storage_key(), r), r;
  }
  async restore_worker_state(t) {
    if (!this._has_local_storage()) return !1;
    const n = globalThis.localStorage.getItem(
      t || this._storage_key()
    );
    if (!n) return !1;
    try {
      return await this.update_from_export(n), !0;
    } catch (r) {
      return console.warn("Failed to restore worker state from storage", r), !1;
    }
  }
}
var BN = { exports: {} }, Mw = {}, UN = { exports: {} }, VN = {};
var h1;
function o9e() {
  return h1 || (h1 = 1, (function(e) {
    function t(L, K) {
      var q = L.length;
      L.push(K);
      e: for (; 0 < q; ) {
        var Z = q - 1 >>> 1, V = L[Z];
        if (0 < a(V, K))
          L[Z] = K, L[q] = V, q = Z;
        else break e;
      }
    }
    function n(L) {
      return L.length === 0 ? null : L[0];
    }
    function r(L) {
      if (L.length === 0) return null;
      var K = L[0], q = L.pop();
      if (q !== K) {
        L[0] = q;
        e: for (var Z = 0, V = L.length, F = V >>> 1; Z < F; ) {
          var X = 2 * (Z + 1) - 1, U = L[X], H = X + 1, Q = L[H];
          if (0 > a(U, q))
            H < V && 0 > a(Q, U) ? (L[Z] = Q, L[H] = q, Z = H) : (L[Z] = U, L[X] = q, Z = X);
          else if (H < V && 0 > a(Q, q))
            L[Z] = Q, L[H] = q, Z = H;
          else break e;
        }
      }
      return K;
    }
    function a(L, K) {
      var q = L.sortIndex - K.sortIndex;
      return q !== 0 ? q : L.id - K.id;
    }
    if (e.unstable_now = void 0, typeof performance == "object" && typeof performance.now == "function") {
      var s = performance;
      e.unstable_now = function() {
        return s.now();
      };
    } else {
      var l = Date, c = l.now();
      e.unstable_now = function() {
        return l.now() - c;
      };
    }
    var d = [], p = [], m = 1, h = null, v = 3, y = !1, w = !1, x = !1, b = !1, k = typeof setTimeout == "function" ? setTimeout : null, C = typeof clearTimeout == "function" ? clearTimeout : null, _ = typeof setImmediate < "u" ? setImmediate : null;
    function O(L) {
      for (var K = n(p); K !== null; ) {
        if (K.callback === null) r(p);
        else if (K.startTime <= L)
          r(p), K.sortIndex = K.expirationTime, t(d, K);
        else break;
        K = n(p);
      }
    }
    function N(L) {
      if (x = !1, O(L), !w)
        if (n(d) !== null)
          w = !0, R || (R = !0, P());
        else {
          var K = n(p);
          K !== null && G(N, K.startTime - L);
        }
    }
    var R = !1, j = -1, D = 5, $ = -1;
    function z() {
      return b ? !0 : !(e.unstable_now() - $ < D);
    }
    function B() {
      if (b = !1, R) {
        var L = e.unstable_now();
        $ = L;
        var K = !0;
        try {
          e: {
            w = !1, x && (x = !1, C(j), j = -1), y = !0;
            var q = v;
            try {
              t: {
                for (O(L), h = n(d); h !== null && !(h.expirationTime > L && z()); ) {
                  var Z = h.callback;
                  if (typeof Z == "function") {
                    h.callback = null, v = h.priorityLevel;
                    var V = Z(
                      h.expirationTime <= L
                    );
                    if (L = e.unstable_now(), typeof V == "function") {
                      h.callback = V, O(L), K = !0;
                      break t;
                    }
                    h === n(d) && r(d), O(L);
                  } else r(d);
                  h = n(d);
                }
                if (h !== null) K = !0;
                else {
                  var F = n(p);
                  F !== null && G(
                    N,
                    F.startTime - L
                  ), K = !1;
                }
              }
              break e;
            } finally {
              h = null, v = q, y = !1;
            }
            K = void 0;
          }
        } finally {
          K ? P() : R = !1;
        }
      }
    }
    var P;
    if (typeof _ == "function")
      P = function() {
        _(B);
      };
    else if (typeof MessageChannel < "u") {
      var W = new MessageChannel(), I = W.port2;
      W.port1.onmessage = B, P = function() {
        I.postMessage(null);
      };
    } else
      P = function() {
        k(B, 0);
      };
    function G(L, K) {
      j = k(function() {
        L(e.unstable_now());
      }, K);
    }
    e.unstable_IdlePriority = 5, e.unstable_ImmediatePriority = 1, e.unstable_LowPriority = 4, e.unstable_NormalPriority = 3, e.unstable_Profiling = null, e.unstable_UserBlockingPriority = 2, e.unstable_cancelCallback = function(L) {
      L.callback = null;
    }, e.unstable_forceFrameRate = function(L) {
      0 > L || 125 < L ? console.error(
        "forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"
      ) : D = 0 < L ? Math.floor(1e3 / L) : 5;
    }, e.unstable_getCurrentPriorityLevel = function() {
      return v;
    }, e.unstable_next = function(L) {
      switch (v) {
        case 1:
        case 2:
        case 3:
          var K = 3;
          break;
        default:
          K = v;
      }
      var q = v;
      v = K;
      try {
        return L();
      } finally {
        v = q;
      }
    }, e.unstable_requestPaint = function() {
      b = !0;
    }, e.unstable_runWithPriority = function(L, K) {
      switch (L) {
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
          break;
        default:
          L = 3;
      }
      var q = v;
      v = L;
      try {
        return K();
      } finally {
        v = q;
      }
    }, e.unstable_scheduleCallback = function(L, K, q) {
      var Z = e.unstable_now();
      switch (typeof q == "object" && q !== null ? (q = q.delay, q = typeof q == "number" && 0 < q ? Z + q : Z) : q = Z, L) {
        case 1:
          var V = -1;
          break;
        case 2:
          V = 250;
          break;
        case 5:
          V = 1073741823;
          break;
        case 4:
          V = 1e4;
          break;
        default:
          V = 5e3;
      }
      return V = q + V, L = {
        id: m++,
        callback: K,
        priorityLevel: L,
        startTime: q,
        expirationTime: V,
        sortIndex: -1
      }, q > Z ? (L.sortIndex = q, t(p, L), n(d) === null && L === n(p) && (x ? (C(j), j = -1) : x = !0, G(N, q - Z))) : (L.sortIndex = V, t(d, L), w || y || (w = !0, R || (R = !0, P()))), L;
    }, e.unstable_shouldYield = z, e.unstable_wrapCallback = function(L) {
      var K = v;
      return function() {
        var q = v;
        v = K;
        try {
          return L.apply(this, arguments);
        } finally {
          v = q;
        }
      };
    };
  })(VN)), VN;
}
var g1;
function a9e() {
  return g1 || (g1 = 1, UN.exports = o9e()), UN.exports;
}
var v1;
function i9e() {
  if (v1) return Mw;
  v1 = 1;
  var e = a9e(), t = P3(), n = w1();
  function r(o) {
    var i = "https://react.dev/errors/" + o;
    if (1 < arguments.length) {
      i += "?args[]=" + encodeURIComponent(arguments[1]);
      for (var u = 2; u < arguments.length; u++)
        i += "&args[]=" + encodeURIComponent(arguments[u]);
    }
    return "Minified React error #" + o + "; visit " + i + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
  }
  function a(o) {
    return !(!o || o.nodeType !== 1 && o.nodeType !== 9 && o.nodeType !== 11);
  }
  function s(o) {
    var i = o, u = o;
    if (o.alternate) for (; i.return; ) i = i.return;
    else {
      o = i;
      do
        i = o, (i.flags & 4098) !== 0 && (u = i.return), o = i.return;
      while (o);
    }
    return i.tag === 3 ? u : null;
  }
  function l(o) {
    if (o.tag === 13) {
      var i = o.memoizedState;
      if (i === null && (o = o.alternate, o !== null && (i = o.memoizedState)), i !== null) return i.dehydrated;
    }
    return null;
  }
  function c(o) {
    if (o.tag === 31) {
      var i = o.memoizedState;
      if (i === null && (o = o.alternate, o !== null && (i = o.memoizedState)), i !== null) return i.dehydrated;
    }
    return null;
  }
  function d(o) {
    if (s(o) !== o)
      throw Error(r(188));
  }
  function p(o) {
    var i = o.alternate;
    if (!i) {
      if (i = s(o), i === null) throw Error(r(188));
      return i !== o ? null : o;
    }
    for (var u = o, f = i; ; ) {
      var g = u.return;
      if (g === null) break;
      var S = g.alternate;
      if (S === null) {
        if (f = g.return, f !== null) {
          u = f;
          continue;
        }
        break;
      }
      if (g.child === S.child) {
        for (S = g.child; S; ) {
          if (S === u) return d(g), o;
          if (S === f) return d(g), i;
          S = S.sibling;
        }
        throw Error(r(188));
      }
      if (u.return !== f.return) u = g, f = S;
      else {
        for (var A = !1, T = g.child; T; ) {
          if (T === u) {
            A = !0, u = g, f = S;
            break;
          }
          if (T === f) {
            A = !0, f = g, u = S;
            break;
          }
          T = T.sibling;
        }
        if (!A) {
          for (T = S.child; T; ) {
            if (T === u) {
              A = !0, u = S, f = g;
              break;
            }
            if (T === f) {
              A = !0, f = S, u = g;
              break;
            }
            T = T.sibling;
          }
          if (!A) throw Error(r(189));
        }
      }
      if (u.alternate !== f) throw Error(r(190));
    }
    if (u.tag !== 3) throw Error(r(188));
    return u.stateNode.current === u ? o : i;
  }
  function m(o) {
    var i = o.tag;
    if (i === 5 || i === 26 || i === 27 || i === 6) return o;
    for (o = o.child; o !== null; ) {
      if (i = m(o), i !== null) return i;
      o = o.sibling;
    }
    return null;
  }
  var h = Object.assign, v = /* @__PURE__ */ Symbol.for("react.element"), y = /* @__PURE__ */ Symbol.for("react.transitional.element"), w = /* @__PURE__ */ Symbol.for("react.portal"), x = /* @__PURE__ */ Symbol.for("react.fragment"), b = /* @__PURE__ */ Symbol.for("react.strict_mode"), k = /* @__PURE__ */ Symbol.for("react.profiler"), C = /* @__PURE__ */ Symbol.for("react.consumer"), _ = /* @__PURE__ */ Symbol.for("react.context"), O = /* @__PURE__ */ Symbol.for("react.forward_ref"), N = /* @__PURE__ */ Symbol.for("react.suspense"), R = /* @__PURE__ */ Symbol.for("react.suspense_list"), j = /* @__PURE__ */ Symbol.for("react.memo"), D = /* @__PURE__ */ Symbol.for("react.lazy"), $ = /* @__PURE__ */ Symbol.for("react.activity"), z = /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel"), B = Symbol.iterator;
  function P(o) {
    return o === null || typeof o != "object" ? null : (o = B && o[B] || o["@@iterator"], typeof o == "function" ? o : null);
  }
  var W = /* @__PURE__ */ Symbol.for("react.client.reference");
  function I(o) {
    if (o == null) return null;
    if (typeof o == "function")
      return o.$$typeof === W ? null : o.displayName || o.name || null;
    if (typeof o == "string") return o;
    switch (o) {
      case x:
        return "Fragment";
      case k:
        return "Profiler";
      case b:
        return "StrictMode";
      case N:
        return "Suspense";
      case R:
        return "SuspenseList";
      case $:
        return "Activity";
    }
    if (typeof o == "object")
      switch (o.$$typeof) {
        case w:
          return "Portal";
        case _:
          return o.displayName || "Context";
        case C:
          return (o._context.displayName || "Context") + ".Consumer";
        case O:
          var i = o.render;
          return o = o.displayName, o || (o = i.displayName || i.name || "", o = o !== "" ? "ForwardRef(" + o + ")" : "ForwardRef"), o;
        case j:
          return i = o.displayName || null, i !== null ? i : I(o.type) || "Memo";
        case D:
          i = o._payload, o = o._init;
          try {
            return I(o(i));
          } catch {
          }
      }
    return null;
  }
  var G = Array.isArray, L = t.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, K = n.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, q = {
    pending: !1,
    data: null,
    method: null,
    action: null
  }, Z = [], V = -1;
  function F(o) {
    return { current: o };
  }
  function X(o) {
    0 > V || (o.current = Z[V], Z[V] = null, V--);
  }
  function U(o, i) {
    V++, Z[V] = o.current, o.current = i;
  }
  var H = F(null), Q = F(null), re = F(null), de = F(null);
  function le(o, i) {
    switch (U(re, i), U(Q, o), U(H, null), i.nodeType) {
      case 9:
      case 11:
        o = (o = i.documentElement) && (o = o.namespaceURI) ? Ob(o) : 0;
        break;
      default:
        if (o = i.tagName, i = i.namespaceURI)
          i = Ob(i), o = Mb(i, o);
        else
          switch (o) {
            case "svg":
              o = 1;
              break;
            case "math":
              o = 2;
              break;
            default:
              o = 0;
          }
    }
    X(H), U(H, o);
  }
  function me() {
    X(H), X(Q), X(re);
  }
  function ve(o) {
    o.memoizedState !== null && U(de, o);
    var i = H.current, u = Mb(i, o.type);
    i !== u && (U(Q, o), U(H, u));
  }
  function ae(o) {
    Q.current === o && (X(H), X(Q)), de.current === o && (X(de), Es._currentValue = q);
  }
  var se, pe;
  function ge(o) {
    if (se === void 0)
      try {
        throw Error();
      } catch (u) {
        var i = u.stack.trim().match(/\n( *(at )?)/);
        se = i && i[1] || "", pe = -1 < u.stack.indexOf(`
    at`) ? " (<anonymous>)" : -1 < u.stack.indexOf("@") ? "@unknown:0:0" : "";
      }
    return `
` + se + o + pe;
  }
  var xe = !1;
  function _e(o, i) {
    if (!o || xe) return "";
    xe = !0;
    var u = Error.prepareStackTrace;
    Error.prepareStackTrace = void 0;
    try {
      var f = {
        DetermineComponentFrameRoot: function() {
          try {
            if (i) {
              var fe = function() {
                throw Error();
              };
              if (Object.defineProperty(fe.prototype, "props", {
                set: function() {
                  throw Error();
                }
              }), typeof Reflect == "object" && Reflect.construct) {
                try {
                  Reflect.construct(fe, []);
                } catch (ie) {
                  var oe = ie;
                }
                Reflect.construct(o, [], fe);
              } else {
                try {
                  fe.call();
                } catch (ie) {
                  oe = ie;
                }
                o.call(fe.prototype);
              }
            } else {
              try {
                throw Error();
              } catch (ie) {
                oe = ie;
              }
              (fe = o()) && typeof fe.catch == "function" && fe.catch(function() {
              });
            }
          } catch (ie) {
            if (ie && oe && typeof ie.stack == "string")
              return [ie.stack, oe.stack];
          }
          return [null, null];
        }
      };
      f.DetermineComponentFrameRoot.displayName = "DetermineComponentFrameRoot";
      var g = Object.getOwnPropertyDescriptor(
        f.DetermineComponentFrameRoot,
        "name"
      );
      g && g.configurable && Object.defineProperty(
        f.DetermineComponentFrameRoot,
        "name",
        { value: "DetermineComponentFrameRoot" }
      );
      var S = f.DetermineComponentFrameRoot(), A = S[0], T = S[1];
      if (A && T) {
        var Y = A.split(`
`), ne = T.split(`
`);
        for (g = f = 0; f < Y.length && !Y[f].includes("DetermineComponentFrameRoot"); )
          f++;
        for (; g < ne.length && !ne[g].includes(
          "DetermineComponentFrameRoot"
        ); )
          g++;
        if (f === Y.length || g === ne.length)
          for (f = Y.length - 1, g = ne.length - 1; 1 <= f && 0 <= g && Y[f] !== ne[g]; )
            g--;
        for (; 1 <= f && 0 <= g; f--, g--)
          if (Y[f] !== ne[g]) {
            if (f !== 1 || g !== 1)
              do
                if (f--, g--, 0 > g || Y[f] !== ne[g]) {
                  var ue = `
` + Y[f].replace(" at new ", " at ");
                  return o.displayName && ue.includes("<anonymous>") && (ue = ue.replace("<anonymous>", o.displayName)), ue;
                }
              while (1 <= f && 0 <= g);
            break;
          }
      }
    } finally {
      xe = !1, Error.prepareStackTrace = u;
    }
    return (u = o ? o.displayName || o.name : "") ? ge(u) : "";
  }
  function We(o, i) {
    switch (o.tag) {
      case 26:
      case 27:
      case 5:
        return ge(o.type);
      case 16:
        return ge("Lazy");
      case 13:
        return o.child !== i && i !== null ? ge("Suspense Fallback") : ge("Suspense");
      case 19:
        return ge("SuspenseList");
      case 0:
      case 15:
        return _e(o.type, !1);
      case 11:
        return _e(o.type.render, !1);
      case 1:
        return _e(o.type, !0);
      case 31:
        return ge("Activity");
      default:
        return "";
    }
  }
  function Xe(o) {
    try {
      var i = "", u = null;
      do
        i += We(o, u), u = o, o = o.return;
      while (o);
      return i;
    } catch (f) {
      return `
Error generating stack: ` + f.message + `
` + f.stack;
    }
  }
  var et = Object.prototype.hasOwnProperty, tt = e.unstable_scheduleCallback, je = e.unstable_cancelCallback, an = e.unstable_shouldYield, dt = e.unstable_requestPaint, Ce = e.unstable_now, Me = e.unstable_getCurrentPriorityLevel, he = e.unstable_ImmediatePriority, ye = e.unstable_UserBlockingPriority, Ee = e.unstable_NormalPriority, Le = e.unstable_LowPriority, ze = e.unstable_IdlePriority, It = e.log, zt = e.unstable_setDisableYieldValue, Wt = null, Ot = null;
  function bn(o) {
    if (typeof It == "function" && zt(o), Ot && typeof Ot.setStrictMode == "function")
      try {
        Ot.setStrictMode(Wt, o);
      } catch {
      }
  }
  var Re = Math.clz32 ? Math.clz32 : To, Ft = Math.log, Xt = Math.LN2;
  function To(o) {
    return o >>>= 0, o === 0 ? 32 : 31 - (Ft(o) / Xt | 0) | 0;
  }
  var Lo = 256, dn = 262144, kn = 4194304;
  function wr(o) {
    var i = o & 42;
    if (i !== 0) return i;
    switch (o & -o) {
      case 1:
        return 1;
      case 2:
        return 2;
      case 4:
        return 4;
      case 8:
        return 8;
      case 16:
        return 16;
      case 32:
        return 32;
      case 64:
        return 64;
      case 128:
        return 128;
      case 256:
      case 512:
      case 1024:
      case 2048:
      case 4096:
      case 8192:
      case 16384:
      case 32768:
      case 65536:
      case 131072:
        return o & 261888;
      case 262144:
      case 524288:
      case 1048576:
      case 2097152:
        return o & 3932160;
      case 4194304:
      case 8388608:
      case 16777216:
      case 33554432:
        return o & 62914560;
      case 67108864:
        return 67108864;
      case 134217728:
        return 134217728;
      case 268435456:
        return 268435456;
      case 536870912:
        return 536870912;
      case 1073741824:
        return 0;
      default:
        return o;
    }
  }
  function Io(o, i, u) {
    var f = o.pendingLanes;
    if (f === 0) return 0;
    var g = 0, S = o.suspendedLanes, A = o.pingedLanes;
    o = o.warmLanes;
    var T = f & 134217727;
    return T !== 0 ? (f = T & ~S, f !== 0 ? g = wr(f) : (A &= T, A !== 0 ? g = wr(A) : u || (u = T & ~o, u !== 0 && (g = wr(u))))) : (T = f & ~S, T !== 0 ? g = wr(T) : A !== 0 ? g = wr(A) : u || (u = f & ~o, u !== 0 && (g = wr(u)))), g === 0 ? 0 : i !== 0 && i !== g && (i & S) === 0 && (S = g & -g, u = i & -i, S >= u || S === 32 && (u & 4194048) !== 0) ? i : g;
  }
  function pr(o, i) {
    return (o.pendingLanes & ~(o.suspendedLanes & ~o.pingedLanes) & i) === 0;
  }
  function hg(o, i) {
    switch (o) {
      case 1:
      case 2:
      case 4:
      case 8:
      case 64:
        return i + 250;
      case 16:
      case 32:
      case 128:
      case 256:
      case 512:
      case 1024:
      case 2048:
      case 4096:
      case 8192:
      case 16384:
      case 32768:
      case 65536:
      case 131072:
      case 262144:
      case 524288:
      case 1048576:
      case 2097152:
        return i + 5e3;
      case 4194304:
      case 8388608:
      case 16777216:
      case 33554432:
        return -1;
      case 67108864:
      case 134217728:
      case 268435456:
      case 536870912:
      case 1073741824:
        return -1;
      default:
        return -1;
    }
  }
  function xd() {
    var o = kn;
    return kn <<= 1, (kn & 62914560) === 0 && (kn = 4194304), o;
  }
  function zl(o) {
    for (var i = [], u = 0; 31 > u; u++) i.push(o);
    return i;
  }
  function ja(o, i) {
    o.pendingLanes |= i, i !== 268435456 && (o.suspendedLanes = 0, o.pingedLanes = 0, o.warmLanes = 0);
  }
  function gg(o, i, u, f, g, S) {
    var A = o.pendingLanes;
    o.pendingLanes = u, o.suspendedLanes = 0, o.pingedLanes = 0, o.warmLanes = 0, o.expiredLanes &= u, o.entangledLanes &= u, o.errorRecoveryDisabledLanes &= u, o.shellSuspendCounter = 0;
    var T = o.entanglements, Y = o.expirationTimes, ne = o.hiddenUpdates;
    for (u = A & ~u; 0 < u; ) {
      var ue = 31 - Re(u), fe = 1 << ue;
      T[ue] = 0, Y[ue] = -1;
      var oe = ne[ue];
      if (oe !== null)
        for (ne[ue] = null, ue = 0; ue < oe.length; ue++) {
          var ie = oe[ue];
          ie !== null && (ie.lane &= -536870913);
        }
      u &= ~fe;
    }
    f !== 0 && Sd(o, f, 0), S !== 0 && g === 0 && o.tag !== 0 && (o.suspendedLanes |= S & ~(A & ~i));
  }
  function Sd(o, i, u) {
    o.pendingLanes |= i, o.suspendedLanes &= ~i;
    var f = 31 - Re(i);
    o.entangledLanes |= i, o.entanglements[f] = o.entanglements[f] | 1073741824 | u & 261930;
  }
  function kd(o, i) {
    var u = o.entangledLanes |= i;
    for (o = o.entanglements; u; ) {
      var f = 31 - Re(u), g = 1 << f;
      g & i | o[f] & i && (o[f] |= i), u &= ~g;
    }
  }
  function _d(o, i) {
    var u = i & -i;
    return u = (u & 42) !== 0 ? 1 : Fl(u), (u & (o.suspendedLanes | i)) !== 0 ? 0 : u;
  }
  function Fl(o) {
    switch (o) {
      case 2:
        o = 1;
        break;
      case 8:
        o = 4;
        break;
      case 32:
        o = 16;
        break;
      case 256:
      case 512:
      case 1024:
      case 2048:
      case 4096:
      case 8192:
      case 16384:
      case 32768:
      case 65536:
      case 131072:
      case 262144:
      case 524288:
      case 1048576:
      case 2097152:
      case 4194304:
      case 8388608:
      case 16777216:
      case 33554432:
        o = 128;
        break;
      case 268435456:
        o = 134217728;
        break;
      default:
        o = 0;
    }
    return o;
  }
  function Bl(o) {
    return o &= -o, 2 < o ? 8 < o ? (o & 134217727) !== 0 ? 32 : 268435456 : 8 : 2;
  }
  function Ed() {
    var o = K.p;
    return o !== 0 ? o : (o = window.event, o === void 0 ? 32 : Qb(o.type));
  }
  function Cd(o, i) {
    var u = K.p;
    try {
      return K.p = o, i();
    } finally {
      K.p = u;
    }
  }
  var Dr = Math.random().toString(36).slice(2), Yt = "__reactFiber$" + Dr, mn = "__reactProps$" + Dr, zo = "__reactContainer$" + Dr, Xs = "__reactEvents$" + Dr, Tm = "__reactListeners$" + Dr, vg = "__reactHandles$" + Dr, Od = "__reactResources$" + Dr, Pa = "__reactMarker$" + Dr;
  function Ul(o) {
    delete o[Yt], delete o[mn], delete o[Xs], delete o[Tm], delete o[vg];
  }
  function Qo(o) {
    var i = o[Yt];
    if (i) return i;
    for (var u = o.parentNode; u; ) {
      if (i = u[zo] || u[Yt]) {
        if (u = i.alternate, i.child !== null || u !== null && u.child !== null)
          for (o = $b(o); o !== null; ) {
            if (u = o[Yt]) return u;
            o = $b(o);
          }
        return i;
      }
      o = u, u = o.parentNode;
    }
    return null;
  }
  function Jo(o) {
    if (o = o[Yt] || o[zo]) {
      var i = o.tag;
      if (i === 5 || i === 6 || i === 13 || i === 31 || i === 26 || i === 27 || i === 3)
        return o;
    }
    return null;
  }
  function ka(o) {
    var i = o.tag;
    if (i === 5 || i === 26 || i === 27 || i === 6) return o.stateNode;
    throw Error(r(33));
  }
  function Zo(o) {
    var i = o[Od];
    return i || (i = o[Od] = { hoistableStyles: /* @__PURE__ */ new Map(), hoistableScripts: /* @__PURE__ */ new Map() }), i;
  }
  function Bt(o) {
    o[Pa] = !0;
  }
  var Md = /* @__PURE__ */ new Set(), Nd = {};
  function oo(o, i) {
    ea(o, i), ea(o + "Capture", i);
  }
  function ea(o, i) {
    for (Nd[o] = i, o = 0; o < i.length; o++)
      Md.add(i[o]);
  }
  var yg = RegExp(
    "^[:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD][:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"
  ), Lc = {}, Rd = {};
  function bg(o) {
    return et.call(Rd, o) ? !0 : et.call(Lc, o) ? !1 : yg.test(o) ? Rd[o] = !0 : (Lc[o] = !0, !1);
  }
  function zi(o, i, u) {
    if (bg(i))
      if (u === null) o.removeAttribute(i);
      else {
        switch (typeof u) {
          case "undefined":
          case "function":
          case "symbol":
            o.removeAttribute(i);
            return;
          case "boolean":
            var f = i.toLowerCase().slice(0, 5);
            if (f !== "data-" && f !== "aria-") {
              o.removeAttribute(i);
              return;
            }
        }
        o.setAttribute(i, "" + u);
      }
  }
  function Fi(o, i, u) {
    if (u === null) o.removeAttribute(i);
    else {
      switch (typeof u) {
        case "undefined":
        case "function":
        case "symbol":
        case "boolean":
          o.removeAttribute(i);
          return;
      }
      o.setAttribute(i, "" + u);
    }
  }
  function xr(o, i, u, f) {
    if (f === null) o.removeAttribute(u);
    else {
      switch (typeof f) {
        case "undefined":
        case "function":
        case "symbol":
        case "boolean":
          o.removeAttribute(u);
          return;
      }
      o.setAttributeNS(i, u, "" + f);
    }
  }
  function Tn(o) {
    switch (typeof o) {
      case "bigint":
      case "boolean":
      case "number":
      case "string":
      case "undefined":
        return o;
      case "object":
        return o;
      default:
        return "";
    }
  }
  function Ad(o) {
    var i = o.type;
    return (o = o.nodeName) && o.toLowerCase() === "input" && (i === "checkbox" || i === "radio");
  }
  function wg(o, i, u) {
    var f = Object.getOwnPropertyDescriptor(
      o.constructor.prototype,
      i
    );
    if (!o.hasOwnProperty(i) && typeof f < "u" && typeof f.get == "function" && typeof f.set == "function") {
      var g = f.get, S = f.set;
      return Object.defineProperty(o, i, {
        configurable: !0,
        get: function() {
          return g.call(this);
        },
        set: function(A) {
          u = "" + A, S.call(this, A);
        }
      }), Object.defineProperty(o, i, {
        enumerable: f.enumerable
      }), {
        getValue: function() {
          return u;
        },
        setValue: function(A) {
          u = "" + A;
        },
        stopTracking: function() {
          o._valueTracker = null, delete o[i];
        }
      };
    }
  }
  function Ys(o) {
    if (!o._valueTracker) {
      var i = Ad(o) ? "checked" : "value";
      o._valueTracker = wg(
        o,
        i,
        "" + o[i]
      );
    }
  }
  function jd(o) {
    if (!o) return !1;
    var i = o._valueTracker;
    if (!i) return !0;
    var u = i.getValue(), f = "";
    return o && (f = Ad(o) ? o.checked ? "true" : "false" : o.value), o = f, o !== u ? (i.setValue(o), !0) : !1;
  }
  function Ei(o) {
    if (o = o || (typeof document < "u" ? document : void 0), typeof o > "u") return null;
    try {
      return o.activeElement || o.body;
    } catch {
      return o.body;
    }
  }
  var xg = /[\n"\\]/g;
  function Gn(o) {
    return o.replace(
      xg,
      function(i) {
        return "\\" + i.charCodeAt(0).toString(16) + " ";
      }
    );
  }
  function Bi(o, i, u, f, g, S, A, T) {
    o.name = "", A != null && typeof A != "function" && typeof A != "symbol" && typeof A != "boolean" ? o.type = A : o.removeAttribute("type"), i != null ? A === "number" ? (i === 0 && o.value === "" || o.value != i) && (o.value = "" + Tn(i)) : o.value !== "" + Tn(i) && (o.value = "" + Tn(i)) : A !== "submit" && A !== "reset" || o.removeAttribute("value"), i != null ? Vl(o, A, Tn(i)) : u != null ? Vl(o, A, Tn(u)) : f != null && o.removeAttribute("value"), g == null && S != null && (o.defaultChecked = !!S), g != null && (o.checked = g && typeof g != "function" && typeof g != "symbol"), T != null && typeof T != "function" && typeof T != "symbol" && typeof T != "boolean" ? o.name = "" + Tn(T) : o.removeAttribute("name");
  }
  function Pd(o, i, u, f, g, S, A, T) {
    if (S != null && typeof S != "function" && typeof S != "symbol" && typeof S != "boolean" && (o.type = S), i != null || u != null) {
      if (!(S !== "submit" && S !== "reset" || i != null)) {
        Ys(o);
        return;
      }
      u = u != null ? "" + Tn(u) : "", i = i != null ? "" + Tn(i) : u, T || i === o.value || (o.value = i), o.defaultValue = i;
    }
    f = f ?? g, f = typeof f != "function" && typeof f != "symbol" && !!f, o.checked = T ? o.checked : !!f, o.defaultChecked = !!f, A != null && typeof A != "function" && typeof A != "symbol" && typeof A != "boolean" && (o.name = A), Ys(o);
  }
  function Vl(o, i, u) {
    i === "number" && Ei(o.ownerDocument) === o || o.defaultValue === "" + u || (o.defaultValue = "" + u);
  }
  function Fo(o, i, u, f) {
    if (o = o.options, i) {
      i = {};
      for (var g = 0; g < u.length; g++)
        i["$" + u[g]] = !0;
      for (u = 0; u < o.length; u++)
        g = i.hasOwnProperty("$" + o[u].value), o[u].selected !== g && (o[u].selected = g), g && f && (o[u].defaultSelected = !0);
    } else {
      for (u = "" + Tn(u), i = null, g = 0; g < o.length; g++) {
        if (o[g].value === u) {
          o[g].selected = !0, f && (o[g].defaultSelected = !0);
          return;
        }
        i !== null || o[g].disabled || (i = o[g]);
      }
      i !== null && (i.selected = !0);
    }
  }
  function Sg(o, i, u) {
    if (i != null && (i = "" + Tn(i), i !== o.value && (o.value = i), u == null)) {
      o.defaultValue !== i && (o.defaultValue = i);
      return;
    }
    o.defaultValue = u != null ? "" + Tn(u) : "";
  }
  function kg(o, i, u, f) {
    if (i == null) {
      if (f != null) {
        if (u != null) throw Error(r(92));
        if (G(f)) {
          if (1 < f.length) throw Error(r(93));
          f = f[0];
        }
        u = f;
      }
      u == null && (u = ""), i = u;
    }
    u = Tn(i), o.defaultValue = u, f = o.textContent, f === u && f !== "" && f !== null && (o.value = f), Ys(o);
  }
  function Da(o, i) {
    if (i) {
      var u = o.firstChild;
      if (u && u === o.lastChild && u.nodeType === 3) {
        u.nodeValue = i;
        return;
      }
    }
    o.textContent = i;
  }
  var TE = new Set(
    "animationIterationCount aspectRatio borderImageOutset borderImageSlice borderImageWidth boxFlex boxFlexGroup boxOrdinalGroup columnCount columns flex flexGrow flexPositive flexShrink flexNegative flexOrder gridArea gridRow gridRowEnd gridRowSpan gridRowStart gridColumn gridColumnEnd gridColumnSpan gridColumnStart fontWeight lineClamp lineHeight opacity order orphans scale tabSize widows zIndex zoom fillOpacity floodOpacity stopOpacity strokeDasharray strokeDashoffset strokeMiterlimit strokeOpacity strokeWidth MozAnimationIterationCount MozBoxFlex MozBoxFlexGroup MozLineClamp msAnimationIterationCount msFlex msZoom msFlexGrow msFlexNegative msFlexOrder msFlexPositive msFlexShrink msGridColumn msGridColumnSpan msGridRow msGridRowSpan WebkitAnimationIterationCount WebkitBoxFlex WebKitBoxFlexGroup WebkitBoxOrdinalGroup WebkitColumnCount WebkitColumns WebkitFlex WebkitFlexGrow WebkitFlexPositive WebkitFlexShrink WebkitLineClamp".split(
      " "
    )
  );
  function _g(o, i, u) {
    var f = i.indexOf("--") === 0;
    u == null || typeof u == "boolean" || u === "" ? f ? o.setProperty(i, "") : i === "float" ? o.cssFloat = "" : o[i] = "" : f ? o.setProperty(i, u) : typeof u != "number" || u === 0 || TE.has(i) ? i === "float" ? o.cssFloat = u : o[i] = ("" + u).trim() : o[i] = u + "px";
  }
  function Eg(o, i, u) {
    if (i != null && typeof i != "object")
      throw Error(r(62));
    if (o = o.style, u != null) {
      for (var f in u)
        !u.hasOwnProperty(f) || i != null && i.hasOwnProperty(f) || (f.indexOf("--") === 0 ? o.setProperty(f, "") : f === "float" ? o.cssFloat = "" : o[f] = "");
      for (var g in i)
        f = i[g], i.hasOwnProperty(g) && u[g] !== f && _g(o, g, f);
    } else
      for (var S in i)
        i.hasOwnProperty(S) && _g(o, S, i[S]);
  }
  function Dd(o) {
    if (o.indexOf("-") === -1) return !1;
    switch (o) {
      case "annotation-xml":
      case "color-profile":
      case "font-face":
      case "font-face-src":
      case "font-face-uri":
      case "font-face-format":
      case "font-face-name":
      case "missing-glyph":
        return !1;
      default:
        return !0;
    }
  }
  var LE = /* @__PURE__ */ new Map([
    ["acceptCharset", "accept-charset"],
    ["htmlFor", "for"],
    ["httpEquiv", "http-equiv"],
    ["crossOrigin", "crossorigin"],
    ["accentHeight", "accent-height"],
    ["alignmentBaseline", "alignment-baseline"],
    ["arabicForm", "arabic-form"],
    ["baselineShift", "baseline-shift"],
    ["capHeight", "cap-height"],
    ["clipPath", "clip-path"],
    ["clipRule", "clip-rule"],
    ["colorInterpolation", "color-interpolation"],
    ["colorInterpolationFilters", "color-interpolation-filters"],
    ["colorProfile", "color-profile"],
    ["colorRendering", "color-rendering"],
    ["dominantBaseline", "dominant-baseline"],
    ["enableBackground", "enable-background"],
    ["fillOpacity", "fill-opacity"],
    ["fillRule", "fill-rule"],
    ["floodColor", "flood-color"],
    ["floodOpacity", "flood-opacity"],
    ["fontFamily", "font-family"],
    ["fontSize", "font-size"],
    ["fontSizeAdjust", "font-size-adjust"],
    ["fontStretch", "font-stretch"],
    ["fontStyle", "font-style"],
    ["fontVariant", "font-variant"],
    ["fontWeight", "font-weight"],
    ["glyphName", "glyph-name"],
    ["glyphOrientationHorizontal", "glyph-orientation-horizontal"],
    ["glyphOrientationVertical", "glyph-orientation-vertical"],
    ["horizAdvX", "horiz-adv-x"],
    ["horizOriginX", "horiz-origin-x"],
    ["imageRendering", "image-rendering"],
    ["letterSpacing", "letter-spacing"],
    ["lightingColor", "lighting-color"],
    ["markerEnd", "marker-end"],
    ["markerMid", "marker-mid"],
    ["markerStart", "marker-start"],
    ["overlinePosition", "overline-position"],
    ["overlineThickness", "overline-thickness"],
    ["paintOrder", "paint-order"],
    ["panose-1", "panose-1"],
    ["pointerEvents", "pointer-events"],
    ["renderingIntent", "rendering-intent"],
    ["shapeRendering", "shape-rendering"],
    ["stopColor", "stop-color"],
    ["stopOpacity", "stop-opacity"],
    ["strikethroughPosition", "strikethrough-position"],
    ["strikethroughThickness", "strikethrough-thickness"],
    ["strokeDasharray", "stroke-dasharray"],
    ["strokeDashoffset", "stroke-dashoffset"],
    ["strokeLinecap", "stroke-linecap"],
    ["strokeLinejoin", "stroke-linejoin"],
    ["strokeMiterlimit", "stroke-miterlimit"],
    ["strokeOpacity", "stroke-opacity"],
    ["strokeWidth", "stroke-width"],
    ["textAnchor", "text-anchor"],
    ["textDecoration", "text-decoration"],
    ["textRendering", "text-rendering"],
    ["transformOrigin", "transform-origin"],
    ["underlinePosition", "underline-position"],
    ["underlineThickness", "underline-thickness"],
    ["unicodeBidi", "unicode-bidi"],
    ["unicodeRange", "unicode-range"],
    ["unitsPerEm", "units-per-em"],
    ["vAlphabetic", "v-alphabetic"],
    ["vHanging", "v-hanging"],
    ["vIdeographic", "v-ideographic"],
    ["vMathematical", "v-mathematical"],
    ["vectorEffect", "vector-effect"],
    ["vertAdvY", "vert-adv-y"],
    ["vertOriginX", "vert-origin-x"],
    ["vertOriginY", "vert-origin-y"],
    ["wordSpacing", "word-spacing"],
    ["writingMode", "writing-mode"],
    ["xmlnsXlink", "xmlns:xlink"],
    ["xHeight", "x-height"]
  ]), IE = /^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*:/i;
  function Hl(o) {
    return IE.test("" + o) ? "javascript:throw new Error('React has blocked a javascript: URL as a security precaution.')" : o;
  }
  function $r() {
  }
  var $d = null;
  function Td(o) {
    return o = o.target || o.srcElement || window, o.correspondingUseElement && (o = o.correspondingUseElement), o.nodeType === 3 ? o.parentNode : o;
  }
  var $a = null, Ta = null;
  function Cg(o) {
    var i = Jo(o);
    if (i && (o = i.stateNode)) {
      var u = o[mn] || null;
      e: switch (o = i.stateNode, i.type) {
        case "input":
          if (Bi(
            o,
            u.value,
            u.defaultValue,
            u.defaultValue,
            u.checked,
            u.defaultChecked,
            u.type,
            u.name
          ), i = u.name, u.type === "radio" && i != null) {
            for (u = o; u.parentNode; ) u = u.parentNode;
            for (u = u.querySelectorAll(
              'input[name="' + Gn(
                "" + i
              ) + '"][type="radio"]'
            ), i = 0; i < u.length; i++) {
              var f = u[i];
              if (f !== o && f.form === o.form) {
                var g = f[mn] || null;
                if (!g) throw Error(r(90));
                Bi(
                  f,
                  g.value,
                  g.defaultValue,
                  g.defaultValue,
                  g.checked,
                  g.defaultChecked,
                  g.type,
                  g.name
                );
              }
            }
            for (i = 0; i < u.length; i++)
              f = u[i], f.form === o.form && jd(f);
          }
          break e;
        case "textarea":
          Sg(o, u.value, u.defaultValue);
          break e;
        case "select":
          i = u.value, i != null && Fo(o, !!u.multiple, i, !1);
      }
    }
  }
  var Ld = !1;
  function Og(o, i, u) {
    if (Ld) return o(i, u);
    Ld = !0;
    try {
      var f = o(i);
      return f;
    } finally {
      if (Ld = !1, ($a !== null || Ta !== null) && (Au(), $a && (i = $a, o = Ta, Ta = $a = null, Cg(i), o)))
        for (i = 0; i < o.length; i++) Cg(o[i]);
    }
  }
  function Ui(o, i) {
    var u = o.stateNode;
    if (u === null) return null;
    var f = u[mn] || null;
    if (f === null) return null;
    u = f[i];
    e: switch (i) {
      case "onClick":
      case "onClickCapture":
      case "onDoubleClick":
      case "onDoubleClickCapture":
      case "onMouseDown":
      case "onMouseDownCapture":
      case "onMouseMove":
      case "onMouseMoveCapture":
      case "onMouseUp":
      case "onMouseUpCapture":
      case "onMouseEnter":
        (f = !f.disabled) || (o = o.type, f = !(o === "button" || o === "input" || o === "select" || o === "textarea")), o = !f;
        break e;
      default:
        o = !1;
    }
    if (o) return null;
    if (u && typeof u != "function")
      throw Error(
        r(231, i, typeof u)
      );
    return u;
  }
  var Tr = !(typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u"), Id = !1;
  if (Tr)
    try {
      var Vi = {};
      Object.defineProperty(Vi, "passive", {
        get: function() {
          Id = !0;
        }
      }), window.addEventListener("test", Vi, Vi), window.removeEventListener("test", Vi, Vi);
    } catch {
      Id = !1;
    }
  var ao = null, zd = null, ql = null;
  function Mg() {
    if (ql) return ql;
    var o, i = zd, u = i.length, f, g = "value" in ao ? ao.value : ao.textContent, S = g.length;
    for (o = 0; o < u && i[o] === g[o]; o++) ;
    var A = u - o;
    for (f = 1; f <= A && i[u - f] === g[S - f]; f++) ;
    return ql = g.slice(o, 1 < f ? 1 - f : void 0);
  }
  function Wl(o) {
    var i = o.keyCode;
    return "charCode" in o ? (o = o.charCode, o === 0 && i === 13 && (o = 13)) : o = i, o === 10 && (o = 13), 32 <= o || o === 13 ? o : 0;
  }
  function Gl() {
    return !0;
  }
  function Ng() {
    return !1;
  }
  function _n(o) {
    function i(u, f, g, S, A) {
      this._reactName = u, this._targetInst = g, this.type = f, this.nativeEvent = S, this.target = A, this.currentTarget = null;
      for (var T in o)
        o.hasOwnProperty(T) && (u = o[T], this[T] = u ? u(S) : S[T]);
      return this.isDefaultPrevented = (S.defaultPrevented != null ? S.defaultPrevented : S.returnValue === !1) ? Gl : Ng, this.isPropagationStopped = Ng, this;
    }
    return h(i.prototype, {
      preventDefault: function() {
        this.defaultPrevented = !0;
        var u = this.nativeEvent;
        u && (u.preventDefault ? u.preventDefault() : typeof u.returnValue != "unknown" && (u.returnValue = !1), this.isDefaultPrevented = Gl);
      },
      stopPropagation: function() {
        var u = this.nativeEvent;
        u && (u.stopPropagation ? u.stopPropagation() : typeof u.cancelBubble != "unknown" && (u.cancelBubble = !0), this.isPropagationStopped = Gl);
      },
      persist: function() {
      },
      isPersistent: Gl
    }), i;
  }
  var ta = {
    eventPhase: 0,
    bubbles: 0,
    cancelable: 0,
    timeStamp: function(o) {
      return o.timeStamp || Date.now();
    },
    defaultPrevented: 0,
    isTrusted: 0
  }, Kl = _n(ta), Hi = h({}, ta, { view: 0, detail: 0 }), zE = _n(Hi), Fd, Bd, qi, Xl = h({}, Hi, {
    screenX: 0,
    screenY: 0,
    clientX: 0,
    clientY: 0,
    pageX: 0,
    pageY: 0,
    ctrlKey: 0,
    shiftKey: 0,
    altKey: 0,
    metaKey: 0,
    getModifierState: Vd,
    button: 0,
    buttons: 0,
    relatedTarget: function(o) {
      return o.relatedTarget === void 0 ? o.fromElement === o.srcElement ? o.toElement : o.fromElement : o.relatedTarget;
    },
    movementX: function(o) {
      return "movementX" in o ? o.movementX : (o !== qi && (qi && o.type === "mousemove" ? (Fd = o.screenX - qi.screenX, Bd = o.screenY - qi.screenY) : Bd = Fd = 0, qi = o), Fd);
    },
    movementY: function(o) {
      return "movementY" in o ? o.movementY : Bd;
    }
  }), Rg = _n(Xl), FE = h({}, Xl, { dataTransfer: 0 }), BE = _n(FE), UE = h({}, Hi, { relatedTarget: 0 }), Ud = _n(UE), VE = h({}, ta, {
    animationName: 0,
    elapsedTime: 0,
    pseudoElement: 0
  }), HE = _n(VE), qE = h({}, ta, {
    clipboardData: function(o) {
      return "clipboardData" in o ? o.clipboardData : window.clipboardData;
    }
  }), WE = _n(qE), GE = h({}, ta, { data: 0 }), Ag = _n(GE), KE = {
    Esc: "Escape",
    Spacebar: " ",
    Left: "ArrowLeft",
    Up: "ArrowUp",
    Right: "ArrowRight",
    Down: "ArrowDown",
    Del: "Delete",
    Win: "OS",
    Menu: "ContextMenu",
    Apps: "ContextMenu",
    Scroll: "ScrollLock",
    MozPrintableKey: "Unidentified"
  }, XE = {
    8: "Backspace",
    9: "Tab",
    12: "Clear",
    13: "Enter",
    16: "Shift",
    17: "Control",
    18: "Alt",
    19: "Pause",
    20: "CapsLock",
    27: "Escape",
    32: " ",
    33: "PageUp",
    34: "PageDown",
    35: "End",
    36: "Home",
    37: "ArrowLeft",
    38: "ArrowUp",
    39: "ArrowRight",
    40: "ArrowDown",
    45: "Insert",
    46: "Delete",
    112: "F1",
    113: "F2",
    114: "F3",
    115: "F4",
    116: "F5",
    117: "F6",
    118: "F7",
    119: "F8",
    120: "F9",
    121: "F10",
    122: "F11",
    123: "F12",
    144: "NumLock",
    145: "ScrollLock",
    224: "Meta"
  }, YE = {
    Alt: "altKey",
    Control: "ctrlKey",
    Meta: "metaKey",
    Shift: "shiftKey"
  };
  function QE(o) {
    var i = this.nativeEvent;
    return i.getModifierState ? i.getModifierState(o) : (o = YE[o]) ? !!i[o] : !1;
  }
  function Vd() {
    return QE;
  }
  var JE = h({}, Hi, {
    key: function(o) {
      if (o.key) {
        var i = KE[o.key] || o.key;
        if (i !== "Unidentified") return i;
      }
      return o.type === "keypress" ? (o = Wl(o), o === 13 ? "Enter" : String.fromCharCode(o)) : o.type === "keydown" || o.type === "keyup" ? XE[o.keyCode] || "Unidentified" : "";
    },
    code: 0,
    location: 0,
    ctrlKey: 0,
    shiftKey: 0,
    altKey: 0,
    metaKey: 0,
    repeat: 0,
    locale: 0,
    getModifierState: Vd,
    charCode: function(o) {
      return o.type === "keypress" ? Wl(o) : 0;
    },
    keyCode: function(o) {
      return o.type === "keydown" || o.type === "keyup" ? o.keyCode : 0;
    },
    which: function(o) {
      return o.type === "keypress" ? Wl(o) : o.type === "keydown" || o.type === "keyup" ? o.keyCode : 0;
    }
  }), ZE = _n(JE), eC = h({}, Xl, {
    pointerId: 0,
    width: 0,
    height: 0,
    pressure: 0,
    tangentialPressure: 0,
    tiltX: 0,
    tiltY: 0,
    twist: 0,
    pointerType: 0,
    isPrimary: 0
  }), jg = _n(eC), tC = h({}, Hi, {
    touches: 0,
    targetTouches: 0,
    changedTouches: 0,
    altKey: 0,
    metaKey: 0,
    ctrlKey: 0,
    shiftKey: 0,
    getModifierState: Vd
  }), nC = _n(tC), rC = h({}, ta, {
    propertyName: 0,
    elapsedTime: 0,
    pseudoElement: 0
  }), oC = _n(rC), aC = h({}, Xl, {
    deltaX: function(o) {
      return "deltaX" in o ? o.deltaX : "wheelDeltaX" in o ? -o.wheelDeltaX : 0;
    },
    deltaY: function(o) {
      return "deltaY" in o ? o.deltaY : "wheelDeltaY" in o ? -o.wheelDeltaY : "wheelDelta" in o ? -o.wheelDelta : 0;
    },
    deltaZ: 0,
    deltaMode: 0
  }), iC = _n(aC), sC = h({}, ta, {
    newState: 0,
    oldState: 0
  }), lC = _n(sC), uC = [9, 13, 27, 32], Hd = Tr && "CompositionEvent" in window, Wi = null;
  Tr && "documentMode" in document && (Wi = document.documentMode);
  var cC = Tr && "TextEvent" in window && !Wi, Pg = Tr && (!Hd || Wi && 8 < Wi && 11 >= Wi), Dg = " ", $g = !1;
  function Tg(o, i) {
    switch (o) {
      case "keyup":
        return uC.indexOf(i.keyCode) !== -1;
      case "keydown":
        return i.keyCode !== 229;
      case "keypress":
      case "mousedown":
      case "focusout":
        return !0;
      default:
        return !1;
    }
  }
  function Lg(o) {
    return o = o.detail, typeof o == "object" && "data" in o ? o.data : null;
  }
  var La = !1;
  function dC(o, i) {
    switch (o) {
      case "compositionend":
        return Lg(i);
      case "keypress":
        return i.which !== 32 ? null : ($g = !0, Dg);
      case "textInput":
        return o = i.data, o === Dg && $g ? null : o;
      default:
        return null;
    }
  }
  function fC(o, i) {
    if (La)
      return o === "compositionend" || !Hd && Tg(o, i) ? (o = Mg(), ql = zd = ao = null, La = !1, o) : null;
    switch (o) {
      case "paste":
        return null;
      case "keypress":
        if (!(i.ctrlKey || i.altKey || i.metaKey) || i.ctrlKey && i.altKey) {
          if (i.char && 1 < i.char.length)
            return i.char;
          if (i.which) return String.fromCharCode(i.which);
        }
        return null;
      case "compositionend":
        return Pg && i.locale !== "ko" ? null : i.data;
      default:
        return null;
    }
  }
  var pC = {
    color: !0,
    date: !0,
    datetime: !0,
    "datetime-local": !0,
    email: !0,
    month: !0,
    number: !0,
    password: !0,
    range: !0,
    search: !0,
    tel: !0,
    text: !0,
    time: !0,
    url: !0,
    week: !0
  };
  function Ig(o) {
    var i = o && o.nodeName && o.nodeName.toLowerCase();
    return i === "input" ? !!pC[o.type] : i === "textarea";
  }
  function zg(o, i, u, f) {
    $a ? Ta ? Ta.push(f) : Ta = [f] : $a = f, i = Iu(i, "onChange"), 0 < i.length && (u = new Kl(
      "onChange",
      "change",
      null,
      u,
      f
    ), o.push({ event: u, listeners: i }));
  }
  var Gi = null, Ki = null;
  function mC(o) {
    xb(o, 0);
  }
  function Yl(o) {
    var i = ka(o);
    if (jd(i)) return o;
  }
  function Fg(o, i) {
    if (o === "change") return i;
  }
  var Bg = !1;
  if (Tr) {
    var qd;
    if (Tr) {
      var Wd = "oninput" in document;
      if (!Wd) {
        var Ug = document.createElement("div");
        Ug.setAttribute("oninput", "return;"), Wd = typeof Ug.oninput == "function";
      }
      qd = Wd;
    } else qd = !1;
    Bg = qd && (!document.documentMode || 9 < document.documentMode);
  }
  function Vg() {
    Gi && (Gi.detachEvent("onpropertychange", Hg), Ki = Gi = null);
  }
  function Hg(o) {
    if (o.propertyName === "value" && Yl(Ki)) {
      var i = [];
      zg(
        i,
        Ki,
        o,
        Td(o)
      ), Og(mC, i);
    }
  }
  function hC(o, i, u) {
    o === "focusin" ? (Vg(), Gi = i, Ki = u, Gi.attachEvent("onpropertychange", Hg)) : o === "focusout" && Vg();
  }
  function gC(o) {
    if (o === "selectionchange" || o === "keyup" || o === "keydown")
      return Yl(Ki);
  }
  function vC(o, i) {
    if (o === "click") return Yl(i);
  }
  function yC(o, i) {
    if (o === "input" || o === "change")
      return Yl(i);
  }
  function bC(o, i) {
    return o === i && (o !== 0 || 1 / o === 1 / i) || o !== o && i !== i;
  }
  var Ln = typeof Object.is == "function" ? Object.is : bC;
  function Xi(o, i) {
    if (Ln(o, i)) return !0;
    if (typeof o != "object" || o === null || typeof i != "object" || i === null)
      return !1;
    var u = Object.keys(o), f = Object.keys(i);
    if (u.length !== f.length) return !1;
    for (f = 0; f < u.length; f++) {
      var g = u[f];
      if (!et.call(i, g) || !Ln(o[g], i[g]))
        return !1;
    }
    return !0;
  }
  function qg(o) {
    for (; o && o.firstChild; ) o = o.firstChild;
    return o;
  }
  function Wg(o, i) {
    var u = qg(o);
    o = 0;
    for (var f; u; ) {
      if (u.nodeType === 3) {
        if (f = o + u.textContent.length, o <= i && f >= i)
          return { node: u, offset: i - o };
        o = f;
      }
      e: {
        for (; u; ) {
          if (u.nextSibling) {
            u = u.nextSibling;
            break e;
          }
          u = u.parentNode;
        }
        u = void 0;
      }
      u = qg(u);
    }
  }
  function Gg(o, i) {
    return o && i ? o === i ? !0 : o && o.nodeType === 3 ? !1 : i && i.nodeType === 3 ? Gg(o, i.parentNode) : "contains" in o ? o.contains(i) : o.compareDocumentPosition ? !!(o.compareDocumentPosition(i) & 16) : !1 : !1;
  }
  function Kg(o) {
    o = o != null && o.ownerDocument != null && o.ownerDocument.defaultView != null ? o.ownerDocument.defaultView : window;
    for (var i = Ei(o.document); i instanceof o.HTMLIFrameElement; ) {
      try {
        var u = typeof i.contentWindow.location.href == "string";
      } catch {
        u = !1;
      }
      if (u) o = i.contentWindow;
      else break;
      i = Ei(o.document);
    }
    return i;
  }
  function Gd(o) {
    var i = o && o.nodeName && o.nodeName.toLowerCase();
    return i && (i === "input" && (o.type === "text" || o.type === "search" || o.type === "tel" || o.type === "url" || o.type === "password") || i === "textarea" || o.contentEditable === "true");
  }
  var wC = Tr && "documentMode" in document && 11 >= document.documentMode, Ia = null, Kd = null, Yi = null, Xd = !1;
  function Xg(o, i, u) {
    var f = u.window === u ? u.document : u.nodeType === 9 ? u : u.ownerDocument;
    Xd || Ia == null || Ia !== Ei(f) || (f = Ia, "selectionStart" in f && Gd(f) ? f = { start: f.selectionStart, end: f.selectionEnd } : (f = (f.ownerDocument && f.ownerDocument.defaultView || window).getSelection(), f = {
      anchorNode: f.anchorNode,
      anchorOffset: f.anchorOffset,
      focusNode: f.focusNode,
      focusOffset: f.focusOffset
    }), Yi && Xi(Yi, f) || (Yi = f, f = Iu(Kd, "onSelect"), 0 < f.length && (i = new Kl(
      "onSelect",
      "select",
      null,
      i,
      u
    ), o.push({ event: i, listeners: f }), i.target = Ia)));
  }
  function na(o, i) {
    var u = {};
    return u[o.toLowerCase()] = i.toLowerCase(), u["Webkit" + o] = "webkit" + i, u["Moz" + o] = "moz" + i, u;
  }
  var za = {
    animationend: na("Animation", "AnimationEnd"),
    animationiteration: na("Animation", "AnimationIteration"),
    animationstart: na("Animation", "AnimationStart"),
    transitionrun: na("Transition", "TransitionRun"),
    transitionstart: na("Transition", "TransitionStart"),
    transitioncancel: na("Transition", "TransitionCancel"),
    transitionend: na("Transition", "TransitionEnd")
  }, Yd = {}, Yg = {};
  Tr && (Yg = document.createElement("div").style, "AnimationEvent" in window || (delete za.animationend.animation, delete za.animationiteration.animation, delete za.animationstart.animation), "TransitionEvent" in window || delete za.transitionend.transition);
  function ra(o) {
    if (Yd[o]) return Yd[o];
    if (!za[o]) return o;
    var i = za[o], u;
    for (u in i)
      if (i.hasOwnProperty(u) && u in Yg)
        return Yd[o] = i[u];
    return o;
  }
  var Qg = ra("animationend"), Jg = ra("animationiteration"), Zg = ra("animationstart"), xC = ra("transitionrun"), SC = ra("transitionstart"), kC = ra("transitioncancel"), ev = ra("transitionend"), tv = /* @__PURE__ */ new Map(), Qd = "abort auxClick beforeToggle cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(
    " "
  );
  Qd.push("scrollEnd");
  function mr(o, i) {
    tv.set(o, i), oo(i, [o]);
  }
  var Ql = typeof reportError == "function" ? reportError : function(o) {
    if (typeof window == "object" && typeof window.ErrorEvent == "function") {
      var i = new window.ErrorEvent("error", {
        bubbles: !0,
        cancelable: !0,
        message: typeof o == "object" && o !== null && typeof o.message == "string" ? String(o.message) : String(o),
        error: o
      });
      if (!window.dispatchEvent(i)) return;
    } else if (typeof process == "object" && typeof process.emit == "function") {
      process.emit("uncaughtException", o);
      return;
    }
    console.error(o);
  }, Jn = [], Fa = 0, Jd = 0;
  function Jl() {
    for (var o = Fa, i = Jd = Fa = 0; i < o; ) {
      var u = Jn[i];
      Jn[i++] = null;
      var f = Jn[i];
      Jn[i++] = null;
      var g = Jn[i];
      Jn[i++] = null;
      var S = Jn[i];
      if (Jn[i++] = null, f !== null && g !== null) {
        var A = f.pending;
        A === null ? g.next = g : (g.next = A.next, A.next = g), f.pending = g;
      }
      S !== 0 && nv(u, g, S);
    }
  }
  function Zl(o, i, u, f) {
    Jn[Fa++] = o, Jn[Fa++] = i, Jn[Fa++] = u, Jn[Fa++] = f, Jd |= f, o.lanes |= f, o = o.alternate, o !== null && (o.lanes |= f);
  }
  function Zd(o, i, u, f) {
    return Zl(o, i, u, f), eu(o);
  }
  function oa(o, i) {
    return Zl(o, null, null, i), eu(o);
  }
  function nv(o, i, u) {
    o.lanes |= u;
    var f = o.alternate;
    f !== null && (f.lanes |= u);
    for (var g = !1, S = o.return; S !== null; )
      S.childLanes |= u, f = S.alternate, f !== null && (f.childLanes |= u), S.tag === 22 && (o = S.stateNode, o === null || o._visibility & 1 || (g = !0)), o = S, S = S.return;
    return o.tag === 3 ? (S = o.stateNode, g && i !== null && (g = 31 - Re(u), o = S.hiddenUpdates, f = o[g], f === null ? o[g] = [i] : f.push(i), i.lane = u | 536870912), S) : null;
  }
  function eu(o) {
    if (50 < ys)
      throw ys = 0, up = null, Error(r(185));
    for (var i = o.return; i !== null; )
      o = i, i = o.return;
    return o.tag === 3 ? o.stateNode : null;
  }
  var Ba = {};
  function _C(o, i, u, f) {
    this.tag = o, this.key = u, this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null, this.index = 0, this.refCleanup = this.ref = null, this.pendingProps = i, this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null, this.mode = f, this.subtreeFlags = this.flags = 0, this.deletions = null, this.childLanes = this.lanes = 0, this.alternate = null;
  }
  function In(o, i, u, f) {
    return new _C(o, i, u, f);
  }
  function ef(o) {
    return o = o.prototype, !(!o || !o.isReactComponent);
  }
  function Lr(o, i) {
    var u = o.alternate;
    return u === null ? (u = In(
      o.tag,
      i,
      o.key,
      o.mode
    ), u.elementType = o.elementType, u.type = o.type, u.stateNode = o.stateNode, u.alternate = o, o.alternate = u) : (u.pendingProps = i, u.type = o.type, u.flags = 0, u.subtreeFlags = 0, u.deletions = null), u.flags = o.flags & 65011712, u.childLanes = o.childLanes, u.lanes = o.lanes, u.child = o.child, u.memoizedProps = o.memoizedProps, u.memoizedState = o.memoizedState, u.updateQueue = o.updateQueue, i = o.dependencies, u.dependencies = i === null ? null : { lanes: i.lanes, firstContext: i.firstContext }, u.sibling = o.sibling, u.index = o.index, u.ref = o.ref, u.refCleanup = o.refCleanup, u;
  }
  function rv(o, i) {
    o.flags &= 65011714;
    var u = o.alternate;
    return u === null ? (o.childLanes = 0, o.lanes = i, o.child = null, o.subtreeFlags = 0, o.memoizedProps = null, o.memoizedState = null, o.updateQueue = null, o.dependencies = null, o.stateNode = null) : (o.childLanes = u.childLanes, o.lanes = u.lanes, o.child = u.child, o.subtreeFlags = 0, o.deletions = null, o.memoizedProps = u.memoizedProps, o.memoizedState = u.memoizedState, o.updateQueue = u.updateQueue, o.type = u.type, i = u.dependencies, o.dependencies = i === null ? null : {
      lanes: i.lanes,
      firstContext: i.firstContext
    }), o;
  }
  function tu(o, i, u, f, g, S) {
    var A = 0;
    if (f = o, typeof o == "function") ef(o) && (A = 1);
    else if (typeof o == "string")
      A = NO(
        o,
        u,
        H.current
      ) ? 26 : o === "html" || o === "head" || o === "body" ? 27 : 5;
    else
      e: switch (o) {
        case $:
          return o = In(31, u, i, g), o.elementType = $, o.lanes = S, o;
        case x:
          return aa(u.children, g, S, i);
        case b:
          A = 8, g |= 24;
          break;
        case k:
          return o = In(12, u, i, g | 2), o.elementType = k, o.lanes = S, o;
        case N:
          return o = In(13, u, i, g), o.elementType = N, o.lanes = S, o;
        case R:
          return o = In(19, u, i, g), o.elementType = R, o.lanes = S, o;
        default:
          if (typeof o == "object" && o !== null)
            switch (o.$$typeof) {
              case _:
                A = 10;
                break e;
              case C:
                A = 9;
                break e;
              case O:
                A = 11;
                break e;
              case j:
                A = 14;
                break e;
              case D:
                A = 16, f = null;
                break e;
            }
          A = 29, u = Error(
            r(130, o === null ? "null" : typeof o, "")
          ), f = null;
      }
    return i = In(A, u, i, g), i.elementType = o, i.type = f, i.lanes = S, i;
  }
  function aa(o, i, u, f) {
    return o = In(7, o, f, i), o.lanes = u, o;
  }
  function tf(o, i, u) {
    return o = In(6, o, null, i), o.lanes = u, o;
  }
  function ov(o) {
    var i = In(18, null, null, 0);
    return i.stateNode = o, i;
  }
  function nf(o, i, u) {
    return i = In(
      4,
      o.children !== null ? o.children : [],
      o.key,
      i
    ), i.lanes = u, i.stateNode = {
      containerInfo: o.containerInfo,
      pendingChildren: null,
      implementation: o.implementation
    }, i;
  }
  var av = /* @__PURE__ */ new WeakMap();
  function Zn(o, i) {
    if (typeof o == "object" && o !== null) {
      var u = av.get(o);
      return u !== void 0 ? u : (i = {
        value: o,
        source: i,
        stack: Xe(i)
      }, av.set(o, i), i);
    }
    return {
      value: o,
      source: i,
      stack: Xe(i)
    };
  }
  var Ua = [], Va = 0, nu = null, Qi = 0, er = [], tr = 0, io = null, Sr = 1, kr = "";
  function Ir(o, i) {
    Ua[Va++] = Qi, Ua[Va++] = nu, nu = o, Qi = i;
  }
  function iv(o, i, u) {
    er[tr++] = Sr, er[tr++] = kr, er[tr++] = io, io = o;
    var f = Sr;
    o = kr;
    var g = 32 - Re(f) - 1;
    f &= ~(1 << g), u += 1;
    var S = 32 - Re(i) + g;
    if (30 < S) {
      var A = g - g % 5;
      S = (f & (1 << A) - 1).toString(32), f >>= A, g -= A, Sr = 1 << 32 - Re(i) + g | u << g | f, kr = S + o;
    } else
      Sr = 1 << S | u << g | f, kr = o;
  }
  function rf(o) {
    o.return !== null && (Ir(o, 1), iv(o, 1, 0));
  }
  function of(o) {
    for (; o === nu; )
      nu = Ua[--Va], Ua[Va] = null, Qi = Ua[--Va], Ua[Va] = null;
    for (; o === io; )
      io = er[--tr], er[tr] = null, kr = er[--tr], er[tr] = null, Sr = er[--tr], er[tr] = null;
  }
  function sv(o, i) {
    er[tr++] = Sr, er[tr++] = kr, er[tr++] = io, Sr = i.id, kr = i.overflow, io = o;
  }
  var en = null, gt = null, Ge = !1, so = null, nr = !1, af = Error(r(519));
  function lo(o) {
    var i = Error(
      r(
        418,
        1 < arguments.length && arguments[1] !== void 0 && arguments[1] ? "text" : "HTML",
        ""
      )
    );
    throw Ji(Zn(i, o)), af;
  }
  function lv(o) {
    var i = o.stateNode, u = o.type, f = o.memoizedProps;
    switch (i[Yt] = o, i[mn] = f, u) {
      case "dialog":
        Be("cancel", i), Be("close", i);
        break;
      case "iframe":
      case "object":
      case "embed":
        Be("load", i);
        break;
      case "video":
      case "audio":
        for (u = 0; u < ws.length; u++)
          Be(ws[u], i);
        break;
      case "source":
        Be("error", i);
        break;
      case "img":
      case "image":
      case "link":
        Be("error", i), Be("load", i);
        break;
      case "details":
        Be("toggle", i);
        break;
      case "input":
        Be("invalid", i), Pd(
          i,
          f.value,
          f.defaultValue,
          f.checked,
          f.defaultChecked,
          f.type,
          f.name,
          !0
        );
        break;
      case "select":
        Be("invalid", i);
        break;
      case "textarea":
        Be("invalid", i), kg(i, f.value, f.defaultValue, f.children);
    }
    u = f.children, typeof u != "string" && typeof u != "number" && typeof u != "bigint" || i.textContent === "" + u || f.suppressHydrationWarning === !0 || Eb(i.textContent, u) ? (f.popover != null && (Be("beforetoggle", i), Be("toggle", i)), f.onScroll != null && Be("scroll", i), f.onScrollEnd != null && Be("scrollend", i), f.onClick != null && (i.onclick = $r), i = !0) : i = !1, i || lo(o, !0);
  }
  function uv(o) {
    for (en = o.return; en; )
      switch (en.tag) {
        case 5:
        case 31:
        case 13:
          nr = !1;
          return;
        case 27:
        case 3:
          nr = !0;
          return;
        default:
          en = en.return;
      }
  }
  function Ha(o) {
    if (o !== en) return !1;
    if (!Ge) return uv(o), Ge = !0, !1;
    var i = o.tag, u;
    if ((u = i !== 3 && i !== 27) && ((u = i === 5) && (u = o.type, u = !(u !== "form" && u !== "button") || _p(o.type, o.memoizedProps)), u = !u), u && gt && lo(o), uv(o), i === 13) {
      if (o = o.memoizedState, o = o !== null ? o.dehydrated : null, !o) throw Error(r(317));
      gt = Db(o);
    } else if (i === 31) {
      if (o = o.memoizedState, o = o !== null ? o.dehydrated : null, !o) throw Error(r(317));
      gt = Db(o);
    } else
      i === 27 ? (i = gt, ko(o.type) ? (o = Np, Np = null, gt = o) : gt = i) : gt = en ? rr(o.stateNode.nextSibling) : null;
    return !0;
  }
  function ia() {
    gt = en = null, Ge = !1;
  }
  function sf() {
    var o = so;
    return o !== null && (Mn === null ? Mn = o : Mn.push.apply(
      Mn,
      o
    ), so = null), o;
  }
  function Ji(o) {
    so === null ? so = [o] : so.push(o);
  }
  var lf = F(null), sa = null, zr = null;
  function uo(o, i, u) {
    U(lf, i._currentValue), i._currentValue = u;
  }
  function Fr(o) {
    o._currentValue = lf.current, X(lf);
  }
  function uf(o, i, u) {
    for (; o !== null; ) {
      var f = o.alternate;
      if ((o.childLanes & i) !== i ? (o.childLanes |= i, f !== null && (f.childLanes |= i)) : f !== null && (f.childLanes & i) !== i && (f.childLanes |= i), o === u) break;
      o = o.return;
    }
  }
  function cf(o, i, u, f) {
    var g = o.child;
    for (g !== null && (g.return = o); g !== null; ) {
      var S = g.dependencies;
      if (S !== null) {
        var A = g.child;
        S = S.firstContext;
        e: for (; S !== null; ) {
          var T = S;
          S = g;
          for (var Y = 0; Y < i.length; Y++)
            if (T.context === i[Y]) {
              S.lanes |= u, T = S.alternate, T !== null && (T.lanes |= u), uf(
                S.return,
                u,
                o
              ), f || (A = null);
              break e;
            }
          S = T.next;
        }
      } else if (g.tag === 18) {
        if (A = g.return, A === null) throw Error(r(341));
        A.lanes |= u, S = A.alternate, S !== null && (S.lanes |= u), uf(A, u, o), A = null;
      } else A = g.child;
      if (A !== null) A.return = g;
      else
        for (A = g; A !== null; ) {
          if (A === o) {
            A = null;
            break;
          }
          if (g = A.sibling, g !== null) {
            g.return = A.return, A = g;
            break;
          }
          A = A.return;
        }
      g = A;
    }
  }
  function qa(o, i, u, f) {
    o = null;
    for (var g = i, S = !1; g !== null; ) {
      if (!S) {
        if ((g.flags & 524288) !== 0) S = !0;
        else if ((g.flags & 262144) !== 0) break;
      }
      if (g.tag === 10) {
        var A = g.alternate;
        if (A === null) throw Error(r(387));
        if (A = A.memoizedProps, A !== null) {
          var T = g.type;
          Ln(g.pendingProps.value, A.value) || (o !== null ? o.push(T) : o = [T]);
        }
      } else if (g === de.current) {
        if (A = g.alternate, A === null) throw Error(r(387));
        A.memoizedState.memoizedState !== g.memoizedState.memoizedState && (o !== null ? o.push(Es) : o = [Es]);
      }
      g = g.return;
    }
    o !== null && cf(
      i,
      o,
      u,
      f
    ), i.flags |= 262144;
  }
  function ru(o) {
    for (o = o.firstContext; o !== null; ) {
      if (!Ln(
        o.context._currentValue,
        o.memoizedValue
      ))
        return !0;
      o = o.next;
    }
    return !1;
  }
  function la(o) {
    sa = o, zr = null, o = o.dependencies, o !== null && (o.firstContext = null);
  }
  function tn(o) {
    return cv(sa, o);
  }
  function ou(o, i) {
    return sa === null && la(o), cv(o, i);
  }
  function cv(o, i) {
    var u = i._currentValue;
    if (i = { context: i, memoizedValue: u, next: null }, zr === null) {
      if (o === null) throw Error(r(308));
      zr = i, o.dependencies = { lanes: 0, firstContext: i }, o.flags |= 524288;
    } else zr = zr.next = i;
    return u;
  }
  var EC = typeof AbortController < "u" ? AbortController : function() {
    var o = [], i = this.signal = {
      aborted: !1,
      addEventListener: function(u, f) {
        o.push(f);
      }
    };
    this.abort = function() {
      i.aborted = !0, o.forEach(function(u) {
        return u();
      });
    };
  }, CC = e.unstable_scheduleCallback, OC = e.unstable_NormalPriority, jt = {
    $$typeof: _,
    Consumer: null,
    Provider: null,
    _currentValue: null,
    _currentValue2: null,
    _threadCount: 0
  };
  function df() {
    return {
      controller: new EC(),
      data: /* @__PURE__ */ new Map(),
      refCount: 0
    };
  }
  function Zi(o) {
    o.refCount--, o.refCount === 0 && CC(OC, function() {
      o.controller.abort();
    });
  }
  var es = null, ff = 0, Wa = 0, Ga = null;
  function MC(o, i) {
    if (es === null) {
      var u = es = [];
      ff = 0, Wa = hp(), Ga = {
        status: "pending",
        value: void 0,
        then: function(f) {
          u.push(f);
        }
      };
    }
    return ff++, i.then(dv, dv), i;
  }
  function dv() {
    if (--ff === 0 && es !== null) {
      Ga !== null && (Ga.status = "fulfilled");
      var o = es;
      es = null, Wa = 0, Ga = null;
      for (var i = 0; i < o.length; i++) (0, o[i])();
    }
  }
  function NC(o, i) {
    var u = [], f = {
      status: "pending",
      value: null,
      reason: null,
      then: function(g) {
        u.push(g);
      }
    };
    return o.then(
      function() {
        f.status = "fulfilled", f.value = i;
        for (var g = 0; g < u.length; g++) (0, u[g])(i);
      },
      function(g) {
        for (f.status = "rejected", f.reason = g, g = 0; g < u.length; g++)
          (0, u[g])(void 0);
      }
    ), f;
  }
  var fv = L.S;
  L.S = function(o, i) {
    Xy = Ce(), typeof i == "object" && i !== null && typeof i.then == "function" && MC(o, i), fv !== null && fv(o, i);
  };
  var ua = F(null);
  function pf() {
    var o = ua.current;
    return o !== null ? o : lt.pooledCache;
  }
  function au(o, i) {
    i === null ? U(ua, ua.current) : U(ua, i.pool);
  }
  function pv() {
    var o = pf();
    return o === null ? null : { parent: jt._currentValue, pool: o };
  }
  var Ka = Error(r(460)), mf = Error(r(474)), iu = Error(r(542)), su = { then: function() {
  } };
  function mv(o) {
    return o = o.status, o === "fulfilled" || o === "rejected";
  }
  function hv(o, i, u) {
    switch (u = o[u], u === void 0 ? o.push(i) : u !== i && (i.then($r, $r), i = u), i.status) {
      case "fulfilled":
        return i.value;
      case "rejected":
        throw o = i.reason, vv(o), o;
      default:
        if (typeof i.status == "string") i.then($r, $r);
        else {
          if (o = lt, o !== null && 100 < o.shellSuspendCounter)
            throw Error(r(482));
          o = i, o.status = "pending", o.then(
            function(f) {
              if (i.status === "pending") {
                var g = i;
                g.status = "fulfilled", g.value = f;
              }
            },
            function(f) {
              if (i.status === "pending") {
                var g = i;
                g.status = "rejected", g.reason = f;
              }
            }
          );
        }
        switch (i.status) {
          case "fulfilled":
            return i.value;
          case "rejected":
            throw o = i.reason, vv(o), o;
        }
        throw da = i, Ka;
    }
  }
  function ca(o) {
    try {
      var i = o._init;
      return i(o._payload);
    } catch (u) {
      throw u !== null && typeof u == "object" && typeof u.then == "function" ? (da = u, Ka) : u;
    }
  }
  var da = null;
  function gv() {
    if (da === null) throw Error(r(459));
    var o = da;
    return da = null, o;
  }
  function vv(o) {
    if (o === Ka || o === iu)
      throw Error(r(483));
  }
  var Xa = null, ts = 0;
  function lu(o) {
    var i = ts;
    return ts += 1, Xa === null && (Xa = []), hv(Xa, o, i);
  }
  function ns(o, i) {
    i = i.props.ref, o.ref = i !== void 0 ? i : null;
  }
  function uu(o, i) {
    throw i.$$typeof === v ? Error(r(525)) : (o = Object.prototype.toString.call(i), Error(
      r(
        31,
        o === "[object Object]" ? "object with keys {" + Object.keys(i).join(", ") + "}" : o
      )
    ));
  }
  function yv(o) {
    function i(ee, J) {
      if (o) {
        var te = ee.deletions;
        te === null ? (ee.deletions = [J], ee.flags |= 16) : te.push(J);
      }
    }
    function u(ee, J) {
      if (!o) return null;
      for (; J !== null; )
        i(ee, J), J = J.sibling;
      return null;
    }
    function f(ee) {
      for (var J = /* @__PURE__ */ new Map(); ee !== null; )
        ee.key !== null ? J.set(ee.key, ee) : J.set(ee.index, ee), ee = ee.sibling;
      return J;
    }
    function g(ee, J) {
      return ee = Lr(ee, J), ee.index = 0, ee.sibling = null, ee;
    }
    function S(ee, J, te) {
      return ee.index = te, o ? (te = ee.alternate, te !== null ? (te = te.index, te < J ? (ee.flags |= 67108866, J) : te) : (ee.flags |= 67108866, J)) : (ee.flags |= 1048576, J);
    }
    function A(ee) {
      return o && ee.alternate === null && (ee.flags |= 67108866), ee;
    }
    function T(ee, J, te, ce) {
      return J === null || J.tag !== 6 ? (J = tf(te, ee.mode, ce), J.return = ee, J) : (J = g(J, te), J.return = ee, J);
    }
    function Y(ee, J, te, ce) {
      var Oe = te.type;
      return Oe === x ? ue(
        ee,
        J,
        te.props.children,
        ce,
        te.key
      ) : J !== null && (J.elementType === Oe || typeof Oe == "object" && Oe !== null && Oe.$$typeof === D && ca(Oe) === J.type) ? (J = g(J, te.props), ns(J, te), J.return = ee, J) : (J = tu(
        te.type,
        te.key,
        te.props,
        null,
        ee.mode,
        ce
      ), ns(J, te), J.return = ee, J);
    }
    function ne(ee, J, te, ce) {
      return J === null || J.tag !== 4 || J.stateNode.containerInfo !== te.containerInfo || J.stateNode.implementation !== te.implementation ? (J = nf(te, ee.mode, ce), J.return = ee, J) : (J = g(J, te.children || []), J.return = ee, J);
    }
    function ue(ee, J, te, ce, Oe) {
      return J === null || J.tag !== 7 ? (J = aa(
        te,
        ee.mode,
        ce,
        Oe
      ), J.return = ee, J) : (J = g(J, te), J.return = ee, J);
    }
    function fe(ee, J, te) {
      if (typeof J == "string" && J !== "" || typeof J == "number" || typeof J == "bigint")
        return J = tf(
          "" + J,
          ee.mode,
          te
        ), J.return = ee, J;
      if (typeof J == "object" && J !== null) {
        switch (J.$$typeof) {
          case y:
            return te = tu(
              J.type,
              J.key,
              J.props,
              null,
              ee.mode,
              te
            ), ns(te, J), te.return = ee, te;
          case w:
            return J = nf(
              J,
              ee.mode,
              te
            ), J.return = ee, J;
          case D:
            return J = ca(J), fe(ee, J, te);
        }
        if (G(J) || P(J))
          return J = aa(
            J,
            ee.mode,
            te,
            null
          ), J.return = ee, J;
        if (typeof J.then == "function")
          return fe(ee, lu(J), te);
        if (J.$$typeof === _)
          return fe(
            ee,
            ou(ee, J),
            te
          );
        uu(ee, J);
      }
      return null;
    }
    function oe(ee, J, te, ce) {
      var Oe = J !== null ? J.key : null;
      if (typeof te == "string" && te !== "" || typeof te == "number" || typeof te == "bigint")
        return Oe !== null ? null : T(ee, J, "" + te, ce);
      if (typeof te == "object" && te !== null) {
        switch (te.$$typeof) {
          case y:
            return te.key === Oe ? Y(ee, J, te, ce) : null;
          case w:
            return te.key === Oe ? ne(ee, J, te, ce) : null;
          case D:
            return te = ca(te), oe(ee, J, te, ce);
        }
        if (G(te) || P(te))
          return Oe !== null ? null : ue(ee, J, te, ce, null);
        if (typeof te.then == "function")
          return oe(
            ee,
            J,
            lu(te),
            ce
          );
        if (te.$$typeof === _)
          return oe(
            ee,
            J,
            ou(ee, te),
            ce
          );
        uu(ee, te);
      }
      return null;
    }
    function ie(ee, J, te, ce, Oe) {
      if (typeof ce == "string" && ce !== "" || typeof ce == "number" || typeof ce == "bigint")
        return ee = ee.get(te) || null, T(J, ee, "" + ce, Oe);
      if (typeof ce == "object" && ce !== null) {
        switch (ce.$$typeof) {
          case y:
            return ee = ee.get(
              ce.key === null ? te : ce.key
            ) || null, Y(J, ee, ce, Oe);
          case w:
            return ee = ee.get(
              ce.key === null ? te : ce.key
            ) || null, ne(J, ee, ce, Oe);
          case D:
            return ce = ca(ce), ie(
              ee,
              J,
              te,
              ce,
              Oe
            );
        }
        if (G(ce) || P(ce))
          return ee = ee.get(te) || null, ue(J, ee, ce, Oe, null);
        if (typeof ce.then == "function")
          return ie(
            ee,
            J,
            te,
            lu(ce),
            Oe
          );
        if (ce.$$typeof === _)
          return ie(
            ee,
            J,
            te,
            ou(J, ce),
            Oe
          );
        uu(J, ce);
      }
      return null;
    }
    function we(ee, J, te, ce) {
      for (var Oe = null, Ye = null, ke = J, Ie = J = 0, He = null; ke !== null && Ie < te.length; Ie++) {
        ke.index > Ie ? (He = ke, ke = null) : He = ke.sibling;
        var Qe = oe(
          ee,
          ke,
          te[Ie],
          ce
        );
        if (Qe === null) {
          ke === null && (ke = He);
          break;
        }
        o && ke && Qe.alternate === null && i(ee, ke), J = S(Qe, J, Ie), Ye === null ? Oe = Qe : Ye.sibling = Qe, Ye = Qe, ke = He;
      }
      if (Ie === te.length)
        return u(ee, ke), Ge && Ir(ee, Ie), Oe;
      if (ke === null) {
        for (; Ie < te.length; Ie++)
          ke = fe(ee, te[Ie], ce), ke !== null && (J = S(
            ke,
            J,
            Ie
          ), Ye === null ? Oe = ke : Ye.sibling = ke, Ye = ke);
        return Ge && Ir(ee, Ie), Oe;
      }
      for (ke = f(ke); Ie < te.length; Ie++)
        He = ie(
          ke,
          ee,
          Ie,
          te[Ie],
          ce
        ), He !== null && (o && He.alternate !== null && ke.delete(
          He.key === null ? Ie : He.key
        ), J = S(
          He,
          J,
          Ie
        ), Ye === null ? Oe = He : Ye.sibling = He, Ye = He);
      return o && ke.forEach(function(Mo) {
        return i(ee, Mo);
      }), Ge && Ir(ee, Ie), Oe;
    }
    function Ne(ee, J, te, ce) {
      if (te == null) throw Error(r(151));
      for (var Oe = null, Ye = null, ke = J, Ie = J = 0, He = null, Qe = te.next(); ke !== null && !Qe.done; Ie++, Qe = te.next()) {
        ke.index > Ie ? (He = ke, ke = null) : He = ke.sibling;
        var Mo = oe(ee, ke, Qe.value, ce);
        if (Mo === null) {
          ke === null && (ke = He);
          break;
        }
        o && ke && Mo.alternate === null && i(ee, ke), J = S(Mo, J, Ie), Ye === null ? Oe = Mo : Ye.sibling = Mo, Ye = Mo, ke = He;
      }
      if (Qe.done)
        return u(ee, ke), Ge && Ir(ee, Ie), Oe;
      if (ke === null) {
        for (; !Qe.done; Ie++, Qe = te.next())
          Qe = fe(ee, Qe.value, ce), Qe !== null && (J = S(Qe, J, Ie), Ye === null ? Oe = Qe : Ye.sibling = Qe, Ye = Qe);
        return Ge && Ir(ee, Ie), Oe;
      }
      for (ke = f(ke); !Qe.done; Ie++, Qe = te.next())
        Qe = ie(ke, ee, Ie, Qe.value, ce), Qe !== null && (o && Qe.alternate !== null && ke.delete(Qe.key === null ? Ie : Qe.key), J = S(Qe, J, Ie), Ye === null ? Oe = Qe : Ye.sibling = Qe, Ye = Qe);
      return o && ke.forEach(function(FO) {
        return i(ee, FO);
      }), Ge && Ir(ee, Ie), Oe;
    }
    function it(ee, J, te, ce) {
      if (typeof te == "object" && te !== null && te.type === x && te.key === null && (te = te.props.children), typeof te == "object" && te !== null) {
        switch (te.$$typeof) {
          case y:
            e: {
              for (var Oe = te.key; J !== null; ) {
                if (J.key === Oe) {
                  if (Oe = te.type, Oe === x) {
                    if (J.tag === 7) {
                      u(
                        ee,
                        J.sibling
                      ), ce = g(
                        J,
                        te.props.children
                      ), ce.return = ee, ee = ce;
                      break e;
                    }
                  } else if (J.elementType === Oe || typeof Oe == "object" && Oe !== null && Oe.$$typeof === D && ca(Oe) === J.type) {
                    u(
                      ee,
                      J.sibling
                    ), ce = g(J, te.props), ns(ce, te), ce.return = ee, ee = ce;
                    break e;
                  }
                  u(ee, J);
                  break;
                } else i(ee, J);
                J = J.sibling;
              }
              te.type === x ? (ce = aa(
                te.props.children,
                ee.mode,
                ce,
                te.key
              ), ce.return = ee, ee = ce) : (ce = tu(
                te.type,
                te.key,
                te.props,
                null,
                ee.mode,
                ce
              ), ns(ce, te), ce.return = ee, ee = ce);
            }
            return A(ee);
          case w:
            e: {
              for (Oe = te.key; J !== null; ) {
                if (J.key === Oe)
                  if (J.tag === 4 && J.stateNode.containerInfo === te.containerInfo && J.stateNode.implementation === te.implementation) {
                    u(
                      ee,
                      J.sibling
                    ), ce = g(J, te.children || []), ce.return = ee, ee = ce;
                    break e;
                  } else {
                    u(ee, J);
                    break;
                  }
                else i(ee, J);
                J = J.sibling;
              }
              ce = nf(te, ee.mode, ce), ce.return = ee, ee = ce;
            }
            return A(ee);
          case D:
            return te = ca(te), it(
              ee,
              J,
              te,
              ce
            );
        }
        if (G(te))
          return we(
            ee,
            J,
            te,
            ce
          );
        if (P(te)) {
          if (Oe = P(te), typeof Oe != "function") throw Error(r(150));
          return te = Oe.call(te), Ne(
            ee,
            J,
            te,
            ce
          );
        }
        if (typeof te.then == "function")
          return it(
            ee,
            J,
            lu(te),
            ce
          );
        if (te.$$typeof === _)
          return it(
            ee,
            J,
            ou(ee, te),
            ce
          );
        uu(ee, te);
      }
      return typeof te == "string" && te !== "" || typeof te == "number" || typeof te == "bigint" ? (te = "" + te, J !== null && J.tag === 6 ? (u(ee, J.sibling), ce = g(J, te), ce.return = ee, ee = ce) : (u(ee, J), ce = tf(te, ee.mode, ce), ce.return = ee, ee = ce), A(ee)) : u(ee, J);
    }
    return function(ee, J, te, ce) {
      try {
        ts = 0;
        var Oe = it(
          ee,
          J,
          te,
          ce
        );
        return Xa = null, Oe;
      } catch (ke) {
        if (ke === Ka || ke === iu) throw ke;
        var Ye = In(29, ke, null, ee.mode);
        return Ye.lanes = ce, Ye.return = ee, Ye;
      }
    };
  }
  var fa = yv(!0), bv = yv(!1), co = !1;
  function hf(o) {
    o.updateQueue = {
      baseState: o.memoizedState,
      firstBaseUpdate: null,
      lastBaseUpdate: null,
      shared: { pending: null, lanes: 0, hiddenCallbacks: null },
      callbacks: null
    };
  }
  function gf(o, i) {
    o = o.updateQueue, i.updateQueue === o && (i.updateQueue = {
      baseState: o.baseState,
      firstBaseUpdate: o.firstBaseUpdate,
      lastBaseUpdate: o.lastBaseUpdate,
      shared: o.shared,
      callbacks: null
    });
  }
  function fo(o) {
    return { lane: o, tag: 0, payload: null, callback: null, next: null };
  }
  function po(o, i, u) {
    var f = o.updateQueue;
    if (f === null) return null;
    if (f = f.shared, (Je & 2) !== 0) {
      var g = f.pending;
      return g === null ? i.next = i : (i.next = g.next, g.next = i), f.pending = i, i = eu(o), nv(o, null, u), i;
    }
    return Zl(o, f, i, u), eu(o);
  }
  function rs(o, i, u) {
    if (i = i.updateQueue, i !== null && (i = i.shared, (u & 4194048) !== 0)) {
      var f = i.lanes;
      f &= o.pendingLanes, u |= f, i.lanes = u, kd(o, u);
    }
  }
  function vf(o, i) {
    var u = o.updateQueue, f = o.alternate;
    if (f !== null && (f = f.updateQueue, u === f)) {
      var g = null, S = null;
      if (u = u.firstBaseUpdate, u !== null) {
        do {
          var A = {
            lane: u.lane,
            tag: u.tag,
            payload: u.payload,
            callback: null,
            next: null
          };
          S === null ? g = S = A : S = S.next = A, u = u.next;
        } while (u !== null);
        S === null ? g = S = i : S = S.next = i;
      } else g = S = i;
      u = {
        baseState: f.baseState,
        firstBaseUpdate: g,
        lastBaseUpdate: S,
        shared: f.shared,
        callbacks: f.callbacks
      }, o.updateQueue = u;
      return;
    }
    o = u.lastBaseUpdate, o === null ? u.firstBaseUpdate = i : o.next = i, u.lastBaseUpdate = i;
  }
  var yf = !1;
  function os() {
    if (yf) {
      var o = Ga;
      if (o !== null) throw o;
    }
  }
  function as(o, i, u, f) {
    yf = !1;
    var g = o.updateQueue;
    co = !1;
    var S = g.firstBaseUpdate, A = g.lastBaseUpdate, T = g.shared.pending;
    if (T !== null) {
      g.shared.pending = null;
      var Y = T, ne = Y.next;
      Y.next = null, A === null ? S = ne : A.next = ne, A = Y;
      var ue = o.alternate;
      ue !== null && (ue = ue.updateQueue, T = ue.lastBaseUpdate, T !== A && (T === null ? ue.firstBaseUpdate = ne : T.next = ne, ue.lastBaseUpdate = Y));
    }
    if (S !== null) {
      var fe = g.baseState;
      A = 0, ue = ne = Y = null, T = S;
      do {
        var oe = T.lane & -536870913, ie = oe !== T.lane;
        if (ie ? (Ve & oe) === oe : (f & oe) === oe) {
          oe !== 0 && oe === Wa && (yf = !0), ue !== null && (ue = ue.next = {
            lane: 0,
            tag: T.tag,
            payload: T.payload,
            callback: null,
            next: null
          });
          e: {
            var we = o, Ne = T;
            oe = i;
            var it = u;
            switch (Ne.tag) {
              case 1:
                if (we = Ne.payload, typeof we == "function") {
                  fe = we.call(it, fe, oe);
                  break e;
                }
                fe = we;
                break e;
              case 3:
                we.flags = we.flags & -65537 | 128;
              case 0:
                if (we = Ne.payload, oe = typeof we == "function" ? we.call(it, fe, oe) : we, oe == null) break e;
                fe = h({}, fe, oe);
                break e;
              case 2:
                co = !0;
            }
          }
          oe = T.callback, oe !== null && (o.flags |= 64, ie && (o.flags |= 8192), ie = g.callbacks, ie === null ? g.callbacks = [oe] : ie.push(oe));
        } else
          ie = {
            lane: oe,
            tag: T.tag,
            payload: T.payload,
            callback: T.callback,
            next: null
          }, ue === null ? (ne = ue = ie, Y = fe) : ue = ue.next = ie, A |= oe;
        if (T = T.next, T === null) {
          if (T = g.shared.pending, T === null)
            break;
          ie = T, T = ie.next, ie.next = null, g.lastBaseUpdate = ie, g.shared.pending = null;
        }
      } while (!0);
      ue === null && (Y = fe), g.baseState = Y, g.firstBaseUpdate = ne, g.lastBaseUpdate = ue, S === null && (g.shared.lanes = 0), yo |= A, o.lanes = A, o.memoizedState = fe;
    }
  }
  function wv(o, i) {
    if (typeof o != "function")
      throw Error(r(191, o));
    o.call(i);
  }
  function xv(o, i) {
    var u = o.callbacks;
    if (u !== null)
      for (o.callbacks = null, o = 0; o < u.length; o++)
        wv(u[o], i);
  }
  var Ya = F(null), cu = F(0);
  function Sv(o, i) {
    o = Xr, U(cu, o), U(Ya, i), Xr = o | i.baseLanes;
  }
  function bf() {
    U(cu, Xr), U(Ya, Ya.current);
  }
  function wf() {
    Xr = cu.current, X(Ya), X(cu);
  }
  var zn = F(null), lr = null;
  function mo(o) {
    var i = o.alternate;
    U(Mt, Mt.current & 1), U(zn, o), lr === null && (i === null || Ya.current !== null || i.memoizedState !== null) && (lr = o);
  }
  function xf(o) {
    U(Mt, Mt.current), U(zn, o), lr === null && (lr = o);
  }
  function kv(o) {
    o.tag === 22 ? (U(Mt, Mt.current), U(zn, o), lr === null && (lr = o)) : ho();
  }
  function ho() {
    U(Mt, Mt.current), U(zn, zn.current);
  }
  function Fn(o) {
    X(zn), lr === o && (lr = null), X(Mt);
  }
  var Mt = F(0);
  function du(o) {
    for (var i = o; i !== null; ) {
      if (i.tag === 13) {
        var u = i.memoizedState;
        if (u !== null && (u = u.dehydrated, u === null || Op(u) || Mp(u)))
          return i;
      } else if (i.tag === 19 && (i.memoizedProps.revealOrder === "forwards" || i.memoizedProps.revealOrder === "backwards" || i.memoizedProps.revealOrder === "unstable_legacy-backwards" || i.memoizedProps.revealOrder === "together")) {
        if ((i.flags & 128) !== 0) return i;
      } else if (i.child !== null) {
        i.child.return = i, i = i.child;
        continue;
      }
      if (i === o) break;
      for (; i.sibling === null; ) {
        if (i.return === null || i.return === o) return null;
        i = i.return;
      }
      i.sibling.return = i.return, i = i.sibling;
    }
    return null;
  }
  var Br = 0, Te = null, ot = null, Pt = null, fu = !1, Qa = !1, pa = !1, pu = 0, is = 0, Ja = null, RC = 0;
  function xt() {
    throw Error(r(321));
  }
  function Sf(o, i) {
    if (i === null) return !1;
    for (var u = 0; u < i.length && u < o.length; u++)
      if (!Ln(o[u], i[u])) return !1;
    return !0;
  }
  function kf(o, i, u, f, g, S) {
    return Br = S, Te = i, i.memoizedState = null, i.updateQueue = null, i.lanes = 0, L.H = o === null || o.memoizedState === null ? iy : If, pa = !1, S = u(f, g), pa = !1, Qa && (S = Ev(
      i,
      u,
      f,
      g
    )), _v(o), S;
  }
  function _v(o) {
    L.H = us;
    var i = ot !== null && ot.next !== null;
    if (Br = 0, Pt = ot = Te = null, fu = !1, is = 0, Ja = null, i) throw Error(r(300));
    o === null || Dt || (o = o.dependencies, o !== null && ru(o) && (Dt = !0));
  }
  function Ev(o, i, u, f) {
    Te = o;
    var g = 0;
    do {
      if (Qa && (Ja = null), is = 0, Qa = !1, 25 <= g) throw Error(r(301));
      if (g += 1, Pt = ot = null, o.updateQueue != null) {
        var S = o.updateQueue;
        S.lastEffect = null, S.events = null, S.stores = null, S.memoCache != null && (S.memoCache.index = 0);
      }
      L.H = sy, S = i(u, f);
    } while (Qa);
    return S;
  }
  function AC() {
    var o = L.H, i = o.useState()[0];
    return i = typeof i.then == "function" ? ss(i) : i, o = o.useState()[0], (ot !== null ? ot.memoizedState : null) !== o && (Te.flags |= 1024), i;
  }
  function _f() {
    var o = pu !== 0;
    return pu = 0, o;
  }
  function Ef(o, i, u) {
    i.updateQueue = o.updateQueue, i.flags &= -2053, o.lanes &= ~u;
  }
  function Cf(o) {
    if (fu) {
      for (o = o.memoizedState; o !== null; ) {
        var i = o.queue;
        i !== null && (i.pending = null), o = o.next;
      }
      fu = !1;
    }
    Br = 0, Pt = ot = Te = null, Qa = !1, is = pu = 0, Ja = null;
  }
  function hn() {
    var o = {
      memoizedState: null,
      baseState: null,
      baseQueue: null,
      queue: null,
      next: null
    };
    return Pt === null ? Te.memoizedState = Pt = o : Pt = Pt.next = o, Pt;
  }
  function Nt() {
    if (ot === null) {
      var o = Te.alternate;
      o = o !== null ? o.memoizedState : null;
    } else o = ot.next;
    var i = Pt === null ? Te.memoizedState : Pt.next;
    if (i !== null)
      Pt = i, ot = o;
    else {
      if (o === null)
        throw Te.alternate === null ? Error(r(467)) : Error(r(310));
      ot = o, o = {
        memoizedState: ot.memoizedState,
        baseState: ot.baseState,
        baseQueue: ot.baseQueue,
        queue: ot.queue,
        next: null
      }, Pt === null ? Te.memoizedState = Pt = o : Pt = Pt.next = o;
    }
    return Pt;
  }
  function mu() {
    return { lastEffect: null, events: null, stores: null, memoCache: null };
  }
  function ss(o) {
    var i = is;
    return is += 1, Ja === null && (Ja = []), o = hv(Ja, o, i), i = Te, (Pt === null ? i.memoizedState : Pt.next) === null && (i = i.alternate, L.H = i === null || i.memoizedState === null ? iy : If), o;
  }
  function hu(o) {
    if (o !== null && typeof o == "object") {
      if (typeof o.then == "function") return ss(o);
      if (o.$$typeof === _) return tn(o);
    }
    throw Error(r(438, String(o)));
  }
  function Of(o) {
    var i = null, u = Te.updateQueue;
    if (u !== null && (i = u.memoCache), i == null) {
      var f = Te.alternate;
      f !== null && (f = f.updateQueue, f !== null && (f = f.memoCache, f != null && (i = {
        data: f.data.map(function(g) {
          return g.slice();
        }),
        index: 0
      })));
    }
    if (i == null && (i = { data: [], index: 0 }), u === null && (u = mu(), Te.updateQueue = u), u.memoCache = i, u = i.data[i.index], u === void 0)
      for (u = i.data[i.index] = Array(o), f = 0; f < o; f++)
        u[f] = z;
    return i.index++, u;
  }
  function Ur(o, i) {
    return typeof i == "function" ? i(o) : i;
  }
  function gu(o) {
    var i = Nt();
    return Mf(i, ot, o);
  }
  function Mf(o, i, u) {
    var f = o.queue;
    if (f === null) throw Error(r(311));
    f.lastRenderedReducer = u;
    var g = o.baseQueue, S = f.pending;
    if (S !== null) {
      if (g !== null) {
        var A = g.next;
        g.next = S.next, S.next = A;
      }
      i.baseQueue = g = S, f.pending = null;
    }
    if (S = o.baseState, g === null) o.memoizedState = S;
    else {
      i = g.next;
      var T = A = null, Y = null, ne = i, ue = !1;
      do {
        var fe = ne.lane & -536870913;
        if (fe !== ne.lane ? (Ve & fe) === fe : (Br & fe) === fe) {
          var oe = ne.revertLane;
          if (oe === 0)
            Y !== null && (Y = Y.next = {
              lane: 0,
              revertLane: 0,
              gesture: null,
              action: ne.action,
              hasEagerState: ne.hasEagerState,
              eagerState: ne.eagerState,
              next: null
            }), fe === Wa && (ue = !0);
          else if ((Br & oe) === oe) {
            ne = ne.next, oe === Wa && (ue = !0);
            continue;
          } else
            fe = {
              lane: 0,
              revertLane: ne.revertLane,
              gesture: null,
              action: ne.action,
              hasEagerState: ne.hasEagerState,
              eagerState: ne.eagerState,
              next: null
            }, Y === null ? (T = Y = fe, A = S) : Y = Y.next = fe, Te.lanes |= oe, yo |= oe;
          fe = ne.action, pa && u(S, fe), S = ne.hasEagerState ? ne.eagerState : u(S, fe);
        } else
          oe = {
            lane: fe,
            revertLane: ne.revertLane,
            gesture: ne.gesture,
            action: ne.action,
            hasEagerState: ne.hasEagerState,
            eagerState: ne.eagerState,
            next: null
          }, Y === null ? (T = Y = oe, A = S) : Y = Y.next = oe, Te.lanes |= fe, yo |= fe;
        ne = ne.next;
      } while (ne !== null && ne !== i);
      if (Y === null ? A = S : Y.next = T, !Ln(S, o.memoizedState) && (Dt = !0, ue && (u = Ga, u !== null)))
        throw u;
      o.memoizedState = S, o.baseState = A, o.baseQueue = Y, f.lastRenderedState = S;
    }
    return g === null && (f.lanes = 0), [o.memoizedState, f.dispatch];
  }
  function Nf(o) {
    var i = Nt(), u = i.queue;
    if (u === null) throw Error(r(311));
    u.lastRenderedReducer = o;
    var f = u.dispatch, g = u.pending, S = i.memoizedState;
    if (g !== null) {
      u.pending = null;
      var A = g = g.next;
      do
        S = o(S, A.action), A = A.next;
      while (A !== g);
      Ln(S, i.memoizedState) || (Dt = !0), i.memoizedState = S, i.baseQueue === null && (i.baseState = S), u.lastRenderedState = S;
    }
    return [S, f];
  }
  function Cv(o, i, u) {
    var f = Te, g = Nt(), S = Ge;
    if (S) {
      if (u === void 0) throw Error(r(407));
      u = u();
    } else u = i();
    var A = !Ln(
      (ot || g).memoizedState,
      u
    );
    if (A && (g.memoizedState = u, Dt = !0), g = g.queue, jf(Nv.bind(null, f, g, o), [
      o
    ]), g.getSnapshot !== i || A || Pt !== null && Pt.memoizedState.tag & 1) {
      if (f.flags |= 2048, Za(
        9,
        { destroy: void 0 },
        Mv.bind(
          null,
          f,
          g,
          u,
          i
        ),
        null
      ), lt === null) throw Error(r(349));
      S || (Br & 127) !== 0 || Ov(f, i, u);
    }
    return u;
  }
  function Ov(o, i, u) {
    o.flags |= 16384, o = { getSnapshot: i, value: u }, i = Te.updateQueue, i === null ? (i = mu(), Te.updateQueue = i, i.stores = [o]) : (u = i.stores, u === null ? i.stores = [o] : u.push(o));
  }
  function Mv(o, i, u, f) {
    i.value = u, i.getSnapshot = f, Rv(i) && Av(o);
  }
  function Nv(o, i, u) {
    return u(function() {
      Rv(i) && Av(o);
    });
  }
  function Rv(o) {
    var i = o.getSnapshot;
    o = o.value;
    try {
      var u = i();
      return !Ln(o, u);
    } catch {
      return !0;
    }
  }
  function Av(o) {
    var i = oa(o, 2);
    i !== null && Nn(i, o, 2);
  }
  function Rf(o) {
    var i = hn();
    if (typeof o == "function") {
      var u = o;
      if (o = u(), pa) {
        bn(!0);
        try {
          u();
        } finally {
          bn(!1);
        }
      }
    }
    return i.memoizedState = i.baseState = o, i.queue = {
      pending: null,
      lanes: 0,
      dispatch: null,
      lastRenderedReducer: Ur,
      lastRenderedState: o
    }, i;
  }
  function jv(o, i, u, f) {
    return o.baseState = u, Mf(
      o,
      ot,
      typeof f == "function" ? f : Ur
    );
  }
  function jC(o, i, u, f, g) {
    if (bu(o)) throw Error(r(485));
    if (o = i.action, o !== null) {
      var S = {
        payload: g,
        action: o,
        next: null,
        isTransition: !0,
        status: "pending",
        value: null,
        reason: null,
        listeners: [],
        then: function(A) {
          S.listeners.push(A);
        }
      };
      L.T !== null ? u(!0) : S.isTransition = !1, f(S), u = i.pending, u === null ? (S.next = i.pending = S, Pv(i, S)) : (S.next = u.next, i.pending = u.next = S);
    }
  }
  function Pv(o, i) {
    var u = i.action, f = i.payload, g = o.state;
    if (i.isTransition) {
      var S = L.T, A = {};
      L.T = A;
      try {
        var T = u(g, f), Y = L.S;
        Y !== null && Y(A, T), Dv(o, i, T);
      } catch (ne) {
        Af(o, i, ne);
      } finally {
        S !== null && A.types !== null && (S.types = A.types), L.T = S;
      }
    } else
      try {
        S = u(g, f), Dv(o, i, S);
      } catch (ne) {
        Af(o, i, ne);
      }
  }
  function Dv(o, i, u) {
    u !== null && typeof u == "object" && typeof u.then == "function" ? u.then(
      function(f) {
        $v(o, i, f);
      },
      function(f) {
        return Af(o, i, f);
      }
    ) : $v(o, i, u);
  }
  function $v(o, i, u) {
    i.status = "fulfilled", i.value = u, Tv(i), o.state = u, i = o.pending, i !== null && (u = i.next, u === i ? o.pending = null : (u = u.next, i.next = u, Pv(o, u)));
  }
  function Af(o, i, u) {
    var f = o.pending;
    if (o.pending = null, f !== null) {
      f = f.next;
      do
        i.status = "rejected", i.reason = u, Tv(i), i = i.next;
      while (i !== f);
    }
    o.action = null;
  }
  function Tv(o) {
    o = o.listeners;
    for (var i = 0; i < o.length; i++) (0, o[i])();
  }
  function Lv(o, i) {
    return i;
  }
  function Iv(o, i) {
    if (Ge) {
      var u = lt.formState;
      if (u !== null) {
        e: {
          var f = Te;
          if (Ge) {
            if (gt) {
              t: {
                for (var g = gt, S = nr; g.nodeType !== 8; ) {
                  if (!S) {
                    g = null;
                    break t;
                  }
                  if (g = rr(
                    g.nextSibling
                  ), g === null) {
                    g = null;
                    break t;
                  }
                }
                S = g.data, g = S === "F!" || S === "F" ? g : null;
              }
              if (g) {
                gt = rr(
                  g.nextSibling
                ), f = g.data === "F!";
                break e;
              }
            }
            lo(f);
          }
          f = !1;
        }
        f && (i = u[0]);
      }
    }
    return u = hn(), u.memoizedState = u.baseState = i, f = {
      pending: null,
      lanes: 0,
      dispatch: null,
      lastRenderedReducer: Lv,
      lastRenderedState: i
    }, u.queue = f, u = ry.bind(
      null,
      Te,
      f
    ), f.dispatch = u, f = Rf(!1), S = Lf.bind(
      null,
      Te,
      !1,
      f.queue
    ), f = hn(), g = {
      state: i,
      dispatch: null,
      action: o,
      pending: null
    }, f.queue = g, u = jC.bind(
      null,
      Te,
      g,
      S,
      u
    ), g.dispatch = u, f.memoizedState = o, [i, u, !1];
  }
  function zv(o) {
    var i = Nt();
    return Fv(i, ot, o);
  }
  function Fv(o, i, u) {
    if (i = Mf(
      o,
      i,
      Lv
    )[0], o = gu(Ur)[0], typeof i == "object" && i !== null && typeof i.then == "function")
      try {
        var f = ss(i);
      } catch (A) {
        throw A === Ka ? iu : A;
      }
    else f = i;
    i = Nt();
    var g = i.queue, S = g.dispatch;
    return u !== i.memoizedState && (Te.flags |= 2048, Za(
      9,
      { destroy: void 0 },
      PC.bind(null, g, u),
      null
    )), [f, S, o];
  }
  function PC(o, i) {
    o.action = i;
  }
  function Bv(o) {
    var i = Nt(), u = ot;
    if (u !== null)
      return Fv(i, u, o);
    Nt(), i = i.memoizedState, u = Nt();
    var f = u.queue.dispatch;
    return u.memoizedState = o, [i, f, !1];
  }
  function Za(o, i, u, f) {
    return o = { tag: o, create: u, deps: f, inst: i, next: null }, i = Te.updateQueue, i === null && (i = mu(), Te.updateQueue = i), u = i.lastEffect, u === null ? i.lastEffect = o.next = o : (f = u.next, u.next = o, o.next = f, i.lastEffect = o), o;
  }
  function Uv() {
    return Nt().memoizedState;
  }
  function vu(o, i, u, f) {
    var g = hn();
    Te.flags |= o, g.memoizedState = Za(
      1 | i,
      { destroy: void 0 },
      u,
      f === void 0 ? null : f
    );
  }
  function yu(o, i, u, f) {
    var g = Nt();
    f = f === void 0 ? null : f;
    var S = g.memoizedState.inst;
    ot !== null && f !== null && Sf(f, ot.memoizedState.deps) ? g.memoizedState = Za(i, S, u, f) : (Te.flags |= o, g.memoizedState = Za(
      1 | i,
      S,
      u,
      f
    ));
  }
  function Vv(o, i) {
    vu(8390656, 8, o, i);
  }
  function jf(o, i) {
    yu(2048, 8, o, i);
  }
  function DC(o) {
    Te.flags |= 4;
    var i = Te.updateQueue;
    if (i === null)
      i = mu(), Te.updateQueue = i, i.events = [o];
    else {
      var u = i.events;
      u === null ? i.events = [o] : u.push(o);
    }
  }
  function Hv(o) {
    var i = Nt().memoizedState;
    return DC({ ref: i, nextImpl: o }), function() {
      if ((Je & 2) !== 0) throw Error(r(440));
      return i.impl.apply(void 0, arguments);
    };
  }
  function qv(o, i) {
    return yu(4, 2, o, i);
  }
  function Wv(o, i) {
    return yu(4, 4, o, i);
  }
  function Gv(o, i) {
    if (typeof i == "function") {
      o = o();
      var u = i(o);
      return function() {
        typeof u == "function" ? u() : i(null);
      };
    }
    if (i != null)
      return o = o(), i.current = o, function() {
        i.current = null;
      };
  }
  function Kv(o, i, u) {
    u = u != null ? u.concat([o]) : null, yu(4, 4, Gv.bind(null, i, o), u);
  }
  function Pf() {
  }
  function Xv(o, i) {
    var u = Nt();
    i = i === void 0 ? null : i;
    var f = u.memoizedState;
    return i !== null && Sf(i, f[1]) ? f[0] : (u.memoizedState = [o, i], o);
  }
  function Yv(o, i) {
    var u = Nt();
    i = i === void 0 ? null : i;
    var f = u.memoizedState;
    if (i !== null && Sf(i, f[1]))
      return f[0];
    if (f = o(), pa) {
      bn(!0);
      try {
        o();
      } finally {
        bn(!1);
      }
    }
    return u.memoizedState = [f, i], f;
  }
  function Df(o, i, u) {
    return u === void 0 || (Br & 1073741824) !== 0 && (Ve & 261930) === 0 ? o.memoizedState = i : (o.memoizedState = u, o = Qy(), Te.lanes |= o, yo |= o, u);
  }
  function Qv(o, i, u, f) {
    return Ln(u, i) ? u : Ya.current !== null ? (o = Df(o, u, f), Ln(o, i) || (Dt = !0), o) : (Br & 42) === 0 || (Br & 1073741824) !== 0 && (Ve & 261930) === 0 ? (Dt = !0, o.memoizedState = u) : (o = Qy(), Te.lanes |= o, yo |= o, i);
  }
  function Jv(o, i, u, f, g) {
    var S = K.p;
    K.p = S !== 0 && 8 > S ? S : 8;
    var A = L.T, T = {};
    L.T = T, Lf(o, !1, i, u);
    try {
      var Y = g(), ne = L.S;
      if (ne !== null && ne(T, Y), Y !== null && typeof Y == "object" && typeof Y.then == "function") {
        var ue = NC(
          Y,
          f
        );
        ls(
          o,
          i,
          ue,
          Vn(o)
        );
      } else
        ls(
          o,
          i,
          f,
          Vn(o)
        );
    } catch (fe) {
      ls(
        o,
        i,
        { then: function() {
        }, status: "rejected", reason: fe },
        Vn()
      );
    } finally {
      K.p = S, A !== null && T.types !== null && (A.types = T.types), L.T = A;
    }
  }
  function $C() {
  }
  function $f(o, i, u, f) {
    if (o.tag !== 5) throw Error(r(476));
    var g = Zv(o).queue;
    Jv(
      o,
      g,
      i,
      q,
      u === null ? $C : function() {
        return ey(o), u(f);
      }
    );
  }
  function Zv(o) {
    var i = o.memoizedState;
    if (i !== null) return i;
    i = {
      memoizedState: q,
      baseState: q,
      baseQueue: null,
      queue: {
        pending: null,
        lanes: 0,
        dispatch: null,
        lastRenderedReducer: Ur,
        lastRenderedState: q
      },
      next: null
    };
    var u = {};
    return i.next = {
      memoizedState: u,
      baseState: u,
      baseQueue: null,
      queue: {
        pending: null,
        lanes: 0,
        dispatch: null,
        lastRenderedReducer: Ur,
        lastRenderedState: u
      },
      next: null
    }, o.memoizedState = i, o = o.alternate, o !== null && (o.memoizedState = i), i;
  }
  function ey(o) {
    var i = Zv(o);
    i.next === null && (i = o.alternate.memoizedState), ls(
      o,
      i.next.queue,
      {},
      Vn()
    );
  }
  function Tf() {
    return tn(Es);
  }
  function ty() {
    return Nt().memoizedState;
  }
  function ny() {
    return Nt().memoizedState;
  }
  function TC(o) {
    for (var i = o.return; i !== null; ) {
      switch (i.tag) {
        case 24:
        case 3:
          var u = Vn();
          o = fo(u);
          var f = po(i, o, u);
          f !== null && (Nn(f, i, u), rs(f, i, u)), i = { cache: df() }, o.payload = i;
          return;
      }
      i = i.return;
    }
  }
  function LC(o, i, u) {
    var f = Vn();
    u = {
      lane: f,
      revertLane: 0,
      gesture: null,
      action: u,
      hasEagerState: !1,
      eagerState: null,
      next: null
    }, bu(o) ? oy(i, u) : (u = Zd(o, i, u, f), u !== null && (Nn(u, o, f), ay(u, i, f)));
  }
  function ry(o, i, u) {
    var f = Vn();
    ls(o, i, u, f);
  }
  function ls(o, i, u, f) {
    var g = {
      lane: f,
      revertLane: 0,
      gesture: null,
      action: u,
      hasEagerState: !1,
      eagerState: null,
      next: null
    };
    if (bu(o)) oy(i, g);
    else {
      var S = o.alternate;
      if (o.lanes === 0 && (S === null || S.lanes === 0) && (S = i.lastRenderedReducer, S !== null))
        try {
          var A = i.lastRenderedState, T = S(A, u);
          if (g.hasEagerState = !0, g.eagerState = T, Ln(T, A))
            return Zl(o, i, g, 0), lt === null && Jl(), !1;
        } catch {
        }
      if (u = Zd(o, i, g, f), u !== null)
        return Nn(u, o, f), ay(u, i, f), !0;
    }
    return !1;
  }
  function Lf(o, i, u, f) {
    if (f = {
      lane: 2,
      revertLane: hp(),
      gesture: null,
      action: f,
      hasEagerState: !1,
      eagerState: null,
      next: null
    }, bu(o)) {
      if (i) throw Error(r(479));
    } else
      i = Zd(
        o,
        u,
        f,
        2
      ), i !== null && Nn(i, o, 2);
  }
  function bu(o) {
    var i = o.alternate;
    return o === Te || i !== null && i === Te;
  }
  function oy(o, i) {
    Qa = fu = !0;
    var u = o.pending;
    u === null ? i.next = i : (i.next = u.next, u.next = i), o.pending = i;
  }
  function ay(o, i, u) {
    if ((u & 4194048) !== 0) {
      var f = i.lanes;
      f &= o.pendingLanes, u |= f, i.lanes = u, kd(o, u);
    }
  }
  var us = {
    readContext: tn,
    use: hu,
    useCallback: xt,
    useContext: xt,
    useEffect: xt,
    useImperativeHandle: xt,
    useLayoutEffect: xt,
    useInsertionEffect: xt,
    useMemo: xt,
    useReducer: xt,
    useRef: xt,
    useState: xt,
    useDebugValue: xt,
    useDeferredValue: xt,
    useTransition: xt,
    useSyncExternalStore: xt,
    useId: xt,
    useHostTransitionStatus: xt,
    useFormState: xt,
    useActionState: xt,
    useOptimistic: xt,
    useMemoCache: xt,
    useCacheRefresh: xt
  };
  us.useEffectEvent = xt;
  var iy = {
    readContext: tn,
    use: hu,
    useCallback: function(o, i) {
      return hn().memoizedState = [
        o,
        i === void 0 ? null : i
      ], o;
    },
    useContext: tn,
    useEffect: Vv,
    useImperativeHandle: function(o, i, u) {
      u = u != null ? u.concat([o]) : null, vu(
        4194308,
        4,
        Gv.bind(null, i, o),
        u
      );
    },
    useLayoutEffect: function(o, i) {
      return vu(4194308, 4, o, i);
    },
    useInsertionEffect: function(o, i) {
      vu(4, 2, o, i);
    },
    useMemo: function(o, i) {
      var u = hn();
      i = i === void 0 ? null : i;
      var f = o();
      if (pa) {
        bn(!0);
        try {
          o();
        } finally {
          bn(!1);
        }
      }
      return u.memoizedState = [f, i], f;
    },
    useReducer: function(o, i, u) {
      var f = hn();
      if (u !== void 0) {
        var g = u(i);
        if (pa) {
          bn(!0);
          try {
            u(i);
          } finally {
            bn(!1);
          }
        }
      } else g = i;
      return f.memoizedState = f.baseState = g, o = {
        pending: null,
        lanes: 0,
        dispatch: null,
        lastRenderedReducer: o,
        lastRenderedState: g
      }, f.queue = o, o = o.dispatch = LC.bind(
        null,
        Te,
        o
      ), [f.memoizedState, o];
    },
    useRef: function(o) {
      var i = hn();
      return o = { current: o }, i.memoizedState = o;
    },
    useState: function(o) {
      o = Rf(o);
      var i = o.queue, u = ry.bind(null, Te, i);
      return i.dispatch = u, [o.memoizedState, u];
    },
    useDebugValue: Pf,
    useDeferredValue: function(o, i) {
      var u = hn();
      return Df(u, o, i);
    },
    useTransition: function() {
      var o = Rf(!1);
      return o = Jv.bind(
        null,
        Te,
        o.queue,
        !0,
        !1
      ), hn().memoizedState = o, [!1, o];
    },
    useSyncExternalStore: function(o, i, u) {
      var f = Te, g = hn();
      if (Ge) {
        if (u === void 0)
          throw Error(r(407));
        u = u();
      } else {
        if (u = i(), lt === null)
          throw Error(r(349));
        (Ve & 127) !== 0 || Ov(f, i, u);
      }
      g.memoizedState = u;
      var S = { value: u, getSnapshot: i };
      return g.queue = S, Vv(Nv.bind(null, f, S, o), [
        o
      ]), f.flags |= 2048, Za(
        9,
        { destroy: void 0 },
        Mv.bind(
          null,
          f,
          S,
          u,
          i
        ),
        null
      ), u;
    },
    useId: function() {
      var o = hn(), i = lt.identifierPrefix;
      if (Ge) {
        var u = kr, f = Sr;
        u = (f & ~(1 << 32 - Re(f) - 1)).toString(32) + u, i = "_" + i + "R_" + u, u = pu++, 0 < u && (i += "H" + u.toString(32)), i += "_";
      } else
        u = RC++, i = "_" + i + "r_" + u.toString(32) + "_";
      return o.memoizedState = i;
    },
    useHostTransitionStatus: Tf,
    useFormState: Iv,
    useActionState: Iv,
    useOptimistic: function(o) {
      var i = hn();
      i.memoizedState = i.baseState = o;
      var u = {
        pending: null,
        lanes: 0,
        dispatch: null,
        lastRenderedReducer: null,
        lastRenderedState: null
      };
      return i.queue = u, i = Lf.bind(
        null,
        Te,
        !0,
        u
      ), u.dispatch = i, [o, i];
    },
    useMemoCache: Of,
    useCacheRefresh: function() {
      return hn().memoizedState = TC.bind(
        null,
        Te
      );
    },
    useEffectEvent: function(o) {
      var i = hn(), u = { impl: o };
      return i.memoizedState = u, function() {
        if ((Je & 2) !== 0)
          throw Error(r(440));
        return u.impl.apply(void 0, arguments);
      };
    }
  }, If = {
    readContext: tn,
    use: hu,
    useCallback: Xv,
    useContext: tn,
    useEffect: jf,
    useImperativeHandle: Kv,
    useInsertionEffect: qv,
    useLayoutEffect: Wv,
    useMemo: Yv,
    useReducer: gu,
    useRef: Uv,
    useState: function() {
      return gu(Ur);
    },
    useDebugValue: Pf,
    useDeferredValue: function(o, i) {
      var u = Nt();
      return Qv(
        u,
        ot.memoizedState,
        o,
        i
      );
    },
    useTransition: function() {
      var o = gu(Ur)[0], i = Nt().memoizedState;
      return [
        typeof o == "boolean" ? o : ss(o),
        i
      ];
    },
    useSyncExternalStore: Cv,
    useId: ty,
    useHostTransitionStatus: Tf,
    useFormState: zv,
    useActionState: zv,
    useOptimistic: function(o, i) {
      var u = Nt();
      return jv(u, ot, o, i);
    },
    useMemoCache: Of,
    useCacheRefresh: ny
  };
  If.useEffectEvent = Hv;
  var sy = {
    readContext: tn,
    use: hu,
    useCallback: Xv,
    useContext: tn,
    useEffect: jf,
    useImperativeHandle: Kv,
    useInsertionEffect: qv,
    useLayoutEffect: Wv,
    useMemo: Yv,
    useReducer: Nf,
    useRef: Uv,
    useState: function() {
      return Nf(Ur);
    },
    useDebugValue: Pf,
    useDeferredValue: function(o, i) {
      var u = Nt();
      return ot === null ? Df(u, o, i) : Qv(
        u,
        ot.memoizedState,
        o,
        i
      );
    },
    useTransition: function() {
      var o = Nf(Ur)[0], i = Nt().memoizedState;
      return [
        typeof o == "boolean" ? o : ss(o),
        i
      ];
    },
    useSyncExternalStore: Cv,
    useId: ty,
    useHostTransitionStatus: Tf,
    useFormState: Bv,
    useActionState: Bv,
    useOptimistic: function(o, i) {
      var u = Nt();
      return ot !== null ? jv(u, ot, o, i) : (u.baseState = o, [o, u.queue.dispatch]);
    },
    useMemoCache: Of,
    useCacheRefresh: ny
  };
  sy.useEffectEvent = Hv;
  function zf(o, i, u, f) {
    i = o.memoizedState, u = u(f, i), u = u == null ? i : h({}, i, u), o.memoizedState = u, o.lanes === 0 && (o.updateQueue.baseState = u);
  }
  var Ff = {
    enqueueSetState: function(o, i, u) {
      o = o._reactInternals;
      var f = Vn(), g = fo(f);
      g.payload = i, u != null && (g.callback = u), i = po(o, g, f), i !== null && (Nn(i, o, f), rs(i, o, f));
    },
    enqueueReplaceState: function(o, i, u) {
      o = o._reactInternals;
      var f = Vn(), g = fo(f);
      g.tag = 1, g.payload = i, u != null && (g.callback = u), i = po(o, g, f), i !== null && (Nn(i, o, f), rs(i, o, f));
    },
    enqueueForceUpdate: function(o, i) {
      o = o._reactInternals;
      var u = Vn(), f = fo(u);
      f.tag = 2, i != null && (f.callback = i), i = po(o, f, u), i !== null && (Nn(i, o, u), rs(i, o, u));
    }
  };
  function ly(o, i, u, f, g, S, A) {
    return o = o.stateNode, typeof o.shouldComponentUpdate == "function" ? o.shouldComponentUpdate(f, S, A) : i.prototype && i.prototype.isPureReactComponent ? !Xi(u, f) || !Xi(g, S) : !0;
  }
  function uy(o, i, u, f) {
    o = i.state, typeof i.componentWillReceiveProps == "function" && i.componentWillReceiveProps(u, f), typeof i.UNSAFE_componentWillReceiveProps == "function" && i.UNSAFE_componentWillReceiveProps(u, f), i.state !== o && Ff.enqueueReplaceState(i, i.state, null);
  }
  function ma(o, i) {
    var u = i;
    if ("ref" in i) {
      u = {};
      for (var f in i)
        f !== "ref" && (u[f] = i[f]);
    }
    if (o = o.defaultProps) {
      u === i && (u = h({}, u));
      for (var g in o)
        u[g] === void 0 && (u[g] = o[g]);
    }
    return u;
  }
  function cy(o) {
    Ql(o);
  }
  function dy(o) {
    console.error(o);
  }
  function fy(o) {
    Ql(o);
  }
  function wu(o, i) {
    try {
      var u = o.onUncaughtError;
      u(i.value, { componentStack: i.stack });
    } catch (f) {
      setTimeout(function() {
        throw f;
      });
    }
  }
  function py(o, i, u) {
    try {
      var f = o.onCaughtError;
      f(u.value, {
        componentStack: u.stack,
        errorBoundary: i.tag === 1 ? i.stateNode : null
      });
    } catch (g) {
      setTimeout(function() {
        throw g;
      });
    }
  }
  function Bf(o, i, u) {
    return u = fo(u), u.tag = 3, u.payload = { element: null }, u.callback = function() {
      wu(o, i);
    }, u;
  }
  function my(o) {
    return o = fo(o), o.tag = 3, o;
  }
  function hy(o, i, u, f) {
    var g = u.type.getDerivedStateFromError;
    if (typeof g == "function") {
      var S = f.value;
      o.payload = function() {
        return g(S);
      }, o.callback = function() {
        py(i, u, f);
      };
    }
    var A = u.stateNode;
    A !== null && typeof A.componentDidCatch == "function" && (o.callback = function() {
      py(i, u, f), typeof g != "function" && (bo === null ? bo = /* @__PURE__ */ new Set([this]) : bo.add(this));
      var T = f.stack;
      this.componentDidCatch(f.value, {
        componentStack: T !== null ? T : ""
      });
    });
  }
  function IC(o, i, u, f, g) {
    if (u.flags |= 32768, f !== null && typeof f == "object" && typeof f.then == "function") {
      if (i = u.alternate, i !== null && qa(
        i,
        u,
        g,
        !0
      ), u = zn.current, u !== null) {
        switch (u.tag) {
          case 31:
          case 13:
            return lr === null ? ju() : u.alternate === null && St === 0 && (St = 3), u.flags &= -257, u.flags |= 65536, u.lanes = g, f === su ? u.flags |= 16384 : (i = u.updateQueue, i === null ? u.updateQueue = /* @__PURE__ */ new Set([f]) : i.add(f), fp(o, f, g)), !1;
          case 22:
            return u.flags |= 65536, f === su ? u.flags |= 16384 : (i = u.updateQueue, i === null ? (i = {
              transitions: null,
              markerInstances: null,
              retryQueue: /* @__PURE__ */ new Set([f])
            }, u.updateQueue = i) : (u = i.retryQueue, u === null ? i.retryQueue = /* @__PURE__ */ new Set([f]) : u.add(f)), fp(o, f, g)), !1;
        }
        throw Error(r(435, u.tag));
      }
      return fp(o, f, g), ju(), !1;
    }
    if (Ge)
      return i = zn.current, i !== null ? ((i.flags & 65536) === 0 && (i.flags |= 256), i.flags |= 65536, i.lanes = g, f !== af && (o = Error(r(422), { cause: f }), Ji(Zn(o, u)))) : (f !== af && (i = Error(r(423), {
        cause: f
      }), Ji(
        Zn(i, u)
      )), o = o.current.alternate, o.flags |= 65536, g &= -g, o.lanes |= g, f = Zn(f, u), g = Bf(
        o.stateNode,
        f,
        g
      ), vf(o, g), St !== 4 && (St = 2)), !1;
    var S = Error(r(520), { cause: f });
    if (S = Zn(S, u), vs === null ? vs = [S] : vs.push(S), St !== 4 && (St = 2), i === null) return !0;
    f = Zn(f, u), u = i;
    do {
      switch (u.tag) {
        case 3:
          return u.flags |= 65536, o = g & -g, u.lanes |= o, o = Bf(u.stateNode, f, o), vf(u, o), !1;
        case 1:
          if (i = u.type, S = u.stateNode, (u.flags & 128) === 0 && (typeof i.getDerivedStateFromError == "function" || S !== null && typeof S.componentDidCatch == "function" && (bo === null || !bo.has(S))))
            return u.flags |= 65536, g &= -g, u.lanes |= g, g = my(g), hy(
              g,
              o,
              u,
              f
            ), vf(u, g), !1;
      }
      u = u.return;
    } while (u !== null);
    return !1;
  }
  var Uf = Error(r(461)), Dt = !1;
  function nn(o, i, u, f) {
    i.child = o === null ? bv(i, null, u, f) : fa(
      i,
      o.child,
      u,
      f
    );
  }
  function gy(o, i, u, f, g) {
    u = u.render;
    var S = i.ref;
    if ("ref" in f) {
      var A = {};
      for (var T in f)
        T !== "ref" && (A[T] = f[T]);
    } else A = f;
    return la(i), f = kf(
      o,
      i,
      u,
      A,
      S,
      g
    ), T = _f(), o !== null && !Dt ? (Ef(o, i, g), Vr(o, i, g)) : (Ge && T && rf(i), i.flags |= 1, nn(o, i, f, g), i.child);
  }
  function vy(o, i, u, f, g) {
    if (o === null) {
      var S = u.type;
      return typeof S == "function" && !ef(S) && S.defaultProps === void 0 && u.compare === null ? (i.tag = 15, i.type = S, yy(
        o,
        i,
        S,
        f,
        g
      )) : (o = tu(
        u.type,
        null,
        f,
        i,
        i.mode,
        g
      ), o.ref = i.ref, o.return = i, i.child = o);
    }
    if (S = o.child, !Yf(o, g)) {
      var A = S.memoizedProps;
      if (u = u.compare, u = u !== null ? u : Xi, u(A, f) && o.ref === i.ref)
        return Vr(o, i, g);
    }
    return i.flags |= 1, o = Lr(S, f), o.ref = i.ref, o.return = i, i.child = o;
  }
  function yy(o, i, u, f, g) {
    if (o !== null) {
      var S = o.memoizedProps;
      if (Xi(S, f) && o.ref === i.ref)
        if (Dt = !1, i.pendingProps = f = S, Yf(o, g))
          (o.flags & 131072) !== 0 && (Dt = !0);
        else
          return i.lanes = o.lanes, Vr(o, i, g);
    }
    return Vf(
      o,
      i,
      u,
      f,
      g
    );
  }
  function by(o, i, u, f) {
    var g = f.children, S = o !== null ? o.memoizedState : null;
    if (o === null && i.stateNode === null && (i.stateNode = {
      _visibility: 1,
      _pendingMarkers: null,
      _retryCache: null,
      _transitions: null
    }), f.mode === "hidden") {
      if ((i.flags & 128) !== 0) {
        if (S = S !== null ? S.baseLanes | u : u, o !== null) {
          for (f = i.child = o.child, g = 0; f !== null; )
            g = g | f.lanes | f.childLanes, f = f.sibling;
          f = g & ~S;
        } else f = 0, i.child = null;
        return wy(
          o,
          i,
          S,
          u,
          f
        );
      }
      if ((u & 536870912) !== 0)
        i.memoizedState = { baseLanes: 0, cachePool: null }, o !== null && au(
          i,
          S !== null ? S.cachePool : null
        ), S !== null ? Sv(i, S) : bf(), kv(i);
      else
        return f = i.lanes = 536870912, wy(
          o,
          i,
          S !== null ? S.baseLanes | u : u,
          u,
          f
        );
    } else
      S !== null ? (au(i, S.cachePool), Sv(i, S), ho(), i.memoizedState = null) : (o !== null && au(i, null), bf(), ho());
    return nn(o, i, g, u), i.child;
  }
  function cs(o, i) {
    return o !== null && o.tag === 22 || i.stateNode !== null || (i.stateNode = {
      _visibility: 1,
      _pendingMarkers: null,
      _retryCache: null,
      _transitions: null
    }), i.sibling;
  }
  function wy(o, i, u, f, g) {
    var S = pf();
    return S = S === null ? null : { parent: jt._currentValue, pool: S }, i.memoizedState = {
      baseLanes: u,
      cachePool: S
    }, o !== null && au(i, null), bf(), kv(i), o !== null && qa(o, i, f, !0), i.childLanes = g, null;
  }
  function xu(o, i) {
    return i = ku(
      { mode: i.mode, children: i.children },
      o.mode
    ), i.ref = o.ref, o.child = i, i.return = o, i;
  }
  function xy(o, i, u) {
    return fa(i, o.child, null, u), o = xu(i, i.pendingProps), o.flags |= 2, Fn(i), i.memoizedState = null, o;
  }
  function zC(o, i, u) {
    var f = i.pendingProps, g = (i.flags & 128) !== 0;
    if (i.flags &= -129, o === null) {
      if (Ge) {
        if (f.mode === "hidden")
          return o = xu(i, f), i.lanes = 536870912, cs(null, o);
        if (xf(i), (o = gt) ? (o = Pb(
          o,
          nr
        ), o = o !== null && o.data === "&" ? o : null, o !== null && (i.memoizedState = {
          dehydrated: o,
          treeContext: io !== null ? { id: Sr, overflow: kr } : null,
          retryLane: 536870912,
          hydrationErrors: null
        }, u = ov(o), u.return = i, i.child = u, en = i, gt = null)) : o = null, o === null) throw lo(i);
        return i.lanes = 536870912, null;
      }
      return xu(i, f);
    }
    var S = o.memoizedState;
    if (S !== null) {
      var A = S.dehydrated;
      if (xf(i), g)
        if (i.flags & 256)
          i.flags &= -257, i = xy(
            o,
            i,
            u
          );
        else if (i.memoizedState !== null)
          i.child = o.child, i.flags |= 128, i = null;
        else throw Error(r(558));
      else if (Dt || qa(o, i, u, !1), g = (u & o.childLanes) !== 0, Dt || g) {
        if (f = lt, f !== null && (A = _d(f, u), A !== 0 && A !== S.retryLane))
          throw S.retryLane = A, oa(o, A), Nn(f, o, A), Uf;
        ju(), i = xy(
          o,
          i,
          u
        );
      } else
        o = S.treeContext, gt = rr(A.nextSibling), en = i, Ge = !0, so = null, nr = !1, o !== null && sv(i, o), i = xu(i, f), i.flags |= 4096;
      return i;
    }
    return o = Lr(o.child, {
      mode: f.mode,
      children: f.children
    }), o.ref = i.ref, i.child = o, o.return = i, o;
  }
  function Su(o, i) {
    var u = i.ref;
    if (u === null)
      o !== null && o.ref !== null && (i.flags |= 4194816);
    else {
      if (typeof u != "function" && typeof u != "object")
        throw Error(r(284));
      (o === null || o.ref !== u) && (i.flags |= 4194816);
    }
  }
  function Vf(o, i, u, f, g) {
    return la(i), u = kf(
      o,
      i,
      u,
      f,
      void 0,
      g
    ), f = _f(), o !== null && !Dt ? (Ef(o, i, g), Vr(o, i, g)) : (Ge && f && rf(i), i.flags |= 1, nn(o, i, u, g), i.child);
  }
  function Sy(o, i, u, f, g, S) {
    return la(i), i.updateQueue = null, u = Ev(
      i,
      f,
      u,
      g
    ), _v(o), f = _f(), o !== null && !Dt ? (Ef(o, i, S), Vr(o, i, S)) : (Ge && f && rf(i), i.flags |= 1, nn(o, i, u, S), i.child);
  }
  function ky(o, i, u, f, g) {
    if (la(i), i.stateNode === null) {
      var S = Ba, A = u.contextType;
      typeof A == "object" && A !== null && (S = tn(A)), S = new u(f, S), i.memoizedState = S.state !== null && S.state !== void 0 ? S.state : null, S.updater = Ff, i.stateNode = S, S._reactInternals = i, S = i.stateNode, S.props = f, S.state = i.memoizedState, S.refs = {}, hf(i), A = u.contextType, S.context = typeof A == "object" && A !== null ? tn(A) : Ba, S.state = i.memoizedState, A = u.getDerivedStateFromProps, typeof A == "function" && (zf(
        i,
        u,
        A,
        f
      ), S.state = i.memoizedState), typeof u.getDerivedStateFromProps == "function" || typeof S.getSnapshotBeforeUpdate == "function" || typeof S.UNSAFE_componentWillMount != "function" && typeof S.componentWillMount != "function" || (A = S.state, typeof S.componentWillMount == "function" && S.componentWillMount(), typeof S.UNSAFE_componentWillMount == "function" && S.UNSAFE_componentWillMount(), A !== S.state && Ff.enqueueReplaceState(S, S.state, null), as(i, f, S, g), os(), S.state = i.memoizedState), typeof S.componentDidMount == "function" && (i.flags |= 4194308), f = !0;
    } else if (o === null) {
      S = i.stateNode;
      var T = i.memoizedProps, Y = ma(u, T);
      S.props = Y;
      var ne = S.context, ue = u.contextType;
      A = Ba, typeof ue == "object" && ue !== null && (A = tn(ue));
      var fe = u.getDerivedStateFromProps;
      ue = typeof fe == "function" || typeof S.getSnapshotBeforeUpdate == "function", T = i.pendingProps !== T, ue || typeof S.UNSAFE_componentWillReceiveProps != "function" && typeof S.componentWillReceiveProps != "function" || (T || ne !== A) && uy(
        i,
        S,
        f,
        A
      ), co = !1;
      var oe = i.memoizedState;
      S.state = oe, as(i, f, S, g), os(), ne = i.memoizedState, T || oe !== ne || co ? (typeof fe == "function" && (zf(
        i,
        u,
        fe,
        f
      ), ne = i.memoizedState), (Y = co || ly(
        i,
        u,
        Y,
        f,
        oe,
        ne,
        A
      )) ? (ue || typeof S.UNSAFE_componentWillMount != "function" && typeof S.componentWillMount != "function" || (typeof S.componentWillMount == "function" && S.componentWillMount(), typeof S.UNSAFE_componentWillMount == "function" && S.UNSAFE_componentWillMount()), typeof S.componentDidMount == "function" && (i.flags |= 4194308)) : (typeof S.componentDidMount == "function" && (i.flags |= 4194308), i.memoizedProps = f, i.memoizedState = ne), S.props = f, S.state = ne, S.context = A, f = Y) : (typeof S.componentDidMount == "function" && (i.flags |= 4194308), f = !1);
    } else {
      S = i.stateNode, gf(o, i), A = i.memoizedProps, ue = ma(u, A), S.props = ue, fe = i.pendingProps, oe = S.context, ne = u.contextType, Y = Ba, typeof ne == "object" && ne !== null && (Y = tn(ne)), T = u.getDerivedStateFromProps, (ne = typeof T == "function" || typeof S.getSnapshotBeforeUpdate == "function") || typeof S.UNSAFE_componentWillReceiveProps != "function" && typeof S.componentWillReceiveProps != "function" || (A !== fe || oe !== Y) && uy(
        i,
        S,
        f,
        Y
      ), co = !1, oe = i.memoizedState, S.state = oe, as(i, f, S, g), os();
      var ie = i.memoizedState;
      A !== fe || oe !== ie || co || o !== null && o.dependencies !== null && ru(o.dependencies) ? (typeof T == "function" && (zf(
        i,
        u,
        T,
        f
      ), ie = i.memoizedState), (ue = co || ly(
        i,
        u,
        ue,
        f,
        oe,
        ie,
        Y
      ) || o !== null && o.dependencies !== null && ru(o.dependencies)) ? (ne || typeof S.UNSAFE_componentWillUpdate != "function" && typeof S.componentWillUpdate != "function" || (typeof S.componentWillUpdate == "function" && S.componentWillUpdate(f, ie, Y), typeof S.UNSAFE_componentWillUpdate == "function" && S.UNSAFE_componentWillUpdate(
        f,
        ie,
        Y
      )), typeof S.componentDidUpdate == "function" && (i.flags |= 4), typeof S.getSnapshotBeforeUpdate == "function" && (i.flags |= 1024)) : (typeof S.componentDidUpdate != "function" || A === o.memoizedProps && oe === o.memoizedState || (i.flags |= 4), typeof S.getSnapshotBeforeUpdate != "function" || A === o.memoizedProps && oe === o.memoizedState || (i.flags |= 1024), i.memoizedProps = f, i.memoizedState = ie), S.props = f, S.state = ie, S.context = Y, f = ue) : (typeof S.componentDidUpdate != "function" || A === o.memoizedProps && oe === o.memoizedState || (i.flags |= 4), typeof S.getSnapshotBeforeUpdate != "function" || A === o.memoizedProps && oe === o.memoizedState || (i.flags |= 1024), f = !1);
    }
    return S = f, Su(o, i), f = (i.flags & 128) !== 0, S || f ? (S = i.stateNode, u = f && typeof u.getDerivedStateFromError != "function" ? null : S.render(), i.flags |= 1, o !== null && f ? (i.child = fa(
      i,
      o.child,
      null,
      g
    ), i.child = fa(
      i,
      null,
      u,
      g
    )) : nn(o, i, u, g), i.memoizedState = S.state, o = i.child) : o = Vr(
      o,
      i,
      g
    ), o;
  }
  function _y(o, i, u, f) {
    return ia(), i.flags |= 256, nn(o, i, u, f), i.child;
  }
  var Hf = {
    dehydrated: null,
    treeContext: null,
    retryLane: 0,
    hydrationErrors: null
  };
  function qf(o) {
    return { baseLanes: o, cachePool: pv() };
  }
  function Wf(o, i, u) {
    return o = o !== null ? o.childLanes & ~u : 0, i && (o |= Un), o;
  }
  function Ey(o, i, u) {
    var f = i.pendingProps, g = !1, S = (i.flags & 128) !== 0, A;
    if ((A = S) || (A = o !== null && o.memoizedState === null ? !1 : (Mt.current & 2) !== 0), A && (g = !0, i.flags &= -129), A = (i.flags & 32) !== 0, i.flags &= -33, o === null) {
      if (Ge) {
        if (g ? mo(i) : ho(), (o = gt) ? (o = Pb(
          o,
          nr
        ), o = o !== null && o.data !== "&" ? o : null, o !== null && (i.memoizedState = {
          dehydrated: o,
          treeContext: io !== null ? { id: Sr, overflow: kr } : null,
          retryLane: 536870912,
          hydrationErrors: null
        }, u = ov(o), u.return = i, i.child = u, en = i, gt = null)) : o = null, o === null) throw lo(i);
        return Mp(o) ? i.lanes = 32 : i.lanes = 536870912, null;
      }
      var T = f.children;
      return f = f.fallback, g ? (ho(), g = i.mode, T = ku(
        { mode: "hidden", children: T },
        g
      ), f = aa(
        f,
        g,
        u,
        null
      ), T.return = i, f.return = i, T.sibling = f, i.child = T, f = i.child, f.memoizedState = qf(u), f.childLanes = Wf(
        o,
        A,
        u
      ), i.memoizedState = Hf, cs(null, f)) : (mo(i), Gf(i, T));
    }
    var Y = o.memoizedState;
    if (Y !== null && (T = Y.dehydrated, T !== null)) {
      if (S)
        i.flags & 256 ? (mo(i), i.flags &= -257, i = Kf(
          o,
          i,
          u
        )) : i.memoizedState !== null ? (ho(), i.child = o.child, i.flags |= 128, i = null) : (ho(), T = f.fallback, g = i.mode, f = ku(
          { mode: "visible", children: f.children },
          g
        ), T = aa(
          T,
          g,
          u,
          null
        ), T.flags |= 2, f.return = i, T.return = i, f.sibling = T, i.child = f, fa(
          i,
          o.child,
          null,
          u
        ), f = i.child, f.memoizedState = qf(u), f.childLanes = Wf(
          o,
          A,
          u
        ), i.memoizedState = Hf, i = cs(null, f));
      else if (mo(i), Mp(T)) {
        if (A = T.nextSibling && T.nextSibling.dataset, A) var ne = A.dgst;
        A = ne, f = Error(r(419)), f.stack = "", f.digest = A, Ji({ value: f, source: null, stack: null }), i = Kf(
          o,
          i,
          u
        );
      } else if (Dt || qa(o, i, u, !1), A = (u & o.childLanes) !== 0, Dt || A) {
        if (A = lt, A !== null && (f = _d(A, u), f !== 0 && f !== Y.retryLane))
          throw Y.retryLane = f, oa(o, f), Nn(A, o, f), Uf;
        Op(T) || ju(), i = Kf(
          o,
          i,
          u
        );
      } else
        Op(T) ? (i.flags |= 192, i.child = o.child, i = null) : (o = Y.treeContext, gt = rr(
          T.nextSibling
        ), en = i, Ge = !0, so = null, nr = !1, o !== null && sv(i, o), i = Gf(
          i,
          f.children
        ), i.flags |= 4096);
      return i;
    }
    return g ? (ho(), T = f.fallback, g = i.mode, Y = o.child, ne = Y.sibling, f = Lr(Y, {
      mode: "hidden",
      children: f.children
    }), f.subtreeFlags = Y.subtreeFlags & 65011712, ne !== null ? T = Lr(
      ne,
      T
    ) : (T = aa(
      T,
      g,
      u,
      null
    ), T.flags |= 2), T.return = i, f.return = i, f.sibling = T, i.child = f, cs(null, f), f = i.child, T = o.child.memoizedState, T === null ? T = qf(u) : (g = T.cachePool, g !== null ? (Y = jt._currentValue, g = g.parent !== Y ? { parent: Y, pool: Y } : g) : g = pv(), T = {
      baseLanes: T.baseLanes | u,
      cachePool: g
    }), f.memoizedState = T, f.childLanes = Wf(
      o,
      A,
      u
    ), i.memoizedState = Hf, cs(o.child, f)) : (mo(i), u = o.child, o = u.sibling, u = Lr(u, {
      mode: "visible",
      children: f.children
    }), u.return = i, u.sibling = null, o !== null && (A = i.deletions, A === null ? (i.deletions = [o], i.flags |= 16) : A.push(o)), i.child = u, i.memoizedState = null, u);
  }
  function Gf(o, i) {
    return i = ku(
      { mode: "visible", children: i },
      o.mode
    ), i.return = o, o.child = i;
  }
  function ku(o, i) {
    return o = In(22, o, null, i), o.lanes = 0, o;
  }
  function Kf(o, i, u) {
    return fa(i, o.child, null, u), o = Gf(
      i,
      i.pendingProps.children
    ), o.flags |= 2, i.memoizedState = null, o;
  }
  function Cy(o, i, u) {
    o.lanes |= i;
    var f = o.alternate;
    f !== null && (f.lanes |= i), uf(o.return, i, u);
  }
  function Xf(o, i, u, f, g, S) {
    var A = o.memoizedState;
    A === null ? o.memoizedState = {
      isBackwards: i,
      rendering: null,
      renderingStartTime: 0,
      last: f,
      tail: u,
      tailMode: g,
      treeForkCount: S
    } : (A.isBackwards = i, A.rendering = null, A.renderingStartTime = 0, A.last = f, A.tail = u, A.tailMode = g, A.treeForkCount = S);
  }
  function Oy(o, i, u) {
    var f = i.pendingProps, g = f.revealOrder, S = f.tail;
    f = f.children;
    var A = Mt.current, T = (A & 2) !== 0;
    if (T ? (A = A & 1 | 2, i.flags |= 128) : A &= 1, U(Mt, A), nn(o, i, f, u), f = Ge ? Qi : 0, !T && o !== null && (o.flags & 128) !== 0)
      e: for (o = i.child; o !== null; ) {
        if (o.tag === 13)
          o.memoizedState !== null && Cy(o, u, i);
        else if (o.tag === 19)
          Cy(o, u, i);
        else if (o.child !== null) {
          o.child.return = o, o = o.child;
          continue;
        }
        if (o === i) break e;
        for (; o.sibling === null; ) {
          if (o.return === null || o.return === i)
            break e;
          o = o.return;
        }
        o.sibling.return = o.return, o = o.sibling;
      }
    switch (g) {
      case "forwards":
        for (u = i.child, g = null; u !== null; )
          o = u.alternate, o !== null && du(o) === null && (g = u), u = u.sibling;
        u = g, u === null ? (g = i.child, i.child = null) : (g = u.sibling, u.sibling = null), Xf(
          i,
          !1,
          g,
          u,
          S,
          f
        );
        break;
      case "backwards":
      case "unstable_legacy-backwards":
        for (u = null, g = i.child, i.child = null; g !== null; ) {
          if (o = g.alternate, o !== null && du(o) === null) {
            i.child = g;
            break;
          }
          o = g.sibling, g.sibling = u, u = g, g = o;
        }
        Xf(
          i,
          !0,
          u,
          null,
          S,
          f
        );
        break;
      case "together":
        Xf(
          i,
          !1,
          null,
          null,
          void 0,
          f
        );
        break;
      default:
        i.memoizedState = null;
    }
    return i.child;
  }
  function Vr(o, i, u) {
    if (o !== null && (i.dependencies = o.dependencies), yo |= i.lanes, (u & i.childLanes) === 0)
      if (o !== null) {
        if (qa(
          o,
          i,
          u,
          !1
        ), (u & i.childLanes) === 0)
          return null;
      } else return null;
    if (o !== null && i.child !== o.child)
      throw Error(r(153));
    if (i.child !== null) {
      for (o = i.child, u = Lr(o, o.pendingProps), i.child = u, u.return = i; o.sibling !== null; )
        o = o.sibling, u = u.sibling = Lr(o, o.pendingProps), u.return = i;
      u.sibling = null;
    }
    return i.child;
  }
  function Yf(o, i) {
    return (o.lanes & i) !== 0 ? !0 : (o = o.dependencies, !!(o !== null && ru(o)));
  }
  function FC(o, i, u) {
    switch (i.tag) {
      case 3:
        le(i, i.stateNode.containerInfo), uo(i, jt, o.memoizedState.cache), ia();
        break;
      case 27:
      case 5:
        ve(i);
        break;
      case 4:
        le(i, i.stateNode.containerInfo);
        break;
      case 10:
        uo(
          i,
          i.type,
          i.memoizedProps.value
        );
        break;
      case 31:
        if (i.memoizedState !== null)
          return i.flags |= 128, xf(i), null;
        break;
      case 13:
        var f = i.memoizedState;
        if (f !== null)
          return f.dehydrated !== null ? (mo(i), i.flags |= 128, null) : (u & i.child.childLanes) !== 0 ? Ey(o, i, u) : (mo(i), o = Vr(
            o,
            i,
            u
          ), o !== null ? o.sibling : null);
        mo(i);
        break;
      case 19:
        var g = (o.flags & 128) !== 0;
        if (f = (u & i.childLanes) !== 0, f || (qa(
          o,
          i,
          u,
          !1
        ), f = (u & i.childLanes) !== 0), g) {
          if (f)
            return Oy(
              o,
              i,
              u
            );
          i.flags |= 128;
        }
        if (g = i.memoizedState, g !== null && (g.rendering = null, g.tail = null, g.lastEffect = null), U(Mt, Mt.current), f) break;
        return null;
      case 22:
        return i.lanes = 0, by(
          o,
          i,
          u,
          i.pendingProps
        );
      case 24:
        uo(i, jt, o.memoizedState.cache);
    }
    return Vr(o, i, u);
  }
  function My(o, i, u) {
    if (o !== null)
      if (o.memoizedProps !== i.pendingProps)
        Dt = !0;
      else {
        if (!Yf(o, u) && (i.flags & 128) === 0)
          return Dt = !1, FC(
            o,
            i,
            u
          );
        Dt = (o.flags & 131072) !== 0;
      }
    else
      Dt = !1, Ge && (i.flags & 1048576) !== 0 && iv(i, Qi, i.index);
    switch (i.lanes = 0, i.tag) {
      case 16:
        e: {
          var f = i.pendingProps;
          if (o = ca(i.elementType), i.type = o, typeof o == "function")
            ef(o) ? (f = ma(o, f), i.tag = 1, i = ky(
              null,
              i,
              o,
              f,
              u
            )) : (i.tag = 0, i = Vf(
              null,
              i,
              o,
              f,
              u
            ));
          else {
            if (o != null) {
              var g = o.$$typeof;
              if (g === O) {
                i.tag = 11, i = gy(
                  null,
                  i,
                  o,
                  f,
                  u
                );
                break e;
              } else if (g === j) {
                i.tag = 14, i = vy(
                  null,
                  i,
                  o,
                  f,
                  u
                );
                break e;
              }
            }
            throw i = I(o) || o, Error(r(306, i, ""));
          }
        }
        return i;
      case 0:
        return Vf(
          o,
          i,
          i.type,
          i.pendingProps,
          u
        );
      case 1:
        return f = i.type, g = ma(
          f,
          i.pendingProps
        ), ky(
          o,
          i,
          f,
          g,
          u
        );
      case 3:
        e: {
          if (le(
            i,
            i.stateNode.containerInfo
          ), o === null) throw Error(r(387));
          f = i.pendingProps;
          var S = i.memoizedState;
          g = S.element, gf(o, i), as(i, f, null, u);
          var A = i.memoizedState;
          if (f = A.cache, uo(i, jt, f), f !== S.cache && cf(
            i,
            [jt],
            u,
            !0
          ), os(), f = A.element, S.isDehydrated)
            if (S = {
              element: f,
              isDehydrated: !1,
              cache: A.cache
            }, i.updateQueue.baseState = S, i.memoizedState = S, i.flags & 256) {
              i = _y(
                o,
                i,
                f,
                u
              );
              break e;
            } else if (f !== g) {
              g = Zn(
                Error(r(424)),
                i
              ), Ji(g), i = _y(
                o,
                i,
                f,
                u
              );
              break e;
            } else
              for (o = i.stateNode.containerInfo, o.nodeType === 9 ? o = o.body : o = o.nodeName === "HTML" ? o.ownerDocument.body : o, gt = rr(o.firstChild), en = i, Ge = !0, so = null, nr = !0, u = bv(
                i,
                null,
                f,
                u
              ), i.child = u; u; )
                u.flags = u.flags & -3 | 4096, u = u.sibling;
          else {
            if (ia(), f === g) {
              i = Vr(
                o,
                i,
                u
              );
              break e;
            }
            nn(o, i, f, u);
          }
          i = i.child;
        }
        return i;
      case 26:
        return Su(o, i), o === null ? (u = zb(
          i.type,
          null,
          i.pendingProps,
          null
        )) ? i.memoizedState = u : Ge || (u = i.type, o = i.pendingProps, f = zu(
          re.current
        ).createElement(u), f[Yt] = i, f[mn] = o, rn(f, u, o), Bt(f), i.stateNode = f) : i.memoizedState = zb(
          i.type,
          o.memoizedProps,
          i.pendingProps,
          o.memoizedState
        ), null;
      case 27:
        return ve(i), o === null && Ge && (f = i.stateNode = Tb(
          i.type,
          i.pendingProps,
          re.current
        ), en = i, nr = !0, g = gt, ko(i.type) ? (Np = g, gt = rr(f.firstChild)) : gt = g), nn(
          o,
          i,
          i.pendingProps.children,
          u
        ), Su(o, i), o === null && (i.flags |= 4194304), i.child;
      case 5:
        return o === null && Ge && ((g = f = gt) && (f = gO(
          f,
          i.type,
          i.pendingProps,
          nr
        ), f !== null ? (i.stateNode = f, en = i, gt = rr(f.firstChild), nr = !1, g = !0) : g = !1), g || lo(i)), ve(i), g = i.type, S = i.pendingProps, A = o !== null ? o.memoizedProps : null, f = S.children, _p(g, S) ? f = null : A !== null && _p(g, A) && (i.flags |= 32), i.memoizedState !== null && (g = kf(
          o,
          i,
          AC,
          null,
          null,
          u
        ), Es._currentValue = g), Su(o, i), nn(o, i, f, u), i.child;
      case 6:
        return o === null && Ge && ((o = u = gt) && (u = vO(
          u,
          i.pendingProps,
          nr
        ), u !== null ? (i.stateNode = u, en = i, gt = null, o = !0) : o = !1), o || lo(i)), null;
      case 13:
        return Ey(o, i, u);
      case 4:
        return le(
          i,
          i.stateNode.containerInfo
        ), f = i.pendingProps, o === null ? i.child = fa(
          i,
          null,
          f,
          u
        ) : nn(o, i, f, u), i.child;
      case 11:
        return gy(
          o,
          i,
          i.type,
          i.pendingProps,
          u
        );
      case 7:
        return nn(
          o,
          i,
          i.pendingProps,
          u
        ), i.child;
      case 8:
        return nn(
          o,
          i,
          i.pendingProps.children,
          u
        ), i.child;
      case 12:
        return nn(
          o,
          i,
          i.pendingProps.children,
          u
        ), i.child;
      case 10:
        return f = i.pendingProps, uo(i, i.type, f.value), nn(o, i, f.children, u), i.child;
      case 9:
        return g = i.type._context, f = i.pendingProps.children, la(i), g = tn(g), f = f(g), i.flags |= 1, nn(o, i, f, u), i.child;
      case 14:
        return vy(
          o,
          i,
          i.type,
          i.pendingProps,
          u
        );
      case 15:
        return yy(
          o,
          i,
          i.type,
          i.pendingProps,
          u
        );
      case 19:
        return Oy(o, i, u);
      case 31:
        return zC(o, i, u);
      case 22:
        return by(
          o,
          i,
          u,
          i.pendingProps
        );
      case 24:
        return la(i), f = tn(jt), o === null ? (g = pf(), g === null && (g = lt, S = df(), g.pooledCache = S, S.refCount++, S !== null && (g.pooledCacheLanes |= u), g = S), i.memoizedState = { parent: f, cache: g }, hf(i), uo(i, jt, g)) : ((o.lanes & u) !== 0 && (gf(o, i), as(i, null, null, u), os()), g = o.memoizedState, S = i.memoizedState, g.parent !== f ? (g = { parent: f, cache: f }, i.memoizedState = g, i.lanes === 0 && (i.memoizedState = i.updateQueue.baseState = g), uo(i, jt, f)) : (f = S.cache, uo(i, jt, f), f !== g.cache && cf(
          i,
          [jt],
          u,
          !0
        ))), nn(
          o,
          i,
          i.pendingProps.children,
          u
        ), i.child;
      case 29:
        throw i.pendingProps;
    }
    throw Error(r(156, i.tag));
  }
  function Hr(o) {
    o.flags |= 4;
  }
  function Qf(o, i, u, f, g) {
    if ((i = (o.mode & 32) !== 0) && (i = !1), i) {
      if (o.flags |= 16777216, (g & 335544128) === g)
        if (o.stateNode.complete) o.flags |= 8192;
        else if (tb()) o.flags |= 8192;
        else
          throw da = su, mf;
    } else o.flags &= -16777217;
  }
  function Ny(o, i) {
    if (i.type !== "stylesheet" || (i.state.loading & 4) !== 0)
      o.flags &= -16777217;
    else if (o.flags |= 16777216, !Hb(i))
      if (tb()) o.flags |= 8192;
      else
        throw da = su, mf;
  }
  function _u(o, i) {
    i !== null && (o.flags |= 4), o.flags & 16384 && (i = o.tag !== 22 ? xd() : 536870912, o.lanes |= i, ri |= i);
  }
  function ds(o, i) {
    if (!Ge)
      switch (o.tailMode) {
        case "hidden":
          i = o.tail;
          for (var u = null; i !== null; )
            i.alternate !== null && (u = i), i = i.sibling;
          u === null ? o.tail = null : u.sibling = null;
          break;
        case "collapsed":
          u = o.tail;
          for (var f = null; u !== null; )
            u.alternate !== null && (f = u), u = u.sibling;
          f === null ? i || o.tail === null ? o.tail = null : o.tail.sibling = null : f.sibling = null;
      }
  }
  function vt(o) {
    var i = o.alternate !== null && o.alternate.child === o.child, u = 0, f = 0;
    if (i)
      for (var g = o.child; g !== null; )
        u |= g.lanes | g.childLanes, f |= g.subtreeFlags & 65011712, f |= g.flags & 65011712, g.return = o, g = g.sibling;
    else
      for (g = o.child; g !== null; )
        u |= g.lanes | g.childLanes, f |= g.subtreeFlags, f |= g.flags, g.return = o, g = g.sibling;
    return o.subtreeFlags |= f, o.childLanes = u, i;
  }
  function BC(o, i, u) {
    var f = i.pendingProps;
    switch (of(i), i.tag) {
      case 16:
      case 15:
      case 0:
      case 11:
      case 7:
      case 8:
      case 12:
      case 9:
      case 14:
        return vt(i), null;
      case 1:
        return vt(i), null;
      case 3:
        return u = i.stateNode, f = null, o !== null && (f = o.memoizedState.cache), i.memoizedState.cache !== f && (i.flags |= 2048), Fr(jt), me(), u.pendingContext && (u.context = u.pendingContext, u.pendingContext = null), (o === null || o.child === null) && (Ha(i) ? Hr(i) : o === null || o.memoizedState.isDehydrated && (i.flags & 256) === 0 || (i.flags |= 1024, sf())), vt(i), null;
      case 26:
        var g = i.type, S = i.memoizedState;
        return o === null ? (Hr(i), S !== null ? (vt(i), Ny(i, S)) : (vt(i), Qf(
          i,
          g,
          null,
          f,
          u
        ))) : S ? S !== o.memoizedState ? (Hr(i), vt(i), Ny(i, S)) : (vt(i), i.flags &= -16777217) : (o = o.memoizedProps, o !== f && Hr(i), vt(i), Qf(
          i,
          g,
          o,
          f,
          u
        )), null;
      case 27:
        if (ae(i), u = re.current, g = i.type, o !== null && i.stateNode != null)
          o.memoizedProps !== f && Hr(i);
        else {
          if (!f) {
            if (i.stateNode === null)
              throw Error(r(166));
            return vt(i), null;
          }
          o = H.current, Ha(i) ? lv(i) : (o = Tb(g, f, u), i.stateNode = o, Hr(i));
        }
        return vt(i), null;
      case 5:
        if (ae(i), g = i.type, o !== null && i.stateNode != null)
          o.memoizedProps !== f && Hr(i);
        else {
          if (!f) {
            if (i.stateNode === null)
              throw Error(r(166));
            return vt(i), null;
          }
          if (S = H.current, Ha(i))
            lv(i);
          else {
            var A = zu(
              re.current
            );
            switch (S) {
              case 1:
                S = A.createElementNS(
                  "http://www.w3.org/2000/svg",
                  g
                );
                break;
              case 2:
                S = A.createElementNS(
                  "http://www.w3.org/1998/Math/MathML",
                  g
                );
                break;
              default:
                switch (g) {
                  case "svg":
                    S = A.createElementNS(
                      "http://www.w3.org/2000/svg",
                      g
                    );
                    break;
                  case "math":
                    S = A.createElementNS(
                      "http://www.w3.org/1998/Math/MathML",
                      g
                    );
                    break;
                  case "script":
                    S = A.createElement("div"), S.innerHTML = "<script><\/script>", S = S.removeChild(
                      S.firstChild
                    );
                    break;
                  case "select":
                    S = typeof f.is == "string" ? A.createElement("select", {
                      is: f.is
                    }) : A.createElement("select"), f.multiple ? S.multiple = !0 : f.size && (S.size = f.size);
                    break;
                  default:
                    S = typeof f.is == "string" ? A.createElement(g, { is: f.is }) : A.createElement(g);
                }
            }
            S[Yt] = i, S[mn] = f;
            e: for (A = i.child; A !== null; ) {
              if (A.tag === 5 || A.tag === 6)
                S.appendChild(A.stateNode);
              else if (A.tag !== 4 && A.tag !== 27 && A.child !== null) {
                A.child.return = A, A = A.child;
                continue;
              }
              if (A === i) break e;
              for (; A.sibling === null; ) {
                if (A.return === null || A.return === i)
                  break e;
                A = A.return;
              }
              A.sibling.return = A.return, A = A.sibling;
            }
            i.stateNode = S;
            e: switch (rn(S, g, f), g) {
              case "button":
              case "input":
              case "select":
              case "textarea":
                f = !!f.autoFocus;
                break e;
              case "img":
                f = !0;
                break e;
              default:
                f = !1;
            }
            f && Hr(i);
          }
        }
        return vt(i), Qf(
          i,
          i.type,
          o === null ? null : o.memoizedProps,
          i.pendingProps,
          u
        ), null;
      case 6:
        if (o && i.stateNode != null)
          o.memoizedProps !== f && Hr(i);
        else {
          if (typeof f != "string" && i.stateNode === null)
            throw Error(r(166));
          if (o = re.current, Ha(i)) {
            if (o = i.stateNode, u = i.memoizedProps, f = null, g = en, g !== null)
              switch (g.tag) {
                case 27:
                case 5:
                  f = g.memoizedProps;
              }
            o[Yt] = i, o = !!(o.nodeValue === u || f !== null && f.suppressHydrationWarning === !0 || Eb(o.nodeValue, u)), o || lo(i, !0);
          } else
            o = zu(o).createTextNode(
              f
            ), o[Yt] = i, i.stateNode = o;
        }
        return vt(i), null;
      case 31:
        if (u = i.memoizedState, o === null || o.memoizedState !== null) {
          if (f = Ha(i), u !== null) {
            if (o === null) {
              if (!f) throw Error(r(318));
              if (o = i.memoizedState, o = o !== null ? o.dehydrated : null, !o) throw Error(r(557));
              o[Yt] = i;
            } else
              ia(), (i.flags & 128) === 0 && (i.memoizedState = null), i.flags |= 4;
            vt(i), o = !1;
          } else
            u = sf(), o !== null && o.memoizedState !== null && (o.memoizedState.hydrationErrors = u), o = !0;
          if (!o)
            return i.flags & 256 ? (Fn(i), i) : (Fn(i), null);
          if ((i.flags & 128) !== 0)
            throw Error(r(558));
        }
        return vt(i), null;
      case 13:
        if (f = i.memoizedState, o === null || o.memoizedState !== null && o.memoizedState.dehydrated !== null) {
          if (g = Ha(i), f !== null && f.dehydrated !== null) {
            if (o === null) {
              if (!g) throw Error(r(318));
              if (g = i.memoizedState, g = g !== null ? g.dehydrated : null, !g) throw Error(r(317));
              g[Yt] = i;
            } else
              ia(), (i.flags & 128) === 0 && (i.memoizedState = null), i.flags |= 4;
            vt(i), g = !1;
          } else
            g = sf(), o !== null && o.memoizedState !== null && (o.memoizedState.hydrationErrors = g), g = !0;
          if (!g)
            return i.flags & 256 ? (Fn(i), i) : (Fn(i), null);
        }
        return Fn(i), (i.flags & 128) !== 0 ? (i.lanes = u, i) : (u = f !== null, o = o !== null && o.memoizedState !== null, u && (f = i.child, g = null, f.alternate !== null && f.alternate.memoizedState !== null && f.alternate.memoizedState.cachePool !== null && (g = f.alternate.memoizedState.cachePool.pool), S = null, f.memoizedState !== null && f.memoizedState.cachePool !== null && (S = f.memoizedState.cachePool.pool), S !== g && (f.flags |= 2048)), u !== o && u && (i.child.flags |= 8192), _u(i, i.updateQueue), vt(i), null);
      case 4:
        return me(), o === null && bp(i.stateNode.containerInfo), vt(i), null;
      case 10:
        return Fr(i.type), vt(i), null;
      case 19:
        if (X(Mt), f = i.memoizedState, f === null) return vt(i), null;
        if (g = (i.flags & 128) !== 0, S = f.rendering, S === null)
          if (g) ds(f, !1);
          else {
            if (St !== 0 || o !== null && (o.flags & 128) !== 0)
              for (o = i.child; o !== null; ) {
                if (S = du(o), S !== null) {
                  for (i.flags |= 128, ds(f, !1), o = S.updateQueue, i.updateQueue = o, _u(i, o), i.subtreeFlags = 0, o = u, u = i.child; u !== null; )
                    rv(u, o), u = u.sibling;
                  return U(
                    Mt,
                    Mt.current & 1 | 2
                  ), Ge && Ir(i, f.treeForkCount), i.child;
                }
                o = o.sibling;
              }
            f.tail !== null && Ce() > Nu && (i.flags |= 128, g = !0, ds(f, !1), i.lanes = 4194304);
          }
        else {
          if (!g)
            if (o = du(S), o !== null) {
              if (i.flags |= 128, g = !0, o = o.updateQueue, i.updateQueue = o, _u(i, o), ds(f, !0), f.tail === null && f.tailMode === "hidden" && !S.alternate && !Ge)
                return vt(i), null;
            } else
              2 * Ce() - f.renderingStartTime > Nu && u !== 536870912 && (i.flags |= 128, g = !0, ds(f, !1), i.lanes = 4194304);
          f.isBackwards ? (S.sibling = i.child, i.child = S) : (o = f.last, o !== null ? o.sibling = S : i.child = S, f.last = S);
        }
        return f.tail !== null ? (o = f.tail, f.rendering = o, f.tail = o.sibling, f.renderingStartTime = Ce(), o.sibling = null, u = Mt.current, U(
          Mt,
          g ? u & 1 | 2 : u & 1
        ), Ge && Ir(i, f.treeForkCount), o) : (vt(i), null);
      case 22:
      case 23:
        return Fn(i), wf(), f = i.memoizedState !== null, o !== null ? o.memoizedState !== null !== f && (i.flags |= 8192) : f && (i.flags |= 8192), f ? (u & 536870912) !== 0 && (i.flags & 128) === 0 && (vt(i), i.subtreeFlags & 6 && (i.flags |= 8192)) : vt(i), u = i.updateQueue, u !== null && _u(i, u.retryQueue), u = null, o !== null && o.memoizedState !== null && o.memoizedState.cachePool !== null && (u = o.memoizedState.cachePool.pool), f = null, i.memoizedState !== null && i.memoizedState.cachePool !== null && (f = i.memoizedState.cachePool.pool), f !== u && (i.flags |= 2048), o !== null && X(ua), null;
      case 24:
        return u = null, o !== null && (u = o.memoizedState.cache), i.memoizedState.cache !== u && (i.flags |= 2048), Fr(jt), vt(i), null;
      case 25:
        return null;
      case 30:
        return null;
    }
    throw Error(r(156, i.tag));
  }
  function UC(o, i) {
    switch (of(i), i.tag) {
      case 1:
        return o = i.flags, o & 65536 ? (i.flags = o & -65537 | 128, i) : null;
      case 3:
        return Fr(jt), me(), o = i.flags, (o & 65536) !== 0 && (o & 128) === 0 ? (i.flags = o & -65537 | 128, i) : null;
      case 26:
      case 27:
      case 5:
        return ae(i), null;
      case 31:
        if (i.memoizedState !== null) {
          if (Fn(i), i.alternate === null)
            throw Error(r(340));
          ia();
        }
        return o = i.flags, o & 65536 ? (i.flags = o & -65537 | 128, i) : null;
      case 13:
        if (Fn(i), o = i.memoizedState, o !== null && o.dehydrated !== null) {
          if (i.alternate === null)
            throw Error(r(340));
          ia();
        }
        return o = i.flags, o & 65536 ? (i.flags = o & -65537 | 128, i) : null;
      case 19:
        return X(Mt), null;
      case 4:
        return me(), null;
      case 10:
        return Fr(i.type), null;
      case 22:
      case 23:
        return Fn(i), wf(), o !== null && X(ua), o = i.flags, o & 65536 ? (i.flags = o & -65537 | 128, i) : null;
      case 24:
        return Fr(jt), null;
      case 25:
        return null;
      default:
        return null;
    }
  }
  function Ry(o, i) {
    switch (of(i), i.tag) {
      case 3:
        Fr(jt), me();
        break;
      case 26:
      case 27:
      case 5:
        ae(i);
        break;
      case 4:
        me();
        break;
      case 31:
        i.memoizedState !== null && Fn(i);
        break;
      case 13:
        Fn(i);
        break;
      case 19:
        X(Mt);
        break;
      case 10:
        Fr(i.type);
        break;
      case 22:
      case 23:
        Fn(i), wf(), o !== null && X(ua);
        break;
      case 24:
        Fr(jt);
    }
  }
  function fs(o, i) {
    try {
      var u = i.updateQueue, f = u !== null ? u.lastEffect : null;
      if (f !== null) {
        var g = f.next;
        u = g;
        do {
          if ((u.tag & o) === o) {
            f = void 0;
            var S = u.create, A = u.inst;
            f = S(), A.destroy = f;
          }
          u = u.next;
        } while (u !== g);
      }
    } catch (T) {
      rt(i, i.return, T);
    }
  }
  function go(o, i, u) {
    try {
      var f = i.updateQueue, g = f !== null ? f.lastEffect : null;
      if (g !== null) {
        var S = g.next;
        f = S;
        do {
          if ((f.tag & o) === o) {
            var A = f.inst, T = A.destroy;
            if (T !== void 0) {
              A.destroy = void 0, g = i;
              var Y = u, ne = T;
              try {
                ne();
              } catch (ue) {
                rt(
                  g,
                  Y,
                  ue
                );
              }
            }
          }
          f = f.next;
        } while (f !== S);
      }
    } catch (ue) {
      rt(i, i.return, ue);
    }
  }
  function Ay(o) {
    var i = o.updateQueue;
    if (i !== null) {
      var u = o.stateNode;
      try {
        xv(i, u);
      } catch (f) {
        rt(o, o.return, f);
      }
    }
  }
  function jy(o, i, u) {
    u.props = ma(
      o.type,
      o.memoizedProps
    ), u.state = o.memoizedState;
    try {
      u.componentWillUnmount();
    } catch (f) {
      rt(o, i, f);
    }
  }
  function ps(o, i) {
    try {
      var u = o.ref;
      if (u !== null) {
        switch (o.tag) {
          case 26:
          case 27:
          case 5:
            var f = o.stateNode;
            break;
          case 30:
            f = o.stateNode;
            break;
          default:
            f = o.stateNode;
        }
        typeof u == "function" ? o.refCleanup = u(f) : u.current = f;
      }
    } catch (g) {
      rt(o, i, g);
    }
  }
  function _r(o, i) {
    var u = o.ref, f = o.refCleanup;
    if (u !== null)
      if (typeof f == "function")
        try {
          f();
        } catch (g) {
          rt(o, i, g);
        } finally {
          o.refCleanup = null, o = o.alternate, o != null && (o.refCleanup = null);
        }
      else if (typeof u == "function")
        try {
          u(null);
        } catch (g) {
          rt(o, i, g);
        }
      else u.current = null;
  }
  function Py(o) {
    var i = o.type, u = o.memoizedProps, f = o.stateNode;
    try {
      e: switch (i) {
        case "button":
        case "input":
        case "select":
        case "textarea":
          u.autoFocus && f.focus();
          break e;
        case "img":
          u.src ? f.src = u.src : u.srcSet && (f.srcset = u.srcSet);
      }
    } catch (g) {
      rt(o, o.return, g);
    }
  }
  function Jf(o, i, u) {
    try {
      var f = o.stateNode;
      cO(f, o.type, u, i), f[mn] = i;
    } catch (g) {
      rt(o, o.return, g);
    }
  }
  function Dy(o) {
    return o.tag === 5 || o.tag === 3 || o.tag === 26 || o.tag === 27 && ko(o.type) || o.tag === 4;
  }
  function Zf(o) {
    e: for (; ; ) {
      for (; o.sibling === null; ) {
        if (o.return === null || Dy(o.return)) return null;
        o = o.return;
      }
      for (o.sibling.return = o.return, o = o.sibling; o.tag !== 5 && o.tag !== 6 && o.tag !== 18; ) {
        if (o.tag === 27 && ko(o.type) || o.flags & 2 || o.child === null || o.tag === 4) continue e;
        o.child.return = o, o = o.child;
      }
      if (!(o.flags & 2)) return o.stateNode;
    }
  }
  function ep(o, i, u) {
    var f = o.tag;
    if (f === 5 || f === 6)
      o = o.stateNode, i ? (u.nodeType === 9 ? u.body : u.nodeName === "HTML" ? u.ownerDocument.body : u).insertBefore(o, i) : (i = u.nodeType === 9 ? u.body : u.nodeName === "HTML" ? u.ownerDocument.body : u, i.appendChild(o), u = u._reactRootContainer, u != null || i.onclick !== null || (i.onclick = $r));
    else if (f !== 4 && (f === 27 && ko(o.type) && (u = o.stateNode, i = null), o = o.child, o !== null))
      for (ep(o, i, u), o = o.sibling; o !== null; )
        ep(o, i, u), o = o.sibling;
  }
  function Eu(o, i, u) {
    var f = o.tag;
    if (f === 5 || f === 6)
      o = o.stateNode, i ? u.insertBefore(o, i) : u.appendChild(o);
    else if (f !== 4 && (f === 27 && ko(o.type) && (u = o.stateNode), o = o.child, o !== null))
      for (Eu(o, i, u), o = o.sibling; o !== null; )
        Eu(o, i, u), o = o.sibling;
  }
  function $y(o) {
    var i = o.stateNode, u = o.memoizedProps;
    try {
      for (var f = o.type, g = i.attributes; g.length; )
        i.removeAttributeNode(g[0]);
      rn(i, f, u), i[Yt] = o, i[mn] = u;
    } catch (S) {
      rt(o, o.return, S);
    }
  }
  var qr = !1, $t = !1, tp = !1, Ty = typeof WeakSet == "function" ? WeakSet : Set, Qt = null;
  function VC(o, i) {
    if (o = o.containerInfo, Sp = Wu, o = Kg(o), Gd(o)) {
      if ("selectionStart" in o)
        var u = {
          start: o.selectionStart,
          end: o.selectionEnd
        };
      else
        e: {
          u = (u = o.ownerDocument) && u.defaultView || window;
          var f = u.getSelection && u.getSelection();
          if (f && f.rangeCount !== 0) {
            u = f.anchorNode;
            var g = f.anchorOffset, S = f.focusNode;
            f = f.focusOffset;
            try {
              u.nodeType, S.nodeType;
            } catch {
              u = null;
              break e;
            }
            var A = 0, T = -1, Y = -1, ne = 0, ue = 0, fe = o, oe = null;
            t: for (; ; ) {
              for (var ie; fe !== u || g !== 0 && fe.nodeType !== 3 || (T = A + g), fe !== S || f !== 0 && fe.nodeType !== 3 || (Y = A + f), fe.nodeType === 3 && (A += fe.nodeValue.length), (ie = fe.firstChild) !== null; )
                oe = fe, fe = ie;
              for (; ; ) {
                if (fe === o) break t;
                if (oe === u && ++ne === g && (T = A), oe === S && ++ue === f && (Y = A), (ie = fe.nextSibling) !== null) break;
                fe = oe, oe = fe.parentNode;
              }
              fe = ie;
            }
            u = T === -1 || Y === -1 ? null : { start: T, end: Y };
          } else u = null;
        }
      u = u || { start: 0, end: 0 };
    } else u = null;
    for (kp = { focusedElem: o, selectionRange: u }, Wu = !1, Qt = i; Qt !== null; )
      if (i = Qt, o = i.child, (i.subtreeFlags & 1028) !== 0 && o !== null)
        o.return = i, Qt = o;
      else
        for (; Qt !== null; ) {
          switch (i = Qt, S = i.alternate, o = i.flags, i.tag) {
            case 0:
              if ((o & 4) !== 0 && (o = i.updateQueue, o = o !== null ? o.events : null, o !== null))
                for (u = 0; u < o.length; u++)
                  g = o[u], g.ref.impl = g.nextImpl;
              break;
            case 11:
            case 15:
              break;
            case 1:
              if ((o & 1024) !== 0 && S !== null) {
                o = void 0, u = i, g = S.memoizedProps, S = S.memoizedState, f = u.stateNode;
                try {
                  var we = ma(
                    u.type,
                    g
                  );
                  o = f.getSnapshotBeforeUpdate(
                    we,
                    S
                  ), f.__reactInternalSnapshotBeforeUpdate = o;
                } catch (Ne) {
                  rt(
                    u,
                    u.return,
                    Ne
                  );
                }
              }
              break;
            case 3:
              if ((o & 1024) !== 0) {
                if (o = i.stateNode.containerInfo, u = o.nodeType, u === 9)
                  Cp(o);
                else if (u === 1)
                  switch (o.nodeName) {
                    case "HEAD":
                    case "HTML":
                    case "BODY":
                      Cp(o);
                      break;
                    default:
                      o.textContent = "";
                  }
              }
              break;
            case 5:
            case 26:
            case 27:
            case 6:
            case 4:
            case 17:
              break;
            default:
              if ((o & 1024) !== 0) throw Error(r(163));
          }
          if (o = i.sibling, o !== null) {
            o.return = i.return, Qt = o;
            break;
          }
          Qt = i.return;
        }
  }
  function Ly(o, i, u) {
    var f = u.flags;
    switch (u.tag) {
      case 0:
      case 11:
      case 15:
        Gr(o, u), f & 4 && fs(5, u);
        break;
      case 1:
        if (Gr(o, u), f & 4)
          if (o = u.stateNode, i === null)
            try {
              o.componentDidMount();
            } catch (A) {
              rt(u, u.return, A);
            }
          else {
            var g = ma(
              u.type,
              i.memoizedProps
            );
            i = i.memoizedState;
            try {
              o.componentDidUpdate(
                g,
                i,
                o.__reactInternalSnapshotBeforeUpdate
              );
            } catch (A) {
              rt(
                u,
                u.return,
                A
              );
            }
          }
        f & 64 && Ay(u), f & 512 && ps(u, u.return);
        break;
      case 3:
        if (Gr(o, u), f & 64 && (o = u.updateQueue, o !== null)) {
          if (i = null, u.child !== null)
            switch (u.child.tag) {
              case 27:
              case 5:
                i = u.child.stateNode;
                break;
              case 1:
                i = u.child.stateNode;
            }
          try {
            xv(o, i);
          } catch (A) {
            rt(u, u.return, A);
          }
        }
        break;
      case 27:
        i === null && f & 4 && $y(u);
      case 26:
      case 5:
        Gr(o, u), i === null && f & 4 && Py(u), f & 512 && ps(u, u.return);
        break;
      case 12:
        Gr(o, u);
        break;
      case 31:
        Gr(o, u), f & 4 && Fy(o, u);
        break;
      case 13:
        Gr(o, u), f & 4 && By(o, u), f & 64 && (o = u.memoizedState, o !== null && (o = o.dehydrated, o !== null && (u = JC.bind(
          null,
          u
        ), yO(o, u))));
        break;
      case 22:
        if (f = u.memoizedState !== null || qr, !f) {
          i = i !== null && i.memoizedState !== null || $t, g = qr;
          var S = $t;
          qr = f, ($t = i) && !S ? Kr(
            o,
            u,
            (u.subtreeFlags & 8772) !== 0
          ) : Gr(o, u), qr = g, $t = S;
        }
        break;
      case 30:
        break;
      default:
        Gr(o, u);
    }
  }
  function Iy(o) {
    var i = o.alternate;
    i !== null && (o.alternate = null, Iy(i)), o.child = null, o.deletions = null, o.sibling = null, o.tag === 5 && (i = o.stateNode, i !== null && Ul(i)), o.stateNode = null, o.return = null, o.dependencies = null, o.memoizedProps = null, o.memoizedState = null, o.pendingProps = null, o.stateNode = null, o.updateQueue = null;
  }
  var yt = null, En = !1;
  function Wr(o, i, u) {
    for (u = u.child; u !== null; )
      zy(o, i, u), u = u.sibling;
  }
  function zy(o, i, u) {
    if (Ot && typeof Ot.onCommitFiberUnmount == "function")
      try {
        Ot.onCommitFiberUnmount(Wt, u);
      } catch {
      }
    switch (u.tag) {
      case 26:
        $t || _r(u, i), Wr(
          o,
          i,
          u
        ), u.memoizedState ? u.memoizedState.count-- : u.stateNode && (u = u.stateNode, u.parentNode.removeChild(u));
        break;
      case 27:
        $t || _r(u, i);
        var f = yt, g = En;
        ko(u.type) && (yt = u.stateNode, En = !1), Wr(
          o,
          i,
          u
        ), Ss(u.stateNode), yt = f, En = g;
        break;
      case 5:
        $t || _r(u, i);
      case 6:
        if (f = yt, g = En, yt = null, Wr(
          o,
          i,
          u
        ), yt = f, En = g, yt !== null)
          if (En)
            try {
              (yt.nodeType === 9 ? yt.body : yt.nodeName === "HTML" ? yt.ownerDocument.body : yt).removeChild(u.stateNode);
            } catch (S) {
              rt(
                u,
                i,
                S
              );
            }
          else
            try {
              yt.removeChild(u.stateNode);
            } catch (S) {
              rt(
                u,
                i,
                S
              );
            }
        break;
      case 18:
        yt !== null && (En ? (o = yt, Ab(
          o.nodeType === 9 ? o.body : o.nodeName === "HTML" ? o.ownerDocument.body : o,
          u.stateNode
        ), di(o)) : Ab(yt, u.stateNode));
        break;
      case 4:
        f = yt, g = En, yt = u.stateNode.containerInfo, En = !0, Wr(
          o,
          i,
          u
        ), yt = f, En = g;
        break;
      case 0:
      case 11:
      case 14:
      case 15:
        go(2, u, i), $t || go(4, u, i), Wr(
          o,
          i,
          u
        );
        break;
      case 1:
        $t || (_r(u, i), f = u.stateNode, typeof f.componentWillUnmount == "function" && jy(
          u,
          i,
          f
        )), Wr(
          o,
          i,
          u
        );
        break;
      case 21:
        Wr(
          o,
          i,
          u
        );
        break;
      case 22:
        $t = (f = $t) || u.memoizedState !== null, Wr(
          o,
          i,
          u
        ), $t = f;
        break;
      default:
        Wr(
          o,
          i,
          u
        );
    }
  }
  function Fy(o, i) {
    if (i.memoizedState === null && (o = i.alternate, o !== null && (o = o.memoizedState, o !== null))) {
      o = o.dehydrated;
      try {
        di(o);
      } catch (u) {
        rt(i, i.return, u);
      }
    }
  }
  function By(o, i) {
    if (i.memoizedState === null && (o = i.alternate, o !== null && (o = o.memoizedState, o !== null && (o = o.dehydrated, o !== null))))
      try {
        di(o);
      } catch (u) {
        rt(i, i.return, u);
      }
  }
  function HC(o) {
    switch (o.tag) {
      case 31:
      case 13:
      case 19:
        var i = o.stateNode;
        return i === null && (i = o.stateNode = new Ty()), i;
      case 22:
        return o = o.stateNode, i = o._retryCache, i === null && (i = o._retryCache = new Ty()), i;
      default:
        throw Error(r(435, o.tag));
    }
  }
  function Cu(o, i) {
    var u = HC(o);
    i.forEach(function(f) {
      if (!u.has(f)) {
        u.add(f);
        var g = ZC.bind(null, o, f);
        f.then(g, g);
      }
    });
  }
  function Cn(o, i) {
    var u = i.deletions;
    if (u !== null)
      for (var f = 0; f < u.length; f++) {
        var g = u[f], S = o, A = i, T = A;
        e: for (; T !== null; ) {
          switch (T.tag) {
            case 27:
              if (ko(T.type)) {
                yt = T.stateNode, En = !1;
                break e;
              }
              break;
            case 5:
              yt = T.stateNode, En = !1;
              break e;
            case 3:
            case 4:
              yt = T.stateNode.containerInfo, En = !0;
              break e;
          }
          T = T.return;
        }
        if (yt === null) throw Error(r(160));
        zy(S, A, g), yt = null, En = !1, S = g.alternate, S !== null && (S.return = null), g.return = null;
      }
    if (i.subtreeFlags & 13886)
      for (i = i.child; i !== null; )
        Uy(i, o), i = i.sibling;
  }
  var hr = null;
  function Uy(o, i) {
    var u = o.alternate, f = o.flags;
    switch (o.tag) {
      case 0:
      case 11:
      case 14:
      case 15:
        Cn(i, o), On(o), f & 4 && (go(3, o, o.return), fs(3, o), go(5, o, o.return));
        break;
      case 1:
        Cn(i, o), On(o), f & 512 && ($t || u === null || _r(u, u.return)), f & 64 && qr && (o = o.updateQueue, o !== null && (f = o.callbacks, f !== null && (u = o.shared.hiddenCallbacks, o.shared.hiddenCallbacks = u === null ? f : u.concat(f))));
        break;
      case 26:
        var g = hr;
        if (Cn(i, o), On(o), f & 512 && ($t || u === null || _r(u, u.return)), f & 4) {
          var S = u !== null ? u.memoizedState : null;
          if (f = o.memoizedState, u === null)
            if (f === null)
              if (o.stateNode === null) {
                e: {
                  f = o.type, u = o.memoizedProps, g = g.ownerDocument || g;
                  t: switch (f) {
                    case "title":
                      S = g.getElementsByTagName("title")[0], (!S || S[Pa] || S[Yt] || S.namespaceURI === "http://www.w3.org/2000/svg" || S.hasAttribute("itemprop")) && (S = g.createElement(f), g.head.insertBefore(
                        S,
                        g.querySelector("head > title")
                      )), rn(S, f, u), S[Yt] = o, Bt(S), f = S;
                      break e;
                    case "link":
                      var A = Ub(
                        "link",
                        "href",
                        g
                      ).get(f + (u.href || ""));
                      if (A) {
                        for (var T = 0; T < A.length; T++)
                          if (S = A[T], S.getAttribute("href") === (u.href == null || u.href === "" ? null : u.href) && S.getAttribute("rel") === (u.rel == null ? null : u.rel) && S.getAttribute("title") === (u.title == null ? null : u.title) && S.getAttribute("crossorigin") === (u.crossOrigin == null ? null : u.crossOrigin)) {
                            A.splice(T, 1);
                            break t;
                          }
                      }
                      S = g.createElement(f), rn(S, f, u), g.head.appendChild(S);
                      break;
                    case "meta":
                      if (A = Ub(
                        "meta",
                        "content",
                        g
                      ).get(f + (u.content || ""))) {
                        for (T = 0; T < A.length; T++)
                          if (S = A[T], S.getAttribute("content") === (u.content == null ? null : "" + u.content) && S.getAttribute("name") === (u.name == null ? null : u.name) && S.getAttribute("property") === (u.property == null ? null : u.property) && S.getAttribute("http-equiv") === (u.httpEquiv == null ? null : u.httpEquiv) && S.getAttribute("charset") === (u.charSet == null ? null : u.charSet)) {
                            A.splice(T, 1);
                            break t;
                          }
                      }
                      S = g.createElement(f), rn(S, f, u), g.head.appendChild(S);
                      break;
                    default:
                      throw Error(r(468, f));
                  }
                  S[Yt] = o, Bt(S), f = S;
                }
                o.stateNode = f;
              } else
                Vb(
                  g,
                  o.type,
                  o.stateNode
                );
            else
              o.stateNode = Bb(
                g,
                f,
                o.memoizedProps
              );
          else
            S !== f ? (S === null ? u.stateNode !== null && (u = u.stateNode, u.parentNode.removeChild(u)) : S.count--, f === null ? Vb(
              g,
              o.type,
              o.stateNode
            ) : Bb(
              g,
              f,
              o.memoizedProps
            )) : f === null && o.stateNode !== null && Jf(
              o,
              o.memoizedProps,
              u.memoizedProps
            );
        }
        break;
      case 27:
        Cn(i, o), On(o), f & 512 && ($t || u === null || _r(u, u.return)), u !== null && f & 4 && Jf(
          o,
          o.memoizedProps,
          u.memoizedProps
        );
        break;
      case 5:
        if (Cn(i, o), On(o), f & 512 && ($t || u === null || _r(u, u.return)), o.flags & 32) {
          g = o.stateNode;
          try {
            Da(g, "");
          } catch (we) {
            rt(o, o.return, we);
          }
        }
        f & 4 && o.stateNode != null && (g = o.memoizedProps, Jf(
          o,
          g,
          u !== null ? u.memoizedProps : g
        )), f & 1024 && (tp = !0);
        break;
      case 6:
        if (Cn(i, o), On(o), f & 4) {
          if (o.stateNode === null)
            throw Error(r(162));
          f = o.memoizedProps, u = o.stateNode;
          try {
            u.nodeValue = f;
          } catch (we) {
            rt(o, o.return, we);
          }
        }
        break;
      case 3:
        if (Uu = null, g = hr, hr = Fu(i.containerInfo), Cn(i, o), hr = g, On(o), f & 4 && u !== null && u.memoizedState.isDehydrated)
          try {
            di(i.containerInfo);
          } catch (we) {
            rt(o, o.return, we);
          }
        tp && (tp = !1, Vy(o));
        break;
      case 4:
        f = hr, hr = Fu(
          o.stateNode.containerInfo
        ), Cn(i, o), On(o), hr = f;
        break;
      case 12:
        Cn(i, o), On(o);
        break;
      case 31:
        Cn(i, o), On(o), f & 4 && (f = o.updateQueue, f !== null && (o.updateQueue = null, Cu(o, f)));
        break;
      case 13:
        Cn(i, o), On(o), o.child.flags & 8192 && o.memoizedState !== null != (u !== null && u.memoizedState !== null) && (Mu = Ce()), f & 4 && (f = o.updateQueue, f !== null && (o.updateQueue = null, Cu(o, f)));
        break;
      case 22:
        g = o.memoizedState !== null;
        var Y = u !== null && u.memoizedState !== null, ne = qr, ue = $t;
        if (qr = ne || g, $t = ue || Y, Cn(i, o), $t = ue, qr = ne, On(o), f & 8192)
          e: for (i = o.stateNode, i._visibility = g ? i._visibility & -2 : i._visibility | 1, g && (u === null || Y || qr || $t || ha(o)), u = null, i = o; ; ) {
            if (i.tag === 5 || i.tag === 26) {
              if (u === null) {
                Y = u = i;
                try {
                  if (S = Y.stateNode, g)
                    A = S.style, typeof A.setProperty == "function" ? A.setProperty("display", "none", "important") : A.display = "none";
                  else {
                    T = Y.stateNode;
                    var fe = Y.memoizedProps.style, oe = fe != null && fe.hasOwnProperty("display") ? fe.display : null;
                    T.style.display = oe == null || typeof oe == "boolean" ? "" : ("" + oe).trim();
                  }
                } catch (we) {
                  rt(Y, Y.return, we);
                }
              }
            } else if (i.tag === 6) {
              if (u === null) {
                Y = i;
                try {
                  Y.stateNode.nodeValue = g ? "" : Y.memoizedProps;
                } catch (we) {
                  rt(Y, Y.return, we);
                }
              }
            } else if (i.tag === 18) {
              if (u === null) {
                Y = i;
                try {
                  var ie = Y.stateNode;
                  g ? jb(ie, !0) : jb(Y.stateNode, !1);
                } catch (we) {
                  rt(Y, Y.return, we);
                }
              }
            } else if ((i.tag !== 22 && i.tag !== 23 || i.memoizedState === null || i === o) && i.child !== null) {
              i.child.return = i, i = i.child;
              continue;
            }
            if (i === o) break e;
            for (; i.sibling === null; ) {
              if (i.return === null || i.return === o) break e;
              u === i && (u = null), i = i.return;
            }
            u === i && (u = null), i.sibling.return = i.return, i = i.sibling;
          }
        f & 4 && (f = o.updateQueue, f !== null && (u = f.retryQueue, u !== null && (f.retryQueue = null, Cu(o, u))));
        break;
      case 19:
        Cn(i, o), On(o), f & 4 && (f = o.updateQueue, f !== null && (o.updateQueue = null, Cu(o, f)));
        break;
      case 30:
        break;
      case 21:
        break;
      default:
        Cn(i, o), On(o);
    }
  }
  function On(o) {
    var i = o.flags;
    if (i & 2) {
      try {
        for (var u, f = o.return; f !== null; ) {
          if (Dy(f)) {
            u = f;
            break;
          }
          f = f.return;
        }
        if (u == null) throw Error(r(160));
        switch (u.tag) {
          case 27:
            var g = u.stateNode, S = Zf(o);
            Eu(o, S, g);
            break;
          case 5:
            var A = u.stateNode;
            u.flags & 32 && (Da(A, ""), u.flags &= -33);
            var T = Zf(o);
            Eu(o, T, A);
            break;
          case 3:
          case 4:
            var Y = u.stateNode.containerInfo, ne = Zf(o);
            ep(
              o,
              ne,
              Y
            );
            break;
          default:
            throw Error(r(161));
        }
      } catch (ue) {
        rt(o, o.return, ue);
      }
      o.flags &= -3;
    }
    i & 4096 && (o.flags &= -4097);
  }
  function Vy(o) {
    if (o.subtreeFlags & 1024)
      for (o = o.child; o !== null; ) {
        var i = o;
        Vy(i), i.tag === 5 && i.flags & 1024 && i.stateNode.reset(), o = o.sibling;
      }
  }
  function Gr(o, i) {
    if (i.subtreeFlags & 8772)
      for (i = i.child; i !== null; )
        Ly(o, i.alternate, i), i = i.sibling;
  }
  function ha(o) {
    for (o = o.child; o !== null; ) {
      var i = o;
      switch (i.tag) {
        case 0:
        case 11:
        case 14:
        case 15:
          go(4, i, i.return), ha(i);
          break;
        case 1:
          _r(i, i.return);
          var u = i.stateNode;
          typeof u.componentWillUnmount == "function" && jy(
            i,
            i.return,
            u
          ), ha(i);
          break;
        case 27:
          Ss(i.stateNode);
        case 26:
        case 5:
          _r(i, i.return), ha(i);
          break;
        case 22:
          i.memoizedState === null && ha(i);
          break;
        case 30:
          ha(i);
          break;
        default:
          ha(i);
      }
      o = o.sibling;
    }
  }
  function Kr(o, i, u) {
    for (u = u && (i.subtreeFlags & 8772) !== 0, i = i.child; i !== null; ) {
      var f = i.alternate, g = o, S = i, A = S.flags;
      switch (S.tag) {
        case 0:
        case 11:
        case 15:
          Kr(
            g,
            S,
            u
          ), fs(4, S);
          break;
        case 1:
          if (Kr(
            g,
            S,
            u
          ), f = S, g = f.stateNode, typeof g.componentDidMount == "function")
            try {
              g.componentDidMount();
            } catch (ne) {
              rt(f, f.return, ne);
            }
          if (f = S, g = f.updateQueue, g !== null) {
            var T = f.stateNode;
            try {
              var Y = g.shared.hiddenCallbacks;
              if (Y !== null)
                for (g.shared.hiddenCallbacks = null, g = 0; g < Y.length; g++)
                  wv(Y[g], T);
            } catch (ne) {
              rt(f, f.return, ne);
            }
          }
          u && A & 64 && Ay(S), ps(S, S.return);
          break;
        case 27:
          $y(S);
        case 26:
        case 5:
          Kr(
            g,
            S,
            u
          ), u && f === null && A & 4 && Py(S), ps(S, S.return);
          break;
        case 12:
          Kr(
            g,
            S,
            u
          );
          break;
        case 31:
          Kr(
            g,
            S,
            u
          ), u && A & 4 && Fy(g, S);
          break;
        case 13:
          Kr(
            g,
            S,
            u
          ), u && A & 4 && By(g, S);
          break;
        case 22:
          S.memoizedState === null && Kr(
            g,
            S,
            u
          ), ps(S, S.return);
          break;
        case 30:
          break;
        default:
          Kr(
            g,
            S,
            u
          );
      }
      i = i.sibling;
    }
  }
  function np(o, i) {
    var u = null;
    o !== null && o.memoizedState !== null && o.memoizedState.cachePool !== null && (u = o.memoizedState.cachePool.pool), o = null, i.memoizedState !== null && i.memoizedState.cachePool !== null && (o = i.memoizedState.cachePool.pool), o !== u && (o != null && o.refCount++, u != null && Zi(u));
  }
  function rp(o, i) {
    o = null, i.alternate !== null && (o = i.alternate.memoizedState.cache), i = i.memoizedState.cache, i !== o && (i.refCount++, o != null && Zi(o));
  }
  function gr(o, i, u, f) {
    if (i.subtreeFlags & 10256)
      for (i = i.child; i !== null; )
        Hy(
          o,
          i,
          u,
          f
        ), i = i.sibling;
  }
  function Hy(o, i, u, f) {
    var g = i.flags;
    switch (i.tag) {
      case 0:
      case 11:
      case 15:
        gr(
          o,
          i,
          u,
          f
        ), g & 2048 && fs(9, i);
        break;
      case 1:
        gr(
          o,
          i,
          u,
          f
        );
        break;
      case 3:
        gr(
          o,
          i,
          u,
          f
        ), g & 2048 && (o = null, i.alternate !== null && (o = i.alternate.memoizedState.cache), i = i.memoizedState.cache, i !== o && (i.refCount++, o != null && Zi(o)));
        break;
      case 12:
        if (g & 2048) {
          gr(
            o,
            i,
            u,
            f
          ), o = i.stateNode;
          try {
            var S = i.memoizedProps, A = S.id, T = S.onPostCommit;
            typeof T == "function" && T(
              A,
              i.alternate === null ? "mount" : "update",
              o.passiveEffectDuration,
              -0
            );
          } catch (Y) {
            rt(i, i.return, Y);
          }
        } else
          gr(
            o,
            i,
            u,
            f
          );
        break;
      case 31:
        gr(
          o,
          i,
          u,
          f
        );
        break;
      case 13:
        gr(
          o,
          i,
          u,
          f
        );
        break;
      case 23:
        break;
      case 22:
        S = i.stateNode, A = i.alternate, i.memoizedState !== null ? S._visibility & 2 ? gr(
          o,
          i,
          u,
          f
        ) : ms(o, i) : S._visibility & 2 ? gr(
          o,
          i,
          u,
          f
        ) : (S._visibility |= 2, ei(
          o,
          i,
          u,
          f,
          (i.subtreeFlags & 10256) !== 0 || !1
        )), g & 2048 && np(A, i);
        break;
      case 24:
        gr(
          o,
          i,
          u,
          f
        ), g & 2048 && rp(i.alternate, i);
        break;
      default:
        gr(
          o,
          i,
          u,
          f
        );
    }
  }
  function ei(o, i, u, f, g) {
    for (g = g && ((i.subtreeFlags & 10256) !== 0 || !1), i = i.child; i !== null; ) {
      var S = o, A = i, T = u, Y = f, ne = A.flags;
      switch (A.tag) {
        case 0:
        case 11:
        case 15:
          ei(
            S,
            A,
            T,
            Y,
            g
          ), fs(8, A);
          break;
        case 23:
          break;
        case 22:
          var ue = A.stateNode;
          A.memoizedState !== null ? ue._visibility & 2 ? ei(
            S,
            A,
            T,
            Y,
            g
          ) : ms(
            S,
            A
          ) : (ue._visibility |= 2, ei(
            S,
            A,
            T,
            Y,
            g
          )), g && ne & 2048 && np(
            A.alternate,
            A
          );
          break;
        case 24:
          ei(
            S,
            A,
            T,
            Y,
            g
          ), g && ne & 2048 && rp(A.alternate, A);
          break;
        default:
          ei(
            S,
            A,
            T,
            Y,
            g
          );
      }
      i = i.sibling;
    }
  }
  function ms(o, i) {
    if (i.subtreeFlags & 10256)
      for (i = i.child; i !== null; ) {
        var u = o, f = i, g = f.flags;
        switch (f.tag) {
          case 22:
            ms(u, f), g & 2048 && np(
              f.alternate,
              f
            );
            break;
          case 24:
            ms(u, f), g & 2048 && rp(f.alternate, f);
            break;
          default:
            ms(u, f);
        }
        i = i.sibling;
      }
  }
  var hs = 8192;
  function ti(o, i, u) {
    if (o.subtreeFlags & hs)
      for (o = o.child; o !== null; )
        qy(
          o,
          i,
          u
        ), o = o.sibling;
  }
  function qy(o, i, u) {
    switch (o.tag) {
      case 26:
        ti(
          o,
          i,
          u
        ), o.flags & hs && o.memoizedState !== null && RO(
          u,
          hr,
          o.memoizedState,
          o.memoizedProps
        );
        break;
      case 5:
        ti(
          o,
          i,
          u
        );
        break;
      case 3:
      case 4:
        var f = hr;
        hr = Fu(o.stateNode.containerInfo), ti(
          o,
          i,
          u
        ), hr = f;
        break;
      case 22:
        o.memoizedState === null && (f = o.alternate, f !== null && f.memoizedState !== null ? (f = hs, hs = 16777216, ti(
          o,
          i,
          u
        ), hs = f) : ti(
          o,
          i,
          u
        ));
        break;
      default:
        ti(
          o,
          i,
          u
        );
    }
  }
  function Wy(o) {
    var i = o.alternate;
    if (i !== null && (o = i.child, o !== null)) {
      i.child = null;
      do
        i = o.sibling, o.sibling = null, o = i;
      while (o !== null);
    }
  }
  function gs(o) {
    var i = o.deletions;
    if ((o.flags & 16) !== 0) {
      if (i !== null)
        for (var u = 0; u < i.length; u++) {
          var f = i[u];
          Qt = f, Ky(
            f,
            o
          );
        }
      Wy(o);
    }
    if (o.subtreeFlags & 10256)
      for (o = o.child; o !== null; )
        Gy(o), o = o.sibling;
  }
  function Gy(o) {
    switch (o.tag) {
      case 0:
      case 11:
      case 15:
        gs(o), o.flags & 2048 && go(9, o, o.return);
        break;
      case 3:
        gs(o);
        break;
      case 12:
        gs(o);
        break;
      case 22:
        var i = o.stateNode;
        o.memoizedState !== null && i._visibility & 2 && (o.return === null || o.return.tag !== 13) ? (i._visibility &= -3, Ou(o)) : gs(o);
        break;
      default:
        gs(o);
    }
  }
  function Ou(o) {
    var i = o.deletions;
    if ((o.flags & 16) !== 0) {
      if (i !== null)
        for (var u = 0; u < i.length; u++) {
          var f = i[u];
          Qt = f, Ky(
            f,
            o
          );
        }
      Wy(o);
    }
    for (o = o.child; o !== null; ) {
      switch (i = o, i.tag) {
        case 0:
        case 11:
        case 15:
          go(8, i, i.return), Ou(i);
          break;
        case 22:
          u = i.stateNode, u._visibility & 2 && (u._visibility &= -3, Ou(i));
          break;
        default:
          Ou(i);
      }
      o = o.sibling;
    }
  }
  function Ky(o, i) {
    for (; Qt !== null; ) {
      var u = Qt;
      switch (u.tag) {
        case 0:
        case 11:
        case 15:
          go(8, u, i);
          break;
        case 23:
        case 22:
          if (u.memoizedState !== null && u.memoizedState.cachePool !== null) {
            var f = u.memoizedState.cachePool.pool;
            f != null && f.refCount++;
          }
          break;
        case 24:
          Zi(u.memoizedState.cache);
      }
      if (f = u.child, f !== null) f.return = u, Qt = f;
      else
        e: for (u = o; Qt !== null; ) {
          f = Qt;
          var g = f.sibling, S = f.return;
          if (Iy(f), f === u) {
            Qt = null;
            break e;
          }
          if (g !== null) {
            g.return = S, Qt = g;
            break e;
          }
          Qt = S;
        }
    }
  }
  var qC = {
    getCacheForType: function(o) {
      var i = tn(jt), u = i.data.get(o);
      return u === void 0 && (u = o(), i.data.set(o, u)), u;
    },
    cacheSignal: function() {
      return tn(jt).controller.signal;
    }
  }, WC = typeof WeakMap == "function" ? WeakMap : Map, Je = 0, lt = null, Fe = null, Ve = 0, nt = 0, Bn = null, vo = !1, ni = !1, op = !1, Xr = 0, St = 0, yo = 0, ga = 0, ap = 0, Un = 0, ri = 0, vs = null, Mn = null, ip = !1, Mu = 0, Xy = 0, Nu = 1 / 0, Ru = null, bo = null, Ut = 0, wo = null, oi = null, Yr = 0, sp = 0, lp = null, Yy = null, ys = 0, up = null;
  function Vn() {
    return (Je & 2) !== 0 && Ve !== 0 ? Ve & -Ve : L.T !== null ? hp() : Ed();
  }
  function Qy() {
    if (Un === 0)
      if ((Ve & 536870912) === 0 || Ge) {
        var o = dn;
        dn <<= 1, (dn & 3932160) === 0 && (dn = 262144), Un = o;
      } else Un = 536870912;
    return o = zn.current, o !== null && (o.flags |= 32), Un;
  }
  function Nn(o, i, u) {
    (o === lt && (nt === 2 || nt === 9) || o.cancelPendingCommit !== null) && (ai(o, 0), xo(
      o,
      Ve,
      Un,
      !1
    )), ja(o, u), ((Je & 2) === 0 || o !== lt) && (o === lt && ((Je & 2) === 0 && (ga |= u), St === 4 && xo(
      o,
      Ve,
      Un,
      !1
    )), Er(o));
  }
  function Jy(o, i, u) {
    if ((Je & 6) !== 0) throw Error(r(327));
    var f = !u && (i & 127) === 0 && (i & o.expiredLanes) === 0 || pr(o, i), g = f ? XC(o, i) : dp(o, i, !0), S = f;
    do {
      if (g === 0) {
        ni && !f && xo(o, i, 0, !1);
        break;
      } else {
        if (u = o.current.alternate, S && !GC(u)) {
          g = dp(o, i, !1), S = !1;
          continue;
        }
        if (g === 2) {
          if (S = i, o.errorRecoveryDisabledLanes & S)
            var A = 0;
          else
            A = o.pendingLanes & -536870913, A = A !== 0 ? A : A & 536870912 ? 536870912 : 0;
          if (A !== 0) {
            i = A;
            e: {
              var T = o;
              g = vs;
              var Y = T.current.memoizedState.isDehydrated;
              if (Y && (ai(T, A).flags |= 256), A = dp(
                T,
                A,
                !1
              ), A !== 2) {
                if (op && !Y) {
                  T.errorRecoveryDisabledLanes |= S, ga |= S, g = 4;
                  break e;
                }
                S = Mn, Mn = g, S !== null && (Mn === null ? Mn = S : Mn.push.apply(
                  Mn,
                  S
                ));
              }
              g = A;
            }
            if (S = !1, g !== 2) continue;
          }
        }
        if (g === 1) {
          ai(o, 0), xo(o, i, 0, !0);
          break;
        }
        e: {
          switch (f = o, S = g, S) {
            case 0:
            case 1:
              throw Error(r(345));
            case 4:
              if ((i & 4194048) !== i) break;
            case 6:
              xo(
                f,
                i,
                Un,
                !vo
              );
              break e;
            case 2:
              Mn = null;
              break;
            case 3:
            case 5:
              break;
            default:
              throw Error(r(329));
          }
          if ((i & 62914560) === i && (g = Mu + 300 - Ce(), 10 < g)) {
            if (xo(
              f,
              i,
              Un,
              !vo
            ), Io(f, 0, !0) !== 0) break e;
            Yr = i, f.timeoutHandle = Nb(
              Zy.bind(
                null,
                f,
                u,
                Mn,
                Ru,
                ip,
                i,
                Un,
                ga,
                ri,
                vo,
                S,
                "Throttled",
                -0,
                0
              ),
              g
            );
            break e;
          }
          Zy(
            f,
            u,
            Mn,
            Ru,
            ip,
            i,
            Un,
            ga,
            ri,
            vo,
            S,
            null,
            -0,
            0
          );
        }
      }
      break;
    } while (!0);
    Er(o);
  }
  function Zy(o, i, u, f, g, S, A, T, Y, ne, ue, fe, oe, ie) {
    if (o.timeoutHandle = -1, fe = i.subtreeFlags, fe & 8192 || (fe & 16785408) === 16785408) {
      fe = {
        stylesheets: null,
        count: 0,
        imgCount: 0,
        imgBytes: 0,
        suspenseyImages: [],
        waitingForImages: !0,
        waitingForViewTransition: !1,
        unsuspend: $r
      }, qy(
        i,
        S,
        fe
      );
      var we = (S & 62914560) === S ? Mu - Ce() : (S & 4194048) === S ? Xy - Ce() : 0;
      if (we = AO(
        fe,
        we
      ), we !== null) {
        Yr = S, o.cancelPendingCommit = we(
          sb.bind(
            null,
            o,
            i,
            S,
            u,
            f,
            g,
            A,
            T,
            Y,
            ue,
            fe,
            null,
            oe,
            ie
          )
        ), xo(o, S, A, !ne);
        return;
      }
    }
    sb(
      o,
      i,
      S,
      u,
      f,
      g,
      A,
      T,
      Y
    );
  }
  function GC(o) {
    for (var i = o; ; ) {
      var u = i.tag;
      if ((u === 0 || u === 11 || u === 15) && i.flags & 16384 && (u = i.updateQueue, u !== null && (u = u.stores, u !== null)))
        for (var f = 0; f < u.length; f++) {
          var g = u[f], S = g.getSnapshot;
          g = g.value;
          try {
            if (!Ln(S(), g)) return !1;
          } catch {
            return !1;
          }
        }
      if (u = i.child, i.subtreeFlags & 16384 && u !== null)
        u.return = i, i = u;
      else {
        if (i === o) break;
        for (; i.sibling === null; ) {
          if (i.return === null || i.return === o) return !0;
          i = i.return;
        }
        i.sibling.return = i.return, i = i.sibling;
      }
    }
    return !0;
  }
  function xo(o, i, u, f) {
    i &= ~ap, i &= ~ga, o.suspendedLanes |= i, o.pingedLanes &= ~i, f && (o.warmLanes |= i), f = o.expirationTimes;
    for (var g = i; 0 < g; ) {
      var S = 31 - Re(g), A = 1 << S;
      f[S] = -1, g &= ~A;
    }
    u !== 0 && Sd(o, u, i);
  }
  function Au() {
    return (Je & 6) === 0 ? (bs(0), !1) : !0;
  }
  function cp() {
    if (Fe !== null) {
      if (nt === 0)
        var o = Fe.return;
      else
        o = Fe, zr = sa = null, Cf(o), Xa = null, ts = 0, o = Fe;
      for (; o !== null; )
        Ry(o.alternate, o), o = o.return;
      Fe = null;
    }
  }
  function ai(o, i) {
    var u = o.timeoutHandle;
    u !== -1 && (o.timeoutHandle = -1, pO(u)), u = o.cancelPendingCommit, u !== null && (o.cancelPendingCommit = null, u()), Yr = 0, cp(), lt = o, Fe = u = Lr(o.current, null), Ve = i, nt = 0, Bn = null, vo = !1, ni = pr(o, i), op = !1, ri = Un = ap = ga = yo = St = 0, Mn = vs = null, ip = !1, (i & 8) !== 0 && (i |= i & 32);
    var f = o.entangledLanes;
    if (f !== 0)
      for (o = o.entanglements, f &= i; 0 < f; ) {
        var g = 31 - Re(f), S = 1 << g;
        i |= o[g], f &= ~S;
      }
    return Xr = i, Jl(), u;
  }
  function eb(o, i) {
    Te = null, L.H = us, i === Ka || i === iu ? (i = gv(), nt = 3) : i === mf ? (i = gv(), nt = 4) : nt = i === Uf ? 8 : i !== null && typeof i == "object" && typeof i.then == "function" ? 6 : 1, Bn = i, Fe === null && (St = 1, wu(
      o,
      Zn(i, o.current)
    ));
  }
  function tb() {
    var o = zn.current;
    return o === null ? !0 : (Ve & 4194048) === Ve ? lr === null : (Ve & 62914560) === Ve || (Ve & 536870912) !== 0 ? o === lr : !1;
  }
  function nb() {
    var o = L.H;
    return L.H = us, o === null ? us : o;
  }
  function rb() {
    var o = L.A;
    return L.A = qC, o;
  }
  function ju() {
    St = 4, vo || (Ve & 4194048) !== Ve && zn.current !== null || (ni = !0), (yo & 134217727) === 0 && (ga & 134217727) === 0 || lt === null || xo(
      lt,
      Ve,
      Un,
      !1
    );
  }
  function dp(o, i, u) {
    var f = Je;
    Je |= 2;
    var g = nb(), S = rb();
    (lt !== o || Ve !== i) && (Ru = null, ai(o, i)), i = !1;
    var A = St;
    e: do
      try {
        if (nt !== 0 && Fe !== null) {
          var T = Fe, Y = Bn;
          switch (nt) {
            case 8:
              cp(), A = 6;
              break e;
            case 3:
            case 2:
            case 9:
            case 6:
              zn.current === null && (i = !0);
              var ne = nt;
              if (nt = 0, Bn = null, ii(o, T, Y, ne), u && ni) {
                A = 0;
                break e;
              }
              break;
            default:
              ne = nt, nt = 0, Bn = null, ii(o, T, Y, ne);
          }
        }
        KC(), A = St;
        break;
      } catch (ue) {
        eb(o, ue);
      }
    while (!0);
    return i && o.shellSuspendCounter++, zr = sa = null, Je = f, L.H = g, L.A = S, Fe === null && (lt = null, Ve = 0, Jl()), A;
  }
  function KC() {
    for (; Fe !== null; ) ob(Fe);
  }
  function XC(o, i) {
    var u = Je;
    Je |= 2;
    var f = nb(), g = rb();
    lt !== o || Ve !== i ? (Ru = null, Nu = Ce() + 500, ai(o, i)) : ni = pr(
      o,
      i
    );
    e: do
      try {
        if (nt !== 0 && Fe !== null) {
          i = Fe;
          var S = Bn;
          t: switch (nt) {
            case 1:
              nt = 0, Bn = null, ii(o, i, S, 1);
              break;
            case 2:
            case 9:
              if (mv(S)) {
                nt = 0, Bn = null, ab(i);
                break;
              }
              i = function() {
                nt !== 2 && nt !== 9 || lt !== o || (nt = 7), Er(o);
              }, S.then(i, i);
              break e;
            case 3:
              nt = 7;
              break e;
            case 4:
              nt = 5;
              break e;
            case 7:
              mv(S) ? (nt = 0, Bn = null, ab(i)) : (nt = 0, Bn = null, ii(o, i, S, 7));
              break;
            case 5:
              var A = null;
              switch (Fe.tag) {
                case 26:
                  A = Fe.memoizedState;
                case 5:
                case 27:
                  var T = Fe;
                  if (A ? Hb(A) : T.stateNode.complete) {
                    nt = 0, Bn = null;
                    var Y = T.sibling;
                    if (Y !== null) Fe = Y;
                    else {
                      var ne = T.return;
                      ne !== null ? (Fe = ne, Pu(ne)) : Fe = null;
                    }
                    break t;
                  }
              }
              nt = 0, Bn = null, ii(o, i, S, 5);
              break;
            case 6:
              nt = 0, Bn = null, ii(o, i, S, 6);
              break;
            case 8:
              cp(), St = 6;
              break e;
            default:
              throw Error(r(462));
          }
        }
        YC();
        break;
      } catch (ue) {
        eb(o, ue);
      }
    while (!0);
    return zr = sa = null, L.H = f, L.A = g, Je = u, Fe !== null ? 0 : (lt = null, Ve = 0, Jl(), St);
  }
  function YC() {
    for (; Fe !== null && !an(); )
      ob(Fe);
  }
  function ob(o) {
    var i = My(o.alternate, o, Xr);
    o.memoizedProps = o.pendingProps, i === null ? Pu(o) : Fe = i;
  }
  function ab(o) {
    var i = o, u = i.alternate;
    switch (i.tag) {
      case 15:
      case 0:
        i = Sy(
          u,
          i,
          i.pendingProps,
          i.type,
          void 0,
          Ve
        );
        break;
      case 11:
        i = Sy(
          u,
          i,
          i.pendingProps,
          i.type.render,
          i.ref,
          Ve
        );
        break;
      case 5:
        Cf(i);
      default:
        Ry(u, i), i = Fe = rv(i, Xr), i = My(u, i, Xr);
    }
    o.memoizedProps = o.pendingProps, i === null ? Pu(o) : Fe = i;
  }
  function ii(o, i, u, f) {
    zr = sa = null, Cf(i), Xa = null, ts = 0;
    var g = i.return;
    try {
      if (IC(
        o,
        g,
        i,
        u,
        Ve
      )) {
        St = 1, wu(
          o,
          Zn(u, o.current)
        ), Fe = null;
        return;
      }
    } catch (S) {
      if (g !== null) throw Fe = g, S;
      St = 1, wu(
        o,
        Zn(u, o.current)
      ), Fe = null;
      return;
    }
    i.flags & 32768 ? (Ge || f === 1 ? o = !0 : ni || (Ve & 536870912) !== 0 ? o = !1 : (vo = o = !0, (f === 2 || f === 9 || f === 3 || f === 6) && (f = zn.current, f !== null && f.tag === 13 && (f.flags |= 16384))), ib(i, o)) : Pu(i);
  }
  function Pu(o) {
    var i = o;
    do {
      if ((i.flags & 32768) !== 0) {
        ib(
          i,
          vo
        );
        return;
      }
      o = i.return;
      var u = BC(
        i.alternate,
        i,
        Xr
      );
      if (u !== null) {
        Fe = u;
        return;
      }
      if (i = i.sibling, i !== null) {
        Fe = i;
        return;
      }
      Fe = i = o;
    } while (i !== null);
    St === 0 && (St = 5);
  }
  function ib(o, i) {
    do {
      var u = UC(o.alternate, o);
      if (u !== null) {
        u.flags &= 32767, Fe = u;
        return;
      }
      if (u = o.return, u !== null && (u.flags |= 32768, u.subtreeFlags = 0, u.deletions = null), !i && (o = o.sibling, o !== null)) {
        Fe = o;
        return;
      }
      Fe = o = u;
    } while (o !== null);
    St = 6, Fe = null;
  }
  function sb(o, i, u, f, g, S, A, T, Y) {
    o.cancelPendingCommit = null;
    do
      Du();
    while (Ut !== 0);
    if ((Je & 6) !== 0) throw Error(r(327));
    if (i !== null) {
      if (i === o.current) throw Error(r(177));
      if (S = i.lanes | i.childLanes, S |= Jd, gg(
        o,
        u,
        S,
        A,
        T,
        Y
      ), o === lt && (Fe = lt = null, Ve = 0), oi = i, wo = o, Yr = u, sp = S, lp = g, Yy = f, (i.subtreeFlags & 10256) !== 0 || (i.flags & 10256) !== 0 ? (o.callbackNode = null, o.callbackPriority = 0, eO(Ee, function() {
        return fb(), null;
      })) : (o.callbackNode = null, o.callbackPriority = 0), f = (i.flags & 13878) !== 0, (i.subtreeFlags & 13878) !== 0 || f) {
        f = L.T, L.T = null, g = K.p, K.p = 2, A = Je, Je |= 4;
        try {
          VC(o, i, u);
        } finally {
          Je = A, K.p = g, L.T = f;
        }
      }
      Ut = 1, lb(), ub(), cb();
    }
  }
  function lb() {
    if (Ut === 1) {
      Ut = 0;
      var o = wo, i = oi, u = (i.flags & 13878) !== 0;
      if ((i.subtreeFlags & 13878) !== 0 || u) {
        u = L.T, L.T = null;
        var f = K.p;
        K.p = 2;
        var g = Je;
        Je |= 4;
        try {
          Uy(i, o);
          var S = kp, A = Kg(o.containerInfo), T = S.focusedElem, Y = S.selectionRange;
          if (A !== T && T && T.ownerDocument && Gg(
            T.ownerDocument.documentElement,
            T
          )) {
            if (Y !== null && Gd(T)) {
              var ne = Y.start, ue = Y.end;
              if (ue === void 0 && (ue = ne), "selectionStart" in T)
                T.selectionStart = ne, T.selectionEnd = Math.min(
                  ue,
                  T.value.length
                );
              else {
                var fe = T.ownerDocument || document, oe = fe && fe.defaultView || window;
                if (oe.getSelection) {
                  var ie = oe.getSelection(), we = T.textContent.length, Ne = Math.min(Y.start, we), it = Y.end === void 0 ? Ne : Math.min(Y.end, we);
                  !ie.extend && Ne > it && (A = it, it = Ne, Ne = A);
                  var ee = Wg(
                    T,
                    Ne
                  ), J = Wg(
                    T,
                    it
                  );
                  if (ee && J && (ie.rangeCount !== 1 || ie.anchorNode !== ee.node || ie.anchorOffset !== ee.offset || ie.focusNode !== J.node || ie.focusOffset !== J.offset)) {
                    var te = fe.createRange();
                    te.setStart(ee.node, ee.offset), ie.removeAllRanges(), Ne > it ? (ie.addRange(te), ie.extend(J.node, J.offset)) : (te.setEnd(J.node, J.offset), ie.addRange(te));
                  }
                }
              }
            }
            for (fe = [], ie = T; ie = ie.parentNode; )
              ie.nodeType === 1 && fe.push({
                element: ie,
                left: ie.scrollLeft,
                top: ie.scrollTop
              });
            for (typeof T.focus == "function" && T.focus(), T = 0; T < fe.length; T++) {
              var ce = fe[T];
              ce.element.scrollLeft = ce.left, ce.element.scrollTop = ce.top;
            }
          }
          Wu = !!Sp, kp = Sp = null;
        } finally {
          Je = g, K.p = f, L.T = u;
        }
      }
      o.current = i, Ut = 2;
    }
  }
  function ub() {
    if (Ut === 2) {
      Ut = 0;
      var o = wo, i = oi, u = (i.flags & 8772) !== 0;
      if ((i.subtreeFlags & 8772) !== 0 || u) {
        u = L.T, L.T = null;
        var f = K.p;
        K.p = 2;
        var g = Je;
        Je |= 4;
        try {
          Ly(o, i.alternate, i);
        } finally {
          Je = g, K.p = f, L.T = u;
        }
      }
      Ut = 3;
    }
  }
  function cb() {
    if (Ut === 4 || Ut === 3) {
      Ut = 0, dt();
      var o = wo, i = oi, u = Yr, f = Yy;
      (i.subtreeFlags & 10256) !== 0 || (i.flags & 10256) !== 0 ? Ut = 5 : (Ut = 0, oi = wo = null, db(o, o.pendingLanes));
      var g = o.pendingLanes;
      if (g === 0 && (bo = null), Bl(u), i = i.stateNode, Ot && typeof Ot.onCommitFiberRoot == "function")
        try {
          Ot.onCommitFiberRoot(
            Wt,
            i,
            void 0,
            (i.current.flags & 128) === 128
          );
        } catch {
        }
      if (f !== null) {
        i = L.T, g = K.p, K.p = 2, L.T = null;
        try {
          for (var S = o.onRecoverableError, A = 0; A < f.length; A++) {
            var T = f[A];
            S(T.value, {
              componentStack: T.stack
            });
          }
        } finally {
          L.T = i, K.p = g;
        }
      }
      (Yr & 3) !== 0 && Du(), Er(o), g = o.pendingLanes, (u & 261930) !== 0 && (g & 42) !== 0 ? o === up ? ys++ : (ys = 0, up = o) : ys = 0, bs(0);
    }
  }
  function db(o, i) {
    (o.pooledCacheLanes &= i) === 0 && (i = o.pooledCache, i != null && (o.pooledCache = null, Zi(i)));
  }
  function Du() {
    return lb(), ub(), cb(), fb();
  }
  function fb() {
    if (Ut !== 5) return !1;
    var o = wo, i = sp;
    sp = 0;
    var u = Bl(Yr), f = L.T, g = K.p;
    try {
      K.p = 32 > u ? 32 : u, L.T = null, u = lp, lp = null;
      var S = wo, A = Yr;
      if (Ut = 0, oi = wo = null, Yr = 0, (Je & 6) !== 0) throw Error(r(331));
      var T = Je;
      if (Je |= 4, Gy(S.current), Hy(
        S,
        S.current,
        A,
        u
      ), Je = T, bs(0, !1), Ot && typeof Ot.onPostCommitFiberRoot == "function")
        try {
          Ot.onPostCommitFiberRoot(Wt, S);
        } catch {
        }
      return !0;
    } finally {
      K.p = g, L.T = f, db(o, i);
    }
  }
  function pb(o, i, u) {
    i = Zn(u, i), i = Bf(o.stateNode, i, 2), o = po(o, i, 2), o !== null && (ja(o, 2), Er(o));
  }
  function rt(o, i, u) {
    if (o.tag === 3)
      pb(o, o, u);
    else
      for (; i !== null; ) {
        if (i.tag === 3) {
          pb(
            i,
            o,
            u
          );
          break;
        } else if (i.tag === 1) {
          var f = i.stateNode;
          if (typeof i.type.getDerivedStateFromError == "function" || typeof f.componentDidCatch == "function" && (bo === null || !bo.has(f))) {
            o = Zn(u, o), u = my(2), f = po(i, u, 2), f !== null && (hy(
              u,
              f,
              i,
              o
            ), ja(f, 2), Er(f));
            break;
          }
        }
        i = i.return;
      }
  }
  function fp(o, i, u) {
    var f = o.pingCache;
    if (f === null) {
      f = o.pingCache = new WC();
      var g = /* @__PURE__ */ new Set();
      f.set(i, g);
    } else
      g = f.get(i), g === void 0 && (g = /* @__PURE__ */ new Set(), f.set(i, g));
    g.has(u) || (op = !0, g.add(u), o = QC.bind(null, o, i, u), i.then(o, o));
  }
  function QC(o, i, u) {
    var f = o.pingCache;
    f !== null && f.delete(i), o.pingedLanes |= o.suspendedLanes & u, o.warmLanes &= ~u, lt === o && (Ve & u) === u && (St === 4 || St === 3 && (Ve & 62914560) === Ve && 300 > Ce() - Mu ? (Je & 2) === 0 && ai(o, 0) : ap |= u, ri === Ve && (ri = 0)), Er(o);
  }
  function mb(o, i) {
    i === 0 && (i = xd()), o = oa(o, i), o !== null && (ja(o, i), Er(o));
  }
  function JC(o) {
    var i = o.memoizedState, u = 0;
    i !== null && (u = i.retryLane), mb(o, u);
  }
  function ZC(o, i) {
    var u = 0;
    switch (o.tag) {
      case 31:
      case 13:
        var f = o.stateNode, g = o.memoizedState;
        g !== null && (u = g.retryLane);
        break;
      case 19:
        f = o.stateNode;
        break;
      case 22:
        f = o.stateNode._retryCache;
        break;
      default:
        throw Error(r(314));
    }
    f !== null && f.delete(i), mb(o, u);
  }
  function eO(o, i) {
    return tt(o, i);
  }
  var $u = null, si = null, pp = !1, Tu = !1, mp = !1, So = 0;
  function Er(o) {
    o !== si && o.next === null && (si === null ? $u = si = o : si = si.next = o), Tu = !0, pp || (pp = !0, nO());
  }
  function bs(o, i) {
    if (!mp && Tu) {
      mp = !0;
      do
        for (var u = !1, f = $u; f !== null; ) {
          if (o !== 0) {
            var g = f.pendingLanes;
            if (g === 0) var S = 0;
            else {
              var A = f.suspendedLanes, T = f.pingedLanes;
              S = (1 << 31 - Re(42 | o) + 1) - 1, S &= g & ~(A & ~T), S = S & 201326741 ? S & 201326741 | 1 : S ? S | 2 : 0;
            }
            S !== 0 && (u = !0, yb(f, S));
          } else
            S = Ve, S = Io(
              f,
              f === lt ? S : 0,
              f.cancelPendingCommit !== null || f.timeoutHandle !== -1
            ), (S & 3) === 0 || pr(f, S) || (u = !0, yb(f, S));
          f = f.next;
        }
      while (u);
      mp = !1;
    }
  }
  function tO() {
    hb();
  }
  function hb() {
    Tu = pp = !1;
    var o = 0;
    So !== 0 && fO() && (o = So);
    for (var i = Ce(), u = null, f = $u; f !== null; ) {
      var g = f.next, S = gb(f, i);
      S === 0 ? (f.next = null, u === null ? $u = g : u.next = g, g === null && (si = u)) : (u = f, (o !== 0 || (S & 3) !== 0) && (Tu = !0)), f = g;
    }
    Ut !== 0 && Ut !== 5 || bs(o), So !== 0 && (So = 0);
  }
  function gb(o, i) {
    for (var u = o.suspendedLanes, f = o.pingedLanes, g = o.expirationTimes, S = o.pendingLanes & -62914561; 0 < S; ) {
      var A = 31 - Re(S), T = 1 << A, Y = g[A];
      Y === -1 ? ((T & u) === 0 || (T & f) !== 0) && (g[A] = hg(T, i)) : Y <= i && (o.expiredLanes |= T), S &= ~T;
    }
    if (i = lt, u = Ve, u = Io(
      o,
      o === i ? u : 0,
      o.cancelPendingCommit !== null || o.timeoutHandle !== -1
    ), f = o.callbackNode, u === 0 || o === i && (nt === 2 || nt === 9) || o.cancelPendingCommit !== null)
      return f !== null && f !== null && je(f), o.callbackNode = null, o.callbackPriority = 0;
    if ((u & 3) === 0 || pr(o, u)) {
      if (i = u & -u, i === o.callbackPriority) return i;
      switch (f !== null && je(f), Bl(u)) {
        case 2:
        case 8:
          u = ye;
          break;
        case 32:
          u = Ee;
          break;
        case 268435456:
          u = ze;
          break;
        default:
          u = Ee;
      }
      return f = vb.bind(null, o), u = tt(u, f), o.callbackPriority = i, o.callbackNode = u, i;
    }
    return f !== null && f !== null && je(f), o.callbackPriority = 2, o.callbackNode = null, 2;
  }
  function vb(o, i) {
    if (Ut !== 0 && Ut !== 5)
      return o.callbackNode = null, o.callbackPriority = 0, null;
    var u = o.callbackNode;
    if (Du() && o.callbackNode !== u)
      return null;
    var f = Ve;
    return f = Io(
      o,
      o === lt ? f : 0,
      o.cancelPendingCommit !== null || o.timeoutHandle !== -1
    ), f === 0 ? null : (Jy(o, f, i), gb(o, Ce()), o.callbackNode != null && o.callbackNode === u ? vb.bind(null, o) : null);
  }
  function yb(o, i) {
    if (Du()) return null;
    Jy(o, i, !0);
  }
  function nO() {
    mO(function() {
      (Je & 6) !== 0 ? tt(
        he,
        tO
      ) : hb();
    });
  }
  function hp() {
    if (So === 0) {
      var o = Wa;
      o === 0 && (o = Lo, Lo <<= 1, (Lo & 261888) === 0 && (Lo = 256)), So = o;
    }
    return So;
  }
  function bb(o) {
    return o == null || typeof o == "symbol" || typeof o == "boolean" ? null : typeof o == "function" ? o : Hl("" + o);
  }
  function wb(o, i) {
    var u = i.ownerDocument.createElement("input");
    return u.name = i.name, u.value = i.value, o.id && u.setAttribute("form", o.id), i.parentNode.insertBefore(u, i), o = new FormData(o), u.parentNode.removeChild(u), o;
  }
  function rO(o, i, u, f, g) {
    if (i === "submit" && u && u.stateNode === g) {
      var S = bb(
        (g[mn] || null).action
      ), A = f.submitter;
      A && (i = (i = A[mn] || null) ? bb(i.formAction) : A.getAttribute("formAction"), i !== null && (S = i, A = null));
      var T = new Kl(
        "action",
        "action",
        null,
        f,
        g
      );
      o.push({
        event: T,
        listeners: [
          {
            instance: null,
            listener: function() {
              if (f.defaultPrevented) {
                if (So !== 0) {
                  var Y = A ? wb(g, A) : new FormData(g);
                  $f(
                    u,
                    {
                      pending: !0,
                      data: Y,
                      method: g.method,
                      action: S
                    },
                    null,
                    Y
                  );
                }
              } else
                typeof S == "function" && (T.preventDefault(), Y = A ? wb(g, A) : new FormData(g), $f(
                  u,
                  {
                    pending: !0,
                    data: Y,
                    method: g.method,
                    action: S
                  },
                  S,
                  Y
                ));
            },
            currentTarget: g
          }
        ]
      });
    }
  }
  for (var gp = 0; gp < Qd.length; gp++) {
    var vp = Qd[gp], oO = vp.toLowerCase(), aO = vp[0].toUpperCase() + vp.slice(1);
    mr(
      oO,
      "on" + aO
    );
  }
  mr(Qg, "onAnimationEnd"), mr(Jg, "onAnimationIteration"), mr(Zg, "onAnimationStart"), mr("dblclick", "onDoubleClick"), mr("focusin", "onFocus"), mr("focusout", "onBlur"), mr(xC, "onTransitionRun"), mr(SC, "onTransitionStart"), mr(kC, "onTransitionCancel"), mr(ev, "onTransitionEnd"), ea("onMouseEnter", ["mouseout", "mouseover"]), ea("onMouseLeave", ["mouseout", "mouseover"]), ea("onPointerEnter", ["pointerout", "pointerover"]), ea("onPointerLeave", ["pointerout", "pointerover"]), oo(
    "onChange",
    "change click focusin focusout input keydown keyup selectionchange".split(" ")
  ), oo(
    "onSelect",
    "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(
      " "
    )
  ), oo("onBeforeInput", [
    "compositionend",
    "keypress",
    "textInput",
    "paste"
  ]), oo(
    "onCompositionEnd",
    "compositionend focusout keydown keypress keyup mousedown".split(" ")
  ), oo(
    "onCompositionStart",
    "compositionstart focusout keydown keypress keyup mousedown".split(" ")
  ), oo(
    "onCompositionUpdate",
    "compositionupdate focusout keydown keypress keyup mousedown".split(" ")
  );
  var ws = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(
    " "
  ), iO = new Set(
    "beforetoggle cancel close invalid load scroll scrollend toggle".split(" ").concat(ws)
  );
  function xb(o, i) {
    i = (i & 4) !== 0;
    for (var u = 0; u < o.length; u++) {
      var f = o[u], g = f.event;
      f = f.listeners;
      e: {
        var S = void 0;
        if (i)
          for (var A = f.length - 1; 0 <= A; A--) {
            var T = f[A], Y = T.instance, ne = T.currentTarget;
            if (T = T.listener, Y !== S && g.isPropagationStopped())
              break e;
            S = T, g.currentTarget = ne;
            try {
              S(g);
            } catch (ue) {
              Ql(ue);
            }
            g.currentTarget = null, S = Y;
          }
        else
          for (A = 0; A < f.length; A++) {
            if (T = f[A], Y = T.instance, ne = T.currentTarget, T = T.listener, Y !== S && g.isPropagationStopped())
              break e;
            S = T, g.currentTarget = ne;
            try {
              S(g);
            } catch (ue) {
              Ql(ue);
            }
            g.currentTarget = null, S = Y;
          }
      }
    }
  }
  function Be(o, i) {
    var u = i[Xs];
    u === void 0 && (u = i[Xs] = /* @__PURE__ */ new Set());
    var f = o + "__bubble";
    u.has(f) || (Sb(i, o, 2, !1), u.add(f));
  }
  function yp(o, i, u) {
    var f = 0;
    i && (f |= 4), Sb(
      u,
      o,
      f,
      i
    );
  }
  var Lu = "_reactListening" + Math.random().toString(36).slice(2);
  function bp(o) {
    if (!o[Lu]) {
      o[Lu] = !0, Md.forEach(function(u) {
        u !== "selectionchange" && (iO.has(u) || yp(u, !1, o), yp(u, !0, o));
      });
      var i = o.nodeType === 9 ? o : o.ownerDocument;
      i === null || i[Lu] || (i[Lu] = !0, yp("selectionchange", !1, i));
    }
  }
  function Sb(o, i, u, f) {
    switch (Qb(i)) {
      case 2:
        var g = DO;
        break;
      case 8:
        g = $O;
        break;
      default:
        g = Dp;
    }
    u = g.bind(
      null,
      i,
      u,
      o
    ), g = void 0, !Id || i !== "touchstart" && i !== "touchmove" && i !== "wheel" || (g = !0), f ? g !== void 0 ? o.addEventListener(i, u, {
      capture: !0,
      passive: g
    }) : o.addEventListener(i, u, !0) : g !== void 0 ? o.addEventListener(i, u, {
      passive: g
    }) : o.addEventListener(i, u, !1);
  }
  function wp(o, i, u, f, g) {
    var S = f;
    if ((i & 1) === 0 && (i & 2) === 0 && f !== null)
      e: for (; ; ) {
        if (f === null) return;
        var A = f.tag;
        if (A === 3 || A === 4) {
          var T = f.stateNode.containerInfo;
          if (T === g) break;
          if (A === 4)
            for (A = f.return; A !== null; ) {
              var Y = A.tag;
              if ((Y === 3 || Y === 4) && A.stateNode.containerInfo === g)
                return;
              A = A.return;
            }
          for (; T !== null; ) {
            if (A = Qo(T), A === null) return;
            if (Y = A.tag, Y === 5 || Y === 6 || Y === 26 || Y === 27) {
              f = S = A;
              continue e;
            }
            T = T.parentNode;
          }
        }
        f = f.return;
      }
    Og(function() {
      var ne = S, ue = Td(u), fe = [];
      e: {
        var oe = tv.get(o);
        if (oe !== void 0) {
          var ie = Kl, we = o;
          switch (o) {
            case "keypress":
              if (Wl(u) === 0) break e;
            case "keydown":
            case "keyup":
              ie = ZE;
              break;
            case "focusin":
              we = "focus", ie = Ud;
              break;
            case "focusout":
              we = "blur", ie = Ud;
              break;
            case "beforeblur":
            case "afterblur":
              ie = Ud;
              break;
            case "click":
              if (u.button === 2) break e;
            case "auxclick":
            case "dblclick":
            case "mousedown":
            case "mousemove":
            case "mouseup":
            case "mouseout":
            case "mouseover":
            case "contextmenu":
              ie = Rg;
              break;
            case "drag":
            case "dragend":
            case "dragenter":
            case "dragexit":
            case "dragleave":
            case "dragover":
            case "dragstart":
            case "drop":
              ie = BE;
              break;
            case "touchcancel":
            case "touchend":
            case "touchmove":
            case "touchstart":
              ie = nC;
              break;
            case Qg:
            case Jg:
            case Zg:
              ie = HE;
              break;
            case ev:
              ie = oC;
              break;
            case "scroll":
            case "scrollend":
              ie = zE;
              break;
            case "wheel":
              ie = iC;
              break;
            case "copy":
            case "cut":
            case "paste":
              ie = WE;
              break;
            case "gotpointercapture":
            case "lostpointercapture":
            case "pointercancel":
            case "pointerdown":
            case "pointermove":
            case "pointerout":
            case "pointerover":
            case "pointerup":
              ie = jg;
              break;
            case "toggle":
            case "beforetoggle":
              ie = lC;
          }
          var Ne = (i & 4) !== 0, it = !Ne && (o === "scroll" || o === "scrollend"), ee = Ne ? oe !== null ? oe + "Capture" : null : oe;
          Ne = [];
          for (var J = ne, te; J !== null; ) {
            var ce = J;
            if (te = ce.stateNode, ce = ce.tag, ce !== 5 && ce !== 26 && ce !== 27 || te === null || ee === null || (ce = Ui(J, ee), ce != null && Ne.push(
              xs(J, ce, te)
            )), it) break;
            J = J.return;
          }
          0 < Ne.length && (oe = new ie(
            oe,
            we,
            null,
            u,
            ue
          ), fe.push({ event: oe, listeners: Ne }));
        }
      }
      if ((i & 7) === 0) {
        e: {
          if (oe = o === "mouseover" || o === "pointerover", ie = o === "mouseout" || o === "pointerout", oe && u !== $d && (we = u.relatedTarget || u.fromElement) && (Qo(we) || we[zo]))
            break e;
          if ((ie || oe) && (oe = ue.window === ue ? ue : (oe = ue.ownerDocument) ? oe.defaultView || oe.parentWindow : window, ie ? (we = u.relatedTarget || u.toElement, ie = ne, we = we ? Qo(we) : null, we !== null && (it = s(we), Ne = we.tag, we !== it || Ne !== 5 && Ne !== 27 && Ne !== 6) && (we = null)) : (ie = null, we = ne), ie !== we)) {
            if (Ne = Rg, ce = "onMouseLeave", ee = "onMouseEnter", J = "mouse", (o === "pointerout" || o === "pointerover") && (Ne = jg, ce = "onPointerLeave", ee = "onPointerEnter", J = "pointer"), it = ie == null ? oe : ka(ie), te = we == null ? oe : ka(we), oe = new Ne(
              ce,
              J + "leave",
              ie,
              u,
              ue
            ), oe.target = it, oe.relatedTarget = te, ce = null, Qo(ue) === ne && (Ne = new Ne(
              ee,
              J + "enter",
              we,
              u,
              ue
            ), Ne.target = te, Ne.relatedTarget = it, ce = Ne), it = ce, ie && we)
              t: {
                for (Ne = sO, ee = ie, J = we, te = 0, ce = ee; ce; ce = Ne(ce))
                  te++;
                ce = 0;
                for (var Oe = J; Oe; Oe = Ne(Oe))
                  ce++;
                for (; 0 < te - ce; )
                  ee = Ne(ee), te--;
                for (; 0 < ce - te; )
                  J = Ne(J), ce--;
                for (; te--; ) {
                  if (ee === J || J !== null && ee === J.alternate) {
                    Ne = ee;
                    break t;
                  }
                  ee = Ne(ee), J = Ne(J);
                }
                Ne = null;
              }
            else Ne = null;
            ie !== null && kb(
              fe,
              oe,
              ie,
              Ne,
              !1
            ), we !== null && it !== null && kb(
              fe,
              it,
              we,
              Ne,
              !0
            );
          }
        }
        e: {
          if (oe = ne ? ka(ne) : window, ie = oe.nodeName && oe.nodeName.toLowerCase(), ie === "select" || ie === "input" && oe.type === "file")
            var Ye = Fg;
          else if (Ig(oe))
            if (Bg)
              Ye = yC;
            else {
              Ye = gC;
              var ke = hC;
            }
          else
            ie = oe.nodeName, !ie || ie.toLowerCase() !== "input" || oe.type !== "checkbox" && oe.type !== "radio" ? ne && Dd(ne.elementType) && (Ye = Fg) : Ye = vC;
          if (Ye && (Ye = Ye(o, ne))) {
            zg(
              fe,
              Ye,
              u,
              ue
            );
            break e;
          }
          ke && ke(o, oe, ne), o === "focusout" && ne && oe.type === "number" && ne.memoizedProps.value != null && Vl(oe, "number", oe.value);
        }
        switch (ke = ne ? ka(ne) : window, o) {
          case "focusin":
            (Ig(ke) || ke.contentEditable === "true") && (Ia = ke, Kd = ne, Yi = null);
            break;
          case "focusout":
            Yi = Kd = Ia = null;
            break;
          case "mousedown":
            Xd = !0;
            break;
          case "contextmenu":
          case "mouseup":
          case "dragend":
            Xd = !1, Xg(fe, u, ue);
            break;
          case "selectionchange":
            if (wC) break;
          case "keydown":
          case "keyup":
            Xg(fe, u, ue);
        }
        var Ie;
        if (Hd)
          e: {
            switch (o) {
              case "compositionstart":
                var He = "onCompositionStart";
                break e;
              case "compositionend":
                He = "onCompositionEnd";
                break e;
              case "compositionupdate":
                He = "onCompositionUpdate";
                break e;
            }
            He = void 0;
          }
        else
          La ? Tg(o, u) && (He = "onCompositionEnd") : o === "keydown" && u.keyCode === 229 && (He = "onCompositionStart");
        He && (Pg && u.locale !== "ko" && (La || He !== "onCompositionStart" ? He === "onCompositionEnd" && La && (Ie = Mg()) : (ao = ue, zd = "value" in ao ? ao.value : ao.textContent, La = !0)), ke = Iu(ne, He), 0 < ke.length && (He = new Ag(
          He,
          o,
          null,
          u,
          ue
        ), fe.push({ event: He, listeners: ke }), Ie ? He.data = Ie : (Ie = Lg(u), Ie !== null && (He.data = Ie)))), (Ie = cC ? dC(o, u) : fC(o, u)) && (He = Iu(ne, "onBeforeInput"), 0 < He.length && (ke = new Ag(
          "onBeforeInput",
          "beforeinput",
          null,
          u,
          ue
        ), fe.push({
          event: ke,
          listeners: He
        }), ke.data = Ie)), rO(
          fe,
          o,
          ne,
          u,
          ue
        );
      }
      xb(fe, i);
    });
  }
  function xs(o, i, u) {
    return {
      instance: o,
      listener: i,
      currentTarget: u
    };
  }
  function Iu(o, i) {
    for (var u = i + "Capture", f = []; o !== null; ) {
      var g = o, S = g.stateNode;
      if (g = g.tag, g !== 5 && g !== 26 && g !== 27 || S === null || (g = Ui(o, u), g != null && f.unshift(
        xs(o, g, S)
      ), g = Ui(o, i), g != null && f.push(
        xs(o, g, S)
      )), o.tag === 3) return f;
      o = o.return;
    }
    return [];
  }
  function sO(o) {
    if (o === null) return null;
    do
      o = o.return;
    while (o && o.tag !== 5 && o.tag !== 27);
    return o || null;
  }
  function kb(o, i, u, f, g) {
    for (var S = i._reactName, A = []; u !== null && u !== f; ) {
      var T = u, Y = T.alternate, ne = T.stateNode;
      if (T = T.tag, Y !== null && Y === f) break;
      T !== 5 && T !== 26 && T !== 27 || ne === null || (Y = ne, g ? (ne = Ui(u, S), ne != null && A.unshift(
        xs(u, ne, Y)
      )) : g || (ne = Ui(u, S), ne != null && A.push(
        xs(u, ne, Y)
      ))), u = u.return;
    }
    A.length !== 0 && o.push({ event: i, listeners: A });
  }
  var lO = /\r\n?/g, uO = /\u0000|\uFFFD/g;
  function _b(o) {
    return (typeof o == "string" ? o : "" + o).replace(lO, `
`).replace(uO, "");
  }
  function Eb(o, i) {
    return i = _b(i), _b(o) === i;
  }
  function at(o, i, u, f, g, S) {
    switch (u) {
      case "children":
        typeof f == "string" ? i === "body" || i === "textarea" && f === "" || Da(o, f) : (typeof f == "number" || typeof f == "bigint") && i !== "body" && Da(o, "" + f);
        break;
      case "className":
        Fi(o, "class", f);
        break;
      case "tabIndex":
        Fi(o, "tabindex", f);
        break;
      case "dir":
      case "role":
      case "viewBox":
      case "width":
      case "height":
        Fi(o, u, f);
        break;
      case "style":
        Eg(o, f, S);
        break;
      case "data":
        if (i !== "object") {
          Fi(o, "data", f);
          break;
        }
      case "src":
      case "href":
        if (f === "" && (i !== "a" || u !== "href")) {
          o.removeAttribute(u);
          break;
        }
        if (f == null || typeof f == "function" || typeof f == "symbol" || typeof f == "boolean") {
          o.removeAttribute(u);
          break;
        }
        f = Hl("" + f), o.setAttribute(u, f);
        break;
      case "action":
      case "formAction":
        if (typeof f == "function") {
          o.setAttribute(
            u,
            "javascript:throw new Error('A React form was unexpectedly submitted. If you called form.submit() manually, consider using form.requestSubmit() instead. If you\\'re trying to use event.stopPropagation() in a submit event handler, consider also calling event.preventDefault().')"
          );
          break;
        } else
          typeof S == "function" && (u === "formAction" ? (i !== "input" && at(o, i, "name", g.name, g, null), at(
            o,
            i,
            "formEncType",
            g.formEncType,
            g,
            null
          ), at(
            o,
            i,
            "formMethod",
            g.formMethod,
            g,
            null
          ), at(
            o,
            i,
            "formTarget",
            g.formTarget,
            g,
            null
          )) : (at(o, i, "encType", g.encType, g, null), at(o, i, "method", g.method, g, null), at(o, i, "target", g.target, g, null)));
        if (f == null || typeof f == "symbol" || typeof f == "boolean") {
          o.removeAttribute(u);
          break;
        }
        f = Hl("" + f), o.setAttribute(u, f);
        break;
      case "onClick":
        f != null && (o.onclick = $r);
        break;
      case "onScroll":
        f != null && Be("scroll", o);
        break;
      case "onScrollEnd":
        f != null && Be("scrollend", o);
        break;
      case "dangerouslySetInnerHTML":
        if (f != null) {
          if (typeof f != "object" || !("__html" in f))
            throw Error(r(61));
          if (u = f.__html, u != null) {
            if (g.children != null) throw Error(r(60));
            o.innerHTML = u;
          }
        }
        break;
      case "multiple":
        o.multiple = f && typeof f != "function" && typeof f != "symbol";
        break;
      case "muted":
        o.muted = f && typeof f != "function" && typeof f != "symbol";
        break;
      case "suppressContentEditableWarning":
      case "suppressHydrationWarning":
      case "defaultValue":
      case "defaultChecked":
      case "innerHTML":
      case "ref":
        break;
      case "autoFocus":
        break;
      case "xlinkHref":
        if (f == null || typeof f == "function" || typeof f == "boolean" || typeof f == "symbol") {
          o.removeAttribute("xlink:href");
          break;
        }
        u = Hl("" + f), o.setAttributeNS(
          "http://www.w3.org/1999/xlink",
          "xlink:href",
          u
        );
        break;
      case "contentEditable":
      case "spellCheck":
      case "draggable":
      case "value":
      case "autoReverse":
      case "externalResourcesRequired":
      case "focusable":
      case "preserveAlpha":
        f != null && typeof f != "function" && typeof f != "symbol" ? o.setAttribute(u, "" + f) : o.removeAttribute(u);
        break;
      case "inert":
      case "allowFullScreen":
      case "async":
      case "autoPlay":
      case "controls":
      case "default":
      case "defer":
      case "disabled":
      case "disablePictureInPicture":
      case "disableRemotePlayback":
      case "formNoValidate":
      case "hidden":
      case "loop":
      case "noModule":
      case "noValidate":
      case "open":
      case "playsInline":
      case "readOnly":
      case "required":
      case "reversed":
      case "scoped":
      case "seamless":
      case "itemScope":
        f && typeof f != "function" && typeof f != "symbol" ? o.setAttribute(u, "") : o.removeAttribute(u);
        break;
      case "capture":
      case "download":
        f === !0 ? o.setAttribute(u, "") : f !== !1 && f != null && typeof f != "function" && typeof f != "symbol" ? o.setAttribute(u, f) : o.removeAttribute(u);
        break;
      case "cols":
      case "rows":
      case "size":
      case "span":
        f != null && typeof f != "function" && typeof f != "symbol" && !isNaN(f) && 1 <= f ? o.setAttribute(u, f) : o.removeAttribute(u);
        break;
      case "rowSpan":
      case "start":
        f == null || typeof f == "function" || typeof f == "symbol" || isNaN(f) ? o.removeAttribute(u) : o.setAttribute(u, f);
        break;
      case "popover":
        Be("beforetoggle", o), Be("toggle", o), zi(o, "popover", f);
        break;
      case "xlinkActuate":
        xr(
          o,
          "http://www.w3.org/1999/xlink",
          "xlink:actuate",
          f
        );
        break;
      case "xlinkArcrole":
        xr(
          o,
          "http://www.w3.org/1999/xlink",
          "xlink:arcrole",
          f
        );
        break;
      case "xlinkRole":
        xr(
          o,
          "http://www.w3.org/1999/xlink",
          "xlink:role",
          f
        );
        break;
      case "xlinkShow":
        xr(
          o,
          "http://www.w3.org/1999/xlink",
          "xlink:show",
          f
        );
        break;
      case "xlinkTitle":
        xr(
          o,
          "http://www.w3.org/1999/xlink",
          "xlink:title",
          f
        );
        break;
      case "xlinkType":
        xr(
          o,
          "http://www.w3.org/1999/xlink",
          "xlink:type",
          f
        );
        break;
      case "xmlBase":
        xr(
          o,
          "http://www.w3.org/XML/1998/namespace",
          "xml:base",
          f
        );
        break;
      case "xmlLang":
        xr(
          o,
          "http://www.w3.org/XML/1998/namespace",
          "xml:lang",
          f
        );
        break;
      case "xmlSpace":
        xr(
          o,
          "http://www.w3.org/XML/1998/namespace",
          "xml:space",
          f
        );
        break;
      case "is":
        zi(o, "is", f);
        break;
      case "innerText":
      case "textContent":
        break;
      default:
        (!(2 < u.length) || u[0] !== "o" && u[0] !== "O" || u[1] !== "n" && u[1] !== "N") && (u = LE.get(u) || u, zi(o, u, f));
    }
  }
  function xp(o, i, u, f, g, S) {
    switch (u) {
      case "style":
        Eg(o, f, S);
        break;
      case "dangerouslySetInnerHTML":
        if (f != null) {
          if (typeof f != "object" || !("__html" in f))
            throw Error(r(61));
          if (u = f.__html, u != null) {
            if (g.children != null) throw Error(r(60));
            o.innerHTML = u;
          }
        }
        break;
      case "children":
        typeof f == "string" ? Da(o, f) : (typeof f == "number" || typeof f == "bigint") && Da(o, "" + f);
        break;
      case "onScroll":
        f != null && Be("scroll", o);
        break;
      case "onScrollEnd":
        f != null && Be("scrollend", o);
        break;
      case "onClick":
        f != null && (o.onclick = $r);
        break;
      case "suppressContentEditableWarning":
      case "suppressHydrationWarning":
      case "innerHTML":
      case "ref":
        break;
      case "innerText":
      case "textContent":
        break;
      default:
        if (!Nd.hasOwnProperty(u))
          e: {
            if (u[0] === "o" && u[1] === "n" && (g = u.endsWith("Capture"), i = u.slice(2, g ? u.length - 7 : void 0), S = o[mn] || null, S = S != null ? S[u] : null, typeof S == "function" && o.removeEventListener(i, S, g), typeof f == "function")) {
              typeof S != "function" && S !== null && (u in o ? o[u] = null : o.hasAttribute(u) && o.removeAttribute(u)), o.addEventListener(i, f, g);
              break e;
            }
            u in o ? o[u] = f : f === !0 ? o.setAttribute(u, "") : zi(o, u, f);
          }
    }
  }
  function rn(o, i, u) {
    switch (i) {
      case "div":
      case "span":
      case "svg":
      case "path":
      case "a":
      case "g":
      case "p":
      case "li":
        break;
      case "img":
        Be("error", o), Be("load", o);
        var f = !1, g = !1, S;
        for (S in u)
          if (u.hasOwnProperty(S)) {
            var A = u[S];
            if (A != null)
              switch (S) {
                case "src":
                  f = !0;
                  break;
                case "srcSet":
                  g = !0;
                  break;
                case "children":
                case "dangerouslySetInnerHTML":
                  throw Error(r(137, i));
                default:
                  at(o, i, S, A, u, null);
              }
          }
        g && at(o, i, "srcSet", u.srcSet, u, null), f && at(o, i, "src", u.src, u, null);
        return;
      case "input":
        Be("invalid", o);
        var T = S = A = g = null, Y = null, ne = null;
        for (f in u)
          if (u.hasOwnProperty(f)) {
            var ue = u[f];
            if (ue != null)
              switch (f) {
                case "name":
                  g = ue;
                  break;
                case "type":
                  A = ue;
                  break;
                case "checked":
                  Y = ue;
                  break;
                case "defaultChecked":
                  ne = ue;
                  break;
                case "value":
                  S = ue;
                  break;
                case "defaultValue":
                  T = ue;
                  break;
                case "children":
                case "dangerouslySetInnerHTML":
                  if (ue != null)
                    throw Error(r(137, i));
                  break;
                default:
                  at(o, i, f, ue, u, null);
              }
          }
        Pd(
          o,
          S,
          T,
          Y,
          ne,
          A,
          g,
          !1
        );
        return;
      case "select":
        Be("invalid", o), f = A = S = null;
        for (g in u)
          if (u.hasOwnProperty(g) && (T = u[g], T != null))
            switch (g) {
              case "value":
                S = T;
                break;
              case "defaultValue":
                A = T;
                break;
              case "multiple":
                f = T;
              default:
                at(o, i, g, T, u, null);
            }
        i = S, u = A, o.multiple = !!f, i != null ? Fo(o, !!f, i, !1) : u != null && Fo(o, !!f, u, !0);
        return;
      case "textarea":
        Be("invalid", o), S = g = f = null;
        for (A in u)
          if (u.hasOwnProperty(A) && (T = u[A], T != null))
            switch (A) {
              case "value":
                f = T;
                break;
              case "defaultValue":
                g = T;
                break;
              case "children":
                S = T;
                break;
              case "dangerouslySetInnerHTML":
                if (T != null) throw Error(r(91));
                break;
              default:
                at(o, i, A, T, u, null);
            }
        kg(o, f, g, S);
        return;
      case "option":
        for (Y in u)
          u.hasOwnProperty(Y) && (f = u[Y], f != null) && (Y === "selected" ? o.selected = f && typeof f != "function" && typeof f != "symbol" : at(o, i, Y, f, u, null));
        return;
      case "dialog":
        Be("beforetoggle", o), Be("toggle", o), Be("cancel", o), Be("close", o);
        break;
      case "iframe":
      case "object":
        Be("load", o);
        break;
      case "video":
      case "audio":
        for (f = 0; f < ws.length; f++)
          Be(ws[f], o);
        break;
      case "image":
        Be("error", o), Be("load", o);
        break;
      case "details":
        Be("toggle", o);
        break;
      case "embed":
      case "source":
      case "link":
        Be("error", o), Be("load", o);
      case "area":
      case "base":
      case "br":
      case "col":
      case "hr":
      case "keygen":
      case "meta":
      case "param":
      case "track":
      case "wbr":
      case "menuitem":
        for (ne in u)
          if (u.hasOwnProperty(ne) && (f = u[ne], f != null))
            switch (ne) {
              case "children":
              case "dangerouslySetInnerHTML":
                throw Error(r(137, i));
              default:
                at(o, i, ne, f, u, null);
            }
        return;
      default:
        if (Dd(i)) {
          for (ue in u)
            u.hasOwnProperty(ue) && (f = u[ue], f !== void 0 && xp(
              o,
              i,
              ue,
              f,
              u,
              void 0
            ));
          return;
        }
    }
    for (T in u)
      u.hasOwnProperty(T) && (f = u[T], f != null && at(o, i, T, f, u, null));
  }
  function cO(o, i, u, f) {
    switch (i) {
      case "div":
      case "span":
      case "svg":
      case "path":
      case "a":
      case "g":
      case "p":
      case "li":
        break;
      case "input":
        var g = null, S = null, A = null, T = null, Y = null, ne = null, ue = null;
        for (ie in u) {
          var fe = u[ie];
          if (u.hasOwnProperty(ie) && fe != null)
            switch (ie) {
              case "checked":
                break;
              case "value":
                break;
              case "defaultValue":
                Y = fe;
              default:
                f.hasOwnProperty(ie) || at(o, i, ie, null, f, fe);
            }
        }
        for (var oe in f) {
          var ie = f[oe];
          if (fe = u[oe], f.hasOwnProperty(oe) && (ie != null || fe != null))
            switch (oe) {
              case "type":
                S = ie;
                break;
              case "name":
                g = ie;
                break;
              case "checked":
                ne = ie;
                break;
              case "defaultChecked":
                ue = ie;
                break;
              case "value":
                A = ie;
                break;
              case "defaultValue":
                T = ie;
                break;
              case "children":
              case "dangerouslySetInnerHTML":
                if (ie != null)
                  throw Error(r(137, i));
                break;
              default:
                ie !== fe && at(
                  o,
                  i,
                  oe,
                  ie,
                  f,
                  fe
                );
            }
        }
        Bi(
          o,
          A,
          T,
          Y,
          ne,
          ue,
          S,
          g
        );
        return;
      case "select":
        ie = A = T = oe = null;
        for (S in u)
          if (Y = u[S], u.hasOwnProperty(S) && Y != null)
            switch (S) {
              case "value":
                break;
              case "multiple":
                ie = Y;
              default:
                f.hasOwnProperty(S) || at(
                  o,
                  i,
                  S,
                  null,
                  f,
                  Y
                );
            }
        for (g in f)
          if (S = f[g], Y = u[g], f.hasOwnProperty(g) && (S != null || Y != null))
            switch (g) {
              case "value":
                oe = S;
                break;
              case "defaultValue":
                T = S;
                break;
              case "multiple":
                A = S;
              default:
                S !== Y && at(
                  o,
                  i,
                  g,
                  S,
                  f,
                  Y
                );
            }
        i = T, u = A, f = ie, oe != null ? Fo(o, !!u, oe, !1) : !!f != !!u && (i != null ? Fo(o, !!u, i, !0) : Fo(o, !!u, u ? [] : "", !1));
        return;
      case "textarea":
        ie = oe = null;
        for (T in u)
          if (g = u[T], u.hasOwnProperty(T) && g != null && !f.hasOwnProperty(T))
            switch (T) {
              case "value":
                break;
              case "children":
                break;
              default:
                at(o, i, T, null, f, g);
            }
        for (A in f)
          if (g = f[A], S = u[A], f.hasOwnProperty(A) && (g != null || S != null))
            switch (A) {
              case "value":
                oe = g;
                break;
              case "defaultValue":
                ie = g;
                break;
              case "children":
                break;
              case "dangerouslySetInnerHTML":
                if (g != null) throw Error(r(91));
                break;
              default:
                g !== S && at(o, i, A, g, f, S);
            }
        Sg(o, oe, ie);
        return;
      case "option":
        for (var we in u)
          oe = u[we], u.hasOwnProperty(we) && oe != null && !f.hasOwnProperty(we) && (we === "selected" ? o.selected = !1 : at(
            o,
            i,
            we,
            null,
            f,
            oe
          ));
        for (Y in f)
          oe = f[Y], ie = u[Y], f.hasOwnProperty(Y) && oe !== ie && (oe != null || ie != null) && (Y === "selected" ? o.selected = oe && typeof oe != "function" && typeof oe != "symbol" : at(
            o,
            i,
            Y,
            oe,
            f,
            ie
          ));
        return;
      case "img":
      case "link":
      case "area":
      case "base":
      case "br":
      case "col":
      case "embed":
      case "hr":
      case "keygen":
      case "meta":
      case "param":
      case "source":
      case "track":
      case "wbr":
      case "menuitem":
        for (var Ne in u)
          oe = u[Ne], u.hasOwnProperty(Ne) && oe != null && !f.hasOwnProperty(Ne) && at(o, i, Ne, null, f, oe);
        for (ne in f)
          if (oe = f[ne], ie = u[ne], f.hasOwnProperty(ne) && oe !== ie && (oe != null || ie != null))
            switch (ne) {
              case "children":
              case "dangerouslySetInnerHTML":
                if (oe != null)
                  throw Error(r(137, i));
                break;
              default:
                at(
                  o,
                  i,
                  ne,
                  oe,
                  f,
                  ie
                );
            }
        return;
      default:
        if (Dd(i)) {
          for (var it in u)
            oe = u[it], u.hasOwnProperty(it) && oe !== void 0 && !f.hasOwnProperty(it) && xp(
              o,
              i,
              it,
              void 0,
              f,
              oe
            );
          for (ue in f)
            oe = f[ue], ie = u[ue], !f.hasOwnProperty(ue) || oe === ie || oe === void 0 && ie === void 0 || xp(
              o,
              i,
              ue,
              oe,
              f,
              ie
            );
          return;
        }
    }
    for (var ee in u)
      oe = u[ee], u.hasOwnProperty(ee) && oe != null && !f.hasOwnProperty(ee) && at(o, i, ee, null, f, oe);
    for (fe in f)
      oe = f[fe], ie = u[fe], !f.hasOwnProperty(fe) || oe === ie || oe == null && ie == null || at(o, i, fe, oe, f, ie);
  }
  function Cb(o) {
    switch (o) {
      case "css":
      case "script":
      case "font":
      case "img":
      case "image":
      case "input":
      case "link":
        return !0;
      default:
        return !1;
    }
  }
  function dO() {
    if (typeof performance.getEntriesByType == "function") {
      for (var o = 0, i = 0, u = performance.getEntriesByType("resource"), f = 0; f < u.length; f++) {
        var g = u[f], S = g.transferSize, A = g.initiatorType, T = g.duration;
        if (S && T && Cb(A)) {
          for (A = 0, T = g.responseEnd, f += 1; f < u.length; f++) {
            var Y = u[f], ne = Y.startTime;
            if (ne > T) break;
            var ue = Y.transferSize, fe = Y.initiatorType;
            ue && Cb(fe) && (Y = Y.responseEnd, A += ue * (Y < T ? 1 : (T - ne) / (Y - ne)));
          }
          if (--f, i += 8 * (S + A) / (g.duration / 1e3), o++, 10 < o) break;
        }
      }
      if (0 < o) return i / o / 1e6;
    }
    return navigator.connection && (o = navigator.connection.downlink, typeof o == "number") ? o : 5;
  }
  var Sp = null, kp = null;
  function zu(o) {
    return o.nodeType === 9 ? o : o.ownerDocument;
  }
  function Ob(o) {
    switch (o) {
      case "http://www.w3.org/2000/svg":
        return 1;
      case "http://www.w3.org/1998/Math/MathML":
        return 2;
      default:
        return 0;
    }
  }
  function Mb(o, i) {
    if (o === 0)
      switch (i) {
        case "svg":
          return 1;
        case "math":
          return 2;
        default:
          return 0;
      }
    return o === 1 && i === "foreignObject" ? 0 : o;
  }
  function _p(o, i) {
    return o === "textarea" || o === "noscript" || typeof i.children == "string" || typeof i.children == "number" || typeof i.children == "bigint" || typeof i.dangerouslySetInnerHTML == "object" && i.dangerouslySetInnerHTML !== null && i.dangerouslySetInnerHTML.__html != null;
  }
  var Ep = null;
  function fO() {
    var o = window.event;
    return o && o.type === "popstate" ? o === Ep ? !1 : (Ep = o, !0) : (Ep = null, !1);
  }
  var Nb = typeof setTimeout == "function" ? setTimeout : void 0, pO = typeof clearTimeout == "function" ? clearTimeout : void 0, Rb = typeof Promise == "function" ? Promise : void 0, mO = typeof queueMicrotask == "function" ? queueMicrotask : typeof Rb < "u" ? function(o) {
    return Rb.resolve(null).then(o).catch(hO);
  } : Nb;
  function hO(o) {
    setTimeout(function() {
      throw o;
    });
  }
  function ko(o) {
    return o === "head";
  }
  function Ab(o, i) {
    var u = i, f = 0;
    do {
      var g = u.nextSibling;
      if (o.removeChild(u), g && g.nodeType === 8)
        if (u = g.data, u === "/$" || u === "/&") {
          if (f === 0) {
            o.removeChild(g), di(i);
            return;
          }
          f--;
        } else if (u === "$" || u === "$?" || u === "$~" || u === "$!" || u === "&")
          f++;
        else if (u === "html")
          Ss(o.ownerDocument.documentElement);
        else if (u === "head") {
          u = o.ownerDocument.head, Ss(u);
          for (var S = u.firstChild; S; ) {
            var A = S.nextSibling, T = S.nodeName;
            S[Pa] || T === "SCRIPT" || T === "STYLE" || T === "LINK" && S.rel.toLowerCase() === "stylesheet" || u.removeChild(S), S = A;
          }
        } else
          u === "body" && Ss(o.ownerDocument.body);
      u = g;
    } while (u);
    di(i);
  }
  function jb(o, i) {
    var u = o;
    o = 0;
    do {
      var f = u.nextSibling;
      if (u.nodeType === 1 ? i ? (u._stashedDisplay = u.style.display, u.style.display = "none") : (u.style.display = u._stashedDisplay || "", u.getAttribute("style") === "" && u.removeAttribute("style")) : u.nodeType === 3 && (i ? (u._stashedText = u.nodeValue, u.nodeValue = "") : u.nodeValue = u._stashedText || ""), f && f.nodeType === 8)
        if (u = f.data, u === "/$") {
          if (o === 0) break;
          o--;
        } else
          u !== "$" && u !== "$?" && u !== "$~" && u !== "$!" || o++;
      u = f;
    } while (u);
  }
  function Cp(o) {
    var i = o.firstChild;
    for (i && i.nodeType === 10 && (i = i.nextSibling); i; ) {
      var u = i;
      switch (i = i.nextSibling, u.nodeName) {
        case "HTML":
        case "HEAD":
        case "BODY":
          Cp(u), Ul(u);
          continue;
        case "SCRIPT":
        case "STYLE":
          continue;
        case "LINK":
          if (u.rel.toLowerCase() === "stylesheet") continue;
      }
      o.removeChild(u);
    }
  }
  function gO(o, i, u, f) {
    for (; o.nodeType === 1; ) {
      var g = u;
      if (o.nodeName.toLowerCase() !== i.toLowerCase()) {
        if (!f && (o.nodeName !== "INPUT" || o.type !== "hidden"))
          break;
      } else if (f) {
        if (!o[Pa])
          switch (i) {
            case "meta":
              if (!o.hasAttribute("itemprop")) break;
              return o;
            case "link":
              if (S = o.getAttribute("rel"), S === "stylesheet" && o.hasAttribute("data-precedence"))
                break;
              if (S !== g.rel || o.getAttribute("href") !== (g.href == null || g.href === "" ? null : g.href) || o.getAttribute("crossorigin") !== (g.crossOrigin == null ? null : g.crossOrigin) || o.getAttribute("title") !== (g.title == null ? null : g.title))
                break;
              return o;
            case "style":
              if (o.hasAttribute("data-precedence")) break;
              return o;
            case "script":
              if (S = o.getAttribute("src"), (S !== (g.src == null ? null : g.src) || o.getAttribute("type") !== (g.type == null ? null : g.type) || o.getAttribute("crossorigin") !== (g.crossOrigin == null ? null : g.crossOrigin)) && S && o.hasAttribute("async") && !o.hasAttribute("itemprop"))
                break;
              return o;
            default:
              return o;
          }
      } else if (i === "input" && o.type === "hidden") {
        var S = g.name == null ? null : "" + g.name;
        if (g.type === "hidden" && o.getAttribute("name") === S)
          return o;
      } else return o;
      if (o = rr(o.nextSibling), o === null) break;
    }
    return null;
  }
  function vO(o, i, u) {
    if (i === "") return null;
    for (; o.nodeType !== 3; )
      if ((o.nodeType !== 1 || o.nodeName !== "INPUT" || o.type !== "hidden") && !u || (o = rr(o.nextSibling), o === null)) return null;
    return o;
  }
  function Pb(o, i) {
    for (; o.nodeType !== 8; )
      if ((o.nodeType !== 1 || o.nodeName !== "INPUT" || o.type !== "hidden") && !i || (o = rr(o.nextSibling), o === null)) return null;
    return o;
  }
  function Op(o) {
    return o.data === "$?" || o.data === "$~";
  }
  function Mp(o) {
    return o.data === "$!" || o.data === "$?" && o.ownerDocument.readyState !== "loading";
  }
  function yO(o, i) {
    var u = o.ownerDocument;
    if (o.data === "$~") o._reactRetry = i;
    else if (o.data !== "$?" || u.readyState !== "loading")
      i();
    else {
      var f = function() {
        i(), u.removeEventListener("DOMContentLoaded", f);
      };
      u.addEventListener("DOMContentLoaded", f), o._reactRetry = f;
    }
  }
  function rr(o) {
    for (; o != null; o = o.nextSibling) {
      var i = o.nodeType;
      if (i === 1 || i === 3) break;
      if (i === 8) {
        if (i = o.data, i === "$" || i === "$!" || i === "$?" || i === "$~" || i === "&" || i === "F!" || i === "F")
          break;
        if (i === "/$" || i === "/&") return null;
      }
    }
    return o;
  }
  var Np = null;
  function Db(o) {
    o = o.nextSibling;
    for (var i = 0; o; ) {
      if (o.nodeType === 8) {
        var u = o.data;
        if (u === "/$" || u === "/&") {
          if (i === 0)
            return rr(o.nextSibling);
          i--;
        } else
          u !== "$" && u !== "$!" && u !== "$?" && u !== "$~" && u !== "&" || i++;
      }
      o = o.nextSibling;
    }
    return null;
  }
  function $b(o) {
    o = o.previousSibling;
    for (var i = 0; o; ) {
      if (o.nodeType === 8) {
        var u = o.data;
        if (u === "$" || u === "$!" || u === "$?" || u === "$~" || u === "&") {
          if (i === 0) return o;
          i--;
        } else u !== "/$" && u !== "/&" || i++;
      }
      o = o.previousSibling;
    }
    return null;
  }
  function Tb(o, i, u) {
    switch (i = zu(u), o) {
      case "html":
        if (o = i.documentElement, !o) throw Error(r(452));
        return o;
      case "head":
        if (o = i.head, !o) throw Error(r(453));
        return o;
      case "body":
        if (o = i.body, !o) throw Error(r(454));
        return o;
      default:
        throw Error(r(451));
    }
  }
  function Ss(o) {
    for (var i = o.attributes; i.length; )
      o.removeAttributeNode(i[0]);
    Ul(o);
  }
  var or = /* @__PURE__ */ new Map(), Lb = /* @__PURE__ */ new Set();
  function Fu(o) {
    return typeof o.getRootNode == "function" ? o.getRootNode() : o.nodeType === 9 ? o : o.ownerDocument;
  }
  var Qr = K.d;
  K.d = {
    f: bO,
    r: wO,
    D: xO,
    C: SO,
    L: kO,
    m: _O,
    X: CO,
    S: EO,
    M: OO
  };
  function bO() {
    var o = Qr.f(), i = Au();
    return o || i;
  }
  function wO(o) {
    var i = Jo(o);
    i !== null && i.tag === 5 && i.type === "form" ? ey(i) : Qr.r(o);
  }
  var li = typeof document > "u" ? null : document;
  function Ib(o, i, u) {
    var f = li;
    if (f && typeof i == "string" && i) {
      var g = Gn(i);
      g = 'link[rel="' + o + '"][href="' + g + '"]', typeof u == "string" && (g += '[crossorigin="' + u + '"]'), Lb.has(g) || (Lb.add(g), o = { rel: o, crossOrigin: u, href: i }, f.querySelector(g) === null && (i = f.createElement("link"), rn(i, "link", o), Bt(i), f.head.appendChild(i)));
    }
  }
  function xO(o) {
    Qr.D(o), Ib("dns-prefetch", o, null);
  }
  function SO(o, i) {
    Qr.C(o, i), Ib("preconnect", o, i);
  }
  function kO(o, i, u) {
    Qr.L(o, i, u);
    var f = li;
    if (f && o && i) {
      var g = 'link[rel="preload"][as="' + Gn(i) + '"]';
      i === "image" && u && u.imageSrcSet ? (g += '[imagesrcset="' + Gn(
        u.imageSrcSet
      ) + '"]', typeof u.imageSizes == "string" && (g += '[imagesizes="' + Gn(
        u.imageSizes
      ) + '"]')) : g += '[href="' + Gn(o) + '"]';
      var S = g;
      switch (i) {
        case "style":
          S = ui(o);
          break;
        case "script":
          S = ci(o);
      }
      or.has(S) || (o = h(
        {
          rel: "preload",
          href: i === "image" && u && u.imageSrcSet ? void 0 : o,
          as: i
        },
        u
      ), or.set(S, o), f.querySelector(g) !== null || i === "style" && f.querySelector(ks(S)) || i === "script" && f.querySelector(_s(S)) || (i = f.createElement("link"), rn(i, "link", o), Bt(i), f.head.appendChild(i)));
    }
  }
  function _O(o, i) {
    Qr.m(o, i);
    var u = li;
    if (u && o) {
      var f = i && typeof i.as == "string" ? i.as : "script", g = 'link[rel="modulepreload"][as="' + Gn(f) + '"][href="' + Gn(o) + '"]', S = g;
      switch (f) {
        case "audioworklet":
        case "paintworklet":
        case "serviceworker":
        case "sharedworker":
        case "worker":
        case "script":
          S = ci(o);
      }
      if (!or.has(S) && (o = h({ rel: "modulepreload", href: o }, i), or.set(S, o), u.querySelector(g) === null)) {
        switch (f) {
          case "audioworklet":
          case "paintworklet":
          case "serviceworker":
          case "sharedworker":
          case "worker":
          case "script":
            if (u.querySelector(_s(S)))
              return;
        }
        f = u.createElement("link"), rn(f, "link", o), Bt(f), u.head.appendChild(f);
      }
    }
  }
  function EO(o, i, u) {
    Qr.S(o, i, u);
    var f = li;
    if (f && o) {
      var g = Zo(f).hoistableStyles, S = ui(o);
      i = i || "default";
      var A = g.get(S);
      if (!A) {
        var T = { loading: 0, preload: null };
        if (A = f.querySelector(
          ks(S)
        ))
          T.loading = 5;
        else {
          o = h(
            { rel: "stylesheet", href: o, "data-precedence": i },
            u
          ), (u = or.get(S)) && Rp(o, u);
          var Y = A = f.createElement("link");
          Bt(Y), rn(Y, "link", o), Y._p = new Promise(function(ne, ue) {
            Y.onload = ne, Y.onerror = ue;
          }), Y.addEventListener("load", function() {
            T.loading |= 1;
          }), Y.addEventListener("error", function() {
            T.loading |= 2;
          }), T.loading |= 4, Bu(A, i, f);
        }
        A = {
          type: "stylesheet",
          instance: A,
          count: 1,
          state: T
        }, g.set(S, A);
      }
    }
  }
  function CO(o, i) {
    Qr.X(o, i);
    var u = li;
    if (u && o) {
      var f = Zo(u).hoistableScripts, g = ci(o), S = f.get(g);
      S || (S = u.querySelector(_s(g)), S || (o = h({ src: o, async: !0 }, i), (i = or.get(g)) && Ap(o, i), S = u.createElement("script"), Bt(S), rn(S, "link", o), u.head.appendChild(S)), S = {
        type: "script",
        instance: S,
        count: 1,
        state: null
      }, f.set(g, S));
    }
  }
  function OO(o, i) {
    Qr.M(o, i);
    var u = li;
    if (u && o) {
      var f = Zo(u).hoistableScripts, g = ci(o), S = f.get(g);
      S || (S = u.querySelector(_s(g)), S || (o = h({ src: o, async: !0, type: "module" }, i), (i = or.get(g)) && Ap(o, i), S = u.createElement("script"), Bt(S), rn(S, "link", o), u.head.appendChild(S)), S = {
        type: "script",
        instance: S,
        count: 1,
        state: null
      }, f.set(g, S));
    }
  }
  function zb(o, i, u, f) {
    var g = (g = re.current) ? Fu(g) : null;
    if (!g) throw Error(r(446));
    switch (o) {
      case "meta":
      case "title":
        return null;
      case "style":
        return typeof u.precedence == "string" && typeof u.href == "string" ? (i = ui(u.href), u = Zo(
          g
        ).hoistableStyles, f = u.get(i), f || (f = {
          type: "style",
          instance: null,
          count: 0,
          state: null
        }, u.set(i, f)), f) : { type: "void", instance: null, count: 0, state: null };
      case "link":
        if (u.rel === "stylesheet" && typeof u.href == "string" && typeof u.precedence == "string") {
          o = ui(u.href);
          var S = Zo(
            g
          ).hoistableStyles, A = S.get(o);
          if (A || (g = g.ownerDocument || g, A = {
            type: "stylesheet",
            instance: null,
            count: 0,
            state: { loading: 0, preload: null }
          }, S.set(o, A), (S = g.querySelector(
            ks(o)
          )) && !S._p && (A.instance = S, A.state.loading = 5), or.has(o) || (u = {
            rel: "preload",
            as: "style",
            href: u.href,
            crossOrigin: u.crossOrigin,
            integrity: u.integrity,
            media: u.media,
            hrefLang: u.hrefLang,
            referrerPolicy: u.referrerPolicy
          }, or.set(o, u), S || MO(
            g,
            o,
            u,
            A.state
          ))), i && f === null)
            throw Error(r(528, ""));
          return A;
        }
        if (i && f !== null)
          throw Error(r(529, ""));
        return null;
      case "script":
        return i = u.async, u = u.src, typeof u == "string" && i && typeof i != "function" && typeof i != "symbol" ? (i = ci(u), u = Zo(
          g
        ).hoistableScripts, f = u.get(i), f || (f = {
          type: "script",
          instance: null,
          count: 0,
          state: null
        }, u.set(i, f)), f) : { type: "void", instance: null, count: 0, state: null };
      default:
        throw Error(r(444, o));
    }
  }
  function ui(o) {
    return 'href="' + Gn(o) + '"';
  }
  function ks(o) {
    return 'link[rel="stylesheet"][' + o + "]";
  }
  function Fb(o) {
    return h({}, o, {
      "data-precedence": o.precedence,
      precedence: null
    });
  }
  function MO(o, i, u, f) {
    o.querySelector('link[rel="preload"][as="style"][' + i + "]") ? f.loading = 1 : (i = o.createElement("link"), f.preload = i, i.addEventListener("load", function() {
      return f.loading |= 1;
    }), i.addEventListener("error", function() {
      return f.loading |= 2;
    }), rn(i, "link", u), Bt(i), o.head.appendChild(i));
  }
  function ci(o) {
    return '[src="' + Gn(o) + '"]';
  }
  function _s(o) {
    return "script[async]" + o;
  }
  function Bb(o, i, u) {
    if (i.count++, i.instance === null)
      switch (i.type) {
        case "style":
          var f = o.querySelector(
            'style[data-href~="' + Gn(u.href) + '"]'
          );
          if (f)
            return i.instance = f, Bt(f), f;
          var g = h({}, u, {
            "data-href": u.href,
            "data-precedence": u.precedence,
            href: null,
            precedence: null
          });
          return f = (o.ownerDocument || o).createElement(
            "style"
          ), Bt(f), rn(f, "style", g), Bu(f, u.precedence, o), i.instance = f;
        case "stylesheet":
          g = ui(u.href);
          var S = o.querySelector(
            ks(g)
          );
          if (S)
            return i.state.loading |= 4, i.instance = S, Bt(S), S;
          f = Fb(u), (g = or.get(g)) && Rp(f, g), S = (o.ownerDocument || o).createElement("link"), Bt(S);
          var A = S;
          return A._p = new Promise(function(T, Y) {
            A.onload = T, A.onerror = Y;
          }), rn(S, "link", f), i.state.loading |= 4, Bu(S, u.precedence, o), i.instance = S;
        case "script":
          return S = ci(u.src), (g = o.querySelector(
            _s(S)
          )) ? (i.instance = g, Bt(g), g) : (f = u, (g = or.get(S)) && (f = h({}, u), Ap(f, g)), o = o.ownerDocument || o, g = o.createElement("script"), Bt(g), rn(g, "link", f), o.head.appendChild(g), i.instance = g);
        case "void":
          return null;
        default:
          throw Error(r(443, i.type));
      }
    else
      i.type === "stylesheet" && (i.state.loading & 4) === 0 && (f = i.instance, i.state.loading |= 4, Bu(f, u.precedence, o));
    return i.instance;
  }
  function Bu(o, i, u) {
    for (var f = u.querySelectorAll(
      'link[rel="stylesheet"][data-precedence],style[data-precedence]'
    ), g = f.length ? f[f.length - 1] : null, S = g, A = 0; A < f.length; A++) {
      var T = f[A];
      if (T.dataset.precedence === i) S = T;
      else if (S !== g) break;
    }
    S ? S.parentNode.insertBefore(o, S.nextSibling) : (i = u.nodeType === 9 ? u.head : u, i.insertBefore(o, i.firstChild));
  }
  function Rp(o, i) {
    o.crossOrigin == null && (o.crossOrigin = i.crossOrigin), o.referrerPolicy == null && (o.referrerPolicy = i.referrerPolicy), o.title == null && (o.title = i.title);
  }
  function Ap(o, i) {
    o.crossOrigin == null && (o.crossOrigin = i.crossOrigin), o.referrerPolicy == null && (o.referrerPolicy = i.referrerPolicy), o.integrity == null && (o.integrity = i.integrity);
  }
  var Uu = null;
  function Ub(o, i, u) {
    if (Uu === null) {
      var f = /* @__PURE__ */ new Map(), g = Uu = /* @__PURE__ */ new Map();
      g.set(u, f);
    } else
      g = Uu, f = g.get(u), f || (f = /* @__PURE__ */ new Map(), g.set(u, f));
    if (f.has(o)) return f;
    for (f.set(o, null), u = u.getElementsByTagName(o), g = 0; g < u.length; g++) {
      var S = u[g];
      if (!(S[Pa] || S[Yt] || o === "link" && S.getAttribute("rel") === "stylesheet") && S.namespaceURI !== "http://www.w3.org/2000/svg") {
        var A = S.getAttribute(i) || "";
        A = o + A;
        var T = f.get(A);
        T ? T.push(S) : f.set(A, [S]);
      }
    }
    return f;
  }
  function Vb(o, i, u) {
    o = o.ownerDocument || o, o.head.insertBefore(
      u,
      i === "title" ? o.querySelector("head > title") : null
    );
  }
  function NO(o, i, u) {
    if (u === 1 || i.itemProp != null) return !1;
    switch (o) {
      case "meta":
      case "title":
        return !0;
      case "style":
        if (typeof i.precedence != "string" || typeof i.href != "string" || i.href === "")
          break;
        return !0;
      case "link":
        if (typeof i.rel != "string" || typeof i.href != "string" || i.href === "" || i.onLoad || i.onError)
          break;
        return i.rel === "stylesheet" ? (o = i.disabled, typeof i.precedence == "string" && o == null) : !0;
      case "script":
        if (i.async && typeof i.async != "function" && typeof i.async != "symbol" && !i.onLoad && !i.onError && i.src && typeof i.src == "string")
          return !0;
    }
    return !1;
  }
  function Hb(o) {
    return !(o.type === "stylesheet" && (o.state.loading & 3) === 0);
  }
  function RO(o, i, u, f) {
    if (u.type === "stylesheet" && (typeof f.media != "string" || matchMedia(f.media).matches !== !1) && (u.state.loading & 4) === 0) {
      if (u.instance === null) {
        var g = ui(f.href), S = i.querySelector(
          ks(g)
        );
        if (S) {
          i = S._p, i !== null && typeof i == "object" && typeof i.then == "function" && (o.count++, o = Vu.bind(o), i.then(o, o)), u.state.loading |= 4, u.instance = S, Bt(S);
          return;
        }
        S = i.ownerDocument || i, f = Fb(f), (g = or.get(g)) && Rp(f, g), S = S.createElement("link"), Bt(S);
        var A = S;
        A._p = new Promise(function(T, Y) {
          A.onload = T, A.onerror = Y;
        }), rn(S, "link", f), u.instance = S;
      }
      o.stylesheets === null && (o.stylesheets = /* @__PURE__ */ new Map()), o.stylesheets.set(u, i), (i = u.state.preload) && (u.state.loading & 3) === 0 && (o.count++, u = Vu.bind(o), i.addEventListener("load", u), i.addEventListener("error", u));
    }
  }
  var jp = 0;
  function AO(o, i) {
    return o.stylesheets && o.count === 0 && qu(o, o.stylesheets), 0 < o.count || 0 < o.imgCount ? function(u) {
      var f = setTimeout(function() {
        if (o.stylesheets && qu(o, o.stylesheets), o.unsuspend) {
          var S = o.unsuspend;
          o.unsuspend = null, S();
        }
      }, 6e4 + i);
      0 < o.imgBytes && jp === 0 && (jp = 62500 * dO());
      var g = setTimeout(
        function() {
          if (o.waitingForImages = !1, o.count === 0 && (o.stylesheets && qu(o, o.stylesheets), o.unsuspend)) {
            var S = o.unsuspend;
            o.unsuspend = null, S();
          }
        },
        (o.imgBytes > jp ? 50 : 800) + i
      );
      return o.unsuspend = u, function() {
        o.unsuspend = null, clearTimeout(f), clearTimeout(g);
      };
    } : null;
  }
  function Vu() {
    if (this.count--, this.count === 0 && (this.imgCount === 0 || !this.waitingForImages)) {
      if (this.stylesheets) qu(this, this.stylesheets);
      else if (this.unsuspend) {
        var o = this.unsuspend;
        this.unsuspend = null, o();
      }
    }
  }
  var Hu = null;
  function qu(o, i) {
    o.stylesheets = null, o.unsuspend !== null && (o.count++, Hu = /* @__PURE__ */ new Map(), i.forEach(jO, o), Hu = null, Vu.call(o));
  }
  function jO(o, i) {
    if (!(i.state.loading & 4)) {
      var u = Hu.get(o);
      if (u) var f = u.get(null);
      else {
        u = /* @__PURE__ */ new Map(), Hu.set(o, u);
        for (var g = o.querySelectorAll(
          "link[data-precedence],style[data-precedence]"
        ), S = 0; S < g.length; S++) {
          var A = g[S];
          (A.nodeName === "LINK" || A.getAttribute("media") !== "not all") && (u.set(A.dataset.precedence, A), f = A);
        }
        f && u.set(null, f);
      }
      g = i.instance, A = g.getAttribute("data-precedence"), S = u.get(A) || f, S === f && u.set(null, g), u.set(A, g), this.count++, f = Vu.bind(this), g.addEventListener("load", f), g.addEventListener("error", f), S ? S.parentNode.insertBefore(g, S.nextSibling) : (o = o.nodeType === 9 ? o.head : o, o.insertBefore(g, o.firstChild)), i.state.loading |= 4;
    }
  }
  var Es = {
    $$typeof: _,
    Provider: null,
    Consumer: null,
    _currentValue: q,
    _currentValue2: q,
    _threadCount: 0
  };
  function PO(o, i, u, f, g, S, A, T, Y) {
    this.tag = 1, this.containerInfo = o, this.pingCache = this.current = this.pendingChildren = null, this.timeoutHandle = -1, this.callbackNode = this.next = this.pendingContext = this.context = this.cancelPendingCommit = null, this.callbackPriority = 0, this.expirationTimes = zl(-1), this.entangledLanes = this.shellSuspendCounter = this.errorRecoveryDisabledLanes = this.expiredLanes = this.warmLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0, this.entanglements = zl(0), this.hiddenUpdates = zl(null), this.identifierPrefix = f, this.onUncaughtError = g, this.onCaughtError = S, this.onRecoverableError = A, this.pooledCache = null, this.pooledCacheLanes = 0, this.formState = Y, this.incompleteTransitions = /* @__PURE__ */ new Map();
  }
  function qb(o, i, u, f, g, S, A, T, Y, ne, ue, fe) {
    return o = new PO(
      o,
      i,
      u,
      A,
      Y,
      ne,
      ue,
      fe,
      T
    ), i = 1, S === !0 && (i |= 24), S = In(3, null, null, i), o.current = S, S.stateNode = o, i = df(), i.refCount++, o.pooledCache = i, i.refCount++, S.memoizedState = {
      element: f,
      isDehydrated: u,
      cache: i
    }, hf(S), o;
  }
  function Wb(o) {
    return o ? (o = Ba, o) : Ba;
  }
  function Gb(o, i, u, f, g, S) {
    g = Wb(g), f.context === null ? f.context = g : f.pendingContext = g, f = fo(i), f.payload = { element: u }, S = S === void 0 ? null : S, S !== null && (f.callback = S), u = po(o, f, i), u !== null && (Nn(u, o, i), rs(u, o, i));
  }
  function Kb(o, i) {
    if (o = o.memoizedState, o !== null && o.dehydrated !== null) {
      var u = o.retryLane;
      o.retryLane = u !== 0 && u < i ? u : i;
    }
  }
  function Pp(o, i) {
    Kb(o, i), (o = o.alternate) && Kb(o, i);
  }
  function Xb(o) {
    if (o.tag === 13 || o.tag === 31) {
      var i = oa(o, 67108864);
      i !== null && Nn(i, o, 67108864), Pp(o, 67108864);
    }
  }
  function Yb(o) {
    if (o.tag === 13 || o.tag === 31) {
      var i = Vn();
      i = Fl(i);
      var u = oa(o, i);
      u !== null && Nn(u, o, i), Pp(o, i);
    }
  }
  var Wu = !0;
  function DO(o, i, u, f) {
    var g = L.T;
    L.T = null;
    var S = K.p;
    try {
      K.p = 2, Dp(o, i, u, f);
    } finally {
      K.p = S, L.T = g;
    }
  }
  function $O(o, i, u, f) {
    var g = L.T;
    L.T = null;
    var S = K.p;
    try {
      K.p = 8, Dp(o, i, u, f);
    } finally {
      K.p = S, L.T = g;
    }
  }
  function Dp(o, i, u, f) {
    if (Wu) {
      var g = $p(f);
      if (g === null)
        wp(
          o,
          i,
          f,
          Gu,
          u
        ), Jb(o, f);
      else if (LO(
        g,
        o,
        i,
        u,
        f
      ))
        f.stopPropagation();
      else if (Jb(o, f), i & 4 && -1 < TO.indexOf(o)) {
        for (; g !== null; ) {
          var S = Jo(g);
          if (S !== null)
            switch (S.tag) {
              case 3:
                if (S = S.stateNode, S.current.memoizedState.isDehydrated) {
                  var A = wr(S.pendingLanes);
                  if (A !== 0) {
                    var T = S;
                    for (T.pendingLanes |= 2, T.entangledLanes |= 2; A; ) {
                      var Y = 1 << 31 - Re(A);
                      T.entanglements[1] |= Y, A &= ~Y;
                    }
                    Er(S), (Je & 6) === 0 && (Nu = Ce() + 500, bs(0));
                  }
                }
                break;
              case 31:
              case 13:
                T = oa(S, 2), T !== null && Nn(T, S, 2), Au(), Pp(S, 2);
            }
          if (S = $p(f), S === null && wp(
            o,
            i,
            f,
            Gu,
            u
          ), S === g) break;
          g = S;
        }
        g !== null && f.stopPropagation();
      } else
        wp(
          o,
          i,
          f,
          null,
          u
        );
    }
  }
  function $p(o) {
    return o = Td(o), Tp(o);
  }
  var Gu = null;
  function Tp(o) {
    if (Gu = null, o = Qo(o), o !== null) {
      var i = s(o);
      if (i === null) o = null;
      else {
        var u = i.tag;
        if (u === 13) {
          if (o = l(i), o !== null) return o;
          o = null;
        } else if (u === 31) {
          if (o = c(i), o !== null) return o;
          o = null;
        } else if (u === 3) {
          if (i.stateNode.current.memoizedState.isDehydrated)
            return i.tag === 3 ? i.stateNode.containerInfo : null;
          o = null;
        } else i !== o && (o = null);
      }
    }
    return Gu = o, null;
  }
  function Qb(o) {
    switch (o) {
      case "beforetoggle":
      case "cancel":
      case "click":
      case "close":
      case "contextmenu":
      case "copy":
      case "cut":
      case "auxclick":
      case "dblclick":
      case "dragend":
      case "dragstart":
      case "drop":
      case "focusin":
      case "focusout":
      case "input":
      case "invalid":
      case "keydown":
      case "keypress":
      case "keyup":
      case "mousedown":
      case "mouseup":
      case "paste":
      case "pause":
      case "play":
      case "pointercancel":
      case "pointerdown":
      case "pointerup":
      case "ratechange":
      case "reset":
      case "resize":
      case "seeked":
      case "submit":
      case "toggle":
      case "touchcancel":
      case "touchend":
      case "touchstart":
      case "volumechange":
      case "change":
      case "selectionchange":
      case "textInput":
      case "compositionstart":
      case "compositionend":
      case "compositionupdate":
      case "beforeblur":
      case "afterblur":
      case "beforeinput":
      case "blur":
      case "fullscreenchange":
      case "focus":
      case "hashchange":
      case "popstate":
      case "select":
      case "selectstart":
        return 2;
      case "drag":
      case "dragenter":
      case "dragexit":
      case "dragleave":
      case "dragover":
      case "mousemove":
      case "mouseout":
      case "mouseover":
      case "pointermove":
      case "pointerout":
      case "pointerover":
      case "scroll":
      case "touchmove":
      case "wheel":
      case "mouseenter":
      case "mouseleave":
      case "pointerenter":
      case "pointerleave":
        return 8;
      case "message":
        switch (Me()) {
          case he:
            return 2;
          case ye:
            return 8;
          case Ee:
          case Le:
            return 32;
          case ze:
            return 268435456;
          default:
            return 32;
        }
      default:
        return 32;
    }
  }
  var Lp = !1, _o = null, Eo = null, Co = null, Cs = /* @__PURE__ */ new Map(), Os = /* @__PURE__ */ new Map(), Oo = [], TO = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset".split(
    " "
  );
  function Jb(o, i) {
    switch (o) {
      case "focusin":
      case "focusout":
        _o = null;
        break;
      case "dragenter":
      case "dragleave":
        Eo = null;
        break;
      case "mouseover":
      case "mouseout":
        Co = null;
        break;
      case "pointerover":
      case "pointerout":
        Cs.delete(i.pointerId);
        break;
      case "gotpointercapture":
      case "lostpointercapture":
        Os.delete(i.pointerId);
    }
  }
  function Ms(o, i, u, f, g, S) {
    return o === null || o.nativeEvent !== S ? (o = {
      blockedOn: i,
      domEventName: u,
      eventSystemFlags: f,
      nativeEvent: S,
      targetContainers: [g]
    }, i !== null && (i = Jo(i), i !== null && Xb(i)), o) : (o.eventSystemFlags |= f, i = o.targetContainers, g !== null && i.indexOf(g) === -1 && i.push(g), o);
  }
  function LO(o, i, u, f, g) {
    switch (i) {
      case "focusin":
        return _o = Ms(
          _o,
          o,
          i,
          u,
          f,
          g
        ), !0;
      case "dragenter":
        return Eo = Ms(
          Eo,
          o,
          i,
          u,
          f,
          g
        ), !0;
      case "mouseover":
        return Co = Ms(
          Co,
          o,
          i,
          u,
          f,
          g
        ), !0;
      case "pointerover":
        var S = g.pointerId;
        return Cs.set(
          S,
          Ms(
            Cs.get(S) || null,
            o,
            i,
            u,
            f,
            g
          )
        ), !0;
      case "gotpointercapture":
        return S = g.pointerId, Os.set(
          S,
          Ms(
            Os.get(S) || null,
            o,
            i,
            u,
            f,
            g
          )
        ), !0;
    }
    return !1;
  }
  function Zb(o) {
    var i = Qo(o.target);
    if (i !== null) {
      var u = s(i);
      if (u !== null) {
        if (i = u.tag, i === 13) {
          if (i = l(u), i !== null) {
            o.blockedOn = i, Cd(o.priority, function() {
              Yb(u);
            });
            return;
          }
        } else if (i === 31) {
          if (i = c(u), i !== null) {
            o.blockedOn = i, Cd(o.priority, function() {
              Yb(u);
            });
            return;
          }
        } else if (i === 3 && u.stateNode.current.memoizedState.isDehydrated) {
          o.blockedOn = u.tag === 3 ? u.stateNode.containerInfo : null;
          return;
        }
      }
    }
    o.blockedOn = null;
  }
  function Ku(o) {
    if (o.blockedOn !== null) return !1;
    for (var i = o.targetContainers; 0 < i.length; ) {
      var u = $p(o.nativeEvent);
      if (u === null) {
        u = o.nativeEvent;
        var f = new u.constructor(
          u.type,
          u
        );
        $d = f, u.target.dispatchEvent(f), $d = null;
      } else
        return i = Jo(u), i !== null && Xb(i), o.blockedOn = u, !1;
      i.shift();
    }
    return !0;
  }
  function ew(o, i, u) {
    Ku(o) && u.delete(i);
  }
  function IO() {
    Lp = !1, _o !== null && Ku(_o) && (_o = null), Eo !== null && Ku(Eo) && (Eo = null), Co !== null && Ku(Co) && (Co = null), Cs.forEach(ew), Os.forEach(ew);
  }
  function Xu(o, i) {
    o.blockedOn === i && (o.blockedOn = null, Lp || (Lp = !0, e.unstable_scheduleCallback(
      e.unstable_NormalPriority,
      IO
    )));
  }
  var Yu = null;
  function tw(o) {
    Yu !== o && (Yu = o, e.unstable_scheduleCallback(
      e.unstable_NormalPriority,
      function() {
        Yu === o && (Yu = null);
        for (var i = 0; i < o.length; i += 3) {
          var u = o[i], f = o[i + 1], g = o[i + 2];
          if (typeof f != "function") {
            if (Tp(f || u) === null)
              continue;
            break;
          }
          var S = Jo(u);
          S !== null && (o.splice(i, 3), i -= 3, $f(
            S,
            {
              pending: !0,
              data: g,
              method: u.method,
              action: f
            },
            f,
            g
          ));
        }
      }
    ));
  }
  function di(o) {
    function i(Y) {
      return Xu(Y, o);
    }
    _o !== null && Xu(_o, o), Eo !== null && Xu(Eo, o), Co !== null && Xu(Co, o), Cs.forEach(i), Os.forEach(i);
    for (var u = 0; u < Oo.length; u++) {
      var f = Oo[u];
      f.blockedOn === o && (f.blockedOn = null);
    }
    for (; 0 < Oo.length && (u = Oo[0], u.blockedOn === null); )
      Zb(u), u.blockedOn === null && Oo.shift();
    if (u = (o.ownerDocument || o).$$reactFormReplay, u != null)
      for (f = 0; f < u.length; f += 3) {
        var g = u[f], S = u[f + 1], A = g[mn] || null;
        if (typeof S == "function")
          A || tw(u);
        else if (A) {
          var T = null;
          if (S && S.hasAttribute("formAction")) {
            if (g = S, A = S[mn] || null)
              T = A.formAction;
            else if (Tp(g) !== null) continue;
          } else T = A.action;
          typeof T == "function" ? u[f + 1] = T : (u.splice(f, 3), f -= 3), tw(u);
        }
      }
  }
  function nw() {
    function o(S) {
      S.canIntercept && S.info === "react-transition" && S.intercept({
        handler: function() {
          return new Promise(function(A) {
            return g = A;
          });
        },
        focusReset: "manual",
        scroll: "manual"
      });
    }
    function i() {
      g !== null && (g(), g = null), f || setTimeout(u, 20);
    }
    function u() {
      if (!f && !navigation.transition) {
        var S = navigation.currentEntry;
        S && S.url != null && navigation.navigate(S.url, {
          state: S.getState(),
          info: "react-transition",
          history: "replace"
        });
      }
    }
    if (typeof navigation == "object") {
      var f = !1, g = null;
      return navigation.addEventListener("navigate", o), navigation.addEventListener("navigatesuccess", i), navigation.addEventListener("navigateerror", i), setTimeout(u, 100), function() {
        f = !0, navigation.removeEventListener("navigate", o), navigation.removeEventListener("navigatesuccess", i), navigation.removeEventListener("navigateerror", i), g !== null && (g(), g = null);
      };
    }
  }
  function Ip(o) {
    this._internalRoot = o;
  }
  Qu.prototype.render = Ip.prototype.render = function(o) {
    var i = this._internalRoot;
    if (i === null) throw Error(r(409));
    var u = i.current, f = Vn();
    Gb(u, f, o, i, null, null);
  }, Qu.prototype.unmount = Ip.prototype.unmount = function() {
    var o = this._internalRoot;
    if (o !== null) {
      this._internalRoot = null;
      var i = o.containerInfo;
      Gb(o.current, 2, null, o, null, null), Au(), i[zo] = null;
    }
  };
  function Qu(o) {
    this._internalRoot = o;
  }
  Qu.prototype.unstable_scheduleHydration = function(o) {
    if (o) {
      var i = Ed();
      o = { blockedOn: null, target: o, priority: i };
      for (var u = 0; u < Oo.length && i !== 0 && i < Oo[u].priority; u++) ;
      Oo.splice(u, 0, o), u === 0 && Zb(o);
    }
  };
  var rw = t.version;
  if (rw !== "19.2.3")
    throw Error(
      r(
        527,
        rw,
        "19.2.3"
      )
    );
  K.findDOMNode = function(o) {
    var i = o._reactInternals;
    if (i === void 0)
      throw typeof o.render == "function" ? Error(r(188)) : (o = Object.keys(o).join(","), Error(r(268, o)));
    return o = p(i), o = o !== null ? m(o) : null, o = o === null ? null : o.stateNode, o;
  };
  var zO = {
    bundleType: 0,
    version: "19.2.3",
    rendererPackageName: "react-dom",
    currentDispatcherRef: L,
    reconcilerVersion: "19.2.3"
  };
  if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u") {
    var Ju = __REACT_DEVTOOLS_GLOBAL_HOOK__;
    if (!Ju.isDisabled && Ju.supportsFiber)
      try {
        Wt = Ju.inject(
          zO
        ), Ot = Ju;
      } catch {
      }
  }
  return Mw.createRoot = function(o, i) {
    if (!a(o)) throw Error(r(299));
    var u = !1, f = "", g = cy, S = dy, A = fy;
    return i != null && (i.unstable_strictMode === !0 && (u = !0), i.identifierPrefix !== void 0 && (f = i.identifierPrefix), i.onUncaughtError !== void 0 && (g = i.onUncaughtError), i.onCaughtError !== void 0 && (S = i.onCaughtError), i.onRecoverableError !== void 0 && (A = i.onRecoverableError)), i = qb(
      o,
      1,
      !1,
      null,
      null,
      u,
      f,
      null,
      g,
      S,
      A,
      nw
    ), o[zo] = i.current, bp(o), new Ip(i);
  }, Mw.hydrateRoot = function(o, i, u) {
    if (!a(o)) throw Error(r(299));
    var f = !1, g = "", S = cy, A = dy, T = fy, Y = null;
    return u != null && (u.unstable_strictMode === !0 && (f = !0), u.identifierPrefix !== void 0 && (g = u.identifierPrefix), u.onUncaughtError !== void 0 && (S = u.onUncaughtError), u.onCaughtError !== void 0 && (A = u.onCaughtError), u.onRecoverableError !== void 0 && (T = u.onRecoverableError), u.formState !== void 0 && (Y = u.formState)), i = qb(
      o,
      1,
      !0,
      i,
      u ?? null,
      f,
      g,
      Y,
      S,
      A,
      T,
      nw
    ), i.context = Wb(null), u = i.current, f = Vn(), f = Fl(f), g = fo(f), g.callback = null, po(u, g, f), u = f, i.current.lanes = u, ja(i, u), Er(i), o[zo] = i.current, bp(o), new Qu(i);
  }, Mw.version = "19.2.3", Mw;
}
var y1;
function s9e() {
  if (y1) return BN.exports;
  y1 = 1;
  function e() {
    if (!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != "function"))
      try {
        __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(e);
      } catch (t) {
        console.error(t);
      }
  }
  return e(), BN.exports = i9e(), BN.exports;
}
var l9e = s9e();
const u9e = (e, t, { intervalMs: n = 250 } = {}) => {
  let r = !0, a = !1;
  const s = setInterval(() => {
    !r || a || e.isConnected || (a = !0, r = !1, clearInterval(s), t());
  }, n);
  return () => {
    r && (r = !1, clearInterval(s));
  };
}, c9e = () => {
  const e = /* @__PURE__ */ new Map();
  return {
    register: (t, n) => {
      const r = e.get(t);
      return r && r !== n && r.dispose(), e.set(t, n), () => {
        e.get(t) === n && e.delete(t);
      };
    },
    get: (t) => e.get(t),
    delete: (t) => {
      const n = e.get(t);
      n && (n.dispose(), e.delete(t));
    }
  };
}, d9e = () => {
  const e = globalThis;
  return e.__funcnodes_pyodide_mount_registry || (e.__funcnodes_pyodide_mount_registry = c9e()), e.__funcnodes_pyodide_mount_registry;
}, f9e = (e) => {
  if (typeof e != "string") return e;
  const t = document.getElementById(e);
  if (!t) throw new Error(`Element with id '${e}' not found`);
  return t;
}, p9e = (e, t, n = {}) => {
  t.shared_worker ? t.shared_worker = !0 : t.shared_worker = !1;
  const r = f9e(e);
  if (!t.uuid) {
    const v = r.id;
    v && (t.uuid = v);
  }
  const a = new fK(t), s = {
    ...n,
    worker: a,
    useWorkerManager: !1,
    id: a.uuid,
    debug: t.debug || !1,
    worker_url: "dummy"
    // dummy url as the current implementation requires one (will be removed in the next release of funcnodes_react_flow)
  }, l = d9e();
  let c = !1, d, p = () => {
  }, m = () => {
  };
  const h = {
    worker: a,
    dispose: () => {
      if (!c) {
        c = !0;
        try {
          m();
        } catch {
        }
        try {
          d?.unmount();
        } catch {
        }
        try {
          a.dispose?.();
        } catch {
        }
        try {
          p();
        } catch {
        }
      }
    }
  };
  return p = l.register(r, h), d = l9e.createRoot(r), d.render(
    /* @__PURE__ */ gj.jsx(Qn.StrictMode, { children: /* @__PURE__ */ gj.jsx(fj, { ...s }) })
  ), m = u9e(r, h.dispose, {
    intervalMs: 250
  }), h;
};
window.FuncNodes || (window.FuncNodes = pj);
window.FuncNodes.FuncnodesPyodideWorker = fK;
window.FuncNodes.FuncnodesPyodide = p9e;
