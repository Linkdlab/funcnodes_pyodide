var H6 = window;
function U6(e, t) {
  for (var n = 0; n < t.length; n++) {
    const r = t[n];
    if (typeof r != "string" && !Array.isArray(r)) {
      for (const o in r)
        if (o !== "default" && !(o in e)) {
          const a = Object.getOwnPropertyDescriptor(r, o);
          a && Object.defineProperty(e, o, a.get ? a : {
            enumerable: !0,
            get: () => r[o]
          });
        }
    }
  }
  return Object.freeze(Object.defineProperty(e, Symbol.toStringTag, { value: "Module" }));
}
(function() {
  const t = document.createElement("link").relList;
  if (t && t.supports && t.supports("modulepreload"))
    return;
  for (const o of document.querySelectorAll('link[rel="modulepreload"]'))
    r(o);
  new MutationObserver((o) => {
    for (const a of o)
      if (a.type === "childList")
        for (const l of a.addedNodes)
          l.tagName === "LINK" && l.rel === "modulepreload" && r(l);
  }).observe(document, { childList: !0, subtree: !0 });
  function n(o) {
    const a = {};
    return o.integrity && (a.integrity = o.integrity), o.referrerPolicy && (a.referrerPolicy = o.referrerPolicy), o.crossOrigin === "use-credentials" ? a.credentials = "include" : o.crossOrigin === "anonymous" ? a.credentials = "omit" : a.credentials = "same-origin", a;
  }
  function r(o) {
    if (o.ep)
      return;
    o.ep = !0;
    const a = n(o);
    fetch(o.href, a);
  }
})();
function AO(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var wy = { exports: {} }, Au = {};
/**
 * @license React
 * react-jsx-runtime.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var j_;
function F6() {
  if (j_) return Au;
  j_ = 1;
  var e = Symbol.for("react.transitional.element"), t = Symbol.for("react.fragment");
  function n(r, o, a) {
    var l = null;
    if (a !== void 0 && (l = "" + a), o.key !== void 0 && (l = "" + o.key), "key" in o) {
      a = {};
      for (var u in o)
        u !== "key" && (a[u] = o[u]);
    } else a = o;
    return o = a.ref, {
      $$typeof: e,
      type: r,
      key: l,
      ref: o !== void 0 ? o : null,
      props: a
    };
  }
  return Au.Fragment = t, Au.jsx = n, Au.jsxs = n, Au;
}
var D_;
function $6() {
  return D_ || (D_ = 1, wy.exports = F6()), wy.exports;
}
var Y6 = $6(), xy = { exports: {} }, Ru = {}, Sy = { exports: {} }, ky = {};
/**
 * @license React
 * scheduler.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var T_;
function q6() {
  return T_ || (T_ = 1, function(e) {
    function t(L, H) {
      var q = L.length;
      L.push(H);
      e: for (; 0 < q; ) {
        var Y = q - 1 >>> 1, M = L[Y];
        if (0 < o(M, H))
          L[Y] = H, L[q] = M, q = Y;
        else break e;
      }
    }
    function n(L) {
      return L.length === 0 ? null : L[0];
    }
    function r(L) {
      if (L.length === 0) return null;
      var H = L[0], q = L.pop();
      if (q !== H) {
        L[0] = q;
        e: for (var Y = 0, M = L.length, X = M >>> 1; Y < X; ) {
          var Q = 2 * (Y + 1) - 1, P = L[Q], te = Q + 1, ie = L[te];
          if (0 > o(P, q))
            te < M && 0 > o(ie, P) ? (L[Y] = ie, L[te] = q, Y = te) : (L[Y] = P, L[Q] = q, Y = Q);
          else if (te < M && 0 > o(ie, q))
            L[Y] = ie, L[te] = q, Y = te;
          else break e;
        }
      }
      return H;
    }
    function o(L, H) {
      var q = L.sortIndex - H.sortIndex;
      return q !== 0 ? q : L.id - H.id;
    }
    if (e.unstable_now = void 0, typeof performance == "object" && typeof performance.now == "function") {
      var a = performance;
      e.unstable_now = function() {
        return a.now();
      };
    } else {
      var l = Date, u = l.now();
      e.unstable_now = function() {
        return l.now() - u;
      };
    }
    var d = [], f = [], p = 1, m = null, g = 3, y = !1, w = !1, v = !1, x = !1, E = typeof setTimeout == "function" ? setTimeout : null, N = typeof clearTimeout == "function" ? clearTimeout : null, C = typeof setImmediate < "u" ? setImmediate : null;
    function A(L) {
      for (var H = n(f); H !== null; ) {
        if (H.callback === null) r(f);
        else if (H.startTime <= L)
          r(f), H.sortIndex = H.expirationTime, t(d, H);
        else break;
        H = n(f);
      }
    }
    function R(L) {
      if (v = !1, A(L), !w)
        if (n(d) !== null)
          w = !0, D || (D = !0, U());
        else {
          var H = n(f);
          H !== null && $(R, H.startTime - L);
        }
    }
    var D = !1, T = -1, V = 5, F = -1;
    function O() {
      return x ? !0 : !(e.unstable_now() - F < V);
    }
    function B() {
      if (x = !1, D) {
        var L = e.unstable_now();
        F = L;
        var H = !0;
        try {
          e: {
            w = !1, v && (v = !1, N(T), T = -1), y = !0;
            var q = g;
            try {
              t: {
                for (A(L), m = n(d); m !== null && !(m.expirationTime > L && O()); ) {
                  var Y = m.callback;
                  if (typeof Y == "function") {
                    m.callback = null, g = m.priorityLevel;
                    var M = Y(
                      m.expirationTime <= L
                    );
                    if (L = e.unstable_now(), typeof M == "function") {
                      m.callback = M, A(L), H = !0;
                      break t;
                    }
                    m === n(d) && r(d), A(L);
                  } else r(d);
                  m = n(d);
                }
                if (m !== null) H = !0;
                else {
                  var X = n(f);
                  X !== null && $(
                    R,
                    X.startTime - L
                  ), H = !1;
                }
              }
              break e;
            } finally {
              m = null, g = q, y = !1;
            }
            H = void 0;
          }
        } finally {
          H ? U() : D = !1;
        }
      }
    }
    var U;
    if (typeof C == "function")
      U = function() {
        C(B);
      };
    else if (typeof MessageChannel < "u") {
      var G = new MessageChannel(), z = G.port2;
      G.port1.onmessage = B, U = function() {
        z.postMessage(null);
      };
    } else
      U = function() {
        E(B, 0);
      };
    function $(L, H) {
      T = E(function() {
        L(e.unstable_now());
      }, H);
    }
    e.unstable_IdlePriority = 5, e.unstable_ImmediatePriority = 1, e.unstable_LowPriority = 4, e.unstable_NormalPriority = 3, e.unstable_Profiling = null, e.unstable_UserBlockingPriority = 2, e.unstable_cancelCallback = function(L) {
      L.callback = null;
    }, e.unstable_forceFrameRate = function(L) {
      0 > L || 125 < L ? console.error(
        "forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"
      ) : V = 0 < L ? Math.floor(1e3 / L) : 5;
    }, e.unstable_getCurrentPriorityLevel = function() {
      return g;
    }, e.unstable_next = function(L) {
      switch (g) {
        case 1:
        case 2:
        case 3:
          var H = 3;
          break;
        default:
          H = g;
      }
      var q = g;
      g = H;
      try {
        return L();
      } finally {
        g = q;
      }
    }, e.unstable_requestPaint = function() {
      x = !0;
    }, e.unstable_runWithPriority = function(L, H) {
      switch (L) {
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
          break;
        default:
          L = 3;
      }
      var q = g;
      g = L;
      try {
        return H();
      } finally {
        g = q;
      }
    }, e.unstable_scheduleCallback = function(L, H, q) {
      var Y = e.unstable_now();
      switch (typeof q == "object" && q !== null ? (q = q.delay, q = typeof q == "number" && 0 < q ? Y + q : Y) : q = Y, L) {
        case 1:
          var M = -1;
          break;
        case 2:
          M = 250;
          break;
        case 5:
          M = 1073741823;
          break;
        case 4:
          M = 1e4;
          break;
        default:
          M = 5e3;
      }
      return M = q + M, L = {
        id: p++,
        callback: H,
        priorityLevel: L,
        startTime: q,
        expirationTime: M,
        sortIndex: -1
      }, q > Y ? (L.sortIndex = q, t(f, L), n(d) === null && L === n(f) && (v ? (N(T), T = -1) : v = !0, $(R, q - Y))) : (L.sortIndex = M, t(d, L), w || y || (w = !0, D || (D = !0, U()))), L;
    }, e.unstable_shouldYield = O, e.unstable_wrapCallback = function(L) {
      var H = g;
      return function() {
        var q = g;
        g = H;
        try {
          return L.apply(this, arguments);
        } finally {
          g = q;
        }
      };
    };
  }(ky)), ky;
}
var z_;
function X6() {
  return z_ || (z_ = 1, Sy.exports = q6()), Sy.exports;
}
var _y = { exports: {} }, He = {};
/**
 * @license React
 * react.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var P_;
function G6() {
  if (P_) return He;
  P_ = 1;
  var e = Symbol.for("react.transitional.element"), t = Symbol.for("react.portal"), n = Symbol.for("react.fragment"), r = Symbol.for("react.strict_mode"), o = Symbol.for("react.profiler"), a = Symbol.for("react.consumer"), l = Symbol.for("react.context"), u = Symbol.for("react.forward_ref"), d = Symbol.for("react.suspense"), f = Symbol.for("react.memo"), p = Symbol.for("react.lazy"), m = Symbol.iterator;
  function g(M) {
    return M === null || typeof M != "object" ? null : (M = m && M[m] || M["@@iterator"], typeof M == "function" ? M : null);
  }
  var y = {
    isMounted: function() {
      return !1;
    },
    enqueueForceUpdate: function() {
    },
    enqueueReplaceState: function() {
    },
    enqueueSetState: function() {
    }
  }, w = Object.assign, v = {};
  function x(M, X, Q) {
    this.props = M, this.context = X, this.refs = v, this.updater = Q || y;
  }
  x.prototype.isReactComponent = {}, x.prototype.setState = function(M, X) {
    if (typeof M != "object" && typeof M != "function" && M != null)
      throw Error(
        "takes an object of state variables to update or a function which returns an object of state variables."
      );
    this.updater.enqueueSetState(this, M, X, "setState");
  }, x.prototype.forceUpdate = function(M) {
    this.updater.enqueueForceUpdate(this, M, "forceUpdate");
  };
  function E() {
  }
  E.prototype = x.prototype;
  function N(M, X, Q) {
    this.props = M, this.context = X, this.refs = v, this.updater = Q || y;
  }
  var C = N.prototype = new E();
  C.constructor = N, w(C, x.prototype), C.isPureReactComponent = !0;
  var A = Array.isArray, R = { H: null, A: null, T: null, S: null, V: null }, D = Object.prototype.hasOwnProperty;
  function T(M, X, Q, P, te, ie) {
    return Q = ie.ref, {
      $$typeof: e,
      type: M,
      key: X,
      ref: Q !== void 0 ? Q : null,
      props: ie
    };
  }
  function V(M, X) {
    return T(
      M.type,
      X,
      void 0,
      void 0,
      void 0,
      M.props
    );
  }
  function F(M) {
    return typeof M == "object" && M !== null && M.$$typeof === e;
  }
  function O(M) {
    var X = { "=": "=0", ":": "=2" };
    return "$" + M.replace(/[=:]/g, function(Q) {
      return X[Q];
    });
  }
  var B = /\/+/g;
  function U(M, X) {
    return typeof M == "object" && M !== null && M.key != null ? O("" + M.key) : X.toString(36);
  }
  function G() {
  }
  function z(M) {
    switch (M.status) {
      case "fulfilled":
        return M.value;
      case "rejected":
        throw M.reason;
      default:
        switch (typeof M.status == "string" ? M.then(G, G) : (M.status = "pending", M.then(
          function(X) {
            M.status === "pending" && (M.status = "fulfilled", M.value = X);
          },
          function(X) {
            M.status === "pending" && (M.status = "rejected", M.reason = X);
          }
        )), M.status) {
          case "fulfilled":
            return M.value;
          case "rejected":
            throw M.reason;
        }
    }
    throw M;
  }
  function $(M, X, Q, P, te) {
    var ie = typeof M;
    (ie === "undefined" || ie === "boolean") && (M = null);
    var ae = !1;
    if (M === null) ae = !0;
    else
      switch (ie) {
        case "bigint":
        case "string":
        case "number":
          ae = !0;
          break;
        case "object":
          switch (M.$$typeof) {
            case e:
            case t:
              ae = !0;
              break;
            case p:
              return ae = M._init, $(
                ae(M._payload),
                X,
                Q,
                P,
                te
              );
          }
      }
    if (ae)
      return te = te(M), ae = P === "" ? "." + U(M, 0) : P, A(te) ? (Q = "", ae != null && (Q = ae.replace(B, "$&/") + "/"), $(te, X, Q, "", function(ye) {
        return ye;
      })) : te != null && (F(te) && (te = V(
        te,
        Q + (te.key == null || M && M.key === te.key ? "" : ("" + te.key).replace(
          B,
          "$&/"
        ) + "/") + ae
      )), X.push(te)), 1;
    ae = 0;
    var fe = P === "" ? "." : P + ":";
    if (A(M))
      for (var he = 0; he < M.length; he++)
        P = M[he], ie = fe + U(P, he), ae += $(
          P,
          X,
          Q,
          ie,
          te
        );
    else if (he = g(M), typeof he == "function")
      for (M = he.call(M), he = 0; !(P = M.next()).done; )
        P = P.value, ie = fe + U(P, he++), ae += $(
          P,
          X,
          Q,
          ie,
          te
        );
    else if (ie === "object") {
      if (typeof M.then == "function")
        return $(
          z(M),
          X,
          Q,
          P,
          te
        );
      throw X = String(M), Error(
        "Objects are not valid as a React child (found: " + (X === "[object Object]" ? "object with keys {" + Object.keys(M).join(", ") + "}" : X) + "). If you meant to render a collection of children, use an array instead."
      );
    }
    return ae;
  }
  function L(M, X, Q) {
    if (M == null) return M;
    var P = [], te = 0;
    return $(M, P, "", "", function(ie) {
      return X.call(Q, ie, te++);
    }), P;
  }
  function H(M) {
    if (M._status === -1) {
      var X = M._result;
      X = X(), X.then(
        function(Q) {
          (M._status === 0 || M._status === -1) && (M._status = 1, M._result = Q);
        },
        function(Q) {
          (M._status === 0 || M._status === -1) && (M._status = 2, M._result = Q);
        }
      ), M._status === -1 && (M._status = 0, M._result = X);
    }
    if (M._status === 1) return M._result.default;
    throw M._result;
  }
  var q = typeof reportError == "function" ? reportError : function(M) {
    if (typeof window == "object" && typeof window.ErrorEvent == "function") {
      var X = new window.ErrorEvent("error", {
        bubbles: !0,
        cancelable: !0,
        message: typeof M == "object" && M !== null && typeof M.message == "string" ? String(M.message) : String(M),
        error: M
      });
      if (!window.dispatchEvent(X)) return;
    } else if (typeof process == "object" && typeof process.emit == "function") {
      process.emit("uncaughtException", M);
      return;
    }
    console.error(M);
  };
  function Y() {
  }
  return He.Children = {
    map: L,
    forEach: function(M, X, Q) {
      L(
        M,
        function() {
          X.apply(this, arguments);
        },
        Q
      );
    },
    count: function(M) {
      var X = 0;
      return L(M, function() {
        X++;
      }), X;
    },
    toArray: function(M) {
      return L(M, function(X) {
        return X;
      }) || [];
    },
    only: function(M) {
      if (!F(M))
        throw Error(
          "React.Children.only expected to receive a single React element child."
        );
      return M;
    }
  }, He.Component = x, He.Fragment = n, He.Profiler = o, He.PureComponent = N, He.StrictMode = r, He.Suspense = d, He.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = R, He.__COMPILER_RUNTIME = {
    __proto__: null,
    c: function(M) {
      return R.H.useMemoCache(M);
    }
  }, He.cache = function(M) {
    return function() {
      return M.apply(null, arguments);
    };
  }, He.cloneElement = function(M, X, Q) {
    if (M == null)
      throw Error(
        "The argument must be a React element, but you passed " + M + "."
      );
    var P = w({}, M.props), te = M.key, ie = void 0;
    if (X != null)
      for (ae in X.ref !== void 0 && (ie = void 0), X.key !== void 0 && (te = "" + X.key), X)
        !D.call(X, ae) || ae === "key" || ae === "__self" || ae === "__source" || ae === "ref" && X.ref === void 0 || (P[ae] = X[ae]);
    var ae = arguments.length - 2;
    if (ae === 1) P.children = Q;
    else if (1 < ae) {
      for (var fe = Array(ae), he = 0; he < ae; he++)
        fe[he] = arguments[he + 2];
      P.children = fe;
    }
    return T(M.type, te, void 0, void 0, ie, P);
  }, He.createContext = function(M) {
    return M = {
      $$typeof: l,
      _currentValue: M,
      _currentValue2: M,
      _threadCount: 0,
      Provider: null,
      Consumer: null
    }, M.Provider = M, M.Consumer = {
      $$typeof: a,
      _context: M
    }, M;
  }, He.createElement = function(M, X, Q) {
    var P, te = {}, ie = null;
    if (X != null)
      for (P in X.key !== void 0 && (ie = "" + X.key), X)
        D.call(X, P) && P !== "key" && P !== "__self" && P !== "__source" && (te[P] = X[P]);
    var ae = arguments.length - 2;
    if (ae === 1) te.children = Q;
    else if (1 < ae) {
      for (var fe = Array(ae), he = 0; he < ae; he++)
        fe[he] = arguments[he + 2];
      te.children = fe;
    }
    if (M && M.defaultProps)
      for (P in ae = M.defaultProps, ae)
        te[P] === void 0 && (te[P] = ae[P]);
    return T(M, ie, void 0, void 0, null, te);
  }, He.createRef = function() {
    return { current: null };
  }, He.forwardRef = function(M) {
    return { $$typeof: u, render: M };
  }, He.isValidElement = F, He.lazy = function(M) {
    return {
      $$typeof: p,
      _payload: { _status: -1, _result: M },
      _init: H
    };
  }, He.memo = function(M, X) {
    return {
      $$typeof: f,
      type: M,
      compare: X === void 0 ? null : X
    };
  }, He.startTransition = function(M) {
    var X = R.T, Q = {};
    R.T = Q;
    try {
      var P = M(), te = R.S;
      te !== null && te(Q, P), typeof P == "object" && P !== null && typeof P.then == "function" && P.then(Y, q);
    } catch (ie) {
      q(ie);
    } finally {
      R.T = X;
    }
  }, He.unstable_useCacheRefresh = function() {
    return R.H.useCacheRefresh();
  }, He.use = function(M) {
    return R.H.use(M);
  }, He.useActionState = function(M, X, Q) {
    return R.H.useActionState(M, X, Q);
  }, He.useCallback = function(M, X) {
    return R.H.useCallback(M, X);
  }, He.useContext = function(M) {
    return R.H.useContext(M);
  }, He.useDebugValue = function() {
  }, He.useDeferredValue = function(M, X) {
    return R.H.useDeferredValue(M, X);
  }, He.useEffect = function(M, X, Q) {
    var P = R.H;
    if (typeof Q == "function")
      throw Error(
        "useEffect CRUD overload is not enabled in this build of React."
      );
    return P.useEffect(M, X);
  }, He.useId = function() {
    return R.H.useId();
  }, He.useImperativeHandle = function(M, X, Q) {
    return R.H.useImperativeHandle(M, X, Q);
  }, He.useInsertionEffect = function(M, X) {
    return R.H.useInsertionEffect(M, X);
  }, He.useLayoutEffect = function(M, X) {
    return R.H.useLayoutEffect(M, X);
  }, He.useMemo = function(M, X) {
    return R.H.useMemo(M, X);
  }, He.useOptimistic = function(M, X) {
    return R.H.useOptimistic(M, X);
  }, He.useReducer = function(M, X, Q) {
    return R.H.useReducer(M, X, Q);
  }, He.useRef = function(M) {
    return R.H.useRef(M);
  }, He.useState = function(M) {
    return R.H.useState(M);
  }, He.useSyncExternalStore = function(M, X, Q) {
    return R.H.useSyncExternalStore(
      M,
      X,
      Q
    );
  }, He.useTransition = function() {
    return R.H.useTransition();
  }, He.version = "19.1.0", He;
}
var L_;
function iw() {
  return L_ || (L_ = 1, _y.exports = G6()), _y.exports;
}
var Ey = { exports: {} }, dn = {};
/**
 * @license React
 * react-dom.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var I_;
function Z6() {
  if (I_) return dn;
  I_ = 1;
  var e = iw();
  function t(d) {
    var f = "https://react.dev/errors/" + d;
    if (1 < arguments.length) {
      f += "?args[]=" + encodeURIComponent(arguments[1]);
      for (var p = 2; p < arguments.length; p++)
        f += "&args[]=" + encodeURIComponent(arguments[p]);
    }
    return "Minified React error #" + d + "; visit " + f + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
  }
  function n() {
  }
  var r = {
    d: {
      f: n,
      r: function() {
        throw Error(t(522));
      },
      D: n,
      C: n,
      L: n,
      m: n,
      X: n,
      S: n,
      M: n
    },
    p: 0,
    findDOMNode: null
  }, o = Symbol.for("react.portal");
  function a(d, f, p) {
    var m = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null;
    return {
      $$typeof: o,
      key: m == null ? null : "" + m,
      children: d,
      containerInfo: f,
      implementation: p
    };
  }
  var l = e.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE;
  function u(d, f) {
    if (d === "font") return "";
    if (typeof f == "string")
      return f === "use-credentials" ? f : "";
  }
  return dn.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = r, dn.createPortal = function(d, f) {
    var p = 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : null;
    if (!f || f.nodeType !== 1 && f.nodeType !== 9 && f.nodeType !== 11)
      throw Error(t(299));
    return a(d, f, null, p);
  }, dn.flushSync = function(d) {
    var f = l.T, p = r.p;
    try {
      if (l.T = null, r.p = 2, d) return d();
    } finally {
      l.T = f, r.p = p, r.d.f();
    }
  }, dn.preconnect = function(d, f) {
    typeof d == "string" && (f ? (f = f.crossOrigin, f = typeof f == "string" ? f === "use-credentials" ? f : "" : void 0) : f = null, r.d.C(d, f));
  }, dn.prefetchDNS = function(d) {
    typeof d == "string" && r.d.D(d);
  }, dn.preinit = function(d, f) {
    if (typeof d == "string" && f && typeof f.as == "string") {
      var p = f.as, m = u(p, f.crossOrigin), g = typeof f.integrity == "string" ? f.integrity : void 0, y = typeof f.fetchPriority == "string" ? f.fetchPriority : void 0;
      p === "style" ? r.d.S(
        d,
        typeof f.precedence == "string" ? f.precedence : void 0,
        {
          crossOrigin: m,
          integrity: g,
          fetchPriority: y
        }
      ) : p === "script" && r.d.X(d, {
        crossOrigin: m,
        integrity: g,
        fetchPriority: y,
        nonce: typeof f.nonce == "string" ? f.nonce : void 0
      });
    }
  }, dn.preinitModule = function(d, f) {
    if (typeof d == "string")
      if (typeof f == "object" && f !== null) {
        if (f.as == null || f.as === "script") {
          var p = u(
            f.as,
            f.crossOrigin
          );
          r.d.M(d, {
            crossOrigin: p,
            integrity: typeof f.integrity == "string" ? f.integrity : void 0,
            nonce: typeof f.nonce == "string" ? f.nonce : void 0
          });
        }
      } else f == null && r.d.M(d);
  }, dn.preload = function(d, f) {
    if (typeof d == "string" && typeof f == "object" && f !== null && typeof f.as == "string") {
      var p = f.as, m = u(p, f.crossOrigin);
      r.d.L(d, p, {
        crossOrigin: m,
        integrity: typeof f.integrity == "string" ? f.integrity : void 0,
        nonce: typeof f.nonce == "string" ? f.nonce : void 0,
        type: typeof f.type == "string" ? f.type : void 0,
        fetchPriority: typeof f.fetchPriority == "string" ? f.fetchPriority : void 0,
        referrerPolicy: typeof f.referrerPolicy == "string" ? f.referrerPolicy : void 0,
        imageSrcSet: typeof f.imageSrcSet == "string" ? f.imageSrcSet : void 0,
        imageSizes: typeof f.imageSizes == "string" ? f.imageSizes : void 0,
        media: typeof f.media == "string" ? f.media : void 0
      });
    }
  }, dn.preloadModule = function(d, f) {
    if (typeof d == "string")
      if (f) {
        var p = u(f.as, f.crossOrigin);
        r.d.m(d, {
          as: typeof f.as == "string" && f.as !== "script" ? f.as : void 0,
          crossOrigin: p,
          integrity: typeof f.integrity == "string" ? f.integrity : void 0
        });
      } else r.d.m(d);
  }, dn.requestFormReset = function(d) {
    r.d.r(d);
  }, dn.unstable_batchedUpdates = function(d, f) {
    return d(f);
  }, dn.useFormState = function(d, f, p) {
    return l.H.useFormState(d, f, p);
  }, dn.useFormStatus = function() {
    return l.H.useHostTransitionStatus();
  }, dn.version = "19.1.0", dn;
}
var B_;
function RO() {
  if (B_) return Ey.exports;
  B_ = 1;
  function e() {
    if (!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != "function"))
      try {
        __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(e);
      } catch (t) {
        console.error(t);
      }
  }
  return e(), Ey.exports = Z6(), Ey.exports;
}
/**
 * @license React
 * react-dom-client.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var V_;
function W6() {
  if (V_) return Ru;
  V_ = 1;
  var e = X6(), t = iw(), n = RO();
  function r(i) {
    var s = "https://react.dev/errors/" + i;
    if (1 < arguments.length) {
      s += "?args[]=" + encodeURIComponent(arguments[1]);
      for (var c = 2; c < arguments.length; c++)
        s += "&args[]=" + encodeURIComponent(arguments[c]);
    }
    return "Minified React error #" + i + "; visit " + s + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
  }
  function o(i) {
    return !(!i || i.nodeType !== 1 && i.nodeType !== 9 && i.nodeType !== 11);
  }
  function a(i) {
    var s = i, c = i;
    if (i.alternate) for (; s.return; ) s = s.return;
    else {
      i = s;
      do
        s = i, (s.flags & 4098) !== 0 && (c = s.return), i = s.return;
      while (i);
    }
    return s.tag === 3 ? c : null;
  }
  function l(i) {
    if (i.tag === 13) {
      var s = i.memoizedState;
      if (s === null && (i = i.alternate, i !== null && (s = i.memoizedState)), s !== null) return s.dehydrated;
    }
    return null;
  }
  function u(i) {
    if (a(i) !== i)
      throw Error(r(188));
  }
  function d(i) {
    var s = i.alternate;
    if (!s) {
      if (s = a(i), s === null) throw Error(r(188));
      return s !== i ? null : i;
    }
    for (var c = i, h = s; ; ) {
      var b = c.return;
      if (b === null) break;
      var S = b.alternate;
      if (S === null) {
        if (h = b.return, h !== null) {
          c = h;
          continue;
        }
        break;
      }
      if (b.child === S.child) {
        for (S = b.child; S; ) {
          if (S === c) return u(b), i;
          if (S === h) return u(b), s;
          S = S.sibling;
        }
        throw Error(r(188));
      }
      if (c.return !== h.return) c = b, h = S;
      else {
        for (var j = !1, I = b.child; I; ) {
          if (I === c) {
            j = !0, c = b, h = S;
            break;
          }
          if (I === h) {
            j = !0, h = b, c = S;
            break;
          }
          I = I.sibling;
        }
        if (!j) {
          for (I = S.child; I; ) {
            if (I === c) {
              j = !0, c = S, h = b;
              break;
            }
            if (I === h) {
              j = !0, h = S, c = b;
              break;
            }
            I = I.sibling;
          }
          if (!j) throw Error(r(189));
        }
      }
      if (c.alternate !== h) throw Error(r(190));
    }
    if (c.tag !== 3) throw Error(r(188));
    return c.stateNode.current === c ? i : s;
  }
  function f(i) {
    var s = i.tag;
    if (s === 5 || s === 26 || s === 27 || s === 6) return i;
    for (i = i.child; i !== null; ) {
      if (s = f(i), s !== null) return s;
      i = i.sibling;
    }
    return null;
  }
  var p = Object.assign, m = Symbol.for("react.element"), g = Symbol.for("react.transitional.element"), y = Symbol.for("react.portal"), w = Symbol.for("react.fragment"), v = Symbol.for("react.strict_mode"), x = Symbol.for("react.profiler"), E = Symbol.for("react.provider"), N = Symbol.for("react.consumer"), C = Symbol.for("react.context"), A = Symbol.for("react.forward_ref"), R = Symbol.for("react.suspense"), D = Symbol.for("react.suspense_list"), T = Symbol.for("react.memo"), V = Symbol.for("react.lazy"), F = Symbol.for("react.activity"), O = Symbol.for("react.memo_cache_sentinel"), B = Symbol.iterator;
  function U(i) {
    return i === null || typeof i != "object" ? null : (i = B && i[B] || i["@@iterator"], typeof i == "function" ? i : null);
  }
  var G = Symbol.for("react.client.reference");
  function z(i) {
    if (i == null) return null;
    if (typeof i == "function")
      return i.$$typeof === G ? null : i.displayName || i.name || null;
    if (typeof i == "string") return i;
    switch (i) {
      case w:
        return "Fragment";
      case x:
        return "Profiler";
      case v:
        return "StrictMode";
      case R:
        return "Suspense";
      case D:
        return "SuspenseList";
      case F:
        return "Activity";
    }
    if (typeof i == "object")
      switch (i.$$typeof) {
        case y:
          return "Portal";
        case C:
          return (i.displayName || "Context") + ".Provider";
        case N:
          return (i._context.displayName || "Context") + ".Consumer";
        case A:
          var s = i.render;
          return i = i.displayName, i || (i = s.displayName || s.name || "", i = i !== "" ? "ForwardRef(" + i + ")" : "ForwardRef"), i;
        case T:
          return s = i.displayName || null, s !== null ? s : z(i.type) || "Memo";
        case V:
          s = i._payload, i = i._init;
          try {
            return z(i(s));
          } catch {
          }
      }
    return null;
  }
  var $ = Array.isArray, L = t.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, H = n.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, q = {
    pending: !1,
    data: null,
    method: null,
    action: null
  }, Y = [], M = -1;
  function X(i) {
    return { current: i };
  }
  function Q(i) {
    0 > M || (i.current = Y[M], Y[M] = null, M--);
  }
  function P(i, s) {
    M++, Y[M] = i.current, i.current = s;
  }
  var te = X(null), ie = X(null), ae = X(null), fe = X(null);
  function he(i, s) {
    switch (P(ae, s), P(ie, i), P(te, null), s.nodeType) {
      case 9:
      case 11:
        i = (i = s.documentElement) && (i = i.namespaceURI) ? a_(i) : 0;
        break;
      default:
        if (i = s.tagName, s = s.namespaceURI)
          s = a_(s), i = l_(s, i);
        else
          switch (i) {
            case "svg":
              i = 1;
              break;
            case "math":
              i = 2;
              break;
            default:
              i = 0;
          }
    }
    Q(te), P(te, i);
  }
  function ye() {
    Q(te), Q(ie), Q(ae);
  }
  function Ee(i) {
    i.memoizedState !== null && P(fe, i);
    var s = te.current, c = l_(s, i.type);
    s !== c && (P(ie, i), P(te, c));
  }
  function we(i) {
    ie.current === i && (Q(te), Q(ie)), fe.current === i && (Q(fe), Eu._currentValue = q);
  }
  var xe = Object.prototype.hasOwnProperty, Pe = e.unstable_scheduleCallback, Ve = e.unstable_cancelCallback, Rt = e.unstable_shouldYield, Pt = e.unstable_requestPaint, lt = e.unstable_now, wr = e.unstable_getCurrentPriorityLevel, en = e.unstable_ImmediatePriority, Bn = e.unstable_UserBlockingPriority, je = e.unstable_NormalPriority, ho = e.unstable_LowPriority, Lr = e.unstable_IdlePriority, Ki = e.log, mo = e.unstable_setDisableYieldValue, le = null, pe = null;
  function ke(i) {
    if (typeof Ki == "function" && mo(i), pe && typeof pe.setStrictMode == "function")
      try {
        pe.setStrictMode(le, i);
      } catch {
      }
  }
  var Le = Math.clz32 ? Math.clz32 : Ir, ot = Math.log, En = Math.LN2;
  function Ir(i) {
    return i >>>= 0, i === 0 ? 32 : 31 - (ot(i) / En | 0) | 0;
  }
  var sn = 256, ir = 4194304;
  function vn(i) {
    var s = i & 42;
    if (s !== 0) return s;
    switch (i & -i) {
      case 1:
        return 1;
      case 2:
        return 2;
      case 4:
        return 4;
      case 8:
        return 8;
      case 16:
        return 16;
      case 32:
        return 32;
      case 64:
        return 64;
      case 128:
        return 128;
      case 256:
      case 512:
      case 1024:
      case 2048:
      case 4096:
      case 8192:
      case 16384:
      case 32768:
      case 65536:
      case 131072:
      case 262144:
      case 524288:
      case 1048576:
      case 2097152:
        return i & 4194048;
      case 4194304:
      case 8388608:
      case 16777216:
      case 33554432:
        return i & 62914560;
      case 67108864:
        return 67108864;
      case 134217728:
        return 134217728;
      case 268435456:
        return 268435456;
      case 536870912:
        return 536870912;
      case 1073741824:
        return 0;
      default:
        return i;
    }
  }
  function Lt(i, s, c) {
    var h = i.pendingLanes;
    if (h === 0) return 0;
    var b = 0, S = i.suspendedLanes, j = i.pingedLanes;
    i = i.warmLanes;
    var I = h & 134217727;
    return I !== 0 ? (h = I & ~S, h !== 0 ? b = vn(h) : (j &= I, j !== 0 ? b = vn(j) : c || (c = I & ~i, c !== 0 && (b = vn(c))))) : (I = h & ~S, I !== 0 ? b = vn(I) : j !== 0 ? b = vn(j) : c || (c = h & ~i, c !== 0 && (b = vn(c)))), b === 0 ? 0 : s !== 0 && s !== b && (s & S) === 0 && (S = b & -b, c = s & -s, S >= c || S === 32 && (c & 4194048) !== 0) ? s : b;
  }
  function Cn(i, s) {
    return (i.pendingLanes & ~(i.suspendedLanes & ~i.pingedLanes) & s) === 0;
  }
  function Vn(i, s) {
    switch (i) {
      case 1:
      case 2:
      case 4:
      case 8:
      case 64:
        return s + 250;
      case 16:
      case 32:
      case 128:
      case 256:
      case 512:
      case 1024:
      case 2048:
      case 4096:
      case 8192:
      case 16384:
      case 32768:
      case 65536:
      case 131072:
      case 262144:
      case 524288:
      case 1048576:
      case 2097152:
        return s + 5e3;
      case 4194304:
      case 8388608:
      case 16777216:
      case 33554432:
        return -1;
      case 67108864:
      case 134217728:
      case 268435456:
      case 536870912:
      case 1073741824:
        return -1;
      default:
        return -1;
    }
  }
  function Jc() {
    var i = sn;
    return sn <<= 1, (sn & 4194048) === 0 && (sn = 256), i;
  }
  function ed() {
    var i = ir;
    return ir <<= 1, (ir & 62914560) === 0 && (ir = 4194304), i;
  }
  function Os(i) {
    for (var s = [], c = 0; 31 > c; c++) s.push(i);
    return s;
  }
  function Qi(i, s) {
    i.pendingLanes |= s, s !== 268435456 && (i.suspendedLanes = 0, i.pingedLanes = 0, i.warmLanes = 0);
  }
  function dm(i, s, c, h, b, S) {
    var j = i.pendingLanes;
    i.pendingLanes = c, i.suspendedLanes = 0, i.pingedLanes = 0, i.warmLanes = 0, i.expiredLanes &= c, i.entangledLanes &= c, i.errorRecoveryDisabledLanes &= c, i.shellSuspendCounter = 0;
    var I = i.entanglements, Z = i.expirationTimes, ee = i.hiddenUpdates;
    for (c = j & ~c; 0 < c; ) {
      var ue = 31 - Le(c), de = 1 << ue;
      I[ue] = 0, Z[ue] = -1;
      var ne = ee[ue];
      if (ne !== null)
        for (ee[ue] = null, ue = 0; ue < ne.length; ue++) {
          var re = ne[ue];
          re !== null && (re.lane &= -536870913);
        }
      c &= ~de;
    }
    h !== 0 && Ns(i, h, 0), S !== 0 && b === 0 && i.tag !== 0 && (i.suspendedLanes |= S & ~(j & ~s));
  }
  function Ns(i, s, c) {
    i.pendingLanes |= s, i.suspendedLanes &= ~s;
    var h = 31 - Le(s);
    i.entangledLanes |= s, i.entanglements[h] = i.entanglements[h] | 1073741824 | c & 4194090;
  }
  function td(i, s) {
    var c = i.entangledLanes |= s;
    for (i = i.entanglements; c; ) {
      var h = 31 - Le(c), b = 1 << h;
      b & s | i[h] & s && (i[h] |= s), c &= ~b;
    }
  }
  function Ms(i) {
    switch (i) {
      case 2:
        i = 1;
        break;
      case 8:
        i = 4;
        break;
      case 32:
        i = 16;
        break;
      case 256:
      case 512:
      case 1024:
      case 2048:
      case 4096:
      case 8192:
      case 16384:
      case 32768:
      case 65536:
      case 131072:
      case 262144:
      case 524288:
      case 1048576:
      case 2097152:
      case 4194304:
      case 8388608:
      case 16777216:
      case 33554432:
        i = 128;
        break;
      case 268435456:
        i = 134217728;
        break;
      default:
        i = 0;
    }
    return i;
  }
  function As(i) {
    return i &= -i, 2 < i ? 8 < i ? (i & 134217727) !== 0 ? 32 : 268435456 : 8 : 2;
  }
  function nd() {
    var i = H.p;
    return i !== 0 ? i : (i = window.event, i === void 0 ? 32 : C_(i.type));
  }
  function fm(i, s) {
    var c = H.p;
    try {
      return H.p = i, s();
    } finally {
      H.p = c;
    }
  }
  var Br = Math.random().toString(36).slice(2), Wt = "__reactFiber$" + Br, un = "__reactProps$" + Br, ni = "__reactContainer$" + Br, Rs = "__reactEvents$" + Br, pm = "__reactListeners$" + Br, hm = "__reactHandles$" + Br, rd = "__reactResources$" + Br, Ji = "__reactMarker$" + Br;
  function js(i) {
    delete i[Wt], delete i[un], delete i[Rs], delete i[pm], delete i[hm];
  }
  function go(i) {
    var s = i[Wt];
    if (s) return s;
    for (var c = i.parentNode; c; ) {
      if (s = c[ni] || c[Wt]) {
        if (c = s.alternate, s.child !== null || c !== null && c.child !== null)
          for (i = d_(i); i !== null; ) {
            if (c = i[Wt]) return c;
            i = d_(i);
          }
        return s;
      }
      i = c, c = i.parentNode;
    }
    return null;
  }
  function yo(i) {
    if (i = i[Wt] || i[ni]) {
      var s = i.tag;
      if (s === 5 || s === 6 || s === 13 || s === 26 || s === 27 || s === 3)
        return i;
    }
    return null;
  }
  function ea(i) {
    var s = i.tag;
    if (s === 5 || s === 26 || s === 27 || s === 6) return i.stateNode;
    throw Error(r(33));
  }
  function ri(i) {
    var s = i[rd];
    return s || (s = i[rd] = { hoistableStyles: /* @__PURE__ */ new Map(), hoistableScripts: /* @__PURE__ */ new Map() }), s;
  }
  function It(i) {
    i[Ji] = !0;
  }
  var od = /* @__PURE__ */ new Set(), id = {};
  function vo(i, s) {
    oi(i, s), oi(i + "Capture", s);
  }
  function oi(i, s) {
    for (id[i] = s, i = 0; i < s.length; i++)
      od.add(s[i]);
  }
  var ad = RegExp(
    "^[:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD][:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"
  ), ld = {}, sd = {};
  function mm(i) {
    return xe.call(sd, i) ? !0 : xe.call(ld, i) ? !1 : ad.test(i) ? sd[i] = !0 : (ld[i] = !0, !1);
  }
  function $a(i, s, c) {
    if (mm(s))
      if (c === null) i.removeAttribute(s);
      else {
        switch (typeof c) {
          case "undefined":
          case "function":
          case "symbol":
            i.removeAttribute(s);
            return;
          case "boolean":
            var h = s.toLowerCase().slice(0, 5);
            if (h !== "data-" && h !== "aria-") {
              i.removeAttribute(s);
              return;
            }
        }
        i.setAttribute(s, "" + c);
      }
  }
  function Ya(i, s, c) {
    if (c === null) i.removeAttribute(s);
    else {
      switch (typeof c) {
        case "undefined":
        case "function":
        case "symbol":
        case "boolean":
          i.removeAttribute(s);
          return;
      }
      i.setAttribute(s, "" + c);
    }
  }
  function xr(i, s, c, h) {
    if (h === null) i.removeAttribute(c);
    else {
      switch (typeof h) {
        case "undefined":
        case "function":
        case "symbol":
        case "boolean":
          i.removeAttribute(c);
          return;
      }
      i.setAttributeNS(s, c, "" + h);
    }
  }
  var Ds, Ts;
  function ii(i) {
    if (Ds === void 0)
      try {
        throw Error();
      } catch (c) {
        var s = c.stack.trim().match(/\n( *(at )?)/);
        Ds = s && s[1] || "", Ts = -1 < c.stack.indexOf(`
    at`) ? " (<anonymous>)" : -1 < c.stack.indexOf("@") ? "@unknown:0:0" : "";
      }
    return `
` + Ds + i + Ts;
  }
  var zs = !1;
  function Ps(i, s) {
    if (!i || zs) return "";
    zs = !0;
    var c = Error.prepareStackTrace;
    Error.prepareStackTrace = void 0;
    try {
      var h = {
        DetermineComponentFrameRoot: function() {
          try {
            if (s) {
              var de = function() {
                throw Error();
              };
              if (Object.defineProperty(de.prototype, "props", {
                set: function() {
                  throw Error();
                }
              }), typeof Reflect == "object" && Reflect.construct) {
                try {
                  Reflect.construct(de, []);
                } catch (re) {
                  var ne = re;
                }
                Reflect.construct(i, [], de);
              } else {
                try {
                  de.call();
                } catch (re) {
                  ne = re;
                }
                i.call(de.prototype);
              }
            } else {
              try {
                throw Error();
              } catch (re) {
                ne = re;
              }
              (de = i()) && typeof de.catch == "function" && de.catch(function() {
              });
            }
          } catch (re) {
            if (re && ne && typeof re.stack == "string")
              return [re.stack, ne.stack];
          }
          return [null, null];
        }
      };
      h.DetermineComponentFrameRoot.displayName = "DetermineComponentFrameRoot";
      var b = Object.getOwnPropertyDescriptor(
        h.DetermineComponentFrameRoot,
        "name"
      );
      b && b.configurable && Object.defineProperty(
        h.DetermineComponentFrameRoot,
        "name",
        { value: "DetermineComponentFrameRoot" }
      );
      var S = h.DetermineComponentFrameRoot(), j = S[0], I = S[1];
      if (j && I) {
        var Z = j.split(`
`), ee = I.split(`
`);
        for (b = h = 0; h < Z.length && !Z[h].includes("DetermineComponentFrameRoot"); )
          h++;
        for (; b < ee.length && !ee[b].includes(
          "DetermineComponentFrameRoot"
        ); )
          b++;
        if (h === Z.length || b === ee.length)
          for (h = Z.length - 1, b = ee.length - 1; 1 <= h && 0 <= b && Z[h] !== ee[b]; )
            b--;
        for (; 1 <= h && 0 <= b; h--, b--)
          if (Z[h] !== ee[b]) {
            if (h !== 1 || b !== 1)
              do
                if (h--, b--, 0 > b || Z[h] !== ee[b]) {
                  var ue = `
` + Z[h].replace(" at new ", " at ");
                  return i.displayName && ue.includes("<anonymous>") && (ue = ue.replace("<anonymous>", i.displayName)), ue;
                }
              while (1 <= h && 0 <= b);
            break;
          }
      }
    } finally {
      zs = !1, Error.prepareStackTrace = c;
    }
    return (c = i ? i.displayName || i.name : "") ? ii(c) : "";
  }
  function gm(i) {
    switch (i.tag) {
      case 26:
      case 27:
      case 5:
        return ii(i.type);
      case 16:
        return ii("Lazy");
      case 13:
        return ii("Suspense");
      case 19:
        return ii("SuspenseList");
      case 0:
      case 15:
        return Ps(i.type, !1);
      case 11:
        return Ps(i.type.render, !1);
      case 1:
        return Ps(i.type, !0);
      case 31:
        return ii("Activity");
      default:
        return "";
    }
  }
  function ud(i) {
    try {
      var s = "";
      do
        s += gm(i), i = i.return;
      while (i);
      return s;
    } catch (c) {
      return `
Error generating stack: ` + c.message + `
` + c.stack;
    }
  }
  function On(i) {
    switch (typeof i) {
      case "bigint":
      case "boolean":
      case "number":
      case "string":
      case "undefined":
        return i;
      case "object":
        return i;
      default:
        return "";
    }
  }
  function cd(i) {
    var s = i.type;
    return (i = i.nodeName) && i.toLowerCase() === "input" && (s === "checkbox" || s === "radio");
  }
  function Ls(i) {
    var s = cd(i) ? "checked" : "value", c = Object.getOwnPropertyDescriptor(
      i.constructor.prototype,
      s
    ), h = "" + i[s];
    if (!i.hasOwnProperty(s) && typeof c < "u" && typeof c.get == "function" && typeof c.set == "function") {
      var b = c.get, S = c.set;
      return Object.defineProperty(i, s, {
        configurable: !0,
        get: function() {
          return b.call(this);
        },
        set: function(j) {
          h = "" + j, S.call(this, j);
        }
      }), Object.defineProperty(i, s, {
        enumerable: c.enumerable
      }), {
        getValue: function() {
          return h;
        },
        setValue: function(j) {
          h = "" + j;
        },
        stopTracking: function() {
          i._valueTracker = null, delete i[s];
        }
      };
    }
  }
  function qa(i) {
    i._valueTracker || (i._valueTracker = Ls(i));
  }
  function dd(i) {
    if (!i) return !1;
    var s = i._valueTracker;
    if (!s) return !0;
    var c = s.getValue(), h = "";
    return i && (h = cd(i) ? i.checked ? "true" : "false" : i.value), i = h, i !== c ? (s.setValue(i), !0) : !1;
  }
  function ai(i) {
    if (i = i || (typeof document < "u" ? document : void 0), typeof i > "u") return null;
    try {
      return i.activeElement || i.body;
    } catch {
      return i.body;
    }
  }
  var ym = /[\n"\\]/g;
  function Nn(i) {
    return i.replace(
      ym,
      function(s) {
        return "\\" + s.charCodeAt(0).toString(16) + " ";
      }
    );
  }
  function Xa(i, s, c, h, b, S, j, I) {
    i.name = "", j != null && typeof j != "function" && typeof j != "symbol" && typeof j != "boolean" ? i.type = j : i.removeAttribute("type"), s != null ? j === "number" ? (s === 0 && i.value === "" || i.value != s) && (i.value = "" + On(s)) : i.value !== "" + On(s) && (i.value = "" + On(s)) : j !== "submit" && j !== "reset" || i.removeAttribute("value"), s != null ? vm(i, j, On(s)) : c != null ? vm(i, j, On(c)) : h != null && i.removeAttribute("value"), b == null && S != null && (i.defaultChecked = !!S), b != null && (i.checked = b && typeof b != "function" && typeof b != "symbol"), I != null && typeof I != "function" && typeof I != "symbol" && typeof I != "boolean" ? i.name = "" + On(I) : i.removeAttribute("name");
  }
  function rS(i, s, c, h, b, S, j, I) {
    if (S != null && typeof S != "function" && typeof S != "symbol" && typeof S != "boolean" && (i.type = S), s != null || c != null) {
      if (!(S !== "submit" && S !== "reset" || s != null))
        return;
      c = c != null ? "" + On(c) : "", s = s != null ? "" + On(s) : c, I || s === i.value || (i.value = s), i.defaultValue = s;
    }
    h = h ?? b, h = typeof h != "function" && typeof h != "symbol" && !!h, i.checked = I ? i.checked : !!h, i.defaultChecked = !!h, j != null && typeof j != "function" && typeof j != "symbol" && typeof j != "boolean" && (i.name = j);
  }
  function vm(i, s, c) {
    s === "number" && ai(i.ownerDocument) === i || i.defaultValue === "" + c || (i.defaultValue = "" + c);
  }
  function Ga(i, s, c, h) {
    if (i = i.options, s) {
      s = {};
      for (var b = 0; b < c.length; b++)
        s["$" + c[b]] = !0;
      for (c = 0; c < i.length; c++)
        b = s.hasOwnProperty("$" + i[c].value), i[c].selected !== b && (i[c].selected = b), b && h && (i[c].defaultSelected = !0);
    } else {
      for (c = "" + On(c), s = null, b = 0; b < i.length; b++) {
        if (i[b].value === c) {
          i[b].selected = !0, h && (i[b].defaultSelected = !0);
          return;
        }
        s !== null || i[b].disabled || (s = i[b]);
      }
      s !== null && (s.selected = !0);
    }
  }
  function oS(i, s, c) {
    if (s != null && (s = "" + On(s), s !== i.value && (i.value = s), c == null)) {
      i.defaultValue !== s && (i.defaultValue = s);
      return;
    }
    i.defaultValue = c != null ? "" + On(c) : "";
  }
  function iS(i, s, c, h) {
    if (s == null) {
      if (h != null) {
        if (c != null) throw Error(r(92));
        if ($(h)) {
          if (1 < h.length) throw Error(r(93));
          h = h[0];
        }
        c = h;
      }
      c == null && (c = ""), s = c;
    }
    c = On(s), i.defaultValue = c, h = i.textContent, h === c && h !== "" && h !== null && (i.value = h);
  }
  function Za(i, s) {
    if (s) {
      var c = i.firstChild;
      if (c && c === i.lastChild && c.nodeType === 3) {
        c.nodeValue = s;
        return;
      }
    }
    i.textContent = s;
  }
  var ID = new Set(
    "animationIterationCount aspectRatio borderImageOutset borderImageSlice borderImageWidth boxFlex boxFlexGroup boxOrdinalGroup columnCount columns flex flexGrow flexPositive flexShrink flexNegative flexOrder gridArea gridRow gridRowEnd gridRowSpan gridRowStart gridColumn gridColumnEnd gridColumnSpan gridColumnStart fontWeight lineClamp lineHeight opacity order orphans scale tabSize widows zIndex zoom fillOpacity floodOpacity stopOpacity strokeDasharray strokeDashoffset strokeMiterlimit strokeOpacity strokeWidth MozAnimationIterationCount MozBoxFlex MozBoxFlexGroup MozLineClamp msAnimationIterationCount msFlex msZoom msFlexGrow msFlexNegative msFlexOrder msFlexPositive msFlexShrink msGridColumn msGridColumnSpan msGridRow msGridRowSpan WebkitAnimationIterationCount WebkitBoxFlex WebKitBoxFlexGroup WebkitBoxOrdinalGroup WebkitColumnCount WebkitColumns WebkitFlex WebkitFlexGrow WebkitFlexPositive WebkitFlexShrink WebkitLineClamp".split(
      " "
    )
  );
  function aS(i, s, c) {
    var h = s.indexOf("--") === 0;
    c == null || typeof c == "boolean" || c === "" ? h ? i.setProperty(s, "") : s === "float" ? i.cssFloat = "" : i[s] = "" : h ? i.setProperty(s, c) : typeof c != "number" || c === 0 || ID.has(s) ? s === "float" ? i.cssFloat = c : i[s] = ("" + c).trim() : i[s] = c + "px";
  }
  function lS(i, s, c) {
    if (s != null && typeof s != "object")
      throw Error(r(62));
    if (i = i.style, c != null) {
      for (var h in c)
        !c.hasOwnProperty(h) || s != null && s.hasOwnProperty(h) || (h.indexOf("--") === 0 ? i.setProperty(h, "") : h === "float" ? i.cssFloat = "" : i[h] = "");
      for (var b in s)
        h = s[b], s.hasOwnProperty(b) && c[b] !== h && aS(i, b, h);
    } else
      for (var S in s)
        s.hasOwnProperty(S) && aS(i, S, s[S]);
  }
  function bm(i) {
    if (i.indexOf("-") === -1) return !1;
    switch (i) {
      case "annotation-xml":
      case "color-profile":
      case "font-face":
      case "font-face-src":
      case "font-face-uri":
      case "font-face-format":
      case "font-face-name":
      case "missing-glyph":
        return !1;
      default:
        return !0;
    }
  }
  var BD = /* @__PURE__ */ new Map([
    ["acceptCharset", "accept-charset"],
    ["htmlFor", "for"],
    ["httpEquiv", "http-equiv"],
    ["crossOrigin", "crossorigin"],
    ["accentHeight", "accent-height"],
    ["alignmentBaseline", "alignment-baseline"],
    ["arabicForm", "arabic-form"],
    ["baselineShift", "baseline-shift"],
    ["capHeight", "cap-height"],
    ["clipPath", "clip-path"],
    ["clipRule", "clip-rule"],
    ["colorInterpolation", "color-interpolation"],
    ["colorInterpolationFilters", "color-interpolation-filters"],
    ["colorProfile", "color-profile"],
    ["colorRendering", "color-rendering"],
    ["dominantBaseline", "dominant-baseline"],
    ["enableBackground", "enable-background"],
    ["fillOpacity", "fill-opacity"],
    ["fillRule", "fill-rule"],
    ["floodColor", "flood-color"],
    ["floodOpacity", "flood-opacity"],
    ["fontFamily", "font-family"],
    ["fontSize", "font-size"],
    ["fontSizeAdjust", "font-size-adjust"],
    ["fontStretch", "font-stretch"],
    ["fontStyle", "font-style"],
    ["fontVariant", "font-variant"],
    ["fontWeight", "font-weight"],
    ["glyphName", "glyph-name"],
    ["glyphOrientationHorizontal", "glyph-orientation-horizontal"],
    ["glyphOrientationVertical", "glyph-orientation-vertical"],
    ["horizAdvX", "horiz-adv-x"],
    ["horizOriginX", "horiz-origin-x"],
    ["imageRendering", "image-rendering"],
    ["letterSpacing", "letter-spacing"],
    ["lightingColor", "lighting-color"],
    ["markerEnd", "marker-end"],
    ["markerMid", "marker-mid"],
    ["markerStart", "marker-start"],
    ["overlinePosition", "overline-position"],
    ["overlineThickness", "overline-thickness"],
    ["paintOrder", "paint-order"],
    ["panose-1", "panose-1"],
    ["pointerEvents", "pointer-events"],
    ["renderingIntent", "rendering-intent"],
    ["shapeRendering", "shape-rendering"],
    ["stopColor", "stop-color"],
    ["stopOpacity", "stop-opacity"],
    ["strikethroughPosition", "strikethrough-position"],
    ["strikethroughThickness", "strikethrough-thickness"],
    ["strokeDasharray", "stroke-dasharray"],
    ["strokeDashoffset", "stroke-dashoffset"],
    ["strokeLinecap", "stroke-linecap"],
    ["strokeLinejoin", "stroke-linejoin"],
    ["strokeMiterlimit", "stroke-miterlimit"],
    ["strokeOpacity", "stroke-opacity"],
    ["strokeWidth", "stroke-width"],
    ["textAnchor", "text-anchor"],
    ["textDecoration", "text-decoration"],
    ["textRendering", "text-rendering"],
    ["transformOrigin", "transform-origin"],
    ["underlinePosition", "underline-position"],
    ["underlineThickness", "underline-thickness"],
    ["unicodeBidi", "unicode-bidi"],
    ["unicodeRange", "unicode-range"],
    ["unitsPerEm", "units-per-em"],
    ["vAlphabetic", "v-alphabetic"],
    ["vHanging", "v-hanging"],
    ["vIdeographic", "v-ideographic"],
    ["vMathematical", "v-mathematical"],
    ["vectorEffect", "vector-effect"],
    ["vertAdvY", "vert-adv-y"],
    ["vertOriginX", "vert-origin-x"],
    ["vertOriginY", "vert-origin-y"],
    ["wordSpacing", "word-spacing"],
    ["writingMode", "writing-mode"],
    ["xmlnsXlink", "xmlns:xlink"],
    ["xHeight", "x-height"]
  ]), VD = /^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*:/i;
  function fd(i) {
    return VD.test("" + i) ? "javascript:throw new Error('React has blocked a javascript: URL as a security precaution.')" : i;
  }
  var wm = null;
  function xm(i) {
    return i = i.target || i.srcElement || window, i.correspondingUseElement && (i = i.correspondingUseElement), i.nodeType === 3 ? i.parentNode : i;
  }
  var Wa = null, Ka = null;
  function sS(i) {
    var s = yo(i);
    if (s && (i = s.stateNode)) {
      var c = i[un] || null;
      e: switch (i = s.stateNode, s.type) {
        case "input":
          if (Xa(
            i,
            c.value,
            c.defaultValue,
            c.defaultValue,
            c.checked,
            c.defaultChecked,
            c.type,
            c.name
          ), s = c.name, c.type === "radio" && s != null) {
            for (c = i; c.parentNode; ) c = c.parentNode;
            for (c = c.querySelectorAll(
              'input[name="' + Nn(
                "" + s
              ) + '"][type="radio"]'
            ), s = 0; s < c.length; s++) {
              var h = c[s];
              if (h !== i && h.form === i.form) {
                var b = h[un] || null;
                if (!b) throw Error(r(90));
                Xa(
                  h,
                  b.value,
                  b.defaultValue,
                  b.defaultValue,
                  b.checked,
                  b.defaultChecked,
                  b.type,
                  b.name
                );
              }
            }
            for (s = 0; s < c.length; s++)
              h = c[s], h.form === i.form && dd(h);
          }
          break e;
        case "textarea":
          oS(i, c.value, c.defaultValue);
          break e;
        case "select":
          s = c.value, s != null && Ga(i, !!c.multiple, s, !1);
      }
    }
  }
  var Sm = !1;
  function uS(i, s, c) {
    if (Sm) return i(s, c);
    Sm = !0;
    try {
      var h = i(s);
      return h;
    } finally {
      if (Sm = !1, (Wa !== null || Ka !== null) && (Kd(), Wa && (s = Wa, i = Ka, Ka = Wa = null, sS(s), i)))
        for (s = 0; s < i.length; s++) sS(i[s]);
    }
  }
  function Is(i, s) {
    var c = i.stateNode;
    if (c === null) return null;
    var h = c[un] || null;
    if (h === null) return null;
    c = h[s];
    e: switch (s) {
      case "onClick":
      case "onClickCapture":
      case "onDoubleClick":
      case "onDoubleClickCapture":
      case "onMouseDown":
      case "onMouseDownCapture":
      case "onMouseMove":
      case "onMouseMoveCapture":
      case "onMouseUp":
      case "onMouseUpCapture":
      case "onMouseEnter":
        (h = !h.disabled) || (i = i.type, h = !(i === "button" || i === "input" || i === "select" || i === "textarea")), i = !h;
        break e;
      default:
        i = !1;
    }
    if (i) return null;
    if (c && typeof c != "function")
      throw Error(
        r(231, s, typeof c)
      );
    return c;
  }
  var bo = !(typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u"), km = !1;
  if (bo)
    try {
      var Bs = {};
      Object.defineProperty(Bs, "passive", {
        get: function() {
          km = !0;
        }
      }), window.addEventListener("test", Bs, Bs), window.removeEventListener("test", Bs, Bs);
    } catch {
      km = !1;
    }
  var li = null, _m = null, pd = null;
  function cS() {
    if (pd) return pd;
    var i, s = _m, c = s.length, h, b = "value" in li ? li.value : li.textContent, S = b.length;
    for (i = 0; i < c && s[i] === b[i]; i++) ;
    var j = c - i;
    for (h = 1; h <= j && s[c - h] === b[S - h]; h++) ;
    return pd = b.slice(i, 1 < h ? 1 - h : void 0);
  }
  function hd(i) {
    var s = i.keyCode;
    return "charCode" in i ? (i = i.charCode, i === 0 && s === 13 && (i = 13)) : i = s, i === 10 && (i = 13), 32 <= i || i === 13 ? i : 0;
  }
  function md() {
    return !0;
  }
  function dS() {
    return !1;
  }
  function Mn(i) {
    function s(c, h, b, S, j) {
      this._reactName = c, this._targetInst = b, this.type = h, this.nativeEvent = S, this.target = j, this.currentTarget = null;
      for (var I in i)
        i.hasOwnProperty(I) && (c = i[I], this[I] = c ? c(S) : S[I]);
      return this.isDefaultPrevented = (S.defaultPrevented != null ? S.defaultPrevented : S.returnValue === !1) ? md : dS, this.isPropagationStopped = dS, this;
    }
    return p(s.prototype, {
      preventDefault: function() {
        this.defaultPrevented = !0;
        var c = this.nativeEvent;
        c && (c.preventDefault ? c.preventDefault() : typeof c.returnValue != "unknown" && (c.returnValue = !1), this.isDefaultPrevented = md);
      },
      stopPropagation: function() {
        var c = this.nativeEvent;
        c && (c.stopPropagation ? c.stopPropagation() : typeof c.cancelBubble != "unknown" && (c.cancelBubble = !0), this.isPropagationStopped = md);
      },
      persist: function() {
      },
      isPersistent: md
    }), s;
  }
  var ta = {
    eventPhase: 0,
    bubbles: 0,
    cancelable: 0,
    timeStamp: function(i) {
      return i.timeStamp || Date.now();
    },
    defaultPrevented: 0,
    isTrusted: 0
  }, gd = Mn(ta), Vs = p({}, ta, { view: 0, detail: 0 }), HD = Mn(Vs), Em, Cm, Hs, yd = p({}, Vs, {
    screenX: 0,
    screenY: 0,
    clientX: 0,
    clientY: 0,
    pageX: 0,
    pageY: 0,
    ctrlKey: 0,
    shiftKey: 0,
    altKey: 0,
    metaKey: 0,
    getModifierState: Nm,
    button: 0,
    buttons: 0,
    relatedTarget: function(i) {
      return i.relatedTarget === void 0 ? i.fromElement === i.srcElement ? i.toElement : i.fromElement : i.relatedTarget;
    },
    movementX: function(i) {
      return "movementX" in i ? i.movementX : (i !== Hs && (Hs && i.type === "mousemove" ? (Em = i.screenX - Hs.screenX, Cm = i.screenY - Hs.screenY) : Cm = Em = 0, Hs = i), Em);
    },
    movementY: function(i) {
      return "movementY" in i ? i.movementY : Cm;
    }
  }), fS = Mn(yd), UD = p({}, yd, { dataTransfer: 0 }), FD = Mn(UD), $D = p({}, Vs, { relatedTarget: 0 }), Om = Mn($D), YD = p({}, ta, {
    animationName: 0,
    elapsedTime: 0,
    pseudoElement: 0
  }), qD = Mn(YD), XD = p({}, ta, {
    clipboardData: function(i) {
      return "clipboardData" in i ? i.clipboardData : window.clipboardData;
    }
  }), GD = Mn(XD), ZD = p({}, ta, { data: 0 }), pS = Mn(ZD), WD = {
    Esc: "Escape",
    Spacebar: " ",
    Left: "ArrowLeft",
    Up: "ArrowUp",
    Right: "ArrowRight",
    Down: "ArrowDown",
    Del: "Delete",
    Win: "OS",
    Menu: "ContextMenu",
    Apps: "ContextMenu",
    Scroll: "ScrollLock",
    MozPrintableKey: "Unidentified"
  }, KD = {
    8: "Backspace",
    9: "Tab",
    12: "Clear",
    13: "Enter",
    16: "Shift",
    17: "Control",
    18: "Alt",
    19: "Pause",
    20: "CapsLock",
    27: "Escape",
    32: " ",
    33: "PageUp",
    34: "PageDown",
    35: "End",
    36: "Home",
    37: "ArrowLeft",
    38: "ArrowUp",
    39: "ArrowRight",
    40: "ArrowDown",
    45: "Insert",
    46: "Delete",
    112: "F1",
    113: "F2",
    114: "F3",
    115: "F4",
    116: "F5",
    117: "F6",
    118: "F7",
    119: "F8",
    120: "F9",
    121: "F10",
    122: "F11",
    123: "F12",
    144: "NumLock",
    145: "ScrollLock",
    224: "Meta"
  }, QD = {
    Alt: "altKey",
    Control: "ctrlKey",
    Meta: "metaKey",
    Shift: "shiftKey"
  };
  function JD(i) {
    var s = this.nativeEvent;
    return s.getModifierState ? s.getModifierState(i) : (i = QD[i]) ? !!s[i] : !1;
  }
  function Nm() {
    return JD;
  }
  var eT = p({}, Vs, {
    key: function(i) {
      if (i.key) {
        var s = WD[i.key] || i.key;
        if (s !== "Unidentified") return s;
      }
      return i.type === "keypress" ? (i = hd(i), i === 13 ? "Enter" : String.fromCharCode(i)) : i.type === "keydown" || i.type === "keyup" ? KD[i.keyCode] || "Unidentified" : "";
    },
    code: 0,
    location: 0,
    ctrlKey: 0,
    shiftKey: 0,
    altKey: 0,
    metaKey: 0,
    repeat: 0,
    locale: 0,
    getModifierState: Nm,
    charCode: function(i) {
      return i.type === "keypress" ? hd(i) : 0;
    },
    keyCode: function(i) {
      return i.type === "keydown" || i.type === "keyup" ? i.keyCode : 0;
    },
    which: function(i) {
      return i.type === "keypress" ? hd(i) : i.type === "keydown" || i.type === "keyup" ? i.keyCode : 0;
    }
  }), tT = Mn(eT), nT = p({}, yd, {
    pointerId: 0,
    width: 0,
    height: 0,
    pressure: 0,
    tangentialPressure: 0,
    tiltX: 0,
    tiltY: 0,
    twist: 0,
    pointerType: 0,
    isPrimary: 0
  }), hS = Mn(nT), rT = p({}, Vs, {
    touches: 0,
    targetTouches: 0,
    changedTouches: 0,
    altKey: 0,
    metaKey: 0,
    ctrlKey: 0,
    shiftKey: 0,
    getModifierState: Nm
  }), oT = Mn(rT), iT = p({}, ta, {
    propertyName: 0,
    elapsedTime: 0,
    pseudoElement: 0
  }), aT = Mn(iT), lT = p({}, yd, {
    deltaX: function(i) {
      return "deltaX" in i ? i.deltaX : "wheelDeltaX" in i ? -i.wheelDeltaX : 0;
    },
    deltaY: function(i) {
      return "deltaY" in i ? i.deltaY : "wheelDeltaY" in i ? -i.wheelDeltaY : "wheelDelta" in i ? -i.wheelDelta : 0;
    },
    deltaZ: 0,
    deltaMode: 0
  }), sT = Mn(lT), uT = p({}, ta, {
    newState: 0,
    oldState: 0
  }), cT = Mn(uT), dT = [9, 13, 27, 32], Mm = bo && "CompositionEvent" in window, Us = null;
  bo && "documentMode" in document && (Us = document.documentMode);
  var fT = bo && "TextEvent" in window && !Us, mS = bo && (!Mm || Us && 8 < Us && 11 >= Us), gS = " ", yS = !1;
  function vS(i, s) {
    switch (i) {
      case "keyup":
        return dT.indexOf(s.keyCode) !== -1;
      case "keydown":
        return s.keyCode !== 229;
      case "keypress":
      case "mousedown":
      case "focusout":
        return !0;
      default:
        return !1;
    }
  }
  function bS(i) {
    return i = i.detail, typeof i == "object" && "data" in i ? i.data : null;
  }
  var Qa = !1;
  function pT(i, s) {
    switch (i) {
      case "compositionend":
        return bS(s);
      case "keypress":
        return s.which !== 32 ? null : (yS = !0, gS);
      case "textInput":
        return i = s.data, i === gS && yS ? null : i;
      default:
        return null;
    }
  }
  function hT(i, s) {
    if (Qa)
      return i === "compositionend" || !Mm && vS(i, s) ? (i = cS(), pd = _m = li = null, Qa = !1, i) : null;
    switch (i) {
      case "paste":
        return null;
      case "keypress":
        if (!(s.ctrlKey || s.altKey || s.metaKey) || s.ctrlKey && s.altKey) {
          if (s.char && 1 < s.char.length)
            return s.char;
          if (s.which) return String.fromCharCode(s.which);
        }
        return null;
      case "compositionend":
        return mS && s.locale !== "ko" ? null : s.data;
      default:
        return null;
    }
  }
  var mT = {
    color: !0,
    date: !0,
    datetime: !0,
    "datetime-local": !0,
    email: !0,
    month: !0,
    number: !0,
    password: !0,
    range: !0,
    search: !0,
    tel: !0,
    text: !0,
    time: !0,
    url: !0,
    week: !0
  };
  function wS(i) {
    var s = i && i.nodeName && i.nodeName.toLowerCase();
    return s === "input" ? !!mT[i.type] : s === "textarea";
  }
  function xS(i, s, c, h) {
    Wa ? Ka ? Ka.push(h) : Ka = [h] : Wa = h, s = rf(s, "onChange"), 0 < s.length && (c = new gd(
      "onChange",
      "change",
      null,
      c,
      h
    ), i.push({ event: c, listeners: s }));
  }
  var Fs = null, $s = null;
  function gT(i) {
    t_(i, 0);
  }
  function vd(i) {
    var s = ea(i);
    if (dd(s)) return i;
  }
  function SS(i, s) {
    if (i === "change") return s;
  }
  var kS = !1;
  if (bo) {
    var Am;
    if (bo) {
      var Rm = "oninput" in document;
      if (!Rm) {
        var _S = document.createElement("div");
        _S.setAttribute("oninput", "return;"), Rm = typeof _S.oninput == "function";
      }
      Am = Rm;
    } else Am = !1;
    kS = Am && (!document.documentMode || 9 < document.documentMode);
  }
  function ES() {
    Fs && (Fs.detachEvent("onpropertychange", CS), $s = Fs = null);
  }
  function CS(i) {
    if (i.propertyName === "value" && vd($s)) {
      var s = [];
      xS(
        s,
        $s,
        i,
        xm(i)
      ), uS(gT, s);
    }
  }
  function yT(i, s, c) {
    i === "focusin" ? (ES(), Fs = s, $s = c, Fs.attachEvent("onpropertychange", CS)) : i === "focusout" && ES();
  }
  function vT(i) {
    if (i === "selectionchange" || i === "keyup" || i === "keydown")
      return vd($s);
  }
  function bT(i, s) {
    if (i === "click") return vd(s);
  }
  function wT(i, s) {
    if (i === "input" || i === "change")
      return vd(s);
  }
  function xT(i, s) {
    return i === s && (i !== 0 || 1 / i === 1 / s) || i !== i && s !== s;
  }
  var Hn = typeof Object.is == "function" ? Object.is : xT;
  function Ys(i, s) {
    if (Hn(i, s)) return !0;
    if (typeof i != "object" || i === null || typeof s != "object" || s === null)
      return !1;
    var c = Object.keys(i), h = Object.keys(s);
    if (c.length !== h.length) return !1;
    for (h = 0; h < c.length; h++) {
      var b = c[h];
      if (!xe.call(s, b) || !Hn(i[b], s[b]))
        return !1;
    }
    return !0;
  }
  function OS(i) {
    for (; i && i.firstChild; ) i = i.firstChild;
    return i;
  }
  function NS(i, s) {
    var c = OS(i);
    i = 0;
    for (var h; c; ) {
      if (c.nodeType === 3) {
        if (h = i + c.textContent.length, i <= s && h >= s)
          return { node: c, offset: s - i };
        i = h;
      }
      e: {
        for (; c; ) {
          if (c.nextSibling) {
            c = c.nextSibling;
            break e;
          }
          c = c.parentNode;
        }
        c = void 0;
      }
      c = OS(c);
    }
  }
  function MS(i, s) {
    return i && s ? i === s ? !0 : i && i.nodeType === 3 ? !1 : s && s.nodeType === 3 ? MS(i, s.parentNode) : "contains" in i ? i.contains(s) : i.compareDocumentPosition ? !!(i.compareDocumentPosition(s) & 16) : !1 : !1;
  }
  function AS(i) {
    i = i != null && i.ownerDocument != null && i.ownerDocument.defaultView != null ? i.ownerDocument.defaultView : window;
    for (var s = ai(i.document); s instanceof i.HTMLIFrameElement; ) {
      try {
        var c = typeof s.contentWindow.location.href == "string";
      } catch {
        c = !1;
      }
      if (c) i = s.contentWindow;
      else break;
      s = ai(i.document);
    }
    return s;
  }
  function jm(i) {
    var s = i && i.nodeName && i.nodeName.toLowerCase();
    return s && (s === "input" && (i.type === "text" || i.type === "search" || i.type === "tel" || i.type === "url" || i.type === "password") || s === "textarea" || i.contentEditable === "true");
  }
  var ST = bo && "documentMode" in document && 11 >= document.documentMode, Ja = null, Dm = null, qs = null, Tm = !1;
  function RS(i, s, c) {
    var h = c.window === c ? c.document : c.nodeType === 9 ? c : c.ownerDocument;
    Tm || Ja == null || Ja !== ai(h) || (h = Ja, "selectionStart" in h && jm(h) ? h = { start: h.selectionStart, end: h.selectionEnd } : (h = (h.ownerDocument && h.ownerDocument.defaultView || window).getSelection(), h = {
      anchorNode: h.anchorNode,
      anchorOffset: h.anchorOffset,
      focusNode: h.focusNode,
      focusOffset: h.focusOffset
    }), qs && Ys(qs, h) || (qs = h, h = rf(Dm, "onSelect"), 0 < h.length && (s = new gd(
      "onSelect",
      "select",
      null,
      s,
      c
    ), i.push({ event: s, listeners: h }), s.target = Ja)));
  }
  function na(i, s) {
    var c = {};
    return c[i.toLowerCase()] = s.toLowerCase(), c["Webkit" + i] = "webkit" + s, c["Moz" + i] = "moz" + s, c;
  }
  var el = {
    animationend: na("Animation", "AnimationEnd"),
    animationiteration: na("Animation", "AnimationIteration"),
    animationstart: na("Animation", "AnimationStart"),
    transitionrun: na("Transition", "TransitionRun"),
    transitionstart: na("Transition", "TransitionStart"),
    transitioncancel: na("Transition", "TransitionCancel"),
    transitionend: na("Transition", "TransitionEnd")
  }, zm = {}, jS = {};
  bo && (jS = document.createElement("div").style, "AnimationEvent" in window || (delete el.animationend.animation, delete el.animationiteration.animation, delete el.animationstart.animation), "TransitionEvent" in window || delete el.transitionend.transition);
  function ra(i) {
    if (zm[i]) return zm[i];
    if (!el[i]) return i;
    var s = el[i], c;
    for (c in s)
      if (s.hasOwnProperty(c) && c in jS)
        return zm[i] = s[c];
    return i;
  }
  var DS = ra("animationend"), TS = ra("animationiteration"), zS = ra("animationstart"), kT = ra("transitionrun"), _T = ra("transitionstart"), ET = ra("transitioncancel"), PS = ra("transitionend"), LS = /* @__PURE__ */ new Map(), Pm = "abort auxClick beforeToggle cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(
    " "
  );
  Pm.push("scrollEnd");
  function Sr(i, s) {
    LS.set(i, s), vo(s, [i]);
  }
  var IS = /* @__PURE__ */ new WeakMap();
  function ar(i, s) {
    if (typeof i == "object" && i !== null) {
      var c = IS.get(i);
      return c !== void 0 ? c : (s = {
        value: i,
        source: s,
        stack: ud(s)
      }, IS.set(i, s), s);
    }
    return {
      value: i,
      source: s,
      stack: ud(s)
    };
  }
  var lr = [], tl = 0, Lm = 0;
  function bd() {
    for (var i = tl, s = Lm = tl = 0; s < i; ) {
      var c = lr[s];
      lr[s++] = null;
      var h = lr[s];
      lr[s++] = null;
      var b = lr[s];
      lr[s++] = null;
      var S = lr[s];
      if (lr[s++] = null, h !== null && b !== null) {
        var j = h.pending;
        j === null ? b.next = b : (b.next = j.next, j.next = b), h.pending = b;
      }
      S !== 0 && BS(c, b, S);
    }
  }
  function wd(i, s, c, h) {
    lr[tl++] = i, lr[tl++] = s, lr[tl++] = c, lr[tl++] = h, Lm |= h, i.lanes |= h, i = i.alternate, i !== null && (i.lanes |= h);
  }
  function Im(i, s, c, h) {
    return wd(i, s, c, h), xd(i);
  }
  function nl(i, s) {
    return wd(i, null, null, s), xd(i);
  }
  function BS(i, s, c) {
    i.lanes |= c;
    var h = i.alternate;
    h !== null && (h.lanes |= c);
    for (var b = !1, S = i.return; S !== null; )
      S.childLanes |= c, h = S.alternate, h !== null && (h.childLanes |= c), S.tag === 22 && (i = S.stateNode, i === null || i._visibility & 1 || (b = !0)), i = S, S = S.return;
    return i.tag === 3 ? (S = i.stateNode, b && s !== null && (b = 31 - Le(c), i = S.hiddenUpdates, h = i[b], h === null ? i[b] = [s] : h.push(s), s.lane = c | 536870912), S) : null;
  }
  function xd(i) {
    if (50 < yu)
      throw yu = 0, $g = null, Error(r(185));
    for (var s = i.return; s !== null; )
      i = s, s = i.return;
    return i.tag === 3 ? i.stateNode : null;
  }
  var rl = {};
  function CT(i, s, c, h) {
    this.tag = i, this.key = c, this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null, this.index = 0, this.refCleanup = this.ref = null, this.pendingProps = s, this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null, this.mode = h, this.subtreeFlags = this.flags = 0, this.deletions = null, this.childLanes = this.lanes = 0, this.alternate = null;
  }
  function Un(i, s, c, h) {
    return new CT(i, s, c, h);
  }
  function Bm(i) {
    return i = i.prototype, !(!i || !i.isReactComponent);
  }
  function wo(i, s) {
    var c = i.alternate;
    return c === null ? (c = Un(
      i.tag,
      s,
      i.key,
      i.mode
    ), c.elementType = i.elementType, c.type = i.type, c.stateNode = i.stateNode, c.alternate = i, i.alternate = c) : (c.pendingProps = s, c.type = i.type, c.flags = 0, c.subtreeFlags = 0, c.deletions = null), c.flags = i.flags & 65011712, c.childLanes = i.childLanes, c.lanes = i.lanes, c.child = i.child, c.memoizedProps = i.memoizedProps, c.memoizedState = i.memoizedState, c.updateQueue = i.updateQueue, s = i.dependencies, c.dependencies = s === null ? null : { lanes: s.lanes, firstContext: s.firstContext }, c.sibling = i.sibling, c.index = i.index, c.ref = i.ref, c.refCleanup = i.refCleanup, c;
  }
  function VS(i, s) {
    i.flags &= 65011714;
    var c = i.alternate;
    return c === null ? (i.childLanes = 0, i.lanes = s, i.child = null, i.subtreeFlags = 0, i.memoizedProps = null, i.memoizedState = null, i.updateQueue = null, i.dependencies = null, i.stateNode = null) : (i.childLanes = c.childLanes, i.lanes = c.lanes, i.child = c.child, i.subtreeFlags = 0, i.deletions = null, i.memoizedProps = c.memoizedProps, i.memoizedState = c.memoizedState, i.updateQueue = c.updateQueue, i.type = c.type, s = c.dependencies, i.dependencies = s === null ? null : {
      lanes: s.lanes,
      firstContext: s.firstContext
    }), i;
  }
  function Sd(i, s, c, h, b, S) {
    var j = 0;
    if (h = i, typeof i == "function") Bm(i) && (j = 1);
    else if (typeof i == "string")
      j = N6(
        i,
        c,
        te.current
      ) ? 26 : i === "html" || i === "head" || i === "body" ? 27 : 5;
    else
      e: switch (i) {
        case F:
          return i = Un(31, c, s, b), i.elementType = F, i.lanes = S, i;
        case w:
          return oa(c.children, b, S, s);
        case v:
          j = 8, b |= 24;
          break;
        case x:
          return i = Un(12, c, s, b | 2), i.elementType = x, i.lanes = S, i;
        case R:
          return i = Un(13, c, s, b), i.elementType = R, i.lanes = S, i;
        case D:
          return i = Un(19, c, s, b), i.elementType = D, i.lanes = S, i;
        default:
          if (typeof i == "object" && i !== null)
            switch (i.$$typeof) {
              case E:
              case C:
                j = 10;
                break e;
              case N:
                j = 9;
                break e;
              case A:
                j = 11;
                break e;
              case T:
                j = 14;
                break e;
              case V:
                j = 16, h = null;
                break e;
            }
          j = 29, c = Error(
            r(130, i === null ? "null" : typeof i, "")
          ), h = null;
      }
    return s = Un(j, c, s, b), s.elementType = i, s.type = h, s.lanes = S, s;
  }
  function oa(i, s, c, h) {
    return i = Un(7, i, h, s), i.lanes = c, i;
  }
  function Vm(i, s, c) {
    return i = Un(6, i, null, s), i.lanes = c, i;
  }
  function Hm(i, s, c) {
    return s = Un(
      4,
      i.children !== null ? i.children : [],
      i.key,
      s
    ), s.lanes = c, s.stateNode = {
      containerInfo: i.containerInfo,
      pendingChildren: null,
      implementation: i.implementation
    }, s;
  }
  var ol = [], il = 0, kd = null, _d = 0, sr = [], ur = 0, ia = null, xo = 1, So = "";
  function aa(i, s) {
    ol[il++] = _d, ol[il++] = kd, kd = i, _d = s;
  }
  function HS(i, s, c) {
    sr[ur++] = xo, sr[ur++] = So, sr[ur++] = ia, ia = i;
    var h = xo;
    i = So;
    var b = 32 - Le(h) - 1;
    h &= ~(1 << b), c += 1;
    var S = 32 - Le(s) + b;
    if (30 < S) {
      var j = b - b % 5;
      S = (h & (1 << j) - 1).toString(32), h >>= j, b -= j, xo = 1 << 32 - Le(s) + b | c << b | h, So = S + i;
    } else
      xo = 1 << S | c << b | h, So = i;
  }
  function Um(i) {
    i.return !== null && (aa(i, 1), HS(i, 1, 0));
  }
  function Fm(i) {
    for (; i === kd; )
      kd = ol[--il], ol[il] = null, _d = ol[--il], ol[il] = null;
    for (; i === ia; )
      ia = sr[--ur], sr[ur] = null, So = sr[--ur], sr[ur] = null, xo = sr[--ur], sr[ur] = null;
  }
  var bn = null, Ct = null, Je = !1, la = null, Vr = !1, $m = Error(r(519));
  function sa(i) {
    var s = Error(r(418, ""));
    throw Zs(ar(s, i)), $m;
  }
  function US(i) {
    var s = i.stateNode, c = i.type, h = i.memoizedProps;
    switch (s[Wt] = i, s[un] = h, c) {
      case "dialog":
        qe("cancel", s), qe("close", s);
        break;
      case "iframe":
      case "object":
      case "embed":
        qe("load", s);
        break;
      case "video":
      case "audio":
        for (c = 0; c < bu.length; c++)
          qe(bu[c], s);
        break;
      case "source":
        qe("error", s);
        break;
      case "img":
      case "image":
      case "link":
        qe("error", s), qe("load", s);
        break;
      case "details":
        qe("toggle", s);
        break;
      case "input":
        qe("invalid", s), rS(
          s,
          h.value,
          h.defaultValue,
          h.checked,
          h.defaultChecked,
          h.type,
          h.name,
          !0
        ), qa(s);
        break;
      case "select":
        qe("invalid", s);
        break;
      case "textarea":
        qe("invalid", s), iS(s, h.value, h.defaultValue, h.children), qa(s);
    }
    c = h.children, typeof c != "string" && typeof c != "number" && typeof c != "bigint" || s.textContent === "" + c || h.suppressHydrationWarning === !0 || i_(s.textContent, c) ? (h.popover != null && (qe("beforetoggle", s), qe("toggle", s)), h.onScroll != null && qe("scroll", s), h.onScrollEnd != null && qe("scrollend", s), h.onClick != null && (s.onclick = of), s = !0) : s = !1, s || sa(i);
  }
  function FS(i) {
    for (bn = i.return; bn; )
      switch (bn.tag) {
        case 5:
        case 13:
          Vr = !1;
          return;
        case 27:
        case 3:
          Vr = !0;
          return;
        default:
          bn = bn.return;
      }
  }
  function Xs(i) {
    if (i !== bn) return !1;
    if (!Je) return FS(i), Je = !0, !1;
    var s = i.tag, c;
    if ((c = s !== 3 && s !== 27) && ((c = s === 5) && (c = i.type, c = !(c !== "form" && c !== "button") || ay(i.type, i.memoizedProps)), c = !c), c && Ct && sa(i), FS(i), s === 13) {
      if (i = i.memoizedState, i = i !== null ? i.dehydrated : null, !i) throw Error(r(317));
      e: {
        for (i = i.nextSibling, s = 0; i; ) {
          if (i.nodeType === 8)
            if (c = i.data, c === "/$") {
              if (s === 0) {
                Ct = _r(i.nextSibling);
                break e;
              }
              s--;
            } else
              c !== "$" && c !== "$!" && c !== "$?" || s++;
          i = i.nextSibling;
        }
        Ct = null;
      }
    } else
      s === 27 ? (s = Ct, ki(i.type) ? (i = cy, cy = null, Ct = i) : Ct = s) : Ct = bn ? _r(i.stateNode.nextSibling) : null;
    return !0;
  }
  function Gs() {
    Ct = bn = null, Je = !1;
  }
  function $S() {
    var i = la;
    return i !== null && (jn === null ? jn = i : jn.push.apply(
      jn,
      i
    ), la = null), i;
  }
  function Zs(i) {
    la === null ? la = [i] : la.push(i);
  }
  var Ym = X(null), ua = null, ko = null;
  function si(i, s, c) {
    P(Ym, s._currentValue), s._currentValue = c;
  }
  function _o(i) {
    i._currentValue = Ym.current, Q(Ym);
  }
  function qm(i, s, c) {
    for (; i !== null; ) {
      var h = i.alternate;
      if ((i.childLanes & s) !== s ? (i.childLanes |= s, h !== null && (h.childLanes |= s)) : h !== null && (h.childLanes & s) !== s && (h.childLanes |= s), i === c) break;
      i = i.return;
    }
  }
  function Xm(i, s, c, h) {
    var b = i.child;
    for (b !== null && (b.return = i); b !== null; ) {
      var S = b.dependencies;
      if (S !== null) {
        var j = b.child;
        S = S.firstContext;
        e: for (; S !== null; ) {
          var I = S;
          S = b;
          for (var Z = 0; Z < s.length; Z++)
            if (I.context === s[Z]) {
              S.lanes |= c, I = S.alternate, I !== null && (I.lanes |= c), qm(
                S.return,
                c,
                i
              ), h || (j = null);
              break e;
            }
          S = I.next;
        }
      } else if (b.tag === 18) {
        if (j = b.return, j === null) throw Error(r(341));
        j.lanes |= c, S = j.alternate, S !== null && (S.lanes |= c), qm(j, c, i), j = null;
      } else j = b.child;
      if (j !== null) j.return = b;
      else
        for (j = b; j !== null; ) {
          if (j === i) {
            j = null;
            break;
          }
          if (b = j.sibling, b !== null) {
            b.return = j.return, j = b;
            break;
          }
          j = j.return;
        }
      b = j;
    }
  }
  function Ws(i, s, c, h) {
    i = null;
    for (var b = s, S = !1; b !== null; ) {
      if (!S) {
        if ((b.flags & 524288) !== 0) S = !0;
        else if ((b.flags & 262144) !== 0) break;
      }
      if (b.tag === 10) {
        var j = b.alternate;
        if (j === null) throw Error(r(387));
        if (j = j.memoizedProps, j !== null) {
          var I = b.type;
          Hn(b.pendingProps.value, j.value) || (i !== null ? i.push(I) : i = [I]);
        }
      } else if (b === fe.current) {
        if (j = b.alternate, j === null) throw Error(r(387));
        j.memoizedState.memoizedState !== b.memoizedState.memoizedState && (i !== null ? i.push(Eu) : i = [Eu]);
      }
      b = b.return;
    }
    i !== null && Xm(
      s,
      i,
      c,
      h
    ), s.flags |= 262144;
  }
  function Ed(i) {
    for (i = i.firstContext; i !== null; ) {
      if (!Hn(
        i.context._currentValue,
        i.memoizedValue
      ))
        return !0;
      i = i.next;
    }
    return !1;
  }
  function ca(i) {
    ua = i, ko = null, i = i.dependencies, i !== null && (i.firstContext = null);
  }
  function cn(i) {
    return YS(ua, i);
  }
  function Cd(i, s) {
    return ua === null && ca(i), YS(i, s);
  }
  function YS(i, s) {
    var c = s._currentValue;
    if (s = { context: s, memoizedValue: c, next: null }, ko === null) {
      if (i === null) throw Error(r(308));
      ko = s, i.dependencies = { lanes: 0, firstContext: s }, i.flags |= 524288;
    } else ko = ko.next = s;
    return c;
  }
  var OT = typeof AbortController < "u" ? AbortController : function() {
    var i = [], s = this.signal = {
      aborted: !1,
      addEventListener: function(c, h) {
        i.push(h);
      }
    };
    this.abort = function() {
      s.aborted = !0, i.forEach(function(c) {
        return c();
      });
    };
  }, NT = e.unstable_scheduleCallback, MT = e.unstable_NormalPriority, Gt = {
    $$typeof: C,
    Consumer: null,
    Provider: null,
    _currentValue: null,
    _currentValue2: null,
    _threadCount: 0
  };
  function Gm() {
    return {
      controller: new OT(),
      data: /* @__PURE__ */ new Map(),
      refCount: 0
    };
  }
  function Ks(i) {
    i.refCount--, i.refCount === 0 && NT(MT, function() {
      i.controller.abort();
    });
  }
  var Qs = null, Zm = 0, al = 0, ll = null;
  function AT(i, s) {
    if (Qs === null) {
      var c = Qs = [];
      Zm = 0, al = Kg(), ll = {
        status: "pending",
        value: void 0,
        then: function(h) {
          c.push(h);
        }
      };
    }
    return Zm++, s.then(qS, qS), s;
  }
  function qS() {
    if (--Zm === 0 && Qs !== null) {
      ll !== null && (ll.status = "fulfilled");
      var i = Qs;
      Qs = null, al = 0, ll = null;
      for (var s = 0; s < i.length; s++) (0, i[s])();
    }
  }
  function RT(i, s) {
    var c = [], h = {
      status: "pending",
      value: null,
      reason: null,
      then: function(b) {
        c.push(b);
      }
    };
    return i.then(
      function() {
        h.status = "fulfilled", h.value = s;
        for (var b = 0; b < c.length; b++) (0, c[b])(s);
      },
      function(b) {
        for (h.status = "rejected", h.reason = b, b = 0; b < c.length; b++)
          (0, c[b])(void 0);
      }
    ), h;
  }
  var XS = L.S;
  L.S = function(i, s) {
    typeof s == "object" && s !== null && typeof s.then == "function" && AT(i, s), XS !== null && XS(i, s);
  };
  var da = X(null);
  function Wm() {
    var i = da.current;
    return i !== null ? i : gt.pooledCache;
  }
  function Od(i, s) {
    s === null ? P(da, da.current) : P(da, s.pool);
  }
  function GS() {
    var i = Wm();
    return i === null ? null : { parent: Gt._currentValue, pool: i };
  }
  var Js = Error(r(460)), ZS = Error(r(474)), Nd = Error(r(542)), Km = { then: function() {
  } };
  function WS(i) {
    return i = i.status, i === "fulfilled" || i === "rejected";
  }
  function Md() {
  }
  function KS(i, s, c) {
    switch (c = i[c], c === void 0 ? i.push(s) : c !== s && (s.then(Md, Md), s = c), s.status) {
      case "fulfilled":
        return s.value;
      case "rejected":
        throw i = s.reason, JS(i), i;
      default:
        if (typeof s.status == "string") s.then(Md, Md);
        else {
          if (i = gt, i !== null && 100 < i.shellSuspendCounter)
            throw Error(r(482));
          i = s, i.status = "pending", i.then(
            function(h) {
              if (s.status === "pending") {
                var b = s;
                b.status = "fulfilled", b.value = h;
              }
            },
            function(h) {
              if (s.status === "pending") {
                var b = s;
                b.status = "rejected", b.reason = h;
              }
            }
          );
        }
        switch (s.status) {
          case "fulfilled":
            return s.value;
          case "rejected":
            throw i = s.reason, JS(i), i;
        }
        throw eu = s, Js;
    }
  }
  var eu = null;
  function QS() {
    if (eu === null) throw Error(r(459));
    var i = eu;
    return eu = null, i;
  }
  function JS(i) {
    if (i === Js || i === Nd)
      throw Error(r(483));
  }
  var ui = !1;
  function Qm(i) {
    i.updateQueue = {
      baseState: i.memoizedState,
      firstBaseUpdate: null,
      lastBaseUpdate: null,
      shared: { pending: null, lanes: 0, hiddenCallbacks: null },
      callbacks: null
    };
  }
  function Jm(i, s) {
    i = i.updateQueue, s.updateQueue === i && (s.updateQueue = {
      baseState: i.baseState,
      firstBaseUpdate: i.firstBaseUpdate,
      lastBaseUpdate: i.lastBaseUpdate,
      shared: i.shared,
      callbacks: null
    });
  }
  function ci(i) {
    return { lane: i, tag: 0, payload: null, callback: null, next: null };
  }
  function di(i, s, c) {
    var h = i.updateQueue;
    if (h === null) return null;
    if (h = h.shared, (it & 2) !== 0) {
      var b = h.pending;
      return b === null ? s.next = s : (s.next = b.next, b.next = s), h.pending = s, s = xd(i), BS(i, null, c), s;
    }
    return wd(i, h, s, c), xd(i);
  }
  function tu(i, s, c) {
    if (s = s.updateQueue, s !== null && (s = s.shared, (c & 4194048) !== 0)) {
      var h = s.lanes;
      h &= i.pendingLanes, c |= h, s.lanes = c, td(i, c);
    }
  }
  function eg(i, s) {
    var c = i.updateQueue, h = i.alternate;
    if (h !== null && (h = h.updateQueue, c === h)) {
      var b = null, S = null;
      if (c = c.firstBaseUpdate, c !== null) {
        do {
          var j = {
            lane: c.lane,
            tag: c.tag,
            payload: c.payload,
            callback: null,
            next: null
          };
          S === null ? b = S = j : S = S.next = j, c = c.next;
        } while (c !== null);
        S === null ? b = S = s : S = S.next = s;
      } else b = S = s;
      c = {
        baseState: h.baseState,
        firstBaseUpdate: b,
        lastBaseUpdate: S,
        shared: h.shared,
        callbacks: h.callbacks
      }, i.updateQueue = c;
      return;
    }
    i = c.lastBaseUpdate, i === null ? c.firstBaseUpdate = s : i.next = s, c.lastBaseUpdate = s;
  }
  var tg = !1;
  function nu() {
    if (tg) {
      var i = ll;
      if (i !== null) throw i;
    }
  }
  function ru(i, s, c, h) {
    tg = !1;
    var b = i.updateQueue;
    ui = !1;
    var S = b.firstBaseUpdate, j = b.lastBaseUpdate, I = b.shared.pending;
    if (I !== null) {
      b.shared.pending = null;
      var Z = I, ee = Z.next;
      Z.next = null, j === null ? S = ee : j.next = ee, j = Z;
      var ue = i.alternate;
      ue !== null && (ue = ue.updateQueue, I = ue.lastBaseUpdate, I !== j && (I === null ? ue.firstBaseUpdate = ee : I.next = ee, ue.lastBaseUpdate = Z));
    }
    if (S !== null) {
      var de = b.baseState;
      j = 0, ue = ee = Z = null, I = S;
      do {
        var ne = I.lane & -536870913, re = ne !== I.lane;
        if (re ? (We & ne) === ne : (h & ne) === ne) {
          ne !== 0 && ne === al && (tg = !0), ue !== null && (ue = ue.next = {
            lane: 0,
            tag: I.tag,
            payload: I.payload,
            callback: null,
            next: null
          });
          e: {
            var ze = i, Re = I;
            ne = s;
            var ct = c;
            switch (Re.tag) {
              case 1:
                if (ze = Re.payload, typeof ze == "function") {
                  de = ze.call(ct, de, ne);
                  break e;
                }
                de = ze;
                break e;
              case 3:
                ze.flags = ze.flags & -65537 | 128;
              case 0:
                if (ze = Re.payload, ne = typeof ze == "function" ? ze.call(ct, de, ne) : ze, ne == null) break e;
                de = p({}, de, ne);
                break e;
              case 2:
                ui = !0;
            }
          }
          ne = I.callback, ne !== null && (i.flags |= 64, re && (i.flags |= 8192), re = b.callbacks, re === null ? b.callbacks = [ne] : re.push(ne));
        } else
          re = {
            lane: ne,
            tag: I.tag,
            payload: I.payload,
            callback: I.callback,
            next: null
          }, ue === null ? (ee = ue = re, Z = de) : ue = ue.next = re, j |= ne;
        if (I = I.next, I === null) {
          if (I = b.shared.pending, I === null)
            break;
          re = I, I = re.next, re.next = null, b.lastBaseUpdate = re, b.shared.pending = null;
        }
      } while (!0);
      ue === null && (Z = de), b.baseState = Z, b.firstBaseUpdate = ee, b.lastBaseUpdate = ue, S === null && (b.shared.lanes = 0), bi |= j, i.lanes = j, i.memoizedState = de;
    }
  }
  function ek(i, s) {
    if (typeof i != "function")
      throw Error(r(191, i));
    i.call(s);
  }
  function tk(i, s) {
    var c = i.callbacks;
    if (c !== null)
      for (i.callbacks = null, i = 0; i < c.length; i++)
        ek(c[i], s);
  }
  var sl = X(null), Ad = X(0);
  function nk(i, s) {
    i = Ro, P(Ad, i), P(sl, s), Ro = i | s.baseLanes;
  }
  function ng() {
    P(Ad, Ro), P(sl, sl.current);
  }
  function rg() {
    Ro = Ad.current, Q(sl), Q(Ad);
  }
  var fi = 0, Fe = null, st = null, Bt = null, Rd = !1, ul = !1, fa = !1, jd = 0, ou = 0, cl = null, jT = 0;
  function jt() {
    throw Error(r(321));
  }
  function og(i, s) {
    if (s === null) return !1;
    for (var c = 0; c < s.length && c < i.length; c++)
      if (!Hn(i[c], s[c])) return !1;
    return !0;
  }
  function ig(i, s, c, h, b, S) {
    return fi = S, Fe = s, s.memoizedState = null, s.updateQueue = null, s.lanes = 0, L.H = i === null || i.memoizedState === null ? Bk : Vk, fa = !1, S = c(h, b), fa = !1, ul && (S = ok(
      s,
      c,
      h,
      b
    )), rk(i), S;
  }
  function rk(i) {
    L.H = Id;
    var s = st !== null && st.next !== null;
    if (fi = 0, Bt = st = Fe = null, Rd = !1, ou = 0, cl = null, s) throw Error(r(300));
    i === null || Kt || (i = i.dependencies, i !== null && Ed(i) && (Kt = !0));
  }
  function ok(i, s, c, h) {
    Fe = i;
    var b = 0;
    do {
      if (ul && (cl = null), ou = 0, ul = !1, 25 <= b) throw Error(r(301));
      if (b += 1, Bt = st = null, i.updateQueue != null) {
        var S = i.updateQueue;
        S.lastEffect = null, S.events = null, S.stores = null, S.memoCache != null && (S.memoCache.index = 0);
      }
      L.H = BT, S = s(c, h);
    } while (ul);
    return S;
  }
  function DT() {
    var i = L.H, s = i.useState()[0];
    return s = typeof s.then == "function" ? iu(s) : s, i = i.useState()[0], (st !== null ? st.memoizedState : null) !== i && (Fe.flags |= 1024), s;
  }
  function ag() {
    var i = jd !== 0;
    return jd = 0, i;
  }
  function lg(i, s, c) {
    s.updateQueue = i.updateQueue, s.flags &= -2053, i.lanes &= ~c;
  }
  function sg(i) {
    if (Rd) {
      for (i = i.memoizedState; i !== null; ) {
        var s = i.queue;
        s !== null && (s.pending = null), i = i.next;
      }
      Rd = !1;
    }
    fi = 0, Bt = st = Fe = null, ul = !1, ou = jd = 0, cl = null;
  }
  function An() {
    var i = {
      memoizedState: null,
      baseState: null,
      baseQueue: null,
      queue: null,
      next: null
    };
    return Bt === null ? Fe.memoizedState = Bt = i : Bt = Bt.next = i, Bt;
  }
  function Vt() {
    if (st === null) {
      var i = Fe.alternate;
      i = i !== null ? i.memoizedState : null;
    } else i = st.next;
    var s = Bt === null ? Fe.memoizedState : Bt.next;
    if (s !== null)
      Bt = s, st = i;
    else {
      if (i === null)
        throw Fe.alternate === null ? Error(r(467)) : Error(r(310));
      st = i, i = {
        memoizedState: st.memoizedState,
        baseState: st.baseState,
        baseQueue: st.baseQueue,
        queue: st.queue,
        next: null
      }, Bt === null ? Fe.memoizedState = Bt = i : Bt = Bt.next = i;
    }
    return Bt;
  }
  function ug() {
    return { lastEffect: null, events: null, stores: null, memoCache: null };
  }
  function iu(i) {
    var s = ou;
    return ou += 1, cl === null && (cl = []), i = KS(cl, i, s), s = Fe, (Bt === null ? s.memoizedState : Bt.next) === null && (s = s.alternate, L.H = s === null || s.memoizedState === null ? Bk : Vk), i;
  }
  function Dd(i) {
    if (i !== null && typeof i == "object") {
      if (typeof i.then == "function") return iu(i);
      if (i.$$typeof === C) return cn(i);
    }
    throw Error(r(438, String(i)));
  }
  function cg(i) {
    var s = null, c = Fe.updateQueue;
    if (c !== null && (s = c.memoCache), s == null) {
      var h = Fe.alternate;
      h !== null && (h = h.updateQueue, h !== null && (h = h.memoCache, h != null && (s = {
        data: h.data.map(function(b) {
          return b.slice();
        }),
        index: 0
      })));
    }
    if (s == null && (s = { data: [], index: 0 }), c === null && (c = ug(), Fe.updateQueue = c), c.memoCache = s, c = s.data[s.index], c === void 0)
      for (c = s.data[s.index] = Array(i), h = 0; h < i; h++)
        c[h] = O;
    return s.index++, c;
  }
  function Eo(i, s) {
    return typeof s == "function" ? s(i) : s;
  }
  function Td(i) {
    var s = Vt();
    return dg(s, st, i);
  }
  function dg(i, s, c) {
    var h = i.queue;
    if (h === null) throw Error(r(311));
    h.lastRenderedReducer = c;
    var b = i.baseQueue, S = h.pending;
    if (S !== null) {
      if (b !== null) {
        var j = b.next;
        b.next = S.next, S.next = j;
      }
      s.baseQueue = b = S, h.pending = null;
    }
    if (S = i.baseState, b === null) i.memoizedState = S;
    else {
      s = b.next;
      var I = j = null, Z = null, ee = s, ue = !1;
      do {
        var de = ee.lane & -536870913;
        if (de !== ee.lane ? (We & de) === de : (fi & de) === de) {
          var ne = ee.revertLane;
          if (ne === 0)
            Z !== null && (Z = Z.next = {
              lane: 0,
              revertLane: 0,
              action: ee.action,
              hasEagerState: ee.hasEagerState,
              eagerState: ee.eagerState,
              next: null
            }), de === al && (ue = !0);
          else if ((fi & ne) === ne) {
            ee = ee.next, ne === al && (ue = !0);
            continue;
          } else
            de = {
              lane: 0,
              revertLane: ee.revertLane,
              action: ee.action,
              hasEagerState: ee.hasEagerState,
              eagerState: ee.eagerState,
              next: null
            }, Z === null ? (I = Z = de, j = S) : Z = Z.next = de, Fe.lanes |= ne, bi |= ne;
          de = ee.action, fa && c(S, de), S = ee.hasEagerState ? ee.eagerState : c(S, de);
        } else
          ne = {
            lane: de,
            revertLane: ee.revertLane,
            action: ee.action,
            hasEagerState: ee.hasEagerState,
            eagerState: ee.eagerState,
            next: null
          }, Z === null ? (I = Z = ne, j = S) : Z = Z.next = ne, Fe.lanes |= de, bi |= de;
        ee = ee.next;
      } while (ee !== null && ee !== s);
      if (Z === null ? j = S : Z.next = I, !Hn(S, i.memoizedState) && (Kt = !0, ue && (c = ll, c !== null)))
        throw c;
      i.memoizedState = S, i.baseState = j, i.baseQueue = Z, h.lastRenderedState = S;
    }
    return b === null && (h.lanes = 0), [i.memoizedState, h.dispatch];
  }
  function fg(i) {
    var s = Vt(), c = s.queue;
    if (c === null) throw Error(r(311));
    c.lastRenderedReducer = i;
    var h = c.dispatch, b = c.pending, S = s.memoizedState;
    if (b !== null) {
      c.pending = null;
      var j = b = b.next;
      do
        S = i(S, j.action), j = j.next;
      while (j !== b);
      Hn(S, s.memoizedState) || (Kt = !0), s.memoizedState = S, s.baseQueue === null && (s.baseState = S), c.lastRenderedState = S;
    }
    return [S, h];
  }
  function ik(i, s, c) {
    var h = Fe, b = Vt(), S = Je;
    if (S) {
      if (c === void 0) throw Error(r(407));
      c = c();
    } else c = s();
    var j = !Hn(
      (st || b).memoizedState,
      c
    );
    j && (b.memoizedState = c, Kt = !0), b = b.queue;
    var I = sk.bind(null, h, b, i);
    if (au(2048, 8, I, [i]), b.getSnapshot !== s || j || Bt !== null && Bt.memoizedState.tag & 1) {
      if (h.flags |= 2048, dl(
        9,
        zd(),
        lk.bind(
          null,
          h,
          b,
          c,
          s
        ),
        null
      ), gt === null) throw Error(r(349));
      S || (fi & 124) !== 0 || ak(h, s, c);
    }
    return c;
  }
  function ak(i, s, c) {
    i.flags |= 16384, i = { getSnapshot: s, value: c }, s = Fe.updateQueue, s === null ? (s = ug(), Fe.updateQueue = s, s.stores = [i]) : (c = s.stores, c === null ? s.stores = [i] : c.push(i));
  }
  function lk(i, s, c, h) {
    s.value = c, s.getSnapshot = h, uk(s) && ck(i);
  }
  function sk(i, s, c) {
    return c(function() {
      uk(s) && ck(i);
    });
  }
  function uk(i) {
    var s = i.getSnapshot;
    i = i.value;
    try {
      var c = s();
      return !Hn(i, c);
    } catch {
      return !0;
    }
  }
  function ck(i) {
    var s = nl(i, 2);
    s !== null && Xn(s, i, 2);
  }
  function pg(i) {
    var s = An();
    if (typeof i == "function") {
      var c = i;
      if (i = c(), fa) {
        ke(!0);
        try {
          c();
        } finally {
          ke(!1);
        }
      }
    }
    return s.memoizedState = s.baseState = i, s.queue = {
      pending: null,
      lanes: 0,
      dispatch: null,
      lastRenderedReducer: Eo,
      lastRenderedState: i
    }, s;
  }
  function dk(i, s, c, h) {
    return i.baseState = c, dg(
      i,
      st,
      typeof h == "function" ? h : Eo
    );
  }
  function TT(i, s, c, h, b) {
    if (Ld(i)) throw Error(r(485));
    if (i = s.action, i !== null) {
      var S = {
        payload: b,
        action: i,
        next: null,
        isTransition: !0,
        status: "pending",
        value: null,
        reason: null,
        listeners: [],
        then: function(j) {
          S.listeners.push(j);
        }
      };
      L.T !== null ? c(!0) : S.isTransition = !1, h(S), c = s.pending, c === null ? (S.next = s.pending = S, fk(s, S)) : (S.next = c.next, s.pending = c.next = S);
    }
  }
  function fk(i, s) {
    var c = s.action, h = s.payload, b = i.state;
    if (s.isTransition) {
      var S = L.T, j = {};
      L.T = j;
      try {
        var I = c(b, h), Z = L.S;
        Z !== null && Z(j, I), pk(i, s, I);
      } catch (ee) {
        hg(i, s, ee);
      } finally {
        L.T = S;
      }
    } else
      try {
        S = c(b, h), pk(i, s, S);
      } catch (ee) {
        hg(i, s, ee);
      }
  }
  function pk(i, s, c) {
    c !== null && typeof c == "object" && typeof c.then == "function" ? c.then(
      function(h) {
        hk(i, s, h);
      },
      function(h) {
        return hg(i, s, h);
      }
    ) : hk(i, s, c);
  }
  function hk(i, s, c) {
    s.status = "fulfilled", s.value = c, mk(s), i.state = c, s = i.pending, s !== null && (c = s.next, c === s ? i.pending = null : (c = c.next, s.next = c, fk(i, c)));
  }
  function hg(i, s, c) {
    var h = i.pending;
    if (i.pending = null, h !== null) {
      h = h.next;
      do
        s.status = "rejected", s.reason = c, mk(s), s = s.next;
      while (s !== h);
    }
    i.action = null;
  }
  function mk(i) {
    i = i.listeners;
    for (var s = 0; s < i.length; s++) (0, i[s])();
  }
  function gk(i, s) {
    return s;
  }
  function yk(i, s) {
    if (Je) {
      var c = gt.formState;
      if (c !== null) {
        e: {
          var h = Fe;
          if (Je) {
            if (Ct) {
              t: {
                for (var b = Ct, S = Vr; b.nodeType !== 8; ) {
                  if (!S) {
                    b = null;
                    break t;
                  }
                  if (b = _r(
                    b.nextSibling
                  ), b === null) {
                    b = null;
                    break t;
                  }
                }
                S = b.data, b = S === "F!" || S === "F" ? b : null;
              }
              if (b) {
                Ct = _r(
                  b.nextSibling
                ), h = b.data === "F!";
                break e;
              }
            }
            sa(h);
          }
          h = !1;
        }
        h && (s = c[0]);
      }
    }
    return c = An(), c.memoizedState = c.baseState = s, h = {
      pending: null,
      lanes: 0,
      dispatch: null,
      lastRenderedReducer: gk,
      lastRenderedState: s
    }, c.queue = h, c = Pk.bind(
      null,
      Fe,
      h
    ), h.dispatch = c, h = pg(!1), S = bg.bind(
      null,
      Fe,
      !1,
      h.queue
    ), h = An(), b = {
      state: s,
      dispatch: null,
      action: i,
      pending: null
    }, h.queue = b, c = TT.bind(
      null,
      Fe,
      b,
      S,
      c
    ), b.dispatch = c, h.memoizedState = i, [s, c, !1];
  }
  function vk(i) {
    var s = Vt();
    return bk(s, st, i);
  }
  function bk(i, s, c) {
    if (s = dg(
      i,
      s,
      gk
    )[0], i = Td(Eo)[0], typeof s == "object" && s !== null && typeof s.then == "function")
      try {
        var h = iu(s);
      } catch (j) {
        throw j === Js ? Nd : j;
      }
    else h = s;
    s = Vt();
    var b = s.queue, S = b.dispatch;
    return c !== s.memoizedState && (Fe.flags |= 2048, dl(
      9,
      zd(),
      zT.bind(null, b, c),
      null
    )), [h, S, i];
  }
  function zT(i, s) {
    i.action = s;
  }
  function wk(i) {
    var s = Vt(), c = st;
    if (c !== null)
      return bk(s, c, i);
    Vt(), s = s.memoizedState, c = Vt();
    var h = c.queue.dispatch;
    return c.memoizedState = i, [s, h, !1];
  }
  function dl(i, s, c, h) {
    return i = { tag: i, create: c, deps: h, inst: s, next: null }, s = Fe.updateQueue, s === null && (s = ug(), Fe.updateQueue = s), c = s.lastEffect, c === null ? s.lastEffect = i.next = i : (h = c.next, c.next = i, i.next = h, s.lastEffect = i), i;
  }
  function zd() {
    return { destroy: void 0, resource: void 0 };
  }
  function xk() {
    return Vt().memoizedState;
  }
  function Pd(i, s, c, h) {
    var b = An();
    h = h === void 0 ? null : h, Fe.flags |= i, b.memoizedState = dl(
      1 | s,
      zd(),
      c,
      h
    );
  }
  function au(i, s, c, h) {
    var b = Vt();
    h = h === void 0 ? null : h;
    var S = b.memoizedState.inst;
    st !== null && h !== null && og(h, st.memoizedState.deps) ? b.memoizedState = dl(s, S, c, h) : (Fe.flags |= i, b.memoizedState = dl(
      1 | s,
      S,
      c,
      h
    ));
  }
  function Sk(i, s) {
    Pd(8390656, 8, i, s);
  }
  function kk(i, s) {
    au(2048, 8, i, s);
  }
  function _k(i, s) {
    return au(4, 2, i, s);
  }
  function Ek(i, s) {
    return au(4, 4, i, s);
  }
  function Ck(i, s) {
    if (typeof s == "function") {
      i = i();
      var c = s(i);
      return function() {
        typeof c == "function" ? c() : s(null);
      };
    }
    if (s != null)
      return i = i(), s.current = i, function() {
        s.current = null;
      };
  }
  function Ok(i, s, c) {
    c = c != null ? c.concat([i]) : null, au(4, 4, Ck.bind(null, s, i), c);
  }
  function mg() {
  }
  function Nk(i, s) {
    var c = Vt();
    s = s === void 0 ? null : s;
    var h = c.memoizedState;
    return s !== null && og(s, h[1]) ? h[0] : (c.memoizedState = [i, s], i);
  }
  function Mk(i, s) {
    var c = Vt();
    s = s === void 0 ? null : s;
    var h = c.memoizedState;
    if (s !== null && og(s, h[1]))
      return h[0];
    if (h = i(), fa) {
      ke(!0);
      try {
        i();
      } finally {
        ke(!1);
      }
    }
    return c.memoizedState = [h, s], h;
  }
  function gg(i, s, c) {
    return c === void 0 || (fi & 1073741824) !== 0 ? i.memoizedState = s : (i.memoizedState = c, i = j2(), Fe.lanes |= i, bi |= i, c);
  }
  function Ak(i, s, c, h) {
    return Hn(c, s) ? c : sl.current !== null ? (i = gg(i, c, h), Hn(i, s) || (Kt = !0), i) : (fi & 42) === 0 ? (Kt = !0, i.memoizedState = c) : (i = j2(), Fe.lanes |= i, bi |= i, s);
  }
  function Rk(i, s, c, h, b) {
    var S = H.p;
    H.p = S !== 0 && 8 > S ? S : 8;
    var j = L.T, I = {};
    L.T = I, bg(i, !1, s, c);
    try {
      var Z = b(), ee = L.S;
      if (ee !== null && ee(I, Z), Z !== null && typeof Z == "object" && typeof Z.then == "function") {
        var ue = RT(
          Z,
          h
        );
        lu(
          i,
          s,
          ue,
          qn(i)
        );
      } else
        lu(
          i,
          s,
          h,
          qn(i)
        );
    } catch (de) {
      lu(
        i,
        s,
        { then: function() {
        }, status: "rejected", reason: de },
        qn()
      );
    } finally {
      H.p = S, L.T = j;
    }
  }
  function PT() {
  }
  function yg(i, s, c, h) {
    if (i.tag !== 5) throw Error(r(476));
    var b = jk(i).queue;
    Rk(
      i,
      b,
      s,
      q,
      c === null ? PT : function() {
        return Dk(i), c(h);
      }
    );
  }
  function jk(i) {
    var s = i.memoizedState;
    if (s !== null) return s;
    s = {
      memoizedState: q,
      baseState: q,
      baseQueue: null,
      queue: {
        pending: null,
        lanes: 0,
        dispatch: null,
        lastRenderedReducer: Eo,
        lastRenderedState: q
      },
      next: null
    };
    var c = {};
    return s.next = {
      memoizedState: c,
      baseState: c,
      baseQueue: null,
      queue: {
        pending: null,
        lanes: 0,
        dispatch: null,
        lastRenderedReducer: Eo,
        lastRenderedState: c
      },
      next: null
    }, i.memoizedState = s, i = i.alternate, i !== null && (i.memoizedState = s), s;
  }
  function Dk(i) {
    var s = jk(i).next.queue;
    lu(i, s, {}, qn());
  }
  function vg() {
    return cn(Eu);
  }
  function Tk() {
    return Vt().memoizedState;
  }
  function zk() {
    return Vt().memoizedState;
  }
  function LT(i) {
    for (var s = i.return; s !== null; ) {
      switch (s.tag) {
        case 24:
        case 3:
          var c = qn();
          i = ci(c);
          var h = di(s, i, c);
          h !== null && (Xn(h, s, c), tu(h, s, c)), s = { cache: Gm() }, i.payload = s;
          return;
      }
      s = s.return;
    }
  }
  function IT(i, s, c) {
    var h = qn();
    c = {
      lane: h,
      revertLane: 0,
      action: c,
      hasEagerState: !1,
      eagerState: null,
      next: null
    }, Ld(i) ? Lk(s, c) : (c = Im(i, s, c, h), c !== null && (Xn(c, i, h), Ik(c, s, h)));
  }
  function Pk(i, s, c) {
    var h = qn();
    lu(i, s, c, h);
  }
  function lu(i, s, c, h) {
    var b = {
      lane: h,
      revertLane: 0,
      action: c,
      hasEagerState: !1,
      eagerState: null,
      next: null
    };
    if (Ld(i)) Lk(s, b);
    else {
      var S = i.alternate;
      if (i.lanes === 0 && (S === null || S.lanes === 0) && (S = s.lastRenderedReducer, S !== null))
        try {
          var j = s.lastRenderedState, I = S(j, c);
          if (b.hasEagerState = !0, b.eagerState = I, Hn(I, j))
            return wd(i, s, b, 0), gt === null && bd(), !1;
        } catch {
        } finally {
        }
      if (c = Im(i, s, b, h), c !== null)
        return Xn(c, i, h), Ik(c, s, h), !0;
    }
    return !1;
  }
  function bg(i, s, c, h) {
    if (h = {
      lane: 2,
      revertLane: Kg(),
      action: h,
      hasEagerState: !1,
      eagerState: null,
      next: null
    }, Ld(i)) {
      if (s) throw Error(r(479));
    } else
      s = Im(
        i,
        c,
        h,
        2
      ), s !== null && Xn(s, i, 2);
  }
  function Ld(i) {
    var s = i.alternate;
    return i === Fe || s !== null && s === Fe;
  }
  function Lk(i, s) {
    ul = Rd = !0;
    var c = i.pending;
    c === null ? s.next = s : (s.next = c.next, c.next = s), i.pending = s;
  }
  function Ik(i, s, c) {
    if ((c & 4194048) !== 0) {
      var h = s.lanes;
      h &= i.pendingLanes, c |= h, s.lanes = c, td(i, c);
    }
  }
  var Id = {
    readContext: cn,
    use: Dd,
    useCallback: jt,
    useContext: jt,
    useEffect: jt,
    useImperativeHandle: jt,
    useLayoutEffect: jt,
    useInsertionEffect: jt,
    useMemo: jt,
    useReducer: jt,
    useRef: jt,
    useState: jt,
    useDebugValue: jt,
    useDeferredValue: jt,
    useTransition: jt,
    useSyncExternalStore: jt,
    useId: jt,
    useHostTransitionStatus: jt,
    useFormState: jt,
    useActionState: jt,
    useOptimistic: jt,
    useMemoCache: jt,
    useCacheRefresh: jt
  }, Bk = {
    readContext: cn,
    use: Dd,
    useCallback: function(i, s) {
      return An().memoizedState = [
        i,
        s === void 0 ? null : s
      ], i;
    },
    useContext: cn,
    useEffect: Sk,
    useImperativeHandle: function(i, s, c) {
      c = c != null ? c.concat([i]) : null, Pd(
        4194308,
        4,
        Ck.bind(null, s, i),
        c
      );
    },
    useLayoutEffect: function(i, s) {
      return Pd(4194308, 4, i, s);
    },
    useInsertionEffect: function(i, s) {
      Pd(4, 2, i, s);
    },
    useMemo: function(i, s) {
      var c = An();
      s = s === void 0 ? null : s;
      var h = i();
      if (fa) {
        ke(!0);
        try {
          i();
        } finally {
          ke(!1);
        }
      }
      return c.memoizedState = [h, s], h;
    },
    useReducer: function(i, s, c) {
      var h = An();
      if (c !== void 0) {
        var b = c(s);
        if (fa) {
          ke(!0);
          try {
            c(s);
          } finally {
            ke(!1);
          }
        }
      } else b = s;
      return h.memoizedState = h.baseState = b, i = {
        pending: null,
        lanes: 0,
        dispatch: null,
        lastRenderedReducer: i,
        lastRenderedState: b
      }, h.queue = i, i = i.dispatch = IT.bind(
        null,
        Fe,
        i
      ), [h.memoizedState, i];
    },
    useRef: function(i) {
      var s = An();
      return i = { current: i }, s.memoizedState = i;
    },
    useState: function(i) {
      i = pg(i);
      var s = i.queue, c = Pk.bind(null, Fe, s);
      return s.dispatch = c, [i.memoizedState, c];
    },
    useDebugValue: mg,
    useDeferredValue: function(i, s) {
      var c = An();
      return gg(c, i, s);
    },
    useTransition: function() {
      var i = pg(!1);
      return i = Rk.bind(
        null,
        Fe,
        i.queue,
        !0,
        !1
      ), An().memoizedState = i, [!1, i];
    },
    useSyncExternalStore: function(i, s, c) {
      var h = Fe, b = An();
      if (Je) {
        if (c === void 0)
          throw Error(r(407));
        c = c();
      } else {
        if (c = s(), gt === null)
          throw Error(r(349));
        (We & 124) !== 0 || ak(h, s, c);
      }
      b.memoizedState = c;
      var S = { value: c, getSnapshot: s };
      return b.queue = S, Sk(sk.bind(null, h, S, i), [
        i
      ]), h.flags |= 2048, dl(
        9,
        zd(),
        lk.bind(
          null,
          h,
          S,
          c,
          s
        ),
        null
      ), c;
    },
    useId: function() {
      var i = An(), s = gt.identifierPrefix;
      if (Je) {
        var c = So, h = xo;
        c = (h & ~(1 << 32 - Le(h) - 1)).toString(32) + c, s = "" + s + "R" + c, c = jd++, 0 < c && (s += "H" + c.toString(32)), s += "";
      } else
        c = jT++, s = "" + s + "r" + c.toString(32) + "";
      return i.memoizedState = s;
    },
    useHostTransitionStatus: vg,
    useFormState: yk,
    useActionState: yk,
    useOptimistic: function(i) {
      var s = An();
      s.memoizedState = s.baseState = i;
      var c = {
        pending: null,
        lanes: 0,
        dispatch: null,
        lastRenderedReducer: null,
        lastRenderedState: null
      };
      return s.queue = c, s = bg.bind(
        null,
        Fe,
        !0,
        c
      ), c.dispatch = s, [i, s];
    },
    useMemoCache: cg,
    useCacheRefresh: function() {
      return An().memoizedState = LT.bind(
        null,
        Fe
      );
    }
  }, Vk = {
    readContext: cn,
    use: Dd,
    useCallback: Nk,
    useContext: cn,
    useEffect: kk,
    useImperativeHandle: Ok,
    useInsertionEffect: _k,
    useLayoutEffect: Ek,
    useMemo: Mk,
    useReducer: Td,
    useRef: xk,
    useState: function() {
      return Td(Eo);
    },
    useDebugValue: mg,
    useDeferredValue: function(i, s) {
      var c = Vt();
      return Ak(
        c,
        st.memoizedState,
        i,
        s
      );
    },
    useTransition: function() {
      var i = Td(Eo)[0], s = Vt().memoizedState;
      return [
        typeof i == "boolean" ? i : iu(i),
        s
      ];
    },
    useSyncExternalStore: ik,
    useId: Tk,
    useHostTransitionStatus: vg,
    useFormState: vk,
    useActionState: vk,
    useOptimistic: function(i, s) {
      var c = Vt();
      return dk(c, st, i, s);
    },
    useMemoCache: cg,
    useCacheRefresh: zk
  }, BT = {
    readContext: cn,
    use: Dd,
    useCallback: Nk,
    useContext: cn,
    useEffect: kk,
    useImperativeHandle: Ok,
    useInsertionEffect: _k,
    useLayoutEffect: Ek,
    useMemo: Mk,
    useReducer: fg,
    useRef: xk,
    useState: function() {
      return fg(Eo);
    },
    useDebugValue: mg,
    useDeferredValue: function(i, s) {
      var c = Vt();
      return st === null ? gg(c, i, s) : Ak(
        c,
        st.memoizedState,
        i,
        s
      );
    },
    useTransition: function() {
      var i = fg(Eo)[0], s = Vt().memoizedState;
      return [
        typeof i == "boolean" ? i : iu(i),
        s
      ];
    },
    useSyncExternalStore: ik,
    useId: Tk,
    useHostTransitionStatus: vg,
    useFormState: wk,
    useActionState: wk,
    useOptimistic: function(i, s) {
      var c = Vt();
      return st !== null ? dk(c, st, i, s) : (c.baseState = i, [i, c.queue.dispatch]);
    },
    useMemoCache: cg,
    useCacheRefresh: zk
  }, fl = null, su = 0;
  function Bd(i) {
    var s = su;
    return su += 1, fl === null && (fl = []), KS(fl, i, s);
  }
  function uu(i, s) {
    s = s.props.ref, i.ref = s !== void 0 ? s : null;
  }
  function Vd(i, s) {
    throw s.$$typeof === m ? Error(r(525)) : (i = Object.prototype.toString.call(s), Error(
      r(
        31,
        i === "[object Object]" ? "object with keys {" + Object.keys(s).join(", ") + "}" : i
      )
    ));
  }
  function Hk(i) {
    var s = i._init;
    return s(i._payload);
  }
  function Uk(i) {
    function s(K, W) {
      if (i) {
        var J = K.deletions;
        J === null ? (K.deletions = [W], K.flags |= 16) : J.push(W);
      }
    }
    function c(K, W) {
      if (!i) return null;
      for (; W !== null; )
        s(K, W), W = W.sibling;
      return null;
    }
    function h(K) {
      for (var W = /* @__PURE__ */ new Map(); K !== null; )
        K.key !== null ? W.set(K.key, K) : W.set(K.index, K), K = K.sibling;
      return W;
    }
    function b(K, W) {
      return K = wo(K, W), K.index = 0, K.sibling = null, K;
    }
    function S(K, W, J) {
      return K.index = J, i ? (J = K.alternate, J !== null ? (J = J.index, J < W ? (K.flags |= 67108866, W) : J) : (K.flags |= 67108866, W)) : (K.flags |= 1048576, W);
    }
    function j(K) {
      return i && K.alternate === null && (K.flags |= 67108866), K;
    }
    function I(K, W, J, ce) {
      return W === null || W.tag !== 6 ? (W = Vm(J, K.mode, ce), W.return = K, W) : (W = b(W, J), W.return = K, W);
    }
    function Z(K, W, J, ce) {
      var be = J.type;
      return be === w ? ue(
        K,
        W,
        J.props.children,
        ce,
        J.key
      ) : W !== null && (W.elementType === be || typeof be == "object" && be !== null && be.$$typeof === V && Hk(be) === W.type) ? (W = b(W, J.props), uu(W, J), W.return = K, W) : (W = Sd(
        J.type,
        J.key,
        J.props,
        null,
        K.mode,
        ce
      ), uu(W, J), W.return = K, W);
    }
    function ee(K, W, J, ce) {
      return W === null || W.tag !== 4 || W.stateNode.containerInfo !== J.containerInfo || W.stateNode.implementation !== J.implementation ? (W = Hm(J, K.mode, ce), W.return = K, W) : (W = b(W, J.children || []), W.return = K, W);
    }
    function ue(K, W, J, ce, be) {
      return W === null || W.tag !== 7 ? (W = oa(
        J,
        K.mode,
        ce,
        be
      ), W.return = K, W) : (W = b(W, J), W.return = K, W);
    }
    function de(K, W, J) {
      if (typeof W == "string" && W !== "" || typeof W == "number" || typeof W == "bigint")
        return W = Vm(
          "" + W,
          K.mode,
          J
        ), W.return = K, W;
      if (typeof W == "object" && W !== null) {
        switch (W.$$typeof) {
          case g:
            return J = Sd(
              W.type,
              W.key,
              W.props,
              null,
              K.mode,
              J
            ), uu(J, W), J.return = K, J;
          case y:
            return W = Hm(
              W,
              K.mode,
              J
            ), W.return = K, W;
          case V:
            var ce = W._init;
            return W = ce(W._payload), de(K, W, J);
        }
        if ($(W) || U(W))
          return W = oa(
            W,
            K.mode,
            J,
            null
          ), W.return = K, W;
        if (typeof W.then == "function")
          return de(K, Bd(W), J);
        if (W.$$typeof === C)
          return de(
            K,
            Cd(K, W),
            J
          );
        Vd(K, W);
      }
      return null;
    }
    function ne(K, W, J, ce) {
      var be = W !== null ? W.key : null;
      if (typeof J == "string" && J !== "" || typeof J == "number" || typeof J == "bigint")
        return be !== null ? null : I(K, W, "" + J, ce);
      if (typeof J == "object" && J !== null) {
        switch (J.$$typeof) {
          case g:
            return J.key === be ? Z(K, W, J, ce) : null;
          case y:
            return J.key === be ? ee(K, W, J, ce) : null;
          case V:
            return be = J._init, J = be(J._payload), ne(K, W, J, ce);
        }
        if ($(J) || U(J))
          return be !== null ? null : ue(K, W, J, ce, null);
        if (typeof J.then == "function")
          return ne(
            K,
            W,
            Bd(J),
            ce
          );
        if (J.$$typeof === C)
          return ne(
            K,
            W,
            Cd(K, J),
            ce
          );
        Vd(K, J);
      }
      return null;
    }
    function re(K, W, J, ce, be) {
      if (typeof ce == "string" && ce !== "" || typeof ce == "number" || typeof ce == "bigint")
        return K = K.get(J) || null, I(W, K, "" + ce, be);
      if (typeof ce == "object" && ce !== null) {
        switch (ce.$$typeof) {
          case g:
            return K = K.get(
              ce.key === null ? J : ce.key
            ) || null, Z(W, K, ce, be);
          case y:
            return K = K.get(
              ce.key === null ? J : ce.key
            ) || null, ee(W, K, ce, be);
          case V:
            var $e = ce._init;
            return ce = $e(ce._payload), re(
              K,
              W,
              J,
              ce,
              be
            );
        }
        if ($(ce) || U(ce))
          return K = K.get(J) || null, ue(W, K, ce, be, null);
        if (typeof ce.then == "function")
          return re(
            K,
            W,
            J,
            Bd(ce),
            be
          );
        if (ce.$$typeof === C)
          return re(
            K,
            W,
            J,
            Cd(W, ce),
            be
          );
        Vd(W, ce);
      }
      return null;
    }
    function ze(K, W, J, ce) {
      for (var be = null, $e = null, _e = W, De = W = 0, Jt = null; _e !== null && De < J.length; De++) {
        _e.index > De ? (Jt = _e, _e = null) : Jt = _e.sibling;
        var Qe = ne(
          K,
          _e,
          J[De],
          ce
        );
        if (Qe === null) {
          _e === null && (_e = Jt);
          break;
        }
        i && _e && Qe.alternate === null && s(K, _e), W = S(Qe, W, De), $e === null ? be = Qe : $e.sibling = Qe, $e = Qe, _e = Jt;
      }
      if (De === J.length)
        return c(K, _e), Je && aa(K, De), be;
      if (_e === null) {
        for (; De < J.length; De++)
          _e = de(K, J[De], ce), _e !== null && (W = S(
            _e,
            W,
            De
          ), $e === null ? be = _e : $e.sibling = _e, $e = _e);
        return Je && aa(K, De), be;
      }
      for (_e = h(_e); De < J.length; De++)
        Jt = re(
          _e,
          K,
          De,
          J[De],
          ce
        ), Jt !== null && (i && Jt.alternate !== null && _e.delete(
          Jt.key === null ? De : Jt.key
        ), W = S(
          Jt,
          W,
          De
        ), $e === null ? be = Jt : $e.sibling = Jt, $e = Jt);
      return i && _e.forEach(function(Ni) {
        return s(K, Ni);
      }), Je && aa(K, De), be;
    }
    function Re(K, W, J, ce) {
      if (J == null) throw Error(r(151));
      for (var be = null, $e = null, _e = W, De = W = 0, Jt = null, Qe = J.next(); _e !== null && !Qe.done; De++, Qe = J.next()) {
        _e.index > De ? (Jt = _e, _e = null) : Jt = _e.sibling;
        var Ni = ne(K, _e, Qe.value, ce);
        if (Ni === null) {
          _e === null && (_e = Jt);
          break;
        }
        i && _e && Ni.alternate === null && s(K, _e), W = S(Ni, W, De), $e === null ? be = Ni : $e.sibling = Ni, $e = Ni, _e = Jt;
      }
      if (Qe.done)
        return c(K, _e), Je && aa(K, De), be;
      if (_e === null) {
        for (; !Qe.done; De++, Qe = J.next())
          Qe = de(K, Qe.value, ce), Qe !== null && (W = S(Qe, W, De), $e === null ? be = Qe : $e.sibling = Qe, $e = Qe);
        return Je && aa(K, De), be;
      }
      for (_e = h(_e); !Qe.done; De++, Qe = J.next())
        Qe = re(_e, K, De, Qe.value, ce), Qe !== null && (i && Qe.alternate !== null && _e.delete(Qe.key === null ? De : Qe.key), W = S(Qe, W, De), $e === null ? be = Qe : $e.sibling = Qe, $e = Qe);
      return i && _e.forEach(function(V6) {
        return s(K, V6);
      }), Je && aa(K, De), be;
    }
    function ct(K, W, J, ce) {
      if (typeof J == "object" && J !== null && J.type === w && J.key === null && (J = J.props.children), typeof J == "object" && J !== null) {
        switch (J.$$typeof) {
          case g:
            e: {
              for (var be = J.key; W !== null; ) {
                if (W.key === be) {
                  if (be = J.type, be === w) {
                    if (W.tag === 7) {
                      c(
                        K,
                        W.sibling
                      ), ce = b(
                        W,
                        J.props.children
                      ), ce.return = K, K = ce;
                      break e;
                    }
                  } else if (W.elementType === be || typeof be == "object" && be !== null && be.$$typeof === V && Hk(be) === W.type) {
                    c(
                      K,
                      W.sibling
                    ), ce = b(W, J.props), uu(ce, J), ce.return = K, K = ce;
                    break e;
                  }
                  c(K, W);
                  break;
                } else s(K, W);
                W = W.sibling;
              }
              J.type === w ? (ce = oa(
                J.props.children,
                K.mode,
                ce,
                J.key
              ), ce.return = K, K = ce) : (ce = Sd(
                J.type,
                J.key,
                J.props,
                null,
                K.mode,
                ce
              ), uu(ce, J), ce.return = K, K = ce);
            }
            return j(K);
          case y:
            e: {
              for (be = J.key; W !== null; ) {
                if (W.key === be)
                  if (W.tag === 4 && W.stateNode.containerInfo === J.containerInfo && W.stateNode.implementation === J.implementation) {
                    c(
                      K,
                      W.sibling
                    ), ce = b(W, J.children || []), ce.return = K, K = ce;
                    break e;
                  } else {
                    c(K, W);
                    break;
                  }
                else s(K, W);
                W = W.sibling;
              }
              ce = Hm(J, K.mode, ce), ce.return = K, K = ce;
            }
            return j(K);
          case V:
            return be = J._init, J = be(J._payload), ct(
              K,
              W,
              J,
              ce
            );
        }
        if ($(J))
          return ze(
            K,
            W,
            J,
            ce
          );
        if (U(J)) {
          if (be = U(J), typeof be != "function") throw Error(r(150));
          return J = be.call(J), Re(
            K,
            W,
            J,
            ce
          );
        }
        if (typeof J.then == "function")
          return ct(
            K,
            W,
            Bd(J),
            ce
          );
        if (J.$$typeof === C)
          return ct(
            K,
            W,
            Cd(K, J),
            ce
          );
        Vd(K, J);
      }
      return typeof J == "string" && J !== "" || typeof J == "number" || typeof J == "bigint" ? (J = "" + J, W !== null && W.tag === 6 ? (c(K, W.sibling), ce = b(W, J), ce.return = K, K = ce) : (c(K, W), ce = Vm(J, K.mode, ce), ce.return = K, K = ce), j(K)) : c(K, W);
    }
    return function(K, W, J, ce) {
      try {
        su = 0;
        var be = ct(
          K,
          W,
          J,
          ce
        );
        return fl = null, be;
      } catch (_e) {
        if (_e === Js || _e === Nd) throw _e;
        var $e = Un(29, _e, null, K.mode);
        return $e.lanes = ce, $e.return = K, $e;
      } finally {
      }
    };
  }
  var pl = Uk(!0), Fk = Uk(!1), cr = X(null), Hr = null;
  function pi(i) {
    var s = i.alternate;
    P(Zt, Zt.current & 1), P(cr, i), Hr === null && (s === null || sl.current !== null || s.memoizedState !== null) && (Hr = i);
  }
  function $k(i) {
    if (i.tag === 22) {
      if (P(Zt, Zt.current), P(cr, i), Hr === null) {
        var s = i.alternate;
        s !== null && s.memoizedState !== null && (Hr = i);
      }
    } else hi();
  }
  function hi() {
    P(Zt, Zt.current), P(cr, cr.current);
  }
  function Co(i) {
    Q(cr), Hr === i && (Hr = null), Q(Zt);
  }
  var Zt = X(0);
  function Hd(i) {
    for (var s = i; s !== null; ) {
      if (s.tag === 13) {
        var c = s.memoizedState;
        if (c !== null && (c = c.dehydrated, c === null || c.data === "$?" || uy(c)))
          return s;
      } else if (s.tag === 19 && s.memoizedProps.revealOrder !== void 0) {
        if ((s.flags & 128) !== 0) return s;
      } else if (s.child !== null) {
        s.child.return = s, s = s.child;
        continue;
      }
      if (s === i) break;
      for (; s.sibling === null; ) {
        if (s.return === null || s.return === i) return null;
        s = s.return;
      }
      s.sibling.return = s.return, s = s.sibling;
    }
    return null;
  }
  function wg(i, s, c, h) {
    s = i.memoizedState, c = c(h, s), c = c == null ? s : p({}, s, c), i.memoizedState = c, i.lanes === 0 && (i.updateQueue.baseState = c);
  }
  var xg = {
    enqueueSetState: function(i, s, c) {
      i = i._reactInternals;
      var h = qn(), b = ci(h);
      b.payload = s, c != null && (b.callback = c), s = di(i, b, h), s !== null && (Xn(s, i, h), tu(s, i, h));
    },
    enqueueReplaceState: function(i, s, c) {
      i = i._reactInternals;
      var h = qn(), b = ci(h);
      b.tag = 1, b.payload = s, c != null && (b.callback = c), s = di(i, b, h), s !== null && (Xn(s, i, h), tu(s, i, h));
    },
    enqueueForceUpdate: function(i, s) {
      i = i._reactInternals;
      var c = qn(), h = ci(c);
      h.tag = 2, s != null && (h.callback = s), s = di(i, h, c), s !== null && (Xn(s, i, c), tu(s, i, c));
    }
  };
  function Yk(i, s, c, h, b, S, j) {
    return i = i.stateNode, typeof i.shouldComponentUpdate == "function" ? i.shouldComponentUpdate(h, S, j) : s.prototype && s.prototype.isPureReactComponent ? !Ys(c, h) || !Ys(b, S) : !0;
  }
  function qk(i, s, c, h) {
    i = s.state, typeof s.componentWillReceiveProps == "function" && s.componentWillReceiveProps(c, h), typeof s.UNSAFE_componentWillReceiveProps == "function" && s.UNSAFE_componentWillReceiveProps(c, h), s.state !== i && xg.enqueueReplaceState(s, s.state, null);
  }
  function pa(i, s) {
    var c = s;
    if ("ref" in s) {
      c = {};
      for (var h in s)
        h !== "ref" && (c[h] = s[h]);
    }
    if (i = i.defaultProps) {
      c === s && (c = p({}, c));
      for (var b in i)
        c[b] === void 0 && (c[b] = i[b]);
    }
    return c;
  }
  var Ud = typeof reportError == "function" ? reportError : function(i) {
    if (typeof window == "object" && typeof window.ErrorEvent == "function") {
      var s = new window.ErrorEvent("error", {
        bubbles: !0,
        cancelable: !0,
        message: typeof i == "object" && i !== null && typeof i.message == "string" ? String(i.message) : String(i),
        error: i
      });
      if (!window.dispatchEvent(s)) return;
    } else if (typeof process == "object" && typeof process.emit == "function") {
      process.emit("uncaughtException", i);
      return;
    }
    console.error(i);
  };
  function Xk(i) {
    Ud(i);
  }
  function Gk(i) {
    console.error(i);
  }
  function Zk(i) {
    Ud(i);
  }
  function Fd(i, s) {
    try {
      var c = i.onUncaughtError;
      c(s.value, { componentStack: s.stack });
    } catch (h) {
      setTimeout(function() {
        throw h;
      });
    }
  }
  function Wk(i, s, c) {
    try {
      var h = i.onCaughtError;
      h(c.value, {
        componentStack: c.stack,
        errorBoundary: s.tag === 1 ? s.stateNode : null
      });
    } catch (b) {
      setTimeout(function() {
        throw b;
      });
    }
  }
  function Sg(i, s, c) {
    return c = ci(c), c.tag = 3, c.payload = { element: null }, c.callback = function() {
      Fd(i, s);
    }, c;
  }
  function Kk(i) {
    return i = ci(i), i.tag = 3, i;
  }
  function Qk(i, s, c, h) {
    var b = c.type.getDerivedStateFromError;
    if (typeof b == "function") {
      var S = h.value;
      i.payload = function() {
        return b(S);
      }, i.callback = function() {
        Wk(s, c, h);
      };
    }
    var j = c.stateNode;
    j !== null && typeof j.componentDidCatch == "function" && (i.callback = function() {
      Wk(s, c, h), typeof b != "function" && (wi === null ? wi = /* @__PURE__ */ new Set([this]) : wi.add(this));
      var I = h.stack;
      this.componentDidCatch(h.value, {
        componentStack: I !== null ? I : ""
      });
    });
  }
  function VT(i, s, c, h, b) {
    if (c.flags |= 32768, h !== null && typeof h == "object" && typeof h.then == "function") {
      if (s = c.alternate, s !== null && Ws(
        s,
        c,
        b,
        !0
      ), c = cr.current, c !== null) {
        switch (c.tag) {
          case 13:
            return Hr === null ? qg() : c.alternate === null && Ot === 0 && (Ot = 3), c.flags &= -257, c.flags |= 65536, c.lanes = b, h === Km ? c.flags |= 16384 : (s = c.updateQueue, s === null ? c.updateQueue = /* @__PURE__ */ new Set([h]) : s.add(h), Gg(i, h, b)), !1;
          case 22:
            return c.flags |= 65536, h === Km ? c.flags |= 16384 : (s = c.updateQueue, s === null ? (s = {
              transitions: null,
              markerInstances: null,
              retryQueue: /* @__PURE__ */ new Set([h])
            }, c.updateQueue = s) : (c = s.retryQueue, c === null ? s.retryQueue = /* @__PURE__ */ new Set([h]) : c.add(h)), Gg(i, h, b)), !1;
        }
        throw Error(r(435, c.tag));
      }
      return Gg(i, h, b), qg(), !1;
    }
    if (Je)
      return s = cr.current, s !== null ? ((s.flags & 65536) === 0 && (s.flags |= 256), s.flags |= 65536, s.lanes = b, h !== $m && (i = Error(r(422), { cause: h }), Zs(ar(i, c)))) : (h !== $m && (s = Error(r(423), {
        cause: h
      }), Zs(
        ar(s, c)
      )), i = i.current.alternate, i.flags |= 65536, b &= -b, i.lanes |= b, h = ar(h, c), b = Sg(
        i.stateNode,
        h,
        b
      ), eg(i, b), Ot !== 4 && (Ot = 2)), !1;
    var S = Error(r(520), { cause: h });
    if (S = ar(S, c), gu === null ? gu = [S] : gu.push(S), Ot !== 4 && (Ot = 2), s === null) return !0;
    h = ar(h, c), c = s;
    do {
      switch (c.tag) {
        case 3:
          return c.flags |= 65536, i = b & -b, c.lanes |= i, i = Sg(c.stateNode, h, i), eg(c, i), !1;
        case 1:
          if (s = c.type, S = c.stateNode, (c.flags & 128) === 0 && (typeof s.getDerivedStateFromError == "function" || S !== null && typeof S.componentDidCatch == "function" && (wi === null || !wi.has(S))))
            return c.flags |= 65536, b &= -b, c.lanes |= b, b = Kk(b), Qk(
              b,
              i,
              c,
              h
            ), eg(c, b), !1;
      }
      c = c.return;
    } while (c !== null);
    return !1;
  }
  var Jk = Error(r(461)), Kt = !1;
  function tn(i, s, c, h) {
    s.child = i === null ? Fk(s, null, c, h) : pl(
      s,
      i.child,
      c,
      h
    );
  }
  function e2(i, s, c, h, b) {
    c = c.render;
    var S = s.ref;
    if ("ref" in h) {
      var j = {};
      for (var I in h)
        I !== "ref" && (j[I] = h[I]);
    } else j = h;
    return ca(s), h = ig(
      i,
      s,
      c,
      j,
      S,
      b
    ), I = ag(), i !== null && !Kt ? (lg(i, s, b), Oo(i, s, b)) : (Je && I && Um(s), s.flags |= 1, tn(i, s, h, b), s.child);
  }
  function t2(i, s, c, h, b) {
    if (i === null) {
      var S = c.type;
      return typeof S == "function" && !Bm(S) && S.defaultProps === void 0 && c.compare === null ? (s.tag = 15, s.type = S, n2(
        i,
        s,
        S,
        h,
        b
      )) : (i = Sd(
        c.type,
        null,
        h,
        s,
        s.mode,
        b
      ), i.ref = s.ref, i.return = s, s.child = i);
    }
    if (S = i.child, !Ag(i, b)) {
      var j = S.memoizedProps;
      if (c = c.compare, c = c !== null ? c : Ys, c(j, h) && i.ref === s.ref)
        return Oo(i, s, b);
    }
    return s.flags |= 1, i = wo(S, h), i.ref = s.ref, i.return = s, s.child = i;
  }
  function n2(i, s, c, h, b) {
    if (i !== null) {
      var S = i.memoizedProps;
      if (Ys(S, h) && i.ref === s.ref)
        if (Kt = !1, s.pendingProps = h = S, Ag(i, b))
          (i.flags & 131072) !== 0 && (Kt = !0);
        else
          return s.lanes = i.lanes, Oo(i, s, b);
    }
    return kg(
      i,
      s,
      c,
      h,
      b
    );
  }
  function r2(i, s, c) {
    var h = s.pendingProps, b = h.children, S = i !== null ? i.memoizedState : null;
    if (h.mode === "hidden") {
      if ((s.flags & 128) !== 0) {
        if (h = S !== null ? S.baseLanes | c : c, i !== null) {
          for (b = s.child = i.child, S = 0; b !== null; )
            S = S | b.lanes | b.childLanes, b = b.sibling;
          s.childLanes = S & ~h;
        } else s.childLanes = 0, s.child = null;
        return o2(
          i,
          s,
          h,
          c
        );
      }
      if ((c & 536870912) !== 0)
        s.memoizedState = { baseLanes: 0, cachePool: null }, i !== null && Od(
          s,
          S !== null ? S.cachePool : null
        ), S !== null ? nk(s, S) : ng(), $k(s);
      else
        return s.lanes = s.childLanes = 536870912, o2(
          i,
          s,
          S !== null ? S.baseLanes | c : c,
          c
        );
    } else
      S !== null ? (Od(s, S.cachePool), nk(s, S), hi(), s.memoizedState = null) : (i !== null && Od(s, null), ng(), hi());
    return tn(i, s, b, c), s.child;
  }
  function o2(i, s, c, h) {
    var b = Wm();
    return b = b === null ? null : { parent: Gt._currentValue, pool: b }, s.memoizedState = {
      baseLanes: c,
      cachePool: b
    }, i !== null && Od(s, null), ng(), $k(s), i !== null && Ws(i, s, h, !0), null;
  }
  function $d(i, s) {
    var c = s.ref;
    if (c === null)
      i !== null && i.ref !== null && (s.flags |= 4194816);
    else {
      if (typeof c != "function" && typeof c != "object")
        throw Error(r(284));
      (i === null || i.ref !== c) && (s.flags |= 4194816);
    }
  }
  function kg(i, s, c, h, b) {
    return ca(s), c = ig(
      i,
      s,
      c,
      h,
      void 0,
      b
    ), h = ag(), i !== null && !Kt ? (lg(i, s, b), Oo(i, s, b)) : (Je && h && Um(s), s.flags |= 1, tn(i, s, c, b), s.child);
  }
  function i2(i, s, c, h, b, S) {
    return ca(s), s.updateQueue = null, c = ok(
      s,
      h,
      c,
      b
    ), rk(i), h = ag(), i !== null && !Kt ? (lg(i, s, S), Oo(i, s, S)) : (Je && h && Um(s), s.flags |= 1, tn(i, s, c, S), s.child);
  }
  function a2(i, s, c, h, b) {
    if (ca(s), s.stateNode === null) {
      var S = rl, j = c.contextType;
      typeof j == "object" && j !== null && (S = cn(j)), S = new c(h, S), s.memoizedState = S.state !== null && S.state !== void 0 ? S.state : null, S.updater = xg, s.stateNode = S, S._reactInternals = s, S = s.stateNode, S.props = h, S.state = s.memoizedState, S.refs = {}, Qm(s), j = c.contextType, S.context = typeof j == "object" && j !== null ? cn(j) : rl, S.state = s.memoizedState, j = c.getDerivedStateFromProps, typeof j == "function" && (wg(
        s,
        c,
        j,
        h
      ), S.state = s.memoizedState), typeof c.getDerivedStateFromProps == "function" || typeof S.getSnapshotBeforeUpdate == "function" || typeof S.UNSAFE_componentWillMount != "function" && typeof S.componentWillMount != "function" || (j = S.state, typeof S.componentWillMount == "function" && S.componentWillMount(), typeof S.UNSAFE_componentWillMount == "function" && S.UNSAFE_componentWillMount(), j !== S.state && xg.enqueueReplaceState(S, S.state, null), ru(s, h, S, b), nu(), S.state = s.memoizedState), typeof S.componentDidMount == "function" && (s.flags |= 4194308), h = !0;
    } else if (i === null) {
      S = s.stateNode;
      var I = s.memoizedProps, Z = pa(c, I);
      S.props = Z;
      var ee = S.context, ue = c.contextType;
      j = rl, typeof ue == "object" && ue !== null && (j = cn(ue));
      var de = c.getDerivedStateFromProps;
      ue = typeof de == "function" || typeof S.getSnapshotBeforeUpdate == "function", I = s.pendingProps !== I, ue || typeof S.UNSAFE_componentWillReceiveProps != "function" && typeof S.componentWillReceiveProps != "function" || (I || ee !== j) && qk(
        s,
        S,
        h,
        j
      ), ui = !1;
      var ne = s.memoizedState;
      S.state = ne, ru(s, h, S, b), nu(), ee = s.memoizedState, I || ne !== ee || ui ? (typeof de == "function" && (wg(
        s,
        c,
        de,
        h
      ), ee = s.memoizedState), (Z = ui || Yk(
        s,
        c,
        Z,
        h,
        ne,
        ee,
        j
      )) ? (ue || typeof S.UNSAFE_componentWillMount != "function" && typeof S.componentWillMount != "function" || (typeof S.componentWillMount == "function" && S.componentWillMount(), typeof S.UNSAFE_componentWillMount == "function" && S.UNSAFE_componentWillMount()), typeof S.componentDidMount == "function" && (s.flags |= 4194308)) : (typeof S.componentDidMount == "function" && (s.flags |= 4194308), s.memoizedProps = h, s.memoizedState = ee), S.props = h, S.state = ee, S.context = j, h = Z) : (typeof S.componentDidMount == "function" && (s.flags |= 4194308), h = !1);
    } else {
      S = s.stateNode, Jm(i, s), j = s.memoizedProps, ue = pa(c, j), S.props = ue, de = s.pendingProps, ne = S.context, ee = c.contextType, Z = rl, typeof ee == "object" && ee !== null && (Z = cn(ee)), I = c.getDerivedStateFromProps, (ee = typeof I == "function" || typeof S.getSnapshotBeforeUpdate == "function") || typeof S.UNSAFE_componentWillReceiveProps != "function" && typeof S.componentWillReceiveProps != "function" || (j !== de || ne !== Z) && qk(
        s,
        S,
        h,
        Z
      ), ui = !1, ne = s.memoizedState, S.state = ne, ru(s, h, S, b), nu();
      var re = s.memoizedState;
      j !== de || ne !== re || ui || i !== null && i.dependencies !== null && Ed(i.dependencies) ? (typeof I == "function" && (wg(
        s,
        c,
        I,
        h
      ), re = s.memoizedState), (ue = ui || Yk(
        s,
        c,
        ue,
        h,
        ne,
        re,
        Z
      ) || i !== null && i.dependencies !== null && Ed(i.dependencies)) ? (ee || typeof S.UNSAFE_componentWillUpdate != "function" && typeof S.componentWillUpdate != "function" || (typeof S.componentWillUpdate == "function" && S.componentWillUpdate(h, re, Z), typeof S.UNSAFE_componentWillUpdate == "function" && S.UNSAFE_componentWillUpdate(
        h,
        re,
        Z
      )), typeof S.componentDidUpdate == "function" && (s.flags |= 4), typeof S.getSnapshotBeforeUpdate == "function" && (s.flags |= 1024)) : (typeof S.componentDidUpdate != "function" || j === i.memoizedProps && ne === i.memoizedState || (s.flags |= 4), typeof S.getSnapshotBeforeUpdate != "function" || j === i.memoizedProps && ne === i.memoizedState || (s.flags |= 1024), s.memoizedProps = h, s.memoizedState = re), S.props = h, S.state = re, S.context = Z, h = ue) : (typeof S.componentDidUpdate != "function" || j === i.memoizedProps && ne === i.memoizedState || (s.flags |= 4), typeof S.getSnapshotBeforeUpdate != "function" || j === i.memoizedProps && ne === i.memoizedState || (s.flags |= 1024), h = !1);
    }
    return S = h, $d(i, s), h = (s.flags & 128) !== 0, S || h ? (S = s.stateNode, c = h && typeof c.getDerivedStateFromError != "function" ? null : S.render(), s.flags |= 1, i !== null && h ? (s.child = pl(
      s,
      i.child,
      null,
      b
    ), s.child = pl(
      s,
      null,
      c,
      b
    )) : tn(i, s, c, b), s.memoizedState = S.state, i = s.child) : i = Oo(
      i,
      s,
      b
    ), i;
  }
  function l2(i, s, c, h) {
    return Gs(), s.flags |= 256, tn(i, s, c, h), s.child;
  }
  var _g = {
    dehydrated: null,
    treeContext: null,
    retryLane: 0,
    hydrationErrors: null
  };
  function Eg(i) {
    return { baseLanes: i, cachePool: GS() };
  }
  function Cg(i, s, c) {
    return i = i !== null ? i.childLanes & ~c : 0, s && (i |= dr), i;
  }
  function s2(i, s, c) {
    var h = s.pendingProps, b = !1, S = (s.flags & 128) !== 0, j;
    if ((j = S) || (j = i !== null && i.memoizedState === null ? !1 : (Zt.current & 2) !== 0), j && (b = !0, s.flags &= -129), j = (s.flags & 32) !== 0, s.flags &= -33, i === null) {
      if (Je) {
        if (b ? pi(s) : hi(), Je) {
          var I = Ct, Z;
          if (Z = I) {
            e: {
              for (Z = I, I = Vr; Z.nodeType !== 8; ) {
                if (!I) {
                  I = null;
                  break e;
                }
                if (Z = _r(
                  Z.nextSibling
                ), Z === null) {
                  I = null;
                  break e;
                }
              }
              I = Z;
            }
            I !== null ? (s.memoizedState = {
              dehydrated: I,
              treeContext: ia !== null ? { id: xo, overflow: So } : null,
              retryLane: 536870912,
              hydrationErrors: null
            }, Z = Un(
              18,
              null,
              null,
              0
            ), Z.stateNode = I, Z.return = s, s.child = Z, bn = s, Ct = null, Z = !0) : Z = !1;
          }
          Z || sa(s);
        }
        if (I = s.memoizedState, I !== null && (I = I.dehydrated, I !== null))
          return uy(I) ? s.lanes = 32 : s.lanes = 536870912, null;
        Co(s);
      }
      return I = h.children, h = h.fallback, b ? (hi(), b = s.mode, I = Yd(
        { mode: "hidden", children: I },
        b
      ), h = oa(
        h,
        b,
        c,
        null
      ), I.return = s, h.return = s, I.sibling = h, s.child = I, b = s.child, b.memoizedState = Eg(c), b.childLanes = Cg(
        i,
        j,
        c
      ), s.memoizedState = _g, h) : (pi(s), Og(s, I));
    }
    if (Z = i.memoizedState, Z !== null && (I = Z.dehydrated, I !== null)) {
      if (S)
        s.flags & 256 ? (pi(s), s.flags &= -257, s = Ng(
          i,
          s,
          c
        )) : s.memoizedState !== null ? (hi(), s.child = i.child, s.flags |= 128, s = null) : (hi(), b = h.fallback, I = s.mode, h = Yd(
          { mode: "visible", children: h.children },
          I
        ), b = oa(
          b,
          I,
          c,
          null
        ), b.flags |= 2, h.return = s, b.return = s, h.sibling = b, s.child = h, pl(
          s,
          i.child,
          null,
          c
        ), h = s.child, h.memoizedState = Eg(c), h.childLanes = Cg(
          i,
          j,
          c
        ), s.memoizedState = _g, s = b);
      else if (pi(s), uy(I)) {
        if (j = I.nextSibling && I.nextSibling.dataset, j) var ee = j.dgst;
        j = ee, h = Error(r(419)), h.stack = "", h.digest = j, Zs({ value: h, source: null, stack: null }), s = Ng(
          i,
          s,
          c
        );
      } else if (Kt || Ws(i, s, c, !1), j = (c & i.childLanes) !== 0, Kt || j) {
        if (j = gt, j !== null && (h = c & -c, h = (h & 42) !== 0 ? 1 : Ms(h), h = (h & (j.suspendedLanes | c)) !== 0 ? 0 : h, h !== 0 && h !== Z.retryLane))
          throw Z.retryLane = h, nl(i, h), Xn(j, i, h), Jk;
        I.data === "$?" || qg(), s = Ng(
          i,
          s,
          c
        );
      } else
        I.data === "$?" ? (s.flags |= 192, s.child = i.child, s = null) : (i = Z.treeContext, Ct = _r(
          I.nextSibling
        ), bn = s, Je = !0, la = null, Vr = !1, i !== null && (sr[ur++] = xo, sr[ur++] = So, sr[ur++] = ia, xo = i.id, So = i.overflow, ia = s), s = Og(
          s,
          h.children
        ), s.flags |= 4096);
      return s;
    }
    return b ? (hi(), b = h.fallback, I = s.mode, Z = i.child, ee = Z.sibling, h = wo(Z, {
      mode: "hidden",
      children: h.children
    }), h.subtreeFlags = Z.subtreeFlags & 65011712, ee !== null ? b = wo(ee, b) : (b = oa(
      b,
      I,
      c,
      null
    ), b.flags |= 2), b.return = s, h.return = s, h.sibling = b, s.child = h, h = b, b = s.child, I = i.child.memoizedState, I === null ? I = Eg(c) : (Z = I.cachePool, Z !== null ? (ee = Gt._currentValue, Z = Z.parent !== ee ? { parent: ee, pool: ee } : Z) : Z = GS(), I = {
      baseLanes: I.baseLanes | c,
      cachePool: Z
    }), b.memoizedState = I, b.childLanes = Cg(
      i,
      j,
      c
    ), s.memoizedState = _g, h) : (pi(s), c = i.child, i = c.sibling, c = wo(c, {
      mode: "visible",
      children: h.children
    }), c.return = s, c.sibling = null, i !== null && (j = s.deletions, j === null ? (s.deletions = [i], s.flags |= 16) : j.push(i)), s.child = c, s.memoizedState = null, c);
  }
  function Og(i, s) {
    return s = Yd(
      { mode: "visible", children: s },
      i.mode
    ), s.return = i, i.child = s;
  }
  function Yd(i, s) {
    return i = Un(22, i, null, s), i.lanes = 0, i.stateNode = {
      _visibility: 1,
      _pendingMarkers: null,
      _retryCache: null,
      _transitions: null
    }, i;
  }
  function Ng(i, s, c) {
    return pl(s, i.child, null, c), i = Og(
      s,
      s.pendingProps.children
    ), i.flags |= 2, s.memoizedState = null, i;
  }
  function u2(i, s, c) {
    i.lanes |= s;
    var h = i.alternate;
    h !== null && (h.lanes |= s), qm(i.return, s, c);
  }
  function Mg(i, s, c, h, b) {
    var S = i.memoizedState;
    S === null ? i.memoizedState = {
      isBackwards: s,
      rendering: null,
      renderingStartTime: 0,
      last: h,
      tail: c,
      tailMode: b
    } : (S.isBackwards = s, S.rendering = null, S.renderingStartTime = 0, S.last = h, S.tail = c, S.tailMode = b);
  }
  function c2(i, s, c) {
    var h = s.pendingProps, b = h.revealOrder, S = h.tail;
    if (tn(i, s, h.children, c), h = Zt.current, (h & 2) !== 0)
      h = h & 1 | 2, s.flags |= 128;
    else {
      if (i !== null && (i.flags & 128) !== 0)
        e: for (i = s.child; i !== null; ) {
          if (i.tag === 13)
            i.memoizedState !== null && u2(i, c, s);
          else if (i.tag === 19)
            u2(i, c, s);
          else if (i.child !== null) {
            i.child.return = i, i = i.child;
            continue;
          }
          if (i === s) break e;
          for (; i.sibling === null; ) {
            if (i.return === null || i.return === s)
              break e;
            i = i.return;
          }
          i.sibling.return = i.return, i = i.sibling;
        }
      h &= 1;
    }
    switch (P(Zt, h), b) {
      case "forwards":
        for (c = s.child, b = null; c !== null; )
          i = c.alternate, i !== null && Hd(i) === null && (b = c), c = c.sibling;
        c = b, c === null ? (b = s.child, s.child = null) : (b = c.sibling, c.sibling = null), Mg(
          s,
          !1,
          b,
          c,
          S
        );
        break;
      case "backwards":
        for (c = null, b = s.child, s.child = null; b !== null; ) {
          if (i = b.alternate, i !== null && Hd(i) === null) {
            s.child = b;
            break;
          }
          i = b.sibling, b.sibling = c, c = b, b = i;
        }
        Mg(
          s,
          !0,
          c,
          null,
          S
        );
        break;
      case "together":
        Mg(s, !1, null, null, void 0);
        break;
      default:
        s.memoizedState = null;
    }
    return s.child;
  }
  function Oo(i, s, c) {
    if (i !== null && (s.dependencies = i.dependencies), bi |= s.lanes, (c & s.childLanes) === 0)
      if (i !== null) {
        if (Ws(
          i,
          s,
          c,
          !1
        ), (c & s.childLanes) === 0)
          return null;
      } else return null;
    if (i !== null && s.child !== i.child)
      throw Error(r(153));
    if (s.child !== null) {
      for (i = s.child, c = wo(i, i.pendingProps), s.child = c, c.return = s; i.sibling !== null; )
        i = i.sibling, c = c.sibling = wo(i, i.pendingProps), c.return = s;
      c.sibling = null;
    }
    return s.child;
  }
  function Ag(i, s) {
    return (i.lanes & s) !== 0 ? !0 : (i = i.dependencies, !!(i !== null && Ed(i)));
  }
  function HT(i, s, c) {
    switch (s.tag) {
      case 3:
        he(s, s.stateNode.containerInfo), si(s, Gt, i.memoizedState.cache), Gs();
        break;
      case 27:
      case 5:
        Ee(s);
        break;
      case 4:
        he(s, s.stateNode.containerInfo);
        break;
      case 10:
        si(
          s,
          s.type,
          s.memoizedProps.value
        );
        break;
      case 13:
        var h = s.memoizedState;
        if (h !== null)
          return h.dehydrated !== null ? (pi(s), s.flags |= 128, null) : (c & s.child.childLanes) !== 0 ? s2(i, s, c) : (pi(s), i = Oo(
            i,
            s,
            c
          ), i !== null ? i.sibling : null);
        pi(s);
        break;
      case 19:
        var b = (i.flags & 128) !== 0;
        if (h = (c & s.childLanes) !== 0, h || (Ws(
          i,
          s,
          c,
          !1
        ), h = (c & s.childLanes) !== 0), b) {
          if (h)
            return c2(
              i,
              s,
              c
            );
          s.flags |= 128;
        }
        if (b = s.memoizedState, b !== null && (b.rendering = null, b.tail = null, b.lastEffect = null), P(Zt, Zt.current), h) break;
        return null;
      case 22:
      case 23:
        return s.lanes = 0, r2(i, s, c);
      case 24:
        si(s, Gt, i.memoizedState.cache);
    }
    return Oo(i, s, c);
  }
  function d2(i, s, c) {
    if (i !== null)
      if (i.memoizedProps !== s.pendingProps)
        Kt = !0;
      else {
        if (!Ag(i, c) && (s.flags & 128) === 0)
          return Kt = !1, HT(
            i,
            s,
            c
          );
        Kt = (i.flags & 131072) !== 0;
      }
    else
      Kt = !1, Je && (s.flags & 1048576) !== 0 && HS(s, _d, s.index);
    switch (s.lanes = 0, s.tag) {
      case 16:
        e: {
          i = s.pendingProps;
          var h = s.elementType, b = h._init;
          if (h = b(h._payload), s.type = h, typeof h == "function")
            Bm(h) ? (i = pa(h, i), s.tag = 1, s = a2(
              null,
              s,
              h,
              i,
              c
            )) : (s.tag = 0, s = kg(
              null,
              s,
              h,
              i,
              c
            ));
          else {
            if (h != null) {
              if (b = h.$$typeof, b === A) {
                s.tag = 11, s = e2(
                  null,
                  s,
                  h,
                  i,
                  c
                );
                break e;
              } else if (b === T) {
                s.tag = 14, s = t2(
                  null,
                  s,
                  h,
                  i,
                  c
                );
                break e;
              }
            }
            throw s = z(h) || h, Error(r(306, s, ""));
          }
        }
        return s;
      case 0:
        return kg(
          i,
          s,
          s.type,
          s.pendingProps,
          c
        );
      case 1:
        return h = s.type, b = pa(
          h,
          s.pendingProps
        ), a2(
          i,
          s,
          h,
          b,
          c
        );
      case 3:
        e: {
          if (he(
            s,
            s.stateNode.containerInfo
          ), i === null) throw Error(r(387));
          h = s.pendingProps;
          var S = s.memoizedState;
          b = S.element, Jm(i, s), ru(s, h, null, c);
          var j = s.memoizedState;
          if (h = j.cache, si(s, Gt, h), h !== S.cache && Xm(
            s,
            [Gt],
            c,
            !0
          ), nu(), h = j.element, S.isDehydrated)
            if (S = {
              element: h,
              isDehydrated: !1,
              cache: j.cache
            }, s.updateQueue.baseState = S, s.memoizedState = S, s.flags & 256) {
              s = l2(
                i,
                s,
                h,
                c
              );
              break e;
            } else if (h !== b) {
              b = ar(
                Error(r(424)),
                s
              ), Zs(b), s = l2(
                i,
                s,
                h,
                c
              );
              break e;
            } else {
              switch (i = s.stateNode.containerInfo, i.nodeType) {
                case 9:
                  i = i.body;
                  break;
                default:
                  i = i.nodeName === "HTML" ? i.ownerDocument.body : i;
              }
              for (Ct = _r(i.firstChild), bn = s, Je = !0, la = null, Vr = !0, c = Fk(
                s,
                null,
                h,
                c
              ), s.child = c; c; )
                c.flags = c.flags & -3 | 4096, c = c.sibling;
            }
          else {
            if (Gs(), h === b) {
              s = Oo(
                i,
                s,
                c
              );
              break e;
            }
            tn(
              i,
              s,
              h,
              c
            );
          }
          s = s.child;
        }
        return s;
      case 26:
        return $d(i, s), i === null ? (c = m_(
          s.type,
          null,
          s.pendingProps,
          null
        )) ? s.memoizedState = c : Je || (c = s.type, i = s.pendingProps, h = af(
          ae.current
        ).createElement(c), h[Wt] = s, h[un] = i, rn(h, c, i), It(h), s.stateNode = h) : s.memoizedState = m_(
          s.type,
          i.memoizedProps,
          s.pendingProps,
          i.memoizedState
        ), null;
      case 27:
        return Ee(s), i === null && Je && (h = s.stateNode = f_(
          s.type,
          s.pendingProps,
          ae.current
        ), bn = s, Vr = !0, b = Ct, ki(s.type) ? (cy = b, Ct = _r(
          h.firstChild
        )) : Ct = b), tn(
          i,
          s,
          s.pendingProps.children,
          c
        ), $d(i, s), i === null && (s.flags |= 4194304), s.child;
      case 5:
        return i === null && Je && ((b = h = Ct) && (h = m6(
          h,
          s.type,
          s.pendingProps,
          Vr
        ), h !== null ? (s.stateNode = h, bn = s, Ct = _r(
          h.firstChild
        ), Vr = !1, b = !0) : b = !1), b || sa(s)), Ee(s), b = s.type, S = s.pendingProps, j = i !== null ? i.memoizedProps : null, h = S.children, ay(b, S) ? h = null : j !== null && ay(b, j) && (s.flags |= 32), s.memoizedState !== null && (b = ig(
          i,
          s,
          DT,
          null,
          null,
          c
        ), Eu._currentValue = b), $d(i, s), tn(i, s, h, c), s.child;
      case 6:
        return i === null && Je && ((i = c = Ct) && (c = g6(
          c,
          s.pendingProps,
          Vr
        ), c !== null ? (s.stateNode = c, bn = s, Ct = null, i = !0) : i = !1), i || sa(s)), null;
      case 13:
        return s2(i, s, c);
      case 4:
        return he(
          s,
          s.stateNode.containerInfo
        ), h = s.pendingProps, i === null ? s.child = pl(
          s,
          null,
          h,
          c
        ) : tn(
          i,
          s,
          h,
          c
        ), s.child;
      case 11:
        return e2(
          i,
          s,
          s.type,
          s.pendingProps,
          c
        );
      case 7:
        return tn(
          i,
          s,
          s.pendingProps,
          c
        ), s.child;
      case 8:
        return tn(
          i,
          s,
          s.pendingProps.children,
          c
        ), s.child;
      case 12:
        return tn(
          i,
          s,
          s.pendingProps.children,
          c
        ), s.child;
      case 10:
        return h = s.pendingProps, si(s, s.type, h.value), tn(
          i,
          s,
          h.children,
          c
        ), s.child;
      case 9:
        return b = s.type._context, h = s.pendingProps.children, ca(s), b = cn(b), h = h(b), s.flags |= 1, tn(i, s, h, c), s.child;
      case 14:
        return t2(
          i,
          s,
          s.type,
          s.pendingProps,
          c
        );
      case 15:
        return n2(
          i,
          s,
          s.type,
          s.pendingProps,
          c
        );
      case 19:
        return c2(i, s, c);
      case 31:
        return h = s.pendingProps, c = s.mode, h = {
          mode: h.mode,
          children: h.children
        }, i === null ? (c = Yd(
          h,
          c
        ), c.ref = s.ref, s.child = c, c.return = s, s = c) : (c = wo(i.child, h), c.ref = s.ref, s.child = c, c.return = s, s = c), s;
      case 22:
        return r2(i, s, c);
      case 24:
        return ca(s), h = cn(Gt), i === null ? (b = Wm(), b === null && (b = gt, S = Gm(), b.pooledCache = S, S.refCount++, S !== null && (b.pooledCacheLanes |= c), b = S), s.memoizedState = {
          parent: h,
          cache: b
        }, Qm(s), si(s, Gt, b)) : ((i.lanes & c) !== 0 && (Jm(i, s), ru(s, null, null, c), nu()), b = i.memoizedState, S = s.memoizedState, b.parent !== h ? (b = { parent: h, cache: h }, s.memoizedState = b, s.lanes === 0 && (s.memoizedState = s.updateQueue.baseState = b), si(s, Gt, h)) : (h = S.cache, si(s, Gt, h), h !== b.cache && Xm(
          s,
          [Gt],
          c,
          !0
        ))), tn(
          i,
          s,
          s.pendingProps.children,
          c
        ), s.child;
      case 29:
        throw s.pendingProps;
    }
    throw Error(r(156, s.tag));
  }
  function No(i) {
    i.flags |= 4;
  }
  function f2(i, s) {
    if (s.type !== "stylesheet" || (s.state.loading & 4) !== 0)
      i.flags &= -16777217;
    else if (i.flags |= 16777216, !w_(s)) {
      if (s = cr.current, s !== null && ((We & 4194048) === We ? Hr !== null : (We & 62914560) !== We && (We & 536870912) === 0 || s !== Hr))
        throw eu = Km, ZS;
      i.flags |= 8192;
    }
  }
  function qd(i, s) {
    s !== null && (i.flags |= 4), i.flags & 16384 && (s = i.tag !== 22 ? ed() : 536870912, i.lanes |= s, yl |= s);
  }
  function cu(i, s) {
    if (!Je)
      switch (i.tailMode) {
        case "hidden":
          s = i.tail;
          for (var c = null; s !== null; )
            s.alternate !== null && (c = s), s = s.sibling;
          c === null ? i.tail = null : c.sibling = null;
          break;
        case "collapsed":
          c = i.tail;
          for (var h = null; c !== null; )
            c.alternate !== null && (h = c), c = c.sibling;
          h === null ? s || i.tail === null ? i.tail = null : i.tail.sibling = null : h.sibling = null;
      }
  }
  function Et(i) {
    var s = i.alternate !== null && i.alternate.child === i.child, c = 0, h = 0;
    if (s)
      for (var b = i.child; b !== null; )
        c |= b.lanes | b.childLanes, h |= b.subtreeFlags & 65011712, h |= b.flags & 65011712, b.return = i, b = b.sibling;
    else
      for (b = i.child; b !== null; )
        c |= b.lanes | b.childLanes, h |= b.subtreeFlags, h |= b.flags, b.return = i, b = b.sibling;
    return i.subtreeFlags |= h, i.childLanes = c, s;
  }
  function UT(i, s, c) {
    var h = s.pendingProps;
    switch (Fm(s), s.tag) {
      case 31:
      case 16:
      case 15:
      case 0:
      case 11:
      case 7:
      case 8:
      case 12:
      case 9:
      case 14:
        return Et(s), null;
      case 1:
        return Et(s), null;
      case 3:
        return c = s.stateNode, h = null, i !== null && (h = i.memoizedState.cache), s.memoizedState.cache !== h && (s.flags |= 2048), _o(Gt), ye(), c.pendingContext && (c.context = c.pendingContext, c.pendingContext = null), (i === null || i.child === null) && (Xs(s) ? No(s) : i === null || i.memoizedState.isDehydrated && (s.flags & 256) === 0 || (s.flags |= 1024, $S())), Et(s), null;
      case 26:
        return c = s.memoizedState, i === null ? (No(s), c !== null ? (Et(s), f2(s, c)) : (Et(s), s.flags &= -16777217)) : c ? c !== i.memoizedState ? (No(s), Et(s), f2(s, c)) : (Et(s), s.flags &= -16777217) : (i.memoizedProps !== h && No(s), Et(s), s.flags &= -16777217), null;
      case 27:
        we(s), c = ae.current;
        var b = s.type;
        if (i !== null && s.stateNode != null)
          i.memoizedProps !== h && No(s);
        else {
          if (!h) {
            if (s.stateNode === null)
              throw Error(r(166));
            return Et(s), null;
          }
          i = te.current, Xs(s) ? US(s) : (i = f_(b, h, c), s.stateNode = i, No(s));
        }
        return Et(s), null;
      case 5:
        if (we(s), c = s.type, i !== null && s.stateNode != null)
          i.memoizedProps !== h && No(s);
        else {
          if (!h) {
            if (s.stateNode === null)
              throw Error(r(166));
            return Et(s), null;
          }
          if (i = te.current, Xs(s))
            US(s);
          else {
            switch (b = af(
              ae.current
            ), i) {
              case 1:
                i = b.createElementNS(
                  "http://www.w3.org/2000/svg",
                  c
                );
                break;
              case 2:
                i = b.createElementNS(
                  "http://www.w3.org/1998/Math/MathML",
                  c
                );
                break;
              default:
                switch (c) {
                  case "svg":
                    i = b.createElementNS(
                      "http://www.w3.org/2000/svg",
                      c
                    );
                    break;
                  case "math":
                    i = b.createElementNS(
                      "http://www.w3.org/1998/Math/MathML",
                      c
                    );
                    break;
                  case "script":
                    i = b.createElement("div"), i.innerHTML = "<script><\/script>", i = i.removeChild(i.firstChild);
                    break;
                  case "select":
                    i = typeof h.is == "string" ? b.createElement("select", { is: h.is }) : b.createElement("select"), h.multiple ? i.multiple = !0 : h.size && (i.size = h.size);
                    break;
                  default:
                    i = typeof h.is == "string" ? b.createElement(c, { is: h.is }) : b.createElement(c);
                }
            }
            i[Wt] = s, i[un] = h;
            e: for (b = s.child; b !== null; ) {
              if (b.tag === 5 || b.tag === 6)
                i.appendChild(b.stateNode);
              else if (b.tag !== 4 && b.tag !== 27 && b.child !== null) {
                b.child.return = b, b = b.child;
                continue;
              }
              if (b === s) break e;
              for (; b.sibling === null; ) {
                if (b.return === null || b.return === s)
                  break e;
                b = b.return;
              }
              b.sibling.return = b.return, b = b.sibling;
            }
            s.stateNode = i;
            e: switch (rn(i, c, h), c) {
              case "button":
              case "input":
              case "select":
              case "textarea":
                i = !!h.autoFocus;
                break e;
              case "img":
                i = !0;
                break e;
              default:
                i = !1;
            }
            i && No(s);
          }
        }
        return Et(s), s.flags &= -16777217, null;
      case 6:
        if (i && s.stateNode != null)
          i.memoizedProps !== h && No(s);
        else {
          if (typeof h != "string" && s.stateNode === null)
            throw Error(r(166));
          if (i = ae.current, Xs(s)) {
            if (i = s.stateNode, c = s.memoizedProps, h = null, b = bn, b !== null)
              switch (b.tag) {
                case 27:
                case 5:
                  h = b.memoizedProps;
              }
            i[Wt] = s, i = !!(i.nodeValue === c || h !== null && h.suppressHydrationWarning === !0 || i_(i.nodeValue, c)), i || sa(s);
          } else
            i = af(i).createTextNode(
              h
            ), i[Wt] = s, s.stateNode = i;
        }
        return Et(s), null;
      case 13:
        if (h = s.memoizedState, i === null || i.memoizedState !== null && i.memoizedState.dehydrated !== null) {
          if (b = Xs(s), h !== null && h.dehydrated !== null) {
            if (i === null) {
              if (!b) throw Error(r(318));
              if (b = s.memoizedState, b = b !== null ? b.dehydrated : null, !b) throw Error(r(317));
              b[Wt] = s;
            } else
              Gs(), (s.flags & 128) === 0 && (s.memoizedState = null), s.flags |= 4;
            Et(s), b = !1;
          } else
            b = $S(), i !== null && i.memoizedState !== null && (i.memoizedState.hydrationErrors = b), b = !0;
          if (!b)
            return s.flags & 256 ? (Co(s), s) : (Co(s), null);
        }
        if (Co(s), (s.flags & 128) !== 0)
          return s.lanes = c, s;
        if (c = h !== null, i = i !== null && i.memoizedState !== null, c) {
          h = s.child, b = null, h.alternate !== null && h.alternate.memoizedState !== null && h.alternate.memoizedState.cachePool !== null && (b = h.alternate.memoizedState.cachePool.pool);
          var S = null;
          h.memoizedState !== null && h.memoizedState.cachePool !== null && (S = h.memoizedState.cachePool.pool), S !== b && (h.flags |= 2048);
        }
        return c !== i && c && (s.child.flags |= 8192), qd(s, s.updateQueue), Et(s), null;
      case 4:
        return ye(), i === null && ty(s.stateNode.containerInfo), Et(s), null;
      case 10:
        return _o(s.type), Et(s), null;
      case 19:
        if (Q(Zt), b = s.memoizedState, b === null) return Et(s), null;
        if (h = (s.flags & 128) !== 0, S = b.rendering, S === null)
          if (h) cu(b, !1);
          else {
            if (Ot !== 0 || i !== null && (i.flags & 128) !== 0)
              for (i = s.child; i !== null; ) {
                if (S = Hd(i), S !== null) {
                  for (s.flags |= 128, cu(b, !1), i = S.updateQueue, s.updateQueue = i, qd(s, i), s.subtreeFlags = 0, i = c, c = s.child; c !== null; )
                    VS(c, i), c = c.sibling;
                  return P(
                    Zt,
                    Zt.current & 1 | 2
                  ), s.child;
                }
                i = i.sibling;
              }
            b.tail !== null && lt() > Zd && (s.flags |= 128, h = !0, cu(b, !1), s.lanes = 4194304);
          }
        else {
          if (!h)
            if (i = Hd(S), i !== null) {
              if (s.flags |= 128, h = !0, i = i.updateQueue, s.updateQueue = i, qd(s, i), cu(b, !0), b.tail === null && b.tailMode === "hidden" && !S.alternate && !Je)
                return Et(s), null;
            } else
              2 * lt() - b.renderingStartTime > Zd && c !== 536870912 && (s.flags |= 128, h = !0, cu(b, !1), s.lanes = 4194304);
          b.isBackwards ? (S.sibling = s.child, s.child = S) : (i = b.last, i !== null ? i.sibling = S : s.child = S, b.last = S);
        }
        return b.tail !== null ? (s = b.tail, b.rendering = s, b.tail = s.sibling, b.renderingStartTime = lt(), s.sibling = null, i = Zt.current, P(Zt, h ? i & 1 | 2 : i & 1), s) : (Et(s), null);
      case 22:
      case 23:
        return Co(s), rg(), h = s.memoizedState !== null, i !== null ? i.memoizedState !== null !== h && (s.flags |= 8192) : h && (s.flags |= 8192), h ? (c & 536870912) !== 0 && (s.flags & 128) === 0 && (Et(s), s.subtreeFlags & 6 && (s.flags |= 8192)) : Et(s), c = s.updateQueue, c !== null && qd(s, c.retryQueue), c = null, i !== null && i.memoizedState !== null && i.memoizedState.cachePool !== null && (c = i.memoizedState.cachePool.pool), h = null, s.memoizedState !== null && s.memoizedState.cachePool !== null && (h = s.memoizedState.cachePool.pool), h !== c && (s.flags |= 2048), i !== null && Q(da), null;
      case 24:
        return c = null, i !== null && (c = i.memoizedState.cache), s.memoizedState.cache !== c && (s.flags |= 2048), _o(Gt), Et(s), null;
      case 25:
        return null;
      case 30:
        return null;
    }
    throw Error(r(156, s.tag));
  }
  function FT(i, s) {
    switch (Fm(s), s.tag) {
      case 1:
        return i = s.flags, i & 65536 ? (s.flags = i & -65537 | 128, s) : null;
      case 3:
        return _o(Gt), ye(), i = s.flags, (i & 65536) !== 0 && (i & 128) === 0 ? (s.flags = i & -65537 | 128, s) : null;
      case 26:
      case 27:
      case 5:
        return we(s), null;
      case 13:
        if (Co(s), i = s.memoizedState, i !== null && i.dehydrated !== null) {
          if (s.alternate === null)
            throw Error(r(340));
          Gs();
        }
        return i = s.flags, i & 65536 ? (s.flags = i & -65537 | 128, s) : null;
      case 19:
        return Q(Zt), null;
      case 4:
        return ye(), null;
      case 10:
        return _o(s.type), null;
      case 22:
      case 23:
        return Co(s), rg(), i !== null && Q(da), i = s.flags, i & 65536 ? (s.flags = i & -65537 | 128, s) : null;
      case 24:
        return _o(Gt), null;
      case 25:
        return null;
      default:
        return null;
    }
  }
  function p2(i, s) {
    switch (Fm(s), s.tag) {
      case 3:
        _o(Gt), ye();
        break;
      case 26:
      case 27:
      case 5:
        we(s);
        break;
      case 4:
        ye();
        break;
      case 13:
        Co(s);
        break;
      case 19:
        Q(Zt);
        break;
      case 10:
        _o(s.type);
        break;
      case 22:
      case 23:
        Co(s), rg(), i !== null && Q(da);
        break;
      case 24:
        _o(Gt);
    }
  }
  function du(i, s) {
    try {
      var c = s.updateQueue, h = c !== null ? c.lastEffect : null;
      if (h !== null) {
        var b = h.next;
        c = b;
        do {
          if ((c.tag & i) === i) {
            h = void 0;
            var S = c.create, j = c.inst;
            h = S(), j.destroy = h;
          }
          c = c.next;
        } while (c !== b);
      }
    } catch (I) {
      ft(s, s.return, I);
    }
  }
  function mi(i, s, c) {
    try {
      var h = s.updateQueue, b = h !== null ? h.lastEffect : null;
      if (b !== null) {
        var S = b.next;
        h = S;
        do {
          if ((h.tag & i) === i) {
            var j = h.inst, I = j.destroy;
            if (I !== void 0) {
              j.destroy = void 0, b = s;
              var Z = c, ee = I;
              try {
                ee();
              } catch (ue) {
                ft(
                  b,
                  Z,
                  ue
                );
              }
            }
          }
          h = h.next;
        } while (h !== S);
      }
    } catch (ue) {
      ft(s, s.return, ue);
    }
  }
  function h2(i) {
    var s = i.updateQueue;
    if (s !== null) {
      var c = i.stateNode;
      try {
        tk(s, c);
      } catch (h) {
        ft(i, i.return, h);
      }
    }
  }
  function m2(i, s, c) {
    c.props = pa(
      i.type,
      i.memoizedProps
    ), c.state = i.memoizedState;
    try {
      c.componentWillUnmount();
    } catch (h) {
      ft(i, s, h);
    }
  }
  function fu(i, s) {
    try {
      var c = i.ref;
      if (c !== null) {
        switch (i.tag) {
          case 26:
          case 27:
          case 5:
            var h = i.stateNode;
            break;
          case 30:
            h = i.stateNode;
            break;
          default:
            h = i.stateNode;
        }
        typeof c == "function" ? i.refCleanup = c(h) : c.current = h;
      }
    } catch (b) {
      ft(i, s, b);
    }
  }
  function Ur(i, s) {
    var c = i.ref, h = i.refCleanup;
    if (c !== null)
      if (typeof h == "function")
        try {
          h();
        } catch (b) {
          ft(i, s, b);
        } finally {
          i.refCleanup = null, i = i.alternate, i != null && (i.refCleanup = null);
        }
      else if (typeof c == "function")
        try {
          c(null);
        } catch (b) {
          ft(i, s, b);
        }
      else c.current = null;
  }
  function g2(i) {
    var s = i.type, c = i.memoizedProps, h = i.stateNode;
    try {
      e: switch (s) {
        case "button":
        case "input":
        case "select":
        case "textarea":
          c.autoFocus && h.focus();
          break e;
        case "img":
          c.src ? h.src = c.src : c.srcSet && (h.srcset = c.srcSet);
      }
    } catch (b) {
      ft(i, i.return, b);
    }
  }
  function Rg(i, s, c) {
    try {
      var h = i.stateNode;
      c6(h, i.type, c, s), h[un] = s;
    } catch (b) {
      ft(i, i.return, b);
    }
  }
  function y2(i) {
    return i.tag === 5 || i.tag === 3 || i.tag === 26 || i.tag === 27 && ki(i.type) || i.tag === 4;
  }
  function jg(i) {
    e: for (; ; ) {
      for (; i.sibling === null; ) {
        if (i.return === null || y2(i.return)) return null;
        i = i.return;
      }
      for (i.sibling.return = i.return, i = i.sibling; i.tag !== 5 && i.tag !== 6 && i.tag !== 18; ) {
        if (i.tag === 27 && ki(i.type) || i.flags & 2 || i.child === null || i.tag === 4) continue e;
        i.child.return = i, i = i.child;
      }
      if (!(i.flags & 2)) return i.stateNode;
    }
  }
  function Dg(i, s, c) {
    var h = i.tag;
    if (h === 5 || h === 6)
      i = i.stateNode, s ? (c.nodeType === 9 ? c.body : c.nodeName === "HTML" ? c.ownerDocument.body : c).insertBefore(i, s) : (s = c.nodeType === 9 ? c.body : c.nodeName === "HTML" ? c.ownerDocument.body : c, s.appendChild(i), c = c._reactRootContainer, c != null || s.onclick !== null || (s.onclick = of));
    else if (h !== 4 && (h === 27 && ki(i.type) && (c = i.stateNode, s = null), i = i.child, i !== null))
      for (Dg(i, s, c), i = i.sibling; i !== null; )
        Dg(i, s, c), i = i.sibling;
  }
  function Xd(i, s, c) {
    var h = i.tag;
    if (h === 5 || h === 6)
      i = i.stateNode, s ? c.insertBefore(i, s) : c.appendChild(i);
    else if (h !== 4 && (h === 27 && ki(i.type) && (c = i.stateNode), i = i.child, i !== null))
      for (Xd(i, s, c), i = i.sibling; i !== null; )
        Xd(i, s, c), i = i.sibling;
  }
  function v2(i) {
    var s = i.stateNode, c = i.memoizedProps;
    try {
      for (var h = i.type, b = s.attributes; b.length; )
        s.removeAttributeNode(b[0]);
      rn(s, h, c), s[Wt] = i, s[un] = c;
    } catch (S) {
      ft(i, i.return, S);
    }
  }
  var Mo = !1, Dt = !1, Tg = !1, b2 = typeof WeakSet == "function" ? WeakSet : Set, Qt = null;
  function $T(i, s) {
    if (i = i.containerInfo, oy = ff, i = AS(i), jm(i)) {
      if ("selectionStart" in i)
        var c = {
          start: i.selectionStart,
          end: i.selectionEnd
        };
      else
        e: {
          c = (c = i.ownerDocument) && c.defaultView || window;
          var h = c.getSelection && c.getSelection();
          if (h && h.rangeCount !== 0) {
            c = h.anchorNode;
            var b = h.anchorOffset, S = h.focusNode;
            h = h.focusOffset;
            try {
              c.nodeType, S.nodeType;
            } catch {
              c = null;
              break e;
            }
            var j = 0, I = -1, Z = -1, ee = 0, ue = 0, de = i, ne = null;
            t: for (; ; ) {
              for (var re; de !== c || b !== 0 && de.nodeType !== 3 || (I = j + b), de !== S || h !== 0 && de.nodeType !== 3 || (Z = j + h), de.nodeType === 3 && (j += de.nodeValue.length), (re = de.firstChild) !== null; )
                ne = de, de = re;
              for (; ; ) {
                if (de === i) break t;
                if (ne === c && ++ee === b && (I = j), ne === S && ++ue === h && (Z = j), (re = de.nextSibling) !== null) break;
                de = ne, ne = de.parentNode;
              }
              de = re;
            }
            c = I === -1 || Z === -1 ? null : { start: I, end: Z };
          } else c = null;
        }
      c = c || { start: 0, end: 0 };
    } else c = null;
    for (iy = { focusedElem: i, selectionRange: c }, ff = !1, Qt = s; Qt !== null; )
      if (s = Qt, i = s.child, (s.subtreeFlags & 1024) !== 0 && i !== null)
        i.return = s, Qt = i;
      else
        for (; Qt !== null; ) {
          switch (s = Qt, S = s.alternate, i = s.flags, s.tag) {
            case 0:
              break;
            case 11:
            case 15:
              break;
            case 1:
              if ((i & 1024) !== 0 && S !== null) {
                i = void 0, c = s, b = S.memoizedProps, S = S.memoizedState, h = c.stateNode;
                try {
                  var ze = pa(
                    c.type,
                    b,
                    c.elementType === c.type
                  );
                  i = h.getSnapshotBeforeUpdate(
                    ze,
                    S
                  ), h.__reactInternalSnapshotBeforeUpdate = i;
                } catch (Re) {
                  ft(
                    c,
                    c.return,
                    Re
                  );
                }
              }
              break;
            case 3:
              if ((i & 1024) !== 0) {
                if (i = s.stateNode.containerInfo, c = i.nodeType, c === 9)
                  sy(i);
                else if (c === 1)
                  switch (i.nodeName) {
                    case "HEAD":
                    case "HTML":
                    case "BODY":
                      sy(i);
                      break;
                    default:
                      i.textContent = "";
                  }
              }
              break;
            case 5:
            case 26:
            case 27:
            case 6:
            case 4:
            case 17:
              break;
            default:
              if ((i & 1024) !== 0) throw Error(r(163));
          }
          if (i = s.sibling, i !== null) {
            i.return = s.return, Qt = i;
            break;
          }
          Qt = s.return;
        }
  }
  function w2(i, s, c) {
    var h = c.flags;
    switch (c.tag) {
      case 0:
      case 11:
      case 15:
        gi(i, c), h & 4 && du(5, c);
        break;
      case 1:
        if (gi(i, c), h & 4)
          if (i = c.stateNode, s === null)
            try {
              i.componentDidMount();
            } catch (j) {
              ft(c, c.return, j);
            }
          else {
            var b = pa(
              c.type,
              s.memoizedProps
            );
            s = s.memoizedState;
            try {
              i.componentDidUpdate(
                b,
                s,
                i.__reactInternalSnapshotBeforeUpdate
              );
            } catch (j) {
              ft(
                c,
                c.return,
                j
              );
            }
          }
        h & 64 && h2(c), h & 512 && fu(c, c.return);
        break;
      case 3:
        if (gi(i, c), h & 64 && (i = c.updateQueue, i !== null)) {
          if (s = null, c.child !== null)
            switch (c.child.tag) {
              case 27:
              case 5:
                s = c.child.stateNode;
                break;
              case 1:
                s = c.child.stateNode;
            }
          try {
            tk(i, s);
          } catch (j) {
            ft(c, c.return, j);
          }
        }
        break;
      case 27:
        s === null && h & 4 && v2(c);
      case 26:
      case 5:
        gi(i, c), s === null && h & 4 && g2(c), h & 512 && fu(c, c.return);
        break;
      case 12:
        gi(i, c);
        break;
      case 13:
        gi(i, c), h & 4 && k2(i, c), h & 64 && (i = c.memoizedState, i !== null && (i = i.dehydrated, i !== null && (c = JT.bind(
          null,
          c
        ), y6(i, c))));
        break;
      case 22:
        if (h = c.memoizedState !== null || Mo, !h) {
          s = s !== null && s.memoizedState !== null || Dt, b = Mo;
          var S = Dt;
          Mo = h, (Dt = s) && !S ? yi(
            i,
            c,
            (c.subtreeFlags & 8772) !== 0
          ) : gi(i, c), Mo = b, Dt = S;
        }
        break;
      case 30:
        break;
      default:
        gi(i, c);
    }
  }
  function x2(i) {
    var s = i.alternate;
    s !== null && (i.alternate = null, x2(s)), i.child = null, i.deletions = null, i.sibling = null, i.tag === 5 && (s = i.stateNode, s !== null && js(s)), i.stateNode = null, i.return = null, i.dependencies = null, i.memoizedProps = null, i.memoizedState = null, i.pendingProps = null, i.stateNode = null, i.updateQueue = null;
  }
  var wt = null, Rn = !1;
  function Ao(i, s, c) {
    for (c = c.child; c !== null; )
      S2(i, s, c), c = c.sibling;
  }
  function S2(i, s, c) {
    if (pe && typeof pe.onCommitFiberUnmount == "function")
      try {
        pe.onCommitFiberUnmount(le, c);
      } catch {
      }
    switch (c.tag) {
      case 26:
        Dt || Ur(c, s), Ao(
          i,
          s,
          c
        ), c.memoizedState ? c.memoizedState.count-- : c.stateNode && (c = c.stateNode, c.parentNode.removeChild(c));
        break;
      case 27:
        Dt || Ur(c, s);
        var h = wt, b = Rn;
        ki(c.type) && (wt = c.stateNode, Rn = !1), Ao(
          i,
          s,
          c
        ), xu(c.stateNode), wt = h, Rn = b;
        break;
      case 5:
        Dt || Ur(c, s);
      case 6:
        if (h = wt, b = Rn, wt = null, Ao(
          i,
          s,
          c
        ), wt = h, Rn = b, wt !== null)
          if (Rn)
            try {
              (wt.nodeType === 9 ? wt.body : wt.nodeName === "HTML" ? wt.ownerDocument.body : wt).removeChild(c.stateNode);
            } catch (S) {
              ft(
                c,
                s,
                S
              );
            }
          else
            try {
              wt.removeChild(c.stateNode);
            } catch (S) {
              ft(
                c,
                s,
                S
              );
            }
        break;
      case 18:
        wt !== null && (Rn ? (i = wt, c_(
          i.nodeType === 9 ? i.body : i.nodeName === "HTML" ? i.ownerDocument.body : i,
          c.stateNode
        ), Mu(i)) : c_(wt, c.stateNode));
        break;
      case 4:
        h = wt, b = Rn, wt = c.stateNode.containerInfo, Rn = !0, Ao(
          i,
          s,
          c
        ), wt = h, Rn = b;
        break;
      case 0:
      case 11:
      case 14:
      case 15:
        Dt || mi(2, c, s), Dt || mi(4, c, s), Ao(
          i,
          s,
          c
        );
        break;
      case 1:
        Dt || (Ur(c, s), h = c.stateNode, typeof h.componentWillUnmount == "function" && m2(
          c,
          s,
          h
        )), Ao(
          i,
          s,
          c
        );
        break;
      case 21:
        Ao(
          i,
          s,
          c
        );
        break;
      case 22:
        Dt = (h = Dt) || c.memoizedState !== null, Ao(
          i,
          s,
          c
        ), Dt = h;
        break;
      default:
        Ao(
          i,
          s,
          c
        );
    }
  }
  function k2(i, s) {
    if (s.memoizedState === null && (i = s.alternate, i !== null && (i = i.memoizedState, i !== null && (i = i.dehydrated, i !== null))))
      try {
        Mu(i);
      } catch (c) {
        ft(s, s.return, c);
      }
  }
  function YT(i) {
    switch (i.tag) {
      case 13:
      case 19:
        var s = i.stateNode;
        return s === null && (s = i.stateNode = new b2()), s;
      case 22:
        return i = i.stateNode, s = i._retryCache, s === null && (s = i._retryCache = new b2()), s;
      default:
        throw Error(r(435, i.tag));
    }
  }
  function zg(i, s) {
    var c = YT(i);
    s.forEach(function(h) {
      var b = e6.bind(null, i, h);
      c.has(h) || (c.add(h), h.then(b, b));
    });
  }
  function Fn(i, s) {
    var c = s.deletions;
    if (c !== null)
      for (var h = 0; h < c.length; h++) {
        var b = c[h], S = i, j = s, I = j;
        e: for (; I !== null; ) {
          switch (I.tag) {
            case 27:
              if (ki(I.type)) {
                wt = I.stateNode, Rn = !1;
                break e;
              }
              break;
            case 5:
              wt = I.stateNode, Rn = !1;
              break e;
            case 3:
            case 4:
              wt = I.stateNode.containerInfo, Rn = !0;
              break e;
          }
          I = I.return;
        }
        if (wt === null) throw Error(r(160));
        S2(S, j, b), wt = null, Rn = !1, S = b.alternate, S !== null && (S.return = null), b.return = null;
      }
    if (s.subtreeFlags & 13878)
      for (s = s.child; s !== null; )
        _2(s, i), s = s.sibling;
  }
  var kr = null;
  function _2(i, s) {
    var c = i.alternate, h = i.flags;
    switch (i.tag) {
      case 0:
      case 11:
      case 14:
      case 15:
        Fn(s, i), $n(i), h & 4 && (mi(3, i, i.return), du(3, i), mi(5, i, i.return));
        break;
      case 1:
        Fn(s, i), $n(i), h & 512 && (Dt || c === null || Ur(c, c.return)), h & 64 && Mo && (i = i.updateQueue, i !== null && (h = i.callbacks, h !== null && (c = i.shared.hiddenCallbacks, i.shared.hiddenCallbacks = c === null ? h : c.concat(h))));
        break;
      case 26:
        var b = kr;
        if (Fn(s, i), $n(i), h & 512 && (Dt || c === null || Ur(c, c.return)), h & 4) {
          var S = c !== null ? c.memoizedState : null;
          if (h = i.memoizedState, c === null)
            if (h === null)
              if (i.stateNode === null) {
                e: {
                  h = i.type, c = i.memoizedProps, b = b.ownerDocument || b;
                  t: switch (h) {
                    case "title":
                      S = b.getElementsByTagName("title")[0], (!S || S[Ji] || S[Wt] || S.namespaceURI === "http://www.w3.org/2000/svg" || S.hasAttribute("itemprop")) && (S = b.createElement(h), b.head.insertBefore(
                        S,
                        b.querySelector("head > title")
                      )), rn(S, h, c), S[Wt] = i, It(S), h = S;
                      break e;
                    case "link":
                      var j = v_(
                        "link",
                        "href",
                        b
                      ).get(h + (c.href || ""));
                      if (j) {
                        for (var I = 0; I < j.length; I++)
                          if (S = j[I], S.getAttribute("href") === (c.href == null || c.href === "" ? null : c.href) && S.getAttribute("rel") === (c.rel == null ? null : c.rel) && S.getAttribute("title") === (c.title == null ? null : c.title) && S.getAttribute("crossorigin") === (c.crossOrigin == null ? null : c.crossOrigin)) {
                            j.splice(I, 1);
                            break t;
                          }
                      }
                      S = b.createElement(h), rn(S, h, c), b.head.appendChild(S);
                      break;
                    case "meta":
                      if (j = v_(
                        "meta",
                        "content",
                        b
                      ).get(h + (c.content || ""))) {
                        for (I = 0; I < j.length; I++)
                          if (S = j[I], S.getAttribute("content") === (c.content == null ? null : "" + c.content) && S.getAttribute("name") === (c.name == null ? null : c.name) && S.getAttribute("property") === (c.property == null ? null : c.property) && S.getAttribute("http-equiv") === (c.httpEquiv == null ? null : c.httpEquiv) && S.getAttribute("charset") === (c.charSet == null ? null : c.charSet)) {
                            j.splice(I, 1);
                            break t;
                          }
                      }
                      S = b.createElement(h), rn(S, h, c), b.head.appendChild(S);
                      break;
                    default:
                      throw Error(r(468, h));
                  }
                  S[Wt] = i, It(S), h = S;
                }
                i.stateNode = h;
              } else
                b_(
                  b,
                  i.type,
                  i.stateNode
                );
            else
              i.stateNode = y_(
                b,
                h,
                i.memoizedProps
              );
          else
            S !== h ? (S === null ? c.stateNode !== null && (c = c.stateNode, c.parentNode.removeChild(c)) : S.count--, h === null ? b_(
              b,
              i.type,
              i.stateNode
            ) : y_(
              b,
              h,
              i.memoizedProps
            )) : h === null && i.stateNode !== null && Rg(
              i,
              i.memoizedProps,
              c.memoizedProps
            );
        }
        break;
      case 27:
        Fn(s, i), $n(i), h & 512 && (Dt || c === null || Ur(c, c.return)), c !== null && h & 4 && Rg(
          i,
          i.memoizedProps,
          c.memoizedProps
        );
        break;
      case 5:
        if (Fn(s, i), $n(i), h & 512 && (Dt || c === null || Ur(c, c.return)), i.flags & 32) {
          b = i.stateNode;
          try {
            Za(b, "");
          } catch (re) {
            ft(i, i.return, re);
          }
        }
        h & 4 && i.stateNode != null && (b = i.memoizedProps, Rg(
          i,
          b,
          c !== null ? c.memoizedProps : b
        )), h & 1024 && (Tg = !0);
        break;
      case 6:
        if (Fn(s, i), $n(i), h & 4) {
          if (i.stateNode === null)
            throw Error(r(162));
          h = i.memoizedProps, c = i.stateNode;
          try {
            c.nodeValue = h;
          } catch (re) {
            ft(i, i.return, re);
          }
        }
        break;
      case 3:
        if (uf = null, b = kr, kr = lf(s.containerInfo), Fn(s, i), kr = b, $n(i), h & 4 && c !== null && c.memoizedState.isDehydrated)
          try {
            Mu(s.containerInfo);
          } catch (re) {
            ft(i, i.return, re);
          }
        Tg && (Tg = !1, E2(i));
        break;
      case 4:
        h = kr, kr = lf(
          i.stateNode.containerInfo
        ), Fn(s, i), $n(i), kr = h;
        break;
      case 12:
        Fn(s, i), $n(i);
        break;
      case 13:
        Fn(s, i), $n(i), i.child.flags & 8192 && i.memoizedState !== null != (c !== null && c.memoizedState !== null) && (Hg = lt()), h & 4 && (h = i.updateQueue, h !== null && (i.updateQueue = null, zg(i, h)));
        break;
      case 22:
        b = i.memoizedState !== null;
        var Z = c !== null && c.memoizedState !== null, ee = Mo, ue = Dt;
        if (Mo = ee || b, Dt = ue || Z, Fn(s, i), Dt = ue, Mo = ee, $n(i), h & 8192)
          e: for (s = i.stateNode, s._visibility = b ? s._visibility & -2 : s._visibility | 1, b && (c === null || Z || Mo || Dt || ha(i)), c = null, s = i; ; ) {
            if (s.tag === 5 || s.tag === 26) {
              if (c === null) {
                Z = c = s;
                try {
                  if (S = Z.stateNode, b)
                    j = S.style, typeof j.setProperty == "function" ? j.setProperty("display", "none", "important") : j.display = "none";
                  else {
                    I = Z.stateNode;
                    var de = Z.memoizedProps.style, ne = de != null && de.hasOwnProperty("display") ? de.display : null;
                    I.style.display = ne == null || typeof ne == "boolean" ? "" : ("" + ne).trim();
                  }
                } catch (re) {
                  ft(Z, Z.return, re);
                }
              }
            } else if (s.tag === 6) {
              if (c === null) {
                Z = s;
                try {
                  Z.stateNode.nodeValue = b ? "" : Z.memoizedProps;
                } catch (re) {
                  ft(Z, Z.return, re);
                }
              }
            } else if ((s.tag !== 22 && s.tag !== 23 || s.memoizedState === null || s === i) && s.child !== null) {
              s.child.return = s, s = s.child;
              continue;
            }
            if (s === i) break e;
            for (; s.sibling === null; ) {
              if (s.return === null || s.return === i) break e;
              c === s && (c = null), s = s.return;
            }
            c === s && (c = null), s.sibling.return = s.return, s = s.sibling;
          }
        h & 4 && (h = i.updateQueue, h !== null && (c = h.retryQueue, c !== null && (h.retryQueue = null, zg(i, c))));
        break;
      case 19:
        Fn(s, i), $n(i), h & 4 && (h = i.updateQueue, h !== null && (i.updateQueue = null, zg(i, h)));
        break;
      case 30:
        break;
      case 21:
        break;
      default:
        Fn(s, i), $n(i);
    }
  }
  function $n(i) {
    var s = i.flags;
    if (s & 2) {
      try {
        for (var c, h = i.return; h !== null; ) {
          if (y2(h)) {
            c = h;
            break;
          }
          h = h.return;
        }
        if (c == null) throw Error(r(160));
        switch (c.tag) {
          case 27:
            var b = c.stateNode, S = jg(i);
            Xd(i, S, b);
            break;
          case 5:
            var j = c.stateNode;
            c.flags & 32 && (Za(j, ""), c.flags &= -33);
            var I = jg(i);
            Xd(i, I, j);
            break;
          case 3:
          case 4:
            var Z = c.stateNode.containerInfo, ee = jg(i);
            Dg(
              i,
              ee,
              Z
            );
            break;
          default:
            throw Error(r(161));
        }
      } catch (ue) {
        ft(i, i.return, ue);
      }
      i.flags &= -3;
    }
    s & 4096 && (i.flags &= -4097);
  }
  function E2(i) {
    if (i.subtreeFlags & 1024)
      for (i = i.child; i !== null; ) {
        var s = i;
        E2(s), s.tag === 5 && s.flags & 1024 && s.stateNode.reset(), i = i.sibling;
      }
  }
  function gi(i, s) {
    if (s.subtreeFlags & 8772)
      for (s = s.child; s !== null; )
        w2(i, s.alternate, s), s = s.sibling;
  }
  function ha(i) {
    for (i = i.child; i !== null; ) {
      var s = i;
      switch (s.tag) {
        case 0:
        case 11:
        case 14:
        case 15:
          mi(4, s, s.return), ha(s);
          break;
        case 1:
          Ur(s, s.return);
          var c = s.stateNode;
          typeof c.componentWillUnmount == "function" && m2(
            s,
            s.return,
            c
          ), ha(s);
          break;
        case 27:
          xu(s.stateNode);
        case 26:
        case 5:
          Ur(s, s.return), ha(s);
          break;
        case 22:
          s.memoizedState === null && ha(s);
          break;
        case 30:
          ha(s);
          break;
        default:
          ha(s);
      }
      i = i.sibling;
    }
  }
  function yi(i, s, c) {
    for (c = c && (s.subtreeFlags & 8772) !== 0, s = s.child; s !== null; ) {
      var h = s.alternate, b = i, S = s, j = S.flags;
      switch (S.tag) {
        case 0:
        case 11:
        case 15:
          yi(
            b,
            S,
            c
          ), du(4, S);
          break;
        case 1:
          if (yi(
            b,
            S,
            c
          ), h = S, b = h.stateNode, typeof b.componentDidMount == "function")
            try {
              b.componentDidMount();
            } catch (ee) {
              ft(h, h.return, ee);
            }
          if (h = S, b = h.updateQueue, b !== null) {
            var I = h.stateNode;
            try {
              var Z = b.shared.hiddenCallbacks;
              if (Z !== null)
                for (b.shared.hiddenCallbacks = null, b = 0; b < Z.length; b++)
                  ek(Z[b], I);
            } catch (ee) {
              ft(h, h.return, ee);
            }
          }
          c && j & 64 && h2(S), fu(S, S.return);
          break;
        case 27:
          v2(S);
        case 26:
        case 5:
          yi(
            b,
            S,
            c
          ), c && h === null && j & 4 && g2(S), fu(S, S.return);
          break;
        case 12:
          yi(
            b,
            S,
            c
          );
          break;
        case 13:
          yi(
            b,
            S,
            c
          ), c && j & 4 && k2(b, S);
          break;
        case 22:
          S.memoizedState === null && yi(
            b,
            S,
            c
          ), fu(S, S.return);
          break;
        case 30:
          break;
        default:
          yi(
            b,
            S,
            c
          );
      }
      s = s.sibling;
    }
  }
  function Pg(i, s) {
    var c = null;
    i !== null && i.memoizedState !== null && i.memoizedState.cachePool !== null && (c = i.memoizedState.cachePool.pool), i = null, s.memoizedState !== null && s.memoizedState.cachePool !== null && (i = s.memoizedState.cachePool.pool), i !== c && (i != null && i.refCount++, c != null && Ks(c));
  }
  function Lg(i, s) {
    i = null, s.alternate !== null && (i = s.alternate.memoizedState.cache), s = s.memoizedState.cache, s !== i && (s.refCount++, i != null && Ks(i));
  }
  function Fr(i, s, c, h) {
    if (s.subtreeFlags & 10256)
      for (s = s.child; s !== null; )
        C2(
          i,
          s,
          c,
          h
        ), s = s.sibling;
  }
  function C2(i, s, c, h) {
    var b = s.flags;
    switch (s.tag) {
      case 0:
      case 11:
      case 15:
        Fr(
          i,
          s,
          c,
          h
        ), b & 2048 && du(9, s);
        break;
      case 1:
        Fr(
          i,
          s,
          c,
          h
        );
        break;
      case 3:
        Fr(
          i,
          s,
          c,
          h
        ), b & 2048 && (i = null, s.alternate !== null && (i = s.alternate.memoizedState.cache), s = s.memoizedState.cache, s !== i && (s.refCount++, i != null && Ks(i)));
        break;
      case 12:
        if (b & 2048) {
          Fr(
            i,
            s,
            c,
            h
          ), i = s.stateNode;
          try {
            var S = s.memoizedProps, j = S.id, I = S.onPostCommit;
            typeof I == "function" && I(
              j,
              s.alternate === null ? "mount" : "update",
              i.passiveEffectDuration,
              -0
            );
          } catch (Z) {
            ft(s, s.return, Z);
          }
        } else
          Fr(
            i,
            s,
            c,
            h
          );
        break;
      case 13:
        Fr(
          i,
          s,
          c,
          h
        );
        break;
      case 23:
        break;
      case 22:
        S = s.stateNode, j = s.alternate, s.memoizedState !== null ? S._visibility & 2 ? Fr(
          i,
          s,
          c,
          h
        ) : pu(i, s) : S._visibility & 2 ? Fr(
          i,
          s,
          c,
          h
        ) : (S._visibility |= 2, hl(
          i,
          s,
          c,
          h,
          (s.subtreeFlags & 10256) !== 0
        )), b & 2048 && Pg(j, s);
        break;
      case 24:
        Fr(
          i,
          s,
          c,
          h
        ), b & 2048 && Lg(s.alternate, s);
        break;
      default:
        Fr(
          i,
          s,
          c,
          h
        );
    }
  }
  function hl(i, s, c, h, b) {
    for (b = b && (s.subtreeFlags & 10256) !== 0, s = s.child; s !== null; ) {
      var S = i, j = s, I = c, Z = h, ee = j.flags;
      switch (j.tag) {
        case 0:
        case 11:
        case 15:
          hl(
            S,
            j,
            I,
            Z,
            b
          ), du(8, j);
          break;
        case 23:
          break;
        case 22:
          var ue = j.stateNode;
          j.memoizedState !== null ? ue._visibility & 2 ? hl(
            S,
            j,
            I,
            Z,
            b
          ) : pu(
            S,
            j
          ) : (ue._visibility |= 2, hl(
            S,
            j,
            I,
            Z,
            b
          )), b && ee & 2048 && Pg(
            j.alternate,
            j
          );
          break;
        case 24:
          hl(
            S,
            j,
            I,
            Z,
            b
          ), b && ee & 2048 && Lg(j.alternate, j);
          break;
        default:
          hl(
            S,
            j,
            I,
            Z,
            b
          );
      }
      s = s.sibling;
    }
  }
  function pu(i, s) {
    if (s.subtreeFlags & 10256)
      for (s = s.child; s !== null; ) {
        var c = i, h = s, b = h.flags;
        switch (h.tag) {
          case 22:
            pu(c, h), b & 2048 && Pg(
              h.alternate,
              h
            );
            break;
          case 24:
            pu(c, h), b & 2048 && Lg(h.alternate, h);
            break;
          default:
            pu(c, h);
        }
        s = s.sibling;
      }
  }
  var hu = 8192;
  function ml(i) {
    if (i.subtreeFlags & hu)
      for (i = i.child; i !== null; )
        O2(i), i = i.sibling;
  }
  function O2(i) {
    switch (i.tag) {
      case 26:
        ml(i), i.flags & hu && i.memoizedState !== null && A6(
          kr,
          i.memoizedState,
          i.memoizedProps
        );
        break;
      case 5:
        ml(i);
        break;
      case 3:
      case 4:
        var s = kr;
        kr = lf(i.stateNode.containerInfo), ml(i), kr = s;
        break;
      case 22:
        i.memoizedState === null && (s = i.alternate, s !== null && s.memoizedState !== null ? (s = hu, hu = 16777216, ml(i), hu = s) : ml(i));
        break;
      default:
        ml(i);
    }
  }
  function N2(i) {
    var s = i.alternate;
    if (s !== null && (i = s.child, i !== null)) {
      s.child = null;
      do
        s = i.sibling, i.sibling = null, i = s;
      while (i !== null);
    }
  }
  function mu(i) {
    var s = i.deletions;
    if ((i.flags & 16) !== 0) {
      if (s !== null)
        for (var c = 0; c < s.length; c++) {
          var h = s[c];
          Qt = h, A2(
            h,
            i
          );
        }
      N2(i);
    }
    if (i.subtreeFlags & 10256)
      for (i = i.child; i !== null; )
        M2(i), i = i.sibling;
  }
  function M2(i) {
    switch (i.tag) {
      case 0:
      case 11:
      case 15:
        mu(i), i.flags & 2048 && mi(9, i, i.return);
        break;
      case 3:
        mu(i);
        break;
      case 12:
        mu(i);
        break;
      case 22:
        var s = i.stateNode;
        i.memoizedState !== null && s._visibility & 2 && (i.return === null || i.return.tag !== 13) ? (s._visibility &= -3, Gd(i)) : mu(i);
        break;
      default:
        mu(i);
    }
  }
  function Gd(i) {
    var s = i.deletions;
    if ((i.flags & 16) !== 0) {
      if (s !== null)
        for (var c = 0; c < s.length; c++) {
          var h = s[c];
          Qt = h, A2(
            h,
            i
          );
        }
      N2(i);
    }
    for (i = i.child; i !== null; ) {
      switch (s = i, s.tag) {
        case 0:
        case 11:
        case 15:
          mi(8, s, s.return), Gd(s);
          break;
        case 22:
          c = s.stateNode, c._visibility & 2 && (c._visibility &= -3, Gd(s));
          break;
        default:
          Gd(s);
      }
      i = i.sibling;
    }
  }
  function A2(i, s) {
    for (; Qt !== null; ) {
      var c = Qt;
      switch (c.tag) {
        case 0:
        case 11:
        case 15:
          mi(8, c, s);
          break;
        case 23:
        case 22:
          if (c.memoizedState !== null && c.memoizedState.cachePool !== null) {
            var h = c.memoizedState.cachePool.pool;
            h != null && h.refCount++;
          }
          break;
        case 24:
          Ks(c.memoizedState.cache);
      }
      if (h = c.child, h !== null) h.return = c, Qt = h;
      else
        e: for (c = i; Qt !== null; ) {
          h = Qt;
          var b = h.sibling, S = h.return;
          if (x2(h), h === c) {
            Qt = null;
            break e;
          }
          if (b !== null) {
            b.return = S, Qt = b;
            break e;
          }
          Qt = S;
        }
    }
  }
  var qT = {
    getCacheForType: function(i) {
      var s = cn(Gt), c = s.data.get(i);
      return c === void 0 && (c = i(), s.data.set(i, c)), c;
    }
  }, XT = typeof WeakMap == "function" ? WeakMap : Map, it = 0, gt = null, Ye = null, We = 0, at = 0, Yn = null, vi = !1, gl = !1, Ig = !1, Ro = 0, Ot = 0, bi = 0, ma = 0, Bg = 0, dr = 0, yl = 0, gu = null, jn = null, Vg = !1, Hg = 0, Zd = 1 / 0, Wd = null, wi = null, nn = 0, xi = null, vl = null, bl = 0, Ug = 0, Fg = null, R2 = null, yu = 0, $g = null;
  function qn() {
    if ((it & 2) !== 0 && We !== 0)
      return We & -We;
    if (L.T !== null) {
      var i = al;
      return i !== 0 ? i : Kg();
    }
    return nd();
  }
  function j2() {
    dr === 0 && (dr = (We & 536870912) === 0 || Je ? Jc() : 536870912);
    var i = cr.current;
    return i !== null && (i.flags |= 32), dr;
  }
  function Xn(i, s, c) {
    (i === gt && (at === 2 || at === 9) || i.cancelPendingCommit !== null) && (wl(i, 0), Si(
      i,
      We,
      dr,
      !1
    )), Qi(i, c), ((it & 2) === 0 || i !== gt) && (i === gt && ((it & 2) === 0 && (ma |= c), Ot === 4 && Si(
      i,
      We,
      dr,
      !1
    )), $r(i));
  }
  function D2(i, s, c) {
    if ((it & 6) !== 0) throw Error(r(327));
    var h = !c && (s & 124) === 0 && (s & i.expiredLanes) === 0 || Cn(i, s), b = h ? WT(i, s) : Xg(i, s, !0), S = h;
    do {
      if (b === 0) {
        gl && !h && Si(i, s, 0, !1);
        break;
      } else {
        if (c = i.current.alternate, S && !GT(c)) {
          b = Xg(i, s, !1), S = !1;
          continue;
        }
        if (b === 2) {
          if (S = s, i.errorRecoveryDisabledLanes & S)
            var j = 0;
          else
            j = i.pendingLanes & -536870913, j = j !== 0 ? j : j & 536870912 ? 536870912 : 0;
          if (j !== 0) {
            s = j;
            e: {
              var I = i;
              b = gu;
              var Z = I.current.memoizedState.isDehydrated;
              if (Z && (wl(I, j).flags |= 256), j = Xg(
                I,
                j,
                !1
              ), j !== 2) {
                if (Ig && !Z) {
                  I.errorRecoveryDisabledLanes |= S, ma |= S, b = 4;
                  break e;
                }
                S = jn, jn = b, S !== null && (jn === null ? jn = S : jn.push.apply(
                  jn,
                  S
                ));
              }
              b = j;
            }
            if (S = !1, b !== 2) continue;
          }
        }
        if (b === 1) {
          wl(i, 0), Si(i, s, 0, !0);
          break;
        }
        e: {
          switch (h = i, S = b, S) {
            case 0:
            case 1:
              throw Error(r(345));
            case 4:
              if ((s & 4194048) !== s) break;
            case 6:
              Si(
                h,
                s,
                dr,
                !vi
              );
              break e;
            case 2:
              jn = null;
              break;
            case 3:
            case 5:
              break;
            default:
              throw Error(r(329));
          }
          if ((s & 62914560) === s && (b = Hg + 300 - lt(), 10 < b)) {
            if (Si(
              h,
              s,
              dr,
              !vi
            ), Lt(h, 0, !0) !== 0) break e;
            h.timeoutHandle = s_(
              T2.bind(
                null,
                h,
                c,
                jn,
                Wd,
                Vg,
                s,
                dr,
                ma,
                yl,
                vi,
                S,
                2,
                -0,
                0
              ),
              b
            );
            break e;
          }
          T2(
            h,
            c,
            jn,
            Wd,
            Vg,
            s,
            dr,
            ma,
            yl,
            vi,
            S,
            0,
            -0,
            0
          );
        }
      }
      break;
    } while (!0);
    $r(i);
  }
  function T2(i, s, c, h, b, S, j, I, Z, ee, ue, de, ne, re) {
    if (i.timeoutHandle = -1, de = s.subtreeFlags, (de & 8192 || (de & 16785408) === 16785408) && (_u = { stylesheets: null, count: 0, unsuspend: M6 }, O2(s), de = R6(), de !== null)) {
      i.cancelPendingCommit = de(
        H2.bind(
          null,
          i,
          s,
          S,
          c,
          h,
          b,
          j,
          I,
          Z,
          ue,
          1,
          ne,
          re
        )
      ), Si(i, S, j, !ee);
      return;
    }
    H2(
      i,
      s,
      S,
      c,
      h,
      b,
      j,
      I,
      Z
    );
  }
  function GT(i) {
    for (var s = i; ; ) {
      var c = s.tag;
      if ((c === 0 || c === 11 || c === 15) && s.flags & 16384 && (c = s.updateQueue, c !== null && (c = c.stores, c !== null)))
        for (var h = 0; h < c.length; h++) {
          var b = c[h], S = b.getSnapshot;
          b = b.value;
          try {
            if (!Hn(S(), b)) return !1;
          } catch {
            return !1;
          }
        }
      if (c = s.child, s.subtreeFlags & 16384 && c !== null)
        c.return = s, s = c;
      else {
        if (s === i) break;
        for (; s.sibling === null; ) {
          if (s.return === null || s.return === i) return !0;
          s = s.return;
        }
        s.sibling.return = s.return, s = s.sibling;
      }
    }
    return !0;
  }
  function Si(i, s, c, h) {
    s &= ~Bg, s &= ~ma, i.suspendedLanes |= s, i.pingedLanes &= ~s, h && (i.warmLanes |= s), h = i.expirationTimes;
    for (var b = s; 0 < b; ) {
      var S = 31 - Le(b), j = 1 << S;
      h[S] = -1, b &= ~j;
    }
    c !== 0 && Ns(i, c, s);
  }
  function Kd() {
    return (it & 6) === 0 ? (vu(0), !1) : !0;
  }
  function Yg() {
    if (Ye !== null) {
      if (at === 0)
        var i = Ye.return;
      else
        i = Ye, ko = ua = null, sg(i), fl = null, su = 0, i = Ye;
      for (; i !== null; )
        p2(i.alternate, i), i = i.return;
      Ye = null;
    }
  }
  function wl(i, s) {
    var c = i.timeoutHandle;
    c !== -1 && (i.timeoutHandle = -1, f6(c)), c = i.cancelPendingCommit, c !== null && (i.cancelPendingCommit = null, c()), Yg(), gt = i, Ye = c = wo(i.current, null), We = s, at = 0, Yn = null, vi = !1, gl = Cn(i, s), Ig = !1, yl = dr = Bg = ma = bi = Ot = 0, jn = gu = null, Vg = !1, (s & 8) !== 0 && (s |= s & 32);
    var h = i.entangledLanes;
    if (h !== 0)
      for (i = i.entanglements, h &= s; 0 < h; ) {
        var b = 31 - Le(h), S = 1 << b;
        s |= i[b], h &= ~S;
      }
    return Ro = s, bd(), c;
  }
  function z2(i, s) {
    Fe = null, L.H = Id, s === Js || s === Nd ? (s = QS(), at = 3) : s === ZS ? (s = QS(), at = 4) : at = s === Jk ? 8 : s !== null && typeof s == "object" && typeof s.then == "function" ? 6 : 1, Yn = s, Ye === null && (Ot = 1, Fd(
      i,
      ar(s, i.current)
    ));
  }
  function P2() {
    var i = L.H;
    return L.H = Id, i === null ? Id : i;
  }
  function L2() {
    var i = L.A;
    return L.A = qT, i;
  }
  function qg() {
    Ot = 4, vi || (We & 4194048) !== We && cr.current !== null || (gl = !0), (bi & 134217727) === 0 && (ma & 134217727) === 0 || gt === null || Si(
      gt,
      We,
      dr,
      !1
    );
  }
  function Xg(i, s, c) {
    var h = it;
    it |= 2;
    var b = P2(), S = L2();
    (gt !== i || We !== s) && (Wd = null, wl(i, s)), s = !1;
    var j = Ot;
    e: do
      try {
        if (at !== 0 && Ye !== null) {
          var I = Ye, Z = Yn;
          switch (at) {
            case 8:
              Yg(), j = 6;
              break e;
            case 3:
            case 2:
            case 9:
            case 6:
              cr.current === null && (s = !0);
              var ee = at;
              if (at = 0, Yn = null, xl(i, I, Z, ee), c && gl) {
                j = 0;
                break e;
              }
              break;
            default:
              ee = at, at = 0, Yn = null, xl(i, I, Z, ee);
          }
        }
        ZT(), j = Ot;
        break;
      } catch (ue) {
        z2(i, ue);
      }
    while (!0);
    return s && i.shellSuspendCounter++, ko = ua = null, it = h, L.H = b, L.A = S, Ye === null && (gt = null, We = 0, bd()), j;
  }
  function ZT() {
    for (; Ye !== null; ) I2(Ye);
  }
  function WT(i, s) {
    var c = it;
    it |= 2;
    var h = P2(), b = L2();
    gt !== i || We !== s ? (Wd = null, Zd = lt() + 500, wl(i, s)) : gl = Cn(
      i,
      s
    );
    e: do
      try {
        if (at !== 0 && Ye !== null) {
          s = Ye;
          var S = Yn;
          t: switch (at) {
            case 1:
              at = 0, Yn = null, xl(i, s, S, 1);
              break;
            case 2:
            case 9:
              if (WS(S)) {
                at = 0, Yn = null, B2(s);
                break;
              }
              s = function() {
                at !== 2 && at !== 9 || gt !== i || (at = 7), $r(i);
              }, S.then(s, s);
              break e;
            case 3:
              at = 7;
              break e;
            case 4:
              at = 5;
              break e;
            case 7:
              WS(S) ? (at = 0, Yn = null, B2(s)) : (at = 0, Yn = null, xl(i, s, S, 7));
              break;
            case 5:
              var j = null;
              switch (Ye.tag) {
                case 26:
                  j = Ye.memoizedState;
                case 5:
                case 27:
                  var I = Ye;
                  if (!j || w_(j)) {
                    at = 0, Yn = null;
                    var Z = I.sibling;
                    if (Z !== null) Ye = Z;
                    else {
                      var ee = I.return;
                      ee !== null ? (Ye = ee, Qd(ee)) : Ye = null;
                    }
                    break t;
                  }
              }
              at = 0, Yn = null, xl(i, s, S, 5);
              break;
            case 6:
              at = 0, Yn = null, xl(i, s, S, 6);
              break;
            case 8:
              Yg(), Ot = 6;
              break e;
            default:
              throw Error(r(462));
          }
        }
        KT();
        break;
      } catch (ue) {
        z2(i, ue);
      }
    while (!0);
    return ko = ua = null, L.H = h, L.A = b, it = c, Ye !== null ? 0 : (gt = null, We = 0, bd(), Ot);
  }
  function KT() {
    for (; Ye !== null && !Rt(); )
      I2(Ye);
  }
  function I2(i) {
    var s = d2(i.alternate, i, Ro);
    i.memoizedProps = i.pendingProps, s === null ? Qd(i) : Ye = s;
  }
  function B2(i) {
    var s = i, c = s.alternate;
    switch (s.tag) {
      case 15:
      case 0:
        s = i2(
          c,
          s,
          s.pendingProps,
          s.type,
          void 0,
          We
        );
        break;
      case 11:
        s = i2(
          c,
          s,
          s.pendingProps,
          s.type.render,
          s.ref,
          We
        );
        break;
      case 5:
        sg(s);
      default:
        p2(c, s), s = Ye = VS(s, Ro), s = d2(c, s, Ro);
    }
    i.memoizedProps = i.pendingProps, s === null ? Qd(i) : Ye = s;
  }
  function xl(i, s, c, h) {
    ko = ua = null, sg(s), fl = null, su = 0;
    var b = s.return;
    try {
      if (VT(
        i,
        b,
        s,
        c,
        We
      )) {
        Ot = 1, Fd(
          i,
          ar(c, i.current)
        ), Ye = null;
        return;
      }
    } catch (S) {
      if (b !== null) throw Ye = b, S;
      Ot = 1, Fd(
        i,
        ar(c, i.current)
      ), Ye = null;
      return;
    }
    s.flags & 32768 ? (Je || h === 1 ? i = !0 : gl || (We & 536870912) !== 0 ? i = !1 : (vi = i = !0, (h === 2 || h === 9 || h === 3 || h === 6) && (h = cr.current, h !== null && h.tag === 13 && (h.flags |= 16384))), V2(s, i)) : Qd(s);
  }
  function Qd(i) {
    var s = i;
    do {
      if ((s.flags & 32768) !== 0) {
        V2(
          s,
          vi
        );
        return;
      }
      i = s.return;
      var c = UT(
        s.alternate,
        s,
        Ro
      );
      if (c !== null) {
        Ye = c;
        return;
      }
      if (s = s.sibling, s !== null) {
        Ye = s;
        return;
      }
      Ye = s = i;
    } while (s !== null);
    Ot === 0 && (Ot = 5);
  }
  function V2(i, s) {
    do {
      var c = FT(i.alternate, i);
      if (c !== null) {
        c.flags &= 32767, Ye = c;
        return;
      }
      if (c = i.return, c !== null && (c.flags |= 32768, c.subtreeFlags = 0, c.deletions = null), !s && (i = i.sibling, i !== null)) {
        Ye = i;
        return;
      }
      Ye = i = c;
    } while (i !== null);
    Ot = 6, Ye = null;
  }
  function H2(i, s, c, h, b, S, j, I, Z) {
    i.cancelPendingCommit = null;
    do
      Jd();
    while (nn !== 0);
    if ((it & 6) !== 0) throw Error(r(327));
    if (s !== null) {
      if (s === i.current) throw Error(r(177));
      if (S = s.lanes | s.childLanes, S |= Lm, dm(
        i,
        c,
        S,
        j,
        I,
        Z
      ), i === gt && (Ye = gt = null, We = 0), vl = s, xi = i, bl = c, Ug = S, Fg = b, R2 = h, (s.subtreeFlags & 10256) !== 0 || (s.flags & 10256) !== 0 ? (i.callbackNode = null, i.callbackPriority = 0, t6(je, function() {
        return q2(), null;
      })) : (i.callbackNode = null, i.callbackPriority = 0), h = (s.flags & 13878) !== 0, (s.subtreeFlags & 13878) !== 0 || h) {
        h = L.T, L.T = null, b = H.p, H.p = 2, j = it, it |= 4;
        try {
          $T(i, s, c);
        } finally {
          it = j, H.p = b, L.T = h;
        }
      }
      nn = 1, U2(), F2(), $2();
    }
  }
  function U2() {
    if (nn === 1) {
      nn = 0;
      var i = xi, s = vl, c = (s.flags & 13878) !== 0;
      if ((s.subtreeFlags & 13878) !== 0 || c) {
        c = L.T, L.T = null;
        var h = H.p;
        H.p = 2;
        var b = it;
        it |= 4;
        try {
          _2(s, i);
          var S = iy, j = AS(i.containerInfo), I = S.focusedElem, Z = S.selectionRange;
          if (j !== I && I && I.ownerDocument && MS(
            I.ownerDocument.documentElement,
            I
          )) {
            if (Z !== null && jm(I)) {
              var ee = Z.start, ue = Z.end;
              if (ue === void 0 && (ue = ee), "selectionStart" in I)
                I.selectionStart = ee, I.selectionEnd = Math.min(
                  ue,
                  I.value.length
                );
              else {
                var de = I.ownerDocument || document, ne = de && de.defaultView || window;
                if (ne.getSelection) {
                  var re = ne.getSelection(), ze = I.textContent.length, Re = Math.min(Z.start, ze), ct = Z.end === void 0 ? Re : Math.min(Z.end, ze);
                  !re.extend && Re > ct && (j = ct, ct = Re, Re = j);
                  var K = NS(
                    I,
                    Re
                  ), W = NS(
                    I,
                    ct
                  );
                  if (K && W && (re.rangeCount !== 1 || re.anchorNode !== K.node || re.anchorOffset !== K.offset || re.focusNode !== W.node || re.focusOffset !== W.offset)) {
                    var J = de.createRange();
                    J.setStart(K.node, K.offset), re.removeAllRanges(), Re > ct ? (re.addRange(J), re.extend(W.node, W.offset)) : (J.setEnd(W.node, W.offset), re.addRange(J));
                  }
                }
              }
            }
            for (de = [], re = I; re = re.parentNode; )
              re.nodeType === 1 && de.push({
                element: re,
                left: re.scrollLeft,
                top: re.scrollTop
              });
            for (typeof I.focus == "function" && I.focus(), I = 0; I < de.length; I++) {
              var ce = de[I];
              ce.element.scrollLeft = ce.left, ce.element.scrollTop = ce.top;
            }
          }
          ff = !!oy, iy = oy = null;
        } finally {
          it = b, H.p = h, L.T = c;
        }
      }
      i.current = s, nn = 2;
    }
  }
  function F2() {
    if (nn === 2) {
      nn = 0;
      var i = xi, s = vl, c = (s.flags & 8772) !== 0;
      if ((s.subtreeFlags & 8772) !== 0 || c) {
        c = L.T, L.T = null;
        var h = H.p;
        H.p = 2;
        var b = it;
        it |= 4;
        try {
          w2(i, s.alternate, s);
        } finally {
          it = b, H.p = h, L.T = c;
        }
      }
      nn = 3;
    }
  }
  function $2() {
    if (nn === 4 || nn === 3) {
      nn = 0, Pt();
      var i = xi, s = vl, c = bl, h = R2;
      (s.subtreeFlags & 10256) !== 0 || (s.flags & 10256) !== 0 ? nn = 5 : (nn = 0, vl = xi = null, Y2(i, i.pendingLanes));
      var b = i.pendingLanes;
      if (b === 0 && (wi = null), As(c), s = s.stateNode, pe && typeof pe.onCommitFiberRoot == "function")
        try {
          pe.onCommitFiberRoot(
            le,
            s,
            void 0,
            (s.current.flags & 128) === 128
          );
        } catch {
        }
      if (h !== null) {
        s = L.T, b = H.p, H.p = 2, L.T = null;
        try {
          for (var S = i.onRecoverableError, j = 0; j < h.length; j++) {
            var I = h[j];
            S(I.value, {
              componentStack: I.stack
            });
          }
        } finally {
          L.T = s, H.p = b;
        }
      }
      (bl & 3) !== 0 && Jd(), $r(i), b = i.pendingLanes, (c & 4194090) !== 0 && (b & 42) !== 0 ? i === $g ? yu++ : (yu = 0, $g = i) : yu = 0, vu(0);
    }
  }
  function Y2(i, s) {
    (i.pooledCacheLanes &= s) === 0 && (s = i.pooledCache, s != null && (i.pooledCache = null, Ks(s)));
  }
  function Jd(i) {
    return U2(), F2(), $2(), q2();
  }
  function q2() {
    if (nn !== 5) return !1;
    var i = xi, s = Ug;
    Ug = 0;
    var c = As(bl), h = L.T, b = H.p;
    try {
      H.p = 32 > c ? 32 : c, L.T = null, c = Fg, Fg = null;
      var S = xi, j = bl;
      if (nn = 0, vl = xi = null, bl = 0, (it & 6) !== 0) throw Error(r(331));
      var I = it;
      if (it |= 4, M2(S.current), C2(
        S,
        S.current,
        j,
        c
      ), it = I, vu(0, !1), pe && typeof pe.onPostCommitFiberRoot == "function")
        try {
          pe.onPostCommitFiberRoot(le, S);
        } catch {
        }
      return !0;
    } finally {
      H.p = b, L.T = h, Y2(i, s);
    }
  }
  function X2(i, s, c) {
    s = ar(c, s), s = Sg(i.stateNode, s, 2), i = di(i, s, 2), i !== null && (Qi(i, 2), $r(i));
  }
  function ft(i, s, c) {
    if (i.tag === 3)
      X2(i, i, c);
    else
      for (; s !== null; ) {
        if (s.tag === 3) {
          X2(
            s,
            i,
            c
          );
          break;
        } else if (s.tag === 1) {
          var h = s.stateNode;
          if (typeof s.type.getDerivedStateFromError == "function" || typeof h.componentDidCatch == "function" && (wi === null || !wi.has(h))) {
            i = ar(c, i), c = Kk(2), h = di(s, c, 2), h !== null && (Qk(
              c,
              h,
              s,
              i
            ), Qi(h, 2), $r(h));
            break;
          }
        }
        s = s.return;
      }
  }
  function Gg(i, s, c) {
    var h = i.pingCache;
    if (h === null) {
      h = i.pingCache = new XT();
      var b = /* @__PURE__ */ new Set();
      h.set(s, b);
    } else
      b = h.get(s), b === void 0 && (b = /* @__PURE__ */ new Set(), h.set(s, b));
    b.has(c) || (Ig = !0, b.add(c), i = QT.bind(null, i, s, c), s.then(i, i));
  }
  function QT(i, s, c) {
    var h = i.pingCache;
    h !== null && h.delete(s), i.pingedLanes |= i.suspendedLanes & c, i.warmLanes &= ~c, gt === i && (We & c) === c && (Ot === 4 || Ot === 3 && (We & 62914560) === We && 300 > lt() - Hg ? (it & 2) === 0 && wl(i, 0) : Bg |= c, yl === We && (yl = 0)), $r(i);
  }
  function G2(i, s) {
    s === 0 && (s = ed()), i = nl(i, s), i !== null && (Qi(i, s), $r(i));
  }
  function JT(i) {
    var s = i.memoizedState, c = 0;
    s !== null && (c = s.retryLane), G2(i, c);
  }
  function e6(i, s) {
    var c = 0;
    switch (i.tag) {
      case 13:
        var h = i.stateNode, b = i.memoizedState;
        b !== null && (c = b.retryLane);
        break;
      case 19:
        h = i.stateNode;
        break;
      case 22:
        h = i.stateNode._retryCache;
        break;
      default:
        throw Error(r(314));
    }
    h !== null && h.delete(s), G2(i, c);
  }
  function t6(i, s) {
    return Pe(i, s);
  }
  var ef = null, Sl = null, Zg = !1, tf = !1, Wg = !1, ga = 0;
  function $r(i) {
    i !== Sl && i.next === null && (Sl === null ? ef = Sl = i : Sl = Sl.next = i), tf = !0, Zg || (Zg = !0, r6());
  }
  function vu(i, s) {
    if (!Wg && tf) {
      Wg = !0;
      do
        for (var c = !1, h = ef; h !== null; ) {
          if (i !== 0) {
            var b = h.pendingLanes;
            if (b === 0) var S = 0;
            else {
              var j = h.suspendedLanes, I = h.pingedLanes;
              S = (1 << 31 - Le(42 | i) + 1) - 1, S &= b & ~(j & ~I), S = S & 201326741 ? S & 201326741 | 1 : S ? S | 2 : 0;
            }
            S !== 0 && (c = !0, Q2(h, S));
          } else
            S = We, S = Lt(
              h,
              h === gt ? S : 0,
              h.cancelPendingCommit !== null || h.timeoutHandle !== -1
            ), (S & 3) === 0 || Cn(h, S) || (c = !0, Q2(h, S));
          h = h.next;
        }
      while (c);
      Wg = !1;
    }
  }
  function n6() {
    Z2();
  }
  function Z2() {
    tf = Zg = !1;
    var i = 0;
    ga !== 0 && (d6() && (i = ga), ga = 0);
    for (var s = lt(), c = null, h = ef; h !== null; ) {
      var b = h.next, S = W2(h, s);
      S === 0 ? (h.next = null, c === null ? ef = b : c.next = b, b === null && (Sl = c)) : (c = h, (i !== 0 || (S & 3) !== 0) && (tf = !0)), h = b;
    }
    vu(i);
  }
  function W2(i, s) {
    for (var c = i.suspendedLanes, h = i.pingedLanes, b = i.expirationTimes, S = i.pendingLanes & -62914561; 0 < S; ) {
      var j = 31 - Le(S), I = 1 << j, Z = b[j];
      Z === -1 ? ((I & c) === 0 || (I & h) !== 0) && (b[j] = Vn(I, s)) : Z <= s && (i.expiredLanes |= I), S &= ~I;
    }
    if (s = gt, c = We, c = Lt(
      i,
      i === s ? c : 0,
      i.cancelPendingCommit !== null || i.timeoutHandle !== -1
    ), h = i.callbackNode, c === 0 || i === s && (at === 2 || at === 9) || i.cancelPendingCommit !== null)
      return h !== null && h !== null && Ve(h), i.callbackNode = null, i.callbackPriority = 0;
    if ((c & 3) === 0 || Cn(i, c)) {
      if (s = c & -c, s === i.callbackPriority) return s;
      switch (h !== null && Ve(h), As(c)) {
        case 2:
        case 8:
          c = Bn;
          break;
        case 32:
          c = je;
          break;
        case 268435456:
          c = Lr;
          break;
        default:
          c = je;
      }
      return h = K2.bind(null, i), c = Pe(c, h), i.callbackPriority = s, i.callbackNode = c, s;
    }
    return h !== null && h !== null && Ve(h), i.callbackPriority = 2, i.callbackNode = null, 2;
  }
  function K2(i, s) {
    if (nn !== 0 && nn !== 5)
      return i.callbackNode = null, i.callbackPriority = 0, null;
    var c = i.callbackNode;
    if (Jd() && i.callbackNode !== c)
      return null;
    var h = We;
    return h = Lt(
      i,
      i === gt ? h : 0,
      i.cancelPendingCommit !== null || i.timeoutHandle !== -1
    ), h === 0 ? null : (D2(i, h, s), W2(i, lt()), i.callbackNode != null && i.callbackNode === c ? K2.bind(null, i) : null);
  }
  function Q2(i, s) {
    if (Jd()) return null;
    D2(i, s, !0);
  }
  function r6() {
    p6(function() {
      (it & 6) !== 0 ? Pe(
        en,
        n6
      ) : Z2();
    });
  }
  function Kg() {
    return ga === 0 && (ga = Jc()), ga;
  }
  function J2(i) {
    return i == null || typeof i == "symbol" || typeof i == "boolean" ? null : typeof i == "function" ? i : fd("" + i);
  }
  function e_(i, s) {
    var c = s.ownerDocument.createElement("input");
    return c.name = s.name, c.value = s.value, i.id && c.setAttribute("form", i.id), s.parentNode.insertBefore(c, s), i = new FormData(i), c.parentNode.removeChild(c), i;
  }
  function o6(i, s, c, h, b) {
    if (s === "submit" && c && c.stateNode === b) {
      var S = J2(
        (b[un] || null).action
      ), j = h.submitter;
      j && (s = (s = j[un] || null) ? J2(s.formAction) : j.getAttribute("formAction"), s !== null && (S = s, j = null));
      var I = new gd(
        "action",
        "action",
        null,
        h,
        b
      );
      i.push({
        event: I,
        listeners: [
          {
            instance: null,
            listener: function() {
              if (h.defaultPrevented) {
                if (ga !== 0) {
                  var Z = j ? e_(b, j) : new FormData(b);
                  yg(
                    c,
                    {
                      pending: !0,
                      data: Z,
                      method: b.method,
                      action: S
                    },
                    null,
                    Z
                  );
                }
              } else
                typeof S == "function" && (I.preventDefault(), Z = j ? e_(b, j) : new FormData(b), yg(
                  c,
                  {
                    pending: !0,
                    data: Z,
                    method: b.method,
                    action: S
                  },
                  S,
                  Z
                ));
            },
            currentTarget: b
          }
        ]
      });
    }
  }
  for (var Qg = 0; Qg < Pm.length; Qg++) {
    var Jg = Pm[Qg], i6 = Jg.toLowerCase(), a6 = Jg[0].toUpperCase() + Jg.slice(1);
    Sr(
      i6,
      "on" + a6
    );
  }
  Sr(DS, "onAnimationEnd"), Sr(TS, "onAnimationIteration"), Sr(zS, "onAnimationStart"), Sr("dblclick", "onDoubleClick"), Sr("focusin", "onFocus"), Sr("focusout", "onBlur"), Sr(kT, "onTransitionRun"), Sr(_T, "onTransitionStart"), Sr(ET, "onTransitionCancel"), Sr(PS, "onTransitionEnd"), oi("onMouseEnter", ["mouseout", "mouseover"]), oi("onMouseLeave", ["mouseout", "mouseover"]), oi("onPointerEnter", ["pointerout", "pointerover"]), oi("onPointerLeave", ["pointerout", "pointerover"]), vo(
    "onChange",
    "change click focusin focusout input keydown keyup selectionchange".split(" ")
  ), vo(
    "onSelect",
    "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(
      " "
    )
  ), vo("onBeforeInput", [
    "compositionend",
    "keypress",
    "textInput",
    "paste"
  ]), vo(
    "onCompositionEnd",
    "compositionend focusout keydown keypress keyup mousedown".split(" ")
  ), vo(
    "onCompositionStart",
    "compositionstart focusout keydown keypress keyup mousedown".split(" ")
  ), vo(
    "onCompositionUpdate",
    "compositionupdate focusout keydown keypress keyup mousedown".split(" ")
  );
  var bu = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(
    " "
  ), l6 = new Set(
    "beforetoggle cancel close invalid load scroll scrollend toggle".split(" ").concat(bu)
  );
  function t_(i, s) {
    s = (s & 4) !== 0;
    for (var c = 0; c < i.length; c++) {
      var h = i[c], b = h.event;
      h = h.listeners;
      e: {
        var S = void 0;
        if (s)
          for (var j = h.length - 1; 0 <= j; j--) {
            var I = h[j], Z = I.instance, ee = I.currentTarget;
            if (I = I.listener, Z !== S && b.isPropagationStopped())
              break e;
            S = I, b.currentTarget = ee;
            try {
              S(b);
            } catch (ue) {
              Ud(ue);
            }
            b.currentTarget = null, S = Z;
          }
        else
          for (j = 0; j < h.length; j++) {
            if (I = h[j], Z = I.instance, ee = I.currentTarget, I = I.listener, Z !== S && b.isPropagationStopped())
              break e;
            S = I, b.currentTarget = ee;
            try {
              S(b);
            } catch (ue) {
              Ud(ue);
            }
            b.currentTarget = null, S = Z;
          }
      }
    }
  }
  function qe(i, s) {
    var c = s[Rs];
    c === void 0 && (c = s[Rs] = /* @__PURE__ */ new Set());
    var h = i + "__bubble";
    c.has(h) || (n_(s, i, 2, !1), c.add(h));
  }
  function ey(i, s, c) {
    var h = 0;
    s && (h |= 4), n_(
      c,
      i,
      h,
      s
    );
  }
  var nf = "_reactListening" + Math.random().toString(36).slice(2);
  function ty(i) {
    if (!i[nf]) {
      i[nf] = !0, od.forEach(function(c) {
        c !== "selectionchange" && (l6.has(c) || ey(c, !1, i), ey(c, !0, i));
      });
      var s = i.nodeType === 9 ? i : i.ownerDocument;
      s === null || s[nf] || (s[nf] = !0, ey("selectionchange", !1, s));
    }
  }
  function n_(i, s, c, h) {
    switch (C_(s)) {
      case 2:
        var b = T6;
        break;
      case 8:
        b = z6;
        break;
      default:
        b = my;
    }
    c = b.bind(
      null,
      s,
      c,
      i
    ), b = void 0, !km || s !== "touchstart" && s !== "touchmove" && s !== "wheel" || (b = !0), h ? b !== void 0 ? i.addEventListener(s, c, {
      capture: !0,
      passive: b
    }) : i.addEventListener(s, c, !0) : b !== void 0 ? i.addEventListener(s, c, {
      passive: b
    }) : i.addEventListener(s, c, !1);
  }
  function ny(i, s, c, h, b) {
    var S = h;
    if ((s & 1) === 0 && (s & 2) === 0 && h !== null)
      e: for (; ; ) {
        if (h === null) return;
        var j = h.tag;
        if (j === 3 || j === 4) {
          var I = h.stateNode.containerInfo;
          if (I === b) break;
          if (j === 4)
            for (j = h.return; j !== null; ) {
              var Z = j.tag;
              if ((Z === 3 || Z === 4) && j.stateNode.containerInfo === b)
                return;
              j = j.return;
            }
          for (; I !== null; ) {
            if (j = go(I), j === null) return;
            if (Z = j.tag, Z === 5 || Z === 6 || Z === 26 || Z === 27) {
              h = S = j;
              continue e;
            }
            I = I.parentNode;
          }
        }
        h = h.return;
      }
    uS(function() {
      var ee = S, ue = xm(c), de = [];
      e: {
        var ne = LS.get(i);
        if (ne !== void 0) {
          var re = gd, ze = i;
          switch (i) {
            case "keypress":
              if (hd(c) === 0) break e;
            case "keydown":
            case "keyup":
              re = tT;
              break;
            case "focusin":
              ze = "focus", re = Om;
              break;
            case "focusout":
              ze = "blur", re = Om;
              break;
            case "beforeblur":
            case "afterblur":
              re = Om;
              break;
            case "click":
              if (c.button === 2) break e;
            case "auxclick":
            case "dblclick":
            case "mousedown":
            case "mousemove":
            case "mouseup":
            case "mouseout":
            case "mouseover":
            case "contextmenu":
              re = fS;
              break;
            case "drag":
            case "dragend":
            case "dragenter":
            case "dragexit":
            case "dragleave":
            case "dragover":
            case "dragstart":
            case "drop":
              re = FD;
              break;
            case "touchcancel":
            case "touchend":
            case "touchmove":
            case "touchstart":
              re = oT;
              break;
            case DS:
            case TS:
            case zS:
              re = qD;
              break;
            case PS:
              re = aT;
              break;
            case "scroll":
            case "scrollend":
              re = HD;
              break;
            case "wheel":
              re = sT;
              break;
            case "copy":
            case "cut":
            case "paste":
              re = GD;
              break;
            case "gotpointercapture":
            case "lostpointercapture":
            case "pointercancel":
            case "pointerdown":
            case "pointermove":
            case "pointerout":
            case "pointerover":
            case "pointerup":
              re = hS;
              break;
            case "toggle":
            case "beforetoggle":
              re = cT;
          }
          var Re = (s & 4) !== 0, ct = !Re && (i === "scroll" || i === "scrollend"), K = Re ? ne !== null ? ne + "Capture" : null : ne;
          Re = [];
          for (var W = ee, J; W !== null; ) {
            var ce = W;
            if (J = ce.stateNode, ce = ce.tag, ce !== 5 && ce !== 26 && ce !== 27 || J === null || K === null || (ce = Is(W, K), ce != null && Re.push(
              wu(W, ce, J)
            )), ct) break;
            W = W.return;
          }
          0 < Re.length && (ne = new re(
            ne,
            ze,
            null,
            c,
            ue
          ), de.push({ event: ne, listeners: Re }));
        }
      }
      if ((s & 7) === 0) {
        e: {
          if (ne = i === "mouseover" || i === "pointerover", re = i === "mouseout" || i === "pointerout", ne && c !== wm && (ze = c.relatedTarget || c.fromElement) && (go(ze) || ze[ni]))
            break e;
          if ((re || ne) && (ne = ue.window === ue ? ue : (ne = ue.ownerDocument) ? ne.defaultView || ne.parentWindow : window, re ? (ze = c.relatedTarget || c.toElement, re = ee, ze = ze ? go(ze) : null, ze !== null && (ct = a(ze), Re = ze.tag, ze !== ct || Re !== 5 && Re !== 27 && Re !== 6) && (ze = null)) : (re = null, ze = ee), re !== ze)) {
            if (Re = fS, ce = "onMouseLeave", K = "onMouseEnter", W = "mouse", (i === "pointerout" || i === "pointerover") && (Re = hS, ce = "onPointerLeave", K = "onPointerEnter", W = "pointer"), ct = re == null ? ne : ea(re), J = ze == null ? ne : ea(ze), ne = new Re(
              ce,
              W + "leave",
              re,
              c,
              ue
            ), ne.target = ct, ne.relatedTarget = J, ce = null, go(ue) === ee && (Re = new Re(
              K,
              W + "enter",
              ze,
              c,
              ue
            ), Re.target = J, Re.relatedTarget = ct, ce = Re), ct = ce, re && ze)
              t: {
                for (Re = re, K = ze, W = 0, J = Re; J; J = kl(J))
                  W++;
                for (J = 0, ce = K; ce; ce = kl(ce))
                  J++;
                for (; 0 < W - J; )
                  Re = kl(Re), W--;
                for (; 0 < J - W; )
                  K = kl(K), J--;
                for (; W--; ) {
                  if (Re === K || K !== null && Re === K.alternate)
                    break t;
                  Re = kl(Re), K = kl(K);
                }
                Re = null;
              }
            else Re = null;
            re !== null && r_(
              de,
              ne,
              re,
              Re,
              !1
            ), ze !== null && ct !== null && r_(
              de,
              ct,
              ze,
              Re,
              !0
            );
          }
        }
        e: {
          if (ne = ee ? ea(ee) : window, re = ne.nodeName && ne.nodeName.toLowerCase(), re === "select" || re === "input" && ne.type === "file")
            var be = SS;
          else if (wS(ne))
            if (kS)
              be = wT;
            else {
              be = vT;
              var $e = yT;
            }
          else
            re = ne.nodeName, !re || re.toLowerCase() !== "input" || ne.type !== "checkbox" && ne.type !== "radio" ? ee && bm(ee.elementType) && (be = SS) : be = bT;
          if (be && (be = be(i, ee))) {
            xS(
              de,
              be,
              c,
              ue
            );
            break e;
          }
          $e && $e(i, ne, ee), i === "focusout" && ee && ne.type === "number" && ee.memoizedProps.value != null && vm(ne, "number", ne.value);
        }
        switch ($e = ee ? ea(ee) : window, i) {
          case "focusin":
            (wS($e) || $e.contentEditable === "true") && (Ja = $e, Dm = ee, qs = null);
            break;
          case "focusout":
            qs = Dm = Ja = null;
            break;
          case "mousedown":
            Tm = !0;
            break;
          case "contextmenu":
          case "mouseup":
          case "dragend":
            Tm = !1, RS(de, c, ue);
            break;
          case "selectionchange":
            if (ST) break;
          case "keydown":
          case "keyup":
            RS(de, c, ue);
        }
        var _e;
        if (Mm)
          e: {
            switch (i) {
              case "compositionstart":
                var De = "onCompositionStart";
                break e;
              case "compositionend":
                De = "onCompositionEnd";
                break e;
              case "compositionupdate":
                De = "onCompositionUpdate";
                break e;
            }
            De = void 0;
          }
        else
          Qa ? vS(i, c) && (De = "onCompositionEnd") : i === "keydown" && c.keyCode === 229 && (De = "onCompositionStart");
        De && (mS && c.locale !== "ko" && (Qa || De !== "onCompositionStart" ? De === "onCompositionEnd" && Qa && (_e = cS()) : (li = ue, _m = "value" in li ? li.value : li.textContent, Qa = !0)), $e = rf(ee, De), 0 < $e.length && (De = new pS(
          De,
          i,
          null,
          c,
          ue
        ), de.push({ event: De, listeners: $e }), _e ? De.data = _e : (_e = bS(c), _e !== null && (De.data = _e)))), (_e = fT ? pT(i, c) : hT(i, c)) && (De = rf(ee, "onBeforeInput"), 0 < De.length && ($e = new pS(
          "onBeforeInput",
          "beforeinput",
          null,
          c,
          ue
        ), de.push({
          event: $e,
          listeners: De
        }), $e.data = _e)), o6(
          de,
          i,
          ee,
          c,
          ue
        );
      }
      t_(de, s);
    });
  }
  function wu(i, s, c) {
    return {
      instance: i,
      listener: s,
      currentTarget: c
    };
  }
  function rf(i, s) {
    for (var c = s + "Capture", h = []; i !== null; ) {
      var b = i, S = b.stateNode;
      if (b = b.tag, b !== 5 && b !== 26 && b !== 27 || S === null || (b = Is(i, c), b != null && h.unshift(
        wu(i, b, S)
      ), b = Is(i, s), b != null && h.push(
        wu(i, b, S)
      )), i.tag === 3) return h;
      i = i.return;
    }
    return [];
  }
  function kl(i) {
    if (i === null) return null;
    do
      i = i.return;
    while (i && i.tag !== 5 && i.tag !== 27);
    return i || null;
  }
  function r_(i, s, c, h, b) {
    for (var S = s._reactName, j = []; c !== null && c !== h; ) {
      var I = c, Z = I.alternate, ee = I.stateNode;
      if (I = I.tag, Z !== null && Z === h) break;
      I !== 5 && I !== 26 && I !== 27 || ee === null || (Z = ee, b ? (ee = Is(c, S), ee != null && j.unshift(
        wu(c, ee, Z)
      )) : b || (ee = Is(c, S), ee != null && j.push(
        wu(c, ee, Z)
      ))), c = c.return;
    }
    j.length !== 0 && i.push({ event: s, listeners: j });
  }
  var s6 = /\r\n?/g, u6 = /\u0000|\uFFFD/g;
  function o_(i) {
    return (typeof i == "string" ? i : "" + i).replace(s6, `
`).replace(u6, "");
  }
  function i_(i, s) {
    return s = o_(s), o_(i) === s;
  }
  function of() {
  }
  function ut(i, s, c, h, b, S) {
    switch (c) {
      case "children":
        typeof h == "string" ? s === "body" || s === "textarea" && h === "" || Za(i, h) : (typeof h == "number" || typeof h == "bigint") && s !== "body" && Za(i, "" + h);
        break;
      case "className":
        Ya(i, "class", h);
        break;
      case "tabIndex":
        Ya(i, "tabindex", h);
        break;
      case "dir":
      case "role":
      case "viewBox":
      case "width":
      case "height":
        Ya(i, c, h);
        break;
      case "style":
        lS(i, h, S);
        break;
      case "data":
        if (s !== "object") {
          Ya(i, "data", h);
          break;
        }
      case "src":
      case "href":
        if (h === "" && (s !== "a" || c !== "href")) {
          i.removeAttribute(c);
          break;
        }
        if (h == null || typeof h == "function" || typeof h == "symbol" || typeof h == "boolean") {
          i.removeAttribute(c);
          break;
        }
        h = fd("" + h), i.setAttribute(c, h);
        break;
      case "action":
      case "formAction":
        if (typeof h == "function") {
          i.setAttribute(
            c,
            "javascript:throw new Error('A React form was unexpectedly submitted. If you called form.submit() manually, consider using form.requestSubmit() instead. If you\\'re trying to use event.stopPropagation() in a submit event handler, consider also calling event.preventDefault().')"
          );
          break;
        } else
          typeof S == "function" && (c === "formAction" ? (s !== "input" && ut(i, s, "name", b.name, b, null), ut(
            i,
            s,
            "formEncType",
            b.formEncType,
            b,
            null
          ), ut(
            i,
            s,
            "formMethod",
            b.formMethod,
            b,
            null
          ), ut(
            i,
            s,
            "formTarget",
            b.formTarget,
            b,
            null
          )) : (ut(i, s, "encType", b.encType, b, null), ut(i, s, "method", b.method, b, null), ut(i, s, "target", b.target, b, null)));
        if (h == null || typeof h == "symbol" || typeof h == "boolean") {
          i.removeAttribute(c);
          break;
        }
        h = fd("" + h), i.setAttribute(c, h);
        break;
      case "onClick":
        h != null && (i.onclick = of);
        break;
      case "onScroll":
        h != null && qe("scroll", i);
        break;
      case "onScrollEnd":
        h != null && qe("scrollend", i);
        break;
      case "dangerouslySetInnerHTML":
        if (h != null) {
          if (typeof h != "object" || !("__html" in h))
            throw Error(r(61));
          if (c = h.__html, c != null) {
            if (b.children != null) throw Error(r(60));
            i.innerHTML = c;
          }
        }
        break;
      case "multiple":
        i.multiple = h && typeof h != "function" && typeof h != "symbol";
        break;
      case "muted":
        i.muted = h && typeof h != "function" && typeof h != "symbol";
        break;
      case "suppressContentEditableWarning":
      case "suppressHydrationWarning":
      case "defaultValue":
      case "defaultChecked":
      case "innerHTML":
      case "ref":
        break;
      case "autoFocus":
        break;
      case "xlinkHref":
        if (h == null || typeof h == "function" || typeof h == "boolean" || typeof h == "symbol") {
          i.removeAttribute("xlink:href");
          break;
        }
        c = fd("" + h), i.setAttributeNS(
          "http://www.w3.org/1999/xlink",
          "xlink:href",
          c
        );
        break;
      case "contentEditable":
      case "spellCheck":
      case "draggable":
      case "value":
      case "autoReverse":
      case "externalResourcesRequired":
      case "focusable":
      case "preserveAlpha":
        h != null && typeof h != "function" && typeof h != "symbol" ? i.setAttribute(c, "" + h) : i.removeAttribute(c);
        break;
      case "inert":
      case "allowFullScreen":
      case "async":
      case "autoPlay":
      case "controls":
      case "default":
      case "defer":
      case "disabled":
      case "disablePictureInPicture":
      case "disableRemotePlayback":
      case "formNoValidate":
      case "hidden":
      case "loop":
      case "noModule":
      case "noValidate":
      case "open":
      case "playsInline":
      case "readOnly":
      case "required":
      case "reversed":
      case "scoped":
      case "seamless":
      case "itemScope":
        h && typeof h != "function" && typeof h != "symbol" ? i.setAttribute(c, "") : i.removeAttribute(c);
        break;
      case "capture":
      case "download":
        h === !0 ? i.setAttribute(c, "") : h !== !1 && h != null && typeof h != "function" && typeof h != "symbol" ? i.setAttribute(c, h) : i.removeAttribute(c);
        break;
      case "cols":
      case "rows":
      case "size":
      case "span":
        h != null && typeof h != "function" && typeof h != "symbol" && !isNaN(h) && 1 <= h ? i.setAttribute(c, h) : i.removeAttribute(c);
        break;
      case "rowSpan":
      case "start":
        h == null || typeof h == "function" || typeof h == "symbol" || isNaN(h) ? i.removeAttribute(c) : i.setAttribute(c, h);
        break;
      case "popover":
        qe("beforetoggle", i), qe("toggle", i), $a(i, "popover", h);
        break;
      case "xlinkActuate":
        xr(
          i,
          "http://www.w3.org/1999/xlink",
          "xlink:actuate",
          h
        );
        break;
      case "xlinkArcrole":
        xr(
          i,
          "http://www.w3.org/1999/xlink",
          "xlink:arcrole",
          h
        );
        break;
      case "xlinkRole":
        xr(
          i,
          "http://www.w3.org/1999/xlink",
          "xlink:role",
          h
        );
        break;
      case "xlinkShow":
        xr(
          i,
          "http://www.w3.org/1999/xlink",
          "xlink:show",
          h
        );
        break;
      case "xlinkTitle":
        xr(
          i,
          "http://www.w3.org/1999/xlink",
          "xlink:title",
          h
        );
        break;
      case "xlinkType":
        xr(
          i,
          "http://www.w3.org/1999/xlink",
          "xlink:type",
          h
        );
        break;
      case "xmlBase":
        xr(
          i,
          "http://www.w3.org/XML/1998/namespace",
          "xml:base",
          h
        );
        break;
      case "xmlLang":
        xr(
          i,
          "http://www.w3.org/XML/1998/namespace",
          "xml:lang",
          h
        );
        break;
      case "xmlSpace":
        xr(
          i,
          "http://www.w3.org/XML/1998/namespace",
          "xml:space",
          h
        );
        break;
      case "is":
        $a(i, "is", h);
        break;
      case "innerText":
      case "textContent":
        break;
      default:
        (!(2 < c.length) || c[0] !== "o" && c[0] !== "O" || c[1] !== "n" && c[1] !== "N") && (c = BD.get(c) || c, $a(i, c, h));
    }
  }
  function ry(i, s, c, h, b, S) {
    switch (c) {
      case "style":
        lS(i, h, S);
        break;
      case "dangerouslySetInnerHTML":
        if (h != null) {
          if (typeof h != "object" || !("__html" in h))
            throw Error(r(61));
          if (c = h.__html, c != null) {
            if (b.children != null) throw Error(r(60));
            i.innerHTML = c;
          }
        }
        break;
      case "children":
        typeof h == "string" ? Za(i, h) : (typeof h == "number" || typeof h == "bigint") && Za(i, "" + h);
        break;
      case "onScroll":
        h != null && qe("scroll", i);
        break;
      case "onScrollEnd":
        h != null && qe("scrollend", i);
        break;
      case "onClick":
        h != null && (i.onclick = of);
        break;
      case "suppressContentEditableWarning":
      case "suppressHydrationWarning":
      case "innerHTML":
      case "ref":
        break;
      case "innerText":
      case "textContent":
        break;
      default:
        if (!id.hasOwnProperty(c))
          e: {
            if (c[0] === "o" && c[1] === "n" && (b = c.endsWith("Capture"), s = c.slice(2, b ? c.length - 7 : void 0), S = i[un] || null, S = S != null ? S[c] : null, typeof S == "function" && i.removeEventListener(s, S, b), typeof h == "function")) {
              typeof S != "function" && S !== null && (c in i ? i[c] = null : i.hasAttribute(c) && i.removeAttribute(c)), i.addEventListener(s, h, b);
              break e;
            }
            c in i ? i[c] = h : h === !0 ? i.setAttribute(c, "") : $a(i, c, h);
          }
    }
  }
  function rn(i, s, c) {
    switch (s) {
      case "div":
      case "span":
      case "svg":
      case "path":
      case "a":
      case "g":
      case "p":
      case "li":
        break;
      case "img":
        qe("error", i), qe("load", i);
        var h = !1, b = !1, S;
        for (S in c)
          if (c.hasOwnProperty(S)) {
            var j = c[S];
            if (j != null)
              switch (S) {
                case "src":
                  h = !0;
                  break;
                case "srcSet":
                  b = !0;
                  break;
                case "children":
                case "dangerouslySetInnerHTML":
                  throw Error(r(137, s));
                default:
                  ut(i, s, S, j, c, null);
              }
          }
        b && ut(i, s, "srcSet", c.srcSet, c, null), h && ut(i, s, "src", c.src, c, null);
        return;
      case "input":
        qe("invalid", i);
        var I = S = j = b = null, Z = null, ee = null;
        for (h in c)
          if (c.hasOwnProperty(h)) {
            var ue = c[h];
            if (ue != null)
              switch (h) {
                case "name":
                  b = ue;
                  break;
                case "type":
                  j = ue;
                  break;
                case "checked":
                  Z = ue;
                  break;
                case "defaultChecked":
                  ee = ue;
                  break;
                case "value":
                  S = ue;
                  break;
                case "defaultValue":
                  I = ue;
                  break;
                case "children":
                case "dangerouslySetInnerHTML":
                  if (ue != null)
                    throw Error(r(137, s));
                  break;
                default:
                  ut(i, s, h, ue, c, null);
              }
          }
        rS(
          i,
          S,
          I,
          Z,
          ee,
          j,
          b,
          !1
        ), qa(i);
        return;
      case "select":
        qe("invalid", i), h = j = S = null;
        for (b in c)
          if (c.hasOwnProperty(b) && (I = c[b], I != null))
            switch (b) {
              case "value":
                S = I;
                break;
              case "defaultValue":
                j = I;
                break;
              case "multiple":
                h = I;
              default:
                ut(i, s, b, I, c, null);
            }
        s = S, c = j, i.multiple = !!h, s != null ? Ga(i, !!h, s, !1) : c != null && Ga(i, !!h, c, !0);
        return;
      case "textarea":
        qe("invalid", i), S = b = h = null;
        for (j in c)
          if (c.hasOwnProperty(j) && (I = c[j], I != null))
            switch (j) {
              case "value":
                h = I;
                break;
              case "defaultValue":
                b = I;
                break;
              case "children":
                S = I;
                break;
              case "dangerouslySetInnerHTML":
                if (I != null) throw Error(r(91));
                break;
              default:
                ut(i, s, j, I, c, null);
            }
        iS(i, h, b, S), qa(i);
        return;
      case "option":
        for (Z in c)
          if (c.hasOwnProperty(Z) && (h = c[Z], h != null))
            switch (Z) {
              case "selected":
                i.selected = h && typeof h != "function" && typeof h != "symbol";
                break;
              default:
                ut(i, s, Z, h, c, null);
            }
        return;
      case "dialog":
        qe("beforetoggle", i), qe("toggle", i), qe("cancel", i), qe("close", i);
        break;
      case "iframe":
      case "object":
        qe("load", i);
        break;
      case "video":
      case "audio":
        for (h = 0; h < bu.length; h++)
          qe(bu[h], i);
        break;
      case "image":
        qe("error", i), qe("load", i);
        break;
      case "details":
        qe("toggle", i);
        break;
      case "embed":
      case "source":
      case "link":
        qe("error", i), qe("load", i);
      case "area":
      case "base":
      case "br":
      case "col":
      case "hr":
      case "keygen":
      case "meta":
      case "param":
      case "track":
      case "wbr":
      case "menuitem":
        for (ee in c)
          if (c.hasOwnProperty(ee) && (h = c[ee], h != null))
            switch (ee) {
              case "children":
              case "dangerouslySetInnerHTML":
                throw Error(r(137, s));
              default:
                ut(i, s, ee, h, c, null);
            }
        return;
      default:
        if (bm(s)) {
          for (ue in c)
            c.hasOwnProperty(ue) && (h = c[ue], h !== void 0 && ry(
              i,
              s,
              ue,
              h,
              c,
              void 0
            ));
          return;
        }
    }
    for (I in c)
      c.hasOwnProperty(I) && (h = c[I], h != null && ut(i, s, I, h, c, null));
  }
  function c6(i, s, c, h) {
    switch (s) {
      case "div":
      case "span":
      case "svg":
      case "path":
      case "a":
      case "g":
      case "p":
      case "li":
        break;
      case "input":
        var b = null, S = null, j = null, I = null, Z = null, ee = null, ue = null;
        for (re in c) {
          var de = c[re];
          if (c.hasOwnProperty(re) && de != null)
            switch (re) {
              case "checked":
                break;
              case "value":
                break;
              case "defaultValue":
                Z = de;
              default:
                h.hasOwnProperty(re) || ut(i, s, re, null, h, de);
            }
        }
        for (var ne in h) {
          var re = h[ne];
          if (de = c[ne], h.hasOwnProperty(ne) && (re != null || de != null))
            switch (ne) {
              case "type":
                S = re;
                break;
              case "name":
                b = re;
                break;
              case "checked":
                ee = re;
                break;
              case "defaultChecked":
                ue = re;
                break;
              case "value":
                j = re;
                break;
              case "defaultValue":
                I = re;
                break;
              case "children":
              case "dangerouslySetInnerHTML":
                if (re != null)
                  throw Error(r(137, s));
                break;
              default:
                re !== de && ut(
                  i,
                  s,
                  ne,
                  re,
                  h,
                  de
                );
            }
        }
        Xa(
          i,
          j,
          I,
          Z,
          ee,
          ue,
          S,
          b
        );
        return;
      case "select":
        re = j = I = ne = null;
        for (S in c)
          if (Z = c[S], c.hasOwnProperty(S) && Z != null)
            switch (S) {
              case "value":
                break;
              case "multiple":
                re = Z;
              default:
                h.hasOwnProperty(S) || ut(
                  i,
                  s,
                  S,
                  null,
                  h,
                  Z
                );
            }
        for (b in h)
          if (S = h[b], Z = c[b], h.hasOwnProperty(b) && (S != null || Z != null))
            switch (b) {
              case "value":
                ne = S;
                break;
              case "defaultValue":
                I = S;
                break;
              case "multiple":
                j = S;
              default:
                S !== Z && ut(
                  i,
                  s,
                  b,
                  S,
                  h,
                  Z
                );
            }
        s = I, c = j, h = re, ne != null ? Ga(i, !!c, ne, !1) : !!h != !!c && (s != null ? Ga(i, !!c, s, !0) : Ga(i, !!c, c ? [] : "", !1));
        return;
      case "textarea":
        re = ne = null;
        for (I in c)
          if (b = c[I], c.hasOwnProperty(I) && b != null && !h.hasOwnProperty(I))
            switch (I) {
              case "value":
                break;
              case "children":
                break;
              default:
                ut(i, s, I, null, h, b);
            }
        for (j in h)
          if (b = h[j], S = c[j], h.hasOwnProperty(j) && (b != null || S != null))
            switch (j) {
              case "value":
                ne = b;
                break;
              case "defaultValue":
                re = b;
                break;
              case "children":
                break;
              case "dangerouslySetInnerHTML":
                if (b != null) throw Error(r(91));
                break;
              default:
                b !== S && ut(i, s, j, b, h, S);
            }
        oS(i, ne, re);
        return;
      case "option":
        for (var ze in c)
          if (ne = c[ze], c.hasOwnProperty(ze) && ne != null && !h.hasOwnProperty(ze))
            switch (ze) {
              case "selected":
                i.selected = !1;
                break;
              default:
                ut(
                  i,
                  s,
                  ze,
                  null,
                  h,
                  ne
                );
            }
        for (Z in h)
          if (ne = h[Z], re = c[Z], h.hasOwnProperty(Z) && ne !== re && (ne != null || re != null))
            switch (Z) {
              case "selected":
                i.selected = ne && typeof ne != "function" && typeof ne != "symbol";
                break;
              default:
                ut(
                  i,
                  s,
                  Z,
                  ne,
                  h,
                  re
                );
            }
        return;
      case "img":
      case "link":
      case "area":
      case "base":
      case "br":
      case "col":
      case "embed":
      case "hr":
      case "keygen":
      case "meta":
      case "param":
      case "source":
      case "track":
      case "wbr":
      case "menuitem":
        for (var Re in c)
          ne = c[Re], c.hasOwnProperty(Re) && ne != null && !h.hasOwnProperty(Re) && ut(i, s, Re, null, h, ne);
        for (ee in h)
          if (ne = h[ee], re = c[ee], h.hasOwnProperty(ee) && ne !== re && (ne != null || re != null))
            switch (ee) {
              case "children":
              case "dangerouslySetInnerHTML":
                if (ne != null)
                  throw Error(r(137, s));
                break;
              default:
                ut(
                  i,
                  s,
                  ee,
                  ne,
                  h,
                  re
                );
            }
        return;
      default:
        if (bm(s)) {
          for (var ct in c)
            ne = c[ct], c.hasOwnProperty(ct) && ne !== void 0 && !h.hasOwnProperty(ct) && ry(
              i,
              s,
              ct,
              void 0,
              h,
              ne
            );
          for (ue in h)
            ne = h[ue], re = c[ue], !h.hasOwnProperty(ue) || ne === re || ne === void 0 && re === void 0 || ry(
              i,
              s,
              ue,
              ne,
              h,
              re
            );
          return;
        }
    }
    for (var K in c)
      ne = c[K], c.hasOwnProperty(K) && ne != null && !h.hasOwnProperty(K) && ut(i, s, K, null, h, ne);
    for (de in h)
      ne = h[de], re = c[de], !h.hasOwnProperty(de) || ne === re || ne == null && re == null || ut(i, s, de, ne, h, re);
  }
  var oy = null, iy = null;
  function af(i) {
    return i.nodeType === 9 ? i : i.ownerDocument;
  }
  function a_(i) {
    switch (i) {
      case "http://www.w3.org/2000/svg":
        return 1;
      case "http://www.w3.org/1998/Math/MathML":
        return 2;
      default:
        return 0;
    }
  }
  function l_(i, s) {
    if (i === 0)
      switch (s) {
        case "svg":
          return 1;
        case "math":
          return 2;
        default:
          return 0;
      }
    return i === 1 && s === "foreignObject" ? 0 : i;
  }
  function ay(i, s) {
    return i === "textarea" || i === "noscript" || typeof s.children == "string" || typeof s.children == "number" || typeof s.children == "bigint" || typeof s.dangerouslySetInnerHTML == "object" && s.dangerouslySetInnerHTML !== null && s.dangerouslySetInnerHTML.__html != null;
  }
  var ly = null;
  function d6() {
    var i = window.event;
    return i && i.type === "popstate" ? i === ly ? !1 : (ly = i, !0) : (ly = null, !1);
  }
  var s_ = typeof setTimeout == "function" ? setTimeout : void 0, f6 = typeof clearTimeout == "function" ? clearTimeout : void 0, u_ = typeof Promise == "function" ? Promise : void 0, p6 = typeof queueMicrotask == "function" ? queueMicrotask : typeof u_ < "u" ? function(i) {
    return u_.resolve(null).then(i).catch(h6);
  } : s_;
  function h6(i) {
    setTimeout(function() {
      throw i;
    });
  }
  function ki(i) {
    return i === "head";
  }
  function c_(i, s) {
    var c = s, h = 0, b = 0;
    do {
      var S = c.nextSibling;
      if (i.removeChild(c), S && S.nodeType === 8)
        if (c = S.data, c === "/$") {
          if (0 < h && 8 > h) {
            c = h;
            var j = i.ownerDocument;
            if (c & 1 && xu(j.documentElement), c & 2 && xu(j.body), c & 4)
              for (c = j.head, xu(c), j = c.firstChild; j; ) {
                var I = j.nextSibling, Z = j.nodeName;
                j[Ji] || Z === "SCRIPT" || Z === "STYLE" || Z === "LINK" && j.rel.toLowerCase() === "stylesheet" || c.removeChild(j), j = I;
              }
          }
          if (b === 0) {
            i.removeChild(S), Mu(s);
            return;
          }
          b--;
        } else
          c === "$" || c === "$?" || c === "$!" ? b++ : h = c.charCodeAt(0) - 48;
      else h = 0;
      c = S;
    } while (c);
    Mu(s);
  }
  function sy(i) {
    var s = i.firstChild;
    for (s && s.nodeType === 10 && (s = s.nextSibling); s; ) {
      var c = s;
      switch (s = s.nextSibling, c.nodeName) {
        case "HTML":
        case "HEAD":
        case "BODY":
          sy(c), js(c);
          continue;
        case "SCRIPT":
        case "STYLE":
          continue;
        case "LINK":
          if (c.rel.toLowerCase() === "stylesheet") continue;
      }
      i.removeChild(c);
    }
  }
  function m6(i, s, c, h) {
    for (; i.nodeType === 1; ) {
      var b = c;
      if (i.nodeName.toLowerCase() !== s.toLowerCase()) {
        if (!h && (i.nodeName !== "INPUT" || i.type !== "hidden"))
          break;
      } else if (h) {
        if (!i[Ji])
          switch (s) {
            case "meta":
              if (!i.hasAttribute("itemprop")) break;
              return i;
            case "link":
              if (S = i.getAttribute("rel"), S === "stylesheet" && i.hasAttribute("data-precedence"))
                break;
              if (S !== b.rel || i.getAttribute("href") !== (b.href == null || b.href === "" ? null : b.href) || i.getAttribute("crossorigin") !== (b.crossOrigin == null ? null : b.crossOrigin) || i.getAttribute("title") !== (b.title == null ? null : b.title))
                break;
              return i;
            case "style":
              if (i.hasAttribute("data-precedence")) break;
              return i;
            case "script":
              if (S = i.getAttribute("src"), (S !== (b.src == null ? null : b.src) || i.getAttribute("type") !== (b.type == null ? null : b.type) || i.getAttribute("crossorigin") !== (b.crossOrigin == null ? null : b.crossOrigin)) && S && i.hasAttribute("async") && !i.hasAttribute("itemprop"))
                break;
              return i;
            default:
              return i;
          }
      } else if (s === "input" && i.type === "hidden") {
        var S = b.name == null ? null : "" + b.name;
        if (b.type === "hidden" && i.getAttribute("name") === S)
          return i;
      } else return i;
      if (i = _r(i.nextSibling), i === null) break;
    }
    return null;
  }
  function g6(i, s, c) {
    if (s === "") return null;
    for (; i.nodeType !== 3; )
      if ((i.nodeType !== 1 || i.nodeName !== "INPUT" || i.type !== "hidden") && !c || (i = _r(i.nextSibling), i === null)) return null;
    return i;
  }
  function uy(i) {
    return i.data === "$!" || i.data === "$?" && i.ownerDocument.readyState === "complete";
  }
  function y6(i, s) {
    var c = i.ownerDocument;
    if (i.data !== "$?" || c.readyState === "complete")
      s();
    else {
      var h = function() {
        s(), c.removeEventListener("DOMContentLoaded", h);
      };
      c.addEventListener("DOMContentLoaded", h), i._reactRetry = h;
    }
  }
  function _r(i) {
    for (; i != null; i = i.nextSibling) {
      var s = i.nodeType;
      if (s === 1 || s === 3) break;
      if (s === 8) {
        if (s = i.data, s === "$" || s === "$!" || s === "$?" || s === "F!" || s === "F")
          break;
        if (s === "/$") return null;
      }
    }
    return i;
  }
  var cy = null;
  function d_(i) {
    i = i.previousSibling;
    for (var s = 0; i; ) {
      if (i.nodeType === 8) {
        var c = i.data;
        if (c === "$" || c === "$!" || c === "$?") {
          if (s === 0) return i;
          s--;
        } else c === "/$" && s++;
      }
      i = i.previousSibling;
    }
    return null;
  }
  function f_(i, s, c) {
    switch (s = af(c), i) {
      case "html":
        if (i = s.documentElement, !i) throw Error(r(452));
        return i;
      case "head":
        if (i = s.head, !i) throw Error(r(453));
        return i;
      case "body":
        if (i = s.body, !i) throw Error(r(454));
        return i;
      default:
        throw Error(r(451));
    }
  }
  function xu(i) {
    for (var s = i.attributes; s.length; )
      i.removeAttributeNode(s[0]);
    js(i);
  }
  var fr = /* @__PURE__ */ new Map(), p_ = /* @__PURE__ */ new Set();
  function lf(i) {
    return typeof i.getRootNode == "function" ? i.getRootNode() : i.nodeType === 9 ? i : i.ownerDocument;
  }
  var jo = H.d;
  H.d = {
    f: v6,
    r: b6,
    D: w6,
    C: x6,
    L: S6,
    m: k6,
    X: E6,
    S: _6,
    M: C6
  };
  function v6() {
    var i = jo.f(), s = Kd();
    return i || s;
  }
  function b6(i) {
    var s = yo(i);
    s !== null && s.tag === 5 && s.type === "form" ? Dk(s) : jo.r(i);
  }
  var _l = typeof document > "u" ? null : document;
  function h_(i, s, c) {
    var h = _l;
    if (h && typeof s == "string" && s) {
      var b = Nn(s);
      b = 'link[rel="' + i + '"][href="' + b + '"]', typeof c == "string" && (b += '[crossorigin="' + c + '"]'), p_.has(b) || (p_.add(b), i = { rel: i, crossOrigin: c, href: s }, h.querySelector(b) === null && (s = h.createElement("link"), rn(s, "link", i), It(s), h.head.appendChild(s)));
    }
  }
  function w6(i) {
    jo.D(i), h_("dns-prefetch", i, null);
  }
  function x6(i, s) {
    jo.C(i, s), h_("preconnect", i, s);
  }
  function S6(i, s, c) {
    jo.L(i, s, c);
    var h = _l;
    if (h && i && s) {
      var b = 'link[rel="preload"][as="' + Nn(s) + '"]';
      s === "image" && c && c.imageSrcSet ? (b += '[imagesrcset="' + Nn(
        c.imageSrcSet
      ) + '"]', typeof c.imageSizes == "string" && (b += '[imagesizes="' + Nn(
        c.imageSizes
      ) + '"]')) : b += '[href="' + Nn(i) + '"]';
      var S = b;
      switch (s) {
        case "style":
          S = El(i);
          break;
        case "script":
          S = Cl(i);
      }
      fr.has(S) || (i = p(
        {
          rel: "preload",
          href: s === "image" && c && c.imageSrcSet ? void 0 : i,
          as: s
        },
        c
      ), fr.set(S, i), h.querySelector(b) !== null || s === "style" && h.querySelector(Su(S)) || s === "script" && h.querySelector(ku(S)) || (s = h.createElement("link"), rn(s, "link", i), It(s), h.head.appendChild(s)));
    }
  }
  function k6(i, s) {
    jo.m(i, s);
    var c = _l;
    if (c && i) {
      var h = s && typeof s.as == "string" ? s.as : "script", b = 'link[rel="modulepreload"][as="' + Nn(h) + '"][href="' + Nn(i) + '"]', S = b;
      switch (h) {
        case "audioworklet":
        case "paintworklet":
        case "serviceworker":
        case "sharedworker":
        case "worker":
        case "script":
          S = Cl(i);
      }
      if (!fr.has(S) && (i = p({ rel: "modulepreload", href: i }, s), fr.set(S, i), c.querySelector(b) === null)) {
        switch (h) {
          case "audioworklet":
          case "paintworklet":
          case "serviceworker":
          case "sharedworker":
          case "worker":
          case "script":
            if (c.querySelector(ku(S)))
              return;
        }
        h = c.createElement("link"), rn(h, "link", i), It(h), c.head.appendChild(h);
      }
    }
  }
  function _6(i, s, c) {
    jo.S(i, s, c);
    var h = _l;
    if (h && i) {
      var b = ri(h).hoistableStyles, S = El(i);
      s = s || "default";
      var j = b.get(S);
      if (!j) {
        var I = { loading: 0, preload: null };
        if (j = h.querySelector(
          Su(S)
        ))
          I.loading = 5;
        else {
          i = p(
            { rel: "stylesheet", href: i, "data-precedence": s },
            c
          ), (c = fr.get(S)) && dy(i, c);
          var Z = j = h.createElement("link");
          It(Z), rn(Z, "link", i), Z._p = new Promise(function(ee, ue) {
            Z.onload = ee, Z.onerror = ue;
          }), Z.addEventListener("load", function() {
            I.loading |= 1;
          }), Z.addEventListener("error", function() {
            I.loading |= 2;
          }), I.loading |= 4, sf(j, s, h);
        }
        j = {
          type: "stylesheet",
          instance: j,
          count: 1,
          state: I
        }, b.set(S, j);
      }
    }
  }
  function E6(i, s) {
    jo.X(i, s);
    var c = _l;
    if (c && i) {
      var h = ri(c).hoistableScripts, b = Cl(i), S = h.get(b);
      S || (S = c.querySelector(ku(b)), S || (i = p({ src: i, async: !0 }, s), (s = fr.get(b)) && fy(i, s), S = c.createElement("script"), It(S), rn(S, "link", i), c.head.appendChild(S)), S = {
        type: "script",
        instance: S,
        count: 1,
        state: null
      }, h.set(b, S));
    }
  }
  function C6(i, s) {
    jo.M(i, s);
    var c = _l;
    if (c && i) {
      var h = ri(c).hoistableScripts, b = Cl(i), S = h.get(b);
      S || (S = c.querySelector(ku(b)), S || (i = p({ src: i, async: !0, type: "module" }, s), (s = fr.get(b)) && fy(i, s), S = c.createElement("script"), It(S), rn(S, "link", i), c.head.appendChild(S)), S = {
        type: "script",
        instance: S,
        count: 1,
        state: null
      }, h.set(b, S));
    }
  }
  function m_(i, s, c, h) {
    var b = (b = ae.current) ? lf(b) : null;
    if (!b) throw Error(r(446));
    switch (i) {
      case "meta":
      case "title":
        return null;
      case "style":
        return typeof c.precedence == "string" && typeof c.href == "string" ? (s = El(c.href), c = ri(
          b
        ).hoistableStyles, h = c.get(s), h || (h = {
          type: "style",
          instance: null,
          count: 0,
          state: null
        }, c.set(s, h)), h) : { type: "void", instance: null, count: 0, state: null };
      case "link":
        if (c.rel === "stylesheet" && typeof c.href == "string" && typeof c.precedence == "string") {
          i = El(c.href);
          var S = ri(
            b
          ).hoistableStyles, j = S.get(i);
          if (j || (b = b.ownerDocument || b, j = {
            type: "stylesheet",
            instance: null,
            count: 0,
            state: { loading: 0, preload: null }
          }, S.set(i, j), (S = b.querySelector(
            Su(i)
          )) && !S._p && (j.instance = S, j.state.loading = 5), fr.has(i) || (c = {
            rel: "preload",
            as: "style",
            href: c.href,
            crossOrigin: c.crossOrigin,
            integrity: c.integrity,
            media: c.media,
            hrefLang: c.hrefLang,
            referrerPolicy: c.referrerPolicy
          }, fr.set(i, c), S || O6(
            b,
            i,
            c,
            j.state
          ))), s && h === null)
            throw Error(r(528, ""));
          return j;
        }
        if (s && h !== null)
          throw Error(r(529, ""));
        return null;
      case "script":
        return s = c.async, c = c.src, typeof c == "string" && s && typeof s != "function" && typeof s != "symbol" ? (s = Cl(c), c = ri(
          b
        ).hoistableScripts, h = c.get(s), h || (h = {
          type: "script",
          instance: null,
          count: 0,
          state: null
        }, c.set(s, h)), h) : { type: "void", instance: null, count: 0, state: null };
      default:
        throw Error(r(444, i));
    }
  }
  function El(i) {
    return 'href="' + Nn(i) + '"';
  }
  function Su(i) {
    return 'link[rel="stylesheet"][' + i + "]";
  }
  function g_(i) {
    return p({}, i, {
      "data-precedence": i.precedence,
      precedence: null
    });
  }
  function O6(i, s, c, h) {
    i.querySelector('link[rel="preload"][as="style"][' + s + "]") ? h.loading = 1 : (s = i.createElement("link"), h.preload = s, s.addEventListener("load", function() {
      return h.loading |= 1;
    }), s.addEventListener("error", function() {
      return h.loading |= 2;
    }), rn(s, "link", c), It(s), i.head.appendChild(s));
  }
  function Cl(i) {
    return '[src="' + Nn(i) + '"]';
  }
  function ku(i) {
    return "script[async]" + i;
  }
  function y_(i, s, c) {
    if (s.count++, s.instance === null)
      switch (s.type) {
        case "style":
          var h = i.querySelector(
            'style[data-href~="' + Nn(c.href) + '"]'
          );
          if (h)
            return s.instance = h, It(h), h;
          var b = p({}, c, {
            "data-href": c.href,
            "data-precedence": c.precedence,
            href: null,
            precedence: null
          });
          return h = (i.ownerDocument || i).createElement(
            "style"
          ), It(h), rn(h, "style", b), sf(h, c.precedence, i), s.instance = h;
        case "stylesheet":
          b = El(c.href);
          var S = i.querySelector(
            Su(b)
          );
          if (S)
            return s.state.loading |= 4, s.instance = S, It(S), S;
          h = g_(c), (b = fr.get(b)) && dy(h, b), S = (i.ownerDocument || i).createElement("link"), It(S);
          var j = S;
          return j._p = new Promise(function(I, Z) {
            j.onload = I, j.onerror = Z;
          }), rn(S, "link", h), s.state.loading |= 4, sf(S, c.precedence, i), s.instance = S;
        case "script":
          return S = Cl(c.src), (b = i.querySelector(
            ku(S)
          )) ? (s.instance = b, It(b), b) : (h = c, (b = fr.get(S)) && (h = p({}, c), fy(h, b)), i = i.ownerDocument || i, b = i.createElement("script"), It(b), rn(b, "link", h), i.head.appendChild(b), s.instance = b);
        case "void":
          return null;
        default:
          throw Error(r(443, s.type));
      }
    else
      s.type === "stylesheet" && (s.state.loading & 4) === 0 && (h = s.instance, s.state.loading |= 4, sf(h, c.precedence, i));
    return s.instance;
  }
  function sf(i, s, c) {
    for (var h = c.querySelectorAll(
      'link[rel="stylesheet"][data-precedence],style[data-precedence]'
    ), b = h.length ? h[h.length - 1] : null, S = b, j = 0; j < h.length; j++) {
      var I = h[j];
      if (I.dataset.precedence === s) S = I;
      else if (S !== b) break;
    }
    S ? S.parentNode.insertBefore(i, S.nextSibling) : (s = c.nodeType === 9 ? c.head : c, s.insertBefore(i, s.firstChild));
  }
  function dy(i, s) {
    i.crossOrigin == null && (i.crossOrigin = s.crossOrigin), i.referrerPolicy == null && (i.referrerPolicy = s.referrerPolicy), i.title == null && (i.title = s.title);
  }
  function fy(i, s) {
    i.crossOrigin == null && (i.crossOrigin = s.crossOrigin), i.referrerPolicy == null && (i.referrerPolicy = s.referrerPolicy), i.integrity == null && (i.integrity = s.integrity);
  }
  var uf = null;
  function v_(i, s, c) {
    if (uf === null) {
      var h = /* @__PURE__ */ new Map(), b = uf = /* @__PURE__ */ new Map();
      b.set(c, h);
    } else
      b = uf, h = b.get(c), h || (h = /* @__PURE__ */ new Map(), b.set(c, h));
    if (h.has(i)) return h;
    for (h.set(i, null), c = c.getElementsByTagName(i), b = 0; b < c.length; b++) {
      var S = c[b];
      if (!(S[Ji] || S[Wt] || i === "link" && S.getAttribute("rel") === "stylesheet") && S.namespaceURI !== "http://www.w3.org/2000/svg") {
        var j = S.getAttribute(s) || "";
        j = i + j;
        var I = h.get(j);
        I ? I.push(S) : h.set(j, [S]);
      }
    }
    return h;
  }
  function b_(i, s, c) {
    i = i.ownerDocument || i, i.head.insertBefore(
      c,
      s === "title" ? i.querySelector("head > title") : null
    );
  }
  function N6(i, s, c) {
    if (c === 1 || s.itemProp != null) return !1;
    switch (i) {
      case "meta":
      case "title":
        return !0;
      case "style":
        if (typeof s.precedence != "string" || typeof s.href != "string" || s.href === "")
          break;
        return !0;
      case "link":
        if (typeof s.rel != "string" || typeof s.href != "string" || s.href === "" || s.onLoad || s.onError)
          break;
        switch (s.rel) {
          case "stylesheet":
            return i = s.disabled, typeof s.precedence == "string" && i == null;
          default:
            return !0;
        }
      case "script":
        if (s.async && typeof s.async != "function" && typeof s.async != "symbol" && !s.onLoad && !s.onError && s.src && typeof s.src == "string")
          return !0;
    }
    return !1;
  }
  function w_(i) {
    return !(i.type === "stylesheet" && (i.state.loading & 3) === 0);
  }
  var _u = null;
  function M6() {
  }
  function A6(i, s, c) {
    if (_u === null) throw Error(r(475));
    var h = _u;
    if (s.type === "stylesheet" && (typeof c.media != "string" || matchMedia(c.media).matches !== !1) && (s.state.loading & 4) === 0) {
      if (s.instance === null) {
        var b = El(c.href), S = i.querySelector(
          Su(b)
        );
        if (S) {
          i = S._p, i !== null && typeof i == "object" && typeof i.then == "function" && (h.count++, h = cf.bind(h), i.then(h, h)), s.state.loading |= 4, s.instance = S, It(S);
          return;
        }
        S = i.ownerDocument || i, c = g_(c), (b = fr.get(b)) && dy(c, b), S = S.createElement("link"), It(S);
        var j = S;
        j._p = new Promise(function(I, Z) {
          j.onload = I, j.onerror = Z;
        }), rn(S, "link", c), s.instance = S;
      }
      h.stylesheets === null && (h.stylesheets = /* @__PURE__ */ new Map()), h.stylesheets.set(s, i), (i = s.state.preload) && (s.state.loading & 3) === 0 && (h.count++, s = cf.bind(h), i.addEventListener("load", s), i.addEventListener("error", s));
    }
  }
  function R6() {
    if (_u === null) throw Error(r(475));
    var i = _u;
    return i.stylesheets && i.count === 0 && py(i, i.stylesheets), 0 < i.count ? function(s) {
      var c = setTimeout(function() {
        if (i.stylesheets && py(i, i.stylesheets), i.unsuspend) {
          var h = i.unsuspend;
          i.unsuspend = null, h();
        }
      }, 6e4);
      return i.unsuspend = s, function() {
        i.unsuspend = null, clearTimeout(c);
      };
    } : null;
  }
  function cf() {
    if (this.count--, this.count === 0) {
      if (this.stylesheets) py(this, this.stylesheets);
      else if (this.unsuspend) {
        var i = this.unsuspend;
        this.unsuspend = null, i();
      }
    }
  }
  var df = null;
  function py(i, s) {
    i.stylesheets = null, i.unsuspend !== null && (i.count++, df = /* @__PURE__ */ new Map(), s.forEach(j6, i), df = null, cf.call(i));
  }
  function j6(i, s) {
    if (!(s.state.loading & 4)) {
      var c = df.get(i);
      if (c) var h = c.get(null);
      else {
        c = /* @__PURE__ */ new Map(), df.set(i, c);
        for (var b = i.querySelectorAll(
          "link[data-precedence],style[data-precedence]"
        ), S = 0; S < b.length; S++) {
          var j = b[S];
          (j.nodeName === "LINK" || j.getAttribute("media") !== "not all") && (c.set(j.dataset.precedence, j), h = j);
        }
        h && c.set(null, h);
      }
      b = s.instance, j = b.getAttribute("data-precedence"), S = c.get(j) || h, S === h && c.set(null, b), c.set(j, b), this.count++, h = cf.bind(this), b.addEventListener("load", h), b.addEventListener("error", h), S ? S.parentNode.insertBefore(b, S.nextSibling) : (i = i.nodeType === 9 ? i.head : i, i.insertBefore(b, i.firstChild)), s.state.loading |= 4;
    }
  }
  var Eu = {
    $$typeof: C,
    Provider: null,
    Consumer: null,
    _currentValue: q,
    _currentValue2: q,
    _threadCount: 0
  };
  function D6(i, s, c, h, b, S, j, I) {
    this.tag = 1, this.containerInfo = i, this.pingCache = this.current = this.pendingChildren = null, this.timeoutHandle = -1, this.callbackNode = this.next = this.pendingContext = this.context = this.cancelPendingCommit = null, this.callbackPriority = 0, this.expirationTimes = Os(-1), this.entangledLanes = this.shellSuspendCounter = this.errorRecoveryDisabledLanes = this.expiredLanes = this.warmLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0, this.entanglements = Os(0), this.hiddenUpdates = Os(null), this.identifierPrefix = h, this.onUncaughtError = b, this.onCaughtError = S, this.onRecoverableError = j, this.pooledCache = null, this.pooledCacheLanes = 0, this.formState = I, this.incompleteTransitions = /* @__PURE__ */ new Map();
  }
  function x_(i, s, c, h, b, S, j, I, Z, ee, ue, de) {
    return i = new D6(
      i,
      s,
      c,
      j,
      I,
      Z,
      ee,
      de
    ), s = 1, S === !0 && (s |= 24), S = Un(3, null, null, s), i.current = S, S.stateNode = i, s = Gm(), s.refCount++, i.pooledCache = s, s.refCount++, S.memoizedState = {
      element: h,
      isDehydrated: c,
      cache: s
    }, Qm(S), i;
  }
  function S_(i) {
    return i ? (i = rl, i) : rl;
  }
  function k_(i, s, c, h, b, S) {
    b = S_(b), h.context === null ? h.context = b : h.pendingContext = b, h = ci(s), h.payload = { element: c }, S = S === void 0 ? null : S, S !== null && (h.callback = S), c = di(i, h, s), c !== null && (Xn(c, i, s), tu(c, i, s));
  }
  function __(i, s) {
    if (i = i.memoizedState, i !== null && i.dehydrated !== null) {
      var c = i.retryLane;
      i.retryLane = c !== 0 && c < s ? c : s;
    }
  }
  function hy(i, s) {
    __(i, s), (i = i.alternate) && __(i, s);
  }
  function E_(i) {
    if (i.tag === 13) {
      var s = nl(i, 67108864);
      s !== null && Xn(s, i, 67108864), hy(i, 67108864);
    }
  }
  var ff = !0;
  function T6(i, s, c, h) {
    var b = L.T;
    L.T = null;
    var S = H.p;
    try {
      H.p = 2, my(i, s, c, h);
    } finally {
      H.p = S, L.T = b;
    }
  }
  function z6(i, s, c, h) {
    var b = L.T;
    L.T = null;
    var S = H.p;
    try {
      H.p = 8, my(i, s, c, h);
    } finally {
      H.p = S, L.T = b;
    }
  }
  function my(i, s, c, h) {
    if (ff) {
      var b = gy(h);
      if (b === null)
        ny(
          i,
          s,
          h,
          pf,
          c
        ), O_(i, h);
      else if (L6(
        b,
        i,
        s,
        c,
        h
      ))
        h.stopPropagation();
      else if (O_(i, h), s & 4 && -1 < P6.indexOf(i)) {
        for (; b !== null; ) {
          var S = yo(b);
          if (S !== null)
            switch (S.tag) {
              case 3:
                if (S = S.stateNode, S.current.memoizedState.isDehydrated) {
                  var j = vn(S.pendingLanes);
                  if (j !== 0) {
                    var I = S;
                    for (I.pendingLanes |= 2, I.entangledLanes |= 2; j; ) {
                      var Z = 1 << 31 - Le(j);
                      I.entanglements[1] |= Z, j &= ~Z;
                    }
                    $r(S), (it & 6) === 0 && (Zd = lt() + 500, vu(0));
                  }
                }
                break;
              case 13:
                I = nl(S, 2), I !== null && Xn(I, S, 2), Kd(), hy(S, 2);
            }
          if (S = gy(h), S === null && ny(
            i,
            s,
            h,
            pf,
            c
          ), S === b) break;
          b = S;
        }
        b !== null && h.stopPropagation();
      } else
        ny(
          i,
          s,
          h,
          null,
          c
        );
    }
  }
  function gy(i) {
    return i = xm(i), yy(i);
  }
  var pf = null;
  function yy(i) {
    if (pf = null, i = go(i), i !== null) {
      var s = a(i);
      if (s === null) i = null;
      else {
        var c = s.tag;
        if (c === 13) {
          if (i = l(s), i !== null) return i;
          i = null;
        } else if (c === 3) {
          if (s.stateNode.current.memoizedState.isDehydrated)
            return s.tag === 3 ? s.stateNode.containerInfo : null;
          i = null;
        } else s !== i && (i = null);
      }
    }
    return pf = i, null;
  }
  function C_(i) {
    switch (i) {
      case "beforetoggle":
      case "cancel":
      case "click":
      case "close":
      case "contextmenu":
      case "copy":
      case "cut":
      case "auxclick":
      case "dblclick":
      case "dragend":
      case "dragstart":
      case "drop":
      case "focusin":
      case "focusout":
      case "input":
      case "invalid":
      case "keydown":
      case "keypress":
      case "keyup":
      case "mousedown":
      case "mouseup":
      case "paste":
      case "pause":
      case "play":
      case "pointercancel":
      case "pointerdown":
      case "pointerup":
      case "ratechange":
      case "reset":
      case "resize":
      case "seeked":
      case "submit":
      case "toggle":
      case "touchcancel":
      case "touchend":
      case "touchstart":
      case "volumechange":
      case "change":
      case "selectionchange":
      case "textInput":
      case "compositionstart":
      case "compositionend":
      case "compositionupdate":
      case "beforeblur":
      case "afterblur":
      case "beforeinput":
      case "blur":
      case "fullscreenchange":
      case "focus":
      case "hashchange":
      case "popstate":
      case "select":
      case "selectstart":
        return 2;
      case "drag":
      case "dragenter":
      case "dragexit":
      case "dragleave":
      case "dragover":
      case "mousemove":
      case "mouseout":
      case "mouseover":
      case "pointermove":
      case "pointerout":
      case "pointerover":
      case "scroll":
      case "touchmove":
      case "wheel":
      case "mouseenter":
      case "mouseleave":
      case "pointerenter":
      case "pointerleave":
        return 8;
      case "message":
        switch (wr()) {
          case en:
            return 2;
          case Bn:
            return 8;
          case je:
          case ho:
            return 32;
          case Lr:
            return 268435456;
          default:
            return 32;
        }
      default:
        return 32;
    }
  }
  var vy = !1, _i = null, Ei = null, Ci = null, Cu = /* @__PURE__ */ new Map(), Ou = /* @__PURE__ */ new Map(), Oi = [], P6 = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset".split(
    " "
  );
  function O_(i, s) {
    switch (i) {
      case "focusin":
      case "focusout":
        _i = null;
        break;
      case "dragenter":
      case "dragleave":
        Ei = null;
        break;
      case "mouseover":
      case "mouseout":
        Ci = null;
        break;
      case "pointerover":
      case "pointerout":
        Cu.delete(s.pointerId);
        break;
      case "gotpointercapture":
      case "lostpointercapture":
        Ou.delete(s.pointerId);
    }
  }
  function Nu(i, s, c, h, b, S) {
    return i === null || i.nativeEvent !== S ? (i = {
      blockedOn: s,
      domEventName: c,
      eventSystemFlags: h,
      nativeEvent: S,
      targetContainers: [b]
    }, s !== null && (s = yo(s), s !== null && E_(s)), i) : (i.eventSystemFlags |= h, s = i.targetContainers, b !== null && s.indexOf(b) === -1 && s.push(b), i);
  }
  function L6(i, s, c, h, b) {
    switch (s) {
      case "focusin":
        return _i = Nu(
          _i,
          i,
          s,
          c,
          h,
          b
        ), !0;
      case "dragenter":
        return Ei = Nu(
          Ei,
          i,
          s,
          c,
          h,
          b
        ), !0;
      case "mouseover":
        return Ci = Nu(
          Ci,
          i,
          s,
          c,
          h,
          b
        ), !0;
      case "pointerover":
        var S = b.pointerId;
        return Cu.set(
          S,
          Nu(
            Cu.get(S) || null,
            i,
            s,
            c,
            h,
            b
          )
        ), !0;
      case "gotpointercapture":
        return S = b.pointerId, Ou.set(
          S,
          Nu(
            Ou.get(S) || null,
            i,
            s,
            c,
            h,
            b
          )
        ), !0;
    }
    return !1;
  }
  function N_(i) {
    var s = go(i.target);
    if (s !== null) {
      var c = a(s);
      if (c !== null) {
        if (s = c.tag, s === 13) {
          if (s = l(c), s !== null) {
            i.blockedOn = s, fm(i.priority, function() {
              if (c.tag === 13) {
                var h = qn();
                h = Ms(h);
                var b = nl(c, h);
                b !== null && Xn(b, c, h), hy(c, h);
              }
            });
            return;
          }
        } else if (s === 3 && c.stateNode.current.memoizedState.isDehydrated) {
          i.blockedOn = c.tag === 3 ? c.stateNode.containerInfo : null;
          return;
        }
      }
    }
    i.blockedOn = null;
  }
  function hf(i) {
    if (i.blockedOn !== null) return !1;
    for (var s = i.targetContainers; 0 < s.length; ) {
      var c = gy(i.nativeEvent);
      if (c === null) {
        c = i.nativeEvent;
        var h = new c.constructor(
          c.type,
          c
        );
        wm = h, c.target.dispatchEvent(h), wm = null;
      } else
        return s = yo(c), s !== null && E_(s), i.blockedOn = c, !1;
      s.shift();
    }
    return !0;
  }
  function M_(i, s, c) {
    hf(i) && c.delete(s);
  }
  function I6() {
    vy = !1, _i !== null && hf(_i) && (_i = null), Ei !== null && hf(Ei) && (Ei = null), Ci !== null && hf(Ci) && (Ci = null), Cu.forEach(M_), Ou.forEach(M_);
  }
  function mf(i, s) {
    i.blockedOn === s && (i.blockedOn = null, vy || (vy = !0, e.unstable_scheduleCallback(
      e.unstable_NormalPriority,
      I6
    )));
  }
  var gf = null;
  function A_(i) {
    gf !== i && (gf = i, e.unstable_scheduleCallback(
      e.unstable_NormalPriority,
      function() {
        gf === i && (gf = null);
        for (var s = 0; s < i.length; s += 3) {
          var c = i[s], h = i[s + 1], b = i[s + 2];
          if (typeof h != "function") {
            if (yy(h || c) === null)
              continue;
            break;
          }
          var S = yo(c);
          S !== null && (i.splice(s, 3), s -= 3, yg(
            S,
            {
              pending: !0,
              data: b,
              method: c.method,
              action: h
            },
            h,
            b
          ));
        }
      }
    ));
  }
  function Mu(i) {
    function s(Z) {
      return mf(Z, i);
    }
    _i !== null && mf(_i, i), Ei !== null && mf(Ei, i), Ci !== null && mf(Ci, i), Cu.forEach(s), Ou.forEach(s);
    for (var c = 0; c < Oi.length; c++) {
      var h = Oi[c];
      h.blockedOn === i && (h.blockedOn = null);
    }
    for (; 0 < Oi.length && (c = Oi[0], c.blockedOn === null); )
      N_(c), c.blockedOn === null && Oi.shift();
    if (c = (i.ownerDocument || i).$$reactFormReplay, c != null)
      for (h = 0; h < c.length; h += 3) {
        var b = c[h], S = c[h + 1], j = b[un] || null;
        if (typeof S == "function")
          j || A_(c);
        else if (j) {
          var I = null;
          if (S && S.hasAttribute("formAction")) {
            if (b = S, j = S[un] || null)
              I = j.formAction;
            else if (yy(b) !== null) continue;
          } else I = j.action;
          typeof I == "function" ? c[h + 1] = I : (c.splice(h, 3), h -= 3), A_(c);
        }
      }
  }
  function by(i) {
    this._internalRoot = i;
  }
  yf.prototype.render = by.prototype.render = function(i) {
    var s = this._internalRoot;
    if (s === null) throw Error(r(409));
    var c = s.current, h = qn();
    k_(c, h, i, s, null, null);
  }, yf.prototype.unmount = by.prototype.unmount = function() {
    var i = this._internalRoot;
    if (i !== null) {
      this._internalRoot = null;
      var s = i.containerInfo;
      k_(i.current, 2, null, i, null, null), Kd(), s[ni] = null;
    }
  };
  function yf(i) {
    this._internalRoot = i;
  }
  yf.prototype.unstable_scheduleHydration = function(i) {
    if (i) {
      var s = nd();
      i = { blockedOn: null, target: i, priority: s };
      for (var c = 0; c < Oi.length && s !== 0 && s < Oi[c].priority; c++) ;
      Oi.splice(c, 0, i), c === 0 && N_(i);
    }
  };
  var R_ = t.version;
  if (R_ !== "19.1.0")
    throw Error(
      r(
        527,
        R_,
        "19.1.0"
      )
    );
  H.findDOMNode = function(i) {
    var s = i._reactInternals;
    if (s === void 0)
      throw typeof i.render == "function" ? Error(r(188)) : (i = Object.keys(i).join(","), Error(r(268, i)));
    return i = d(s), i = i !== null ? f(i) : null, i = i === null ? null : i.stateNode, i;
  };
  var B6 = {
    bundleType: 0,
    version: "19.1.0",
    rendererPackageName: "react-dom",
    currentDispatcherRef: L,
    reconcilerVersion: "19.1.0"
  };
  if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u") {
    var vf = __REACT_DEVTOOLS_GLOBAL_HOOK__;
    if (!vf.isDisabled && vf.supportsFiber)
      try {
        le = vf.inject(
          B6
        ), pe = vf;
      } catch {
      }
  }
  return Ru.createRoot = function(i, s) {
    if (!o(i)) throw Error(r(299));
    var c = !1, h = "", b = Xk, S = Gk, j = Zk, I = null;
    return s != null && (s.unstable_strictMode === !0 && (c = !0), s.identifierPrefix !== void 0 && (h = s.identifierPrefix), s.onUncaughtError !== void 0 && (b = s.onUncaughtError), s.onCaughtError !== void 0 && (S = s.onCaughtError), s.onRecoverableError !== void 0 && (j = s.onRecoverableError), s.unstable_transitionCallbacks !== void 0 && (I = s.unstable_transitionCallbacks)), s = x_(
      i,
      1,
      !1,
      null,
      null,
      c,
      h,
      b,
      S,
      j,
      I,
      null
    ), i[ni] = s.current, ty(i), new by(s);
  }, Ru.hydrateRoot = function(i, s, c) {
    if (!o(i)) throw Error(r(299));
    var h = !1, b = "", S = Xk, j = Gk, I = Zk, Z = null, ee = null;
    return c != null && (c.unstable_strictMode === !0 && (h = !0), c.identifierPrefix !== void 0 && (b = c.identifierPrefix), c.onUncaughtError !== void 0 && (S = c.onUncaughtError), c.onCaughtError !== void 0 && (j = c.onCaughtError), c.onRecoverableError !== void 0 && (I = c.onRecoverableError), c.unstable_transitionCallbacks !== void 0 && (Z = c.unstable_transitionCallbacks), c.formState !== void 0 && (ee = c.formState)), s = x_(
      i,
      1,
      !0,
      s,
      c ?? null,
      h,
      b,
      S,
      j,
      I,
      Z,
      ee
    ), s.context = S_(null), c = s.current, h = qn(), h = Ms(h), b = ci(h), b.callback = null, di(c, b, h), c = h, s.current.lanes = c, Qi(s, c), $r(s), i[ni] = s.current, ty(i), new yf(s);
  }, Ru.version = "19.1.0", Ru;
}
var H_;
function K6() {
  if (H_) return xy.exports;
  H_ = 1;
  function e() {
    if (!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != "function"))
      try {
        __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(e);
      } catch (t) {
        console.error(t);
      }
  }
  return e(), xy.exports = W6(), xy.exports;
}
var Q6 = K6(), _ = iw();
const $t = /* @__PURE__ */ AO(_), jO = /* @__PURE__ */ U6({
  __proto__: null,
  default: $t
}, [_]);
var Mc = RO();
const J6 = /* @__PURE__ */ AO(Mc);
var ez = Object.defineProperty, tz = (e, t, n) => t in e ? ez(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : e[t] = n, Zf = (e, t, n) => tz(e, typeof t != "symbol" ? t + "" : t, n);
function th(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var U_ = { exports: {} }, ju = {};
/**
 * @license React
 * react-jsx-runtime.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var F_;
function nz() {
  if (F_) return ju;
  F_ = 1;
  var e = Symbol.for("react.transitional.element"), t = Symbol.for("react.fragment");
  function n(r, o, a) {
    var l = null;
    if (a !== void 0 && (l = "" + a), o.key !== void 0 && (l = "" + o.key), "key" in o) {
      a = {};
      for (var u in o)
        u !== "key" && (a[u] = o[u]);
    } else a = o;
    return o = a.ref, {
      $$typeof: e,
      type: r,
      key: l,
      ref: o !== void 0 ? o : null,
      props: a
    };
  }
  return ju.Fragment = t, ju.jsx = n, ju.jsxs = n, ju;
}
var $_;
function rz() {
  return $_ || ($_ = 1, U_.exports = nz()), U_.exports;
}
var k = rz();
const oz = {}, Y_ = (e) => {
  let t;
  const n = /* @__PURE__ */ new Set(), r = (u, d) => {
    const f = typeof u == "function" ? u(t) : u;
    if (!Object.is(f, t)) {
      const p = t;
      t = d ?? (typeof f != "object" || f === null) ? f : Object.assign({}, t, f), n.forEach((m) => m(t, p));
    }
  }, o = () => t, a = { setState: r, getState: o, getInitialState: () => l, subscribe: (u) => (n.add(u), () => n.delete(u)), destroy: () => {
    (oz ? "production" : void 0) !== "production" && console.warn(
      "[DEPRECATED] The `destroy` method will be unsupported in a future version. Instead use unsubscribe function returned by subscribe. Everything will be garbage-collected if store is garbage-collected."
    ), n.clear();
  } }, l = t = e(r, o, a);
  return a;
}, DO = (e) => e ? Y_(e) : Y_;
var q_ = { exports: {} }, Cy = {}, X_ = { exports: {} }, Oy = {};
/**
 * @license React
 * use-sync-external-store-shim.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var G_;
function iz() {
  if (G_) return Oy;
  G_ = 1;
  var e = $t;
  function t(m, g) {
    return m === g && (m !== 0 || 1 / m === 1 / g) || m !== m && g !== g;
  }
  var n = typeof Object.is == "function" ? Object.is : t, r = e.useState, o = e.useEffect, a = e.useLayoutEffect, l = e.useDebugValue;
  function u(m, g) {
    var y = g(), w = r({ inst: { value: y, getSnapshot: g } }), v = w[0].inst, x = w[1];
    return a(
      function() {
        v.value = y, v.getSnapshot = g, d(v) && x({ inst: v });
      },
      [m, y, g]
    ), o(
      function() {
        return d(v) && x({ inst: v }), m(function() {
          d(v) && x({ inst: v });
        });
      },
      [m]
    ), l(y), y;
  }
  function d(m) {
    var g = m.getSnapshot;
    m = m.value;
    try {
      var y = g();
      return !n(m, y);
    } catch {
      return !0;
    }
  }
  function f(m, g) {
    return g();
  }
  var p = typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u" ? f : u;
  return Oy.useSyncExternalStore = e.useSyncExternalStore !== void 0 ? e.useSyncExternalStore : p, Oy;
}
var Z_;
function az() {
  return Z_ || (Z_ = 1, X_.exports = iz()), X_.exports;
}
/**
 * @license React
 * use-sync-external-store-shim/with-selector.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var W_;
function lz() {
  if (W_) return Cy;
  W_ = 1;
  var e = $t, t = az();
  function n(f, p) {
    return f === p && (f !== 0 || 1 / f === 1 / p) || f !== f && p !== p;
  }
  var r = typeof Object.is == "function" ? Object.is : n, o = t.useSyncExternalStore, a = e.useRef, l = e.useEffect, u = e.useMemo, d = e.useDebugValue;
  return Cy.useSyncExternalStoreWithSelector = function(f, p, m, g, y) {
    var w = a(null);
    if (w.current === null) {
      var v = { hasValue: !1, value: null };
      w.current = v;
    } else v = w.current;
    w = u(
      function() {
        function E(D) {
          if (!N) {
            if (N = !0, C = D, D = g(D), y !== void 0 && v.hasValue) {
              var T = v.value;
              if (y(T, D))
                return A = T;
            }
            return A = D;
          }
          if (T = A, r(C, D)) return T;
          var V = g(D);
          return y !== void 0 && y(T, V) ? (C = D, T) : (C = D, A = V);
        }
        var N = !1, C, A, R = m === void 0 ? null : m;
        return [
          function() {
            return E(p());
          },
          R === null ? void 0 : function() {
            return E(R());
          }
        ];
      },
      [p, m, g, y]
    );
    var x = o(f, w[0], w[1]);
    return l(
      function() {
        v.hasValue = !0, v.value = x;
      },
      [x]
    ), d(x), x;
  }, Cy;
}
var K_;
function sz() {
  return K_ || (K_ = 1, q_.exports = lz()), q_.exports;
}
var uz = sz();
const TO = /* @__PURE__ */ th(uz), zO = {}, { useDebugValue: cz } = $t, { useSyncExternalStoreWithSelector: dz } = TO;
let Q_ = !1;
const fz = (e) => e;
function pz(e, t = fz, n) {
  (zO ? "production" : void 0) !== "production" && n && !Q_ && (console.warn(
    "[DEPRECATED] Use `createWithEqualityFn` instead of `create` or use `useStoreWithEqualityFn` instead of `useStore`. They can be imported from 'zustand/traditional'. https://github.com/pmndrs/zustand/discussions/1937"
  ), Q_ = !0);
  const r = dz(
    e.subscribe,
    e.getState,
    e.getServerState || e.getInitialState,
    t,
    n
  );
  return cz(r), r;
}
const J_ = (e) => {
  (zO ? "production" : void 0) !== "production" && typeof e != "function" && console.warn(
    "[DEPRECATED] Passing a vanilla store will be unsupported in a future version. Instead use `import { useStore } from 'zustand'`."
  );
  const t = typeof e == "function" ? DO(e) : e, n = (r, o) => pz(t, r, o);
  return Object.assign(n, t), n;
}, wn = (e) => e ? J_(e) : J_, hz = () => ({
  libstate: wn((e, t) => ({
    lib: {
      shelves: []
    },
    external_worker: [],
    set: (n) => e((r) => ({ ...r, ...n })),
    get_lib: () => t().lib,
    get_external_worker: () => t().external_worker
  }))
}), mz = ({}) => {
  const e = /* @__PURE__ */ new Map();
  return {
    nodesstates: e,
    get_node: (t, n = !0) => {
      const r = e.get(t);
      if (!r && n) {
        const o = e.keys();
        throw new Error(
          `Node ${t} not found, available nodes: ${Array.from(o)}`
        );
      }
      return r;
    }
  };
};
function Bi(e) {
  return Object.prototype.toString.call(e) === "[object Object]";
}
function aw(e, t) {
  if (e === t) return !0;
  if (typeof e != "object" || e === null || typeof t != "object" || t === null || e.constructor !== t.constructor) return !1;
  if (e.constructor === Object || e.constructor === Array) {
    const n = Object.keys(e), r = Object.keys(t);
    if (n.length !== r.length) return !1;
    for (const o of n)
      if (!r.includes(o) || !aw(e[o], t[o])) return !1;
  }
  return e instanceof Date && t instanceof Date ? e.getTime() === t.getTime() : !0;
}
const Mr = (e, t) => {
  let n = !1;
  if (!Bi(e))
    throw new Error("Target must be a plain object not" + typeof e);
  if (!Bi(t))
    throw new Error("Source must be a plain object not" + typeof t);
  const r = { ...e };
  return Object.keys(t).forEach((o) => {
    const a = t[o], l = e[o];
    if (Bi(a) && Bi(l)) {
      const { new_obj: u, change: d } = Mr(
        l,
        a
      );
      d && (n = !0, r[o] = u);
    } else aw(l, a) || (n = !0, r[o] = a);
  }), { new_obj: r, change: n };
}, nh = (e, t) => {
  let n = !1;
  if (!Bi(e))
    throw new Error("Target must be a plain object");
  if (!Bi(t))
    throw new Error("Source must be a plain object");
  const r = { ...e };
  return Object.keys(t).forEach((o) => {
    const a = t[o], l = e[o];
    if (!(l === void 0 && a === void 0)) {
      if (l === void 0) {
        n = !0, r[o] = a;
        return;
      }
      if (Bi(a) && Bi(l)) {
        const { new_obj: u, change: d } = nh(
          l,
          a
        );
        d && (n = !0, r[o] = u);
      }
    }
  }), { new_obj: r, change: n };
}, Zr = (e, t) => t === void 0 ? [e, !1] : [t, e !== t];
function PO(e, t) {
  throw new Error("Unhandled case: " + e + " with: " + JSON.stringify(t));
}
const LO = (e) => {
  e.io === void 0 && (e.io = {});
  let t = e.io, n = e.io_order;
  if (n === void 0)
    if (Array.isArray(t)) {
      n = t.map((o) => o.id);
      const r = {};
      for (const o of t)
        r[o.id] = o;
      t = r;
    } else
      n = Object.keys(e.io);
  else if (Array.isArray(t)) {
    const r = {};
    for (const o of t)
      r[o.id] = o, n.includes(o.id) || n.push(o.id);
    t = r;
  } else
    for (const r in t)
      n.includes(r) || n.push(r);
  return { ...e, io_order: n, io: t };
}, gz = (e, t) => {
  const n = e.getState(), r = {}, o = LO(t), a = Object.keys(
    o
  );
  for (const l of a)
    switch (l) {
      case "id": {
        const [u, d] = Zr(
          n[l],
          o[l]
        );
        d && (r[l] = u);
        break;
      }
      case "node_id": {
        const [u, d] = Zr(
          n[l],
          o[l]
        );
        d && (r[l] = u);
        break;
      }
      case "node_name": {
        const [u, d] = Zr(
          n[l],
          o[l]
        );
        d && (r[l] = u);
        break;
      }
      case "name": {
        const [u, d] = Zr(
          n[l],
          o[l]
        );
        d && (r[l] = u);
        break;
      }
      case "in_trigger": {
        n[l].setState(!!o[l]);
        break;
      }
      case "error": {
        o[l] !== n[l] && (r[l] = o[l]);
        break;
      }
      case "render_options": {
        const [u, d] = ((f, p) => {
          if (p === void 0) return [f, !1];
          if (f === void 0) return [p, p !== void 0];
          const { new_obj: m, change: g } = Mr(f, p);
          return [m, g];
        })(n[l], o[l]);
        d && (r[l] = u);
        break;
      }
      case "io_order": {
        const [u, d] = ((f, p) => p === void 0 ? [f, !1] : [p, !aw(f, p)])(n[l], o[l]);
        d && (r[l] = u);
        break;
      }
      case "io": {
        const u = n[l], d = o[l];
        if (d === void 0 || u === void 0) break;
        for (const f in d) {
          if (u[f] === void 0) {
            console.error(
              "io key not found in oldvalue:",
              f,
              "allowed:",
              u,
              "for update:",
              o
            );
            continue;
          }
          u[f].update(d[f]);
        }
        break;
      }
      case "progress": {
        const [u, d] = ((f, p) => {
          if (p === void 0) return [f, !1];
          if (f === void 0) return [p, p !== void 0];
          const { new_obj: m, change: g } = Mr(f, p);
          return [m, g];
        })(n[l].getState(), o[l]);
        d && n[l].setState(u);
        break;
      }
      case "description": {
        r[l] = o[l];
        break;
      }
      case "properties": {
        const [u, d] = ((f, p) => {
          if (p === void 0) return [f, !1];
          if (f === void 0) return [p, p !== void 0];
          const { new_obj: m, change: g } = Mr(f, p);
          return [m, g];
        })(n[l], o[l]);
        d && (r[l] = u);
        break;
      }
      case "status": {
        const [u, d] = ((f, p) => {
          if (p === void 0) return [f, !1];
          if (f === void 0) return [p, p !== void 0];
          const { new_obj: m, change: g } = Mr(f, p);
          return [m, g];
        })(n[l], o[l]);
        d && (r[l] = u);
        break;
      }
      default:
        try {
          PO(l, o[l]);
        } catch (u) {
          console.error(u);
        }
    }
  Object.keys(r).length > 0 && e.setState(r);
}, e0 = (e, t) => {
  e.properties = e.properties || {}, t.pos && (e.properties["frontend:pos"] = t.pos), t.size && (e.properties["frontend:size"] = t.size), t.collapsed !== void 0 && (e.properties["frontend:collapsed"] = !!t.collapsed);
}, yz = (e, t) => {
  const n = e.getState(), r = {}, o = {}, a = Object.keys(t);
  for (const l of a)
    switch (l) {
      case "name": {
        const [u, d] = Zr(
          n[l],
          t[l]
        );
        d && (r[l] = u);
        break;
      }
      case "id": {
        const [u, d] = Zr(
          n[l],
          t[l]
        );
        d && (r[l] = u);
        break;
      }
      case "connected": {
        const [u, d] = Zr(
          n[l],
          t[l]
        );
        d && (r[l] = u);
        break;
      }
      case "does_trigger": {
        const [u, d] = Zr(
          n[l],
          t[l]
        );
        d && (r[l] = u);
        break;
      }
      case "hidden": {
        const [u, d] = Zr(
          n[l],
          t[l]
        );
        d && (r[l] = u);
        break;
      }
      case "full_id": {
        const [u, d] = Zr(
          n[l],
          t[l]
        );
        d && (r[l] = u);
        break;
      }
      case "is_input":
        break;
      case "node":
        break;
      case "type":
        break;
      case "value": {
        o.preview = t[l];
        break;
      }
      case "fullvalue": {
        o.full = t[l];
        break;
      }
      case "render_options": {
        const [u, d] = ((f, p) => {
          if (p === void 0) return [f, !1];
          if (f === void 0) return [p, p !== void 0];
          const { new_obj: m, change: g } = Mr(f, p);
          return [m, g];
        })(n[l], t[l]);
        d && (r[l] = u);
        break;
      }
      case "value_options": {
        const [u, d] = ((f, p) => {
          if (p === void 0) return [f, !1];
          if (f === void 0) return [p, p !== void 0];
          const { new_obj: m, change: g } = Mr(f, p);
          return [m, g];
        })(n[l], t[l]);
        d && (r[l] = u);
        break;
      }
      case "valuepreview_type": {
        r[l] = t[l];
        break;
      }
      case "emit_value_set": {
        r[l] = t[l];
        break;
      }
      case "default": {
        r[l] = t[l];
        break;
      }
      case "required": {
        r[l] = t[l];
        break;
      }
      default:
        try {
          PO(l, t[l]);
        } catch (u) {
          console.error(u);
        }
    }
  Object.keys(o).length > 0 && e.updateValueStore(o), Object.keys(r).length > 0 && e.setState(r);
};
class Lo {
  constructor({ data: t, mime: n }) {
    this._data = t, this._mime = n;
  }
  get data() {
    return this._data;
  }
  get value() {
    return this._data;
  }
  get mime() {
    return this._mime;
  }
  toString() {
    return this._data instanceof ArrayBuffer ? `DataStructure(${this._data.byteLength},${this._mime})` : this._data instanceof Blob ? `DataStructure(${this._data.size},${this._mime})` : this._data instanceof String ? `DataStructure(${this._data.length},${this._mime})` : this._data instanceof Array ? `DataStructure(${this._data.length},${this._mime})` : this._data instanceof Object ? `DataStructure(${Object.keys(this._data).length},${this._mime})` : `DataStructure(${this._mime})`;
  }
  toJSON() {
    return this.toString();
  }
  dispose() {
  }
}
class vz extends Lo {
  get objectUrl() {
    if (this._objectUrl)
      return this._objectUrl;
    const t = this.data instanceof Blob ? this.data : new Blob([this.data], { type: this.mime });
    return this._objectUrl = URL.createObjectURL(t), this._objectUrl;
  }
  dispose() {
    this._objectUrl && URL.revokeObjectURL(this._objectUrl), super.dispose();
  }
  get value() {
    return this.objectUrl;
  }
}
const Ut = (e) => e.buffer ? e.buffer : e, bz = {
  x: (e, t) => null,
  //  pad byte 	no value 	(7 )
  c: (e, t) => new DataView(Ut(e)).getInt8(0),
  //  char 	bytes of length 1 	1 	b 	signed char 	integer 	1 	(1 ), (2 )
  B: (e, t) => new DataView(Ut(e)).getUint8(0),
  //  unsigned char 	integer 	1 	(2 )
  "?": (e, t) => new DataView(Ut(e)).getInt8(0) === 1,
  //  _Bool 	bool 	1 	(1 )
  h: (e, t) => new DataView(Ut(e)).getInt16(0, t),
  //  short 	integer 	2 	(2 )
  H: (e, t) => new DataView(Ut(e)).getUint16(0, t),
  //  unsigned short 	integer 	2 	(2 )
  i: (e, t) => new DataView(Ut(e)).getInt32(0, t),
  //  int 	integer 	4 	(2 )
  I: (e, t) => new DataView(Ut(e)).getUint32(0, t),
  //  unsigned int 	integer 	4 	(2 )
  l: (e, t) => new DataView(Ut(e)).getInt32(0, t),
  //  long 	integer 	4 	(2 )
  L: (e, t) => new DataView(Ut(e)).getUint32(0, t),
  //  unsigned long 	integer 	4 	(2 )
  q: (e, t) => Number(
    new DataView(Ut(e)).getBigInt64(0, t)
  ),
  //  long long 	integer 	8 	(2 )
  Q: (e, t) => Number(
    new DataView(Ut(e)).getBigUint64(0, t)
  ),
  //  unsigned long long 	integer 	8 	(2 )
  n: (e, t) => Number(
    new DataView(Ut(e)).getBigInt64(0, t)
  ),
  //  ssize_t 	integer 	(3 )
  N: (e, t) => Number(
    new DataView(Ut(e)).getBigUint64(0, t)
  ),
  //  size_t 	integer 	(3 )
  // "e":(data:ArrayBufferLike)=>{return new DataView(to_arraybuffer(data)).getFloat16(0)}, //  (6 ) float 	2 	(4 )
  f: (e, t) => new DataView(Ut(e)).getFloat32(0, t),
  //  float 	float 	4 	(4 )
  d: (e, t) => new DataView(Ut(e)).getFloat64(0, t),
  //  double 	float 	8 	(4 )
  s: (e, t) => new TextDecoder().decode(Ut(e)),
  //  char[] 	bytes 	(9 )
  p: (e, t) => new TextDecoder().decode(Ut(e)),
  //  char[] 	bytes 	(8 )
  P: (e, t) => Number(
    new DataView(Ut(e)).getBigUint64(0, t)
  )
  //  void* 	int
};
class wz extends Lo {
  constructor({ data: t, mime: n }) {
    super({ data: t, mime: n }), this._cType = n.split("application/fn.struct.")[1], this._value = null, this.parse_value();
  }
  parse_value() {
    let t = !0, n = this._cType;
    return n.startsWith("<") && (t = !0, n = n.slice(1)), n.startsWith(">") && (t = !1, n = n.slice(1)), n.startsWith("!") && (t = !1, n = n.slice(1)), n.startsWith("@") && (t = !1, n = n.slice(1)), n.startsWith("=") && (t = !1, n = n.slice(1)), this._value = bz[n](this.data, t), this._value;
  }
  get value() {
    return this._value;
  }
  toString() {
    return this._value === null ? "null" : this._value.toString();
  }
}
class wa extends Lo {
  constructor({ data: t, mime: n }) {
    super({ data: t, mime: n }), t.length === 0 ? this._json = void 0 : (this._json = JSON.parse(new TextDecoder().decode(Ut(t))), this._json === "<NoValue>" && (this._json = void 0));
  }
  get value() {
    return this._json;
  }
  static fromObject(t) {
    const n = t === "<NoValue>" ? new Uint8Array(0) : new TextEncoder().encode(JSON.stringify(t));
    return new wa({ data: n, mime: "application/json" });
  }
  toString() {
    return JSON.stringify(this._json);
  }
}
class xz extends Lo {
  constructor({ data: t, mime: n }) {
    super({ data: t, mime: n }), this._value = new TextDecoder().decode(Ut(t));
  }
  get value() {
    return this._value;
  }
  toString() {
    return this._value;
  }
}
const t0 = ({
  data: e,
  mime: t
}) => e instanceof ArrayBuffer || e instanceof Uint8Array ? t.startsWith("application/fn.struct.") ? new wz({ data: e, mime: t }) : t.startsWith("application/json") ? new wa({ data: e, mime: t }) : t === "text" || t.startsWith("text/") ? new xz({ data: e, mime: t }) : new vz({ data: e, mime: t }) : new Lo({ data: e, mime: t }), Sz = {
  id: "dummy",
  node_id: "dummy",
  node_name: "dummy",
  properties: {
    "frontend:size": [200, 100],
    "frontend:pos": [NaN, NaN],
    "frontend:collapsed": !1
  },
  io: {},
  name: "dummy",
  in_trigger: !1,
  progress: {
    ascii: !1,
    elapsed: 0,
    initial: 0,
    n: 0,
    prefix: "idle",
    unit: "it",
    unit_divisor: 1e3,
    unit_scale: !1
  }
}, kz = {
  id: "dummy",
  name: "dummy",
  node: "dummy",
  full_id: "dummy",
  type: "any",
  value: void 0,
  is_input: !1,
  connected: !1,
  does_trigger: !0,
  fullvalue: void 0,
  render_options: {
    set_default: !0,
    type: "any"
  },
  hidden: !1,
  emit_value_set: !0,
  required: !1
}, _z = (e, t) => {
  const n = () => {
    var r;
    t.node === void 0 || t.id === void 0 || (r = e.worker) == null || r.get_io_full_value({ nid: t.node, ioid: t.id });
  };
  return t.value === "<NoValue>" && (t.value = void 0), t.fullvalue === "<NoValue>" && (t.fullvalue = void 0), t.hidden === void 0 && (t.hidden = !1), {
    ...t,
    try_get_full_value: n,
    set_hidden: (r) => {
      var o;
      t.node === void 0 || t.id === void 0 || (o = e.worker) == null || o.update_io_options({
        nid: t.node,
        ioid: t.id,
        options: { hidden: r }
      });
    }
  };
}, Ez = (e, t) => {
  if (!t.id)
    throw new Error(
      "IO must have an id but is missing for " + JSON.stringify(t)
    );
  t.name === void 0 && (t.name = t.id);
  const { new_obj: n } = nh(t, kz);
  return (n.render_options.type === "any" || n.render_options.type === void 0) && (n.render_options.type = n.type), _z(e, n);
}, Cz = (e, t, n) => {
  let r;
  if (e === void 0)
    throw new Error("nodestore is undefined");
  return r = {
    _state: wn(
      (o, a) => Ez(t, n)
    ),
    use: () => r._state(),
    getState: () => r._state.getState(),
    setState: (o) => {
      r._state.setState(o);
    },
    update: (o) => {
      yz(r, o);
    },
    valuestore: wn((o, a) => {
      let l = n.value;
      l === "<NoValue>" && (l = void 0), !(l instanceof Lo) && l !== void 0 && (l = wa.fromObject(l));
      let u = n.fullvalue;
      return u === "<NoValue>" && (u = void 0), !(u instanceof Lo) && u !== void 0 && (u = wa.fromObject(u)), {
        preview: l,
        full: u
      };
    }),
    updateValueStore: (o) => {
      r.valuestore.setState((a) => (a.preview && typeof a.preview.dispose == "function" && a.preview.dispose(), a.full && typeof a.full.dispose == "function" && a.full.dispose(), o.preview !== void 0 && o.full === void 0 && (o.full = void 0, a.full = void 0), o.preview !== void 0 && !(o.preview instanceof Lo) && (o.preview = wa.fromObject(o.preview)), o.full !== void 0 && !(o.full instanceof Lo) && (o.full = wa.fromObject(o.full)), { ...a, ...o }));
    },
    node: e
  }, r;
}, Oz = (e, t, n) => {
  const r = n.io_order;
  if (r === void 0)
    throw new Error("Node must have io_order");
  return {
    ...n,
    in_trigger: wn(() => !1),
    inputs: Object.keys(n.io).filter((o) => n.io[o].is_input),
    outputs: Object.keys(n.io).filter((o) => !n.io[o].is_input),
    io: Object.fromEntries(
      Object.entries(n.io).map(([o, a]) => [
        o,
        Cz(e, t, a)
      ])
    ),
    io_order: r,
    progress: wn(() => n.progress)
  };
}, Nz = (e, t, n) => {
  if (!n.id)
    throw new Error("Node must have an id");
  const { new_obj: r } = nh(
    n,
    Sz
  );
  return Oz(
    e,
    t,
    r
  );
}, Mz = (e, t) => {
  const n = {
    use: () => n._state(),
    getState: () => n._state.getState(),
    setState: (r) => {
      n._state.setState(r);
    },
    update: (r) => {
      gz(n._state, r);
    }
  };
  return n._state = wn((r, o) => Nz(n, e, LO(t))), n;
};
function Xt(e) {
  if (typeof e == "string" || typeof e == "number") return "" + e;
  let t = "";
  if (Array.isArray(e))
    for (let n = 0, r; n < e.length; n++)
      (r = Xt(e[n])) !== "" && (t += (t && " ") + r);
  else
    for (let n in e)
      e[n] && (t += (t && " ") + n);
  return t;
}
var Az = { value: () => {
} };
function rh() {
  for (var e = 0, t = arguments.length, n = {}, r; e < t; ++e) {
    if (!(r = arguments[e] + "") || r in n || /[\s.]/.test(r)) throw new Error("illegal type: " + r);
    n[r] = [];
  }
  return new Wf(n);
}
function Wf(e) {
  this._ = e;
}
function Rz(e, t) {
  return e.trim().split(/^|\s+/).map(function(n) {
    var r = "", o = n.indexOf(".");
    if (o >= 0 && (r = n.slice(o + 1), n = n.slice(0, o)), n && !t.hasOwnProperty(n)) throw new Error("unknown type: " + n);
    return { type: n, name: r };
  });
}
Wf.prototype = rh.prototype = {
  constructor: Wf,
  on: function(e, t) {
    var n = this._, r = Rz(e + "", n), o, a = -1, l = r.length;
    if (arguments.length < 2) {
      for (; ++a < l; ) if ((o = (e = r[a]).type) && (o = jz(n[o], e.name))) return o;
      return;
    }
    if (t != null && typeof t != "function") throw new Error("invalid callback: " + t);
    for (; ++a < l; )
      if (o = (e = r[a]).type) n[o] = n0(n[o], e.name, t);
      else if (t == null) for (o in n) n[o] = n0(n[o], e.name, null);
    return this;
  },
  copy: function() {
    var e = {}, t = this._;
    for (var n in t) e[n] = t[n].slice();
    return new Wf(e);
  },
  call: function(e, t) {
    if ((o = arguments.length - 2) > 0) for (var n = new Array(o), r = 0, o, a; r < o; ++r) n[r] = arguments[r + 2];
    if (!this._.hasOwnProperty(e)) throw new Error("unknown type: " + e);
    for (a = this._[e], r = 0, o = a.length; r < o; ++r) a[r].value.apply(t, n);
  },
  apply: function(e, t, n) {
    if (!this._.hasOwnProperty(e)) throw new Error("unknown type: " + e);
    for (var r = this._[e], o = 0, a = r.length; o < a; ++o) r[o].value.apply(t, n);
  }
};
function jz(e, t) {
  for (var n = 0, r = e.length, o; n < r; ++n)
    if ((o = e[n]).name === t)
      return o.value;
}
function n0(e, t, n) {
  for (var r = 0, o = e.length; r < o; ++r)
    if (e[r].name === t) {
      e[r] = Az, e = e.slice(0, r).concat(e.slice(r + 1));
      break;
    }
  return n != null && e.push({ name: t, value: n }), e;
}
var Lv = "http://www.w3.org/1999/xhtml";
const r0 = {
  svg: "http://www.w3.org/2000/svg",
  xhtml: Lv,
  xlink: "http://www.w3.org/1999/xlink",
  xml: "http://www.w3.org/XML/1998/namespace",
  xmlns: "http://www.w3.org/2000/xmlns/"
};
function oh(e) {
  var t = e += "", n = t.indexOf(":");
  return n >= 0 && (t = e.slice(0, n)) !== "xmlns" && (e = e.slice(n + 1)), r0.hasOwnProperty(t) ? { space: r0[t], local: e } : e;
}
function Dz(e) {
  return function() {
    var t = this.ownerDocument, n = this.namespaceURI;
    return n === Lv && t.documentElement.namespaceURI === Lv ? t.createElement(e) : t.createElementNS(n, e);
  };
}
function Tz(e) {
  return function() {
    return this.ownerDocument.createElementNS(e.space, e.local);
  };
}
function IO(e) {
  var t = oh(e);
  return (t.local ? Tz : Dz)(t);
}
function zz() {
}
function lw(e) {
  return e == null ? zz : function() {
    return this.querySelector(e);
  };
}
function Pz(e) {
  typeof e != "function" && (e = lw(e));
  for (var t = this._groups, n = t.length, r = new Array(n), o = 0; o < n; ++o)
    for (var a = t[o], l = a.length, u = r[o] = new Array(l), d, f, p = 0; p < l; ++p)
      (d = a[p]) && (f = e.call(d, d.__data__, p, a)) && ("__data__" in d && (f.__data__ = d.__data__), u[p] = f);
  return new rr(r, this._parents);
}
function Lz(e) {
  return e == null ? [] : Array.isArray(e) ? e : Array.from(e);
}
function Iz() {
  return [];
}
function BO(e) {
  return e == null ? Iz : function() {
    return this.querySelectorAll(e);
  };
}
function Bz(e) {
  return function() {
    return Lz(e.apply(this, arguments));
  };
}
function Vz(e) {
  typeof e == "function" ? e = Bz(e) : e = BO(e);
  for (var t = this._groups, n = t.length, r = [], o = [], a = 0; a < n; ++a)
    for (var l = t[a], u = l.length, d, f = 0; f < u; ++f)
      (d = l[f]) && (r.push(e.call(d, d.__data__, f, l)), o.push(d));
  return new rr(r, o);
}
function VO(e) {
  return function() {
    return this.matches(e);
  };
}
function HO(e) {
  return function(t) {
    return t.matches(e);
  };
}
var Hz = Array.prototype.find;
function Uz(e) {
  return function() {
    return Hz.call(this.children, e);
  };
}
function Fz() {
  return this.firstElementChild;
}
function $z(e) {
  return this.select(e == null ? Fz : Uz(typeof e == "function" ? e : HO(e)));
}
var Yz = Array.prototype.filter;
function qz() {
  return Array.from(this.children);
}
function Xz(e) {
  return function() {
    return Yz.call(this.children, e);
  };
}
function Gz(e) {
  return this.selectAll(e == null ? qz : Xz(typeof e == "function" ? e : HO(e)));
}
function Zz(e) {
  typeof e != "function" && (e = VO(e));
  for (var t = this._groups, n = t.length, r = new Array(n), o = 0; o < n; ++o)
    for (var a = t[o], l = a.length, u = r[o] = [], d, f = 0; f < l; ++f)
      (d = a[f]) && e.call(d, d.__data__, f, a) && u.push(d);
  return new rr(r, this._parents);
}
function UO(e) {
  return new Array(e.length);
}
function Wz() {
  return new rr(this._enter || this._groups.map(UO), this._parents);
}
function gp(e, t) {
  this.ownerDocument = e.ownerDocument, this.namespaceURI = e.namespaceURI, this._next = null, this._parent = e, this.__data__ = t;
}
gp.prototype = {
  constructor: gp,
  appendChild: function(e) {
    return this._parent.insertBefore(e, this._next);
  },
  insertBefore: function(e, t) {
    return this._parent.insertBefore(e, t);
  },
  querySelector: function(e) {
    return this._parent.querySelector(e);
  },
  querySelectorAll: function(e) {
    return this._parent.querySelectorAll(e);
  }
};
function Kz(e) {
  return function() {
    return e;
  };
}
function Qz(e, t, n, r, o, a) {
  for (var l = 0, u, d = t.length, f = a.length; l < f; ++l)
    (u = t[l]) ? (u.__data__ = a[l], r[l] = u) : n[l] = new gp(e, a[l]);
  for (; l < d; ++l)
    (u = t[l]) && (o[l] = u);
}
function Jz(e, t, n, r, o, a, l) {
  var u, d, f = /* @__PURE__ */ new Map(), p = t.length, m = a.length, g = new Array(p), y;
  for (u = 0; u < p; ++u)
    (d = t[u]) && (g[u] = y = l.call(d, d.__data__, u, t) + "", f.has(y) ? o[u] = d : f.set(y, d));
  for (u = 0; u < m; ++u)
    y = l.call(e, a[u], u, a) + "", (d = f.get(y)) ? (r[u] = d, d.__data__ = a[u], f.delete(y)) : n[u] = new gp(e, a[u]);
  for (u = 0; u < p; ++u)
    (d = t[u]) && f.get(g[u]) === d && (o[u] = d);
}
function eP(e) {
  return e.__data__;
}
function tP(e, t) {
  if (!arguments.length) return Array.from(this, eP);
  var n = t ? Jz : Qz, r = this._parents, o = this._groups;
  typeof e != "function" && (e = Kz(e));
  for (var a = o.length, l = new Array(a), u = new Array(a), d = new Array(a), f = 0; f < a; ++f) {
    var p = r[f], m = o[f], g = m.length, y = nP(e.call(p, p && p.__data__, f, r)), w = y.length, v = u[f] = new Array(w), x = l[f] = new Array(w), E = d[f] = new Array(g);
    n(p, m, v, x, E, y, t);
    for (var N = 0, C = 0, A, R; N < w; ++N)
      if (A = v[N]) {
        for (N >= C && (C = N + 1); !(R = x[C]) && ++C < w; ) ;
        A._next = R || null;
      }
  }
  return l = new rr(l, r), l._enter = u, l._exit = d, l;
}
function nP(e) {
  return typeof e == "object" && "length" in e ? e : Array.from(e);
}
function rP() {
  return new rr(this._exit || this._groups.map(UO), this._parents);
}
function oP(e, t, n) {
  var r = this.enter(), o = this, a = this.exit();
  return typeof e == "function" ? (r = e(r), r && (r = r.selection())) : r = r.append(e + ""), t != null && (o = t(o), o && (o = o.selection())), n == null ? a.remove() : n(a), r && o ? r.merge(o).order() : o;
}
function iP(e) {
  for (var t = e.selection ? e.selection() : e, n = this._groups, r = t._groups, o = n.length, a = r.length, l = Math.min(o, a), u = new Array(o), d = 0; d < l; ++d)
    for (var f = n[d], p = r[d], m = f.length, g = u[d] = new Array(m), y, w = 0; w < m; ++w)
      (y = f[w] || p[w]) && (g[w] = y);
  for (; d < o; ++d)
    u[d] = n[d];
  return new rr(u, this._parents);
}
function aP() {
  for (var e = this._groups, t = -1, n = e.length; ++t < n; )
    for (var r = e[t], o = r.length - 1, a = r[o], l; --o >= 0; )
      (l = r[o]) && (a && l.compareDocumentPosition(a) ^ 4 && a.parentNode.insertBefore(l, a), a = l);
  return this;
}
function lP(e) {
  e || (e = sP);
  function t(m, g) {
    return m && g ? e(m.__data__, g.__data__) : !m - !g;
  }
  for (var n = this._groups, r = n.length, o = new Array(r), a = 0; a < r; ++a) {
    for (var l = n[a], u = l.length, d = o[a] = new Array(u), f, p = 0; p < u; ++p)
      (f = l[p]) && (d[p] = f);
    d.sort(t);
  }
  return new rr(o, this._parents).order();
}
function sP(e, t) {
  return e < t ? -1 : e > t ? 1 : e >= t ? 0 : NaN;
}
function uP() {
  var e = arguments[0];
  return arguments[0] = this, e.apply(null, arguments), this;
}
function cP() {
  return Array.from(this);
}
function dP() {
  for (var e = this._groups, t = 0, n = e.length; t < n; ++t)
    for (var r = e[t], o = 0, a = r.length; o < a; ++o) {
      var l = r[o];
      if (l) return l;
    }
  return null;
}
function fP() {
  let e = 0;
  for (const t of this) ++e;
  return e;
}
function pP() {
  return !this.node();
}
function hP(e) {
  for (var t = this._groups, n = 0, r = t.length; n < r; ++n)
    for (var o = t[n], a = 0, l = o.length, u; a < l; ++a)
      (u = o[a]) && e.call(u, u.__data__, a, o);
  return this;
}
function mP(e) {
  return function() {
    this.removeAttribute(e);
  };
}
function gP(e) {
  return function() {
    this.removeAttributeNS(e.space, e.local);
  };
}
function yP(e, t) {
  return function() {
    this.setAttribute(e, t);
  };
}
function vP(e, t) {
  return function() {
    this.setAttributeNS(e.space, e.local, t);
  };
}
function bP(e, t) {
  return function() {
    var n = t.apply(this, arguments);
    n == null ? this.removeAttribute(e) : this.setAttribute(e, n);
  };
}
function wP(e, t) {
  return function() {
    var n = t.apply(this, arguments);
    n == null ? this.removeAttributeNS(e.space, e.local) : this.setAttributeNS(e.space, e.local, n);
  };
}
function xP(e, t) {
  var n = oh(e);
  if (arguments.length < 2) {
    var r = this.node();
    return n.local ? r.getAttributeNS(n.space, n.local) : r.getAttribute(n);
  }
  return this.each((t == null ? n.local ? gP : mP : typeof t == "function" ? n.local ? wP : bP : n.local ? vP : yP)(n, t));
}
function FO(e) {
  return e.ownerDocument && e.ownerDocument.defaultView || e.document && e || e.defaultView;
}
function SP(e) {
  return function() {
    this.style.removeProperty(e);
  };
}
function kP(e, t, n) {
  return function() {
    this.style.setProperty(e, t, n);
  };
}
function _P(e, t, n) {
  return function() {
    var r = t.apply(this, arguments);
    r == null ? this.style.removeProperty(e) : this.style.setProperty(e, r, n);
  };
}
function EP(e, t, n) {
  return arguments.length > 1 ? this.each((t == null ? SP : typeof t == "function" ? _P : kP)(e, t, n ?? "")) : ts(this.node(), e);
}
function ts(e, t) {
  return e.style.getPropertyValue(t) || FO(e).getComputedStyle(e, null).getPropertyValue(t);
}
function CP(e) {
  return function() {
    delete this[e];
  };
}
function OP(e, t) {
  return function() {
    this[e] = t;
  };
}
function NP(e, t) {
  return function() {
    var n = t.apply(this, arguments);
    n == null ? delete this[e] : this[e] = n;
  };
}
function MP(e, t) {
  return arguments.length > 1 ? this.each((t == null ? CP : typeof t == "function" ? NP : OP)(e, t)) : this.node()[e];
}
function $O(e) {
  return e.trim().split(/^|\s+/);
}
function sw(e) {
  return e.classList || new YO(e);
}
function YO(e) {
  this._node = e, this._names = $O(e.getAttribute("class") || "");
}
YO.prototype = {
  add: function(e) {
    var t = this._names.indexOf(e);
    t < 0 && (this._names.push(e), this._node.setAttribute("class", this._names.join(" ")));
  },
  remove: function(e) {
    var t = this._names.indexOf(e);
    t >= 0 && (this._names.splice(t, 1), this._node.setAttribute("class", this._names.join(" ")));
  },
  contains: function(e) {
    return this._names.indexOf(e) >= 0;
  }
};
function qO(e, t) {
  for (var n = sw(e), r = -1, o = t.length; ++r < o; ) n.add(t[r]);
}
function XO(e, t) {
  for (var n = sw(e), r = -1, o = t.length; ++r < o; ) n.remove(t[r]);
}
function AP(e) {
  return function() {
    qO(this, e);
  };
}
function RP(e) {
  return function() {
    XO(this, e);
  };
}
function jP(e, t) {
  return function() {
    (t.apply(this, arguments) ? qO : XO)(this, e);
  };
}
function DP(e, t) {
  var n = $O(e + "");
  if (arguments.length < 2) {
    for (var r = sw(this.node()), o = -1, a = n.length; ++o < a; ) if (!r.contains(n[o])) return !1;
    return !0;
  }
  return this.each((typeof t == "function" ? jP : t ? AP : RP)(n, t));
}
function TP() {
  this.textContent = "";
}
function zP(e) {
  return function() {
    this.textContent = e;
  };
}
function PP(e) {
  return function() {
    var t = e.apply(this, arguments);
    this.textContent = t ?? "";
  };
}
function LP(e) {
  return arguments.length ? this.each(e == null ? TP : (typeof e == "function" ? PP : zP)(e)) : this.node().textContent;
}
function IP() {
  this.innerHTML = "";
}
function BP(e) {
  return function() {
    this.innerHTML = e;
  };
}
function VP(e) {
  return function() {
    var t = e.apply(this, arguments);
    this.innerHTML = t ?? "";
  };
}
function HP(e) {
  return arguments.length ? this.each(e == null ? IP : (typeof e == "function" ? VP : BP)(e)) : this.node().innerHTML;
}
function UP() {
  this.nextSibling && this.parentNode.appendChild(this);
}
function FP() {
  return this.each(UP);
}
function $P() {
  this.previousSibling && this.parentNode.insertBefore(this, this.parentNode.firstChild);
}
function YP() {
  return this.each($P);
}
function qP(e) {
  var t = typeof e == "function" ? e : IO(e);
  return this.select(function() {
    return this.appendChild(t.apply(this, arguments));
  });
}
function XP() {
  return null;
}
function GP(e, t) {
  var n = typeof e == "function" ? e : IO(e), r = t == null ? XP : typeof t == "function" ? t : lw(t);
  return this.select(function() {
    return this.insertBefore(n.apply(this, arguments), r.apply(this, arguments) || null);
  });
}
function ZP() {
  var e = this.parentNode;
  e && e.removeChild(this);
}
function WP() {
  return this.each(ZP);
}
function KP() {
  var e = this.cloneNode(!1), t = this.parentNode;
  return t ? t.insertBefore(e, this.nextSibling) : e;
}
function QP() {
  var e = this.cloneNode(!0), t = this.parentNode;
  return t ? t.insertBefore(e, this.nextSibling) : e;
}
function JP(e) {
  return this.select(e ? QP : KP);
}
function e8(e) {
  return arguments.length ? this.property("__data__", e) : this.node().__data__;
}
function t8(e) {
  return function(t) {
    e.call(this, t, this.__data__);
  };
}
function n8(e) {
  return e.trim().split(/^|\s+/).map(function(t) {
    var n = "", r = t.indexOf(".");
    return r >= 0 && (n = t.slice(r + 1), t = t.slice(0, r)), { type: t, name: n };
  });
}
function r8(e) {
  return function() {
    var t = this.__on;
    if (t) {
      for (var n = 0, r = -1, o = t.length, a; n < o; ++n)
        a = t[n], (!e.type || a.type === e.type) && a.name === e.name ? this.removeEventListener(a.type, a.listener, a.options) : t[++r] = a;
      ++r ? t.length = r : delete this.__on;
    }
  };
}
function o8(e, t, n) {
  return function() {
    var r = this.__on, o, a = t8(t);
    if (r) {
      for (var l = 0, u = r.length; l < u; ++l)
        if ((o = r[l]).type === e.type && o.name === e.name) {
          this.removeEventListener(o.type, o.listener, o.options), this.addEventListener(o.type, o.listener = a, o.options = n), o.value = t;
          return;
        }
    }
    this.addEventListener(e.type, a, n), o = { type: e.type, name: e.name, value: t, listener: a, options: n }, r ? r.push(o) : this.__on = [o];
  };
}
function i8(e, t, n) {
  var r = n8(e + ""), o, a = r.length, l;
  if (arguments.length < 2) {
    var u = this.node().__on;
    if (u) {
      for (var d = 0, f = u.length, p; d < f; ++d)
        for (o = 0, p = u[d]; o < a; ++o)
          if ((l = r[o]).type === p.type && l.name === p.name)
            return p.value;
    }
    return;
  }
  for (u = t ? o8 : r8, o = 0; o < a; ++o) this.each(u(r[o], t, n));
  return this;
}
function GO(e, t, n) {
  var r = FO(e), o = r.CustomEvent;
  typeof o == "function" ? o = new o(t, n) : (o = r.document.createEvent("Event"), n ? (o.initEvent(t, n.bubbles, n.cancelable), o.detail = n.detail) : o.initEvent(t, !1, !1)), e.dispatchEvent(o);
}
function a8(e, t) {
  return function() {
    return GO(this, e, t);
  };
}
function l8(e, t) {
  return function() {
    return GO(this, e, t.apply(this, arguments));
  };
}
function s8(e, t) {
  return this.each((typeof t == "function" ? l8 : a8)(e, t));
}
function* u8() {
  for (var e = this._groups, t = 0, n = e.length; t < n; ++t)
    for (var r = e[t], o = 0, a = r.length, l; o < a; ++o)
      (l = r[o]) && (yield l);
}
var ZO = [null];
function rr(e, t) {
  this._groups = e, this._parents = t;
}
function Ac() {
  return new rr([[document.documentElement]], ZO);
}
function c8() {
  return this;
}
rr.prototype = Ac.prototype = {
  constructor: rr,
  select: Pz,
  selectAll: Vz,
  selectChild: $z,
  selectChildren: Gz,
  filter: Zz,
  data: tP,
  enter: Wz,
  exit: rP,
  join: oP,
  merge: iP,
  selection: c8,
  order: aP,
  sort: lP,
  call: uP,
  nodes: cP,
  node: dP,
  size: fP,
  empty: pP,
  each: hP,
  attr: xP,
  style: EP,
  property: MP,
  classed: DP,
  text: LP,
  html: HP,
  raise: FP,
  lower: YP,
  append: qP,
  insert: GP,
  remove: WP,
  clone: JP,
  datum: e8,
  on: i8,
  dispatch: s8,
  [Symbol.iterator]: u8
};
function Wn(e) {
  return typeof e == "string" ? new rr([[document.querySelector(e)]], [document.documentElement]) : new rr([[e]], ZO);
}
function d8(e) {
  let t;
  for (; t = e.sourceEvent; ) e = t;
  return e;
}
function Cr(e, t) {
  if (e = d8(e), t === void 0 && (t = e.currentTarget), t) {
    var n = t.ownerSVGElement || t;
    if (n.createSVGPoint) {
      var r = n.createSVGPoint();
      return r.x = e.clientX, r.y = e.clientY, r = r.matrixTransform(t.getScreenCTM().inverse()), [r.x, r.y];
    }
    if (t.getBoundingClientRect) {
      var o = t.getBoundingClientRect();
      return [e.clientX - o.left - t.clientLeft, e.clientY - o.top - t.clientTop];
    }
  }
  return [e.pageX, e.pageY];
}
const f8 = { passive: !1 }, oc = { capture: !0, passive: !1 };
function Ny(e) {
  e.stopImmediatePropagation();
}
function ql(e) {
  e.preventDefault(), e.stopImmediatePropagation();
}
function WO(e) {
  var t = e.document.documentElement, n = Wn(e).on("dragstart.drag", ql, oc);
  "onselectstart" in t ? n.on("selectstart.drag", ql, oc) : (t.__noselect = t.style.MozUserSelect, t.style.MozUserSelect = "none");
}
function KO(e, t) {
  var n = e.document.documentElement, r = Wn(e).on("dragstart.drag", null);
  t && (r.on("click.drag", ql, oc), setTimeout(function() {
    r.on("click.drag", null);
  }, 0)), "onselectstart" in n ? r.on("selectstart.drag", null) : (n.style.MozUserSelect = n.__noselect, delete n.__noselect);
}
const bf = (e) => () => e;
function Iv(e, {
  sourceEvent: t,
  subject: n,
  target: r,
  identifier: o,
  active: a,
  x: l,
  y: u,
  dx: d,
  dy: f,
  dispatch: p
}) {
  Object.defineProperties(this, {
    type: { value: e, enumerable: !0, configurable: !0 },
    sourceEvent: { value: t, enumerable: !0, configurable: !0 },
    subject: { value: n, enumerable: !0, configurable: !0 },
    target: { value: r, enumerable: !0, configurable: !0 },
    identifier: { value: o, enumerable: !0, configurable: !0 },
    active: { value: a, enumerable: !0, configurable: !0 },
    x: { value: l, enumerable: !0, configurable: !0 },
    y: { value: u, enumerable: !0, configurable: !0 },
    dx: { value: d, enumerable: !0, configurable: !0 },
    dy: { value: f, enumerable: !0, configurable: !0 },
    _: { value: p }
  });
}
Iv.prototype.on = function() {
  var e = this._.on.apply(this._, arguments);
  return e === this._ ? this : e;
};
function p8(e) {
  return !e.ctrlKey && !e.button;
}
function h8() {
  return this.parentNode;
}
function m8(e, t) {
  return t ?? { x: e.x, y: e.y };
}
function g8() {
  return navigator.maxTouchPoints || "ontouchstart" in this;
}
function QO() {
  var e = p8, t = h8, n = m8, r = g8, o = {}, a = rh("start", "drag", "end"), l = 0, u, d, f, p, m = 0;
  function g(A) {
    A.on("mousedown.drag", y).filter(r).on("touchstart.drag", x).on("touchmove.drag", E, f8).on("touchend.drag touchcancel.drag", N).style("touch-action", "none").style("-webkit-tap-highlight-color", "rgba(0,0,0,0)");
  }
  function y(A, R) {
    if (!(p || !e.call(this, A, R))) {
      var D = C(this, t.call(this, A, R), A, R, "mouse");
      D && (Wn(A.view).on("mousemove.drag", w, oc).on("mouseup.drag", v, oc), WO(A.view), Ny(A), f = !1, u = A.clientX, d = A.clientY, D("start", A));
    }
  }
  function w(A) {
    if (ql(A), !f) {
      var R = A.clientX - u, D = A.clientY - d;
      f = R * R + D * D > m;
    }
    o.mouse("drag", A);
  }
  function v(A) {
    Wn(A.view).on("mousemove.drag mouseup.drag", null), KO(A.view, f), ql(A), o.mouse("end", A);
  }
  function x(A, R) {
    if (e.call(this, A, R)) {
      var D = A.changedTouches, T = t.call(this, A, R), V = D.length, F, O;
      for (F = 0; F < V; ++F)
        (O = C(this, T, A, R, D[F].identifier, D[F])) && (Ny(A), O("start", A, D[F]));
    }
  }
  function E(A) {
    var R = A.changedTouches, D = R.length, T, V;
    for (T = 0; T < D; ++T)
      (V = o[R[T].identifier]) && (ql(A), V("drag", A, R[T]));
  }
  function N(A) {
    var R = A.changedTouches, D = R.length, T, V;
    for (p && clearTimeout(p), p = setTimeout(function() {
      p = null;
    }, 500), T = 0; T < D; ++T)
      (V = o[R[T].identifier]) && (Ny(A), V("end", A, R[T]));
  }
  function C(A, R, D, T, V, F) {
    var O = a.copy(), B = Cr(F || D, R), U, G, z;
    if ((z = n.call(A, new Iv("beforestart", {
      sourceEvent: D,
      target: g,
      identifier: V,
      active: l,
      x: B[0],
      y: B[1],
      dx: 0,
      dy: 0,
      dispatch: O
    }), T)) != null)
      return U = z.x - B[0] || 0, G = z.y - B[1] || 0, function $(L, H, q) {
        var Y = B, M;
        switch (L) {
          case "start":
            o[V] = $, M = l++;
            break;
          case "end":
            delete o[V], --l;
          // falls through
          case "drag":
            B = Cr(q || H, R), M = l;
            break;
        }
        O.call(
          L,
          A,
          new Iv(L, {
            sourceEvent: H,
            subject: z,
            target: g,
            identifier: V,
            active: M,
            x: B[0] + U,
            y: B[1] + G,
            dx: B[0] - Y[0],
            dy: B[1] - Y[1],
            dispatch: O
          }),
          T
        );
      };
  }
  return g.filter = function(A) {
    return arguments.length ? (e = typeof A == "function" ? A : bf(!!A), g) : e;
  }, g.container = function(A) {
    return arguments.length ? (t = typeof A == "function" ? A : bf(A), g) : t;
  }, g.subject = function(A) {
    return arguments.length ? (n = typeof A == "function" ? A : bf(A), g) : n;
  }, g.touchable = function(A) {
    return arguments.length ? (r = typeof A == "function" ? A : bf(!!A), g) : r;
  }, g.on = function() {
    var A = a.on.apply(a, arguments);
    return A === a ? g : A;
  }, g.clickDistance = function(A) {
    return arguments.length ? (m = (A = +A) * A, g) : Math.sqrt(m);
  }, g;
}
function uw(e, t, n) {
  e.prototype = t.prototype = n, n.constructor = e;
}
function JO(e, t) {
  var n = Object.create(e.prototype);
  for (var r in t) n[r] = t[r];
  return n;
}
function Rc() {
}
var ic = 0.7, yp = 1 / ic, Xl = "\\s*([+-]?\\d+)\\s*", ac = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)\\s*", no = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)%\\s*", y8 = /^#([0-9a-f]{3,8})$/, v8 = new RegExp(`^rgb\\(${Xl},${Xl},${Xl}\\)$`), b8 = new RegExp(`^rgb\\(${no},${no},${no}\\)$`), w8 = new RegExp(`^rgba\\(${Xl},${Xl},${Xl},${ac}\\)$`), x8 = new RegExp(`^rgba\\(${no},${no},${no},${ac}\\)$`), S8 = new RegExp(`^hsl\\(${ac},${no},${no}\\)$`), k8 = new RegExp(`^hsla\\(${ac},${no},${no},${ac}\\)$`), o0 = {
  aliceblue: 15792383,
  antiquewhite: 16444375,
  aqua: 65535,
  aquamarine: 8388564,
  azure: 15794175,
  beige: 16119260,
  bisque: 16770244,
  black: 0,
  blanchedalmond: 16772045,
  blue: 255,
  blueviolet: 9055202,
  brown: 10824234,
  burlywood: 14596231,
  cadetblue: 6266528,
  chartreuse: 8388352,
  chocolate: 13789470,
  coral: 16744272,
  cornflowerblue: 6591981,
  cornsilk: 16775388,
  crimson: 14423100,
  cyan: 65535,
  darkblue: 139,
  darkcyan: 35723,
  darkgoldenrod: 12092939,
  darkgray: 11119017,
  darkgreen: 25600,
  darkgrey: 11119017,
  darkkhaki: 12433259,
  darkmagenta: 9109643,
  darkolivegreen: 5597999,
  darkorange: 16747520,
  darkorchid: 10040012,
  darkred: 9109504,
  darksalmon: 15308410,
  darkseagreen: 9419919,
  darkslateblue: 4734347,
  darkslategray: 3100495,
  darkslategrey: 3100495,
  darkturquoise: 52945,
  darkviolet: 9699539,
  deeppink: 16716947,
  deepskyblue: 49151,
  dimgray: 6908265,
  dimgrey: 6908265,
  dodgerblue: 2003199,
  firebrick: 11674146,
  floralwhite: 16775920,
  forestgreen: 2263842,
  fuchsia: 16711935,
  gainsboro: 14474460,
  ghostwhite: 16316671,
  gold: 16766720,
  goldenrod: 14329120,
  gray: 8421504,
  green: 32768,
  greenyellow: 11403055,
  grey: 8421504,
  honeydew: 15794160,
  hotpink: 16738740,
  indianred: 13458524,
  indigo: 4915330,
  ivory: 16777200,
  khaki: 15787660,
  lavender: 15132410,
  lavenderblush: 16773365,
  lawngreen: 8190976,
  lemonchiffon: 16775885,
  lightblue: 11393254,
  lightcoral: 15761536,
  lightcyan: 14745599,
  lightgoldenrodyellow: 16448210,
  lightgray: 13882323,
  lightgreen: 9498256,
  lightgrey: 13882323,
  lightpink: 16758465,
  lightsalmon: 16752762,
  lightseagreen: 2142890,
  lightskyblue: 8900346,
  lightslategray: 7833753,
  lightslategrey: 7833753,
  lightsteelblue: 11584734,
  lightyellow: 16777184,
  lime: 65280,
  limegreen: 3329330,
  linen: 16445670,
  magenta: 16711935,
  maroon: 8388608,
  mediumaquamarine: 6737322,
  mediumblue: 205,
  mediumorchid: 12211667,
  mediumpurple: 9662683,
  mediumseagreen: 3978097,
  mediumslateblue: 8087790,
  mediumspringgreen: 64154,
  mediumturquoise: 4772300,
  mediumvioletred: 13047173,
  midnightblue: 1644912,
  mintcream: 16121850,
  mistyrose: 16770273,
  moccasin: 16770229,
  navajowhite: 16768685,
  navy: 128,
  oldlace: 16643558,
  olive: 8421376,
  olivedrab: 7048739,
  orange: 16753920,
  orangered: 16729344,
  orchid: 14315734,
  palegoldenrod: 15657130,
  palegreen: 10025880,
  paleturquoise: 11529966,
  palevioletred: 14381203,
  papayawhip: 16773077,
  peachpuff: 16767673,
  peru: 13468991,
  pink: 16761035,
  plum: 14524637,
  powderblue: 11591910,
  purple: 8388736,
  rebeccapurple: 6697881,
  red: 16711680,
  rosybrown: 12357519,
  royalblue: 4286945,
  saddlebrown: 9127187,
  salmon: 16416882,
  sandybrown: 16032864,
  seagreen: 3050327,
  seashell: 16774638,
  sienna: 10506797,
  silver: 12632256,
  skyblue: 8900331,
  slateblue: 6970061,
  slategray: 7372944,
  slategrey: 7372944,
  snow: 16775930,
  springgreen: 65407,
  steelblue: 4620980,
  tan: 13808780,
  teal: 32896,
  thistle: 14204888,
  tomato: 16737095,
  turquoise: 4251856,
  violet: 15631086,
  wheat: 16113331,
  white: 16777215,
  whitesmoke: 16119285,
  yellow: 16776960,
  yellowgreen: 10145074
};
uw(Rc, lc, {
  copy(e) {
    return Object.assign(new this.constructor(), this, e);
  },
  displayable() {
    return this.rgb().displayable();
  },
  hex: i0,
  // Deprecated! Use color.formatHex.
  formatHex: i0,
  formatHex8: _8,
  formatHsl: E8,
  formatRgb: a0,
  toString: a0
});
function i0() {
  return this.rgb().formatHex();
}
function _8() {
  return this.rgb().formatHex8();
}
function E8() {
  return e3(this).formatHsl();
}
function a0() {
  return this.rgb().formatRgb();
}
function lc(e) {
  var t, n;
  return e = (e + "").trim().toLowerCase(), (t = y8.exec(e)) ? (n = t[1].length, t = parseInt(t[1], 16), n === 6 ? l0(t) : n === 3 ? new zn(t >> 8 & 15 | t >> 4 & 240, t >> 4 & 15 | t & 240, (t & 15) << 4 | t & 15, 1) : n === 8 ? wf(t >> 24 & 255, t >> 16 & 255, t >> 8 & 255, (t & 255) / 255) : n === 4 ? wf(t >> 12 & 15 | t >> 8 & 240, t >> 8 & 15 | t >> 4 & 240, t >> 4 & 15 | t & 240, ((t & 15) << 4 | t & 15) / 255) : null) : (t = v8.exec(e)) ? new zn(t[1], t[2], t[3], 1) : (t = b8.exec(e)) ? new zn(t[1] * 255 / 100, t[2] * 255 / 100, t[3] * 255 / 100, 1) : (t = w8.exec(e)) ? wf(t[1], t[2], t[3], t[4]) : (t = x8.exec(e)) ? wf(t[1] * 255 / 100, t[2] * 255 / 100, t[3] * 255 / 100, t[4]) : (t = S8.exec(e)) ? c0(t[1], t[2] / 100, t[3] / 100, 1) : (t = k8.exec(e)) ? c0(t[1], t[2] / 100, t[3] / 100, t[4]) : o0.hasOwnProperty(e) ? l0(o0[e]) : e === "transparent" ? new zn(NaN, NaN, NaN, 0) : null;
}
function l0(e) {
  return new zn(e >> 16 & 255, e >> 8 & 255, e & 255, 1);
}
function wf(e, t, n, r) {
  return r <= 0 && (e = t = n = NaN), new zn(e, t, n, r);
}
function C8(e) {
  return e instanceof Rc || (e = lc(e)), e ? (e = e.rgb(), new zn(e.r, e.g, e.b, e.opacity)) : new zn();
}
function Bv(e, t, n, r) {
  return arguments.length === 1 ? C8(e) : new zn(e, t, n, r ?? 1);
}
function zn(e, t, n, r) {
  this.r = +e, this.g = +t, this.b = +n, this.opacity = +r;
}
uw(zn, Bv, JO(Rc, {
  brighter(e) {
    return e = e == null ? yp : Math.pow(yp, e), new zn(this.r * e, this.g * e, this.b * e, this.opacity);
  },
  darker(e) {
    return e = e == null ? ic : Math.pow(ic, e), new zn(this.r * e, this.g * e, this.b * e, this.opacity);
  },
  rgb() {
    return this;
  },
  clamp() {
    return new zn(Ca(this.r), Ca(this.g), Ca(this.b), vp(this.opacity));
  },
  displayable() {
    return -0.5 <= this.r && this.r < 255.5 && -0.5 <= this.g && this.g < 255.5 && -0.5 <= this.b && this.b < 255.5 && 0 <= this.opacity && this.opacity <= 1;
  },
  hex: s0,
  // Deprecated! Use color.formatHex.
  formatHex: s0,
  formatHex8: O8,
  formatRgb: u0,
  toString: u0
}));
function s0() {
  return `#${xa(this.r)}${xa(this.g)}${xa(this.b)}`;
}
function O8() {
  return `#${xa(this.r)}${xa(this.g)}${xa(this.b)}${xa((isNaN(this.opacity) ? 1 : this.opacity) * 255)}`;
}
function u0() {
  const e = vp(this.opacity);
  return `${e === 1 ? "rgb(" : "rgba("}${Ca(this.r)}, ${Ca(this.g)}, ${Ca(this.b)}${e === 1 ? ")" : `, ${e})`}`;
}
function vp(e) {
  return isNaN(e) ? 1 : Math.max(0, Math.min(1, e));
}
function Ca(e) {
  return Math.max(0, Math.min(255, Math.round(e) || 0));
}
function xa(e) {
  return e = Ca(e), (e < 16 ? "0" : "") + e.toString(16);
}
function c0(e, t, n, r) {
  return r <= 0 ? e = t = n = NaN : n <= 0 || n >= 1 ? e = t = NaN : t <= 0 && (e = NaN), new Nr(e, t, n, r);
}
function e3(e) {
  if (e instanceof Nr) return new Nr(e.h, e.s, e.l, e.opacity);
  if (e instanceof Rc || (e = lc(e)), !e) return new Nr();
  if (e instanceof Nr) return e;
  e = e.rgb();
  var t = e.r / 255, n = e.g / 255, r = e.b / 255, o = Math.min(t, n, r), a = Math.max(t, n, r), l = NaN, u = a - o, d = (a + o) / 2;
  return u ? (t === a ? l = (n - r) / u + (n < r) * 6 : n === a ? l = (r - t) / u + 2 : l = (t - n) / u + 4, u /= d < 0.5 ? a + o : 2 - a - o, l *= 60) : u = d > 0 && d < 1 ? 0 : l, new Nr(l, u, d, e.opacity);
}
function N8(e, t, n, r) {
  return arguments.length === 1 ? e3(e) : new Nr(e, t, n, r ?? 1);
}
function Nr(e, t, n, r) {
  this.h = +e, this.s = +t, this.l = +n, this.opacity = +r;
}
uw(Nr, N8, JO(Rc, {
  brighter(e) {
    return e = e == null ? yp : Math.pow(yp, e), new Nr(this.h, this.s, this.l * e, this.opacity);
  },
  darker(e) {
    return e = e == null ? ic : Math.pow(ic, e), new Nr(this.h, this.s, this.l * e, this.opacity);
  },
  rgb() {
    var e = this.h % 360 + (this.h < 0) * 360, t = isNaN(e) || isNaN(this.s) ? 0 : this.s, n = this.l, r = n + (n < 0.5 ? n : 1 - n) * t, o = 2 * n - r;
    return new zn(
      My(e >= 240 ? e - 240 : e + 120, o, r),
      My(e, o, r),
      My(e < 120 ? e + 240 : e - 120, o, r),
      this.opacity
    );
  },
  clamp() {
    return new Nr(d0(this.h), xf(this.s), xf(this.l), vp(this.opacity));
  },
  displayable() {
    return (0 <= this.s && this.s <= 1 || isNaN(this.s)) && 0 <= this.l && this.l <= 1 && 0 <= this.opacity && this.opacity <= 1;
  },
  formatHsl() {
    const e = vp(this.opacity);
    return `${e === 1 ? "hsl(" : "hsla("}${d0(this.h)}, ${xf(this.s) * 100}%, ${xf(this.l) * 100}%${e === 1 ? ")" : `, ${e})`}`;
  }
}));
function d0(e) {
  return e = (e || 0) % 360, e < 0 ? e + 360 : e;
}
function xf(e) {
  return Math.max(0, Math.min(1, e || 0));
}
function My(e, t, n) {
  return (e < 60 ? t + (n - t) * e / 60 : e < 180 ? n : e < 240 ? t + (n - t) * (240 - e) / 60 : t) * 255;
}
const t3 = (e) => () => e;
function M8(e, t) {
  return function(n) {
    return e + n * t;
  };
}
function A8(e, t, n) {
  return e = Math.pow(e, n), t = Math.pow(t, n) - e, n = 1 / n, function(r) {
    return Math.pow(e + r * t, n);
  };
}
function R8(e) {
  return (e = +e) == 1 ? n3 : function(t, n) {
    return n - t ? A8(t, n, e) : t3(isNaN(t) ? n : t);
  };
}
function n3(e, t) {
  var n = t - e;
  return n ? M8(e, n) : t3(isNaN(e) ? t : e);
}
const f0 = function e(t) {
  var n = R8(t);
  function r(o, a) {
    var l = n((o = Bv(o)).r, (a = Bv(a)).r), u = n(o.g, a.g), d = n(o.b, a.b), f = n3(o.opacity, a.opacity);
    return function(p) {
      return o.r = l(p), o.g = u(p), o.b = d(p), o.opacity = f(p), o + "";
    };
  }
  return r.gamma = e, r;
}(1);
function Ti(e, t) {
  return e = +e, t = +t, function(n) {
    return e * (1 - n) + t * n;
  };
}
var Vv = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g, Ay = new RegExp(Vv.source, "g");
function j8(e) {
  return function() {
    return e;
  };
}
function D8(e) {
  return function(t) {
    return e(t) + "";
  };
}
function T8(e, t) {
  var n = Vv.lastIndex = Ay.lastIndex = 0, r, o, a, l = -1, u = [], d = [];
  for (e = e + "", t = t + ""; (r = Vv.exec(e)) && (o = Ay.exec(t)); )
    (a = o.index) > n && (a = t.slice(n, a), u[l] ? u[l] += a : u[++l] = a), (r = r[0]) === (o = o[0]) ? u[l] ? u[l] += o : u[++l] = o : (u[++l] = null, d.push({ i: l, x: Ti(r, o) })), n = Ay.lastIndex;
  return n < t.length && (a = t.slice(n), u[l] ? u[l] += a : u[++l] = a), u.length < 2 ? d[0] ? D8(d[0].x) : j8(t) : (t = d.length, function(f) {
    for (var p = 0, m; p < t; ++p) u[(m = d[p]).i] = m.x(f);
    return u.join("");
  });
}
var p0 = 180 / Math.PI, r3 = {
  translateX: 0,
  translateY: 0,
  rotate: 0,
  skewX: 0,
  scaleX: 1,
  scaleY: 1
};
function o3(e, t, n, r, o, a) {
  var l, u, d;
  return (l = Math.sqrt(e * e + t * t)) && (e /= l, t /= l), (d = e * n + t * r) && (n -= e * d, r -= t * d), (u = Math.sqrt(n * n + r * r)) && (n /= u, r /= u, d /= u), e * r < t * n && (e = -e, t = -t, d = -d, l = -l), {
    translateX: o,
    translateY: a,
    rotate: Math.atan2(t, e) * p0,
    skewX: Math.atan(d) * p0,
    scaleX: l,
    scaleY: u
  };
}
var Sf;
function z8(e) {
  const t = new (typeof DOMMatrix == "function" ? DOMMatrix : WebKitCSSMatrix)(e + "");
  return t.isIdentity ? r3 : o3(t.a, t.b, t.c, t.d, t.e, t.f);
}
function P8(e) {
  return e == null || (Sf || (Sf = document.createElementNS("http://www.w3.org/2000/svg", "g")), Sf.setAttribute("transform", e), !(e = Sf.transform.baseVal.consolidate())) ? r3 : (e = e.matrix, o3(e.a, e.b, e.c, e.d, e.e, e.f));
}
function i3(e, t, n, r) {
  function o(f) {
    return f.length ? f.pop() + " " : "";
  }
  function a(f, p, m, g, y, w) {
    if (f !== m || p !== g) {
      var v = y.push("translate(", null, t, null, n);
      w.push({ i: v - 4, x: Ti(f, m) }, { i: v - 2, x: Ti(p, g) });
    } else (m || g) && y.push("translate(" + m + t + g + n);
  }
  function l(f, p, m, g) {
    f !== p ? (f - p > 180 ? p += 360 : p - f > 180 && (f += 360), g.push({ i: m.push(o(m) + "rotate(", null, r) - 2, x: Ti(f, p) })) : p && m.push(o(m) + "rotate(" + p + r);
  }
  function u(f, p, m, g) {
    f !== p ? g.push({ i: m.push(o(m) + "skewX(", null, r) - 2, x: Ti(f, p) }) : p && m.push(o(m) + "skewX(" + p + r);
  }
  function d(f, p, m, g, y, w) {
    if (f !== m || p !== g) {
      var v = y.push(o(y) + "scale(", null, ",", null, ")");
      w.push({ i: v - 4, x: Ti(f, m) }, { i: v - 2, x: Ti(p, g) });
    } else (m !== 1 || g !== 1) && y.push(o(y) + "scale(" + m + "," + g + ")");
  }
  return function(f, p) {
    var m = [], g = [];
    return f = e(f), p = e(p), a(f.translateX, f.translateY, p.translateX, p.translateY, m, g), l(f.rotate, p.rotate, m, g), u(f.skewX, p.skewX, m, g), d(f.scaleX, f.scaleY, p.scaleX, p.scaleY, m, g), f = p = null, function(y) {
      for (var w = -1, v = g.length, x; ++w < v; ) m[(x = g[w]).i] = x.x(y);
      return m.join("");
    };
  };
}
var L8 = i3(z8, "px, ", "px)", "deg)"), I8 = i3(P8, ", ", ")", ")"), B8 = 1e-12;
function h0(e) {
  return ((e = Math.exp(e)) + 1 / e) / 2;
}
function V8(e) {
  return ((e = Math.exp(e)) - 1 / e) / 2;
}
function H8(e) {
  return ((e = Math.exp(2 * e)) - 1) / (e + 1);
}
const U8 = function e(t, n, r) {
  function o(a, l) {
    var u = a[0], d = a[1], f = a[2], p = l[0], m = l[1], g = l[2], y = p - u, w = m - d, v = y * y + w * w, x, E;
    if (v < B8)
      E = Math.log(g / f) / t, x = function(T) {
        return [
          u + T * y,
          d + T * w,
          f * Math.exp(t * T * E)
        ];
      };
    else {
      var N = Math.sqrt(v), C = (g * g - f * f + r * v) / (2 * f * n * N), A = (g * g - f * f - r * v) / (2 * g * n * N), R = Math.log(Math.sqrt(C * C + 1) - C), D = Math.log(Math.sqrt(A * A + 1) - A);
      E = (D - R) / t, x = function(T) {
        var V = T * E, F = h0(R), O = f / (n * N) * (F * H8(t * V + R) - V8(R));
        return [
          u + O * y,
          d + O * w,
          f * F / h0(t * V + R)
        ];
      };
    }
    return x.duration = E * 1e3 * t / Math.SQRT2, x;
  }
  return o.rho = function(a) {
    var l = Math.max(1e-3, +a), u = l * l, d = u * u;
    return e(l, u, d);
  }, o;
}(Math.SQRT2, 2, 4);
var ns = 0, Fu = 0, Du = 0, a3 = 1e3, bp, $u, wp = 0, Ma = 0, ih = 0, sc = typeof performance == "object" && performance.now ? performance : Date, l3 = typeof window == "object" && window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : function(e) {
  setTimeout(e, 17);
};
function cw() {
  return Ma || (l3(F8), Ma = sc.now() + ih);
}
function F8() {
  Ma = 0;
}
function xp() {
  this._call = this._time = this._next = null;
}
xp.prototype = s3.prototype = {
  constructor: xp,
  restart: function(e, t, n) {
    if (typeof e != "function") throw new TypeError("callback is not a function");
    n = (n == null ? cw() : +n) + (t == null ? 0 : +t), !this._next && $u !== this && ($u ? $u._next = this : bp = this, $u = this), this._call = e, this._time = n, Hv();
  },
  stop: function() {
    this._call && (this._call = null, this._time = 1 / 0, Hv());
  }
};
function s3(e, t, n) {
  var r = new xp();
  return r.restart(e, t, n), r;
}
function $8() {
  cw(), ++ns;
  for (var e = bp, t; e; )
    (t = Ma - e._time) >= 0 && e._call.call(void 0, t), e = e._next;
  --ns;
}
function m0() {
  Ma = (wp = sc.now()) + ih, ns = Fu = 0;
  try {
    $8();
  } finally {
    ns = 0, q8(), Ma = 0;
  }
}
function Y8() {
  var e = sc.now(), t = e - wp;
  t > a3 && (ih -= t, wp = e);
}
function q8() {
  for (var e, t = bp, n, r = 1 / 0; t; )
    t._call ? (r > t._time && (r = t._time), e = t, t = t._next) : (n = t._next, t._next = null, t = e ? e._next = n : bp = n);
  $u = e, Hv(r);
}
function Hv(e) {
  if (!ns) {
    Fu && (Fu = clearTimeout(Fu));
    var t = e - Ma;
    t > 24 ? (e < 1 / 0 && (Fu = setTimeout(m0, e - sc.now() - ih)), Du && (Du = clearInterval(Du))) : (Du || (wp = sc.now(), Du = setInterval(Y8, a3)), ns = 1, l3(m0));
  }
}
function g0(e, t, n) {
  var r = new xp();
  return t = t == null ? 0 : +t, r.restart((o) => {
    r.stop(), e(o + t);
  }, t, n), r;
}
var X8 = rh("start", "end", "cancel", "interrupt"), G8 = [], u3 = 0, y0 = 1, Uv = 2, Kf = 3, v0 = 4, Fv = 5, Qf = 6;
function ah(e, t, n, r, o, a) {
  var l = e.__transition;
  if (!l) e.__transition = {};
  else if (n in l) return;
  Z8(e, n, {
    name: t,
    index: r,
    // For context during callback.
    group: o,
    // For context during callback.
    on: X8,
    tween: G8,
    time: a.time,
    delay: a.delay,
    duration: a.duration,
    ease: a.ease,
    timer: null,
    state: u3
  });
}
function dw(e, t) {
  var n = Tr(e, t);
  if (n.state > u3) throw new Error("too late; already scheduled");
  return n;
}
function lo(e, t) {
  var n = Tr(e, t);
  if (n.state > Kf) throw new Error("too late; already running");
  return n;
}
function Tr(e, t) {
  var n = e.__transition;
  if (!n || !(n = n[t])) throw new Error("transition not found");
  return n;
}
function Z8(e, t, n) {
  var r = e.__transition, o;
  r[t] = n, n.timer = s3(a, 0, n.time);
  function a(f) {
    n.state = y0, n.timer.restart(l, n.delay, n.time), n.delay <= f && l(f - n.delay);
  }
  function l(f) {
    var p, m, g, y;
    if (n.state !== y0) return d();
    for (p in r)
      if (y = r[p], y.name === n.name) {
        if (y.state === Kf) return g0(l);
        y.state === v0 ? (y.state = Qf, y.timer.stop(), y.on.call("interrupt", e, e.__data__, y.index, y.group), delete r[p]) : +p < t && (y.state = Qf, y.timer.stop(), y.on.call("cancel", e, e.__data__, y.index, y.group), delete r[p]);
      }
    if (g0(function() {
      n.state === Kf && (n.state = v0, n.timer.restart(u, n.delay, n.time), u(f));
    }), n.state = Uv, n.on.call("start", e, e.__data__, n.index, n.group), n.state === Uv) {
      for (n.state = Kf, o = new Array(g = n.tween.length), p = 0, m = -1; p < g; ++p)
        (y = n.tween[p].value.call(e, e.__data__, n.index, n.group)) && (o[++m] = y);
      o.length = m + 1;
    }
  }
  function u(f) {
    for (var p = f < n.duration ? n.ease.call(null, f / n.duration) : (n.timer.restart(d), n.state = Fv, 1), m = -1, g = o.length; ++m < g; )
      o[m].call(e, p);
    n.state === Fv && (n.on.call("end", e, e.__data__, n.index, n.group), d());
  }
  function d() {
    n.state = Qf, n.timer.stop(), delete r[t];
    for (var f in r) return;
    delete e.__transition;
  }
}
function Jf(e, t) {
  var n = e.__transition, r, o, a = !0, l;
  if (n) {
    t = t == null ? null : t + "";
    for (l in n) {
      if ((r = n[l]).name !== t) {
        a = !1;
        continue;
      }
      o = r.state > Uv && r.state < Fv, r.state = Qf, r.timer.stop(), r.on.call(o ? "interrupt" : "cancel", e, e.__data__, r.index, r.group), delete n[l];
    }
    a && delete e.__transition;
  }
}
function W8(e) {
  return this.each(function() {
    Jf(this, e);
  });
}
function K8(e, t) {
  var n, r;
  return function() {
    var o = lo(this, e), a = o.tween;
    if (a !== n) {
      r = n = a;
      for (var l = 0, u = r.length; l < u; ++l)
        if (r[l].name === t) {
          r = r.slice(), r.splice(l, 1);
          break;
        }
    }
    o.tween = r;
  };
}
function Q8(e, t, n) {
  var r, o;
  if (typeof n != "function") throw new Error();
  return function() {
    var a = lo(this, e), l = a.tween;
    if (l !== r) {
      o = (r = l).slice();
      for (var u = { name: t, value: n }, d = 0, f = o.length; d < f; ++d)
        if (o[d].name === t) {
          o[d] = u;
          break;
        }
      d === f && o.push(u);
    }
    a.tween = o;
  };
}
function J8(e, t) {
  var n = this._id;
  if (e += "", arguments.length < 2) {
    for (var r = Tr(this.node(), n).tween, o = 0, a = r.length, l; o < a; ++o)
      if ((l = r[o]).name === e)
        return l.value;
    return null;
  }
  return this.each((t == null ? K8 : Q8)(n, e, t));
}
function fw(e, t, n) {
  var r = e._id;
  return e.each(function() {
    var o = lo(this, r);
    (o.value || (o.value = {}))[t] = n.apply(this, arguments);
  }), function(o) {
    return Tr(o, r).value[t];
  };
}
function c3(e, t) {
  var n;
  return (typeof t == "number" ? Ti : t instanceof lc ? f0 : (n = lc(t)) ? (t = n, f0) : T8)(e, t);
}
function eL(e) {
  return function() {
    this.removeAttribute(e);
  };
}
function tL(e) {
  return function() {
    this.removeAttributeNS(e.space, e.local);
  };
}
function nL(e, t, n) {
  var r, o = n + "", a;
  return function() {
    var l = this.getAttribute(e);
    return l === o ? null : l === r ? a : a = t(r = l, n);
  };
}
function rL(e, t, n) {
  var r, o = n + "", a;
  return function() {
    var l = this.getAttributeNS(e.space, e.local);
    return l === o ? null : l === r ? a : a = t(r = l, n);
  };
}
function oL(e, t, n) {
  var r, o, a;
  return function() {
    var l, u = n(this), d;
    return u == null ? void this.removeAttribute(e) : (l = this.getAttribute(e), d = u + "", l === d ? null : l === r && d === o ? a : (o = d, a = t(r = l, u)));
  };
}
function iL(e, t, n) {
  var r, o, a;
  return function() {
    var l, u = n(this), d;
    return u == null ? void this.removeAttributeNS(e.space, e.local) : (l = this.getAttributeNS(e.space, e.local), d = u + "", l === d ? null : l === r && d === o ? a : (o = d, a = t(r = l, u)));
  };
}
function aL(e, t) {
  var n = oh(e), r = n === "transform" ? I8 : c3;
  return this.attrTween(e, typeof t == "function" ? (n.local ? iL : oL)(n, r, fw(this, "attr." + e, t)) : t == null ? (n.local ? tL : eL)(n) : (n.local ? rL : nL)(n, r, t));
}
function lL(e, t) {
  return function(n) {
    this.setAttribute(e, t.call(this, n));
  };
}
function sL(e, t) {
  return function(n) {
    this.setAttributeNS(e.space, e.local, t.call(this, n));
  };
}
function uL(e, t) {
  var n, r;
  function o() {
    var a = t.apply(this, arguments);
    return a !== r && (n = (r = a) && sL(e, a)), n;
  }
  return o._value = t, o;
}
function cL(e, t) {
  var n, r;
  function o() {
    var a = t.apply(this, arguments);
    return a !== r && (n = (r = a) && lL(e, a)), n;
  }
  return o._value = t, o;
}
function dL(e, t) {
  var n = "attr." + e;
  if (arguments.length < 2) return (n = this.tween(n)) && n._value;
  if (t == null) return this.tween(n, null);
  if (typeof t != "function") throw new Error();
  var r = oh(e);
  return this.tween(n, (r.local ? uL : cL)(r, t));
}
function fL(e, t) {
  return function() {
    dw(this, e).delay = +t.apply(this, arguments);
  };
}
function pL(e, t) {
  return t = +t, function() {
    dw(this, e).delay = t;
  };
}
function hL(e) {
  var t = this._id;
  return arguments.length ? this.each((typeof e == "function" ? fL : pL)(t, e)) : Tr(this.node(), t).delay;
}
function mL(e, t) {
  return function() {
    lo(this, e).duration = +t.apply(this, arguments);
  };
}
function gL(e, t) {
  return t = +t, function() {
    lo(this, e).duration = t;
  };
}
function yL(e) {
  var t = this._id;
  return arguments.length ? this.each((typeof e == "function" ? mL : gL)(t, e)) : Tr(this.node(), t).duration;
}
function vL(e, t) {
  if (typeof t != "function") throw new Error();
  return function() {
    lo(this, e).ease = t;
  };
}
function bL(e) {
  var t = this._id;
  return arguments.length ? this.each(vL(t, e)) : Tr(this.node(), t).ease;
}
function wL(e, t) {
  return function() {
    var n = t.apply(this, arguments);
    if (typeof n != "function") throw new Error();
    lo(this, e).ease = n;
  };
}
function xL(e) {
  if (typeof e != "function") throw new Error();
  return this.each(wL(this._id, e));
}
function SL(e) {
  typeof e != "function" && (e = VO(e));
  for (var t = this._groups, n = t.length, r = new Array(n), o = 0; o < n; ++o)
    for (var a = t[o], l = a.length, u = r[o] = [], d, f = 0; f < l; ++f)
      (d = a[f]) && e.call(d, d.__data__, f, a) && u.push(d);
  return new Fo(r, this._parents, this._name, this._id);
}
function kL(e) {
  if (e._id !== this._id) throw new Error();
  for (var t = this._groups, n = e._groups, r = t.length, o = n.length, a = Math.min(r, o), l = new Array(r), u = 0; u < a; ++u)
    for (var d = t[u], f = n[u], p = d.length, m = l[u] = new Array(p), g, y = 0; y < p; ++y)
      (g = d[y] || f[y]) && (m[y] = g);
  for (; u < r; ++u)
    l[u] = t[u];
  return new Fo(l, this._parents, this._name, this._id);
}
function _L(e) {
  return (e + "").trim().split(/^|\s+/).every(function(t) {
    var n = t.indexOf(".");
    return n >= 0 && (t = t.slice(0, n)), !t || t === "start";
  });
}
function EL(e, t, n) {
  var r, o, a = _L(t) ? dw : lo;
  return function() {
    var l = a(this, e), u = l.on;
    u !== r && (o = (r = u).copy()).on(t, n), l.on = o;
  };
}
function CL(e, t) {
  var n = this._id;
  return arguments.length < 2 ? Tr(this.node(), n).on.on(e) : this.each(EL(n, e, t));
}
function OL(e) {
  return function() {
    var t = this.parentNode;
    for (var n in this.__transition) if (+n !== e) return;
    t && t.removeChild(this);
  };
}
function NL() {
  return this.on("end.remove", OL(this._id));
}
function ML(e) {
  var t = this._name, n = this._id;
  typeof e != "function" && (e = lw(e));
  for (var r = this._groups, o = r.length, a = new Array(o), l = 0; l < o; ++l)
    for (var u = r[l], d = u.length, f = a[l] = new Array(d), p, m, g = 0; g < d; ++g)
      (p = u[g]) && (m = e.call(p, p.__data__, g, u)) && ("__data__" in p && (m.__data__ = p.__data__), f[g] = m, ah(f[g], t, n, g, f, Tr(p, n)));
  return new Fo(a, this._parents, t, n);
}
function AL(e) {
  var t = this._name, n = this._id;
  typeof e != "function" && (e = BO(e));
  for (var r = this._groups, o = r.length, a = [], l = [], u = 0; u < o; ++u)
    for (var d = r[u], f = d.length, p, m = 0; m < f; ++m)
      if (p = d[m]) {
        for (var g = e.call(p, p.__data__, m, d), y, w = Tr(p, n), v = 0, x = g.length; v < x; ++v)
          (y = g[v]) && ah(y, t, n, v, g, w);
        a.push(g), l.push(p);
      }
  return new Fo(a, l, t, n);
}
var RL = Ac.prototype.constructor;
function jL() {
  return new RL(this._groups, this._parents);
}
function DL(e, t) {
  var n, r, o;
  return function() {
    var a = ts(this, e), l = (this.style.removeProperty(e), ts(this, e));
    return a === l ? null : a === n && l === r ? o : o = t(n = a, r = l);
  };
}
function d3(e) {
  return function() {
    this.style.removeProperty(e);
  };
}
function TL(e, t, n) {
  var r, o = n + "", a;
  return function() {
    var l = ts(this, e);
    return l === o ? null : l === r ? a : a = t(r = l, n);
  };
}
function zL(e, t, n) {
  var r, o, a;
  return function() {
    var l = ts(this, e), u = n(this), d = u + "";
    return u == null && (d = u = (this.style.removeProperty(e), ts(this, e))), l === d ? null : l === r && d === o ? a : (o = d, a = t(r = l, u));
  };
}
function PL(e, t) {
  var n, r, o, a = "style." + t, l = "end." + a, u;
  return function() {
    var d = lo(this, e), f = d.on, p = d.value[a] == null ? u || (u = d3(t)) : void 0;
    (f !== n || o !== p) && (r = (n = f).copy()).on(l, o = p), d.on = r;
  };
}
function LL(e, t, n) {
  var r = (e += "") == "transform" ? L8 : c3;
  return t == null ? this.styleTween(e, DL(e, r)).on("end.style." + e, d3(e)) : typeof t == "function" ? this.styleTween(e, zL(e, r, fw(this, "style." + e, t))).each(PL(this._id, e)) : this.styleTween(e, TL(e, r, t), n).on("end.style." + e, null);
}
function IL(e, t, n) {
  return function(r) {
    this.style.setProperty(e, t.call(this, r), n);
  };
}
function BL(e, t, n) {
  var r, o;
  function a() {
    var l = t.apply(this, arguments);
    return l !== o && (r = (o = l) && IL(e, l, n)), r;
  }
  return a._value = t, a;
}
function VL(e, t, n) {
  var r = "style." + (e += "");
  if (arguments.length < 2) return (r = this.tween(r)) && r._value;
  if (t == null) return this.tween(r, null);
  if (typeof t != "function") throw new Error();
  return this.tween(r, BL(e, t, n ?? ""));
}
function HL(e) {
  return function() {
    this.textContent = e;
  };
}
function UL(e) {
  return function() {
    var t = e(this);
    this.textContent = t ?? "";
  };
}
function FL(e) {
  return this.tween("text", typeof e == "function" ? UL(fw(this, "text", e)) : HL(e == null ? "" : e + ""));
}
function $L(e) {
  return function(t) {
    this.textContent = e.call(this, t);
  };
}
function YL(e) {
  var t, n;
  function r() {
    var o = e.apply(this, arguments);
    return o !== n && (t = (n = o) && $L(o)), t;
  }
  return r._value = e, r;
}
function qL(e) {
  var t = "text";
  if (arguments.length < 1) return (t = this.tween(t)) && t._value;
  if (e == null) return this.tween(t, null);
  if (typeof e != "function") throw new Error();
  return this.tween(t, YL(e));
}
function XL() {
  for (var e = this._name, t = this._id, n = f3(), r = this._groups, o = r.length, a = 0; a < o; ++a)
    for (var l = r[a], u = l.length, d, f = 0; f < u; ++f)
      if (d = l[f]) {
        var p = Tr(d, t);
        ah(d, e, n, f, l, {
          time: p.time + p.delay + p.duration,
          delay: 0,
          duration: p.duration,
          ease: p.ease
        });
      }
  return new Fo(r, this._parents, e, n);
}
function GL() {
  var e, t, n = this, r = n._id, o = n.size();
  return new Promise(function(a, l) {
    var u = { value: l }, d = { value: function() {
      --o === 0 && a();
    } };
    n.each(function() {
      var f = lo(this, r), p = f.on;
      p !== e && (t = (e = p).copy(), t._.cancel.push(u), t._.interrupt.push(u), t._.end.push(d)), f.on = t;
    }), o === 0 && a();
  });
}
var ZL = 0;
function Fo(e, t, n, r) {
  this._groups = e, this._parents = t, this._name = n, this._id = r;
}
function f3() {
  return ++ZL;
}
var Do = Ac.prototype;
Fo.prototype = {
  constructor: Fo,
  select: ML,
  selectAll: AL,
  selectChild: Do.selectChild,
  selectChildren: Do.selectChildren,
  filter: SL,
  merge: kL,
  selection: jL,
  transition: XL,
  call: Do.call,
  nodes: Do.nodes,
  node: Do.node,
  size: Do.size,
  empty: Do.empty,
  each: Do.each,
  on: CL,
  attr: aL,
  attrTween: dL,
  style: LL,
  styleTween: VL,
  text: FL,
  textTween: qL,
  remove: NL,
  tween: J8,
  delay: hL,
  duration: yL,
  ease: bL,
  easeVarying: xL,
  end: GL,
  [Symbol.iterator]: Do[Symbol.iterator]
};
function WL(e) {
  return ((e *= 2) <= 1 ? e * e * e : (e -= 2) * e * e + 2) / 2;
}
var KL = {
  time: null,
  // Set on use.
  delay: 0,
  duration: 250,
  ease: WL
};
function QL(e, t) {
  for (var n; !(n = e.__transition) || !(n = n[t]); )
    if (!(e = e.parentNode))
      throw new Error(`transition ${t} not found`);
  return n;
}
function JL(e) {
  var t, n;
  e instanceof Fo ? (t = e._id, e = e._name) : (t = f3(), (n = KL).time = cw(), e = e == null ? null : e + "");
  for (var r = this._groups, o = r.length, a = 0; a < o; ++a)
    for (var l = r[a], u = l.length, d, f = 0; f < u; ++f)
      (d = l[f]) && ah(d, e, t, f, l, n || QL(d, t));
  return new Fo(r, this._parents, e, t);
}
Ac.prototype.interrupt = W8;
Ac.prototype.transition = JL;
const kf = (e) => () => e;
function e9(e, {
  sourceEvent: t,
  target: n,
  transform: r,
  dispatch: o
}) {
  Object.defineProperties(this, {
    type: { value: e, enumerable: !0, configurable: !0 },
    sourceEvent: { value: t, enumerable: !0, configurable: !0 },
    target: { value: n, enumerable: !0, configurable: !0 },
    transform: { value: r, enumerable: !0, configurable: !0 },
    _: { value: o }
  });
}
function Io(e, t, n) {
  this.k = e, this.x = t, this.y = n;
}
Io.prototype = {
  constructor: Io,
  scale: function(e) {
    return e === 1 ? this : new Io(this.k * e, this.x, this.y);
  },
  translate: function(e, t) {
    return e === 0 & t === 0 ? this : new Io(this.k, this.x + this.k * e, this.y + this.k * t);
  },
  apply: function(e) {
    return [e[0] * this.k + this.x, e[1] * this.k + this.y];
  },
  applyX: function(e) {
    return e * this.k + this.x;
  },
  applyY: function(e) {
    return e * this.k + this.y;
  },
  invert: function(e) {
    return [(e[0] - this.x) / this.k, (e[1] - this.y) / this.k];
  },
  invertX: function(e) {
    return (e - this.x) / this.k;
  },
  invertY: function(e) {
    return (e - this.y) / this.k;
  },
  rescaleX: function(e) {
    return e.copy().domain(e.range().map(this.invertX, this).map(e.invert, e));
  },
  rescaleY: function(e) {
    return e.copy().domain(e.range().map(this.invertY, this).map(e.invert, e));
  },
  toString: function() {
    return "translate(" + this.x + "," + this.y + ") scale(" + this.k + ")";
  }
};
var lh = new Io(1, 0, 0);
p3.prototype = Io.prototype;
function p3(e) {
  for (; !e.__zoom; ) if (!(e = e.parentNode)) return lh;
  return e.__zoom;
}
function Ry(e) {
  e.stopImmediatePropagation();
}
function Tu(e) {
  e.preventDefault(), e.stopImmediatePropagation();
}
function t9(e) {
  return (!e.ctrlKey || e.type === "wheel") && !e.button;
}
function n9() {
  var e = this;
  return e instanceof SVGElement ? (e = e.ownerSVGElement || e, e.hasAttribute("viewBox") ? (e = e.viewBox.baseVal, [[e.x, e.y], [e.x + e.width, e.y + e.height]]) : [[0, 0], [e.width.baseVal.value, e.height.baseVal.value]]) : [[0, 0], [e.clientWidth, e.clientHeight]];
}
function b0() {
  return this.__zoom || lh;
}
function r9(e) {
  return -e.deltaY * (e.deltaMode === 1 ? 0.05 : e.deltaMode ? 1 : 2e-3) * (e.ctrlKey ? 10 : 1);
}
function o9() {
  return navigator.maxTouchPoints || "ontouchstart" in this;
}
function i9(e, t, n) {
  var r = e.invertX(t[0][0]) - n[0][0], o = e.invertX(t[1][0]) - n[1][0], a = e.invertY(t[0][1]) - n[0][1], l = e.invertY(t[1][1]) - n[1][1];
  return e.translate(
    o > r ? (r + o) / 2 : Math.min(0, r) || Math.max(0, o),
    l > a ? (a + l) / 2 : Math.min(0, a) || Math.max(0, l)
  );
}
function h3() {
  var e = t9, t = n9, n = i9, r = r9, o = o9, a = [0, 1 / 0], l = [[-1 / 0, -1 / 0], [1 / 0, 1 / 0]], u = 250, d = U8, f = rh("start", "zoom", "end"), p, m, g, y = 500, w = 150, v = 0, x = 10;
  function E(z) {
    z.property("__zoom", b0).on("wheel.zoom", V, { passive: !1 }).on("mousedown.zoom", F).on("dblclick.zoom", O).filter(o).on("touchstart.zoom", B).on("touchmove.zoom", U).on("touchend.zoom touchcancel.zoom", G).style("-webkit-tap-highlight-color", "rgba(0,0,0,0)");
  }
  E.transform = function(z, $, L, H) {
    var q = z.selection ? z.selection() : z;
    q.property("__zoom", b0), z !== q ? R(z, $, L, H) : q.interrupt().each(function() {
      D(this, arguments).event(H).start().zoom(null, typeof $ == "function" ? $.apply(this, arguments) : $).end();
    });
  }, E.scaleBy = function(z, $, L, H) {
    E.scaleTo(z, function() {
      var q = this.__zoom.k, Y = typeof $ == "function" ? $.apply(this, arguments) : $;
      return q * Y;
    }, L, H);
  }, E.scaleTo = function(z, $, L, H) {
    E.transform(z, function() {
      var q = t.apply(this, arguments), Y = this.__zoom, M = L == null ? A(q) : typeof L == "function" ? L.apply(this, arguments) : L, X = Y.invert(M), Q = typeof $ == "function" ? $.apply(this, arguments) : $;
      return n(C(N(Y, Q), M, X), q, l);
    }, L, H);
  }, E.translateBy = function(z, $, L, H) {
    E.transform(z, function() {
      return n(this.__zoom.translate(
        typeof $ == "function" ? $.apply(this, arguments) : $,
        typeof L == "function" ? L.apply(this, arguments) : L
      ), t.apply(this, arguments), l);
    }, null, H);
  }, E.translateTo = function(z, $, L, H, q) {
    E.transform(z, function() {
      var Y = t.apply(this, arguments), M = this.__zoom, X = H == null ? A(Y) : typeof H == "function" ? H.apply(this, arguments) : H;
      return n(lh.translate(X[0], X[1]).scale(M.k).translate(
        typeof $ == "function" ? -$.apply(this, arguments) : -$,
        typeof L == "function" ? -L.apply(this, arguments) : -L
      ), Y, l);
    }, H, q);
  };
  function N(z, $) {
    return $ = Math.max(a[0], Math.min(a[1], $)), $ === z.k ? z : new Io($, z.x, z.y);
  }
  function C(z, $, L) {
    var H = $[0] - L[0] * z.k, q = $[1] - L[1] * z.k;
    return H === z.x && q === z.y ? z : new Io(z.k, H, q);
  }
  function A(z) {
    return [(+z[0][0] + +z[1][0]) / 2, (+z[0][1] + +z[1][1]) / 2];
  }
  function R(z, $, L, H) {
    z.on("start.zoom", function() {
      D(this, arguments).event(H).start();
    }).on("interrupt.zoom end.zoom", function() {
      D(this, arguments).event(H).end();
    }).tween("zoom", function() {
      var q = this, Y = arguments, M = D(q, Y).event(H), X = t.apply(q, Y), Q = L == null ? A(X) : typeof L == "function" ? L.apply(q, Y) : L, P = Math.max(X[1][0] - X[0][0], X[1][1] - X[0][1]), te = q.__zoom, ie = typeof $ == "function" ? $.apply(q, Y) : $, ae = d(te.invert(Q).concat(P / te.k), ie.invert(Q).concat(P / ie.k));
      return function(fe) {
        if (fe === 1) fe = ie;
        else {
          var he = ae(fe), ye = P / he[2];
          fe = new Io(ye, Q[0] - he[0] * ye, Q[1] - he[1] * ye);
        }
        M.zoom(null, fe);
      };
    });
  }
  function D(z, $, L) {
    return !L && z.__zooming || new T(z, $);
  }
  function T(z, $) {
    this.that = z, this.args = $, this.active = 0, this.sourceEvent = null, this.extent = t.apply(z, $), this.taps = 0;
  }
  T.prototype = {
    event: function(z) {
      return z && (this.sourceEvent = z), this;
    },
    start: function() {
      return ++this.active === 1 && (this.that.__zooming = this, this.emit("start")), this;
    },
    zoom: function(z, $) {
      return this.mouse && z !== "mouse" && (this.mouse[1] = $.invert(this.mouse[0])), this.touch0 && z !== "touch" && (this.touch0[1] = $.invert(this.touch0[0])), this.touch1 && z !== "touch" && (this.touch1[1] = $.invert(this.touch1[0])), this.that.__zoom = $, this.emit("zoom"), this;
    },
    end: function() {
      return --this.active === 0 && (delete this.that.__zooming, this.emit("end")), this;
    },
    emit: function(z) {
      var $ = Wn(this.that).datum();
      f.call(
        z,
        this.that,
        new e9(z, {
          sourceEvent: this.sourceEvent,
          target: E,
          transform: this.that.__zoom,
          dispatch: f
        }),
        $
      );
    }
  };
  function V(z, ...$) {
    if (!e.apply(this, arguments)) return;
    var L = D(this, $).event(z), H = this.__zoom, q = Math.max(a[0], Math.min(a[1], H.k * Math.pow(2, r.apply(this, arguments)))), Y = Cr(z);
    if (L.wheel)
      (L.mouse[0][0] !== Y[0] || L.mouse[0][1] !== Y[1]) && (L.mouse[1] = H.invert(L.mouse[0] = Y)), clearTimeout(L.wheel);
    else {
      if (H.k === q) return;
      L.mouse = [Y, H.invert(Y)], Jf(this), L.start();
    }
    Tu(z), L.wheel = setTimeout(M, w), L.zoom("mouse", n(C(N(H, q), L.mouse[0], L.mouse[1]), L.extent, l));
    function M() {
      L.wheel = null, L.end();
    }
  }
  function F(z, ...$) {
    if (g || !e.apply(this, arguments)) return;
    var L = z.currentTarget, H = D(this, $, !0).event(z), q = Wn(z.view).on("mousemove.zoom", Q, !0).on("mouseup.zoom", P, !0), Y = Cr(z, L), M = z.clientX, X = z.clientY;
    WO(z.view), Ry(z), H.mouse = [Y, this.__zoom.invert(Y)], Jf(this), H.start();
    function Q(te) {
      if (Tu(te), !H.moved) {
        var ie = te.clientX - M, ae = te.clientY - X;
        H.moved = ie * ie + ae * ae > v;
      }
      H.event(te).zoom("mouse", n(C(H.that.__zoom, H.mouse[0] = Cr(te, L), H.mouse[1]), H.extent, l));
    }
    function P(te) {
      q.on("mousemove.zoom mouseup.zoom", null), KO(te.view, H.moved), Tu(te), H.event(te).end();
    }
  }
  function O(z, ...$) {
    if (e.apply(this, arguments)) {
      var L = this.__zoom, H = Cr(z.changedTouches ? z.changedTouches[0] : z, this), q = L.invert(H), Y = L.k * (z.shiftKey ? 0.5 : 2), M = n(C(N(L, Y), H, q), t.apply(this, $), l);
      Tu(z), u > 0 ? Wn(this).transition().duration(u).call(R, M, H, z) : Wn(this).call(E.transform, M, H, z);
    }
  }
  function B(z, ...$) {
    if (e.apply(this, arguments)) {
      var L = z.touches, H = L.length, q = D(this, $, z.changedTouches.length === H).event(z), Y, M, X, Q;
      for (Ry(z), M = 0; M < H; ++M)
        X = L[M], Q = Cr(X, this), Q = [Q, this.__zoom.invert(Q), X.identifier], q.touch0 ? !q.touch1 && q.touch0[2] !== Q[2] && (q.touch1 = Q, q.taps = 0) : (q.touch0 = Q, Y = !0, q.taps = 1 + !!p);
      p && (p = clearTimeout(p)), Y && (q.taps < 2 && (m = Q[0], p = setTimeout(function() {
        p = null;
      }, y)), Jf(this), q.start());
    }
  }
  function U(z, ...$) {
    if (this.__zooming) {
      var L = D(this, $).event(z), H = z.changedTouches, q = H.length, Y, M, X, Q;
      for (Tu(z), Y = 0; Y < q; ++Y)
        M = H[Y], X = Cr(M, this), L.touch0 && L.touch0[2] === M.identifier ? L.touch0[0] = X : L.touch1 && L.touch1[2] === M.identifier && (L.touch1[0] = X);
      if (M = L.that.__zoom, L.touch1) {
        var P = L.touch0[0], te = L.touch0[1], ie = L.touch1[0], ae = L.touch1[1], fe = (fe = ie[0] - P[0]) * fe + (fe = ie[1] - P[1]) * fe, he = (he = ae[0] - te[0]) * he + (he = ae[1] - te[1]) * he;
        M = N(M, Math.sqrt(fe / he)), X = [(P[0] + ie[0]) / 2, (P[1] + ie[1]) / 2], Q = [(te[0] + ae[0]) / 2, (te[1] + ae[1]) / 2];
      } else if (L.touch0) X = L.touch0[0], Q = L.touch0[1];
      else return;
      L.zoom("touch", n(C(M, X, Q), L.extent, l));
    }
  }
  function G(z, ...$) {
    if (this.__zooming) {
      var L = D(this, $).event(z), H = z.changedTouches, q = H.length, Y, M;
      for (Ry(z), g && clearTimeout(g), g = setTimeout(function() {
        g = null;
      }, y), Y = 0; Y < q; ++Y)
        M = H[Y], L.touch0 && L.touch0[2] === M.identifier ? delete L.touch0 : L.touch1 && L.touch1[2] === M.identifier && delete L.touch1;
      if (L.touch1 && !L.touch0 && (L.touch0 = L.touch1, delete L.touch1), L.touch0) L.touch0[1] = this.__zoom.invert(L.touch0[0]);
      else if (L.end(), L.taps === 2 && (M = Cr(M, this), Math.hypot(m[0] - M[0], m[1] - M[1]) < x)) {
        var X = Wn(this).on("dblclick.zoom");
        X && X.apply(this, arguments);
      }
    }
  }
  return E.wheelDelta = function(z) {
    return arguments.length ? (r = typeof z == "function" ? z : kf(+z), E) : r;
  }, E.filter = function(z) {
    return arguments.length ? (e = typeof z == "function" ? z : kf(!!z), E) : e;
  }, E.touchable = function(z) {
    return arguments.length ? (o = typeof z == "function" ? z : kf(!!z), E) : o;
  }, E.extent = function(z) {
    return arguments.length ? (t = typeof z == "function" ? z : kf([[+z[0][0], +z[0][1]], [+z[1][0], +z[1][1]]]), E) : t;
  }, E.scaleExtent = function(z) {
    return arguments.length ? (a[0] = +z[0], a[1] = +z[1], E) : [a[0], a[1]];
  }, E.translateExtent = function(z) {
    return arguments.length ? (l[0][0] = +z[0][0], l[1][0] = +z[1][0], l[0][1] = +z[0][1], l[1][1] = +z[1][1], E) : [[l[0][0], l[0][1]], [l[1][0], l[1][1]]];
  }, E.constrain = function(z) {
    return arguments.length ? (n = z, E) : n;
  }, E.duration = function(z) {
    return arguments.length ? (u = +z, E) : u;
  }, E.interpolate = function(z) {
    return arguments.length ? (d = z, E) : d;
  }, E.on = function() {
    var z = f.on.apply(f, arguments);
    return z === f ? E : z;
  }, E.clickDistance = function(z) {
    return arguments.length ? (v = (z = +z) * z, E) : Math.sqrt(v);
  }, E.tapDistance = function(z) {
    return arguments.length ? (x = +z, E) : x;
  }, E;
}
const io = {
  error001: () => "[React Flow]: Seems like you have not used zustand provider as an ancestor. Help: https://reactflow.dev/error#001",
  error002: () => "It looks like you've created a new nodeTypes or edgeTypes object. If this wasn't on purpose please define the nodeTypes/edgeTypes outside of the component or memoize them.",
  error003: (e) => `Node type "${e}" not found. Using fallback type "default".`,
  error004: () => "The React Flow parent container needs a width and a height to render the graph.",
  error005: () => "Only child nodes can use a parent extent.",
  error006: () => "Can't create edge. An edge needs a source and a target.",
  error007: (e) => `The old edge with id=${e} does not exist.`,
  error009: (e) => `Marker type "${e}" doesn't exist.`,
  error008: (e, { id: t, sourceHandle: n, targetHandle: r }) => `Couldn't create edge for ${e} handle id: "${e === "source" ? n : r}", edge id: ${t}.`,
  error010: () => "Handle: No node id found. Make sure to only use a Handle inside a custom Node.",
  error011: (e) => `Edge type "${e}" not found. Using fallback type "default".`,
  error012: (e) => `Node with id "${e}" does not exist, it may have been removed. This can happen when a node is deleted before the "onNodeClick" handler is called.`,
  error013: (e = "react") => `It seems that you haven't loaded the styles. Please import '@xyflow/${e}/dist/style.css' or base.css to make sure everything is working properly.`,
  error014: () => "useNodeConnections: No node ID found. Call useNodeConnections inside a custom Node or provide a node ID.",
  error015: () => "It seems that you are trying to drag a node that is not initialized. Please use onNodesChange as explained in the docs."
}, uc = [
  [Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY],
  [Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY]
], m3 = ["Enter", " ", "Escape"];
var rs;
(function(e) {
  e.Strict = "strict", e.Loose = "loose";
})(rs || (rs = {}));
var Oa;
(function(e) {
  e.Free = "free", e.Vertical = "vertical", e.Horizontal = "horizontal";
})(Oa || (Oa = {}));
var cc;
(function(e) {
  e.Partial = "partial", e.Full = "full";
})(cc || (cc = {}));
const g3 = {
  inProgress: !1,
  isValid: null,
  from: null,
  fromHandle: null,
  fromPosition: null,
  fromNode: null,
  to: null,
  toHandle: null,
  toPosition: null,
  toNode: null
};
var zi;
(function(e) {
  e.Bezier = "default", e.Straight = "straight", e.Step = "step", e.SmoothStep = "smoothstep", e.SimpleBezier = "simplebezier";
})(zi || (zi = {}));
var Sp;
(function(e) {
  e.Arrow = "arrow", e.ArrowClosed = "arrowclosed";
})(Sp || (Sp = {}));
var Ce;
(function(e) {
  e.Left = "left", e.Top = "top", e.Right = "right", e.Bottom = "bottom";
})(Ce || (Ce = {}));
const w0 = {
  [Ce.Left]: Ce.Right,
  [Ce.Right]: Ce.Left,
  [Ce.Top]: Ce.Bottom,
  [Ce.Bottom]: Ce.Top
};
function y3(e) {
  return e === null ? null : e ? "valid" : "invalid";
}
const v3 = (e) => "id" in e && "source" in e && "target" in e, a9 = (e) => "id" in e && "position" in e && !("source" in e) && !("target" in e), pw = (e) => "id" in e && "internals" in e && !("source" in e) && !("target" in e), jc = (e, t = [0, 0]) => {
  const { width: n, height: r } = Zo(e), o = e.origin ?? t, a = n * o[0], l = r * o[1];
  return {
    x: e.position.x - a,
    y: e.position.y - l
  };
}, l9 = (e, t = { nodeOrigin: [0, 0] }) => {
  if (e.length === 0)
    return { x: 0, y: 0, width: 0, height: 0 };
  const n = e.reduce((r, o) => {
    const a = typeof o == "string";
    let l = !t.nodeLookup && !a ? o : void 0;
    t.nodeLookup && (l = a ? t.nodeLookup.get(o) : pw(o) ? o : t.nodeLookup.get(o.id));
    const u = l ? kp(l, t.nodeOrigin) : { x: 0, y: 0, x2: 0, y2: 0 };
    return sh(r, u);
  }, { x: 1 / 0, y: 1 / 0, x2: -1 / 0, y2: -1 / 0 });
  return uh(n);
}, Dc = (e, t = {}) => {
  if (e.size === 0)
    return { x: 0, y: 0, width: 0, height: 0 };
  let n = { x: 1 / 0, y: 1 / 0, x2: -1 / 0, y2: -1 / 0 };
  return e.forEach((r) => {
    if (t.filter === void 0 || t.filter(r)) {
      const o = kp(r);
      n = sh(n, o);
    }
  }), uh(n);
}, b3 = (e, t, [n, r, o] = [0, 0, 1], a = !1, l = !1) => {
  const u = {
    ...Tc(t, [n, r, o]),
    width: t.width / o,
    height: t.height / o
  }, d = [];
  for (const f of e.values()) {
    const { measured: p, selectable: m = !0, hidden: g = !1 } = f;
    if (l && !m || g)
      continue;
    const y = p.width ?? f.width ?? f.initialWidth ?? null, w = p.height ?? f.height ?? f.initialHeight ?? null, v = dc(u, is(f)), x = (y ?? 0) * (w ?? 0), E = a && v > 0;
    (!f.internals.handleBounds || E || v >= x || f.dragging) && d.push(f);
  }
  return d;
}, s9 = (e, t) => {
  const n = /* @__PURE__ */ new Set();
  return e.forEach((r) => {
    n.add(r.id);
  }), t.filter((r) => n.has(r.source) || n.has(r.target));
};
function u9(e, t) {
  const n = /* @__PURE__ */ new Map(), r = t != null && t.nodes ? new Set(t.nodes.map((o) => o.id)) : null;
  return e.forEach((o) => {
    o.measured.width && o.measured.height && (t?.includeHiddenNodes || !o.hidden) && (!r || r.has(o.id)) && n.set(o.id, o);
  }), n;
}
async function c9({ nodes: e, width: t, height: n, panZoom: r, minZoom: o, maxZoom: a }, l) {
  if (e.size === 0)
    return Promise.resolve(!0);
  const u = u9(e, l), d = Dc(u), f = hw(d, t, n, l?.minZoom ?? o, l?.maxZoom ?? a, l?.padding ?? 0.1);
  return await r.setViewport(f, { duration: l?.duration }), Promise.resolve(!0);
}
function w3({ nodeId: e, nextPosition: t, nodeLookup: n, nodeOrigin: r = [0, 0], nodeExtent: o, onError: a }) {
  const l = n.get(e), u = l.parentId ? n.get(l.parentId) : void 0, { x: d, y: f } = u ? u.internals.positionAbsolute : { x: 0, y: 0 }, p = l.origin ?? r;
  let m = o;
  if (l.extent === "parent" && !l.expandParent)
    if (!u)
      a?.("005", io.error005());
    else {
      const y = u.measured.width, w = u.measured.height;
      y && w && (m = [
        [d, f],
        [d + y, f + w]
      ]);
    }
  else u && as(l.extent) && (m = [
    [l.extent[0][0] + d, l.extent[0][1] + f],
    [l.extent[1][0] + d, l.extent[1][1] + f]
  ]);
  const g = as(m) ? Aa(t, m, l.measured) : t;
  return (l.measured.width === void 0 || l.measured.height === void 0) && a?.("015", io.error015()), {
    position: {
      x: g.x - d + (l.measured.width ?? 0) * p[0],
      y: g.y - f + (l.measured.height ?? 0) * p[1]
    },
    positionAbsolute: g
  };
}
async function d9({ nodesToRemove: e = [], edgesToRemove: t = [], nodes: n, edges: r, onBeforeDelete: o }) {
  const a = new Set(e.map((m) => m.id)), l = [];
  for (const m of n) {
    if (m.deletable === !1)
      continue;
    const g = a.has(m.id), y = !g && m.parentId && l.find((w) => w.id === m.parentId);
    (g || y) && l.push(m);
  }
  const u = new Set(t.map((m) => m.id)), d = r.filter((m) => m.deletable !== !1), f = s9(l, d);
  for (const m of d)
    u.has(m.id) && !f.find((g) => g.id === m.id) && f.push(m);
  if (!o)
    return {
      edges: f,
      nodes: l
    };
  const p = await o({
    nodes: l,
    edges: f
  });
  return typeof p == "boolean" ? p ? { edges: f, nodes: l } : { edges: [], nodes: [] } : p;
}
const os = (e, t = 0, n = 1) => Math.min(Math.max(e, t), n), Aa = (e = { x: 0, y: 0 }, t, n) => ({
  x: os(e.x, t[0][0], t[1][0] - (n?.width ?? 0)),
  y: os(e.y, t[0][1], t[1][1] - (n?.height ?? 0))
});
function x3(e, t, n) {
  const { width: r, height: o } = Zo(n), { x: a, y: l } = n.internals.positionAbsolute;
  return Aa(e, [
    [a, l],
    [a + r, l + o]
  ], t);
}
const x0 = (e, t, n) => e < t ? os(Math.abs(e - t), 1, t) / t : e > n ? -os(Math.abs(e - n), 1, t) / t : 0, S3 = (e, t, n = 15, r = 40) => {
  const o = x0(e.x, r, t.width - r) * n, a = x0(e.y, r, t.height - r) * n;
  return [o, a];
}, sh = (e, t) => ({
  x: Math.min(e.x, t.x),
  y: Math.min(e.y, t.y),
  x2: Math.max(e.x2, t.x2),
  y2: Math.max(e.y2, t.y2)
}), $v = ({ x: e, y: t, width: n, height: r }) => ({
  x: e,
  y: t,
  x2: e + n,
  y2: t + r
}), uh = ({ x: e, y: t, x2: n, y2: r }) => ({
  x: e,
  y: t,
  width: n - e,
  height: r - t
}), is = (e, t = [0, 0]) => {
  var n, r;
  const { x: o, y: a } = pw(e) ? e.internals.positionAbsolute : jc(e, t);
  return {
    x: o,
    y: a,
    width: ((n = e.measured) == null ? void 0 : n.width) ?? e.width ?? e.initialWidth ?? 0,
    height: ((r = e.measured) == null ? void 0 : r.height) ?? e.height ?? e.initialHeight ?? 0
  };
}, kp = (e, t = [0, 0]) => {
  var n, r;
  const { x: o, y: a } = pw(e) ? e.internals.positionAbsolute : jc(e, t);
  return {
    x: o,
    y: a,
    x2: o + (((n = e.measured) == null ? void 0 : n.width) ?? e.width ?? e.initialWidth ?? 0),
    y2: a + (((r = e.measured) == null ? void 0 : r.height) ?? e.height ?? e.initialHeight ?? 0)
  };
}, k3 = (e, t) => uh(sh($v(e), $v(t))), dc = (e, t) => {
  const n = Math.max(0, Math.min(e.x + e.width, t.x + t.width) - Math.max(e.x, t.x)), r = Math.max(0, Math.min(e.y + e.height, t.y + t.height) - Math.max(e.y, t.y));
  return Math.ceil(n * r);
}, S0 = (e) => Ar(e.width) && Ar(e.height) && Ar(e.x) && Ar(e.y), Ar = (e) => !isNaN(e) && isFinite(e), f9 = (e, t) => {
}, ch = (e, t = [1, 1]) => ({
  x: t[0] * Math.round(e.x / t[0]),
  y: t[1] * Math.round(e.y / t[1])
}), Tc = ({ x: e, y: t }, [n, r, o], a = !1, l = [1, 1]) => {
  const u = {
    x: (e - n) / o,
    y: (t - r) / o
  };
  return a ? ch(u, l) : u;
}, _p = ({ x: e, y: t }, [n, r, o]) => ({
  x: e * o + n,
  y: t * o + r
});
function Ol(e, t) {
  if (typeof e == "number")
    return Math.floor(t - t / (1 + e));
  if (typeof e == "string" && e.endsWith("px")) {
    const n = parseFloat(e);
    if (!Number.isNaN(n))
      return Math.floor(n);
  }
  if (typeof e == "string" && e.endsWith("%")) {
    const n = parseFloat(e);
    if (!Number.isNaN(n))
      return Math.floor(t * n * 0.01);
  }
  return console.error(`[React Flow] The padding value "${e}" is invalid. Please provide a number or a string with a valid unit (px or %).`), 0;
}
function p9(e, t, n) {
  if (typeof e == "string" || typeof e == "number") {
    const r = Ol(e, n), o = Ol(e, t);
    return {
      top: r,
      right: o,
      bottom: r,
      left: o,
      x: o * 2,
      y: r * 2
    };
  }
  if (typeof e == "object") {
    const r = Ol(e.top ?? e.y ?? 0, n), o = Ol(e.bottom ?? e.y ?? 0, n), a = Ol(e.left ?? e.x ?? 0, t), l = Ol(e.right ?? e.x ?? 0, t);
    return { top: r, right: l, bottom: o, left: a, x: a + l, y: r + o };
  }
  return { top: 0, right: 0, bottom: 0, left: 0, x: 0, y: 0 };
}
function h9(e, t, n, r, o, a) {
  const { x: l, y: u } = _p(e, [t, n, r]), { x: d, y: f } = _p({ x: e.x + e.width, y: e.y + e.height }, [t, n, r]), p = o - d, m = a - f;
  return {
    left: Math.floor(l),
    top: Math.floor(u),
    right: Math.floor(p),
    bottom: Math.floor(m)
  };
}
const hw = (e, t, n, r, o, a) => {
  const l = p9(a, t, n), u = (t - l.x) / e.width, d = (n - l.y) / e.height, f = Math.min(u, d), p = os(f, r, o), m = e.x + e.width / 2, g = e.y + e.height / 2, y = t / 2 - m * p, w = n / 2 - g * p, v = h9(e, y, w, p, t, n), x = {
    left: Math.min(v.left - l.left, 0),
    top: Math.min(v.top - l.top, 0),
    right: Math.min(v.right - l.right, 0),
    bottom: Math.min(v.bottom - l.bottom, 0)
  };
  return {
    x: y - x.left + x.right,
    y: w - x.top + x.bottom,
    zoom: p
  };
}, Ep = () => {
  var e;
  return typeof navigator < "u" && ((e = navigator?.userAgent) == null ? void 0 : e.indexOf("Mac")) >= 0;
};
function as(e) {
  return e !== void 0 && e !== "parent";
}
function Zo(e) {
  var t, n;
  return {
    width: ((t = e.measured) == null ? void 0 : t.width) ?? e.width ?? e.initialWidth ?? 0,
    height: ((n = e.measured) == null ? void 0 : n.height) ?? e.height ?? e.initialHeight ?? 0
  };
}
function _3(e) {
  var t, n;
  return (((t = e.measured) == null ? void 0 : t.width) ?? e.width ?? e.initialWidth) !== void 0 && (((n = e.measured) == null ? void 0 : n.height) ?? e.height ?? e.initialHeight) !== void 0;
}
function E3(e, t = { width: 0, height: 0 }, n, r, o) {
  const a = { ...e }, l = r.get(n);
  if (l) {
    const u = l.origin || o;
    a.x += l.internals.positionAbsolute.x - (t.width ?? 0) * u[0], a.y += l.internals.positionAbsolute.y - (t.height ?? 0) * u[1];
  }
  return a;
}
function k0(e, t) {
  if (e.size !== t.size)
    return !1;
  for (const n of e)
    if (!t.has(n))
      return !1;
  return !0;
}
function Wu(e, { snapGrid: t = [0, 0], snapToGrid: n = !1, transform: r, containerBounds: o }) {
  const { x: a, y: l } = Bo(e), u = Tc({ x: a - (o?.left ?? 0), y: l - (o?.top ?? 0) }, r), { x: d, y: f } = n ? ch(u, t) : u;
  return {
    xSnapped: d,
    ySnapped: f,
    ...u
  };
}
const mw = (e) => ({
  width: e.offsetWidth,
  height: e.offsetHeight
}), C3 = (e) => {
  var t;
  return ((t = e?.getRootNode) == null ? void 0 : t.call(e)) || window?.document;
}, m9 = ["INPUT", "SELECT", "TEXTAREA"];
function O3(e) {
  var t, n;
  const r = ((n = (t = e.composedPath) == null ? void 0 : t.call(e)) == null ? void 0 : n[0]) || e.target;
  return r?.nodeType !== 1 ? !1 : m9.includes(r.nodeName) || r.hasAttribute("contenteditable") || !!r.closest(".nokey");
}
const N3 = (e) => "clientX" in e, Bo = (e, t) => {
  var n, r;
  const o = N3(e), a = o ? e.clientX : (n = e.touches) == null ? void 0 : n[0].clientX, l = o ? e.clientY : (r = e.touches) == null ? void 0 : r[0].clientY;
  return {
    x: a - (t?.left ?? 0),
    y: l - (t?.top ?? 0)
  };
}, _0 = (e, t, n, r, o) => {
  const a = t.querySelectorAll(`.${e}`);
  return !a || !a.length ? null : Array.from(a).map((l) => {
    const u = l.getBoundingClientRect();
    return {
      id: l.getAttribute("data-handleid"),
      type: e,
      nodeId: o,
      position: l.getAttribute("data-handlepos"),
      x: (u.left - n.left) / r,
      y: (u.top - n.top) / r,
      ...mw(l)
    };
  });
};
function M3({ sourceX: e, sourceY: t, targetX: n, targetY: r, sourceControlX: o, sourceControlY: a, targetControlX: l, targetControlY: u }) {
  const d = e * 0.125 + o * 0.375 + l * 0.375 + n * 0.125, f = t * 0.125 + a * 0.375 + u * 0.375 + r * 0.125, p = Math.abs(d - e), m = Math.abs(f - t);
  return [d, f, p, m];
}
function _f(e, t) {
  return e >= 0 ? 0.5 * e : t * 25 * Math.sqrt(-e);
}
function E0({ pos: e, x1: t, y1: n, x2: r, y2: o, c: a }) {
  switch (e) {
    case Ce.Left:
      return [t - _f(t - r, a), n];
    case Ce.Right:
      return [t + _f(r - t, a), n];
    case Ce.Top:
      return [t, n - _f(n - o, a)];
    case Ce.Bottom:
      return [t, n + _f(o - n, a)];
  }
}
function gw({ sourceX: e, sourceY: t, sourcePosition: n = Ce.Bottom, targetX: r, targetY: o, targetPosition: a = Ce.Top, curvature: l = 0.25 }) {
  const [u, d] = E0({
    pos: n,
    x1: e,
    y1: t,
    x2: r,
    y2: o,
    c: l
  }), [f, p] = E0({
    pos: a,
    x1: r,
    y1: o,
    x2: e,
    y2: t,
    c: l
  }), [m, g, y, w] = M3({
    sourceX: e,
    sourceY: t,
    targetX: r,
    targetY: o,
    sourceControlX: u,
    sourceControlY: d,
    targetControlX: f,
    targetControlY: p
  });
  return [
    `M${e},${t} C${u},${d} ${f},${p} ${r},${o}`,
    m,
    g,
    y,
    w
  ];
}
function A3({ sourceX: e, sourceY: t, targetX: n, targetY: r }) {
  const o = Math.abs(n - e) / 2, a = n < e ? n + o : n - o, l = Math.abs(r - t) / 2, u = r < t ? r + l : r - l;
  return [a, u, o, l];
}
function g9({ sourceNode: e, targetNode: t, selected: n = !1, zIndex: r = 0, elevateOnSelect: o = !1 }) {
  if (!o)
    return r;
  const a = n || t.selected || e.selected, l = Math.max(e.internals.z || 0, t.internals.z || 0, 1e3);
  return r + (a ? l : 0);
}
function y9({ sourceNode: e, targetNode: t, width: n, height: r, transform: o }) {
  const a = sh(kp(e), kp(t));
  a.x === a.x2 && (a.x2 += 1), a.y === a.y2 && (a.y2 += 1);
  const l = {
    x: -o[0] / o[2],
    y: -o[1] / o[2],
    width: n / o[2],
    height: r / o[2]
  };
  return dc(l, uh(a)) > 0;
}
const v9 = ({ source: e, sourceHandle: t, target: n, targetHandle: r }) => `xy-edge__${e}${t || ""}-${n}${r || ""}`, b9 = (e, t) => t.some((n) => n.source === e.source && n.target === e.target && (n.sourceHandle === e.sourceHandle || !n.sourceHandle && !e.sourceHandle) && (n.targetHandle === e.targetHandle || !n.targetHandle && !e.targetHandle)), w9 = (e, t) => {
  if (!e.source || !e.target)
    return t;
  let n;
  return v3(e) ? n = { ...e } : n = {
    ...e,
    id: v9(e)
  }, b9(n, t) ? t : (n.sourceHandle === null && delete n.sourceHandle, n.targetHandle === null && delete n.targetHandle, t.concat(n));
};
function R3({ sourceX: e, sourceY: t, targetX: n, targetY: r }) {
  const [o, a, l, u] = A3({
    sourceX: e,
    sourceY: t,
    targetX: n,
    targetY: r
  });
  return [`M ${e},${t}L ${n},${r}`, o, a, l, u];
}
const C0 = {
  [Ce.Left]: { x: -1, y: 0 },
  [Ce.Right]: { x: 1, y: 0 },
  [Ce.Top]: { x: 0, y: -1 },
  [Ce.Bottom]: { x: 0, y: 1 }
}, x9 = ({ source: e, sourcePosition: t = Ce.Bottom, target: n }) => t === Ce.Left || t === Ce.Right ? e.x < n.x ? { x: 1, y: 0 } : { x: -1, y: 0 } : e.y < n.y ? { x: 0, y: 1 } : { x: 0, y: -1 }, O0 = (e, t) => Math.sqrt(Math.pow(t.x - e.x, 2) + Math.pow(t.y - e.y, 2));
function S9({ source: e, sourcePosition: t = Ce.Bottom, target: n, targetPosition: r = Ce.Top, center: o, offset: a }) {
  const l = C0[t], u = C0[r], d = { x: e.x + l.x * a, y: e.y + l.y * a }, f = { x: n.x + u.x * a, y: n.y + u.y * a }, p = x9({
    source: d,
    sourcePosition: t,
    target: f
  }), m = p.x !== 0 ? "x" : "y", g = p[m];
  let y = [], w, v;
  const x = { x: 0, y: 0 }, E = { x: 0, y: 0 }, [N, C, A, R] = A3({
    sourceX: e.x,
    sourceY: e.y,
    targetX: n.x,
    targetY: n.y
  });
  if (l[m] * u[m] === -1) {
    w = o.x ?? N, v = o.y ?? C;
    const D = [
      { x: w, y: d.y },
      { x: w, y: f.y }
    ], T = [
      { x: d.x, y: v },
      { x: f.x, y: v }
    ];
    l[m] === g ? y = m === "x" ? D : T : y = m === "x" ? T : D;
  } else {
    const D = [{ x: d.x, y: f.y }], T = [{ x: f.x, y: d.y }];
    if (m === "x" ? y = l.x === g ? T : D : y = l.y === g ? D : T, t === r) {
      const U = Math.abs(e[m] - n[m]);
      if (U <= a) {
        const G = Math.min(a - 1, a - U);
        l[m] === g ? x[m] = (d[m] > e[m] ? -1 : 1) * G : E[m] = (f[m] > n[m] ? -1 : 1) * G;
      }
    }
    if (t !== r) {
      const U = m === "x" ? "y" : "x", G = l[m] === u[U], z = d[U] > f[U], $ = d[U] < f[U];
      (l[m] === 1 && (!G && z || G && $) || l[m] !== 1 && (!G && $ || G && z)) && (y = m === "x" ? D : T);
    }
    const V = { x: d.x + x.x, y: d.y + x.y }, F = { x: f.x + E.x, y: f.y + E.y }, O = Math.max(Math.abs(V.x - y[0].x), Math.abs(F.x - y[0].x)), B = Math.max(Math.abs(V.y - y[0].y), Math.abs(F.y - y[0].y));
    O >= B ? (w = (V.x + F.x) / 2, v = y[0].y) : (w = y[0].x, v = (V.y + F.y) / 2);
  }
  return [[
    e,
    { x: d.x + x.x, y: d.y + x.y },
    ...y,
    { x: f.x + E.x, y: f.y + E.y },
    n
  ], w, v, A, R];
}
function k9(e, t, n, r) {
  const o = Math.min(O0(e, t) / 2, O0(t, n) / 2, r), { x: a, y: l } = t;
  if (e.x === a && a === n.x || e.y === l && l === n.y)
    return `L${a} ${l}`;
  if (e.y === l) {
    const f = e.x < n.x ? -1 : 1, p = e.y < n.y ? 1 : -1;
    return `L ${a + o * f},${l}Q ${a},${l} ${a},${l + o * p}`;
  }
  const u = e.x < n.x ? 1 : -1, d = e.y < n.y ? -1 : 1;
  return `L ${a},${l + o * d}Q ${a},${l} ${a + o * u},${l}`;
}
function Yv({ sourceX: e, sourceY: t, sourcePosition: n = Ce.Bottom, targetX: r, targetY: o, targetPosition: a = Ce.Top, borderRadius: l = 5, centerX: u, centerY: d, offset: f = 20 }) {
  const [p, m, g, y, w] = S9({
    source: { x: e, y: t },
    sourcePosition: n,
    target: { x: r, y: o },
    targetPosition: a,
    center: { x: u, y: d },
    offset: f
  });
  return [p.reduce((v, x, E) => {
    let N = "";
    return E > 0 && E < p.length - 1 ? N = k9(p[E - 1], x, p[E + 1], l) : N = `${E === 0 ? "M" : "L"}${x.x} ${x.y}`, v += N, v;
  }, ""), m, g, y, w];
}
function N0(e) {
  var t;
  return e && !!(e.internals.handleBounds || (t = e.handles) != null && t.length) && !!(e.measured.width || e.width || e.initialWidth);
}
function _9(e) {
  var t;
  const { sourceNode: n, targetNode: r } = e;
  if (!N0(n) || !N0(r))
    return null;
  const o = n.internals.handleBounds || M0(n.handles), a = r.internals.handleBounds || M0(r.handles), l = A0(o?.source ?? [], e.sourceHandle), u = A0(
    // when connection type is loose we can define all handles as sources and connect source -> source
    e.connectionMode === rs.Strict ? a?.target ?? [] : (a?.target ?? []).concat(a?.source ?? []),
    e.targetHandle
  );
  if (!l || !u)
    return (t = e.onError) == null || t.call(e, "008", io.error008(l ? "target" : "source", {
      id: e.id,
      sourceHandle: e.sourceHandle,
      targetHandle: e.targetHandle
    })), null;
  const d = l?.position || Ce.Bottom, f = u?.position || Ce.Top, p = fc(n, l, d), m = fc(r, u, f);
  return {
    sourceX: p.x,
    sourceY: p.y,
    targetX: m.x,
    targetY: m.y,
    sourcePosition: d,
    targetPosition: f
  };
}
function M0(e) {
  if (!e)
    return null;
  const t = [], n = [];
  for (const r of e)
    r.width = r.width ?? 1, r.height = r.height ?? 1, r.type === "source" ? t.push(r) : r.type === "target" && n.push(r);
  return {
    source: t,
    target: n
  };
}
function fc(e, t, n = Ce.Left, r = !1) {
  const o = (t?.x ?? 0) + e.internals.positionAbsolute.x, a = (t?.y ?? 0) + e.internals.positionAbsolute.y, { width: l, height: u } = t ?? Zo(e);
  if (r)
    return { x: o + l / 2, y: a + u / 2 };
  switch (t?.position ?? n) {
    case Ce.Top:
      return { x: o + l / 2, y: a };
    case Ce.Right:
      return { x: o + l, y: a + u / 2 };
    case Ce.Bottom:
      return { x: o + l / 2, y: a + u };
    case Ce.Left:
      return { x: o, y: a + u / 2 };
  }
}
function A0(e, t) {
  return e && (t ? e.find((n) => n.id === t) : e[0]) || null;
}
function qv(e, t) {
  return e ? typeof e == "string" ? e : `${t ? `${t}__` : ""}${Object.keys(e).sort().map((n) => `${n}=${e[n]}`).join("&")}` : "";
}
function E9(e, { id: t, defaultColor: n, defaultMarkerStart: r, defaultMarkerEnd: o }) {
  const a = /* @__PURE__ */ new Set();
  return e.reduce((l, u) => ([u.markerStart || r, u.markerEnd || o].forEach((d) => {
    if (d && typeof d == "object") {
      const f = qv(d, t);
      a.has(f) || (l.push({ id: f, color: d.color || n, ...d }), a.add(f));
    }
  }), l), []).sort((l, u) => l.id.localeCompare(u.id));
}
const yw = {
  nodeOrigin: [0, 0],
  nodeExtent: uc,
  elevateNodesOnSelect: !0,
  defaults: {}
}, C9 = {
  ...yw,
  checkEquality: !0
};
function vw(e, t) {
  const n = { ...e };
  for (const r in t)
    t[r] !== void 0 && (n[r] = t[r]);
  return n;
}
function O9(e, t, n) {
  const r = vw(yw, n);
  for (const o of e.values())
    if (o.parentId)
      bw(o, e, t, r);
    else {
      const a = jc(o, r.nodeOrigin), l = as(o.extent) ? o.extent : r.nodeExtent, u = Aa(a, l, Zo(o));
      o.internals.positionAbsolute = u;
    }
}
function Xv(e, t, n, r) {
  var o, a;
  const l = vw(C9, r);
  let u = !0;
  const d = new Map(t), f = l != null && l.elevateNodesOnSelect ? 1e3 : 0;
  t.clear(), n.clear();
  for (const p of e) {
    let m = d.get(p.id);
    if (l.checkEquality && p === m?.internals.userNode)
      t.set(p.id, m);
    else {
      const g = jc(p, l.nodeOrigin), y = as(p.extent) ? p.extent : l.nodeExtent, w = Aa(g, y, Zo(p));
      m = {
        ...l.defaults,
        ...p,
        measured: {
          width: (o = p.measured) == null ? void 0 : o.width,
          height: (a = p.measured) == null ? void 0 : a.height
        },
        internals: {
          positionAbsolute: w,
          // if user re-initializes the node or removes `measured` for whatever reason, we reset the handleBounds so that the node gets re-measured
          handleBounds: p.measured ? m?.internals.handleBounds : void 0,
          z: j3(p, f),
          userNode: p
        }
      }, t.set(p.id, m);
    }
    (!m.measured || !m.measured.width || !m.measured.height) && !m.hidden && (u = !1), p.parentId && bw(m, t, n, r);
  }
  return u;
}
function N9(e, t) {
  if (!e.parentId)
    return;
  const n = t.get(e.parentId);
  n ? n.set(e.id, e) : t.set(e.parentId, /* @__PURE__ */ new Map([[e.id, e]]));
}
function bw(e, t, n, r) {
  const { elevateNodesOnSelect: o, nodeOrigin: a, nodeExtent: l } = vw(yw, r), u = e.parentId, d = t.get(u);
  if (!d) {
    console.warn(`Parent node ${u} not found. Please make sure that parent nodes are in front of their child nodes in the nodes array.`);
    return;
  }
  N9(e, n);
  const f = o ? 1e3 : 0, { x: p, y: m, z: g } = M9(e, d, a, l, f), { positionAbsolute: y } = e.internals, w = p !== y.x || m !== y.y;
  (w || g !== e.internals.z) && t.set(e.id, {
    ...e,
    internals: {
      ...e.internals,
      positionAbsolute: w ? { x: p, y: m } : y,
      z: g
    }
  });
}
function j3(e, t) {
  return (Ar(e.zIndex) ? e.zIndex : 0) + (e.selected ? t : 0);
}
function M9(e, t, n, r, o) {
  const { x: a, y: l } = t.internals.positionAbsolute, u = Zo(e), d = jc(e, n), f = as(e.extent) ? Aa(d, e.extent, u) : d;
  let p = Aa({ x: a + f.x, y: l + f.y }, r, u);
  e.extent === "parent" && (p = x3(p, u, t));
  const m = j3(e, o), g = t.internals.z ?? 0;
  return {
    x: p.x,
    y: p.y,
    z: g > m ? g : m
  };
}
function ww(e, t, n, r = [0, 0]) {
  var o;
  const a = [], l = /* @__PURE__ */ new Map();
  for (const u of e) {
    const d = t.get(u.parentId);
    if (!d)
      continue;
    const f = ((o = l.get(u.parentId)) == null ? void 0 : o.expandedRect) ?? is(d), p = k3(f, u.rect);
    l.set(u.parentId, { expandedRect: p, parent: d });
  }
  return l.size > 0 && l.forEach(({ expandedRect: u, parent: d }, f) => {
    var p;
    const m = d.internals.positionAbsolute, g = Zo(d), y = d.origin ?? r, w = u.x < m.x ? Math.round(Math.abs(m.x - u.x)) : 0, v = u.y < m.y ? Math.round(Math.abs(m.y - u.y)) : 0, x = Math.max(g.width, Math.round(u.width)), E = Math.max(g.height, Math.round(u.height)), N = (x - g.width) * y[0], C = (E - g.height) * y[1];
    (w > 0 || v > 0 || N || C) && (a.push({
      id: f,
      type: "position",
      position: {
        x: d.position.x - w + N,
        y: d.position.y - v + C
      }
    }), (p = n.get(f)) == null || p.forEach((A) => {
      e.some((R) => R.id === A.id) || a.push({
        id: A.id,
        type: "position",
        position: {
          x: A.position.x + w,
          y: A.position.y + v
        }
      });
    })), (g.width < u.width || g.height < u.height || w || v) && a.push({
      id: f,
      type: "dimensions",
      setAttributes: !0,
      dimensions: {
        width: x + (w ? y[0] * w - N : 0),
        height: E + (v ? y[1] * v - C : 0)
      }
    });
  }), a;
}
function A9(e, t, n, r, o, a) {
  const l = r?.querySelector(".xyflow__viewport");
  let u = !1;
  if (!l)
    return { changes: [], updatedInternals: u };
  const d = [], f = window.getComputedStyle(l), { m22: p } = new window.DOMMatrixReadOnly(f.transform), m = [];
  for (const g of e.values()) {
    const y = t.get(g.id);
    if (!y)
      continue;
    if (y.hidden) {
      t.set(y.id, {
        ...y,
        internals: {
          ...y.internals,
          handleBounds: void 0
        }
      }), u = !0;
      continue;
    }
    const w = mw(g.nodeElement), v = y.measured.width !== w.width || y.measured.height !== w.height;
    if (w.width && w.height && (v || !y.internals.handleBounds || g.force)) {
      const x = g.nodeElement.getBoundingClientRect(), E = as(y.extent) ? y.extent : a;
      let { positionAbsolute: N } = y.internals;
      y.parentId && y.extent === "parent" ? N = x3(N, w, t.get(y.parentId)) : E && (N = Aa(N, E, w));
      const C = {
        ...y,
        measured: w,
        internals: {
          ...y.internals,
          positionAbsolute: N,
          handleBounds: {
            source: _0("source", g.nodeElement, x, p, y.id),
            target: _0("target", g.nodeElement, x, p, y.id)
          }
        }
      };
      t.set(y.id, C), y.parentId && bw(C, t, n, { nodeOrigin: o }), u = !0, v && (d.push({
        id: y.id,
        type: "dimensions",
        dimensions: w
      }), y.expandParent && y.parentId && m.push({
        id: y.id,
        parentId: y.parentId,
        rect: is(C, o)
      }));
    }
  }
  if (m.length > 0) {
    const g = ww(m, t, n, o);
    d.push(...g);
  }
  return { changes: d, updatedInternals: u };
}
async function R9({ delta: e, panZoom: t, transform: n, translateExtent: r, width: o, height: a }) {
  if (!t || !e.x && !e.y)
    return Promise.resolve(!1);
  const l = await t.setViewportConstrained({
    x: n[0] + e.x,
    y: n[1] + e.y,
    zoom: n[2]
  }, [
    [0, 0],
    [o, a]
  ], r), u = !!l && (l.x !== n[0] || l.y !== n[1] || l.k !== n[2]);
  return Promise.resolve(u);
}
function R0(e, t, n, r, o, a) {
  let l = o;
  const u = r.get(l) || /* @__PURE__ */ new Map();
  r.set(l, u.set(n, t)), l = `${o}-${e}`;
  const d = r.get(l) || /* @__PURE__ */ new Map();
  if (r.set(l, d.set(n, t)), a) {
    l = `${o}-${e}-${a}`;
    const f = r.get(l) || /* @__PURE__ */ new Map();
    r.set(l, f.set(n, t));
  }
}
function D3(e, t, n) {
  e.clear(), t.clear();
  for (const r of n) {
    const { source: o, target: a, sourceHandle: l = null, targetHandle: u = null } = r, d = { edgeId: r.id, source: o, target: a, sourceHandle: l, targetHandle: u }, f = `${o}-${l}--${a}-${u}`, p = `${a}-${u}--${o}-${l}`;
    R0("source", d, p, e, o, l), R0("target", d, f, e, a, u), t.set(r.id, r);
  }
}
function T3(e, t) {
  if (!e.parentId)
    return !1;
  const n = t.get(e.parentId);
  return n ? n.selected ? !0 : T3(n, t) : !1;
}
function j0(e, t, n) {
  var r;
  let o = e;
  do {
    if ((r = o?.matches) != null && r.call(o, t))
      return !0;
    if (o === n)
      return !1;
    o = o?.parentElement;
  } while (o);
  return !1;
}
function j9(e, t, n, r) {
  const o = /* @__PURE__ */ new Map();
  for (const [a, l] of e)
    if ((l.selected || l.id === r) && (!l.parentId || !T3(l, e)) && (l.draggable || t && typeof l.draggable > "u")) {
      const u = e.get(a);
      u && o.set(a, {
        id: a,
        position: u.position || { x: 0, y: 0 },
        distance: {
          x: n.x - u.internals.positionAbsolute.x,
          y: n.y - u.internals.positionAbsolute.y
        },
        extent: u.extent,
        parentId: u.parentId,
        origin: u.origin,
        expandParent: u.expandParent,
        internals: {
          positionAbsolute: u.internals.positionAbsolute || { x: 0, y: 0 }
        },
        measured: {
          width: u.measured.width ?? 0,
          height: u.measured.height ?? 0
        }
      });
    }
  return o;
}
function jy({ nodeId: e, dragItems: t, nodeLookup: n, dragging: r = !0 }) {
  var o, a, l;
  const u = [];
  for (const [f, p] of t) {
    const m = (o = n.get(f)) == null ? void 0 : o.internals.userNode;
    m && u.push({
      ...m,
      position: p.position,
      dragging: r
    });
  }
  if (!e)
    return [u[0], u];
  const d = (a = n.get(e)) == null ? void 0 : a.internals.userNode;
  return [
    d ? {
      ...d,
      position: ((l = t.get(e)) == null ? void 0 : l.position) || d.position,
      dragging: r
    } : u[0],
    u
  ];
}
function D9({ onNodeMouseDown: e, getStoreItems: t, onDragStart: n, onDrag: r, onDragStop: o }) {
  let a = { x: null, y: null }, l = 0, u = /* @__PURE__ */ new Map(), d = !1, f = { x: 0, y: 0 }, p = null, m = !1, g = null, y = !1;
  function w({ noDragClassName: x, handleSelector: E, domNode: N, isSelectable: C, nodeId: A, nodeClickDistance: R = 0 }) {
    g = Wn(N);
    function D({ x: O, y: B }, U) {
      const { nodeLookup: G, nodeExtent: z, snapGrid: $, snapToGrid: L, nodeOrigin: H, onNodeDrag: q, onSelectionDrag: Y, onError: M, updateNodePositions: X } = t();
      a = { x: O, y: B };
      let Q = !1, P = { x: 0, y: 0, x2: 0, y2: 0 };
      if (u.size > 1 && z) {
        const te = Dc(u);
        P = $v(te);
      }
      for (const [te, ie] of u) {
        if (!G.has(te))
          continue;
        let ae = { x: O - ie.distance.x, y: B - ie.distance.y };
        L && (ae = ch(ae, $));
        let fe = [
          [z[0][0], z[0][1]],
          [z[1][0], z[1][1]]
        ];
        if (u.size > 1 && z && !ie.extent) {
          const { positionAbsolute: Ee } = ie.internals, we = Ee.x - P.x + z[0][0], xe = Ee.x + ie.measured.width - P.x2 + z[1][0], Pe = Ee.y - P.y + z[0][1], Ve = Ee.y + ie.measured.height - P.y2 + z[1][1];
          fe = [
            [we, Pe],
            [xe, Ve]
          ];
        }
        const { position: he, positionAbsolute: ye } = w3({
          nodeId: te,
          nextPosition: ae,
          nodeLookup: G,
          nodeExtent: fe,
          nodeOrigin: H,
          onError: M
        });
        Q = Q || ie.position.x !== he.x || ie.position.y !== he.y, ie.position = he, ie.internals.positionAbsolute = ye;
      }
      if (Q && (X(u, !0), U && (r || q || !A && Y))) {
        const [te, ie] = jy({
          nodeId: A,
          dragItems: u,
          nodeLookup: G
        });
        r?.(U, u, te, ie), q?.(U, te, ie), A || Y == null || Y(U, ie);
      }
    }
    async function T() {
      if (!p)
        return;
      const { transform: O, panBy: B, autoPanSpeed: U, autoPanOnNodeDrag: G } = t();
      if (!G) {
        d = !1, cancelAnimationFrame(l);
        return;
      }
      const [z, $] = S3(f, p, U);
      (z !== 0 || $ !== 0) && (a.x = (a.x ?? 0) - z / O[2], a.y = (a.y ?? 0) - $ / O[2], await B({ x: z, y: $ }) && D(a, null)), l = requestAnimationFrame(T);
    }
    function V(O) {
      var B;
      const { nodeLookup: U, multiSelectionActive: G, nodesDraggable: z, transform: $, snapGrid: L, snapToGrid: H, selectNodesOnDrag: q, onNodeDragStart: Y, onSelectionDragStart: M, unselectNodesAndEdges: X } = t();
      m = !0, (!q || !C) && !G && A && ((B = U.get(A)) != null && B.selected || X()), C && q && A && e?.(A);
      const Q = Wu(O.sourceEvent, { transform: $, snapGrid: L, snapToGrid: H, containerBounds: p });
      if (a = Q, u = j9(U, z, Q, A), u.size > 0 && (n || Y || !A && M)) {
        const [P, te] = jy({
          nodeId: A,
          dragItems: u,
          nodeLookup: U
        });
        n?.(O.sourceEvent, u, P, te), Y?.(O.sourceEvent, P, te), A || M == null || M(O.sourceEvent, te);
      }
    }
    const F = QO().clickDistance(R).on("start", (O) => {
      const { domNode: B, nodeDragThreshold: U, transform: G, snapGrid: z, snapToGrid: $ } = t();
      p = B?.getBoundingClientRect() || null, y = !1, U === 0 && V(O), a = Wu(O.sourceEvent, { transform: G, snapGrid: z, snapToGrid: $, containerBounds: p }), f = Bo(O.sourceEvent, p);
    }).on("drag", (O) => {
      const { autoPanOnNodeDrag: B, transform: U, snapGrid: G, snapToGrid: z, nodeDragThreshold: $, nodeLookup: L } = t(), H = Wu(O.sourceEvent, { transform: U, snapGrid: G, snapToGrid: z, containerBounds: p });
      if ((O.sourceEvent.type === "touchmove" && O.sourceEvent.touches.length > 1 || // if user deletes a node while dragging, we need to abort the drag to prevent errors
      A && !L.has(A)) && (y = !0), !y) {
        if (!d && B && m && (d = !0, T()), !m) {
          const q = H.xSnapped - (a.x ?? 0), Y = H.ySnapped - (a.y ?? 0);
          Math.sqrt(q * q + Y * Y) > $ && V(O);
        }
        (a.x !== H.xSnapped || a.y !== H.ySnapped) && u && m && (f = Bo(O.sourceEvent, p), D(H, O.sourceEvent));
      }
    }).on("end", (O) => {
      if (!(!m || y) && (d = !1, m = !1, cancelAnimationFrame(l), u.size > 0)) {
        const { nodeLookup: B, updateNodePositions: U, onNodeDragStop: G, onSelectionDragStop: z } = t();
        if (U(u, !1), o || G || !A && z) {
          const [$, L] = jy({
            nodeId: A,
            dragItems: u,
            nodeLookup: B,
            dragging: !1
          });
          o?.(O.sourceEvent, u, $, L), G?.(O.sourceEvent, $, L), A || z == null || z(O.sourceEvent, L);
        }
      }
    }).filter((O) => {
      const B = O.target;
      return !O.button && (!x || !j0(B, `.${x}`, N)) && (!E || j0(B, E, N));
    });
    g.call(F);
  }
  function v() {
    g?.on(".drag", null);
  }
  return {
    update: w,
    destroy: v
  };
}
function T9(e, t, n) {
  const r = [], o = {
    x: e.x - n,
    y: e.y - n,
    width: n * 2,
    height: n * 2
  };
  for (const a of t.values())
    dc(o, is(a)) > 0 && r.push(a);
  return r;
}
const z9 = 250;
function P9(e, t, n, r) {
  var o, a;
  let l = [], u = 1 / 0;
  const d = T9(e, n, t + z9);
  for (const f of d) {
    const p = [...((o = f.internals.handleBounds) == null ? void 0 : o.source) ?? [], ...((a = f.internals.handleBounds) == null ? void 0 : a.target) ?? []];
    for (const m of p) {
      if (r.nodeId === m.nodeId && r.type === m.type && r.id === m.id)
        continue;
      const { x: g, y } = fc(f, m, m.position, !0), w = Math.sqrt(Math.pow(g - e.x, 2) + Math.pow(y - e.y, 2));
      w > t || (w < u ? (l = [{ ...m, x: g, y }], u = w) : w === u && l.push({ ...m, x: g, y }));
    }
  }
  if (!l.length)
    return null;
  if (l.length > 1) {
    const f = r.type === "source" ? "target" : "source";
    return l.find((p) => p.type === f) ?? l[0];
  }
  return l[0];
}
function z3(e, t, n, r, o, a = !1) {
  var l, u, d;
  const f = r.get(e);
  if (!f)
    return null;
  const p = o === "strict" ? (l = f.internals.handleBounds) == null ? void 0 : l[t] : [...((u = f.internals.handleBounds) == null ? void 0 : u.source) ?? [], ...((d = f.internals.handleBounds) == null ? void 0 : d.target) ?? []], m = (n ? p?.find((g) => g.id === n) : p?.[0]) ?? null;
  return m && a ? { ...m, ...fc(f, m, m.position, !0) } : m;
}
function P3(e, t) {
  return e || (t != null && t.classList.contains("target") ? "target" : t != null && t.classList.contains("source") ? "source" : null);
}
function L9(e, t) {
  let n = null;
  return t ? n = !0 : e && !t && (n = !1), n;
}
const L3 = () => !0;
function I9(e, { connectionMode: t, connectionRadius: n, handleId: r, nodeId: o, edgeUpdaterType: a, isTarget: l, domNode: u, nodeLookup: d, lib: f, autoPanOnConnect: p, flowId: m, panBy: g, cancelConnection: y, onConnectStart: w, onConnect: v, onConnectEnd: x, isValidConnection: E = L3, onReconnectEnd: N, updateConnection: C, getTransform: A, getFromHandle: R, autoPanSpeed: D }) {
  const T = C3(e.target);
  let V = 0, F;
  const { x: O, y: B } = Bo(e), U = T?.elementFromPoint(O, B), G = P3(a, U), z = u?.getBoundingClientRect();
  if (!z || !G)
    return;
  const $ = z3(o, G, r, d, t);
  if (!$)
    return;
  let L = Bo(e, z), H = !1, q = null, Y = !1, M = null;
  function X() {
    if (!p || !z)
      return;
    const [he, ye] = S3(L, z, D);
    g({ x: he, y: ye }), V = requestAnimationFrame(X);
  }
  const Q = {
    ...$,
    nodeId: o,
    type: G,
    position: $.position
  }, P = d.get(o), te = {
    inProgress: !0,
    isValid: null,
    from: fc(P, Q, Ce.Left, !0),
    fromHandle: Q,
    fromPosition: Q.position,
    fromNode: P,
    to: L,
    toHandle: null,
    toPosition: w0[Q.position],
    toNode: null
  };
  C(te);
  let ie = te;
  w?.(e, { nodeId: o, handleId: r, handleType: G });
  function ae(he) {
    if (!R() || !Q) {
      fe(he);
      return;
    }
    const ye = A();
    L = Bo(he, z), F = P9(Tc(L, ye, !1, [1, 1]), n, d, Q), H || (X(), H = !0);
    const Ee = I3(he, {
      handle: F,
      connectionMode: t,
      fromNodeId: o,
      fromHandleId: r,
      fromType: l ? "target" : "source",
      isValidConnection: E,
      doc: T,
      lib: f,
      flowId: m,
      nodeLookup: d
    });
    M = Ee.handleDomNode, q = Ee.connection, Y = L9(!!F, Ee.isValid);
    const we = {
      // from stays the same
      ...ie,
      isValid: Y,
      to: F && Y ? _p({ x: F.x, y: F.y }, ye) : L,
      toHandle: Ee.toHandle,
      toPosition: Y && Ee.toHandle ? Ee.toHandle.position : w0[Q.position],
      toNode: Ee.toHandle ? d.get(Ee.toHandle.nodeId) : null
    };
    Y && F && ie.toHandle && we.toHandle && ie.toHandle.type === we.toHandle.type && ie.toHandle.nodeId === we.toHandle.nodeId && ie.toHandle.id === we.toHandle.id && ie.to.x === we.to.x && ie.to.y === we.to.y || (C(we), ie = we);
  }
  function fe(he) {
    (F || M) && q && Y && v?.(q);
    const { inProgress: ye, ...Ee } = ie, we = {
      ...Ee,
      toPosition: ie.toHandle ? ie.toPosition : null
    };
    x?.(he, we), a && N?.(he, we), y(), cancelAnimationFrame(V), H = !1, Y = !1, q = null, M = null, T.removeEventListener("mousemove", ae), T.removeEventListener("mouseup", fe), T.removeEventListener("touchmove", ae), T.removeEventListener("touchend", fe);
  }
  T.addEventListener("mousemove", ae), T.addEventListener("mouseup", fe), T.addEventListener("touchmove", ae), T.addEventListener("touchend", fe);
}
function I3(e, { handle: t, connectionMode: n, fromNodeId: r, fromHandleId: o, fromType: a, doc: l, lib: u, flowId: d, isValidConnection: f = L3, nodeLookup: p }) {
  const m = a === "target", g = t ? l.querySelector(`.${u}-flow__handle[data-id="${d}-${t?.nodeId}-${t?.id}-${t?.type}"]`) : null, { x: y, y: w } = Bo(e), v = l.elementFromPoint(y, w), x = v != null && v.classList.contains(`${u}-flow__handle`) ? v : g, E = {
    handleDomNode: x,
    isValid: !1,
    connection: null,
    toHandle: null
  };
  if (x) {
    const N = P3(void 0, x), C = x.getAttribute("data-nodeid"), A = x.getAttribute("data-handleid"), R = x.classList.contains("connectable"), D = x.classList.contains("connectableend");
    if (!C || !N)
      return E;
    const T = {
      source: m ? C : r,
      sourceHandle: m ? A : o,
      target: m ? r : C,
      targetHandle: m ? o : A
    };
    E.connection = T;
    const V = R && D && (n === rs.Strict ? m && N === "source" || !m && N === "target" : C !== r || A !== o);
    E.isValid = V && f(T), E.toHandle = z3(C, N, A, p, n, !1);
  }
  return E;
}
const Gv = {
  onPointerDown: I9,
  isValid: I3
};
function B9({ domNode: e, panZoom: t, getTransform: n, getViewScale: r }) {
  const o = Wn(e);
  function a({ translateExtent: u, width: d, height: f, zoomStep: p = 10, pannable: m = !0, zoomable: g = !0, inversePan: y = !1 }) {
    const w = (C) => {
      const A = n();
      if (C.sourceEvent.type !== "wheel" || !t)
        return;
      const R = -C.sourceEvent.deltaY * (C.sourceEvent.deltaMode === 1 ? 0.05 : C.sourceEvent.deltaMode ? 1 : 2e-3) * p, D = A[2] * Math.pow(2, R);
      t.scaleTo(D);
    };
    let v = [0, 0];
    const x = (C) => {
      (C.sourceEvent.type === "mousedown" || C.sourceEvent.type === "touchstart") && (v = [
        C.sourceEvent.clientX ?? C.sourceEvent.touches[0].clientX,
        C.sourceEvent.clientY ?? C.sourceEvent.touches[0].clientY
      ]);
    }, E = (C) => {
      const A = n();
      if (C.sourceEvent.type !== "mousemove" && C.sourceEvent.type !== "touchmove" || !t)
        return;
      const R = [
        C.sourceEvent.clientX ?? C.sourceEvent.touches[0].clientX,
        C.sourceEvent.clientY ?? C.sourceEvent.touches[0].clientY
      ], D = [R[0] - v[0], R[1] - v[1]];
      v = R;
      const T = r() * Math.max(A[2], Math.log(A[2])) * (y ? -1 : 1), V = {
        x: A[0] - D[0] * T,
        y: A[1] - D[1] * T
      }, F = [
        [0, 0],
        [d, f]
      ];
      t.setViewportConstrained({
        x: V.x,
        y: V.y,
        zoom: A[2]
      }, F, u);
    }, N = h3().on("start", x).on("zoom", m ? E : null).on("zoom.wheel", g ? w : null);
    o.call(N, {});
  }
  function l() {
    o.on("zoom", null);
  }
  return {
    update: a,
    destroy: l,
    pointer: Cr
  };
}
const V9 = (e, t) => e.x !== t.x || e.y !== t.y || e.zoom !== t.k, dh = (e) => ({
  x: e.x,
  y: e.y,
  zoom: e.k
}), Dy = ({ x: e, y: t, zoom: n }) => lh.translate(e, t).scale(n), Ul = (e, t) => e.target.closest(`.${t}`), B3 = (e, t) => t === 2 && Array.isArray(e) && e.includes(2), Ty = (e, t = 0, n = () => {
}) => {
  const r = typeof t == "number" && t > 0;
  return r || n(), r ? e.transition().duration(t).on("end", n) : e;
}, V3 = (e) => {
  const t = e.ctrlKey && Ep() ? 10 : 1;
  return -e.deltaY * (e.deltaMode === 1 ? 0.05 : e.deltaMode ? 1 : 2e-3) * t;
};
function H9({ zoomPanValues: e, noWheelClassName: t, d3Selection: n, d3Zoom: r, panOnScrollMode: o, panOnScrollSpeed: a, zoomOnPinch: l, onPanZoomStart: u, onPanZoom: d, onPanZoomEnd: f }) {
  return (p) => {
    if (Ul(p, t))
      return !1;
    p.preventDefault(), p.stopImmediatePropagation();
    const m = n.property("__zoom").k || 1;
    if (p.ctrlKey && l) {
      const x = Cr(p), E = V3(p), N = m * Math.pow(2, E);
      r.scaleTo(n, N, x, p);
      return;
    }
    const g = p.deltaMode === 1 ? 20 : 1;
    let y = o === Oa.Vertical ? 0 : p.deltaX * g, w = o === Oa.Horizontal ? 0 : p.deltaY * g;
    !Ep() && p.shiftKey && o !== Oa.Vertical && (y = p.deltaY * g, w = 0), r.translateBy(
      n,
      -(y / m) * a,
      -(w / m) * a,
      // @ts-ignore
      { internal: !0 }
    );
    const v = dh(n.property("__zoom"));
    clearTimeout(e.panScrollTimeout), e.isPanScrolling || (e.isPanScrolling = !0, u?.(p, v)), e.isPanScrolling && (d?.(p, v), e.panScrollTimeout = setTimeout(() => {
      f?.(p, v), e.isPanScrolling = !1;
    }, 150));
  };
}
function U9({ noWheelClassName: e, preventScrolling: t, d3ZoomHandler: n }) {
  return function(r, o) {
    const a = r.type === "wheel", l = !t && a && !r.ctrlKey, u = Ul(r, e);
    if (r.ctrlKey && a && u && r.preventDefault(), l || u)
      return null;
    r.preventDefault(), n.call(this, r, o);
  };
}
function F9({ zoomPanValues: e, onDraggingChange: t, onPanZoomStart: n }) {
  return (r) => {
    var o, a, l;
    if ((o = r.sourceEvent) != null && o.internal)
      return;
    const u = dh(r.transform);
    e.mouseButton = ((a = r.sourceEvent) == null ? void 0 : a.button) || 0, e.isZoomingOrPanning = !0, e.prevViewport = u, ((l = r.sourceEvent) == null ? void 0 : l.type) === "mousedown" && t(!0), n && n?.(r.sourceEvent, u);
  };
}
function $9({ zoomPanValues: e, panOnDrag: t, onPaneContextMenu: n, onTransformChange: r, onPanZoom: o }) {
  return (a) => {
    var l, u;
    e.usedRightMouseButton = !!(n && B3(t, e.mouseButton ?? 0)), (l = a.sourceEvent) != null && l.sync || r([a.transform.x, a.transform.y, a.transform.k]), o && !((u = a.sourceEvent) != null && u.internal) && o?.(a.sourceEvent, dh(a.transform));
  };
}
function Y9({ zoomPanValues: e, panOnDrag: t, panOnScroll: n, onDraggingChange: r, onPanZoomEnd: o, onPaneContextMenu: a }) {
  return (l) => {
    var u;
    if (!((u = l.sourceEvent) != null && u.internal) && (e.isZoomingOrPanning = !1, a && B3(t, e.mouseButton ?? 0) && !e.usedRightMouseButton && l.sourceEvent && a(l.sourceEvent), e.usedRightMouseButton = !1, r(!1), o && V9(e.prevViewport, l.transform))) {
      const d = dh(l.transform);
      e.prevViewport = d, clearTimeout(e.timerId), e.timerId = setTimeout(
        () => {
          o?.(l.sourceEvent, d);
        },
        // we need a setTimeout for panOnScroll to supress multiple end events fired during scroll
        n ? 150 : 0
      );
    }
  };
}
function q9({ zoomActivationKeyPressed: e, zoomOnScroll: t, zoomOnPinch: n, panOnDrag: r, panOnScroll: o, zoomOnDoubleClick: a, userSelectionActive: l, noWheelClassName: u, noPanClassName: d, lib: f }) {
  return (p) => {
    var m;
    const g = e || t, y = n && p.ctrlKey;
    if (p.button === 1 && p.type === "mousedown" && (Ul(p, `${f}-flow__node`) || Ul(p, `${f}-flow__edge`)))
      return !0;
    if (!r && !g && !o && !a && !n || l || Ul(p, u) && p.type === "wheel" || Ul(p, d) && (p.type !== "wheel" || o && p.type === "wheel" && !e) || !n && p.ctrlKey && p.type === "wheel")
      return !1;
    if (!n && p.type === "touchstart" && ((m = p.touches) == null ? void 0 : m.length) > 1)
      return p.preventDefault(), !1;
    if (!g && !o && !y && p.type === "wheel" || !r && (p.type === "mousedown" || p.type === "touchstart") || Array.isArray(r) && !r.includes(p.button) && p.type === "mousedown")
      return !1;
    const w = Array.isArray(r) && r.includes(p.button) || !p.button || p.button <= 1;
    return (!p.ctrlKey || p.type === "wheel") && w;
  };
}
function X9({ domNode: e, minZoom: t, maxZoom: n, paneClickDistance: r, translateExtent: o, viewport: a, onPanZoom: l, onPanZoomStart: u, onPanZoomEnd: d, onDraggingChange: f }) {
  const p = {
    isZoomingOrPanning: !1,
    usedRightMouseButton: !1,
    prevViewport: { x: 0, y: 0, zoom: 0 },
    mouseButton: 0,
    timerId: void 0,
    panScrollTimeout: void 0,
    isPanScrolling: !1
  }, m = e.getBoundingClientRect(), g = h3().clickDistance(!Ar(r) || r < 0 ? 0 : r).scaleExtent([t, n]).translateExtent(o), y = Wn(e).call(g);
  C({
    x: a.x,
    y: a.y,
    zoom: os(a.zoom, t, n)
  }, [
    [0, 0],
    [m.width, m.height]
  ], o);
  const w = y.on("wheel.zoom"), v = y.on("dblclick.zoom");
  g.wheelDelta(V3);
  function x(U, G) {
    return y ? new Promise((z) => {
      g?.transform(Ty(y, G?.duration, () => z(!0)), U);
    }) : Promise.resolve(!1);
  }
  function E({ noWheelClassName: U, noPanClassName: G, onPaneContextMenu: z, userSelectionActive: $, panOnScroll: L, panOnDrag: H, panOnScrollMode: q, panOnScrollSpeed: Y, preventScrolling: M, zoomOnPinch: X, zoomOnScroll: Q, zoomOnDoubleClick: P, zoomActivationKeyPressed: te, lib: ie, onTransformChange: ae }) {
    $ && !p.isZoomingOrPanning && N();
    const fe = L && !te && !$ ? H9({
      zoomPanValues: p,
      noWheelClassName: U,
      d3Selection: y,
      d3Zoom: g,
      panOnScrollMode: q,
      panOnScrollSpeed: Y,
      zoomOnPinch: X,
      onPanZoomStart: u,
      onPanZoom: l,
      onPanZoomEnd: d
    }) : U9({
      noWheelClassName: U,
      preventScrolling: M,
      d3ZoomHandler: w
    });
    if (y.on("wheel.zoom", fe, { passive: !1 }), !$) {
      const ye = F9({
        zoomPanValues: p,
        onDraggingChange: f,
        onPanZoomStart: u
      });
      g.on("start", ye);
      const Ee = $9({
        zoomPanValues: p,
        panOnDrag: H,
        onPaneContextMenu: !!z,
        onPanZoom: l,
        onTransformChange: ae
      });
      g.on("zoom", Ee);
      const we = Y9({
        zoomPanValues: p,
        panOnDrag: H,
        panOnScroll: L,
        onPaneContextMenu: z,
        onPanZoomEnd: d,
        onDraggingChange: f
      });
      g.on("end", we);
    }
    const he = q9({
      zoomActivationKeyPressed: te,
      panOnDrag: H,
      zoomOnScroll: Q,
      panOnScroll: L,
      zoomOnDoubleClick: P,
      zoomOnPinch: X,
      userSelectionActive: $,
      noPanClassName: G,
      noWheelClassName: U,
      lib: ie
    });
    g.filter(he), P ? y.on("dblclick.zoom", v) : y.on("dblclick.zoom", null);
  }
  function N() {
    g.on("zoom", null);
  }
  async function C(U, G, z) {
    const $ = Dy(U), L = g?.constrain()($, G, z);
    return L && await x(L), new Promise((H) => H(L));
  }
  async function A(U, G) {
    const z = Dy(U);
    return await x(z, G), new Promise(($) => $(z));
  }
  function R(U) {
    if (y) {
      const G = Dy(U), z = y.property("__zoom");
      (z.k !== U.zoom || z.x !== U.x || z.y !== U.y) && g?.transform(y, G, null, { sync: !0 });
    }
  }
  function D() {
    const U = y ? p3(y.node()) : { x: 0, y: 0, k: 1 };
    return { x: U.x, y: U.y, zoom: U.k };
  }
  function T(U, G) {
    return y ? new Promise((z) => {
      g?.scaleTo(Ty(y, G?.duration, () => z(!0)), U);
    }) : Promise.resolve(!1);
  }
  function V(U, G) {
    return y ? new Promise((z) => {
      g?.scaleBy(Ty(y, G?.duration, () => z(!0)), U);
    }) : Promise.resolve(!1);
  }
  function F(U) {
    g?.scaleExtent(U);
  }
  function O(U) {
    g?.translateExtent(U);
  }
  function B(U) {
    const G = !Ar(U) || U < 0 ? 0 : U;
    g?.clickDistance(G);
  }
  return {
    update: E,
    destroy: N,
    setViewport: A,
    setViewportConstrained: C,
    getViewport: D,
    scaleTo: T,
    scaleBy: V,
    setScaleExtent: F,
    setTranslateExtent: O,
    syncViewport: R,
    setClickDistance: B
  };
}
var Ku;
(function(e) {
  e.Line = "line", e.Handle = "handle";
})(Ku || (Ku = {}));
function G9({ width: e, prevWidth: t, height: n, prevHeight: r, affectsX: o, affectsY: a }) {
  const l = e - t, u = n - r, d = [l > 0 ? 1 : l < 0 ? -1 : 0, u > 0 ? 1 : u < 0 ? -1 : 0];
  return l && o && (d[0] = d[0] * -1), u && a && (d[1] = d[1] * -1), d;
}
function Z9(e) {
  const t = e.includes("right") || e.includes("left"), n = e.includes("bottom") || e.includes("top"), r = e.includes("left"), o = e.includes("top");
  return {
    isHorizontal: t,
    isVertical: n,
    affectsX: r,
    affectsY: o
  };
}
function Mi(e, t) {
  return Math.max(0, t - e);
}
function Ai(e, t) {
  return Math.max(0, e - t);
}
function Ef(e, t, n) {
  return Math.max(0, t - e, e - n);
}
function D0(e, t) {
  return e ? !t : t;
}
function W9(e, t, n, r, o, a, l, u) {
  let { affectsX: d, affectsY: f } = t;
  const { isHorizontal: p, isVertical: m } = t, g = p && m, { xSnapped: y, ySnapped: w } = n, { minWidth: v, maxWidth: x, minHeight: E, maxHeight: N } = r, { x: C, y: A, width: R, height: D, aspectRatio: T } = e;
  let V = Math.floor(p ? y - e.pointerX : 0), F = Math.floor(m ? w - e.pointerY : 0);
  const O = R + (d ? -V : V), B = D + (f ? -F : F), U = -a[0] * R, G = -a[1] * D;
  let z = Ef(O, v, x), $ = Ef(B, E, N);
  if (l) {
    let q = 0, Y = 0;
    d && V < 0 ? q = Mi(C + V + U, l[0][0]) : !d && V > 0 && (q = Ai(C + O + U, l[1][0])), f && F < 0 ? Y = Mi(A + F + G, l[0][1]) : !f && F > 0 && (Y = Ai(A + B + G, l[1][1])), z = Math.max(z, q), $ = Math.max($, Y);
  }
  if (u) {
    let q = 0, Y = 0;
    d && V > 0 ? q = Ai(C + V, u[0][0]) : !d && V < 0 && (q = Mi(C + O, u[1][0])), f && F > 0 ? Y = Ai(A + F, u[0][1]) : !f && F < 0 && (Y = Mi(A + B, u[1][1])), z = Math.max(z, q), $ = Math.max($, Y);
  }
  if (o) {
    if (p) {
      const q = Ef(O / T, E, N) * T;
      if (z = Math.max(z, q), l) {
        let Y = 0;
        !d && !f || d && !f && g ? Y = Ai(A + G + O / T, l[1][1]) * T : Y = Mi(A + G + (d ? V : -V) / T, l[0][1]) * T, z = Math.max(z, Y);
      }
      if (u) {
        let Y = 0;
        !d && !f || d && !f && g ? Y = Mi(A + O / T, u[1][1]) * T : Y = Ai(A + (d ? V : -V) / T, u[0][1]) * T, z = Math.max(z, Y);
      }
    }
    if (m) {
      const q = Ef(B * T, v, x) / T;
      if ($ = Math.max($, q), l) {
        let Y = 0;
        !d && !f || f && !d && g ? Y = Ai(C + B * T + U, l[1][0]) / T : Y = Mi(C + (f ? F : -F) * T + U, l[0][0]) / T, $ = Math.max($, Y);
      }
      if (u) {
        let Y = 0;
        !d && !f || f && !d && g ? Y = Mi(C + B * T, u[1][0]) / T : Y = Ai(C + (f ? F : -F) * T, u[0][0]) / T, $ = Math.max($, Y);
      }
    }
  }
  F = F + (F < 0 ? $ : -$), V = V + (V < 0 ? z : -z), o && (g ? O > B * T ? F = (D0(d, f) ? -V : V) / T : V = (D0(d, f) ? -F : F) * T : p ? (F = V / T, f = d) : (V = F * T, d = f));
  const L = d ? C + V : C, H = f ? A + F : A;
  return {
    width: R + (d ? -V : V),
    height: D + (f ? -F : F),
    x: a[0] * V * (d ? -1 : 1) + L,
    y: a[1] * F * (f ? -1 : 1) + H
  };
}
const H3 = { width: 0, height: 0, x: 0, y: 0 }, K9 = {
  ...H3,
  pointerX: 0,
  pointerY: 0,
  aspectRatio: 1
};
function Q9(e) {
  return [
    [0, 0],
    [e.measured.width, e.measured.height]
  ];
}
function J9(e, t, n) {
  const r = t.position.x + e.position.x, o = t.position.y + e.position.y, a = e.measured.width ?? 0, l = e.measured.height ?? 0, u = n[0] * a, d = n[1] * l;
  return [
    [r - u, o - d],
    [r + a - u, o + l - d]
  ];
}
function e7({ domNode: e, nodeId: t, getStoreItems: n, onChange: r, onEnd: o }) {
  const a = Wn(e);
  function l({ controlPosition: d, boundaries: f, keepAspectRatio: p, onResizeStart: m, onResize: g, onResizeEnd: y, shouldResize: w }) {
    let v = { ...H3 }, x = { ...K9 };
    const E = Z9(d);
    let N, C = null, A = [], R, D, T;
    const V = QO().on("start", (F) => {
      const { nodeLookup: O, transform: B, snapGrid: U, snapToGrid: G, nodeOrigin: z, paneDomNode: $ } = n();
      if (N = O.get(t), !N)
        return;
      C = $?.getBoundingClientRect() ?? null;
      const { xSnapped: L, ySnapped: H } = Wu(F.sourceEvent, {
        transform: B,
        snapGrid: U,
        snapToGrid: G,
        containerBounds: C
      });
      v = {
        width: N.measured.width ?? 0,
        height: N.measured.height ?? 0,
        x: N.position.x ?? 0,
        y: N.position.y ?? 0
      }, x = {
        ...v,
        pointerX: L,
        pointerY: H,
        aspectRatio: v.width / v.height
      }, R = void 0, N.parentId && (N.extent === "parent" || N.expandParent) && (R = O.get(N.parentId), D = R && N.extent === "parent" ? Q9(R) : void 0), A = [], T = void 0;
      for (const [q, Y] of O)
        if (Y.parentId === t && (A.push({
          id: q,
          position: { ...Y.position },
          extent: Y.extent
        }), Y.extent === "parent" || Y.expandParent)) {
          const M = J9(Y, N, Y.origin ?? z);
          T ? T = [
            [Math.min(M[0][0], T[0][0]), Math.min(M[0][1], T[0][1])],
            [Math.max(M[1][0], T[1][0]), Math.max(M[1][1], T[1][1])]
          ] : T = M;
        }
      m?.(F, { ...v });
    }).on("drag", (F) => {
      const { transform: O, snapGrid: B, snapToGrid: U, nodeOrigin: G } = n(), z = Wu(F.sourceEvent, {
        transform: O,
        snapGrid: B,
        snapToGrid: U,
        containerBounds: C
      }), $ = [];
      if (!N)
        return;
      const { x: L, y: H, width: q, height: Y } = v, M = {}, X = N.origin ?? G, { width: Q, height: P, x: te, y: ie } = W9(x, E, z, f, p, X, D, T), ae = Q !== q, fe = P !== Y, he = te !== L && ae, ye = ie !== H && fe;
      if (!he && !ye && !ae && !fe)
        return;
      if ((he || ye || X[0] === 1 || X[1] === 1) && (M.x = he ? te : v.x, M.y = ye ? ie : v.y, v.x = M.x, v.y = M.y, A.length > 0)) {
        const xe = te - L, Pe = ie - H;
        for (const Ve of A)
          Ve.position = {
            x: Ve.position.x - xe + X[0] * (Q - q),
            y: Ve.position.y - Pe + X[1] * (P - Y)
          }, $.push(Ve);
      }
      if ((ae || fe) && (M.width = ae ? Q : v.width, M.height = fe ? P : v.height, v.width = M.width, v.height = M.height), R && N.expandParent) {
        const xe = X[0] * (M.width ?? 0);
        M.x && M.x < xe && (v.x = xe, x.x = x.x - (M.x - xe));
        const Pe = X[1] * (M.height ?? 0);
        M.y && M.y < Pe && (v.y = Pe, x.y = x.y - (M.y - Pe));
      }
      const Ee = G9({
        width: v.width,
        prevWidth: q,
        height: v.height,
        prevHeight: Y,
        affectsX: E.affectsX,
        affectsY: E.affectsY
      }), we = { ...v, direction: Ee };
      w?.(F, we) !== !1 && (g?.(F, we), r(M, $));
    }).on("end", (F) => {
      y?.(F, { ...v }), o?.({ ...v });
    });
    a.call(V);
  }
  function u() {
    a.on(".drag", null);
  }
  return {
    update: l,
    destroy: u
  };
}
const { useDebugValue: t7 } = $t, { useSyncExternalStoreWithSelector: n7 } = TO, r7 = (e) => e;
function U3(e, t = r7, n) {
  const r = n7(
    e.subscribe,
    e.getState,
    e.getServerState || e.getInitialState,
    t,
    n
  );
  return t7(r), r;
}
const T0 = (e, t) => {
  const n = DO(e), r = (o, a = t) => U3(n, o, a);
  return Object.assign(r, n), r;
}, o7 = (e, t) => e ? T0(e, t) : T0;
function St(e, t) {
  if (Object.is(e, t))
    return !0;
  if (typeof e != "object" || e === null || typeof t != "object" || t === null)
    return !1;
  if (e instanceof Map && t instanceof Map) {
    if (e.size !== t.size) return !1;
    for (const [r, o] of e)
      if (!Object.is(o, t.get(r)))
        return !1;
    return !0;
  }
  if (e instanceof Set && t instanceof Set) {
    if (e.size !== t.size) return !1;
    for (const r of e)
      if (!t.has(r))
        return !1;
    return !0;
  }
  const n = Object.keys(e);
  if (n.length !== Object.keys(t).length)
    return !1;
  for (const r of n)
    if (!Object.prototype.hasOwnProperty.call(t, r) || !Object.is(e[r], t[r]))
      return !1;
  return !0;
}
const fh = _.createContext(null), i7 = fh.Provider, F3 = io.error001();
function Ze(e, t) {
  const n = _.useContext(fh);
  if (n === null)
    throw new Error(F3);
  return U3(n, e, t);
}
function _t() {
  const e = _.useContext(fh);
  if (e === null)
    throw new Error(F3);
  return _.useMemo(() => ({
    getState: e.getState,
    setState: e.setState,
    subscribe: e.subscribe
  }), [e]);
}
const z0 = { display: "none" }, a7 = {
  position: "absolute",
  width: 1,
  height: 1,
  margin: -1,
  border: 0,
  padding: 0,
  overflow: "hidden",
  clip: "rect(0px, 0px, 0px, 0px)",
  clipPath: "inset(100%)"
}, $3 = "react-flow__node-desc", Y3 = "react-flow__edge-desc", l7 = "react-flow__aria-live", s7 = (e) => e.ariaLiveMessage;
function u7({ rfId: e }) {
  const t = Ze(s7);
  return k.jsx("div", { id: `${l7}-${e}`, "aria-live": "assertive", "aria-atomic": "true", style: a7, children: t });
}
function c7({ rfId: e, disableKeyboardA11y: t }) {
  return k.jsxs(k.Fragment, { children: [k.jsxs("div", { id: `${$3}-${e}`, style: z0, children: ["Press enter or space to select a node.", !t && "You can then use the arrow keys to move the node around.", " Press delete to remove it and escape to cancel.", " "] }), k.jsx("div", { id: `${Y3}-${e}`, style: z0, children: "Press enter or space to select an edge. You can then press delete to remove it or escape to cancel." }), !t && k.jsx(u7, { rfId: e })] });
}
const d7 = (e) => e.userSelectionActive ? "none" : "all", ph = _.forwardRef(({ position: e = "top-left", children: t, className: n, style: r, ...o }, a) => {
  const l = Ze(d7), u = `${e}`.split("-");
  return k.jsx("div", { className: Xt(["react-flow__panel", n, ...u]), style: { ...r, pointerEvents: l }, ref: a, ...o, children: t });
});
ph.displayName = "Panel";
function f7({ proOptions: e, position: t = "bottom-right" }) {
  return e != null && e.hideAttribution ? null : k.jsx(ph, { position: t, className: "react-flow__attribution", "data-message": "Please only hide this attribution when you are subscribed to React Flow Pro: https://pro.reactflow.dev", children: k.jsx("a", { href: "https://reactflow.dev", target: "_blank", rel: "noopener noreferrer", "aria-label": "React Flow attribution", children: "React Flow" }) });
}
const p7 = (e) => {
  const t = [], n = [];
  for (const [, r] of e.nodeLookup)
    r.selected && t.push(r.internals.userNode);
  for (const [, r] of e.edgeLookup)
    r.selected && n.push(r);
  return { selectedNodes: t, selectedEdges: n };
}, Cf = (e) => e.id;
function h7(e, t) {
  return St(e.selectedNodes.map(Cf), t.selectedNodes.map(Cf)) && St(e.selectedEdges.map(Cf), t.selectedEdges.map(Cf));
}
function m7({ onSelectionChange: e }) {
  const t = _t(), { selectedNodes: n, selectedEdges: r } = Ze(p7, h7);
  return _.useEffect(() => {
    const o = { nodes: n, edges: r };
    e?.(o), t.getState().onSelectionChangeHandlers.forEach((a) => a(o));
  }, [n, r, e]), null;
}
const g7 = (e) => !!e.onSelectionChangeHandlers;
function y7({ onSelectionChange: e }) {
  const t = Ze(g7);
  return e || t ? k.jsx(m7, { onSelectionChange: e }) : null;
}
const q3 = [0, 0], v7 = { x: 0, y: 0, zoom: 1 }, b7 = [
  "nodes",
  "edges",
  "defaultNodes",
  "defaultEdges",
  "onConnect",
  "onConnectStart",
  "onConnectEnd",
  "onClickConnectStart",
  "onClickConnectEnd",
  "nodesDraggable",
  "nodesConnectable",
  "nodesFocusable",
  "edgesFocusable",
  "edgesReconnectable",
  "elevateNodesOnSelect",
  "elevateEdgesOnSelect",
  "minZoom",
  "maxZoom",
  "nodeExtent",
  "onNodesChange",
  "onEdgesChange",
  "elementsSelectable",
  "connectionMode",
  "snapGrid",
  "snapToGrid",
  "translateExtent",
  "connectOnClick",
  "defaultEdgeOptions",
  "fitView",
  "fitViewOptions",
  "onNodesDelete",
  "onEdgesDelete",
  "onDelete",
  "onNodeDrag",
  "onNodeDragStart",
  "onNodeDragStop",
  "onSelectionDrag",
  "onSelectionDragStart",
  "onSelectionDragStop",
  "onMoveStart",
  "onMove",
  "onMoveEnd",
  "noPanClassName",
  "nodeOrigin",
  "autoPanOnConnect",
  "autoPanOnNodeDrag",
  "onError",
  "connectionRadius",
  "isValidConnection",
  "selectNodesOnDrag",
  "nodeDragThreshold",
  "onBeforeDelete",
  "debug",
  "autoPanSpeed",
  "paneClickDistance"
], P0 = [...b7, "rfId"], w7 = (e) => ({
  setNodes: e.setNodes,
  setEdges: e.setEdges,
  setMinZoom: e.setMinZoom,
  setMaxZoom: e.setMaxZoom,
  setTranslateExtent: e.setTranslateExtent,
  setNodeExtent: e.setNodeExtent,
  reset: e.reset,
  setDefaultNodesAndEdges: e.setDefaultNodesAndEdges,
  setPaneClickDistance: e.setPaneClickDistance
}), L0 = {
  /*
   * these are values that are also passed directly to other components
   * than the StoreUpdater. We can reduce the number of setStore calls
   * by setting the same values here as prev fields.
   */
  translateExtent: uc,
  nodeOrigin: q3,
  minZoom: 0.5,
  maxZoom: 2,
  elementsSelectable: !0,
  noPanClassName: "nopan",
  rfId: "1",
  paneClickDistance: 0
};
function x7(e) {
  const { setNodes: t, setEdges: n, setMinZoom: r, setMaxZoom: o, setTranslateExtent: a, setNodeExtent: l, reset: u, setDefaultNodesAndEdges: d, setPaneClickDistance: f } = Ze(w7, St), p = _t();
  _.useEffect(() => (d(e.defaultNodes, e.defaultEdges), () => {
    m.current = L0, u();
  }), []);
  const m = _.useRef(L0);
  return _.useEffect(
    () => {
      for (const g of P0) {
        const y = e[g], w = m.current[g];
        y !== w && (typeof e[g] > "u" || (g === "nodes" ? t(y) : g === "edges" ? n(y) : g === "minZoom" ? r(y) : g === "maxZoom" ? o(y) : g === "translateExtent" ? a(y) : g === "nodeExtent" ? l(y) : g === "paneClickDistance" ? f(y) : g === "fitView" ? p.setState({ fitViewQueued: y }) : g === "fitViewOptions" ? p.setState({ fitViewOptions: y }) : p.setState({ [g]: y })));
      }
      m.current = e;
    },
    // Only re-run the effect if one of the fields we track changes
    P0.map((g) => e[g])
  ), null;
}
function I0() {
  return typeof window > "u" || !window.matchMedia ? null : window.matchMedia("(prefers-color-scheme: dark)");
}
function S7(e) {
  var t;
  const [n, r] = _.useState(e === "system" ? null : e);
  return _.useEffect(() => {
    if (e !== "system") {
      r(e);
      return;
    }
    const o = I0(), a = () => r(o != null && o.matches ? "dark" : "light");
    return a(), o?.addEventListener("change", a), () => {
      o?.removeEventListener("change", a);
    };
  }, [e]), n !== null ? n : (t = I0()) != null && t.matches ? "dark" : "light";
}
const B0 = typeof document < "u" ? document : null;
function ls(e = null, t = { target: B0, actInsideInputWithModifier: !0 }) {
  const [n, r] = _.useState(!1), o = _.useRef(!1), a = _.useRef(/* @__PURE__ */ new Set([])), [l, u] = _.useMemo(() => {
    if (e !== null) {
      const d = (Array.isArray(e) ? e : [e]).filter((p) => typeof p == "string").map((p) => p.replace("+", `
`).replace(`

`, `
+`).split(`
`)), f = d.reduce((p, m) => p.concat(...m), []);
      return [d, f];
    }
    return [[], []];
  }, [e]);
  return _.useEffect(() => {
    const d = t?.target || B0;
    if (e !== null) {
      const f = (g) => {
        var y, w;
        if (o.current = g.ctrlKey || g.metaKey || g.shiftKey || g.altKey, (!o.current || o.current && !t.actInsideInputWithModifier) && O3(g))
          return !1;
        const v = H0(g.code, u);
        if (a.current.add(g[v]), V0(l, a.current, !1)) {
          const x = ((w = (y = g.composedPath) == null ? void 0 : y.call(g)) == null ? void 0 : w[0]) || g.target, E = x?.nodeName === "BUTTON" || x?.nodeName === "A";
          t.preventDefault !== !1 && (o.current || !E) && g.preventDefault(), r(!0);
        }
      }, p = (g) => {
        const y = H0(g.code, u);
        V0(l, a.current, !0) ? (r(!1), a.current.clear()) : a.current.delete(g[y]), g.key === "Meta" && a.current.clear(), o.current = !1;
      }, m = () => {
        a.current.clear(), r(!1);
      };
      return d?.addEventListener("keydown", f), d?.addEventListener("keyup", p), window.addEventListener("blur", m), window.addEventListener("contextmenu", m), () => {
        d?.removeEventListener("keydown", f), d?.removeEventListener("keyup", p), window.removeEventListener("blur", m), window.removeEventListener("contextmenu", m);
      };
    }
  }, [e, r]), n;
}
function V0(e, t, n) {
  return e.filter((r) => n || r.length === t.size).some((r) => r.every((o) => t.has(o)));
}
function H0(e, t) {
  return t.includes(e) ? "code" : "key";
}
const k7 = () => {
  const e = _t();
  return _.useMemo(() => ({
    zoomIn: (t) => {
      const { panZoom: n } = e.getState();
      return n ? n.scaleBy(1.2, { duration: t?.duration }) : Promise.resolve(!1);
    },
    zoomOut: (t) => {
      const { panZoom: n } = e.getState();
      return n ? n.scaleBy(1 / 1.2, { duration: t?.duration }) : Promise.resolve(!1);
    },
    zoomTo: (t, n) => {
      const { panZoom: r } = e.getState();
      return r ? r.scaleTo(t, { duration: n?.duration }) : Promise.resolve(!1);
    },
    getZoom: () => e.getState().transform[2],
    setViewport: async (t, n) => {
      const { transform: [r, o, a], panZoom: l } = e.getState();
      return l ? (await l.setViewport({
        x: t.x ?? r,
        y: t.y ?? o,
        zoom: t.zoom ?? a
      }, { duration: n?.duration }), Promise.resolve(!0)) : Promise.resolve(!1);
    },
    getViewport: () => {
      const [t, n, r] = e.getState().transform;
      return { x: t, y: n, zoom: r };
    },
    setCenter: async (t, n, r) => {
      const { width: o, height: a, maxZoom: l, panZoom: u } = e.getState(), d = typeof r?.zoom < "u" ? r.zoom : l, f = o / 2 - t * d, p = a / 2 - n * d;
      return u ? (await u.setViewport({
        x: f,
        y: p,
        zoom: d
      }, { duration: r?.duration }), Promise.resolve(!0)) : Promise.resolve(!1);
    },
    fitBounds: async (t, n) => {
      const { width: r, height: o, minZoom: a, maxZoom: l, panZoom: u } = e.getState(), d = hw(t, r, o, a, l, n?.padding ?? 0.1);
      return u ? (await u.setViewport(d, { duration: n?.duration }), Promise.resolve(!0)) : Promise.resolve(!1);
    },
    screenToFlowPosition: (t, n = {}) => {
      const { transform: r, snapGrid: o, snapToGrid: a, domNode: l } = e.getState();
      if (!l)
        return t;
      const { x: u, y: d } = l.getBoundingClientRect(), f = {
        x: t.x - u,
        y: t.y - d
      }, p = n.snapGrid ?? o, m = n.snapToGrid ?? a;
      return Tc(f, r, m, p);
    },
    flowToScreenPosition: (t) => {
      const { transform: n, domNode: r } = e.getState();
      if (!r)
        return t;
      const { x: o, y: a } = r.getBoundingClientRect(), l = _p(t, n);
      return {
        x: l.x + o,
        y: l.y + a
      };
    }
  }), []);
};
function X3(e, t) {
  const n = [], r = /* @__PURE__ */ new Map(), o = [];
  for (const a of e)
    if (a.type === "add") {
      o.push(a);
      continue;
    } else if (a.type === "remove" || a.type === "replace")
      r.set(a.id, [a]);
    else {
      const l = r.get(a.id);
      l ? l.push(a) : r.set(a.id, [a]);
    }
  for (const a of t) {
    const l = r.get(a.id);
    if (!l) {
      n.push(a);
      continue;
    }
    if (l[0].type === "remove")
      continue;
    if (l[0].type === "replace") {
      n.push({ ...l[0].item });
      continue;
    }
    const u = { ...a };
    for (const d of l)
      _7(d, u);
    n.push(u);
  }
  return o.length && o.forEach((a) => {
    a.index !== void 0 ? n.splice(a.index, 0, { ...a.item }) : n.push({ ...a.item });
  }), n;
}
function _7(e, t) {
  switch (e.type) {
    case "select": {
      t.selected = e.selected;
      break;
    }
    case "position": {
      typeof e.position < "u" && (t.position = e.position), typeof e.dragging < "u" && (t.dragging = e.dragging);
      break;
    }
    case "dimensions": {
      typeof e.dimensions < "u" && (t.measured ?? (t.measured = {}), t.measured.width = e.dimensions.width, t.measured.height = e.dimensions.height, e.setAttributes && (t.width = e.dimensions.width, t.height = e.dimensions.height)), typeof e.resizing == "boolean" && (t.resizing = e.resizing);
      break;
    }
  }
}
function G3(e, t) {
  return X3(e, t);
}
function Z3(e, t) {
  return X3(e, t);
}
function va(e, t) {
  return {
    id: e,
    type: "select",
    selected: t
  };
}
function Fl(e, t = /* @__PURE__ */ new Set(), n = !1) {
  const r = [];
  for (const [o, a] of e) {
    const l = t.has(o);
    !(a.selected === void 0 && !l) && a.selected !== l && (n && (a.selected = l), r.push(va(a.id, l)));
  }
  return r;
}
function U0({ items: e = [], lookup: t }) {
  var n;
  const r = [], o = new Map(e.map((a) => [a.id, a]));
  for (const [a, l] of e.entries()) {
    const u = t.get(l.id), d = ((n = u?.internals) == null ? void 0 : n.userNode) ?? u;
    d !== void 0 && d !== l && r.push({ id: l.id, item: l, type: "replace" }), d === void 0 && r.push({ item: l, type: "add", index: a });
  }
  for (const [a] of t)
    o.get(a) === void 0 && r.push({ id: a, type: "remove" });
  return r;
}
function F0(e) {
  return {
    id: e.id,
    type: "remove"
  };
}
const $0 = (e) => a9(e), E7 = (e) => v3(e);
function W3(e) {
  return _.forwardRef(e);
}
const C7 = typeof window < "u" ? _.useLayoutEffect : _.useEffect;
function Y0(e) {
  const [t, n] = _.useState(BigInt(0)), [r] = _.useState(() => O7(() => n((o) => o + BigInt(1))));
  return C7(() => {
    const o = r.get();
    o.length && (e(o), r.reset());
  }, [t]), r;
}
function O7(e) {
  let t = [];
  return {
    get: () => t,
    reset: () => {
      t = [];
    },
    push: (n) => {
      t.push(n), e();
    }
  };
}
const K3 = _.createContext(null);
function N7({ children: e }) {
  const t = _t(), n = _.useCallback((u) => {
    const { nodes: d = [], setNodes: f, hasDefaultNodes: p, onNodesChange: m, nodeLookup: g, fitViewQueued: y } = t.getState();
    let w = d;
    for (const v of u)
      w = typeof v == "function" ? v(w) : v;
    if (p)
      f(w);
    else {
      const v = U0({
        items: w,
        lookup: g
      });
      v.length > 0 ? m?.(v) : y && window.requestAnimationFrame(() => {
        const { fitViewQueued: x, nodes: E, setNodes: N } = t.getState();
        x && N(E);
      });
    }
  }, []), r = Y0(n), o = _.useCallback((u) => {
    const { edges: d = [], setEdges: f, hasDefaultEdges: p, onEdgesChange: m, edgeLookup: g } = t.getState();
    let y = d;
    for (const w of u)
      y = typeof w == "function" ? w(y) : w;
    p ? f(y) : m && m(U0({
      items: y,
      lookup: g
    }));
  }, []), a = Y0(o), l = _.useMemo(() => ({ nodeQueue: r, edgeQueue: a }), []);
  return k.jsx(K3.Provider, { value: l, children: e });
}
function M7() {
  const e = _.useContext(K3);
  if (!e)
    throw new Error("useBatchContext must be used within a BatchProvider");
  return e;
}
const A7 = (e) => !!e.panZoom;
function zc() {
  const e = k7(), t = _t(), n = M7(), r = Ze(A7), o = _.useMemo(() => {
    const a = (m) => t.getState().nodeLookup.get(m), l = (m) => {
      n.nodeQueue.push(m);
    }, u = (m) => {
      n.edgeQueue.push(m);
    }, d = (m) => {
      var g, y;
      const { nodeLookup: w, nodeOrigin: v } = t.getState(), x = $0(m) ? m : w.get(m.id), E = x.parentId ? E3(x.position, x.measured, x.parentId, w, v) : x.position, N = {
        ...x,
        position: E,
        width: ((g = x.measured) == null ? void 0 : g.width) ?? x.width,
        height: ((y = x.measured) == null ? void 0 : y.height) ?? x.height
      };
      return is(N);
    }, f = (m, g, y = { replace: !1 }) => {
      l((w) => w.map((v) => {
        if (v.id === m) {
          const x = typeof g == "function" ? g(v) : g;
          return y.replace && $0(x) ? x : { ...v, ...x };
        }
        return v;
      }));
    }, p = (m, g, y = { replace: !1 }) => {
      u((w) => w.map((v) => {
        if (v.id === m) {
          const x = typeof g == "function" ? g(v) : g;
          return y.replace && E7(x) ? x : { ...v, ...x };
        }
        return v;
      }));
    };
    return {
      getNodes: () => t.getState().nodes.map((m) => ({ ...m })),
      getNode: (m) => {
        var g;
        return (g = a(m)) == null ? void 0 : g.internals.userNode;
      },
      getInternalNode: a,
      getEdges: () => {
        const { edges: m = [] } = t.getState();
        return m.map((g) => ({ ...g }));
      },
      getEdge: (m) => t.getState().edgeLookup.get(m),
      setNodes: l,
      setEdges: u,
      addNodes: (m) => {
        const g = Array.isArray(m) ? m : [m];
        n.nodeQueue.push((y) => [...y, ...g]);
      },
      addEdges: (m) => {
        const g = Array.isArray(m) ? m : [m];
        n.edgeQueue.push((y) => [...y, ...g]);
      },
      toObject: () => {
        const { nodes: m = [], edges: g = [], transform: y } = t.getState(), [w, v, x] = y;
        return {
          nodes: m.map((E) => ({ ...E })),
          edges: g.map((E) => ({ ...E })),
          viewport: {
            x: w,
            y: v,
            zoom: x
          }
        };
      },
      deleteElements: async ({ nodes: m = [], edges: g = [] }) => {
        const { nodes: y, edges: w, onNodesDelete: v, onEdgesDelete: x, triggerNodeChanges: E, triggerEdgeChanges: N, onDelete: C, onBeforeDelete: A } = t.getState(), { nodes: R, edges: D } = await d9({
          nodesToRemove: m,
          edgesToRemove: g,
          nodes: y,
          edges: w,
          onBeforeDelete: A
        }), T = D.length > 0, V = R.length > 0;
        if (T) {
          const F = D.map(F0);
          x?.(D), N(F);
        }
        if (V) {
          const F = R.map(F0);
          v?.(R), E(F);
        }
        return (V || T) && C?.({ nodes: R, edges: D }), { deletedNodes: R, deletedEdges: D };
      },
      getIntersectingNodes: (m, g = !0, y) => {
        const w = S0(m), v = w ? m : d(m), x = y !== void 0;
        return v ? (y || t.getState().nodes).filter((E) => {
          const N = t.getState().nodeLookup.get(E.id);
          if (N && !w && (E.id === m.id || !N.internals.positionAbsolute))
            return !1;
          const C = is(x ? E : N), A = dc(C, v);
          return g && A > 0 || A >= v.width * v.height;
        }) : [];
      },
      isNodeIntersecting: (m, g, y = !0) => {
        const w = S0(m) ? m : d(m);
        if (!w)
          return !1;
        const v = dc(w, g);
        return y && v > 0 || v >= w.width * w.height;
      },
      updateNode: f,
      updateNodeData: (m, g, y = { replace: !1 }) => {
        f(m, (w) => {
          const v = typeof g == "function" ? g(w) : g;
          return y.replace ? { ...w, data: v } : { ...w, data: { ...w.data, ...v } };
        }, y);
      },
      updateEdge: p,
      updateEdgeData: (m, g, y = { replace: !1 }) => {
        p(m, (w) => {
          const v = typeof g == "function" ? g(w) : g;
          return y.replace ? { ...w, data: v } : { ...w, data: { ...w.data, ...v } };
        }, y);
      },
      getNodesBounds: (m) => {
        const { nodeLookup: g, nodeOrigin: y } = t.getState();
        return l9(m, { nodeLookup: g, nodeOrigin: y });
      },
      getHandleConnections: ({ type: m, id: g, nodeId: y }) => {
        var w;
        return Array.from(((w = t.getState().connectionLookup.get(`${y}-${m}${g ? `-${g}` : ""}`)) == null ? void 0 : w.values()) ?? []);
      },
      getNodeConnections: ({ type: m, handleId: g, nodeId: y }) => {
        var w;
        return Array.from(((w = t.getState().connectionLookup.get(`${y}${m ? g ? `-${m}-${g}` : `-${m}` : ""}`)) == null ? void 0 : w.values()) ?? []);
      },
      fitView: async (m) => {
        const g = t.getState().fitViewResolver ?? Promise.withResolvers();
        return t.setState({ fitViewQueued: !0, fitViewOptions: m, fitViewResolver: g }), n.nodeQueue.push((y) => [...y]), g.promise;
      }
    };
  }, []);
  return _.useMemo(() => ({
    ...o,
    ...e,
    viewportInitialized: r
  }), [r]);
}
const q0 = (e) => e.selected, R7 = { actInsideInputWithModifier: !1 }, j7 = typeof window < "u" ? window : void 0;
function D7({ deleteKeyCode: e, multiSelectionKeyCode: t }) {
  const n = _t(), { deleteElements: r } = zc(), o = ls(e, R7), a = ls(t, { target: j7 });
  _.useEffect(() => {
    if (o) {
      const { edges: l, nodes: u } = n.getState();
      r({ nodes: u.filter(q0), edges: l.filter(q0) }), n.setState({ nodesSelectionActive: !1 });
    }
  }, [o]), _.useEffect(() => {
    n.setState({ multiSelectionActive: a });
  }, [a]);
}
function T7(e) {
  const t = _t();
  _.useEffect(() => {
    const n = () => {
      var r, o;
      if (!e.current)
        return !1;
      const a = mw(e.current);
      (a.height === 0 || a.width === 0) && ((o = (r = t.getState()).onError) == null || o.call(r, "004", io.error004())), t.setState({ width: a.width || 500, height: a.height || 500 });
    };
    if (e.current) {
      n(), window.addEventListener("resize", n);
      const r = new ResizeObserver(() => n());
      return r.observe(e.current), () => {
        window.removeEventListener("resize", n), r && e.current && r.unobserve(e.current);
      };
    }
  }, []);
}
const hh = {
  position: "absolute",
  width: "100%",
  height: "100%",
  top: 0,
  left: 0
}, z7 = (e) => ({
  userSelectionActive: e.userSelectionActive,
  lib: e.lib
});
function P7({ onPaneContextMenu: e, zoomOnScroll: t = !0, zoomOnPinch: n = !0, panOnScroll: r = !1, panOnScrollSpeed: o = 0.5, panOnScrollMode: a = Oa.Free, zoomOnDoubleClick: l = !0, panOnDrag: u = !0, defaultViewport: d, translateExtent: f, minZoom: p, maxZoom: m, zoomActivationKeyCode: g, preventScrolling: y = !0, children: w, noWheelClassName: v, noPanClassName: x, onViewportChange: E, isControlledViewport: N, paneClickDistance: C }) {
  const A = _t(), R = _.useRef(null), { userSelectionActive: D, lib: T } = Ze(z7, St), V = ls(g), F = _.useRef();
  T7(R);
  const O = _.useCallback((B) => {
    E?.({ x: B[0], y: B[1], zoom: B[2] }), N || A.setState({ transform: B });
  }, [E, N]);
  return _.useEffect(() => {
    if (R.current) {
      F.current = X9({
        domNode: R.current,
        minZoom: p,
        maxZoom: m,
        translateExtent: f,
        viewport: d,
        paneClickDistance: C,
        onDraggingChange: (z) => A.setState({ paneDragging: z }),
        onPanZoomStart: (z, $) => {
          const { onViewportChangeStart: L, onMoveStart: H } = A.getState();
          H?.(z, $), L?.($);
        },
        onPanZoom: (z, $) => {
          const { onViewportChange: L, onMove: H } = A.getState();
          H?.(z, $), L?.($);
        },
        onPanZoomEnd: (z, $) => {
          const { onViewportChangeEnd: L, onMoveEnd: H } = A.getState();
          H?.(z, $), L?.($);
        }
      });
      const { x: B, y: U, zoom: G } = F.current.getViewport();
      return A.setState({
        panZoom: F.current,
        transform: [B, U, G],
        domNode: R.current.closest(".react-flow")
      }), () => {
        var z;
        (z = F.current) == null || z.destroy();
      };
    }
  }, []), _.useEffect(() => {
    var B;
    (B = F.current) == null || B.update({
      onPaneContextMenu: e,
      zoomOnScroll: t,
      zoomOnPinch: n,
      panOnScroll: r,
      panOnScrollSpeed: o,
      panOnScrollMode: a,
      zoomOnDoubleClick: l,
      panOnDrag: u,
      zoomActivationKeyPressed: V,
      preventScrolling: y,
      noPanClassName: x,
      userSelectionActive: D,
      noWheelClassName: v,
      lib: T,
      onTransformChange: O
    });
  }, [
    e,
    t,
    n,
    r,
    o,
    a,
    l,
    u,
    V,
    y,
    x,
    D,
    v,
    T,
    O
  ]), k.jsx("div", { className: "react-flow__renderer", ref: R, style: hh, children: w });
}
const L7 = (e) => ({
  userSelectionActive: e.userSelectionActive,
  userSelectionRect: e.userSelectionRect
});
function I7() {
  const { userSelectionActive: e, userSelectionRect: t } = Ze(L7, St);
  return e && t ? k.jsx("div", { className: "react-flow__selection react-flow__container", style: {
    width: t.width,
    height: t.height,
    transform: `translate(${t.x}px, ${t.y}px)`
  } }) : null;
}
const zy = (e, t) => (n) => {
  n.target === t.current && e?.(n);
}, B7 = (e) => ({
  userSelectionActive: e.userSelectionActive,
  elementsSelectable: e.elementsSelectable,
  connectionInProgress: e.connection.inProgress,
  dragging: e.paneDragging
});
function V7({ isSelecting: e, selectionKeyPressed: t, selectionMode: n = cc.Full, panOnDrag: r, selectionOnDrag: o, onSelectionStart: a, onSelectionEnd: l, onPaneClick: u, onPaneContextMenu: d, onPaneScroll: f, onPaneMouseEnter: p, onPaneMouseMove: m, onPaneMouseLeave: g, children: y }) {
  const w = _t(), { userSelectionActive: v, elementsSelectable: x, dragging: E, connectionInProgress: N } = Ze(B7, St), C = x && (e || v), A = _.useRef(null), R = _.useRef(), D = _.useRef(/* @__PURE__ */ new Set()), T = _.useRef(/* @__PURE__ */ new Set()), V = _.useRef(!1), F = _.useRef(!1), O = (H) => {
    if (V.current || N) {
      V.current = !1;
      return;
    }
    u?.(H), w.getState().resetSelectedElements(), w.setState({ nodesSelectionActive: !1 });
  }, B = (H) => {
    if (Array.isArray(r) && r != null && r.includes(2)) {
      H.preventDefault();
      return;
    }
    d?.(H);
  }, U = f ? (H) => f(H) : void 0, G = (H) => {
    var q, Y;
    const { resetSelectedElements: M, domNode: X } = w.getState();
    if (R.current = X?.getBoundingClientRect(), !x || !e || H.button !== 0 || H.target !== A.current || !R.current)
      return;
    (Y = (q = H.target) == null ? void 0 : q.setPointerCapture) == null || Y.call(q, H.pointerId), F.current = !0, V.current = !1;
    const { x: Q, y: P } = Bo(H.nativeEvent, R.current);
    M(), w.setState({
      userSelectionRect: {
        width: 0,
        height: 0,
        startX: Q,
        startY: P,
        x: Q,
        y: P
      }
    }), a?.(H);
  }, z = (H) => {
    const { userSelectionRect: q, transform: Y, nodeLookup: M, edgeLookup: X, connectionLookup: Q, triggerNodeChanges: P, triggerEdgeChanges: te, defaultEdgeOptions: ie } = w.getState();
    if (!R.current || !q)
      return;
    V.current = !0;
    const { x: ae, y: fe } = Bo(H.nativeEvent, R.current), { startX: he, startY: ye } = q, Ee = {
      startX: he,
      startY: ye,
      x: ae < he ? ae : he,
      y: fe < ye ? fe : ye,
      width: Math.abs(ae - he),
      height: Math.abs(fe - ye)
    }, we = D.current, xe = T.current;
    D.current = new Set(b3(M, Ee, Y, n === cc.Partial, !0).map((Ve) => Ve.id)), T.current = /* @__PURE__ */ new Set();
    const Pe = ie?.selectable ?? !0;
    for (const Ve of D.current) {
      const Rt = Q.get(Ve);
      if (Rt)
        for (const { edgeId: Pt } of Rt.values()) {
          const lt = X.get(Pt);
          lt && (lt.selectable ?? Pe) && T.current.add(Pt);
        }
    }
    if (!k0(we, D.current)) {
      const Ve = Fl(M, D.current, !0);
      P(Ve);
    }
    if (!k0(xe, T.current)) {
      const Ve = Fl(X, T.current);
      te(Ve);
    }
    w.setState({
      userSelectionRect: Ee,
      userSelectionActive: !0,
      nodesSelectionActive: !1
    });
  }, $ = (H) => {
    var q, Y;
    if (H.button !== 0 || !F.current)
      return;
    (Y = (q = H.target) == null ? void 0 : q.releasePointerCapture) == null || Y.call(q, H.pointerId);
    const { userSelectionRect: M } = w.getState();
    !v && M && H.target === A.current && O?.(H), w.setState({
      userSelectionActive: !1,
      userSelectionRect: null,
      nodesSelectionActive: D.current.size > 0
    }), l?.(H), (t || o) && (V.current = !1), F.current = !1;
  }, L = r === !0 || Array.isArray(r) && r.includes(0);
  return k.jsxs("div", { className: Xt(["react-flow__pane", { draggable: L, dragging: E, selection: e }]), onClick: C ? void 0 : zy(O, A), onContextMenu: zy(B, A), onWheel: zy(U, A), onPointerEnter: C ? void 0 : p, onPointerDown: C ? G : m, onPointerMove: C ? z : m, onPointerUp: C ? $ : void 0, onPointerLeave: g, ref: A, style: hh, children: [y, k.jsx(I7, {})] });
}
function Zv({ id: e, store: t, unselect: n = !1, nodeRef: r }) {
  const { addSelectedNodes: o, unselectNodesAndEdges: a, multiSelectionActive: l, nodeLookup: u, onError: d } = t.getState(), f = u.get(e);
  if (!f) {
    d?.("012", io.error012(e));
    return;
  }
  t.setState({ nodesSelectionActive: !1 }), f.selected ? (n || f.selected && l) && (a({ nodes: [f], edges: [] }), requestAnimationFrame(() => {
    var p;
    return (p = r?.current) == null ? void 0 : p.blur();
  })) : o([e]);
}
function Q3({ nodeRef: e, disabled: t = !1, noDragClassName: n, handleSelector: r, nodeId: o, isSelectable: a, nodeClickDistance: l }) {
  const u = _t(), [d, f] = _.useState(!1), p = _.useRef();
  return _.useEffect(() => {
    p.current = D9({
      getStoreItems: () => u.getState(),
      onNodeMouseDown: (m) => {
        Zv({
          id: m,
          store: u,
          nodeRef: e
        });
      },
      onDragStart: () => {
        f(!0);
      },
      onDragStop: () => {
        f(!1);
      }
    });
  }, []), _.useEffect(() => {
    var m, g;
    if (t)
      (m = p.current) == null || m.destroy();
    else if (e.current)
      return (g = p.current) == null || g.update({
        noDragClassName: n,
        handleSelector: r,
        domNode: e.current,
        isSelectable: a,
        nodeId: o,
        nodeClickDistance: l
      }), () => {
        var y;
        (y = p.current) == null || y.destroy();
      };
  }, [n, r, t, a, e, o]), d;
}
const H7 = (e) => (t) => t.selected && (t.draggable || e && typeof t.draggable > "u");
function J3() {
  const e = _t();
  return _.useCallback((t) => {
    const { nodeExtent: n, snapToGrid: r, snapGrid: o, nodesDraggable: a, onError: l, updateNodePositions: u, nodeLookup: d, nodeOrigin: f } = e.getState(), p = /* @__PURE__ */ new Map(), m = H7(a), g = r ? o[0] : 5, y = r ? o[1] : 5, w = t.direction.x * g * t.factor, v = t.direction.y * y * t.factor;
    for (const [, x] of d) {
      if (!m(x))
        continue;
      let E = {
        x: x.internals.positionAbsolute.x + w,
        y: x.internals.positionAbsolute.y + v
      };
      r && (E = ch(E, o));
      const { position: N, positionAbsolute: C } = w3({
        nodeId: x.id,
        nextPosition: E,
        nodeLookup: d,
        nodeExtent: n,
        nodeOrigin: f,
        onError: l
      });
      x.position = N, x.internals.positionAbsolute = C, p.set(x.id, x);
    }
    u(p);
  }, []);
}
const xw = _.createContext(null), U7 = xw.Provider;
xw.Consumer;
const e4 = () => _.useContext(xw), F7 = (e) => ({
  connectOnClick: e.connectOnClick,
  noPanClassName: e.noPanClassName,
  rfId: e.rfId
}), $7 = (e, t, n) => (r) => {
  const { connectionClickStartHandle: o, connectionMode: a, connection: l } = r, { fromHandle: u, toHandle: d, isValid: f } = l, p = d?.nodeId === e && d?.id === t && d?.type === n;
  return {
    connectingFrom: u?.nodeId === e && u?.id === t && u?.type === n,
    connectingTo: p,
    clickConnecting: o?.nodeId === e && o?.id === t && o?.type === n,
    isPossibleEndHandle: a === rs.Strict ? u?.type !== n : e !== u?.nodeId || t !== u?.id,
    connectionInProcess: !!u,
    clickConnectionInProcess: !!o,
    valid: p && f
  };
};
function Y7({ type: e = "source", position: t = Ce.Top, isValidConnection: n, isConnectable: r = !0, isConnectableStart: o = !0, isConnectableEnd: a = !0, id: l, onConnect: u, children: d, className: f, onMouseDown: p, onTouchStart: m, ...g }, y) {
  var w, v;
  const x = l || null, E = e === "target", N = _t(), C = e4(), { connectOnClick: A, noPanClassName: R, rfId: D } = Ze(F7, St), { connectingFrom: T, connectingTo: V, clickConnecting: F, isPossibleEndHandle: O, connectionInProcess: B, clickConnectionInProcess: U, valid: G } = Ze($7(C, x, e), St);
  C || (v = (w = N.getState()).onError) == null || v.call(w, "010", io.error010());
  const z = (H) => {
    const { defaultEdgeOptions: q, onConnect: Y, hasDefaultEdges: M } = N.getState(), X = {
      ...q,
      ...H
    };
    if (M) {
      const { edges: Q, setEdges: P } = N.getState();
      P(w9(X, Q));
    }
    Y?.(X), u?.(X);
  }, $ = (H) => {
    if (!C)
      return;
    const q = N3(H.nativeEvent);
    if (o && (q && H.button === 0 || !q)) {
      const Y = N.getState();
      Gv.onPointerDown(H.nativeEvent, {
        autoPanOnConnect: Y.autoPanOnConnect,
        connectionMode: Y.connectionMode,
        connectionRadius: Y.connectionRadius,
        domNode: Y.domNode,
        nodeLookup: Y.nodeLookup,
        lib: Y.lib,
        isTarget: E,
        handleId: x,
        nodeId: C,
        flowId: Y.rfId,
        panBy: Y.panBy,
        cancelConnection: Y.cancelConnection,
        onConnectStart: Y.onConnectStart,
        onConnectEnd: Y.onConnectEnd,
        updateConnection: Y.updateConnection,
        onConnect: z,
        isValidConnection: n || Y.isValidConnection,
        getTransform: () => N.getState().transform,
        getFromHandle: () => N.getState().connection.fromHandle,
        autoPanSpeed: Y.autoPanSpeed
      });
    }
    q ? p?.(H) : m?.(H);
  }, L = (H) => {
    const { onClickConnectStart: q, onClickConnectEnd: Y, connectionClickStartHandle: M, connectionMode: X, isValidConnection: Q, lib: P, rfId: te, nodeLookup: ie, connection: ae } = N.getState();
    if (!C || !M && !o)
      return;
    if (!M) {
      q?.(H.nativeEvent, { nodeId: C, handleId: x, handleType: e }), N.setState({ connectionClickStartHandle: { nodeId: C, type: e, id: x } });
      return;
    }
    const fe = C3(H.target), he = n || Q, { connection: ye, isValid: Ee } = Gv.isValid(H.nativeEvent, {
      handle: {
        nodeId: C,
        id: x,
        type: e
      },
      connectionMode: X,
      fromNodeId: M.nodeId,
      fromHandleId: M.id || null,
      fromType: M.type,
      isValidConnection: he,
      flowId: te,
      doc: fe,
      lib: P,
      nodeLookup: ie
    });
    Ee && ye && z(ye);
    const we = structuredClone(ae);
    delete we.inProgress, we.toPosition = we.toHandle ? we.toHandle.position : null, Y?.(H, we), N.setState({ connectionClickStartHandle: null });
  };
  return k.jsx("div", { "data-handleid": x, "data-nodeid": C, "data-handlepos": t, "data-id": `${D}-${C}-${x}-${e}`, className: Xt([
    "react-flow__handle",
    `react-flow__handle-${t}`,
    "nodrag",
    R,
    f,
    {
      source: !E,
      target: E,
      connectable: r,
      connectablestart: o,
      connectableend: a,
      clickconnecting: F,
      connectingfrom: T,
      connectingto: V,
      valid: G,
      /*
       * shows where you can start a connection from
       * and where you can end it while connecting
       */
      connectionindicator: r && (!B || O) && (B || U ? a : o)
    }
  ]), onMouseDown: $, onTouchStart: $, onClick: A ? L : void 0, ref: y, ...g, children: d });
}
const pc = _.memo(W3(Y7));
function q7({ data: e, isConnectable: t, sourcePosition: n = Ce.Bottom }) {
  return k.jsxs(k.Fragment, { children: [e?.label, k.jsx(pc, { type: "source", position: n, isConnectable: t })] });
}
function X7({ data: e, isConnectable: t, targetPosition: n = Ce.Top, sourcePosition: r = Ce.Bottom }) {
  return k.jsxs(k.Fragment, { children: [k.jsx(pc, { type: "target", position: n, isConnectable: t }), e?.label, k.jsx(pc, { type: "source", position: r, isConnectable: t })] });
}
function G7() {
  return null;
}
function Z7({ data: e, isConnectable: t, targetPosition: n = Ce.Top }) {
  return k.jsxs(k.Fragment, { children: [k.jsx(pc, { type: "target", position: n, isConnectable: t }), e?.label] });
}
const Cp = {
  ArrowUp: { x: 0, y: -1 },
  ArrowDown: { x: 0, y: 1 },
  ArrowLeft: { x: -1, y: 0 },
  ArrowRight: { x: 1, y: 0 }
}, X0 = {
  input: q7,
  default: X7,
  output: Z7,
  group: G7
};
function W7(e) {
  var t, n, r, o;
  return e.internals.handleBounds === void 0 ? {
    width: e.width ?? e.initialWidth ?? ((t = e.style) == null ? void 0 : t.width),
    height: e.height ?? e.initialHeight ?? ((n = e.style) == null ? void 0 : n.height)
  } : {
    width: e.width ?? ((r = e.style) == null ? void 0 : r.width),
    height: e.height ?? ((o = e.style) == null ? void 0 : o.height)
  };
}
const K7 = (e) => {
  const { width: t, height: n, x: r, y: o } = Dc(e.nodeLookup, {
    filter: (a) => !!a.selected
  });
  return {
    width: Ar(t) ? t : null,
    height: Ar(n) ? n : null,
    userSelectionActive: e.userSelectionActive,
    transformString: `translate(${e.transform[0]}px,${e.transform[1]}px) scale(${e.transform[2]}) translate(${r}px,${o}px)`
  };
};
function Q7({ onSelectionContextMenu: e, noPanClassName: t, disableKeyboardA11y: n }) {
  const r = _t(), { width: o, height: a, transformString: l, userSelectionActive: u } = Ze(K7, St), d = J3(), f = _.useRef(null);
  if (_.useEffect(() => {
    var g;
    n || (g = f.current) == null || g.focus({
      preventScroll: !0
    });
  }, [n]), Q3({
    nodeRef: f
  }), u || !o || !a)
    return null;
  const p = e ? (g) => {
    const y = r.getState().nodes.filter((w) => w.selected);
    e(g, y);
  } : void 0, m = (g) => {
    Object.prototype.hasOwnProperty.call(Cp, g.key) && (g.preventDefault(), d({
      direction: Cp[g.key],
      factor: g.shiftKey ? 4 : 1
    }));
  };
  return k.jsx("div", { className: Xt(["react-flow__nodesselection", "react-flow__container", t]), style: {
    transform: l
  }, children: k.jsx("div", { ref: f, className: "react-flow__nodesselection-rect", onContextMenu: p, tabIndex: n ? void 0 : -1, onKeyDown: n ? void 0 : m, style: {
    width: o,
    height: a
  } }) });
}
const G0 = typeof window < "u" ? window : void 0, J7 = (e) => ({ nodesSelectionActive: e.nodesSelectionActive, userSelectionActive: e.userSelectionActive });
function t4({ children: e, onPaneClick: t, onPaneMouseEnter: n, onPaneMouseMove: r, onPaneMouseLeave: o, onPaneContextMenu: a, onPaneScroll: l, paneClickDistance: u, deleteKeyCode: d, selectionKeyCode: f, selectionOnDrag: p, selectionMode: m, onSelectionStart: g, onSelectionEnd: y, multiSelectionKeyCode: w, panActivationKeyCode: v, zoomActivationKeyCode: x, elementsSelectable: E, zoomOnScroll: N, zoomOnPinch: C, panOnScroll: A, panOnScrollSpeed: R, panOnScrollMode: D, zoomOnDoubleClick: T, panOnDrag: V, defaultViewport: F, translateExtent: O, minZoom: B, maxZoom: U, preventScrolling: G, onSelectionContextMenu: z, noWheelClassName: $, noPanClassName: L, disableKeyboardA11y: H, onViewportChange: q, isControlledViewport: Y }) {
  const { nodesSelectionActive: M, userSelectionActive: X } = Ze(J7), Q = ls(f, { target: G0 }), P = ls(v, { target: G0 }), te = P || V, ie = P || A, ae = p && te !== !0, fe = Q || X || ae;
  return D7({ deleteKeyCode: d, multiSelectionKeyCode: w }), k.jsx(P7, { onPaneContextMenu: a, elementsSelectable: E, zoomOnScroll: N, zoomOnPinch: C, panOnScroll: ie, panOnScrollSpeed: R, panOnScrollMode: D, zoomOnDoubleClick: T, panOnDrag: !Q && te, defaultViewport: F, translateExtent: O, minZoom: B, maxZoom: U, zoomActivationKeyCode: x, preventScrolling: G, noWheelClassName: $, noPanClassName: L, onViewportChange: q, isControlledViewport: Y, paneClickDistance: u, children: k.jsxs(V7, { onSelectionStart: g, onSelectionEnd: y, onPaneClick: t, onPaneMouseEnter: n, onPaneMouseMove: r, onPaneMouseLeave: o, onPaneContextMenu: a, onPaneScroll: l, panOnDrag: te, isSelecting: !!fe, selectionMode: m, selectionKeyPressed: Q, selectionOnDrag: ae, children: [e, M && k.jsx(Q7, { onSelectionContextMenu: z, noPanClassName: L, disableKeyboardA11y: H })] }) });
}
t4.displayName = "FlowRenderer";
const e1 = _.memo(t4), t1 = (e) => (t) => e ? b3(t.nodeLookup, { x: 0, y: 0, width: t.width, height: t.height }, t.transform, !0).map((n) => n.id) : Array.from(t.nodeLookup.keys());
function n1(e) {
  return Ze(_.useCallback(t1(e), [e]), St);
}
const r1 = (e) => e.updateNodeInternals;
function o1() {
  const e = Ze(r1), [t] = _.useState(() => typeof ResizeObserver > "u" ? null : new ResizeObserver((n) => {
    const r = /* @__PURE__ */ new Map();
    n.forEach((o) => {
      const a = o.target.getAttribute("data-id");
      r.set(a, {
        id: a,
        nodeElement: o.target,
        force: !0
      });
    }), e(r);
  }));
  return _.useEffect(() => () => {
    t?.disconnect();
  }, [t]), t;
}
function i1({ node: e, nodeType: t, hasDimensions: n, resizeObserver: r }) {
  const o = _t(), a = _.useRef(null), l = _.useRef(null), u = _.useRef(e.sourcePosition), d = _.useRef(e.targetPosition), f = _.useRef(t), p = n && !!e.internals.handleBounds;
  return _.useEffect(() => {
    a.current && !e.hidden && (!p || l.current !== a.current) && (l.current && r?.unobserve(l.current), r?.observe(a.current), l.current = a.current);
  }, [p, e.hidden]), _.useEffect(() => () => {
    l.current && (r?.unobserve(l.current), l.current = null);
  }, []), _.useEffect(() => {
    if (a.current) {
      const m = f.current !== t, g = u.current !== e.sourcePosition, y = d.current !== e.targetPosition;
      (m || g || y) && (f.current = t, u.current = e.sourcePosition, d.current = e.targetPosition, o.getState().updateNodeInternals(/* @__PURE__ */ new Map([[e.id, { id: e.id, nodeElement: a.current, force: !0 }]])));
    }
  }, [e.id, t, e.sourcePosition, e.targetPosition]), a;
}
function a1({ id: e, onClick: t, onMouseEnter: n, onMouseMove: r, onMouseLeave: o, onContextMenu: a, onDoubleClick: l, nodesDraggable: u, elementsSelectable: d, nodesConnectable: f, nodesFocusable: p, resizeObserver: m, noDragClassName: g, noPanClassName: y, disableKeyboardA11y: w, rfId: v, nodeTypes: x, nodeClickDistance: E, onError: N }) {
  const { node: C, internals: A, isParent: R } = Ze((fe) => {
    const he = fe.nodeLookup.get(e), ye = fe.parentLookup.has(e);
    return {
      node: he,
      internals: he.internals,
      isParent: ye
    };
  }, St);
  let D = C.type || "default", T = x?.[D] || X0[D];
  T === void 0 && (N?.("003", io.error003(D)), D = "default", T = X0.default);
  const V = !!(C.draggable || u && typeof C.draggable > "u"), F = !!(C.selectable || d && typeof C.selectable > "u"), O = !!(C.connectable || f && typeof C.connectable > "u"), B = !!(C.focusable || p && typeof C.focusable > "u"), U = _t(), G = _3(C), z = i1({ node: C, nodeType: D, hasDimensions: G, resizeObserver: m }), $ = Q3({
    nodeRef: z,
    disabled: C.hidden || !V,
    noDragClassName: g,
    handleSelector: C.dragHandle,
    nodeId: e,
    isSelectable: F,
    nodeClickDistance: E
  }), L = J3();
  if (C.hidden)
    return null;
  const H = Zo(C), q = W7(C), Y = F || V || t || n || r || o, M = n ? (fe) => n(fe, { ...A.userNode }) : void 0, X = r ? (fe) => r(fe, { ...A.userNode }) : void 0, Q = o ? (fe) => o(fe, { ...A.userNode }) : void 0, P = a ? (fe) => a(fe, { ...A.userNode }) : void 0, te = l ? (fe) => l(fe, { ...A.userNode }) : void 0, ie = (fe) => {
    const { selectNodesOnDrag: he, nodeDragThreshold: ye } = U.getState();
    F && (!he || !V || ye > 0) && Zv({
      id: e,
      store: U,
      nodeRef: z
    }), t && t(fe, { ...A.userNode });
  }, ae = (fe) => {
    if (!(O3(fe.nativeEvent) || w))
      if (m3.includes(fe.key) && F) {
        const he = fe.key === "Escape";
        Zv({
          id: e,
          store: U,
          unselect: he,
          nodeRef: z
        });
      } else V && C.selected && Object.prototype.hasOwnProperty.call(Cp, fe.key) && (fe.preventDefault(), U.setState({
        ariaLiveMessage: `Moved selected node ${fe.key.replace("Arrow", "").toLowerCase()}. New position, x: ${~~A.positionAbsolute.x}, y: ${~~A.positionAbsolute.y}`
      }), L({
        direction: Cp[fe.key],
        factor: fe.shiftKey ? 4 : 1
      }));
  };
  return k.jsx("div", { className: Xt([
    "react-flow__node",
    `react-flow__node-${D}`,
    {
      // this is overwritable by passing `nopan` as a class name
      [y]: V
    },
    C.className,
    {
      selected: C.selected,
      selectable: F,
      parent: R,
      draggable: V,
      dragging: $
    }
  ]), ref: z, style: {
    zIndex: A.z,
    transform: `translate(${A.positionAbsolute.x}px,${A.positionAbsolute.y}px)`,
    pointerEvents: Y ? "all" : "none",
    visibility: G ? "visible" : "hidden",
    ...C.style,
    ...q
  }, "data-id": e, "data-testid": `rf__node-${e}`, onMouseEnter: M, onMouseMove: X, onMouseLeave: Q, onContextMenu: P, onClick: ie, onDoubleClick: te, onKeyDown: B ? ae : void 0, tabIndex: B ? 0 : void 0, role: B ? "button" : void 0, "aria-describedby": w ? void 0 : `${$3}-${v}`, "aria-label": C.ariaLabel, children: k.jsx(U7, { value: e, children: k.jsx(T, { id: e, data: C.data, type: D, positionAbsoluteX: A.positionAbsolute.x, positionAbsoluteY: A.positionAbsolute.y, selected: C.selected ?? !1, selectable: F, draggable: V, deletable: C.deletable ?? !0, isConnectable: O, sourcePosition: C.sourcePosition, targetPosition: C.targetPosition, dragging: $, dragHandle: C.dragHandle, zIndex: A.z, parentId: C.parentId, ...H }) }) });
}
const l1 = (e) => ({
  nodesDraggable: e.nodesDraggable,
  nodesConnectable: e.nodesConnectable,
  nodesFocusable: e.nodesFocusable,
  elementsSelectable: e.elementsSelectable,
  onError: e.onError
});
function n4(e) {
  const { nodesDraggable: t, nodesConnectable: n, nodesFocusable: r, elementsSelectable: o, onError: a } = Ze(l1, St), l = n1(e.onlyRenderVisibleElements), u = o1();
  return k.jsx("div", { className: "react-flow__nodes", style: hh, children: l.map((d) => (
    /*
     * The split of responsibilities between NodeRenderer and
     * NodeComponentWrapper may appear weird. However, its designed to
     * minimize the cost of updates when individual nodes change.
     *
     * For example, when youre dragging a single node, that node gets
     * updated multiple times per second. If `NodeRenderer` were to update
     * every time, it would have to re-run the `nodes.map()` loop every
     * time. This gets pricey with hundreds of nodes, especially if every
     * loop cycle does more than just rendering a JSX element!
     *
     * As a result of this choice, we took the following implementation
     * decisions:
     * - NodeRenderer subscribes *only* to node IDs  and therefore
     *   rerender *only* when visible nodes are added or removed.
     * - NodeRenderer performs all operations the result of which can be
     *   shared between nodes (such as creating the `ResizeObserver`
     *   instance, or subscribing to `selector`). This means extra prop
     *   drilling into `NodeComponentWrapper`, but it means we need to run
     *   these operations only once  instead of once per node.
     * - Any operations that youd normally write inside `nodes.map` are
     *   moved into `NodeComponentWrapper`. This ensures they are
     *   memorized  so if `NodeRenderer` *has* to rerender, it only
     *   needs to regenerate the list of nodes, nothing else.
     */
    k.jsx(a1, { id: d, nodeTypes: e.nodeTypes, nodeExtent: e.nodeExtent, onClick: e.onNodeClick, onMouseEnter: e.onNodeMouseEnter, onMouseMove: e.onNodeMouseMove, onMouseLeave: e.onNodeMouseLeave, onContextMenu: e.onNodeContextMenu, onDoubleClick: e.onNodeDoubleClick, noDragClassName: e.noDragClassName, noPanClassName: e.noPanClassName, rfId: e.rfId, disableKeyboardA11y: e.disableKeyboardA11y, resizeObserver: u, nodesDraggable: t, nodesConnectable: n, nodesFocusable: r, elementsSelectable: o, nodeClickDistance: e.nodeClickDistance, onError: a }, d)
  )) });
}
n4.displayName = "NodeRenderer";
const s1 = _.memo(n4);
function u1(e) {
  return Ze(_.useCallback((t) => {
    if (!e)
      return t.edges.map((r) => r.id);
    const n = [];
    if (t.width && t.height)
      for (const r of t.edges) {
        const o = t.nodeLookup.get(r.source), a = t.nodeLookup.get(r.target);
        o && a && y9({
          sourceNode: o,
          targetNode: a,
          width: t.width,
          height: t.height,
          transform: t.transform
        }) && n.push(r.id);
      }
    return n;
  }, [e]), St);
}
const c1 = ({ color: e = "none", strokeWidth: t = 1 }) => k.jsx("polyline", { style: {
  stroke: e,
  strokeWidth: t
}, strokeLinecap: "round", strokeLinejoin: "round", fill: "none", points: "-5,-4 0,0 -5,4" }), d1 = ({ color: e = "none", strokeWidth: t = 1 }) => k.jsx("polyline", { style: {
  stroke: e,
  fill: e,
  strokeWidth: t
}, strokeLinecap: "round", strokeLinejoin: "round", points: "-5,-4 0,0 -5,4 -5,-4" }), Z0 = {
  [Sp.Arrow]: c1,
  [Sp.ArrowClosed]: d1
};
function f1(e) {
  const t = _t();
  return _.useMemo(() => {
    var n, r;
    return Object.prototype.hasOwnProperty.call(Z0, e) ? Z0[e] : ((r = (n = t.getState()).onError) == null || r.call(n, "009", io.error009(e)), null);
  }, [e]);
}
const p1 = ({ id: e, type: t, color: n, width: r = 12.5, height: o = 12.5, markerUnits: a = "strokeWidth", strokeWidth: l, orient: u = "auto-start-reverse" }) => {
  const d = f1(t);
  return d ? k.jsx("marker", { className: "react-flow__arrowhead", id: e, markerWidth: `${r}`, markerHeight: `${o}`, viewBox: "-10 -10 20 20", markerUnits: a, orient: u, refX: "0", refY: "0", children: k.jsx(d, { color: n, strokeWidth: l }) }) : null;
}, r4 = ({ defaultColor: e, rfId: t }) => {
  const n = Ze((a) => a.edges), r = Ze((a) => a.defaultEdgeOptions), o = _.useMemo(() => E9(n, {
    id: t,
    defaultColor: e,
    defaultMarkerStart: r?.markerStart,
    defaultMarkerEnd: r?.markerEnd
  }), [n, r, t, e]);
  return o.length ? k.jsx("svg", { className: "react-flow__marker", children: k.jsx("defs", { children: o.map((a) => k.jsx(p1, { id: a.id, type: a.type, color: a.color, width: a.width, height: a.height, markerUnits: a.markerUnits, strokeWidth: a.strokeWidth, orient: a.orient }, a.id)) }) }) : null;
};
r4.displayName = "MarkerDefinitions";
var h1 = _.memo(r4);
function o4({ x: e, y: t, label: n, labelStyle: r, labelShowBg: o = !0, labelBgStyle: a, labelBgPadding: l = [2, 4], labelBgBorderRadius: u = 2, children: d, className: f, ...p }) {
  const [m, g] = _.useState({ x: 1, y: 0, width: 0, height: 0 }), y = Xt(["react-flow__edge-textwrapper", f]), w = _.useRef(null);
  return _.useEffect(() => {
    if (w.current) {
      const v = w.current.getBBox();
      g({
        x: v.x,
        y: v.y,
        width: v.width,
        height: v.height
      });
    }
  }, [n]), n ? k.jsxs("g", { transform: `translate(${e - m.width / 2} ${t - m.height / 2})`, className: y, visibility: m.width ? "visible" : "hidden", ...p, children: [o && k.jsx("rect", { width: m.width + 2 * l[0], x: -l[0], y: -l[1], height: m.height + 2 * l[1], className: "react-flow__edge-textbg", style: a, rx: u, ry: u }), k.jsx("text", { className: "react-flow__edge-text", y: m.height / 2, dy: "0.3em", ref: w, style: r, children: n }), d] }) : null;
}
o4.displayName = "EdgeText";
const m1 = _.memo(o4);
function Pc({ path: e, labelX: t, labelY: n, label: r, labelStyle: o, labelShowBg: a, labelBgStyle: l, labelBgPadding: u, labelBgBorderRadius: d, interactionWidth: f = 20, ...p }) {
  return k.jsxs(k.Fragment, { children: [k.jsx("path", { ...p, d: e, fill: "none", className: Xt(["react-flow__edge-path", p.className]) }), f && k.jsx("path", { d: e, fill: "none", strokeOpacity: 0, strokeWidth: f, className: "react-flow__edge-interaction" }), r && Ar(t) && Ar(n) ? k.jsx(m1, { x: t, y: n, label: r, labelStyle: o, labelShowBg: a, labelBgStyle: l, labelBgPadding: u, labelBgBorderRadius: d }) : null] });
}
function W0({ pos: e, x1: t, y1: n, x2: r, y2: o }) {
  return e === Ce.Left || e === Ce.Right ? [0.5 * (t + r), n] : [t, 0.5 * (n + o)];
}
function i4({ sourceX: e, sourceY: t, sourcePosition: n = Ce.Bottom, targetX: r, targetY: o, targetPosition: a = Ce.Top }) {
  const [l, u] = W0({
    pos: n,
    x1: e,
    y1: t,
    x2: r,
    y2: o
  }), [d, f] = W0({
    pos: a,
    x1: r,
    y1: o,
    x2: e,
    y2: t
  }), [p, m, g, y] = M3({
    sourceX: e,
    sourceY: t,
    targetX: r,
    targetY: o,
    sourceControlX: l,
    sourceControlY: u,
    targetControlX: d,
    targetControlY: f
  });
  return [
    `M${e},${t} C${l},${u} ${d},${f} ${r},${o}`,
    p,
    m,
    g,
    y
  ];
}
function a4(e) {
  return _.memo(({ id: t, sourceX: n, sourceY: r, targetX: o, targetY: a, sourcePosition: l, targetPosition: u, label: d, labelStyle: f, labelShowBg: p, labelBgStyle: m, labelBgPadding: g, labelBgBorderRadius: y, style: w, markerEnd: v, markerStart: x, interactionWidth: E }) => {
    const [N, C, A] = i4({
      sourceX: n,
      sourceY: r,
      sourcePosition: l,
      targetX: o,
      targetY: a,
      targetPosition: u
    }), R = e.isInternal ? void 0 : t;
    return k.jsx(Pc, { id: R, path: N, labelX: C, labelY: A, label: d, labelStyle: f, labelShowBg: p, labelBgStyle: m, labelBgPadding: g, labelBgBorderRadius: y, style: w, markerEnd: v, markerStart: x, interactionWidth: E });
  });
}
const g1 = a4({ isInternal: !1 }), l4 = a4({ isInternal: !0 });
g1.displayName = "SimpleBezierEdge";
l4.displayName = "SimpleBezierEdgeInternal";
function s4(e) {
  return _.memo(({ id: t, sourceX: n, sourceY: r, targetX: o, targetY: a, label: l, labelStyle: u, labelShowBg: d, labelBgStyle: f, labelBgPadding: p, labelBgBorderRadius: m, style: g, sourcePosition: y = Ce.Bottom, targetPosition: w = Ce.Top, markerEnd: v, markerStart: x, pathOptions: E, interactionWidth: N }) => {
    const [C, A, R] = Yv({
      sourceX: n,
      sourceY: r,
      sourcePosition: y,
      targetX: o,
      targetY: a,
      targetPosition: w,
      borderRadius: E?.borderRadius,
      offset: E?.offset
    }), D = e.isInternal ? void 0 : t;
    return k.jsx(Pc, { id: D, path: C, labelX: A, labelY: R, label: l, labelStyle: u, labelShowBg: d, labelBgStyle: f, labelBgPadding: p, labelBgBorderRadius: m, style: g, markerEnd: v, markerStart: x, interactionWidth: N });
  });
}
const u4 = s4({ isInternal: !1 }), c4 = s4({ isInternal: !0 });
u4.displayName = "SmoothStepEdge";
c4.displayName = "SmoothStepEdgeInternal";
function d4(e) {
  return _.memo(({ id: t, ...n }) => {
    var r;
    const o = e.isInternal ? void 0 : t;
    return k.jsx(u4, { ...n, id: o, pathOptions: _.useMemo(() => {
      var a;
      return { borderRadius: 0, offset: (a = n.pathOptions) == null ? void 0 : a.offset };
    }, [(r = n.pathOptions) == null ? void 0 : r.offset]) });
  });
}
const y1 = d4({ isInternal: !1 }), f4 = d4({ isInternal: !0 });
y1.displayName = "StepEdge";
f4.displayName = "StepEdgeInternal";
function p4(e) {
  return _.memo(({ id: t, sourceX: n, sourceY: r, targetX: o, targetY: a, label: l, labelStyle: u, labelShowBg: d, labelBgStyle: f, labelBgPadding: p, labelBgBorderRadius: m, style: g, markerEnd: y, markerStart: w, interactionWidth: v }) => {
    const [x, E, N] = R3({ sourceX: n, sourceY: r, targetX: o, targetY: a }), C = e.isInternal ? void 0 : t;
    return k.jsx(Pc, { id: C, path: x, labelX: E, labelY: N, label: l, labelStyle: u, labelShowBg: d, labelBgStyle: f, labelBgPadding: p, labelBgBorderRadius: m, style: g, markerEnd: y, markerStart: w, interactionWidth: v });
  });
}
const v1 = p4({ isInternal: !1 }), h4 = p4({ isInternal: !0 });
v1.displayName = "StraightEdge";
h4.displayName = "StraightEdgeInternal";
function m4(e) {
  return _.memo(({ id: t, sourceX: n, sourceY: r, targetX: o, targetY: a, sourcePosition: l = Ce.Bottom, targetPosition: u = Ce.Top, label: d, labelStyle: f, labelShowBg: p, labelBgStyle: m, labelBgPadding: g, labelBgBorderRadius: y, style: w, markerEnd: v, markerStart: x, pathOptions: E, interactionWidth: N }) => {
    const [C, A, R] = gw({
      sourceX: n,
      sourceY: r,
      sourcePosition: l,
      targetX: o,
      targetY: a,
      targetPosition: u,
      curvature: E?.curvature
    }), D = e.isInternal ? void 0 : t;
    return k.jsx(Pc, { id: D, path: C, labelX: A, labelY: R, label: d, labelStyle: f, labelShowBg: p, labelBgStyle: m, labelBgPadding: g, labelBgBorderRadius: y, style: w, markerEnd: v, markerStart: x, interactionWidth: N });
  });
}
const b1 = m4({ isInternal: !1 }), g4 = m4({ isInternal: !0 });
b1.displayName = "BezierEdge";
g4.displayName = "BezierEdgeInternal";
const K0 = {
  default: g4,
  straight: h4,
  step: f4,
  smoothstep: c4,
  simplebezier: l4
}, Q0 = {
  sourceX: null,
  sourceY: null,
  targetX: null,
  targetY: null,
  sourcePosition: null,
  targetPosition: null
}, w1 = (e, t, n) => n === Ce.Left ? e - t : n === Ce.Right ? e + t : e, x1 = (e, t, n) => n === Ce.Top ? e - t : n === Ce.Bottom ? e + t : e, J0 = "react-flow__edgeupdater";
function eE({ position: e, centerX: t, centerY: n, radius: r = 10, onMouseDown: o, onMouseEnter: a, onMouseOut: l, type: u }) {
  return k.jsx("circle", { onMouseDown: o, onMouseEnter: a, onMouseOut: l, className: Xt([J0, `${J0}-${u}`]), cx: w1(t, r, e), cy: x1(n, r, e), r, stroke: "transparent", fill: "transparent" });
}
function S1({ isReconnectable: e, reconnectRadius: t, edge: n, sourceX: r, sourceY: o, targetX: a, targetY: l, sourcePosition: u, targetPosition: d, onReconnect: f, onReconnectStart: p, onReconnectEnd: m, setReconnecting: g, setUpdateHover: y }) {
  const w = _t(), v = (A, R) => {
    if (A.button !== 0)
      return;
    const { autoPanOnConnect: D, domNode: T, isValidConnection: V, connectionMode: F, connectionRadius: O, lib: B, onConnectStart: U, onConnectEnd: G, cancelConnection: z, nodeLookup: $, rfId: L, panBy: H, updateConnection: q } = w.getState(), Y = R.type === "target";
    g(!0), p?.(A, n, R.type);
    const M = (Q, P) => {
      g(!1), m?.(Q, n, R.type, P);
    }, X = (Q) => f?.(n, Q);
    Gv.onPointerDown(A.nativeEvent, {
      autoPanOnConnect: D,
      connectionMode: F,
      connectionRadius: O,
      domNode: T,
      handleId: R.id,
      nodeId: R.nodeId,
      nodeLookup: $,
      isTarget: Y,
      edgeUpdaterType: R.type,
      lib: B,
      flowId: L,
      cancelConnection: z,
      panBy: H,
      isValidConnection: V,
      onConnect: X,
      onConnectStart: U,
      onConnectEnd: G,
      onReconnectEnd: M,
      updateConnection: q,
      getTransform: () => w.getState().transform,
      getFromHandle: () => w.getState().connection.fromHandle
    });
  }, x = (A) => v(A, { nodeId: n.target, id: n.targetHandle ?? null, type: "target" }), E = (A) => v(A, { nodeId: n.source, id: n.sourceHandle ?? null, type: "source" }), N = () => y(!0), C = () => y(!1);
  return k.jsxs(k.Fragment, { children: [(e === !0 || e === "source") && k.jsx(eE, { position: u, centerX: r, centerY: o, radius: t, onMouseDown: x, onMouseEnter: N, onMouseOut: C, type: "source" }), (e === !0 || e === "target") && k.jsx(eE, { position: d, centerX: a, centerY: l, radius: t, onMouseDown: E, onMouseEnter: N, onMouseOut: C, type: "target" })] });
}
function k1({ id: e, edgesFocusable: t, edgesReconnectable: n, elementsSelectable: r, onClick: o, onDoubleClick: a, onContextMenu: l, onMouseEnter: u, onMouseMove: d, onMouseLeave: f, reconnectRadius: p, onReconnect: m, onReconnectStart: g, onReconnectEnd: y, rfId: w, edgeTypes: v, noPanClassName: x, onError: E, disableKeyboardA11y: N }) {
  let C = Ze((xe) => xe.edgeLookup.get(e));
  const A = Ze((xe) => xe.defaultEdgeOptions);
  C = A ? { ...A, ...C } : C;
  let R = C.type || "default", D = v?.[R] || K0[R];
  D === void 0 && (E?.("011", io.error011(R)), R = "default", D = K0.default);
  const T = !!(C.focusable || t && typeof C.focusable > "u"), V = typeof m < "u" && (C.reconnectable || n && typeof C.reconnectable > "u"), F = !!(C.selectable || r && typeof C.selectable > "u"), O = _.useRef(null), [B, U] = _.useState(!1), [G, z] = _.useState(!1), $ = _t(), { zIndex: L, sourceX: H, sourceY: q, targetX: Y, targetY: M, sourcePosition: X, targetPosition: Q } = Ze(_.useCallback((xe) => {
    const Pe = xe.nodeLookup.get(C.source), Ve = xe.nodeLookup.get(C.target);
    if (!Pe || !Ve)
      return {
        zIndex: C.zIndex,
        ...Q0
      };
    const Rt = _9({
      id: e,
      sourceNode: Pe,
      targetNode: Ve,
      sourceHandle: C.sourceHandle || null,
      targetHandle: C.targetHandle || null,
      connectionMode: xe.connectionMode,
      onError: E
    });
    return {
      zIndex: g9({
        selected: C.selected,
        zIndex: C.zIndex,
        sourceNode: Pe,
        targetNode: Ve,
        elevateOnSelect: xe.elevateEdgesOnSelect
      }),
      ...Rt || Q0
    };
  }, [C.source, C.target, C.sourceHandle, C.targetHandle, C.selected, C.zIndex]), St), P = _.useMemo(() => C.markerStart ? `url('#${qv(C.markerStart, w)}')` : void 0, [C.markerStart, w]), te = _.useMemo(() => C.markerEnd ? `url('#${qv(C.markerEnd, w)}')` : void 0, [C.markerEnd, w]);
  if (C.hidden || H === null || q === null || Y === null || M === null)
    return null;
  const ie = (xe) => {
    var Pe;
    const { addSelectedEdges: Ve, unselectNodesAndEdges: Rt, multiSelectionActive: Pt } = $.getState();
    F && ($.setState({ nodesSelectionActive: !1 }), C.selected && Pt ? (Rt({ nodes: [], edges: [C] }), (Pe = O.current) == null || Pe.blur()) : Ve([e])), o && o(xe, C);
  }, ae = a ? (xe) => {
    a(xe, { ...C });
  } : void 0, fe = l ? (xe) => {
    l(xe, { ...C });
  } : void 0, he = u ? (xe) => {
    u(xe, { ...C });
  } : void 0, ye = d ? (xe) => {
    d(xe, { ...C });
  } : void 0, Ee = f ? (xe) => {
    f(xe, { ...C });
  } : void 0, we = (xe) => {
    var Pe;
    if (!N && m3.includes(xe.key) && F) {
      const { unselectNodesAndEdges: Ve, addSelectedEdges: Rt } = $.getState();
      xe.key === "Escape" ? ((Pe = O.current) == null || Pe.blur(), Ve({ edges: [C] })) : Rt([e]);
    }
  };
  return k.jsx("svg", { style: { zIndex: L }, children: k.jsxs("g", { className: Xt([
    "react-flow__edge",
    `react-flow__edge-${R}`,
    C.className,
    x,
    {
      selected: C.selected,
      animated: C.animated,
      inactive: !F && !o,
      updating: B,
      selectable: F
    }
  ]), onClick: ie, onDoubleClick: ae, onContextMenu: fe, onMouseEnter: he, onMouseMove: ye, onMouseLeave: Ee, onKeyDown: T ? we : void 0, tabIndex: T ? 0 : void 0, role: T ? "button" : "img", "data-id": e, "data-testid": `rf__edge-${e}`, "aria-label": C.ariaLabel === null ? void 0 : C.ariaLabel || `Edge from ${C.source} to ${C.target}`, "aria-describedby": T ? `${Y3}-${w}` : void 0, ref: O, children: [!G && k.jsx(D, { id: e, source: C.source, target: C.target, type: C.type, selected: C.selected, animated: C.animated, selectable: F, deletable: C.deletable ?? !0, label: C.label, labelStyle: C.labelStyle, labelShowBg: C.labelShowBg, labelBgStyle: C.labelBgStyle, labelBgPadding: C.labelBgPadding, labelBgBorderRadius: C.labelBgBorderRadius, sourceX: H, sourceY: q, targetX: Y, targetY: M, sourcePosition: X, targetPosition: Q, data: C.data, style: C.style, sourceHandleId: C.sourceHandle, targetHandleId: C.targetHandle, markerStart: P, markerEnd: te, pathOptions: "pathOptions" in C ? C.pathOptions : void 0, interactionWidth: C.interactionWidth }), V && k.jsx(S1, { edge: C, isReconnectable: V, reconnectRadius: p, onReconnect: m, onReconnectStart: g, onReconnectEnd: y, sourceX: H, sourceY: q, targetX: Y, targetY: M, sourcePosition: X, targetPosition: Q, setUpdateHover: U, setReconnecting: z })] }) });
}
const _1 = (e) => ({
  edgesFocusable: e.edgesFocusable,
  edgesReconnectable: e.edgesReconnectable,
  elementsSelectable: e.elementsSelectable,
  connectionMode: e.connectionMode,
  onError: e.onError
});
function y4({ defaultMarkerColor: e, onlyRenderVisibleElements: t, rfId: n, edgeTypes: r, noPanClassName: o, onReconnect: a, onEdgeContextMenu: l, onEdgeMouseEnter: u, onEdgeMouseMove: d, onEdgeMouseLeave: f, onEdgeClick: p, reconnectRadius: m, onEdgeDoubleClick: g, onReconnectStart: y, onReconnectEnd: w, disableKeyboardA11y: v }) {
  const { edgesFocusable: x, edgesReconnectable: E, elementsSelectable: N, onError: C } = Ze(_1, St), A = u1(t);
  return k.jsxs("div", { className: "react-flow__edges", children: [k.jsx(h1, { defaultColor: e, rfId: n }), A.map((R) => k.jsx(k1, { id: R, edgesFocusable: x, edgesReconnectable: E, elementsSelectable: N, noPanClassName: o, onReconnect: a, onContextMenu: l, onMouseEnter: u, onMouseMove: d, onMouseLeave: f, onClick: p, reconnectRadius: m, onDoubleClick: g, onReconnectStart: y, onReconnectEnd: w, rfId: n, onError: C, edgeTypes: r, disableKeyboardA11y: v }, R))] });
}
y4.displayName = "EdgeRenderer";
const E1 = _.memo(y4), C1 = (e) => `translate(${e.transform[0]}px,${e.transform[1]}px) scale(${e.transform[2]})`;
function O1({ children: e }) {
  const t = Ze(C1);
  return k.jsx("div", { className: "react-flow__viewport xyflow__viewport react-flow__container", style: { transform: t }, children: e });
}
function N1(e) {
  const t = zc(), n = _.useRef(!1);
  _.useEffect(() => {
    !n.current && t.viewportInitialized && e && (setTimeout(() => e(t), 1), n.current = !0);
  }, [e, t.viewportInitialized]);
}
const M1 = (e) => {
  var t;
  return (t = e.panZoom) == null ? void 0 : t.syncViewport;
};
function A1(e) {
  const t = Ze(M1), n = _t();
  return _.useEffect(() => {
    e && (t?.(e), n.setState({ transform: [e.x, e.y, e.zoom] }));
  }, [e, t]), null;
}
function R1(e) {
  return e.connection.inProgress ? { ...e.connection, to: Tc(e.connection.to, e.transform) } : { ...e.connection };
}
function j1(e) {
  return R1;
}
function D1(e) {
  const t = j1();
  return Ze(t, St);
}
const T1 = (e) => ({
  nodesConnectable: e.nodesConnectable,
  isValid: e.connection.isValid,
  inProgress: e.connection.inProgress,
  width: e.width,
  height: e.height
});
function z1({ containerStyle: e, style: t, type: n, component: r }) {
  const { nodesConnectable: o, width: a, height: l, isValid: u, inProgress: d } = Ze(T1, St);
  return a && o && d ? k.jsx("svg", { style: e, width: a, height: l, className: "react-flow__connectionline react-flow__container", children: k.jsx("g", { className: Xt(["react-flow__connection", y3(u)]), children: k.jsx(v4, { style: t, type: n, CustomComponent: r, isValid: u }) }) }) : null;
}
const v4 = ({ style: e, type: t = zi.Bezier, CustomComponent: n, isValid: r }) => {
  const { inProgress: o, from: a, fromNode: l, fromHandle: u, fromPosition: d, to: f, toNode: p, toHandle: m, toPosition: g } = D1();
  if (!o)
    return;
  if (n)
    return k.jsx(n, { connectionLineType: t, connectionLineStyle: e, fromNode: l, fromHandle: u, fromX: a.x, fromY: a.y, toX: f.x, toY: f.y, fromPosition: d, toPosition: g, connectionStatus: y3(r), toNode: p, toHandle: m });
  let y = "";
  const w = {
    sourceX: a.x,
    sourceY: a.y,
    sourcePosition: d,
    targetX: f.x,
    targetY: f.y,
    targetPosition: g
  };
  switch (t) {
    case zi.Bezier:
      [y] = gw(w);
      break;
    case zi.SimpleBezier:
      [y] = i4(w);
      break;
    case zi.Step:
      [y] = Yv({
        ...w,
        borderRadius: 0
      });
      break;
    case zi.SmoothStep:
      [y] = Yv(w);
      break;
    default:
      [y] = R3(w);
  }
  return k.jsx("path", { d: y, fill: "none", className: "react-flow__connection-path", style: e });
};
v4.displayName = "ConnectionLine";
const P1 = {};
function tE(e = P1) {
  _.useRef(e), _t(), _.useEffect(() => {
  }, [e]);
}
function L1() {
  _t(), _.useRef(!1), _.useEffect(() => {
  }, []);
}
function b4({ nodeTypes: e, edgeTypes: t, onInit: n, onNodeClick: r, onEdgeClick: o, onNodeDoubleClick: a, onEdgeDoubleClick: l, onNodeMouseEnter: u, onNodeMouseMove: d, onNodeMouseLeave: f, onNodeContextMenu: p, onSelectionContextMenu: m, onSelectionStart: g, onSelectionEnd: y, connectionLineType: w, connectionLineStyle: v, connectionLineComponent: x, connectionLineContainerStyle: E, selectionKeyCode: N, selectionOnDrag: C, selectionMode: A, multiSelectionKeyCode: R, panActivationKeyCode: D, zoomActivationKeyCode: T, deleteKeyCode: V, onlyRenderVisibleElements: F, elementsSelectable: O, defaultViewport: B, translateExtent: U, minZoom: G, maxZoom: z, preventScrolling: $, defaultMarkerColor: L, zoomOnScroll: H, zoomOnPinch: q, panOnScroll: Y, panOnScrollSpeed: M, panOnScrollMode: X, zoomOnDoubleClick: Q, panOnDrag: P, onPaneClick: te, onPaneMouseEnter: ie, onPaneMouseMove: ae, onPaneMouseLeave: fe, onPaneScroll: he, onPaneContextMenu: ye, paneClickDistance: Ee, nodeClickDistance: we, onEdgeContextMenu: xe, onEdgeMouseEnter: Pe, onEdgeMouseMove: Ve, onEdgeMouseLeave: Rt, reconnectRadius: Pt, onReconnect: lt, onReconnectStart: wr, onReconnectEnd: en, noDragClassName: Bn, noWheelClassName: je, noPanClassName: ho, disableKeyboardA11y: Lr, nodeExtent: Ki, rfId: mo, viewport: le, onViewportChange: pe }) {
  return tE(e), tE(t), L1(), N1(n), A1(le), k.jsx(e1, { onPaneClick: te, onPaneMouseEnter: ie, onPaneMouseMove: ae, onPaneMouseLeave: fe, onPaneContextMenu: ye, onPaneScroll: he, paneClickDistance: Ee, deleteKeyCode: V, selectionKeyCode: N, selectionOnDrag: C, selectionMode: A, onSelectionStart: g, onSelectionEnd: y, multiSelectionKeyCode: R, panActivationKeyCode: D, zoomActivationKeyCode: T, elementsSelectable: O, zoomOnScroll: H, zoomOnPinch: q, zoomOnDoubleClick: Q, panOnScroll: Y, panOnScrollSpeed: M, panOnScrollMode: X, panOnDrag: P, defaultViewport: B, translateExtent: U, minZoom: G, maxZoom: z, onSelectionContextMenu: m, preventScrolling: $, noDragClassName: Bn, noWheelClassName: je, noPanClassName: ho, disableKeyboardA11y: Lr, onViewportChange: pe, isControlledViewport: !!le, children: k.jsxs(O1, { children: [k.jsx(E1, { edgeTypes: t, onEdgeClick: o, onEdgeDoubleClick: l, onReconnect: lt, onReconnectStart: wr, onReconnectEnd: en, onlyRenderVisibleElements: F, onEdgeContextMenu: xe, onEdgeMouseEnter: Pe, onEdgeMouseMove: Ve, onEdgeMouseLeave: Rt, reconnectRadius: Pt, defaultMarkerColor: L, noPanClassName: ho, disableKeyboardA11y: Lr, rfId: mo }), k.jsx(z1, { style: v, type: w, component: x, containerStyle: E }), k.jsx("div", { className: "react-flow__edgelabel-renderer" }), k.jsx(s1, { nodeTypes: e, onNodeClick: r, onNodeDoubleClick: a, onNodeMouseEnter: u, onNodeMouseMove: d, onNodeMouseLeave: f, onNodeContextMenu: p, nodeClickDistance: we, onlyRenderVisibleElements: F, noPanClassName: ho, noDragClassName: Bn, disableKeyboardA11y: Lr, nodeExtent: Ki, rfId: mo }), k.jsx("div", { className: "react-flow__viewport-portal" })] }) });
}
b4.displayName = "GraphView";
const I1 = _.memo(b4), nE = ({ nodes: e, edges: t, defaultNodes: n, defaultEdges: r, width: o, height: a, fitView: l, nodeOrigin: u, nodeExtent: d } = {}) => {
  const f = /* @__PURE__ */ new Map(), p = /* @__PURE__ */ new Map(), m = /* @__PURE__ */ new Map(), g = /* @__PURE__ */ new Map(), y = r ?? t ?? [], w = n ?? e ?? [], v = u ?? [0, 0], x = d ?? uc;
  D3(m, g, y), Xv(w, f, p, {
    nodeOrigin: v,
    nodeExtent: x,
    elevateNodesOnSelect: !1
  });
  let E = [0, 0, 1];
  if (l && o && a) {
    const N = Dc(f, {
      filter: (D) => !!((D.width || D.initialWidth) && (D.height || D.initialHeight))
    }), { x: C, y: A, zoom: R } = hw(N, o, a, 0.5, 2, 0.1);
    E = [C, A, R];
  }
  return {
    rfId: "1",
    width: 0,
    height: 0,
    transform: E,
    nodes: w,
    nodeLookup: f,
    parentLookup: p,
    edges: y,
    edgeLookup: g,
    connectionLookup: m,
    onNodesChange: null,
    onEdgesChange: null,
    hasDefaultNodes: n !== void 0,
    hasDefaultEdges: r !== void 0,
    panZoom: null,
    minZoom: 0.5,
    maxZoom: 2,
    translateExtent: uc,
    nodeExtent: x,
    nodesSelectionActive: !1,
    userSelectionActive: !1,
    userSelectionRect: null,
    connectionMode: rs.Strict,
    domNode: null,
    paneDragging: !1,
    noPanClassName: "nopan",
    nodeOrigin: v,
    nodeDragThreshold: 1,
    snapGrid: [15, 15],
    snapToGrid: !1,
    nodesDraggable: !0,
    nodesConnectable: !0,
    nodesFocusable: !0,
    edgesFocusable: !0,
    edgesReconnectable: !0,
    elementsSelectable: !0,
    elevateNodesOnSelect: !0,
    elevateEdgesOnSelect: !1,
    selectNodesOnDrag: !0,
    multiSelectionActive: !1,
    fitViewQueued: l ?? !1,
    fitViewOptions: void 0,
    fitViewResolver: null,
    connection: { ...g3 },
    connectionClickStartHandle: null,
    connectOnClick: !0,
    ariaLiveMessage: "",
    autoPanOnConnect: !0,
    autoPanOnNodeDrag: !0,
    autoPanSpeed: 15,
    connectionRadius: 20,
    onError: f9,
    isValidConnection: void 0,
    onSelectionChangeHandlers: [],
    lib: "react",
    debug: !1
  };
}, B1 = ({ nodes: e, edges: t, defaultNodes: n, defaultEdges: r, width: o, height: a, fitView: l, nodeOrigin: u, nodeExtent: d }) => o7((f, p) => {
  async function m() {
    const { nodeLookup: g, panZoom: y, fitViewOptions: w, fitViewResolver: v, width: x, height: E, minZoom: N, maxZoom: C } = p();
    y && (await c9({
      nodes: g,
      width: x,
      height: E,
      panZoom: y,
      minZoom: N,
      maxZoom: C
    }, w), v?.resolve(!0), f({ fitViewResolver: null }));
  }
  return {
    ...nE({ nodes: e, edges: t, width: o, height: a, fitView: l, nodeOrigin: u, nodeExtent: d, defaultNodes: n, defaultEdges: r }),
    setNodes: (g) => {
      const { nodeLookup: y, parentLookup: w, nodeOrigin: v, elevateNodesOnSelect: x, fitViewQueued: E } = p(), N = Xv(g, y, w, {
        nodeOrigin: v,
        nodeExtent: d,
        elevateNodesOnSelect: x,
        checkEquality: !0
      });
      E && N ? (m(), f({ nodes: g, fitViewQueued: !1, fitViewOptions: void 0 })) : f({ nodes: g });
    },
    setEdges: (g) => {
      const { connectionLookup: y, edgeLookup: w } = p();
      D3(y, w, g), f({ edges: g });
    },
    setDefaultNodesAndEdges: (g, y) => {
      if (g) {
        const { setNodes: w } = p();
        w(g), f({ hasDefaultNodes: !0 });
      }
      if (y) {
        const { setEdges: w } = p();
        w(y), f({ hasDefaultEdges: !0 });
      }
    },
    /*
     * Every node gets registerd at a ResizeObserver. Whenever a node
     * changes its dimensions, this function is called to measure the
     * new dimensions and update the nodes.
     */
    updateNodeInternals: (g) => {
      const { triggerNodeChanges: y, nodeLookup: w, parentLookup: v, domNode: x, nodeOrigin: E, nodeExtent: N, debug: C, fitViewQueued: A } = p(), { changes: R, updatedInternals: D } = A9(g, w, v, x, E, N);
      D && (O9(w, v, { nodeOrigin: E, nodeExtent: N }), A ? (m(), f({ fitViewQueued: !1, fitViewOptions: void 0 })) : f({}), R?.length > 0 && (C && console.log("React Flow: trigger node changes", R), y?.(R)));
    },
    updateNodePositions: (g, y = !1) => {
      const w = [], v = [], { nodeLookup: x, triggerNodeChanges: E } = p();
      for (const [N, C] of g) {
        const A = x.get(N), R = !!(A != null && A.expandParent && A != null && A.parentId && C != null && C.position), D = {
          id: N,
          type: "position",
          position: R ? {
            x: Math.max(0, C.position.x),
            y: Math.max(0, C.position.y)
          } : C.position,
          dragging: y
        };
        R && A.parentId && w.push({
          id: N,
          parentId: A.parentId,
          rect: {
            ...C.internals.positionAbsolute,
            width: C.measured.width ?? 0,
            height: C.measured.height ?? 0
          }
        }), v.push(D);
      }
      if (w.length > 0) {
        const { parentLookup: N, nodeOrigin: C } = p(), A = ww(w, x, N, C);
        v.push(...A);
      }
      E(v);
    },
    triggerNodeChanges: (g) => {
      const { onNodesChange: y, setNodes: w, nodes: v, hasDefaultNodes: x, debug: E } = p();
      if (g != null && g.length) {
        if (x) {
          const N = G3(g, v);
          w(N);
        }
        E && console.log("React Flow: trigger node changes", g), y?.(g);
      }
    },
    triggerEdgeChanges: (g) => {
      const { onEdgesChange: y, setEdges: w, edges: v, hasDefaultEdges: x, debug: E } = p();
      if (g != null && g.length) {
        if (x) {
          const N = Z3(g, v);
          w(N);
        }
        E && console.log("React Flow: trigger edge changes", g), y?.(g);
      }
    },
    addSelectedNodes: (g) => {
      const { multiSelectionActive: y, edgeLookup: w, nodeLookup: v, triggerNodeChanges: x, triggerEdgeChanges: E } = p();
      if (y) {
        const N = g.map((C) => va(C, !0));
        x(N);
        return;
      }
      x(Fl(v, /* @__PURE__ */ new Set([...g]), !0)), E(Fl(w));
    },
    addSelectedEdges: (g) => {
      const { multiSelectionActive: y, edgeLookup: w, nodeLookup: v, triggerNodeChanges: x, triggerEdgeChanges: E } = p();
      if (y) {
        const N = g.map((C) => va(C, !0));
        E(N);
        return;
      }
      E(Fl(w, /* @__PURE__ */ new Set([...g]))), x(Fl(v, /* @__PURE__ */ new Set(), !0));
    },
    unselectNodesAndEdges: ({ nodes: g, edges: y } = {}) => {
      const { edges: w, nodes: v, nodeLookup: x, triggerNodeChanges: E, triggerEdgeChanges: N } = p(), C = g || v, A = y || w, R = C.map((T) => {
        const V = x.get(T.id);
        return V && (V.selected = !1), va(T.id, !1);
      }), D = A.map((T) => va(T.id, !1));
      E(R), N(D);
    },
    setMinZoom: (g) => {
      const { panZoom: y, maxZoom: w } = p();
      y?.setScaleExtent([g, w]), f({ minZoom: g });
    },
    setMaxZoom: (g) => {
      const { panZoom: y, minZoom: w } = p();
      y?.setScaleExtent([w, g]), f({ maxZoom: g });
    },
    setTranslateExtent: (g) => {
      var y;
      (y = p().panZoom) == null || y.setTranslateExtent(g), f({ translateExtent: g });
    },
    setPaneClickDistance: (g) => {
      var y;
      (y = p().panZoom) == null || y.setClickDistance(g);
    },
    resetSelectedElements: () => {
      const { edges: g, nodes: y, triggerNodeChanges: w, triggerEdgeChanges: v } = p(), x = y.reduce((N, C) => C.selected ? [...N, va(C.id, !1)] : N, []), E = g.reduce((N, C) => C.selected ? [...N, va(C.id, !1)] : N, []);
      w(x), v(E);
    },
    setNodeExtent: (g) => {
      const { nodes: y, nodeLookup: w, parentLookup: v, nodeOrigin: x, elevateNodesOnSelect: E, nodeExtent: N } = p();
      g[0][0] === N[0][0] && g[0][1] === N[0][1] && g[1][0] === N[1][0] && g[1][1] === N[1][1] || (Xv(y, w, v, {
        nodeOrigin: x,
        nodeExtent: g,
        elevateNodesOnSelect: E,
        checkEquality: !1
      }), f({ nodeExtent: g }));
    },
    panBy: (g) => {
      const { transform: y, width: w, height: v, panZoom: x, translateExtent: E } = p();
      return R9({ delta: g, panZoom: x, transform: y, translateExtent: E, width: w, height: v });
    },
    cancelConnection: () => {
      f({
        connection: { ...g3 }
      });
    },
    updateConnection: (g) => {
      f({ connection: g });
    },
    reset: () => f({ ...nE() })
  };
}, Object.is);
function V1({ initialNodes: e, initialEdges: t, defaultNodes: n, defaultEdges: r, initialWidth: o, initialHeight: a, fitView: l, nodeOrigin: u, nodeExtent: d, children: f }) {
  const [p] = _.useState(() => B1({
    nodes: e,
    edges: t,
    defaultNodes: n,
    defaultEdges: r,
    width: o,
    height: a,
    fitView: l,
    nodeOrigin: u,
    nodeExtent: d
  }));
  return k.jsx(i7, { value: p, children: k.jsx(N7, { children: f }) });
}
function H1({ children: e, nodes: t, edges: n, defaultNodes: r, defaultEdges: o, width: a, height: l, fitView: u, nodeOrigin: d, nodeExtent: f }) {
  return _.useContext(fh) ? k.jsx(k.Fragment, { children: e }) : k.jsx(V1, { initialNodes: t, initialEdges: n, defaultNodes: r, defaultEdges: o, initialWidth: a, initialHeight: l, fitView: u, nodeOrigin: d, nodeExtent: f, children: e });
}
const U1 = {
  width: "100%",
  height: "100%",
  overflow: "hidden",
  position: "relative",
  zIndex: 0
};
function F1({ nodes: e, edges: t, defaultNodes: n, defaultEdges: r, className: o, nodeTypes: a, edgeTypes: l, onNodeClick: u, onEdgeClick: d, onInit: f, onMove: p, onMoveStart: m, onMoveEnd: g, onConnect: y, onConnectStart: w, onConnectEnd: v, onClickConnectStart: x, onClickConnectEnd: E, onNodeMouseEnter: N, onNodeMouseMove: C, onNodeMouseLeave: A, onNodeContextMenu: R, onNodeDoubleClick: D, onNodeDragStart: T, onNodeDrag: V, onNodeDragStop: F, onNodesDelete: O, onEdgesDelete: B, onDelete: U, onSelectionChange: G, onSelectionDragStart: z, onSelectionDrag: $, onSelectionDragStop: L, onSelectionContextMenu: H, onSelectionStart: q, onSelectionEnd: Y, onBeforeDelete: M, connectionMode: X, connectionLineType: Q = zi.Bezier, connectionLineStyle: P, connectionLineComponent: te, connectionLineContainerStyle: ie, deleteKeyCode: ae = "Backspace", selectionKeyCode: fe = "Shift", selectionOnDrag: he = !1, selectionMode: ye = cc.Full, panActivationKeyCode: Ee = "Space", multiSelectionKeyCode: we = Ep() ? "Meta" : "Control", zoomActivationKeyCode: xe = Ep() ? "Meta" : "Control", snapToGrid: Pe, snapGrid: Ve, onlyRenderVisibleElements: Rt = !1, selectNodesOnDrag: Pt, nodesDraggable: lt, nodesConnectable: wr, nodesFocusable: en, nodeOrigin: Bn = q3, edgesFocusable: je, edgesReconnectable: ho, elementsSelectable: Lr = !0, defaultViewport: Ki = v7, minZoom: mo = 0.5, maxZoom: le = 2, translateExtent: pe = uc, preventScrolling: ke = !0, nodeExtent: Le, defaultMarkerColor: ot = "#b1b1b7", zoomOnScroll: En = !0, zoomOnPinch: Ir = !0, panOnScroll: sn = !1, panOnScrollSpeed: ir = 0.5, panOnScrollMode: vn = Oa.Free, zoomOnDoubleClick: Lt = !0, panOnDrag: Cn = !0, onPaneClick: Vn, onPaneMouseEnter: Jc, onPaneMouseMove: ed, onPaneMouseLeave: Os, onPaneScroll: Qi, onPaneContextMenu: dm, paneClickDistance: Ns = 0, nodeClickDistance: td = 0, children: Ms, onReconnect: As, onReconnectStart: nd, onReconnectEnd: fm, onEdgeContextMenu: Br, onEdgeDoubleClick: Wt, onEdgeMouseEnter: un, onEdgeMouseMove: ni, onEdgeMouseLeave: Rs, reconnectRadius: pm = 10, onNodesChange: hm, onEdgesChange: rd, noDragClassName: Ji = "nodrag", noWheelClassName: js = "nowheel", noPanClassName: go = "nopan", fitView: yo, fitViewOptions: ea, connectOnClick: ri, attributionPosition: It, proOptions: od, defaultEdgeOptions: id, elevateNodesOnSelect: vo, elevateEdgesOnSelect: oi, disableKeyboardA11y: ad = !1, autoPanOnConnect: ld, autoPanOnNodeDrag: sd, autoPanSpeed: mm, connectionRadius: $a, isValidConnection: Ya, onError: xr, style: Ds, id: Ts, nodeDragThreshold: ii, viewport: zs, onViewportChange: Ps, width: gm, height: ud, colorMode: On = "light", debug: cd, onScroll: Ls, ...qa }, dd) {
  const ai = Ts || "1", ym = S7(On), Nn = _.useCallback((Xa) => {
    Xa.currentTarget.scrollTo({ top: 0, left: 0, behavior: "instant" }), Ls?.(Xa);
  }, [Ls]);
  return k.jsx("div", { "data-testid": "rf__wrapper", ...qa, onScroll: Nn, style: { ...Ds, ...U1 }, ref: dd, className: Xt(["react-flow", o, ym]), id: Ts, children: k.jsxs(H1, { nodes: e, edges: t, width: gm, height: ud, fitView: yo, nodeOrigin: Bn, nodeExtent: Le, children: [k.jsx(I1, { onInit: f, onNodeClick: u, onEdgeClick: d, onNodeMouseEnter: N, onNodeMouseMove: C, onNodeMouseLeave: A, onNodeContextMenu: R, onNodeDoubleClick: D, nodeTypes: a, edgeTypes: l, connectionLineType: Q, connectionLineStyle: P, connectionLineComponent: te, connectionLineContainerStyle: ie, selectionKeyCode: fe, selectionOnDrag: he, selectionMode: ye, deleteKeyCode: ae, multiSelectionKeyCode: we, panActivationKeyCode: Ee, zoomActivationKeyCode: xe, onlyRenderVisibleElements: Rt, defaultViewport: Ki, translateExtent: pe, minZoom: mo, maxZoom: le, preventScrolling: ke, zoomOnScroll: En, zoomOnPinch: Ir, zoomOnDoubleClick: Lt, panOnScroll: sn, panOnScrollSpeed: ir, panOnScrollMode: vn, panOnDrag: Cn, onPaneClick: Vn, onPaneMouseEnter: Jc, onPaneMouseMove: ed, onPaneMouseLeave: Os, onPaneScroll: Qi, onPaneContextMenu: dm, paneClickDistance: Ns, nodeClickDistance: td, onSelectionContextMenu: H, onSelectionStart: q, onSelectionEnd: Y, onReconnect: As, onReconnectStart: nd, onReconnectEnd: fm, onEdgeContextMenu: Br, onEdgeDoubleClick: Wt, onEdgeMouseEnter: un, onEdgeMouseMove: ni, onEdgeMouseLeave: Rs, reconnectRadius: pm, defaultMarkerColor: ot, noDragClassName: Ji, noWheelClassName: js, noPanClassName: go, rfId: ai, disableKeyboardA11y: ad, nodeExtent: Le, viewport: zs, onViewportChange: Ps }), k.jsx(x7, { nodes: e, edges: t, defaultNodes: n, defaultEdges: r, onConnect: y, onConnectStart: w, onConnectEnd: v, onClickConnectStart: x, onClickConnectEnd: E, nodesDraggable: lt, nodesConnectable: wr, nodesFocusable: en, edgesFocusable: je, edgesReconnectable: ho, elementsSelectable: Lr, elevateNodesOnSelect: vo, elevateEdgesOnSelect: oi, minZoom: mo, maxZoom: le, nodeExtent: Le, onNodesChange: hm, onEdgesChange: rd, snapToGrid: Pe, snapGrid: Ve, connectionMode: X, translateExtent: pe, connectOnClick: ri, defaultEdgeOptions: id, fitView: yo, fitViewOptions: ea, onNodesDelete: O, onEdgesDelete: B, onDelete: U, onNodeDragStart: T, onNodeDrag: V, onNodeDragStop: F, onSelectionDrag: $, onSelectionDragStart: z, onSelectionDragStop: L, onMove: p, onMoveStart: m, onMoveEnd: g, noPanClassName: go, nodeOrigin: Bn, rfId: ai, autoPanOnConnect: ld, autoPanOnNodeDrag: sd, autoPanSpeed: mm, onError: xr, connectionRadius: $a, isValidConnection: Ya, selectNodesOnDrag: Pt, nodeDragThreshold: ii, onBeforeDelete: M, paneClickDistance: Ns, debug: cd }), k.jsx(y7, { onSelectionChange: G }), Ms, k.jsx(f7, { proOptions: od, position: It }), k.jsx(c7, { rfId: ai, disableKeyboardA11y: ad })] }) });
}
var $1 = W3(F1);
const Y1 = (e) => e.nodes;
function q1() {
  return Ze(Y1, St);
}
const X1 = (e) => e.edges;
function G1() {
  return Ze(X1, St);
}
function Z1({ dimensions: e, lineWidth: t, variant: n, className: r }) {
  return k.jsx("path", { strokeWidth: t, d: `M${e[0] / 2} 0 V${e[1]} M0 ${e[1] / 2} H${e[0]}`, className: Xt(["react-flow__background-pattern", n, r]) });
}
function W1({ radius: e, className: t }) {
  return k.jsx("circle", { cx: e, cy: e, r: e, className: Xt(["react-flow__background-pattern", "dots", t]) });
}
var Vi;
(function(e) {
  e.Lines = "lines", e.Dots = "dots", e.Cross = "cross";
})(Vi || (Vi = {}));
const K1 = {
  [Vi.Dots]: 1,
  [Vi.Lines]: 1,
  [Vi.Cross]: 6
}, Q1 = (e) => ({ transform: e.transform, patternId: `pattern-${e.rfId}` });
function w4({
  id: e,
  variant: t = Vi.Dots,
  // only used for dots and cross
  gap: n = 20,
  // only used for lines and cross
  size: r,
  lineWidth: o = 1,
  offset: a = 0,
  color: l,
  bgColor: u,
  style: d,
  className: f,
  patternClassName: p
}) {
  const m = _.useRef(null), { transform: g, patternId: y } = Ze(Q1, St), w = r || K1[t], v = t === Vi.Dots, x = t === Vi.Cross, E = Array.isArray(n) ? n : [n, n], N = [E[0] * g[2] || 1, E[1] * g[2] || 1], C = w * g[2], A = Array.isArray(a) ? a : [a, a], R = x ? [C, C] : N, D = [
    A[0] * g[2] || 1 + R[0] / 2,
    A[1] * g[2] || 1 + R[1] / 2
  ], T = `${y}${e || ""}`;
  return k.jsxs("svg", { className: Xt(["react-flow__background", f]), style: {
    ...d,
    ...hh,
    "--xy-background-color-props": u,
    "--xy-background-pattern-color-props": l
  }, ref: m, "data-testid": "rf__background", children: [k.jsx("pattern", { id: T, x: g[0] % N[0], y: g[1] % N[1], width: N[0], height: N[1], patternUnits: "userSpaceOnUse", patternTransform: `translate(-${D[0]},-${D[1]})`, children: v ? k.jsx(W1, { radius: C / 2, className: p }) : k.jsx(Z1, { dimensions: R, lineWidth: o, variant: t, className: p }) }), k.jsx("rect", { x: "0", y: "0", width: "100%", height: "100%", fill: `url(#${T})` })] });
}
w4.displayName = "Background";
const J1 = _.memo(w4);
function eI() {
  return k.jsx("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 32 32", children: k.jsx("path", { d: "M32 18.133H18.133V32h-4.266V18.133H0v-4.266h13.867V0h4.266v13.867H32z" }) });
}
function tI() {
  return k.jsx("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 32 5", children: k.jsx("path", { d: "M0 0h32v4.2H0z" }) });
}
function nI() {
  return k.jsx("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 32 30", children: k.jsx("path", { d: "M3.692 4.63c0-.53.4-.938.939-.938h5.215V0H4.708C2.13 0 0 2.054 0 4.63v5.216h3.692V4.631zM27.354 0h-5.2v3.692h5.17c.53 0 .984.4.984.939v5.215H32V4.631A4.624 4.624 0 0027.354 0zm.954 24.83c0 .532-.4.94-.939.94h-5.215v3.768h5.215c2.577 0 4.631-2.13 4.631-4.707v-5.139h-3.692v5.139zm-23.677.94c-.531 0-.939-.4-.939-.94v-5.138H0v5.139c0 2.577 2.13 4.707 4.708 4.707h5.138V25.77H4.631z" }) });
}
function rI() {
  return k.jsx("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 25 32", children: k.jsx("path", { d: "M21.333 10.667H19.81V7.619C19.81 3.429 16.38 0 12.19 0 8 0 4.571 3.429 4.571 7.619v3.048H3.048A3.056 3.056 0 000 13.714v15.238A3.056 3.056 0 003.048 32h18.285a3.056 3.056 0 003.048-3.048V13.714a3.056 3.056 0 00-3.048-3.047zM12.19 24.533a3.056 3.056 0 01-3.047-3.047 3.056 3.056 0 013.047-3.048 3.056 3.056 0 013.048 3.048 3.056 3.056 0 01-3.048 3.047zm4.724-13.866H7.467V7.619c0-2.59 2.133-4.724 4.723-4.724 2.591 0 4.724 2.133 4.724 4.724v3.048z" }) });
}
function oI() {
  return k.jsx("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 25 32", children: k.jsx("path", { d: "M21.333 10.667H19.81V7.619C19.81 3.429 16.38 0 12.19 0c-4.114 1.828-1.37 2.133.305 2.438 1.676.305 4.42 2.59 4.42 5.181v3.048H3.047A3.056 3.056 0 000 13.714v15.238A3.056 3.056 0 003.048 32h18.285a3.056 3.056 0 003.048-3.048V13.714a3.056 3.056 0 00-3.048-3.047zM12.19 24.533a3.056 3.056 0 01-3.047-3.047 3.056 3.056 0 013.047-3.048 3.056 3.056 0 013.048 3.048 3.056 3.056 0 01-3.048 3.047z" }) });
}
function Of({ children: e, className: t, ...n }) {
  return k.jsx("button", { type: "button", className: Xt(["react-flow__controls-button", t]), ...n, children: e });
}
const iI = (e) => ({
  isInteractive: e.nodesDraggable || e.nodesConnectable || e.elementsSelectable,
  minZoomReached: e.transform[2] <= e.minZoom,
  maxZoomReached: e.transform[2] >= e.maxZoom
});
function x4({ style: e, showZoom: t = !0, showFitView: n = !0, showInteractive: r = !0, fitViewOptions: o, onZoomIn: a, onZoomOut: l, onFitView: u, onInteractiveChange: d, className: f, children: p, position: m = "bottom-left", orientation: g = "vertical", "aria-label": y = "React Flow controls" }) {
  const w = _t(), { isInteractive: v, minZoomReached: x, maxZoomReached: E } = Ze(iI, St), { zoomIn: N, zoomOut: C, fitView: A } = zc(), R = () => {
    N(), a?.();
  }, D = () => {
    C(), l?.();
  }, T = () => {
    A(o), u?.();
  }, V = () => {
    w.setState({
      nodesDraggable: !v,
      nodesConnectable: !v,
      elementsSelectable: !v
    }), d?.(!v);
  }, F = g === "horizontal" ? "horizontal" : "vertical";
  return k.jsxs(ph, { className: Xt(["react-flow__controls", F, f]), position: m, style: e, "data-testid": "rf__controls", "aria-label": y, children: [t && k.jsxs(k.Fragment, { children: [k.jsx(Of, { onClick: R, className: "react-flow__controls-zoomin", title: "zoom in", "aria-label": "zoom in", disabled: E, children: k.jsx(eI, {}) }), k.jsx(Of, { onClick: D, className: "react-flow__controls-zoomout", title: "zoom out", "aria-label": "zoom out", disabled: x, children: k.jsx(tI, {}) })] }), n && k.jsx(Of, { className: "react-flow__controls-fitview", onClick: T, title: "fit view", "aria-label": "fit view", children: k.jsx(nI, {}) }), r && k.jsx(Of, { className: "react-flow__controls-interactive", onClick: V, title: "toggle interactivity", "aria-label": "toggle interactivity", children: v ? k.jsx(oI, {}) : k.jsx(rI, {}) }), p] });
}
x4.displayName = "Controls";
_.memo(x4);
function aI({ id: e, x: t, y: n, width: r, height: o, style: a, color: l, strokeColor: u, strokeWidth: d, className: f, borderRadius: p, shapeRendering: m, selected: g, onClick: y }) {
  const { background: w, backgroundColor: v } = a || {}, x = l || w || v;
  return k.jsx("rect", { className: Xt(["react-flow__minimap-node", { selected: g }, f]), x: t, y: n, rx: p, ry: p, width: r, height: o, style: {
    fill: x,
    stroke: u,
    strokeWidth: d
  }, shapeRendering: m, onClick: y ? (E) => y(E, e) : void 0 });
}
const lI = _.memo(aI), sI = (e) => e.nodes.map((t) => t.id), Py = (e) => e instanceof Function ? e : () => e;
function uI({
  nodeStrokeColor: e,
  nodeColor: t,
  nodeClassName: n = "",
  nodeBorderRadius: r = 5,
  nodeStrokeWidth: o,
  /*
   * We need to rename the prop to be `CapitalCase` so that JSX will render it as
   * a component properly.
   */
  nodeComponent: a = lI,
  onClick: l
}) {
  const u = Ze(sI, St), d = Py(t), f = Py(e), p = Py(n), m = typeof window > "u" || window.chrome ? "crispEdges" : "geometricPrecision";
  return k.jsx(k.Fragment, { children: u.map((g) => (
    /*
     * The split of responsibilities between MiniMapNodes and
     * NodeComponentWrapper may appear weird. However, its designed to
     * minimize the cost of updates when individual nodes change.
     *
     * For more details, see a similar commit in `NodeRenderer/index.tsx`.
     */
    k.jsx(dI, { id: g, nodeColorFunc: d, nodeStrokeColorFunc: f, nodeClassNameFunc: p, nodeBorderRadius: r, nodeStrokeWidth: o, NodeComponent: a, onClick: l, shapeRendering: m }, g)
  )) });
}
function cI({ id: e, nodeColorFunc: t, nodeStrokeColorFunc: n, nodeClassNameFunc: r, nodeBorderRadius: o, nodeStrokeWidth: a, shapeRendering: l, NodeComponent: u, onClick: d }) {
  const { node: f, x: p, y: m, width: g, height: y } = Ze((w) => {
    const { internals: v } = w.nodeLookup.get(e), x = v.userNode, { x: E, y: N } = v.positionAbsolute, { width: C, height: A } = Zo(x);
    return {
      node: x,
      x: E,
      y: N,
      width: C,
      height: A
    };
  }, St);
  return !f || f.hidden || !_3(f) ? null : k.jsx(u, { x: p, y: m, width: g, height: y, style: f.style, selected: !!f.selected, className: r(f), color: t(f), borderRadius: o, strokeColor: n(f), strokeWidth: a, shapeRendering: l, onClick: d, id: f.id });
}
const dI = _.memo(cI);
var fI = _.memo(uI);
const pI = 200, hI = 150, mI = (e) => !e.hidden, gI = (e) => {
  const t = {
    x: -e.transform[0] / e.transform[2],
    y: -e.transform[1] / e.transform[2],
    width: e.width / e.transform[2],
    height: e.height / e.transform[2]
  };
  return {
    viewBB: t,
    boundingRect: e.nodeLookup.size > 0 ? k3(Dc(e.nodeLookup, { filter: mI }), t) : t,
    rfId: e.rfId,
    panZoom: e.panZoom,
    translateExtent: e.translateExtent,
    flowWidth: e.width,
    flowHeight: e.height
  };
}, yI = "react-flow__minimap-desc";
function S4({
  style: e,
  className: t,
  nodeStrokeColor: n,
  nodeColor: r,
  nodeClassName: o = "",
  nodeBorderRadius: a = 5,
  nodeStrokeWidth: l,
  /*
   * We need to rename the prop to be `CapitalCase` so that JSX will render it as
   * a component properly.
   */
  nodeComponent: u,
  bgColor: d,
  maskColor: f,
  maskStrokeColor: p,
  maskStrokeWidth: m,
  position: g = "bottom-right",
  onClick: y,
  onNodeClick: w,
  pannable: v = !1,
  zoomable: x = !1,
  ariaLabel: E = "React Flow mini map",
  inversePan: N,
  zoomStep: C = 10,
  offsetScale: A = 5
}) {
  const R = _t(), D = _.useRef(null), { boundingRect: T, viewBB: V, rfId: F, panZoom: O, translateExtent: B, flowWidth: U, flowHeight: G } = Ze(gI, St), z = e?.width ?? pI, $ = e?.height ?? hI, L = T.width / z, H = T.height / $, q = Math.max(L, H), Y = q * z, M = q * $, X = A * q, Q = T.x - (Y - T.width) / 2 - X, P = T.y - (M - T.height) / 2 - X, te = Y + X * 2, ie = M + X * 2, ae = `${yI}-${F}`, fe = _.useRef(0), he = _.useRef();
  fe.current = q, _.useEffect(() => {
    if (D.current && O)
      return he.current = B9({
        domNode: D.current,
        panZoom: O,
        getTransform: () => R.getState().transform,
        getViewScale: () => fe.current
      }), () => {
        var we;
        (we = he.current) == null || we.destroy();
      };
  }, [O]), _.useEffect(() => {
    var we;
    (we = he.current) == null || we.update({
      translateExtent: B,
      width: U,
      height: G,
      inversePan: N,
      pannable: v,
      zoomStep: C,
      zoomable: x
    });
  }, [v, x, N, C, B, U, G]);
  const ye = y ? (we) => {
    var xe;
    const [Pe, Ve] = ((xe = he.current) == null ? void 0 : xe.pointer(we)) || [0, 0];
    y(we, { x: Pe, y: Ve });
  } : void 0, Ee = w ? _.useCallback((we, xe) => {
    const Pe = R.getState().nodeLookup.get(xe).internals.userNode;
    w(we, Pe);
  }, []) : void 0;
  return k.jsx(ph, { position: g, style: {
    ...e,
    "--xy-minimap-background-color-props": typeof d == "string" ? d : void 0,
    "--xy-minimap-mask-background-color-props": typeof f == "string" ? f : void 0,
    "--xy-minimap-mask-stroke-color-props": typeof p == "string" ? p : void 0,
    "--xy-minimap-mask-stroke-width-props": typeof m == "number" ? m * q : void 0,
    "--xy-minimap-node-background-color-props": typeof r == "string" ? r : void 0,
    "--xy-minimap-node-stroke-color-props": typeof n == "string" ? n : void 0,
    "--xy-minimap-node-stroke-width-props": typeof l == "number" ? l : void 0
  }, className: Xt(["react-flow__minimap", t]), "data-testid": "rf__minimap", children: k.jsxs("svg", { width: z, height: $, viewBox: `${Q} ${P} ${te} ${ie}`, className: "react-flow__minimap-svg", role: "img", "aria-labelledby": ae, ref: D, onClick: ye, children: [E && k.jsx("title", { id: ae, children: E }), k.jsx(fI, { onClick: Ee, nodeColor: r, nodeStrokeColor: n, nodeBorderRadius: a, nodeClassName: o, nodeStrokeWidth: l, nodeComponent: u }), k.jsx("path", { className: "react-flow__minimap-mask", d: `M${Q - X},${P - X}h${te + X * 2}v${ie + X * 2}h${-te - X * 2}z
        M${V.x},${V.y}h${V.width}v${V.height}h${-V.width}z`, fillRule: "evenodd", pointerEvents: "none" })] }) });
}
S4.displayName = "MiniMap";
const vI = _.memo(S4);
function bI({ nodeId: e, position: t, variant: n = Ku.Handle, className: r, style: o = {}, children: a, color: l, minWidth: u = 10, minHeight: d = 10, maxWidth: f = Number.MAX_VALUE, maxHeight: p = Number.MAX_VALUE, keepAspectRatio: m = !1, shouldResize: g, onResizeStart: y, onResize: w, onResizeEnd: v }) {
  const x = e4(), E = typeof e == "string" ? e : x, N = _t(), C = _.useRef(null), A = n === Ku.Line ? "right" : "bottom-right", R = t ?? A, D = _.useRef(null);
  _.useEffect(() => {
    if (!(!C.current || !E))
      return D.current || (D.current = e7({
        domNode: C.current,
        nodeId: E,
        getStoreItems: () => {
          const { nodeLookup: O, transform: B, snapGrid: U, snapToGrid: G, nodeOrigin: z, domNode: $ } = N.getState();
          return {
            nodeLookup: O,
            transform: B,
            snapGrid: U,
            snapToGrid: G,
            nodeOrigin: z,
            paneDomNode: $
          };
        },
        onChange: (O, B) => {
          const { triggerNodeChanges: U, nodeLookup: G, parentLookup: z, nodeOrigin: $ } = N.getState(), L = [], H = { x: O.x, y: O.y }, q = G.get(E);
          if (q && q.expandParent && q.parentId) {
            const Y = q.origin ?? $, M = O.width ?? q.measured.width ?? 0, X = O.height ?? q.measured.height ?? 0, Q = {
              id: q.id,
              parentId: q.parentId,
              rect: {
                width: M,
                height: X,
                ...E3({
                  x: O.x ?? q.position.x,
                  y: O.y ?? q.position.y
                }, { width: M, height: X }, q.parentId, G, Y)
              }
            }, P = ww([Q], G, z, $);
            L.push(...P), H.x = O.x ? Math.max(Y[0] * M, O.x) : void 0, H.y = O.y ? Math.max(Y[1] * X, O.y) : void 0;
          }
          if (H.x !== void 0 && H.y !== void 0) {
            const Y = {
              id: E,
              type: "position",
              position: { ...H }
            };
            L.push(Y);
          }
          if (O.width !== void 0 && O.height !== void 0) {
            const Y = {
              id: E,
              type: "dimensions",
              resizing: !0,
              setAttributes: !0,
              dimensions: {
                width: O.width,
                height: O.height
              }
            };
            L.push(Y);
          }
          for (const Y of B) {
            const M = {
              ...Y,
              type: "position"
            };
            L.push(M);
          }
          U(L);
        },
        onEnd: ({ width: O, height: B }) => {
          const U = {
            id: E,
            type: "dimensions",
            resizing: !1,
            dimensions: {
              width: O,
              height: B
            }
          };
          N.getState().triggerNodeChanges([U]);
        }
      })), D.current.update({
        controlPosition: R,
        boundaries: {
          minWidth: u,
          minHeight: d,
          maxWidth: f,
          maxHeight: p
        },
        keepAspectRatio: m,
        onResizeStart: y,
        onResize: w,
        onResizeEnd: v,
        shouldResize: g
      }), () => {
        var O;
        (O = D.current) == null || O.destroy();
      };
  }, [
    R,
    u,
    d,
    f,
    p,
    m,
    y,
    w,
    v,
    g
  ]);
  const T = R.split("-"), V = n === Ku.Line ? "borderColor" : "backgroundColor", F = l ? { ...o, [V]: l } : o;
  return k.jsx("div", { className: Xt(["react-flow__resize-control", "nodrag", ...T, n, r]), ref: C, style: F, children: a });
}
_.memo(bI);
const wI = ({
  on_node_change: e,
  on_edge_change: t,
  on_connect: n
}) => {
  const r = e || ((a) => {
  }), o = n || ((a) => {
  });
  return wn((a, l) => ({
    nodes: [],
    edges: [],
    onNodesChange: (u) => {
      a({
        nodes: G3(u, l().nodes)
      }), r(u);
    },
    onEdgesChange: (u) => {
      a({
        edges: Z3(u, l().edges)
      });
    },
    onConnect: (u) => {
      u.source == null || u.target == null || o(u);
    }
  }));
}, rE = ({
  src_nid: e,
  src_ioid: t,
  trg_nid: n,
  trg_ioid: r
}) => [`${e}:${t}`, `${n}:${r}`].sort().join("--");
function xI(e) {
  console.error("Unhandled case: " + e);
}
const SI = (e) => {
  if ((e.v ? Number(e.v) : 0) > 0) throw new Error("Plugin version is too new");
  return e;
};
class kI {
  constructor(t) {
    this.iostore = t;
  }
  get connected() {
    return this.iostore.getState().connected;
  }
  set connected(t) {
    this.iostore.setState({ connected: t });
  }
  get does_trigger() {
    return this.iostore.getState().does_trigger;
  }
  set does_trigger(t) {
    this.iostore.setState({ does_trigger: t });
  }
  get full_id() {
    return this.iostore.getState().full_id;
  }
  set full_id(t) {
    this.iostore.setState({ full_id: t });
  }
  get id() {
    return this.iostore.getState().id;
  }
  set id(t) {
    this.iostore.setState({ id: t });
  }
  get is_input() {
    return this.iostore.getState().is_input;
  }
  set is_input(t) {
    this.iostore.setState({ is_input: t });
  }
  get name() {
    return this.iostore.getState().name;
  }
  set name(t) {
    this.iostore.setState({ name: t });
  }
  get node() {
    return this.iostore.getState().node;
  }
  set node(t) {
    this.iostore.setState({ node: t });
  }
  get type() {
    return this.iostore.getState().type;
  }
  set type(t) {
    this.iostore.setState({ type: t });
  }
  get value() {
    return this.iostore.valuestore.getState().preview;
  }
  set value(t) {
    this.iostore.updateValueStore({ preview: t });
  }
  get fullvalue() {
    return this.iostore.valuestore.getState().full;
  }
  set fullvalue(t) {
    this.iostore.updateValueStore({ full: t });
  }
  get render_options() {
    return this.iostore.getState().render_options;
  }
  set render_options(t) {
    this.iostore.setState({ render_options: t });
  }
  get hidden() {
    return this.iostore.getState().hidden;
  }
  set hidden(t) {
    this.iostore.setState({ hidden: t });
  }
  get try_get_full_value() {
    return this.iostore.getState().try_get_full_value;
  }
  get set_hidden() {
    return this.iostore.getState().set_hidden;
  }
}
const Nl = (e) => (t) => {
  const { iostore: n, ...r } = t, o = new kI(n);
  return e({ ...r, io: o });
}, _I = (e) => {
  const t = e.v ? Number(e.v) : 0;
  if (t > 1) throw new Error("Plugin version is too new");
  if (t === 1) return e;
  const n = SI(e);
  return { ...n, renderpluginfactory: (r) => {
    var o;
    const a = ((o = n.renderpluginfactory) == null ? void 0 : o.call(n, r)) || {}, l = n.RendererPlugin || {}, u = Object.keys({ ...l, ...a }), d = {};
    for (const f of u)
      switch (f) {
        case "input_renderers":
          const p = {};
          for (const [x, E] of Object.entries(l.input_renderers || {}))
            E !== void 0 && (p[x] = Nl(E));
          d.input_renderers = p;
          break;
        case "output_renderers":
          const m = {};
          for (const [x, E] of Object.entries(
            l.output_renderers || {}
          ))
            E !== void 0 && (m[x] = Nl(E));
          d.output_renderers = m;
          break;
        case "handle_preview_renderers":
          const g = {};
          for (const [x, E] of Object.entries(
            l.handle_preview_renderers || {}
          ))
            E !== void 0 && (g[x] = Nl(E));
          d.handle_preview_renderers = g;
          break;
        case "data_overlay_renderers":
          const y = {};
          for (const [x, E] of Object.entries(
            l.data_overlay_renderers || {}
          ))
            E !== void 0 && (y[x] = Nl(E));
          d.data_overlay_renderers = y;
          break;
        case "data_preview_renderers":
          const w = {};
          for (const [x, E] of Object.entries(
            l.data_preview_renderers || {}
          ))
            E !== void 0 && (w[x] = Nl(E));
          d.data_preview_renderers = w;
          break;
        case "data_view_renderers":
          const v = {};
          for (const [x, E] of Object.entries(
            l.data_view_renderers || {}
          ))
            E !== void 0 && (v[x] = Nl(E));
          d.data_view_renderers = v;
          break;
        default:
          xI(f);
      }
    return d;
  }, v: 1 };
}, EI = (e) => _I(e), Tn = {
  DEBUG: 0,
  INFO: 10,
  WARN: 20,
  ERROR: 30
}, CI = Tn.INFO, oE = (e) => typeof e == "string" ? e : e === Tn.DEBUG ? "DEBUG" : e === Tn.INFO ? "INFO" : e === Tn.WARN ? "WARN" : e === Tn.ERROR ? "ERROR" : "UNKNOWN";
function OI() {
  const e = [];
  return function(t, n) {
    if (typeof n != "object" || n === null)
      return n;
    for (; e.length > 0 && e.at(-1) !== this; )
      e.pop();
    return e.includes(n) ? "[Circular]" : (e.push(n), n);
  };
}
const NI = (e) => {
  if (typeof e == "number") return e;
  const t = e.toLowerCase();
  if (t === "debug") return Tn.DEBUG;
  if (t === "info") return Tn.INFO;
  if (t === "warn" || t === "warning") return Tn.WARN;
  if (t === "error") return Tn.ERROR;
  throw new Error(`Unknown log level: ${e}`);
};
class k4 {
  constructor(t, n = Tn.INFO) {
    this.name = t, this.level = NI(n), this._level_name = oE(n);
  }
  set_level(t) {
    this.level = t, this._level_name = oE(t);
  }
  _fomat_message(t, ...n) {
    return `[${this.name}] ${this._level_name}: ${t} ${n.map((r) => JSON.stringify(r, OI())).join(" ")}`;
  }
  debug(t, ...n) {
    this.level <= Tn.DEBUG && console.debug(this._fomat_message(t, ...n));
  }
  info(t, ...n) {
    this.level <= Tn.INFO && console.info(this._fomat_message(t, ...n));
  }
  warn(t, ...n) {
    this.level <= Tn.WARN && console.warn(this._fomat_message(t, ...n));
  }
  error(t, ...n) {
    this.level <= Tn.ERROR && console.error(this._fomat_message(t, ...n));
  }
}
const Wv = !1, MI = (e, t) => {
  const n = e.properties || {};
  n["frontend:size"] || (n["frontend:size"] = [200, 100]);
  const r = n["frontend:pos"];
  if (!r || r.length !== 2 || isNaN(r[0]) || r[0] === null || isNaN(r[1]) || r[1] === null)
    if (!t || !t.rf_instance || t.reactflowRef === null)
      n["frontend:pos"] = [0, 0];
    else {
      const o = t.reactflowRef.getBoundingClientRect(), a = o.left + o.width / 2, l = o.top + o.height / 2, u = t.rf_instance.screenToFlowPosition({
        x: a,
        y: l
      });
      n["frontend:pos"] = [
        u.x - n["frontend:size"][0] / 2,
        u.y - n["frontend:size"][0] / 2
      ];
    }
  n["frontend:collapsed"] || (n["frontend:collapsed"] = !1), e.properties = n;
}, AI = (e, t) => {
  const n = e.getState();
  if (MI(n, t), n.id === void 0)
    throw new Error("Node must have an id");
  const r = {
    nodestore: e
  };
  return {
    position: {
      x: n.properties["frontend:pos"][0],
      y: n.properties["frontend:pos"][1]
    },
    data: r,
    type: "default",
    ...n
  };
}, _4 = (e) => {
  const t = {
    ...e
  }, n = (v) => {
    var x;
    const E = f.getState();
    if (v.from_remote) {
      let N = p.get_node(v.node.id, !1);
      if (N)
        return;
      if (!N)
        try {
          N = Mz(w, v.node), p.nodesstates.set(v.node.id, N);
        } catch (R) {
          w.logger.error(`Failed to create node store ${R}`);
          return;
        }
      const C = N.getState();
      w.logger.info("Add node", C.id, C.name);
      const A = [...E.nodes, AI(N, w)];
      f.setState({ nodes: A });
      for (const R in v.node.io) {
        const D = v.node.io[R].id;
        D !== void 0 && ((x = w.worker) == null || x.get_io_value({ nid: v.node.id, ioid: D }));
      }
      setTimeout(() => {
        var R;
        (R = w.worker) == null || R.call_hooks("node_added", { node: C.id });
      }, 0);
    }
  }, r = (v) => {
    if (v.node.in_trigger && (v.node.error = void 0), v.from_remote) {
      const x = p.get_node(v.id, !1);
      if (!x) {
        console.error("Node not found to update", v.id);
        return;
      }
      x.update(v.node);
    } else
      w.worker && w.worker.locally_update_node(v);
  }, o = (v) => {
    var x;
    w.logger.info("Deleting node", v.id), v.from_remote ? f.getState().onNodesChange([
      {
        type: "remove",
        id: v.id
      }
    ]) : (x = w.worker) == null || x.remove_node(v.id);
  }, a = (v) => {
    w.logger.error("Error", v), u({
      type: "update",
      id: v.id,
      node: {
        in_trigger: !1,
        error: v.error
      },
      from_remote: !0
    });
  }, l = (v) => {
    var x;
    v.from_remote ? u({
      type: "update",
      id: v.id,
      node: {
        in_trigger: !0,
        error: void 0
      },
      from_remote: !0
    }) : (x = w.worker) == null || x.trigger_node(v.id);
  }, u = (v) => {
    switch (v.type) {
      case "add":
        n(v);
        break;
      case "update":
        r(v);
        break;
      case "delete":
        o(v);
        break;
      case "error":
        a(v);
        break;
      case "trigger":
        l(v);
        break;
      default:
        w.logger.error("Unknown node action", v);
    }
  }, d = (v) => {
    var x, E, N, C;
    const A = f.getState();
    switch (v.type) {
      case "add":
        if (v.from_remote) {
          const R = A.edges, D = rE(v);
          if (R.some((V) => V.id === D))
            return;
          const T = {
            id: D,
            source: v.src_nid,
            target: v.trg_nid,
            sourceHandle: v.src_ioid,
            targetHandle: v.trg_ioid,
            className: "funcnodes-edge animated"
          };
          w.logger.info("Adding edge", T), f.setState({ edges: [...R, T] }), (x = w.worker) == null || x.get_remote_node_state(v.src_nid), (E = w.worker) == null || E.get_remote_node_state(v.trg_nid);
        }
        break;
      case "delete":
        if (v.from_remote) {
          const R = A.edges, D = rE(v);
          w.logger.info("Deleting edge", D);
          const T = R.filter((V) => V.id !== D);
          f.setState({ edges: T }), (N = w.worker) == null || N.get_remote_node_state(v.src_nid), (C = w.worker) == null || C.get_remote_node_state(v.trg_nid);
        }
        break;
      default:
        w.logger.error("Unknown edge action", v);
    }
  }, f = wI({
    on_node_change: (v) => {
      for (const x of v)
        switch (x.type) {
          case "position":
            x.position && u({
              type: "update",
              id: x.id,
              node: {
                properties: {
                  "frontend:pos": [x.position.x, x.position.y]
                }
              },
              from_remote: !1
            });
            break;
          case "dimensions":
            x.dimensions && u({
              type: "update",
              id: x.id,
              node: {
                properties: {
                  "frontend:size": [
                    x.dimensions.width,
                    x.dimensions.height
                  ]
                }
              },
              from_remote: !1
            });
            break;
        }
    },
    on_edge_change: (v) => {
    },
    on_connect: (v) => {
      v.source === null || v.target === null || v.sourceHandle === null || v.targetHandle === null || !w.worker || w.worker.add_edge({
        src_nid: v.source,
        src_ioid: v.sourceHandle,
        trg_nid: v.target,
        trg_ioid: v.targetHandle,
        replace: !0
      });
    }
  }), p = mz({}), m = hz(), g = () => {
    var v, x;
    (v = w.worker) == null || v.disconnect(), w.set_worker(void 0), (x = w.workermanager) == null || x.setWorker(void 0), w.lib.libstate.getState().set({ lib: { shelves: [] }, external_worker: [] }), w.nodespace.nodesstates.clear(), w.useReactFlowStore.setState({ nodes: [], edges: [] }), w.auto_progress();
  }, y = (v) => {
    var x;
    if (!w.rf_instance)
      return;
    v = Array.isArray(v) ? v : [v];
    const E = w.useReactFlowStore.getState().nodes.filter((N) => v.includes(N.id));
    E.length > 0 && ((x = w.rf_instance) == null || x.fitView({ padding: 0.2, nodes: E }));
  }, w = {
    local_settings: wn((v, x) => ({
      view_settings: {},
      update_view_settings: (E) => {
        const N = w.local_settings.getState().view_settings, { new_obj: C, change: A } = Mr(N, E);
        A && w.local_settings.setState((R) => ({
          ...R,
          view_settings: C
        }));
      }
    })),
    local_state: wn((v, x) => ({
      selected_nodes: [],
      selected_edges: [],
      funcnodescontainerRef: null
    })),
    options: t,
    lib: m,
    workermanager: void 0,
    workers: wn((v, x) => ({})),
    workerstate: wn((v, x) => ({
      is_open: !1
    })),
    render_options: wn((v, x) => ({})),
    progress_state: wn((v, x) => ({
      message: "please select worker",
      status: "info",
      progress: 0,
      blocking: !1
    })),
    update_render_options: (v) => {
      const x = w.render_options.getState(), { new_obj: E, change: N } = Mr(x, v);
      N && w.render_options.setState(E);
    },
    worker: void 0,
    _unsubscribeFromWorker: void 0,
    set_worker: (v) => {
      v !== w.worker && (w._unsubscribeFromWorker && (w._unsubscribeFromWorker(), w._unsubscribeFromWorker = void 0), v && (w._unsubscribeFromWorker = v.state.subscribe((x) => {
        w.workerstate.setState(x);
      }), w.workerstate.setState(v.state.getState())), w.worker = v, v?.set_zustand(w));
    },
    nodespace: p,
    useReactFlowStore: f,
    on_node_action: u,
    on_edge_action: d,
    reactflowRef: null,
    clear_all: g,
    center_node: y,
    center_all: () => {
      var v;
      console.log("center all", w.rf_instance), (v = w.rf_instance) == null || v.fitView({ padding: 0.2 });
    },
    set_progress: (v) => {
      if (v.message === "")
        return w.auto_progress();
      const x = w.progress_state.getState(), { new_obj: E, change: N } = Mr(
        x,
        v
      );
      N && w.progress_state.setState(E);
    },
    auto_progress: () => {
      if (w.workermanager !== void 0 && !w.workermanager.open)
        return w.set_progress({
          progress: 0,
          message: "connecting to worker manager",
          status: "error",
          blocking: !1
        });
      if (w.worker === void 0)
        return w.set_progress({
          progress: 0,
          message: "please select worker",
          status: "error",
          blocking: !1
        });
      if (!w.worker.is_open)
        return w.set_progress({
          progress: 0,
          message: "connecting to worker",
          status: "info",
          blocking: !0
        });
      w.set_progress({
        progress: 1,
        message: "running",
        status: "info",
        blocking: !1
      });
    },
    plugins: wn((v, x) => ({})),
    add_plugin: (v, x) => {
      if (x === void 0) return;
      const E = EI(x);
      w.plugins.setState((N) => ({ ...N, [v]: E }));
    },
    dev_settings: {
      debug: !0
    },
    logger: new k4("fn", CI)
  };
  return w;
};
function E4(e, t) {
  return function() {
    return e.apply(t, arguments);
  };
}
const { toString: RI } = Object.prototype, { getPrototypeOf: Sw } = Object, mh = /* @__PURE__ */ ((e) => (t) => {
  const n = RI.call(t);
  return e[n] || (e[n] = n.slice(8, -1).toLowerCase());
})(/* @__PURE__ */ Object.create(null)), zr = (e) => (e = e.toLowerCase(), (t) => mh(t) === e), gh = (e) => (t) => typeof t === e, { isArray: ms } = Array, hc = gh("undefined");
function jI(e) {
  return e !== null && !hc(e) && e.constructor !== null && !hc(e.constructor) && Qn(e.constructor.isBuffer) && e.constructor.isBuffer(e);
}
const C4 = zr("ArrayBuffer");
function DI(e) {
  let t;
  return typeof ArrayBuffer < "u" && ArrayBuffer.isView ? t = ArrayBuffer.isView(e) : t = e && e.buffer && C4(e.buffer), t;
}
const TI = gh("string"), Qn = gh("function"), O4 = gh("number"), yh = (e) => e !== null && typeof e == "object", zI = (e) => e === !0 || e === !1, ep = (e) => {
  if (mh(e) !== "object")
    return !1;
  const t = Sw(e);
  return (t === null || t === Object.prototype || Object.getPrototypeOf(t) === null) && !(Symbol.toStringTag in e) && !(Symbol.iterator in e);
}, PI = zr("Date"), LI = zr("File"), II = zr("Blob"), BI = zr("FileList"), VI = (e) => yh(e) && Qn(e.pipe), HI = (e) => {
  let t;
  return e && (typeof FormData == "function" && e instanceof FormData || Qn(e.append) && ((t = mh(e)) === "formdata" || // detect form-data instance
  t === "object" && Qn(e.toString) && e.toString() === "[object FormData]"));
}, UI = zr("URLSearchParams"), [FI, $I, YI, qI] = ["ReadableStream", "Request", "Response", "Headers"].map(zr), XI = (e) => e.trim ? e.trim() : e.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
function Lc(e, t, { allOwnKeys: n = !1 } = {}) {
  if (e === null || typeof e > "u")
    return;
  let r, o;
  if (typeof e != "object" && (e = [e]), ms(e))
    for (r = 0, o = e.length; r < o; r++)
      t.call(null, e[r], r, e);
  else {
    const a = n ? Object.getOwnPropertyNames(e) : Object.keys(e), l = a.length;
    let u;
    for (r = 0; r < l; r++)
      u = a[r], t.call(null, e[u], u, e);
  }
}
function N4(e, t) {
  t = t.toLowerCase();
  const n = Object.keys(e);
  let r = n.length, o;
  for (; r-- > 0; )
    if (o = n[r], t === o.toLowerCase())
      return o;
  return null;
}
const Sa = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : H6, M4 = (e) => !hc(e) && e !== Sa;
function Kv() {
  const { caseless: e } = M4(this) && this || {}, t = {}, n = (r, o) => {
    const a = e && N4(t, o) || o;
    ep(t[a]) && ep(r) ? t[a] = Kv(t[a], r) : ep(r) ? t[a] = Kv({}, r) : ms(r) ? t[a] = r.slice() : t[a] = r;
  };
  for (let r = 0, o = arguments.length; r < o; r++)
    arguments[r] && Lc(arguments[r], n);
  return t;
}
const GI = (e, t, n, { allOwnKeys: r } = {}) => (Lc(t, (o, a) => {
  n && Qn(o) ? e[a] = E4(o, n) : e[a] = o;
}, { allOwnKeys: r }), e), ZI = (e) => (e.charCodeAt(0) === 65279 && (e = e.slice(1)), e), WI = (e, t, n, r) => {
  e.prototype = Object.create(t.prototype, r), e.prototype.constructor = e, Object.defineProperty(e, "super", {
    value: t.prototype
  }), n && Object.assign(e.prototype, n);
}, KI = (e, t, n, r) => {
  let o, a, l;
  const u = {};
  if (t = t || {}, e == null) return t;
  do {
    for (o = Object.getOwnPropertyNames(e), a = o.length; a-- > 0; )
      l = o[a], (!r || r(l, e, t)) && !u[l] && (t[l] = e[l], u[l] = !0);
    e = n !== !1 && Sw(e);
  } while (e && (!n || n(e, t)) && e !== Object.prototype);
  return t;
}, QI = (e, t, n) => {
  e = String(e), (n === void 0 || n > e.length) && (n = e.length), n -= t.length;
  const r = e.indexOf(t, n);
  return r !== -1 && r === n;
}, JI = (e) => {
  if (!e) return null;
  if (ms(e)) return e;
  let t = e.length;
  if (!O4(t)) return null;
  const n = new Array(t);
  for (; t-- > 0; )
    n[t] = e[t];
  return n;
}, eB = /* @__PURE__ */ ((e) => (t) => e && t instanceof e)(typeof Uint8Array < "u" && Sw(Uint8Array)), tB = (e, t) => {
  const n = (e && e[Symbol.iterator]).call(e);
  let r;
  for (; (r = n.next()) && !r.done; ) {
    const o = r.value;
    t.call(e, o[0], o[1]);
  }
}, nB = (e, t) => {
  let n;
  const r = [];
  for (; (n = e.exec(t)) !== null; )
    r.push(n);
  return r;
}, rB = zr("HTMLFormElement"), oB = (e) => e.toLowerCase().replace(
  /[-_\s]([a-z\d])(\w*)/g,
  function(t, n, r) {
    return n.toUpperCase() + r;
  }
), iE = (({ hasOwnProperty: e }) => (t, n) => e.call(t, n))(Object.prototype), iB = zr("RegExp"), A4 = (e, t) => {
  const n = Object.getOwnPropertyDescriptors(e), r = {};
  Lc(n, (o, a) => {
    let l;
    (l = t(o, a, e)) !== !1 && (r[a] = l || o);
  }), Object.defineProperties(e, r);
}, aB = (e) => {
  A4(e, (t, n) => {
    if (Qn(e) && ["arguments", "caller", "callee"].indexOf(n) !== -1)
      return !1;
    const r = e[n];
    if (Qn(r)) {
      if (t.enumerable = !1, "writable" in t) {
        t.writable = !1;
        return;
      }
      t.set || (t.set = () => {
        throw Error("Can not rewrite read-only method '" + n + "'");
      });
    }
  });
}, lB = (e, t) => {
  const n = {}, r = (o) => {
    o.forEach((a) => {
      n[a] = !0;
    });
  };
  return ms(e) ? r(e) : r(String(e).split(t)), n;
}, sB = () => {
}, uB = (e, t) => e != null && Number.isFinite(e = +e) ? e : t;
function cB(e) {
  return !!(e && Qn(e.append) && e[Symbol.toStringTag] === "FormData" && e[Symbol.iterator]);
}
const dB = (e) => {
  const t = new Array(10), n = (r, o) => {
    if (yh(r)) {
      if (t.indexOf(r) >= 0)
        return;
      if (!("toJSON" in r)) {
        t[o] = r;
        const a = ms(r) ? [] : {};
        return Lc(r, (l, u) => {
          const d = n(l, o + 1);
          !hc(d) && (a[u] = d);
        }), t[o] = void 0, a;
      }
    }
    return r;
  };
  return n(e, 0);
}, fB = zr("AsyncFunction"), pB = (e) => e && (yh(e) || Qn(e)) && Qn(e.then) && Qn(e.catch), R4 = ((e, t) => e ? setImmediate : t ? ((n, r) => (Sa.addEventListener("message", ({ source: o, data: a }) => {
  o === Sa && a === n && r.length && r.shift()();
}, !1), (o) => {
  r.push(o), Sa.postMessage(n, "*");
}))(`axios@${Math.random()}`, []) : (n) => setTimeout(n))(
  typeof setImmediate == "function",
  Qn(Sa.postMessage)
), hB = typeof queueMicrotask < "u" ? queueMicrotask.bind(Sa) : typeof process < "u" && process.nextTick || R4, oe = {
  isArray: ms,
  isArrayBuffer: C4,
  isBuffer: jI,
  isFormData: HI,
  isArrayBufferView: DI,
  isString: TI,
  isNumber: O4,
  isBoolean: zI,
  isObject: yh,
  isPlainObject: ep,
  isReadableStream: FI,
  isRequest: $I,
  isResponse: YI,
  isHeaders: qI,
  isUndefined: hc,
  isDate: PI,
  isFile: LI,
  isBlob: II,
  isRegExp: iB,
  isFunction: Qn,
  isStream: VI,
  isURLSearchParams: UI,
  isTypedArray: eB,
  isFileList: BI,
  forEach: Lc,
  merge: Kv,
  extend: GI,
  trim: XI,
  stripBOM: ZI,
  inherits: WI,
  toFlatObject: KI,
  kindOf: mh,
  kindOfTest: zr,
  endsWith: QI,
  toArray: JI,
  forEachEntry: tB,
  matchAll: nB,
  isHTMLForm: rB,
  hasOwnProperty: iE,
  hasOwnProp: iE,
  // an alias to avoid ESLint no-prototype-builtins detection
  reduceDescriptors: A4,
  freezeMethods: aB,
  toObjectSet: lB,
  toCamelCase: oB,
  noop: sB,
  toFiniteNumber: uB,
  findKey: N4,
  global: Sa,
  isContextDefined: M4,
  isSpecCompliantForm: cB,
  toJSONObject: dB,
  isAsyncFn: fB,
  isThenable: pB,
  setImmediate: R4,
  asap: hB
};
function Be(e, t, n, r, o) {
  Error.call(this), Error.captureStackTrace ? Error.captureStackTrace(this, this.constructor) : this.stack = new Error().stack, this.message = e, this.name = "AxiosError", t && (this.code = t), n && (this.config = n), r && (this.request = r), o && (this.response = o, this.status = o.status ? o.status : null);
}
oe.inherits(Be, Error, {
  toJSON: function() {
    return {
      // Standard
      message: this.message,
      name: this.name,
      // Microsoft
      description: this.description,
      number: this.number,
      // Mozilla
      fileName: this.fileName,
      lineNumber: this.lineNumber,
      columnNumber: this.columnNumber,
      stack: this.stack,
      // Axios
      config: oe.toJSONObject(this.config),
      code: this.code,
      status: this.status
    };
  }
});
const j4 = Be.prototype, D4 = {};
[
  "ERR_BAD_OPTION_VALUE",
  "ERR_BAD_OPTION",
  "ECONNABORTED",
  "ETIMEDOUT",
  "ERR_NETWORK",
  "ERR_FR_TOO_MANY_REDIRECTS",
  "ERR_DEPRECATED",
  "ERR_BAD_RESPONSE",
  "ERR_BAD_REQUEST",
  "ERR_CANCELED",
  "ERR_NOT_SUPPORT",
  "ERR_INVALID_URL"
  // eslint-disable-next-line func-names
].forEach((e) => {
  D4[e] = { value: e };
});
Object.defineProperties(Be, D4);
Object.defineProperty(j4, "isAxiosError", { value: !0 });
Be.from = (e, t, n, r, o, a) => {
  const l = Object.create(j4);
  return oe.toFlatObject(e, l, function(u) {
    return u !== Error.prototype;
  }, (u) => u !== "isAxiosError"), Be.call(l, e.message, t, n, r, o), l.cause = e, l.name = e.name, a && Object.assign(l, a), l;
};
const mB = null;
function Qv(e) {
  return oe.isPlainObject(e) || oe.isArray(e);
}
function T4(e) {
  return oe.endsWith(e, "[]") ? e.slice(0, -2) : e;
}
function aE(e, t, n) {
  return e ? e.concat(t).map(function(r, o) {
    return r = T4(r), !n && o ? "[" + r + "]" : r;
  }).join(n ? "." : "") : t;
}
function gB(e) {
  return oe.isArray(e) && !e.some(Qv);
}
const yB = oe.toFlatObject(oe, {}, null, function(e) {
  return /^is[A-Z]/.test(e);
});
function vh(e, t, n) {
  if (!oe.isObject(e))
    throw new TypeError("target must be an object");
  t = t || new FormData(), n = oe.toFlatObject(n, {
    metaTokens: !0,
    dots: !1,
    indexes: !1
  }, !1, function(y, w) {
    return !oe.isUndefined(w[y]);
  });
  const r = n.metaTokens, o = n.visitor || f, a = n.dots, l = n.indexes, u = (n.Blob || typeof Blob < "u" && Blob) && oe.isSpecCompliantForm(t);
  if (!oe.isFunction(o))
    throw new TypeError("visitor must be a function");
  function d(y) {
    if (y === null) return "";
    if (oe.isDate(y))
      return y.toISOString();
    if (!u && oe.isBlob(y))
      throw new Be("Blob is not supported. Use a Buffer instead.");
    return oe.isArrayBuffer(y) || oe.isTypedArray(y) ? u && typeof Blob == "function" ? new Blob([y]) : Buffer.from(y) : y;
  }
  function f(y, w, v) {
    let x = y;
    if (y && !v && typeof y == "object") {
      if (oe.endsWith(w, "{}"))
        w = r ? w : w.slice(0, -2), y = JSON.stringify(y);
      else if (oe.isArray(y) && gB(y) || (oe.isFileList(y) || oe.endsWith(w, "[]")) && (x = oe.toArray(y)))
        return w = T4(w), x.forEach(function(E, N) {
          !(oe.isUndefined(E) || E === null) && t.append(
            // eslint-disable-next-line no-nested-ternary
            l === !0 ? aE([w], N, a) : l === null ? w : w + "[]",
            d(E)
          );
        }), !1;
    }
    return Qv(y) ? !0 : (t.append(aE(v, w, a), d(y)), !1);
  }
  const p = [], m = Object.assign(yB, {
    defaultVisitor: f,
    convertValue: d,
    isVisitable: Qv
  });
  function g(y, w) {
    if (!oe.isUndefined(y)) {
      if (p.indexOf(y) !== -1)
        throw Error("Circular reference detected in " + w.join("."));
      p.push(y), oe.forEach(y, function(v, x) {
        (!(oe.isUndefined(v) || v === null) && o.call(
          t,
          v,
          oe.isString(x) ? x.trim() : x,
          w,
          m
        )) === !0 && g(v, w ? w.concat(x) : [x]);
      }), p.pop();
    }
  }
  if (!oe.isObject(e))
    throw new TypeError("data must be an object");
  return g(e), t;
}
function lE(e) {
  const t = {
    "!": "%21",
    "'": "%27",
    "(": "%28",
    ")": "%29",
    "~": "%7E",
    "%20": "+",
    "%00": "\0"
  };
  return encodeURIComponent(e).replace(/[!'()~]|%20|%00/g, function(n) {
    return t[n];
  });
}
function kw(e, t) {
  this._pairs = [], e && vh(e, this, t);
}
const z4 = kw.prototype;
z4.append = function(e, t) {
  this._pairs.push([e, t]);
};
z4.toString = function(e) {
  const t = e ? function(n) {
    return e.call(this, n, lE);
  } : lE;
  return this._pairs.map(function(n) {
    return t(n[0]) + "=" + t(n[1]);
  }, "").join("&");
};
function vB(e) {
  return encodeURIComponent(e).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
}
function P4(e, t, n) {
  if (!t)
    return e;
  const r = n && n.encode || vB;
  oe.isFunction(n) && (n = {
    serialize: n
  });
  const o = n && n.serialize;
  let a;
  if (o ? a = o(t, n) : a = oe.isURLSearchParams(t) ? t.toString() : new kw(t, n).toString(r), a) {
    const l = e.indexOf("#");
    l !== -1 && (e = e.slice(0, l)), e += (e.indexOf("?") === -1 ? "?" : "&") + a;
  }
  return e;
}
class sE {
  constructor() {
    this.handlers = [];
  }
  /**
   * Add a new interceptor to the stack
   *
   * @param {Function} fulfilled The function to handle `then` for a `Promise`
   * @param {Function} rejected The function to handle `reject` for a `Promise`
   *
   * @return {Number} An ID used to remove interceptor later
   */
  use(t, n, r) {
    return this.handlers.push({
      fulfilled: t,
      rejected: n,
      synchronous: r ? r.synchronous : !1,
      runWhen: r ? r.runWhen : null
    }), this.handlers.length - 1;
  }
  /**
   * Remove an interceptor from the stack
   *
   * @param {Number} id The ID that was returned by `use`
   *
   * @returns {Boolean} `true` if the interceptor was removed, `false` otherwise
   */
  eject(t) {
    this.handlers[t] && (this.handlers[t] = null);
  }
  /**
   * Clear all interceptors from the stack
   *
   * @returns {void}
   */
  clear() {
    this.handlers && (this.handlers = []);
  }
  /**
   * Iterate over all the registered interceptors
   *
   * This method is particularly useful for skipping over any
   * interceptors that may have become `null` calling `eject`.
   *
   * @param {Function} fn The function to call for each interceptor
   *
   * @returns {void}
   */
  forEach(t) {
    oe.forEach(this.handlers, function(n) {
      n !== null && t(n);
    });
  }
}
const L4 = {
  silentJSONParsing: !0,
  forcedJSONParsing: !0,
  clarifyTimeoutError: !1
}, bB = typeof URLSearchParams < "u" ? URLSearchParams : kw, wB = typeof FormData < "u" ? FormData : null, xB = typeof Blob < "u" ? Blob : null, SB = {
  isBrowser: !0,
  classes: {
    URLSearchParams: bB,
    FormData: wB,
    Blob: xB
  },
  protocols: ["http", "https", "file", "blob", "url", "data"]
}, _w = typeof window < "u" && typeof document < "u", Jv = typeof navigator == "object" && navigator || void 0, kB = _w && (!Jv || ["ReactNative", "NativeScript", "NS"].indexOf(Jv.product) < 0), _B = typeof WorkerGlobalScope < "u" && // eslint-disable-next-line no-undef
self instanceof WorkerGlobalScope && typeof self.importScripts == "function", EB = _w && window.location.href || "http://localhost", CB = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  hasBrowserEnv: _w,
  hasStandardBrowserEnv: kB,
  hasStandardBrowserWebWorkerEnv: _B,
  navigator: Jv,
  origin: EB
}, Symbol.toStringTag, { value: "Module" })), hn = {
  ...CB,
  ...SB
};
function OB(e, t) {
  return vh(e, new hn.classes.URLSearchParams(), Object.assign({
    visitor: function(n, r, o, a) {
      return hn.isNode && oe.isBuffer(n) ? (this.append(r, n.toString("base64")), !1) : a.defaultVisitor.apply(this, arguments);
    }
  }, t));
}
function NB(e) {
  return oe.matchAll(/\w+|\[(\w*)]/g, e).map((t) => t[0] === "[]" ? "" : t[1] || t[0]);
}
function MB(e) {
  const t = {}, n = Object.keys(e);
  let r;
  const o = n.length;
  let a;
  for (r = 0; r < o; r++)
    a = n[r], t[a] = e[a];
  return t;
}
function I4(e) {
  function t(n, r, o, a) {
    let l = n[a++];
    if (l === "__proto__") return !0;
    const u = Number.isFinite(+l), d = a >= n.length;
    return l = !l && oe.isArray(o) ? o.length : l, d ? (oe.hasOwnProp(o, l) ? o[l] = [o[l], r] : o[l] = r, !u) : ((!o[l] || !oe.isObject(o[l])) && (o[l] = []), t(n, r, o[l], a) && oe.isArray(o[l]) && (o[l] = MB(o[l])), !u);
  }
  if (oe.isFormData(e) && oe.isFunction(e.entries)) {
    const n = {};
    return oe.forEachEntry(e, (r, o) => {
      t(NB(r), o, n, 0);
    }), n;
  }
  return null;
}
function AB(e, t, n) {
  if (oe.isString(e))
    try {
      return (t || JSON.parse)(e), oe.trim(e);
    } catch (r) {
      if (r.name !== "SyntaxError")
        throw r;
    }
  return (n || JSON.stringify)(e);
}
const Ic = {
  transitional: L4,
  adapter: ["xhr", "http", "fetch"],
  transformRequest: [function(e, t) {
    const n = t.getContentType() || "", r = n.indexOf("application/json") > -1, o = oe.isObject(e);
    if (o && oe.isHTMLForm(e) && (e = new FormData(e)), oe.isFormData(e))
      return r ? JSON.stringify(I4(e)) : e;
    if (oe.isArrayBuffer(e) || oe.isBuffer(e) || oe.isStream(e) || oe.isFile(e) || oe.isBlob(e) || oe.isReadableStream(e))
      return e;
    if (oe.isArrayBufferView(e))
      return e.buffer;
    if (oe.isURLSearchParams(e))
      return t.setContentType("application/x-www-form-urlencoded;charset=utf-8", !1), e.toString();
    let a;
    if (o) {
      if (n.indexOf("application/x-www-form-urlencoded") > -1)
        return OB(e, this.formSerializer).toString();
      if ((a = oe.isFileList(e)) || n.indexOf("multipart/form-data") > -1) {
        const l = this.env && this.env.FormData;
        return vh(
          a ? { "files[]": e } : e,
          l && new l(),
          this.formSerializer
        );
      }
    }
    return o || r ? (t.setContentType("application/json", !1), AB(e)) : e;
  }],
  transformResponse: [function(e) {
    const t = this.transitional || Ic.transitional, n = t && t.forcedJSONParsing, r = this.responseType === "json";
    if (oe.isResponse(e) || oe.isReadableStream(e))
      return e;
    if (e && oe.isString(e) && (n && !this.responseType || r)) {
      const o = !(t && t.silentJSONParsing) && r;
      try {
        return JSON.parse(e);
      } catch (a) {
        if (o)
          throw a.name === "SyntaxError" ? Be.from(a, Be.ERR_BAD_RESPONSE, this, null, this.response) : a;
      }
    }
    return e;
  }],
  /**
   * A timeout in milliseconds to abort a request. If set to 0 (default) a
   * timeout is not created.
   */
  timeout: 0,
  xsrfCookieName: "XSRF-TOKEN",
  xsrfHeaderName: "X-XSRF-TOKEN",
  maxContentLength: -1,
  maxBodyLength: -1,
  env: {
    FormData: hn.classes.FormData,
    Blob: hn.classes.Blob
  },
  validateStatus: function(e) {
    return e >= 200 && e < 300;
  },
  headers: {
    common: {
      Accept: "application/json, text/plain, */*",
      "Content-Type": void 0
    }
  }
};
oe.forEach(["delete", "get", "head", "post", "put", "patch"], (e) => {
  Ic.headers[e] = {};
});
const RB = oe.toObjectSet([
  "age",
  "authorization",
  "content-length",
  "content-type",
  "etag",
  "expires",
  "from",
  "host",
  "if-modified-since",
  "if-unmodified-since",
  "last-modified",
  "location",
  "max-forwards",
  "proxy-authorization",
  "referer",
  "retry-after",
  "user-agent"
]), jB = (e) => {
  const t = {};
  let n, r, o;
  return e && e.split(`
`).forEach(function(a) {
    o = a.indexOf(":"), n = a.substring(0, o).trim().toLowerCase(), r = a.substring(o + 1).trim(), !(!n || t[n] && RB[n]) && (n === "set-cookie" ? t[n] ? t[n].push(r) : t[n] = [r] : t[n] = t[n] ? t[n] + ", " + r : r);
  }), t;
}, uE = Symbol("internals");
function zu(e) {
  return e && String(e).trim().toLowerCase();
}
function tp(e) {
  return e === !1 || e == null ? e : oe.isArray(e) ? e.map(tp) : String(e);
}
function DB(e) {
  const t = /* @__PURE__ */ Object.create(null), n = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
  let r;
  for (; r = n.exec(e); )
    t[r[1]] = r[2];
  return t;
}
const TB = (e) => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(e.trim());
function Ly(e, t, n, r, o) {
  if (oe.isFunction(r))
    return r.call(this, t, n);
  if (o && (t = n), !!oe.isString(t)) {
    if (oe.isString(r))
      return t.indexOf(r) !== -1;
    if (oe.isRegExp(r))
      return r.test(t);
  }
}
function zB(e) {
  return e.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (t, n, r) => n.toUpperCase() + r);
}
function PB(e, t) {
  const n = oe.toCamelCase(" " + t);
  ["get", "set", "has"].forEach((r) => {
    Object.defineProperty(e, r + n, {
      value: function(o, a, l) {
        return this[r].call(this, t, o, a, l);
      },
      configurable: !0
    });
  });
}
let Pn = class {
  constructor(e) {
    e && this.set(e);
  }
  set(e, t, n) {
    const r = this;
    function o(l, u, d) {
      const f = zu(u);
      if (!f)
        throw new Error("header name must be a non-empty string");
      const p = oe.findKey(r, f);
      (!p || r[p] === void 0 || d === !0 || d === void 0 && r[p] !== !1) && (r[p || u] = tp(l));
    }
    const a = (l, u) => oe.forEach(l, (d, f) => o(d, f, u));
    if (oe.isPlainObject(e) || e instanceof this.constructor)
      a(e, t);
    else if (oe.isString(e) && (e = e.trim()) && !TB(e))
      a(jB(e), t);
    else if (oe.isHeaders(e))
      for (const [l, u] of e.entries())
        o(u, l, n);
    else
      e != null && o(t, e, n);
    return this;
  }
  get(e, t) {
    if (e = zu(e), e) {
      const n = oe.findKey(this, e);
      if (n) {
        const r = this[n];
        if (!t)
          return r;
        if (t === !0)
          return DB(r);
        if (oe.isFunction(t))
          return t.call(this, r, n);
        if (oe.isRegExp(t))
          return t.exec(r);
        throw new TypeError("parser must be boolean|regexp|function");
      }
    }
  }
  has(e, t) {
    if (e = zu(e), e) {
      const n = oe.findKey(this, e);
      return !!(n && this[n] !== void 0 && (!t || Ly(this, this[n], n, t)));
    }
    return !1;
  }
  delete(e, t) {
    const n = this;
    let r = !1;
    function o(a) {
      if (a = zu(a), a) {
        const l = oe.findKey(n, a);
        l && (!t || Ly(n, n[l], l, t)) && (delete n[l], r = !0);
      }
    }
    return oe.isArray(e) ? e.forEach(o) : o(e), r;
  }
  clear(e) {
    const t = Object.keys(this);
    let n = t.length, r = !1;
    for (; n--; ) {
      const o = t[n];
      (!e || Ly(this, this[o], o, e, !0)) && (delete this[o], r = !0);
    }
    return r;
  }
  normalize(e) {
    const t = this, n = {};
    return oe.forEach(this, (r, o) => {
      const a = oe.findKey(n, o);
      if (a) {
        t[a] = tp(r), delete t[o];
        return;
      }
      const l = e ? zB(o) : String(o).trim();
      l !== o && delete t[o], t[l] = tp(r), n[l] = !0;
    }), this;
  }
  concat(...e) {
    return this.constructor.concat(this, ...e);
  }
  toJSON(e) {
    const t = /* @__PURE__ */ Object.create(null);
    return oe.forEach(this, (n, r) => {
      n != null && n !== !1 && (t[r] = e && oe.isArray(n) ? n.join(", ") : n);
    }), t;
  }
  [Symbol.iterator]() {
    return Object.entries(this.toJSON())[Symbol.iterator]();
  }
  toString() {
    return Object.entries(this.toJSON()).map(([e, t]) => e + ": " + t).join(`
`);
  }
  get [Symbol.toStringTag]() {
    return "AxiosHeaders";
  }
  static from(e) {
    return e instanceof this ? e : new this(e);
  }
  static concat(e, ...t) {
    const n = new this(e);
    return t.forEach((r) => n.set(r)), n;
  }
  static accessor(e) {
    const t = (this[uE] = this[uE] = {
      accessors: {}
    }).accessors, n = this.prototype;
    function r(o) {
      const a = zu(o);
      t[a] || (PB(n, o), t[a] = !0);
    }
    return oe.isArray(e) ? e.forEach(r) : r(e), this;
  }
};
Pn.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent", "Authorization"]);
oe.reduceDescriptors(Pn.prototype, ({ value: e }, t) => {
  let n = t[0].toUpperCase() + t.slice(1);
  return {
    get: () => e,
    set(r) {
      this[n] = r;
    }
  };
});
oe.freezeMethods(Pn);
function Iy(e, t) {
  const n = this || Ic, r = t || n, o = Pn.from(r.headers);
  let a = r.data;
  return oe.forEach(e, function(l) {
    a = l.call(n, a, o.normalize(), t ? t.status : void 0);
  }), o.normalize(), a;
}
function B4(e) {
  return !!(e && e.__CANCEL__);
}
function gs(e, t, n) {
  Be.call(this, e ?? "canceled", Be.ERR_CANCELED, t, n), this.name = "CanceledError";
}
oe.inherits(gs, Be, {
  __CANCEL__: !0
});
function V4(e, t, n) {
  const r = n.config.validateStatus;
  !n.status || !r || r(n.status) ? e(n) : t(new Be(
    "Request failed with status code " + n.status,
    [Be.ERR_BAD_REQUEST, Be.ERR_BAD_RESPONSE][Math.floor(n.status / 100) - 4],
    n.config,
    n.request,
    n
  ));
}
function LB(e) {
  const t = /^([-+\w]{1,25})(:?\/\/|:)/.exec(e);
  return t && t[1] || "";
}
function IB(e, t) {
  e = e || 10;
  const n = new Array(e), r = new Array(e);
  let o = 0, a = 0, l;
  return t = t !== void 0 ? t : 1e3, function(u) {
    const d = Date.now(), f = r[a];
    l || (l = d), n[o] = u, r[o] = d;
    let p = a, m = 0;
    for (; p !== o; )
      m += n[p++], p = p % e;
    if (o = (o + 1) % e, o === a && (a = (a + 1) % e), d - l < t)
      return;
    const g = f && d - f;
    return g ? Math.round(m * 1e3 / g) : void 0;
  };
}
function BB(e, t) {
  let n = 0, r = 1e3 / t, o, a;
  const l = (u, d = Date.now()) => {
    n = d, o = null, a && (clearTimeout(a), a = null), e.apply(null, u);
  };
  return [(...u) => {
    const d = Date.now(), f = d - n;
    f >= r ? l(u, d) : (o = u, a || (a = setTimeout(() => {
      a = null, l(o);
    }, r - f)));
  }, () => o && l(o)];
}
const Op = (e, t, n = 3) => {
  let r = 0;
  const o = IB(50, 250);
  return BB((a) => {
    const l = a.loaded, u = a.lengthComputable ? a.total : void 0, d = l - r, f = o(d), p = l <= u;
    r = l;
    const m = {
      loaded: l,
      total: u,
      progress: u ? l / u : void 0,
      bytes: d,
      rate: f || void 0,
      estimated: f && u && p ? (u - l) / f : void 0,
      event: a,
      lengthComputable: u != null,
      [t ? "download" : "upload"]: !0
    };
    e(m);
  }, n);
}, cE = (e, t) => {
  const n = e != null;
  return [(r) => t[0]({
    lengthComputable: n,
    total: e,
    loaded: r
  }), t[1]];
}, dE = (e) => (...t) => oe.asap(() => e(...t)), VB = hn.hasStandardBrowserEnv ? /* @__PURE__ */ ((e, t) => (n) => (n = new URL(n, hn.origin), e.protocol === n.protocol && e.host === n.host && (t || e.port === n.port)))(
  new URL(hn.origin),
  hn.navigator && /(msie|trident)/i.test(hn.navigator.userAgent)
) : () => !0, HB = hn.hasStandardBrowserEnv ? (
  // Standard browser envs support document.cookie
  {
    write(e, t, n, r, o, a) {
      const l = [e + "=" + encodeURIComponent(t)];
      oe.isNumber(n) && l.push("expires=" + new Date(n).toGMTString()), oe.isString(r) && l.push("path=" + r), oe.isString(o) && l.push("domain=" + o), a === !0 && l.push("secure"), document.cookie = l.join("; ");
    },
    read(e) {
      const t = document.cookie.match(new RegExp("(^|;\\s*)(" + e + ")=([^;]*)"));
      return t ? decodeURIComponent(t[3]) : null;
    },
    remove(e) {
      this.write(e, "", Date.now() - 864e5);
    }
  }
) : (
  // Non-standard browser env (web workers, react-native) lack needed support.
  {
    write() {
    },
    read() {
      return null;
    },
    remove() {
    }
  }
);
function UB(e) {
  return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(e);
}
function FB(e, t) {
  return t ? e.replace(/\/?\/$/, "") + "/" + t.replace(/^\/+/, "") : e;
}
function H4(e, t, n) {
  let r = !UB(t);
  return e && (r || n == !1) ? FB(e, t) : t;
}
const fE = (e) => e instanceof Pn ? { ...e } : e;
function Ra(e, t) {
  t = t || {};
  const n = {};
  function r(f, p, m, g) {
    return oe.isPlainObject(f) && oe.isPlainObject(p) ? oe.merge.call({ caseless: g }, f, p) : oe.isPlainObject(p) ? oe.merge({}, p) : oe.isArray(p) ? p.slice() : p;
  }
  function o(f, p, m, g) {
    if (oe.isUndefined(p)) {
      if (!oe.isUndefined(f))
        return r(void 0, f, m, g);
    } else return r(f, p, m, g);
  }
  function a(f, p) {
    if (!oe.isUndefined(p))
      return r(void 0, p);
  }
  function l(f, p) {
    if (oe.isUndefined(p)) {
      if (!oe.isUndefined(f))
        return r(void 0, f);
    } else return r(void 0, p);
  }
  function u(f, p, m) {
    if (m in t)
      return r(f, p);
    if (m in e)
      return r(void 0, f);
  }
  const d = {
    url: a,
    method: a,
    data: a,
    baseURL: l,
    transformRequest: l,
    transformResponse: l,
    paramsSerializer: l,
    timeout: l,
    timeoutMessage: l,
    withCredentials: l,
    withXSRFToken: l,
    adapter: l,
    responseType: l,
    xsrfCookieName: l,
    xsrfHeaderName: l,
    onUploadProgress: l,
    onDownloadProgress: l,
    decompress: l,
    maxContentLength: l,
    maxBodyLength: l,
    beforeRedirect: l,
    transport: l,
    httpAgent: l,
    httpsAgent: l,
    cancelToken: l,
    socketPath: l,
    responseEncoding: l,
    validateStatus: u,
    headers: (f, p, m) => o(fE(f), fE(p), m, !0)
  };
  return oe.forEach(Object.keys(Object.assign({}, e, t)), function(f) {
    const p = d[f] || o, m = p(e[f], t[f], f);
    oe.isUndefined(m) && p !== u || (n[f] = m);
  }), n;
}
const U4 = (e) => {
  const t = Ra({}, e);
  let { data: n, withXSRFToken: r, xsrfHeaderName: o, xsrfCookieName: a, headers: l, auth: u } = t;
  t.headers = l = Pn.from(l), t.url = P4(H4(t.baseURL, t.url, t.allowAbsoluteUrls), e.params, e.paramsSerializer), u && l.set(
    "Authorization",
    "Basic " + btoa((u.username || "") + ":" + (u.password ? unescape(encodeURIComponent(u.password)) : ""))
  );
  let d;
  if (oe.isFormData(n)) {
    if (hn.hasStandardBrowserEnv || hn.hasStandardBrowserWebWorkerEnv)
      l.setContentType(void 0);
    else if ((d = l.getContentType()) !== !1) {
      const [f, ...p] = d ? d.split(";").map((m) => m.trim()).filter(Boolean) : [];
      l.setContentType([f || "multipart/form-data", ...p].join("; "));
    }
  }
  if (hn.hasStandardBrowserEnv && (r && oe.isFunction(r) && (r = r(t)), r || r !== !1 && VB(t.url))) {
    const f = o && a && HB.read(a);
    f && l.set(o, f);
  }
  return t;
}, $B = typeof XMLHttpRequest < "u", YB = $B && function(e) {
  return new Promise(function(t, n) {
    const r = U4(e);
    let o = r.data;
    const a = Pn.from(r.headers).normalize();
    let { responseType: l, onUploadProgress: u, onDownloadProgress: d } = r, f, p, m, g, y;
    function w() {
      g && g(), y && y(), r.cancelToken && r.cancelToken.unsubscribe(f), r.signal && r.signal.removeEventListener("abort", f);
    }
    let v = new XMLHttpRequest();
    v.open(r.method.toUpperCase(), r.url, !0), v.timeout = r.timeout;
    function x() {
      if (!v)
        return;
      const N = Pn.from(
        "getAllResponseHeaders" in v && v.getAllResponseHeaders()
      ), C = {
        data: !l || l === "text" || l === "json" ? v.responseText : v.response,
        status: v.status,
        statusText: v.statusText,
        headers: N,
        config: e,
        request: v
      };
      V4(function(A) {
        t(A), w();
      }, function(A) {
        n(A), w();
      }, C), v = null;
    }
    "onloadend" in v ? v.onloadend = x : v.onreadystatechange = function() {
      !v || v.readyState !== 4 || v.status === 0 && !(v.responseURL && v.responseURL.indexOf("file:") === 0) || setTimeout(x);
    }, v.onabort = function() {
      v && (n(new Be("Request aborted", Be.ECONNABORTED, e, v)), v = null);
    }, v.onerror = function() {
      n(new Be("Network Error", Be.ERR_NETWORK, e, v)), v = null;
    }, v.ontimeout = function() {
      let N = r.timeout ? "timeout of " + r.timeout + "ms exceeded" : "timeout exceeded";
      const C = r.transitional || L4;
      r.timeoutErrorMessage && (N = r.timeoutErrorMessage), n(new Be(
        N,
        C.clarifyTimeoutError ? Be.ETIMEDOUT : Be.ECONNABORTED,
        e,
        v
      )), v = null;
    }, o === void 0 && a.setContentType(null), "setRequestHeader" in v && oe.forEach(a.toJSON(), function(N, C) {
      v.setRequestHeader(C, N);
    }), oe.isUndefined(r.withCredentials) || (v.withCredentials = !!r.withCredentials), l && l !== "json" && (v.responseType = r.responseType), d && ([m, y] = Op(d, !0), v.addEventListener("progress", m)), u && v.upload && ([p, g] = Op(u), v.upload.addEventListener("progress", p), v.upload.addEventListener("loadend", g)), (r.cancelToken || r.signal) && (f = (N) => {
      v && (n(!N || N.type ? new gs(null, e, v) : N), v.abort(), v = null);
    }, r.cancelToken && r.cancelToken.subscribe(f), r.signal && (r.signal.aborted ? f() : r.signal.addEventListener("abort", f)));
    const E = LB(r.url);
    if (E && hn.protocols.indexOf(E) === -1) {
      n(new Be("Unsupported protocol " + E + ":", Be.ERR_BAD_REQUEST, e));
      return;
    }
    v.send(o || null);
  });
}, qB = (e, t) => {
  const { length: n } = e = e ? e.filter(Boolean) : [];
  if (t || n) {
    let r = new AbortController(), o;
    const a = function(f) {
      if (!o) {
        o = !0, u();
        const p = f instanceof Error ? f : this.reason;
        r.abort(p instanceof Be ? p : new gs(p instanceof Error ? p.message : p));
      }
    };
    let l = t && setTimeout(() => {
      l = null, a(new Be(`timeout ${t} of ms exceeded`, Be.ETIMEDOUT));
    }, t);
    const u = () => {
      e && (l && clearTimeout(l), l = null, e.forEach((f) => {
        f.unsubscribe ? f.unsubscribe(a) : f.removeEventListener("abort", a);
      }), e = null);
    };
    e.forEach((f) => f.addEventListener("abort", a));
    const { signal: d } = r;
    return d.unsubscribe = () => oe.asap(u), d;
  }
}, XB = function* (e, t) {
  let n = e.byteLength;
  if (n < t) {
    yield e;
    return;
  }
  let r = 0, o;
  for (; r < n; )
    o = r + t, yield e.slice(r, o), r = o;
}, GB = async function* (e, t) {
  for await (const n of ZB(e))
    yield* XB(n, t);
}, ZB = async function* (e) {
  if (e[Symbol.asyncIterator]) {
    yield* e;
    return;
  }
  const t = e.getReader();
  try {
    for (; ; ) {
      const { done: n, value: r } = await t.read();
      if (n)
        break;
      yield r;
    }
  } finally {
    await t.cancel();
  }
}, pE = (e, t, n, r) => {
  const o = GB(e, t);
  let a = 0, l, u = (d) => {
    l || (l = !0, r && r(d));
  };
  return new ReadableStream({
    async pull(d) {
      try {
        const { done: f, value: p } = await o.next();
        if (f) {
          u(), d.close();
          return;
        }
        let m = p.byteLength;
        if (n) {
          let g = a += m;
          n(g);
        }
        d.enqueue(new Uint8Array(p));
      } catch (f) {
        throw u(f), f;
      }
    },
    cancel(d) {
      return u(d), o.return();
    }
  }, {
    highWaterMark: 2
  });
}, bh = typeof fetch == "function" && typeof Request == "function" && typeof Response == "function", F4 = bh && typeof ReadableStream == "function", WB = bh && (typeof TextEncoder == "function" ? /* @__PURE__ */ ((e) => (t) => e.encode(t))(new TextEncoder()) : async (e) => new Uint8Array(await new Response(e).arrayBuffer())), $4 = (e, ...t) => {
  try {
    return !!e(...t);
  } catch {
    return !1;
  }
}, KB = F4 && $4(() => {
  let e = !1;
  const t = new Request(hn.origin, {
    body: new ReadableStream(),
    method: "POST",
    get duplex() {
      return e = !0, "half";
    }
  }).headers.has("Content-Type");
  return e && !t;
}), hE = 64 * 1024, eb = F4 && $4(() => oe.isReadableStream(new Response("").body)), Np = {
  stream: eb && ((e) => e.body)
};
bh && ((e) => {
  ["text", "arrayBuffer", "blob", "formData", "stream"].forEach((t) => {
    !Np[t] && (Np[t] = oe.isFunction(e[t]) ? (n) => n[t]() : (n, r) => {
      throw new Be(`Response type '${t}' is not supported`, Be.ERR_NOT_SUPPORT, r);
    });
  });
})(new Response());
const QB = async (e) => {
  if (e == null)
    return 0;
  if (oe.isBlob(e))
    return e.size;
  if (oe.isSpecCompliantForm(e))
    return (await new Request(hn.origin, {
      method: "POST",
      body: e
    }).arrayBuffer()).byteLength;
  if (oe.isArrayBufferView(e) || oe.isArrayBuffer(e))
    return e.byteLength;
  if (oe.isURLSearchParams(e) && (e = e + ""), oe.isString(e))
    return (await WB(e)).byteLength;
}, JB = async (e, t) => oe.toFiniteNumber(e.getContentLength()) ?? QB(t), eV = bh && (async (e) => {
  let {
    url: t,
    method: n,
    data: r,
    signal: o,
    cancelToken: a,
    timeout: l,
    onDownloadProgress: u,
    onUploadProgress: d,
    responseType: f,
    headers: p,
    withCredentials: m = "same-origin",
    fetchOptions: g
  } = U4(e);
  f = f ? (f + "").toLowerCase() : "text";
  let y = qB([o, a && a.toAbortSignal()], l), w;
  const v = y && y.unsubscribe && (() => {
    y.unsubscribe();
  });
  let x;
  try {
    if (d && KB && n !== "get" && n !== "head" && (x = await JB(p, r)) !== 0) {
      let R = new Request(t, {
        method: "POST",
        body: r,
        duplex: "half"
      }), D;
      if (oe.isFormData(r) && (D = R.headers.get("content-type")) && p.setContentType(D), R.body) {
        const [T, V] = cE(
          x,
          Op(dE(d))
        );
        r = pE(R.body, hE, T, V);
      }
    }
    oe.isString(m) || (m = m ? "include" : "omit");
    const E = "credentials" in Request.prototype;
    w = new Request(t, {
      ...g,
      signal: y,
      method: n.toUpperCase(),
      headers: p.normalize().toJSON(),
      body: r,
      duplex: "half",
      credentials: E ? m : void 0
    });
    let N = await fetch(w);
    const C = eb && (f === "stream" || f === "response");
    if (eb && (u || C && v)) {
      const R = {};
      ["status", "statusText", "headers"].forEach((F) => {
        R[F] = N[F];
      });
      const D = oe.toFiniteNumber(N.headers.get("content-length")), [T, V] = u && cE(
        D,
        Op(dE(u), !0)
      ) || [];
      N = new Response(
        pE(N.body, hE, T, () => {
          V && V(), v && v();
        }),
        R
      );
    }
    f = f || "text";
    let A = await Np[oe.findKey(Np, f) || "text"](N, e);
    return !C && v && v(), await new Promise((R, D) => {
      V4(R, D, {
        data: A,
        headers: Pn.from(N.headers),
        status: N.status,
        statusText: N.statusText,
        config: e,
        request: w
      });
    });
  } catch (E) {
    throw v && v(), E && E.name === "TypeError" && /fetch/i.test(E.message) ? Object.assign(
      new Be("Network Error", Be.ERR_NETWORK, e, w),
      {
        cause: E.cause || E
      }
    ) : Be.from(E, E && E.code, e, w);
  }
}), tb = {
  http: mB,
  xhr: YB,
  fetch: eV
};
oe.forEach(tb, (e, t) => {
  if (e) {
    try {
      Object.defineProperty(e, "name", { value: t });
    } catch {
    }
    Object.defineProperty(e, "adapterName", { value: t });
  }
});
const mE = (e) => `- ${e}`, tV = (e) => oe.isFunction(e) || e === null || e === !1, Y4 = {
  getAdapter: (e) => {
    e = oe.isArray(e) ? e : [e];
    const { length: t } = e;
    let n, r;
    const o = {};
    for (let a = 0; a < t; a++) {
      n = e[a];
      let l;
      if (r = n, !tV(n) && (r = tb[(l = String(n)).toLowerCase()], r === void 0))
        throw new Be(`Unknown adapter '${l}'`);
      if (r)
        break;
      o[l || "#" + a] = r;
    }
    if (!r) {
      const a = Object.entries(o).map(
        ([u, d]) => `adapter ${u} ` + (d === !1 ? "is not supported by the environment" : "is not available in the build")
      );
      let l = t ? a.length > 1 ? `since :
` + a.map(mE).join(`
`) : " " + mE(a[0]) : "as no adapter specified";
      throw new Be(
        "There is no suitable adapter to dispatch the request " + l,
        "ERR_NOT_SUPPORT"
      );
    }
    return r;
  },
  adapters: tb
};
function By(e) {
  if (e.cancelToken && e.cancelToken.throwIfRequested(), e.signal && e.signal.aborted)
    throw new gs(null, e);
}
function gE(e) {
  return By(e), e.headers = Pn.from(e.headers), e.data = Iy.call(
    e,
    e.transformRequest
  ), ["post", "put", "patch"].indexOf(e.method) !== -1 && e.headers.setContentType("application/x-www-form-urlencoded", !1), Y4.getAdapter(e.adapter || Ic.adapter)(e).then(function(t) {
    return By(e), t.data = Iy.call(
      e,
      e.transformResponse,
      t
    ), t.headers = Pn.from(t.headers), t;
  }, function(t) {
    return B4(t) || (By(e), t && t.response && (t.response.data = Iy.call(
      e,
      e.transformResponse,
      t.response
    ), t.response.headers = Pn.from(t.response.headers))), Promise.reject(t);
  });
}
const q4 = "1.8.4", wh = {};
["object", "boolean", "number", "function", "string", "symbol"].forEach((e, t) => {
  wh[e] = function(n) {
    return typeof n === e || "a" + (t < 1 ? "n " : " ") + e;
  };
});
const yE = {};
wh.transitional = function(e, t, n) {
  function r(o, a) {
    return "[Axios v" + q4 + "] Transitional option '" + o + "'" + a + (n ? ". " + n : "");
  }
  return (o, a, l) => {
    if (e === !1)
      throw new Be(
        r(a, " has been removed" + (t ? " in " + t : "")),
        Be.ERR_DEPRECATED
      );
    return t && !yE[a] && (yE[a] = !0, console.warn(
      r(
        a,
        " has been deprecated since v" + t + " and will be removed in the near future"
      )
    )), e ? e(o, a, l) : !0;
  };
};
wh.spelling = function(e) {
  return (t, n) => (console.warn(`${n} is likely a misspelling of ${e}`), !0);
};
function nV(e, t, n) {
  if (typeof e != "object")
    throw new Be("options must be an object", Be.ERR_BAD_OPTION_VALUE);
  const r = Object.keys(e);
  let o = r.length;
  for (; o-- > 0; ) {
    const a = r[o], l = t[a];
    if (l) {
      const u = e[a], d = u === void 0 || l(u, a, e);
      if (d !== !0)
        throw new Be("option " + a + " must be " + d, Be.ERR_BAD_OPTION_VALUE);
      continue;
    }
    if (n !== !0)
      throw new Be("Unknown option " + a, Be.ERR_BAD_OPTION);
  }
}
const np = {
  assertOptions: nV,
  validators: wh
}, Yr = np.validators;
let Na = class {
  constructor(e) {
    this.defaults = e, this.interceptors = {
      request: new sE(),
      response: new sE()
    };
  }
  /**
   * Dispatch a request
   *
   * @param {String|Object} configOrUrl The config specific for this request (merged with this.defaults)
   * @param {?Object} config
   *
   * @returns {Promise} The Promise to be fulfilled
   */
  async request(e, t) {
    try {
      return await this._request(e, t);
    } catch (n) {
      if (n instanceof Error) {
        let r = {};
        Error.captureStackTrace ? Error.captureStackTrace(r) : r = new Error();
        const o = r.stack ? r.stack.replace(/^.+\n/, "") : "";
        try {
          n.stack ? o && !String(n.stack).endsWith(o.replace(/^.+\n.+\n/, "")) && (n.stack += `
` + o) : n.stack = o;
        } catch {
        }
      }
      throw n;
    }
  }
  _request(e, t) {
    typeof e == "string" ? (t = t || {}, t.url = e) : t = e || {}, t = Ra(this.defaults, t);
    const { transitional: n, paramsSerializer: r, headers: o } = t;
    n !== void 0 && np.assertOptions(n, {
      silentJSONParsing: Yr.transitional(Yr.boolean),
      forcedJSONParsing: Yr.transitional(Yr.boolean),
      clarifyTimeoutError: Yr.transitional(Yr.boolean)
    }, !1), r != null && (oe.isFunction(r) ? t.paramsSerializer = {
      serialize: r
    } : np.assertOptions(r, {
      encode: Yr.function,
      serialize: Yr.function
    }, !0)), t.allowAbsoluteUrls !== void 0 || (this.defaults.allowAbsoluteUrls !== void 0 ? t.allowAbsoluteUrls = this.defaults.allowAbsoluteUrls : t.allowAbsoluteUrls = !0), np.assertOptions(t, {
      baseUrl: Yr.spelling("baseURL"),
      withXsrfToken: Yr.spelling("withXSRFToken")
    }, !0), t.method = (t.method || this.defaults.method || "get").toLowerCase();
    let a = o && oe.merge(
      o.common,
      o[t.method]
    );
    o && oe.forEach(
      ["delete", "get", "head", "post", "put", "patch", "common"],
      (y) => {
        delete o[y];
      }
    ), t.headers = Pn.concat(a, o);
    const l = [];
    let u = !0;
    this.interceptors.request.forEach(function(y) {
      typeof y.runWhen == "function" && y.runWhen(t) === !1 || (u = u && y.synchronous, l.unshift(y.fulfilled, y.rejected));
    });
    const d = [];
    this.interceptors.response.forEach(function(y) {
      d.push(y.fulfilled, y.rejected);
    });
    let f, p = 0, m;
    if (!u) {
      const y = [gE.bind(this), void 0];
      for (y.unshift.apply(y, l), y.push.apply(y, d), m = y.length, f = Promise.resolve(t); p < m; )
        f = f.then(y[p++], y[p++]);
      return f;
    }
    m = l.length;
    let g = t;
    for (p = 0; p < m; ) {
      const y = l[p++], w = l[p++];
      try {
        g = y(g);
      } catch (v) {
        w.call(this, v);
        break;
      }
    }
    try {
      f = gE.call(this, g);
    } catch (y) {
      return Promise.reject(y);
    }
    for (p = 0, m = d.length; p < m; )
      f = f.then(d[p++], d[p++]);
    return f;
  }
  getUri(e) {
    e = Ra(this.defaults, e);
    const t = H4(e.baseURL, e.url, e.allowAbsoluteUrls);
    return P4(t, e.params, e.paramsSerializer);
  }
};
oe.forEach(["delete", "get", "head", "options"], function(e) {
  Na.prototype[e] = function(t, n) {
    return this.request(Ra(n || {}, {
      method: e,
      url: t,
      data: (n || {}).data
    }));
  };
});
oe.forEach(["post", "put", "patch"], function(e) {
  function t(n) {
    return function(r, o, a) {
      return this.request(Ra(a || {}, {
        method: e,
        headers: n ? {
          "Content-Type": "multipart/form-data"
        } : {},
        url: r,
        data: o
      }));
    };
  }
  Na.prototype[e] = t(), Na.prototype[e + "Form"] = t(!0);
});
let rV = class X4 {
  constructor(t) {
    if (typeof t != "function")
      throw new TypeError("executor must be a function.");
    let n;
    this.promise = new Promise(function(o) {
      n = o;
    });
    const r = this;
    this.promise.then((o) => {
      if (!r._listeners) return;
      let a = r._listeners.length;
      for (; a-- > 0; )
        r._listeners[a](o);
      r._listeners = null;
    }), this.promise.then = (o) => {
      let a;
      const l = new Promise((u) => {
        r.subscribe(u), a = u;
      }).then(o);
      return l.cancel = function() {
        r.unsubscribe(a);
      }, l;
    }, t(function(o, a, l) {
      r.reason || (r.reason = new gs(o, a, l), n(r.reason));
    });
  }
  /**
   * Throws a `CanceledError` if cancellation has been requested.
   */
  throwIfRequested() {
    if (this.reason)
      throw this.reason;
  }
  /**
   * Subscribe to the cancel signal
   */
  subscribe(t) {
    if (this.reason) {
      t(this.reason);
      return;
    }
    this._listeners ? this._listeners.push(t) : this._listeners = [t];
  }
  /**
   * Unsubscribe from the cancel signal
   */
  unsubscribe(t) {
    if (!this._listeners)
      return;
    const n = this._listeners.indexOf(t);
    n !== -1 && this._listeners.splice(n, 1);
  }
  toAbortSignal() {
    const t = new AbortController(), n = (r) => {
      t.abort(r);
    };
    return this.subscribe(n), t.signal.unsubscribe = () => this.unsubscribe(n), t.signal;
  }
  /**
   * Returns an object that contains a new `CancelToken` and a function that, when called,
   * cancels the `CancelToken`.
   */
  static source() {
    let t;
    return {
      token: new X4(function(n) {
        t = n;
      }),
      cancel: t
    };
  }
};
function oV(e) {
  return function(t) {
    return e.apply(null, t);
  };
}
function iV(e) {
  return oe.isObject(e) && e.isAxiosError === !0;
}
const nb = {
  Continue: 100,
  SwitchingProtocols: 101,
  Processing: 102,
  EarlyHints: 103,
  Ok: 200,
  Created: 201,
  Accepted: 202,
  NonAuthoritativeInformation: 203,
  NoContent: 204,
  ResetContent: 205,
  PartialContent: 206,
  MultiStatus: 207,
  AlreadyReported: 208,
  ImUsed: 226,
  MultipleChoices: 300,
  MovedPermanently: 301,
  Found: 302,
  SeeOther: 303,
  NotModified: 304,
  UseProxy: 305,
  Unused: 306,
  TemporaryRedirect: 307,
  PermanentRedirect: 308,
  BadRequest: 400,
  Unauthorized: 401,
  PaymentRequired: 402,
  Forbidden: 403,
  NotFound: 404,
  MethodNotAllowed: 405,
  NotAcceptable: 406,
  ProxyAuthenticationRequired: 407,
  RequestTimeout: 408,
  Conflict: 409,
  Gone: 410,
  LengthRequired: 411,
  PreconditionFailed: 412,
  PayloadTooLarge: 413,
  UriTooLong: 414,
  UnsupportedMediaType: 415,
  RangeNotSatisfiable: 416,
  ExpectationFailed: 417,
  ImATeapot: 418,
  MisdirectedRequest: 421,
  UnprocessableEntity: 422,
  Locked: 423,
  FailedDependency: 424,
  TooEarly: 425,
  UpgradeRequired: 426,
  PreconditionRequired: 428,
  TooManyRequests: 429,
  RequestHeaderFieldsTooLarge: 431,
  UnavailableForLegalReasons: 451,
  InternalServerError: 500,
  NotImplemented: 501,
  BadGateway: 502,
  ServiceUnavailable: 503,
  GatewayTimeout: 504,
  HttpVersionNotSupported: 505,
  VariantAlsoNegotiates: 506,
  InsufficientStorage: 507,
  LoopDetected: 508,
  NotExtended: 510,
  NetworkAuthenticationRequired: 511
};
Object.entries(nb).forEach(([e, t]) => {
  nb[t] = e;
});
function G4(e) {
  const t = new Na(e), n = E4(Na.prototype.request, t);
  return oe.extend(n, Na.prototype, t, { allOwnKeys: !0 }), oe.extend(n, t, null, { allOwnKeys: !0 }), n.create = function(r) {
    return G4(Ra(e, r));
  }, n;
}
const Tt = G4(Ic);
Tt.Axios = Na;
Tt.CanceledError = gs;
Tt.CancelToken = rV;
Tt.isCancel = B4;
Tt.VERSION = q4;
Tt.toFormData = vh;
Tt.AxiosError = Be;
Tt.Cancel = Tt.CanceledError;
Tt.all = function(e) {
  return Promise.all(e);
};
Tt.spread = oV;
Tt.isAxiosError = iV;
Tt.mergeConfig = Ra;
Tt.AxiosHeaders = Pn;
Tt.formToJSON = (e) => I4(oe.isHTMLForm(e) ? new FormData(e) : e);
Tt.getAdapter = Y4.getAdapter;
Tt.HttpStatusCode = nb;
Tt.default = Tt;
const {
  Axios: zue,
  AxiosError: Pue,
  CanceledError: Lue,
  isCancel: Iue,
  CancelToken: Bue,
  VERSION: Vue,
  all: Hue,
  Cancel: Uue,
  isAxiosError: Fue,
  spread: $ue,
  toFormData: Yue,
  AxiosHeaders: que,
  HttpStatusCode: Xue,
  formToJSON: Gue,
  getAdapter: Zue,
  mergeConfig: Wue
} = Tt, on = [];
for (let e = 0; e < 256; ++e)
  on.push((e + 256).toString(16).slice(1));
function aV(e, t = 0) {
  return (on[e[t + 0]] + on[e[t + 1]] + on[e[t + 2]] + on[e[t + 3]] + "-" + on[e[t + 4]] + on[e[t + 5]] + "-" + on[e[t + 6]] + on[e[t + 7]] + "-" + on[e[t + 8]] + on[e[t + 9]] + "-" + on[e[t + 10]] + on[e[t + 11]] + on[e[t + 12]] + on[e[t + 13]] + on[e[t + 14]] + on[e[t + 15]]).toLowerCase();
}
let Vy;
const lV = new Uint8Array(16);
function sV() {
  if (!Vy) {
    if (typeof crypto > "u" || !crypto.getRandomValues)
      throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
    Vy = crypto.getRandomValues.bind(crypto);
  }
  return Vy(lV);
}
const uV = typeof crypto < "u" && crypto.randomUUID && crypto.randomUUID.bind(crypto), vE = { randomUUID: uV };
function Z4(e, t, n) {
  var r;
  if (vE.randomUUID && !e)
    return vE.randomUUID();
  e = e || {};
  const o = e.random ?? ((r = e.rng) == null ? void 0 : r.call(e)) ?? sV();
  if (o.length < 16)
    throw new Error("Random bytes length must be >= 16");
  return o[6] = o[6] & 15 | 64, o[8] = o[8] & 63 | 128, aV(o);
}
class W4 {
  constructor(t) {
    this.CHUNK_TIMEOUT = 1e4, this.PONGDELAY = 2e3, this.blobChunks = {}, this._hooks = /* @__PURE__ */ new Map(), this._ns_event_intercepts = /* @__PURE__ */ new Map(), this._unique_cmd_outs = {}, this.uuid = t.uuid, this.on_error = t.on_error || ((n) => {
      var r;
      (r = this._zustand) == null || r.logger.error(n);
    }), this.messagePromises = /* @__PURE__ */ new Map(), this._local_nodeupdates = /* @__PURE__ */ new Map(), this._nodeupdatetimer = setTimeout(() => {
      this.sync_local_node_updates();
    }, 5e3), this.state = wn((n, r) => ({
      is_open: !1
    })), t.zustand && this.set_zustand(t.zustand), t.on_sync_complete ? this.on_sync_complete = t.on_sync_complete : this.on_sync_complete = async () => {
    }, this._responsive = !1, this._last_pong = Date.now() - this.PONGDELAY * 100, setInterval(() => {
      this.is_open && this.send({ type: "ping" });
    }, this.PONGDELAY), setInterval(() => {
      Date.now() - this._last_pong > this.PONGDELAY * 3 ? this._responsive = !1 : this._responsive = !0;
    }, this.PONGDELAY * 2), setInterval(() => {
      const n = Date.now();
      for (const r in this.blobChunks)
        n - this.blobChunks[r].timestamp > this.CHUNK_TIMEOUT && delete this.blobChunks[r];
    }, this.CHUNK_TIMEOUT / 2);
  }
  _receive_pong() {
    this._last_pong = Date.now(), this._responsive = !0;
  }
  set_zustand(t) {
    t !== this._zustand && (this._zustand = t, t.set_worker(this), this._zustand.auto_progress(), this.stepwise_fullsync());
  }
  add_hook(t, n) {
    const r = this._hooks.get(t) || [];
    return r.push(n), this._hooks.set(t, r), () => {
      const o = this._hooks.get(t) || [], a = o.indexOf(n);
      a >= 0 && o.splice(a, 1);
    };
  }
  async call_hooks(t, n) {
    const r = [];
    for (const o of this._hooks.get(t) || []) {
      const a = o({ worker: this, data: n });
      a instanceof Promise && r.push(a);
    }
    await Promise.all(r);
  }
  add_ns_event_intercept(t, n) {
    const r = this._ns_event_intercepts.get(t) || [];
    return r.push(n), this._ns_event_intercepts.set(t, r), () => {
      const o = this._ns_event_intercepts.get(t) || [], a = o.indexOf(n);
      a >= 0 && o.splice(a, 1);
    };
  }
  async intercept_ns_event(t) {
    let n = t;
    for (const r of this._ns_event_intercepts.get(t.event) || [])
      n = await r(n);
    return n;
  }
  get is_open() {
    return this.state.getState().is_open;
  }
  set is_open(t) {
    this.state.setState({ is_open: t });
  }
  async stepwise_fullsync() {
    this._zustand && this.is_open && (await this.sync_lib(), await this.sync_external_worker(), await this.sync_funcnodes_plugins(), await this.sync_nodespace(), await this.sync_view_state(), await this.on_sync_complete(this));
  }
  async sync_lib() {
    if (!this._zustand || !this.is_open) return;
    const t = await this._send_cmd({
      cmd: "get_library",
      wait_for_response: !0,
      retries: 2,
      unique: !0
    });
    this._zustand.lib.libstate.getState().set({
      lib: t
    });
  }
  async sync_external_worker() {
    if (!this._zustand || !this.is_open) return;
    const t = await this._send_cmd({
      cmd: "get_worker_dependencies",
      wait_for_response: !0,
      unique: !0
    });
    this._zustand.lib.libstate.getState().set({
      external_worker: t
    });
  }
  async sync_funcnodes_plugins() {
    if (!this._zustand || !this.is_open) return;
    const t = await this._send_cmd({
      cmd: "get_plugin_keys",
      wait_for_response: !0,
      unique: !0,
      kwargs: { type: "react" }
    });
    for (const n of t) {
      const r = await this._send_cmd({
        cmd: "get_plugin",
        wait_for_response: !0,
        kwargs: { key: n, type: "react" },
        unique: !0
      });
      if (r.js)
        for (const o of r.js) {
          const a = document.createElement("script");
          a.text = atob(o), document.body.appendChild(a);
        }
      if (r.css)
        for (const o of r.css) {
          const a = document.createElement("style");
          a.innerHTML = atob(o), document.head.appendChild(a);
        }
      if (r.module !== void 0) {
        const o = atob(r.module), a = o.length, l = new Uint8Array(a);
        for (let p = 0; p < a; p++)
          l[p] = o.charCodeAt(p);
        const u = new Blob([l], { type: "application/javascript" }), d = URL.createObjectURL(u), f = await import(
          /* @vite-ignore */
          d
        );
        URL.revokeObjectURL(d), this._zustand.add_plugin(n, f.default);
      }
    }
  }
  async sync_view_state() {
    if (!this._zustand || !this.is_open) return;
    const t = await this._send_cmd({
      cmd: "view_state",
      wait_for_response: !0,
      unique: !0
    });
    t.renderoptions && this._zustand.update_render_options(t.renderoptions);
    const n = t.nodes;
    if (n)
      for (const r in n) {
        const o = {};
        e0(o, n[r]), this._zustand.on_node_action({
          type: "update",
          node: o,
          id: r,
          from_remote: !0
        });
      }
  }
  async sync_nodespace() {
    if (!this._zustand || !this.is_open) return;
    const t = await this._send_cmd({
      cmd: "get_nodes",
      kwargs: { with_frontend: !0 },
      wait_for_response: !0,
      unique: !0
    });
    for (const r of t)
      this._receive_node_added(r);
    const n = await this._send_cmd({
      cmd: "get_edges",
      wait_for_response: !0,
      unique: !0
    });
    for (const r of n)
      this._receive_edge_added(...r);
  }
  async fullsync() {
    if (!this._zustand || !this.is_open) return;
    let t;
    for (; ; )
      try {
        t = await this._send_cmd({
          cmd: "full_state",
          unique: !0
        });
        break;
      } catch (r) {
        this._zustand.logger.error("Error in fullsync", r);
      }
    this._zustand.logger.debug("Full state", t), this._zustand.lib.libstate.getState().set({
      lib: t.backend.lib,
      external_worker: t.worker_dependencies
    }), t.view.renderoptions && this._zustand.update_render_options(t.view.renderoptions);
    const n = t.view.nodes;
    for (const r of t.backend.nodes) {
      const o = n[r.id];
      o !== void 0 && e0(r, o), this._receive_node_added(r);
    }
    for (const r of t.backend.edges)
      this._receive_edge_added(...r);
  }
  async _receive_edge_added(t, n, r, o) {
    this._zustand && this._zustand.on_edge_action({
      type: "add",
      from_remote: !0,
      src_nid: t,
      src_ioid: n,
      trg_nid: r,
      trg_ioid: o
    });
  }
  async trigger_node(t) {
    await this._send_cmd({
      cmd: "trigger_node",
      kwargs: { nid: t },
      wait_for_response: !1
    });
  }
  async add_node(t) {
    const n = await this._send_cmd({
      cmd: "add_node",
      kwargs: { id: t }
    });
    this._receive_node_added(n);
  }
  async remove_node(t) {
    await this._send_cmd({
      cmd: "remove_node",
      kwargs: { id: t }
    });
  }
  async _receive_node_added(t) {
    this._zustand && this._zustand.on_node_action({
      type: "add",
      node: t,
      id: t.id,
      from_remote: !0
    });
  }
  add_edge({
    src_nid: t,
    src_ioid: n,
    trg_nid: r,
    trg_ioid: o,
    replace: a = !1
  }) {
    return this._send_cmd({
      cmd: "add_edge",
      kwargs: { src_nid: t, src_ioid: n, trg_nid: r, trg_ioid: o, replace: a }
    });
  }
  remove_edge({
    src_nid: t,
    src_ioid: n,
    trg_nid: r,
    trg_ioid: o
  }) {
    return this._send_cmd({
      cmd: "remove_edge",
      kwargs: { src_nid: t, src_ioid: n, trg_nid: r, trg_ioid: o }
    });
  }
  async add_external_worker({
    module: t,
    cls_module: n,
    cls_name: r
  }) {
    return await this._send_cmd({
      cmd: "add_external_worker",
      kwargs: { module: t, cls_module: n, cls_name: r }
    });
  }
  sync_local_node_updates() {
    clearTimeout(this._nodeupdatetimer), this._local_nodeupdates.forEach(async (t, n) => {
      const r = await this._send_cmd({
        cmd: "update_node",
        kwargs: { nid: n, data: t },
        wait_for_response: !0
      });
      this._zustand && this._zustand.on_node_action({
        type: "update",
        node: r,
        id: n,
        from_remote: !0
      });
    }), this._local_nodeupdates.clear(), this._nodeupdatetimer = setTimeout(() => {
      this.sync_local_node_updates();
    }, 200);
  }
  locally_update_node(t) {
    const n = this._local_nodeupdates.get(t.id);
    if (n) {
      const { new_obj: r, change: o } = Mr(n, t.node);
      o && this._local_nodeupdates.set(t.id, r);
    } else
      this._local_nodeupdates.set(t.id, t.node);
    t.immediate && this.sync_local_node_updates();
  }
  async get_remote_node_state(t) {
    const n = await this._send_cmd({
      cmd: "get_node_state",
      kwargs: { nid: t },
      wait_for_response: !0
    });
    this._zustand && this._zustand.on_node_action({
      type: "update",
      node: n,
      id: n.id,
      from_remote: !0
    });
  }
  set_io_value({
    nid: t,
    ioid: n,
    value: r,
    set_default: o = !1
  }) {
    return this._send_cmd({
      cmd: "set_io_value",
      kwargs: { nid: t, ioid: n, value: r, set_default: o },
      wait_for_response: !0
    });
  }
  clear() {
    return this._send_cmd({ cmd: "clear", unique: !0 });
  }
  save() {
    return this._send_cmd({
      cmd: "save",
      wait_for_response: !0,
      unique: !0
    });
  }
  load(t) {
    return this._send_cmd({
      cmd: "load_data",
      kwargs: { data: t },
      wait_for_response: !0
    }).then(() => {
      this.stepwise_fullsync();
    });
  }
  async get_io_value({ nid: t, ioid: n }) {
    const r = await this._send_cmd({
      cmd: "get_io_value",
      kwargs: { nid: t, ioid: n },
      wait_for_response: !0
    });
    return this._zustand && this._zustand.on_node_action({
      type: "update",
      node: {
        io: {
          [n]: {
            value: r
          }
        }
      },
      id: t,
      from_remote: !0
    }), r;
  }
  async get_ios_values({ nid: t }) {
    const n = await this._send_cmd({
      cmd: "get_ios_values",
      kwargs: { nid: t },
      wait_for_response: !0
    });
    if (!this._zustand) return n;
    const r = {};
    for (const o in n)
      r[o] = { value: n[o] };
    return this._zustand.on_node_action({
      type: "update",
      node: {
        io: r
      },
      id: t,
      from_remote: !0
    }), n;
  }
  async get_runstate() {
    return await this._send_cmd({
      cmd: "get_runstate",
      wait_for_response: !0,
      unique: !0
    });
  }
  async _send_cmd({
    cmd: t,
    kwargs: n,
    as_bytes: r = !1,
    wait_for_response: o = !0,
    response_timeout: a = 5e3,
    retries: l = 2,
    unique: u = !1
  }) {
    const d = {
      type: "cmd",
      as_bytes: r,
      cmd: t,
      kwargs: n || {}
    };
    if (await new Promise(async (f) => {
      if (this._responsive) return f();
      const p = setInterval(() => {
        this._responsive && (clearInterval(p), f());
      }, 100);
    }), o) {
      if (u && this._unique_cmd_outs[d.cmd] !== void 0)
        return this._unique_cmd_outs[d.cmd];
      l < 0 && (l = 0);
      const f = (async () => {
        let p;
        for (; l >= 0; ) {
          const m = d.id || Z4();
          d.id = m;
          const g = new Promise((y, w) => {
            const v = setTimeout(() => {
              w("Timeout@wait_for_response for " + t);
            }, a);
            this.messagePromises.set(m, {
              resolve: (x) => {
                clearTimeout(v), y(x), this.messagePromises.delete(m);
              },
              reject: (x) => {
                clearTimeout(v), w(x), this.messagePromises.delete(m);
              }
            });
          });
          await this.send(d);
          try {
            p = await g;
            break;
          } catch (y) {
            if (l === 0)
              throw delete this._unique_cmd_outs[d.cmd], y;
            l -= 1;
            continue;
          }
        }
        return delete this._unique_cmd_outs[d.cmd], p;
      })();
      return u && (this._unique_cmd_outs[d.cmd] = f), f;
    }
    return this.send(d);
  }
  async send(t) {
    throw new Error("async send(data: any)  not implemented");
  }
  async upload_file({
    files: t,
    onProgressCallback: n,
    root: r
  }) {
    throw new Error("upload_file not implemented ");
  }
  async handle_large_message_hint({}) {
    throw new Error(
      "async handle_large_message_hint({}: LargeMessageHint) not implemented "
    );
  }
  async receive_workerevent({ event: t, data: n }) {
    switch (t) {
      case "worker_error":
        return this._zustand ? this._zustand.logger.error(n.error) : void 0;
      case "update_worker_dependencies":
        return this._zustand ? this._zustand.lib.libstate.getState().set({
          external_worker: n.worker_dependencies
        }) : void 0;
      case "lib_update":
        await this.sync_lib();
        return;
      case "fullsync":
        await this.stepwise_fullsync();
        return;
      case "external_worker_update":
        await this.sync_lib(), await this.sync_external_worker();
        return;
      case "starting":
        this.call_hooks("starting");
        return;
      case "stopping":
        this.call_hooks("stopping");
        return;
      default:
        console.warn("Unhandled worker event", t, n);
        break;
    }
  }
  async receive_nodespace_event(t) {
    const { event: n, data: r } = await this.intercept_ns_event(t);
    switch (n) {
      case "after_set_value":
        return this._zustand ? this._zustand.on_node_action({
          type: "update",
          node: {
            id: r.node,
            io: {
              [r.io]: {
                value: r.result
              }
            }
          },
          id: r.node,
          from_remote: !0
        }) : void 0;
      case "after_update_value_options":
        return this._zustand ? this._zustand.on_node_action({
          type: "update",
          node: {
            id: r.node,
            io: {
              [r.io]: {
                value_options: r.result
              }
            }
          },
          id: r.node,
          from_remote: !0
        }) : void 0;
      case "triggerstart":
        return this._zustand ? this._zustand.on_node_action({
          type: "update",
          node: {
            id: r.node,
            in_trigger: !0
          },
          id: r.node,
          from_remote: !0
        }) : void 0;
      case "triggerdone":
        return this._zustand ? this._zustand.on_node_action({
          type: "update",
          node: {
            id: r.node,
            in_trigger: !1
          },
          id: r.node,
          from_remote: !0
        }) : void 0;
      case "triggerfast":
        if (!this._zustand) return;
        this._zustand.on_node_action({
          type: "update",
          node: {
            id: r.node,
            in_trigger: !0
          },
          id: r.node,
          from_remote: !0
        }), setTimeout(() => {
          this._zustand && this._zustand.on_node_action({
            type: "update",
            node: {
              id: r.node,
              in_trigger: !1
            },
            id: r.node,
            from_remote: !0
          });
        }, 50);
        return;
      case "node_trigger_error":
        return this._zustand ? this._zustand.on_node_action({
          type: "error",
          errortype: "trigger",
          error: r.error,
          id: r.node,
          tb: r.tb,
          from_remote: !0
        }) : void 0;
      case "node_removed":
        if (!this._zustand) return;
        this._zustand.on_node_action({
          type: "delete",
          id: r.node,
          from_remote: !0
        }), this.call_hooks("node_removed", { node: r.node });
        return;
      case "node_added":
        this._receive_node_added(r.node);
        return;
      case "after_disconnect":
        return !r.result || !Array.isArray(r.result) || r.result.length !== 4 || !this._zustand ? void 0 : this._zustand.on_edge_action({
          type: "delete",
          from_remote: !0,
          src_nid: r.result[0],
          src_ioid: r.result[1],
          trg_nid: r.result[2],
          trg_ioid: r.result[3]
        });
      case "after_unforward":
        return !r.result || !Array.isArray(r.result) || r.result.length !== 4 || !this._zustand ? void 0 : this._zustand.on_edge_action({
          type: "delete",
          from_remote: !0,
          src_nid: r.result[0],
          src_ioid: r.result[1],
          trg_nid: r.result[2],
          trg_ioid: r.result[3]
        });
      case "after_connect":
        return !r.result || !Array.isArray(r.result) || r.result.length !== 4 ? void 0 : this._receive_edge_added(
          ...r.result
        );
      case "after_forward":
        return !r.result || !Array.isArray(r.result) || r.result.length !== 4 ? void 0 : this._receive_edge_added(
          ...r.result
        );
      case "after_add_shelf":
        return !r.result || !this._zustand ? void 0 : this._zustand.lib.libstate.getState().set({
          lib: r.result
        });
      case "after_remove_shelf":
        return !r.result || !this._zustand ? void 0 : this._zustand.lib.libstate.getState().set({
          lib: r.result
        });
      case "progress":
        if (!this._zustand) return;
        if (r.node)
          return this._zustand.on_node_action({
            type: "update",
            node: {
              id: r.node,
              progress: r.info
            },
            id: r.node,
            from_remote: !0
          });
        console.warn("Unhandled nodepsace event", n, r);
        break;
      default:
        if (["after_set_nodespace"].includes(n)) return;
        console.warn("Unhandled nodepsace event", n, r);
        break;
    }
  }
  async add_lib(t, n) {
    return await this._send_cmd({
      cmd: "add_package_dependency",
      kwargs: { name: t, version: n },
      wait_for_response: !1
    });
  }
  async remove_lib(t) {
    return await this._send_cmd({
      cmd: "remove_package_dependency",
      kwargs: { name: t },
      wait_for_response: !1
    });
  }
  async receive(t) {
    let n;
    switch (this._last_pong = Date.now(), this._responsive = !0, t.type) {
      case "pong":
        this._receive_pong();
        return;
      case "nsevent":
        return await this.receive_nodespace_event(t);
      case "result":
        if (n = t.id && this.messagePromises.get(t.id), n)
          return n.resolve(t.result);
        break;
      case "error":
        if (this.on_error(t.tb + `
` + t.error), n = t.id && this.messagePromises.get(t.id), n)
          return n.reject(t.error);
        break;
      case "progress":
        if (!this._zustand) return;
        this._zustand.set_progress(t);
        break;
      case "workerevent":
        return await this.receive_workerevent(t);
      case "large_message":
        return await this.handle_large_message_hint(t);
      default:
        console.warn("Unhandled message", t);
        break;
    }
  }
  async onbytes(t) {
    try {
      const n = new TextDecoder("utf-8").decode(t), r = n.indexOf(`\r
\r
`);
      if (r === -1) {
        console.error(`Header terminator not found for:
`, n);
        return;
      }
      const o = n.substring(0, r + 4), a = t.slice(r + 4), l = o.split(";"), u = {};
      if (l.forEach((m) => {
        const [g, y] = m.split("=");
        u[g.trim()] = y.trim();
      }), !u.chunk || !u.msgid) {
        console.error(
          "Header missing required fields chunk or msgid",
          u
        );
        return;
      }
      const [d, f] = u.chunk.split("/"), p = u.msgid;
      if (d === "1" && f === "1")
        return this.recieve_bytes(u, a);
      if (this.blobChunks[p] || (this.blobChunks[p] = {
        chunks: Array.from({ length: parseInt(f) }, () => null),
        timestamp: Date.now()
      }), this.blobChunks[p].chunks.length !== parseInt(f)) {
        console.error("Total chunks mismatch");
        return;
      }
      if (this.blobChunks[p].chunks[parseInt(d) - 1] = t, this.blobChunks[p].chunks.every((m) => m !== null)) {
        const m = new Uint8Array(
          this.blobChunks[p].chunks.reduce((g, y) => g.concat(Array.from(y)), [])
        );
        this.recieve_bytes(u, m), delete this.blobChunks[p];
      }
    } catch (n) {
      console.error("Websocketworker: onbytes error", n, t);
      return;
    }
  }
  async recieve_bytes(t, n) {
    const { type: r } = t;
    if (r === "io_value") {
      if (!this._zustand) return;
      const { node: o, io: a, preview: l, mime: u } = t, d = l ? "value" : "fullvalue";
      (!o || !a) && console.error("Invalid io_value message", t);
      const f = t0({
        data: n,
        mime: u || "application/octet-stream"
      });
      this._zustand.on_node_action({
        type: "update",
        node: {
          id: o,
          io: {
            [a]: {
              [d]: f
            }
          }
        },
        id: o,
        from_remote: !0
      });
    } else if (r == "result") {
      const o = t.id && this.messagePromises.get(t.id);
      o && o.resolve({ bytes: n, header: t });
    } else
      console.warn("Unhandled bytes message", t);
  }
  disconnect() {
  }
  onclose() {
    this.is_open = !1, this._zustand && this._zustand.auto_progress();
  }
  async reconnect() {
  }
  async stop() {
    await this._send_cmd({ cmd: "stop_worker", wait_for_response: !1 });
    const t = this.onclose.bind(this);
    this.onclose = () => {
      t(), this._zustand && (this._zustand.worker === this && this._zustand.clear_all(), this.onclose = t);
    };
  }
  async get_io_full_value({ nid: t, ioid: n }) {
    const r = await this._send_cmd({
      cmd: "get_io_full_value",
      kwargs: { nid: t, ioid: n },
      wait_for_response: !0,
      as_bytes: !0
    });
    if (!this._zustand) return r;
    if (!this._zustand) return;
    const { header: o, bytes: a } = r, { mime: l } = o, u = t0({
      data: a,
      mime: l || "application/octet-stream"
    });
    return this._zustand.on_node_action({
      type: "update",
      node: {
        id: t,
        io: {
          [n]: {
            fullvalue: u
          }
        }
      },
      id: t,
      from_remote: !0
    }), r;
  }
  async update_io_options({
    nid: t,
    ioid: n,
    options: r
  }) {
    const o = await this._send_cmd({
      cmd: "update_io_options",
      kwargs: { nid: t, ioid: n, ...r },
      wait_for_response: !0
    });
    if (!this._zustand) return o;
    this._zustand.on_node_action({
      type: "update",
      node: {
        io: {
          [n]: {
            ...r
          }
        }
      },
      id: t,
      from_remote: !0
    });
  }
  async get_node_status(t) {
    return await this._send_cmd({
      cmd: "get_node_state",
      kwargs: { nid: t },
      wait_for_response: !0
    });
  }
  async get_available_modules() {
    return await this._send_cmd({
      cmd: "get_available_modules",
      wait_for_response: !0,
      unique: !0
    });
  }
  async update_external_worker(t, n, r) {
    return await this._send_cmd({
      cmd: "update_external_worker",
      kwargs: { worker_id: t, class_id: n, ...r },
      wait_for_response: !0
    });
  }
  async remove_external_worker(t, n) {
    return await this._send_cmd({
      cmd: "remove_external_worker",
      kwargs: { worker_id: t, class_id: n },
      wait_for_response: !0
    });
  }
  async export({ withFiles: t = !1 }) {
    return await this._send_cmd({
      cmd: "export_worker",
      wait_for_response: !0,
      kwargs: { with_files: t }
    });
  }
  async update_from_export(t) {
    const n = this.add_hook("node_added", async ({}) => {
      var r;
      (r = this._zustand) == null || r.center_all();
    });
    try {
      const r = await this._send_cmd({
        cmd: "update_from_export",
        kwargs: { data: t },
        wait_for_response: !0,
        response_timeout: 6e5,
        // 10 minutes
        unique: !0
      });
      return await new Promise((o) => {
        setTimeout(() => {
          o();
        }, 1e3);
      }), await this.stepwise_fullsync(), r;
    } finally {
      n();
    }
  }
}
class K4 extends W4 {
  constructor(t) {
    super(t), this._websocket = null, this.reconnectAttempts = 0, this.maxReconnectAttempts = 999, this.initialTimeout = 200, this.maxTimeout = 5e3, this._reconnect = !0, this._reconnect_timeout = void 0, this._url = t.url, this._reconnect_timeout = setTimeout(() => {
      this.connect();
    }, 200), this._zustand && this._zustand.auto_progress();
  }
  connect() {
    var t;
    (t = this._zustand) == null || t.logger.info("Connecting to websocket"), this.is_open = !1, this._websocket = new WebSocket(this._url), this._websocket.onopen = () => {
      this.onopen();
    }, this._websocket.onclose = () => {
      this.onclose();
    }, this._websocket.onerror = () => {
      this.on_ws_error();
    }, this._websocket.onmessage = (n) => {
      typeof n.data == "string" ? this.onmessage(n.data) : n.data instanceof Blob && n.data.arrayBuffer().then((r) => {
        const o = new Uint8Array(r);
        this.onbytes(o);
      });
    };
  }
  calculateReconnectTimeout() {
    return Math.min(
      this.initialTimeout * Math.pow(2, this.reconnectAttempts),
      this.maxTimeout
    );
  }
  auto_reconnect() {
    var t, n;
    if (this.reconnectAttempts < this.maxReconnectAttempts) {
      let r = this.calculateReconnectTimeout();
      (t = this._zustand) == null || t.logger.info(`Attempting to reconnect in ${r} ms`), this._reconnect_timeout = setTimeout(() => {
        this._websocket && this._websocket.readyState === WebSocket.OPEN || (this.reconnectAttempts++, this.connect());
      }, r);
    } else
      (n = this._zustand) == null || n.logger.warn(
        "Maximum reconnect attempts reached. Giving up."
      );
  }
  async onmessage(t) {
    var n;
    try {
      const r = JSON.parse(t);
      (n = this._zustand) == null || n.logger.debug(
        `Recieved data of length: ${t.length} and data"`,
        r
      ), await this.receive(r);
    } catch (r) {
      console.error("Websocketworker: onmessage JSON.parse error", r, t);
      return;
    }
  }
  get http_protocol() {
    return this.secure_url ? "https" : "http";
  }
  get secure_url() {
    return this._url.startsWith("wss");
  }
  get url_wo_protocol() {
    return this._url.substring(this.secure_url ? 6 : 5);
  }
  get http_url() {
    var t = this.http_protocol + "://" + this.url_wo_protocol;
    return t[t.length - 1] !== "/" && (t += "/"), t;
  }
  get_io_subscription_url({
    node_id: t,
    io_id: n,
    stream: r
  }) {
    let o = this.http_url + `node/${t}/io/${n}/value`;
    return r && (o += "/stream"), o;
  }
  async upload_file({
    files: t,
    onProgressCallback: n,
    root: r
  }) {
    const o = `${this.http_url}upload/`, a = new FormData(), l = Array.isArray(t) ? t : Array.from(t);
    for (const u of l) {
      const d = u.webkitRelativePath || u.name, f = r ? `${r}/${d}` : d;
      a.append("file", u, f);
    }
    try {
      return (await Tt.post(o, a, {
        headers: {
          "Content-Type": "multipart/form-data"
        },
        onUploadProgress: (u) => {
          n && n(u.loaded, u.total);
        }
      })).data.file;
    } catch {
      throw new Error("Failed to upload file");
    }
  }
  async handle_large_message_hint({ msg_id: t }) {
    const n = this.http_url + "message/" + t, r = await (await fetch(n, {
      method: "GET",
      headers: {
        "Content-Type": "application/json",
        "Access-Control-Allow-Origin": "*"
      }
    })).json();
    this.receive(r);
  }
  onopen() {
    var t;
    (t = this._zustand) == null || t.logger.info("Websocket opened"), this.is_open = !0, this._zustand && this._zustand.auto_progress(), this.reconnectAttempts = 0, this.stepwise_fullsync();
  }
  onclose() {
    var t, n;
    (t = this._zustand) == null || t.logger.info("Websocket closed"), super.onclose(), this._reconnect && ((n = this._zustand) == null || n.logger.info("Websocket closed,reconnecting"), this.auto_reconnect());
  }
  on_ws_error() {
    var t;
    (t = this._zustand) == null || t.logger.warn("Websocket error"), this._websocket ? this._websocket.close() : this.auto_reconnect();
  }
  async send_large_message(t) {
    const n = `${this.http_url}message/`;
    await fetch(n, {
      method: "POST",
      headers: {
        "Content-Type": "application/json"
      },
      body: t
    });
  }
  async send(t) {
    var n, r, o;
    if (!this._websocket || this._websocket.readyState !== WebSocket.OPEN) {
      (n = this._zustand) == null || n.logger.warn("Websocket not connected");
      return;
    }
    const a = JSON.stringify(t);
    if (new Blob([a]).size > 1e6)
      return (r = this._zustand) == null || r.logger.info("Data too large, sending via http"), await this.send_large_message(a);
    (o = this._zustand) == null || o.logger.debug("Sending data", t), this._websocket.send(a);
  }
  async stop() {
    await super.stop(), this._reconnect = !1;
  }
  close() {
    this._websocket && this._websocket.close();
  }
  disconnect() {
    super.disconnect(), this._reconnect = !1, this._reconnect_timeout && (clearTimeout(this._reconnect_timeout), this._reconnect_timeout = void 0), this.close();
  }
  async reconnect() {
    var t;
    if (await super.reconnect(), this._reconnect = !0, this._websocket && ((t = this._zustand) == null || t.logger.info("Reconnecting"), (this._websocket.readyState === WebSocket.OPEN || this._websocket.readyState === WebSocket.CONNECTING) && (this._websocket.readyState === WebSocket.CONNECTING && await new Promise((n, r) => {
      if (this._websocket === null) return;
      let o = setTimeout(() => {
        r("Timeout@reconnect");
      }, 2e3);
      this._websocket.addEventListener(
        "open",
        () => {
          clearTimeout(o), n(null);
        },
        { once: !0 }
      ), this._websocket.readyState === WebSocket.OPEN && (clearTimeout(o), n(null));
    }), this._websocket.readyState === WebSocket.OPEN))) {
      this.stepwise_fullsync();
      return;
    }
    this.connect();
  }
}
class cV {
  constructor(t, n) {
    this.ws = null, this.reconnectAttempts = 0, this.maxReconnectAttempts = 999, this.initialTimeout = 200, this.maxTimeout = 2e3, this.wsuri = t, this.zustand = n, this.workers = {}, this.on_setWorker = (r) => {
      this.zustand.set_worker(r);
    }, this.connectionTimeout = setTimeout(() => {
      this.connect();
    }, 200);
  }
  get open() {
    var t;
    return ((t = this.ws) == null ? void 0 : t.readyState) === WebSocket.OPEN;
  }
  connect() {
    this.zustand.set_progress({
      progress: 0,
      message: "connecting to worker manager",
      status: "info",
      blocking: !0
    }), this.zustand.logger.info("Connecting to websocket:", this.wsuri), this.ws = new WebSocket(this.wsuri), this.ws.onopen = () => {
      this.onopen();
    }, this.ws.onclose = () => {
      this.onclose();
    }, this.ws.onerror = () => {
      this.on_ws_error();
    }, this.ws.onmessage = (t) => {
      typeof t.data == "string" ? this.onmessage(t.data) : console.error(
        "WorkerManager: onmessage event.data is not a string",
        typeof t.data
      );
    }, this.connectionTimeout = setTimeout(() => {
      var t;
      ((t = this.ws) == null ? void 0 : t.readyState) !== WebSocket.OPEN && this.on_ws_error();
    }, 5e3);
  }
  on_ws_error() {
    console.warn("Websocket error"), this.ws ? this.ws.close() : this.reconnect();
  }
  onopen() {
    this.connectionTimeout && (clearTimeout(this.connectionTimeout), this.connectionTimeout = void 0), this.zustand.auto_progress(), this.ws && this.ws.send("worker_status");
    const t = window.localStorage.getItem(
      "funcnodes__active_worker"
    );
    t && this.set_active(t);
  }
  onmessage(t) {
    try {
      let n = JSON.parse(t);
      if (n.type === "worker_status") {
        const r = {};
        for (let o of n.active)
          o.active = !0, r[o.uuid] = o;
        for (let o of n.inactive)
          o.active = !1, r[o.uuid] = o;
        this.zustand.workers.setState(r);
        return;
      } else if (n.type === "set_worker") {
        if (n.data.type === "WSWorker") {
          let r = "ws" + (n.data.ssl ? "s" : "") + "://" + n.data.host + ":" + n.data.port;
          this.setWorker(
            this.workers[n.data.uuid] || new K4({
              url: r,
              zustand: this.zustand,
              uuid: n.data.uuid,
              on_sync_complete: this.zustand.options.on_sync_complete
            })
          );
        } else
          this.zustand.logger.error("WorkerManager: unknown worker type", n);
        return;
      } else if (n.type === "progress") {
        this.zustand.set_progress(n);
        return;
      }
      this.zustand.logger.error("WorkerManager: unknown message", n);
    } catch (n) {
      console.error("WorkerManager: onmessage JSON.parse error", n, t);
      return;
    }
  }
  setWorker(t) {
    for (let n in this.workers)
      n !== t?.uuid && this.workers[n].disconnect();
    t !== void 0 && (this.workers[t.uuid] = t, t.reconnect()), t != null && t.uuid && window.localStorage.setItem("funcnodes__active_worker", t?.uuid), this.zustand.worker !== void 0 && this.zustand.clear_all(), this.zustand.set_worker(t), this.on_setWorker(t);
  }
  async restart_worker(t) {
    var n;
    (n = this.ws) == null || n.send(JSON.stringify({ type: "restart_worker", workerid: t }));
  }
  calculateReconnectTimeout() {
    return Math.min(
      this.initialTimeout * Math.pow(2, this.reconnectAttempts),
      this.maxTimeout
    );
  }
  reconnect() {
    if (this.reconnectAttempts < this.maxReconnectAttempts) {
      let t = this.calculateReconnectTimeout();
      this.zustand.logger.info(`Attempting to reconnect in ${t} ms`), setTimeout(() => {
        this.ws && this.ws.readyState === WebSocket.OPEN || (this.reconnectAttempts++, this.connect());
      }, t);
    } else
      this.zustand.logger.warn(
        "Maximum reconnect attempts reached. Giving up."
      );
  }
  onclose() {
    this.zustand.logger.warn("WorkerManager: onclose"), this.reconnect();
  }
  set_active(t) {
    this.ws && this.ws.send(JSON.stringify({ type: "set_active", workerid: t }));
  }
  new_worker({
    name: t,
    reference: n,
    copyLib: r,
    copyNS: o
  }) {
    t || (t = void 0), r || (r = !1), o || (o = !1), n || (n = void 0, r = !1, o = !1), this.ws && this.ws.send(
      JSON.stringify({
        type: "new_worker",
        kwargs: {
          name: t,
          reference: n,
          copyLib: r,
          copyNS: o
        }
      })
    );
  }
  remove() {
    for (let t in this.workers)
      this.workers[t].disconnect();
    this.connectionTimeout && (clearTimeout(this.connectionTimeout), this.connectionTimeout = void 0), this.ws && (this.ws.onclose = () => {
    }, this.ws.onerror = () => {
    }, this.ws.onmessage = () => {
    }, this.ws.onopen = () => {
    }, this.ws.close());
  }
}
function dV(e) {
  const t = window.atob(e), n = t.length, r = new Uint8Array(n);
  for (let o = 0; o < n; o++)
    r[o] = t.charCodeAt(o);
  return r;
}
function fV(e, t) {
  return new Blob([e], { type: t });
}
function pV(e, t) {
  return fV(dV(e), t);
}
function hV(e, t, n) {
  const r = pV(e, n), o = URL.createObjectURL(r), a = document.createElement("a");
  a.href = o, a.download = t, a.click(), URL.revokeObjectURL(o), a.remove();
}
function mV(e, t = !0) {
  return new Promise((n) => {
    const r = new FileReader();
    r.onload = () => {
      const o = r.result;
      t && n(o.split(",")[1]), n(o);
    }, r.readAsDataURL(e);
  });
}
function gV(e) {
  return new Promise((t) => {
    const n = document.createElement("input");
    n.type = "file", n.accept = e, n.onchange = () => {
      var r;
      const o = (r = n.files) == null ? void 0 : r[0];
      o && t(o);
    }, n.click();
  });
}
function yV(e) {
  return gV(e).then(mV);
}
async function vV(e, t = !0) {
  try {
    const n = await fetch(e);
    if (!n.ok)
      throw new Error(
        `Failed to fetch from URL: ${n.status} ${n.statusText}`
      );
    const r = await n.blob();
    return await new Promise((o, a) => {
      const l = new FileReader();
      l.onload = () => {
        const u = l.result;
        typeof u != "string" && (a("Failed to convert URL to Base64: No result from FileReader"), a(l.error)), o(t ? u.split(",")[1] : u);
      }, l.onerror = () => a(l.error), l.readAsDataURL(r);
    });
  } catch (n) {
    throw console.error("Error converting URL to Base64:", n), n;
  }
}
function Te(e, t, { checkForDefaultPrevented: n = !0 } = {}) {
  return function(r) {
    if (e?.(r), n === !1 || !r.defaultPrevented)
      return t?.(r);
  };
}
function bE(e, t) {
  if (typeof e == "function")
    return e(t);
  e != null && (e.current = t);
}
function xh(...e) {
  return (t) => {
    let n = !1;
    const r = e.map((o) => {
      const a = bE(o, t);
      return !n && typeof a == "function" && (n = !0), a;
    });
    if (n)
      return () => {
        for (let o = 0; o < r.length; o++) {
          const a = r[o];
          typeof a == "function" ? a() : bE(e[o], null);
        }
      };
  };
}
function kt(...e) {
  return _.useCallback(xh(...e), e);
}
function bV(e, t) {
  const n = _.createContext(t), r = (a) => {
    const { children: l, ...u } = a, d = _.useMemo(() => u, Object.values(u));
    return /* @__PURE__ */ k.jsx(n.Provider, { value: d, children: l });
  };
  r.displayName = e + "Provider";
  function o(a) {
    const l = _.useContext(n);
    if (l) return l;
    if (t !== void 0) return t;
    throw new Error(`\`${a}\` must be used within \`${e}\``);
  }
  return [r, o];
}
function Gi(e, t = []) {
  let n = [];
  function r(a, l) {
    const u = _.createContext(l), d = n.length;
    n = [...n, l];
    const f = (m) => {
      var g;
      const { scope: y, children: w, ...v } = m, x = ((g = y?.[e]) == null ? void 0 : g[d]) || u, E = _.useMemo(() => v, Object.values(v));
      return /* @__PURE__ */ k.jsx(x.Provider, { value: E, children: w });
    };
    f.displayName = a + "Provider";
    function p(m, g) {
      var y;
      const w = ((y = g?.[e]) == null ? void 0 : y[d]) || u, v = _.useContext(w);
      if (v) return v;
      if (l !== void 0) return l;
      throw new Error(`\`${m}\` must be used within \`${a}\``);
    }
    return [f, p];
  }
  const o = () => {
    const a = n.map((l) => _.createContext(l));
    return function(l) {
      const u = l?.[e] || a;
      return _.useMemo(
        () => ({ [`__scope${e}`]: { ...l, [e]: u } }),
        [l, u]
      );
    };
  };
  return o.scopeName = e, [r, wV(o, ...t)];
}
function wV(...e) {
  const t = e[0];
  if (e.length === 1) return t;
  const n = () => {
    const r = e.map((o) => ({
      useScope: o(),
      scopeName: o.scopeName
    }));
    return function(o) {
      const a = r.reduce((l, { useScope: u, scopeName: d }) => {
        const f = u(o)[`__scope${d}`];
        return { ...l, ...f };
      }, {});
      return _.useMemo(() => ({ [`__scope${t.scopeName}`]: a }), [a]);
    };
  };
  return n.scopeName = t.scopeName, n;
}
var ja = globalThis != null && globalThis.document ? _.useLayoutEffect : () => {
}, xV = jO[" useId ".trim().toString()] || (() => {
}), SV = 0;
function Vo(e) {
  const [t, n] = _.useState(xV());
  return ja(() => {
    n((r) => r ?? String(SV++));
  }, [e]), t ? `radix-${t}` : "";
}
function yr(e) {
  const t = _.useRef(e);
  return _.useEffect(() => {
    t.current = e;
  }), _.useMemo(() => (...n) => {
    var r;
    return (r = t.current) == null ? void 0 : r.call(t, ...n);
  }, []);
}
function ys({
  prop: e,
  defaultProp: t,
  onChange: n = () => {
  }
}) {
  const [r, o] = kV({ defaultProp: t, onChange: n }), a = e !== void 0, l = a ? e : r, u = yr(n), d = _.useCallback(
    (f) => {
      if (a) {
        const p = typeof f == "function" ? f(e) : f;
        p !== e && u(p);
      } else
        o(f);
    },
    [a, e, o, u]
  );
  return [l, d];
}
function kV({
  defaultProp: e,
  onChange: t
}) {
  const n = _.useState(e), [r] = n, o = _.useRef(r), a = yr(t);
  return _.useEffect(() => {
    o.current !== r && (a(r), o.current = r);
  }, [r, o, a]), n;
}
// @__NO_SIDE_EFFECTS__
function ss(e) {
  const t = /* @__PURE__ */ _V(e), n = _.forwardRef((r, o) => {
    const { children: a, ...l } = r, u = _.Children.toArray(a), d = u.find(CV);
    if (d) {
      const f = d.props.children, p = u.map((m) => m === d ? _.Children.count(f) > 1 ? _.Children.only(null) : _.isValidElement(f) ? f.props.children : null : m);
      return /* @__PURE__ */ k.jsx(t, { ...l, ref: o, children: _.isValidElement(f) ? _.cloneElement(f, void 0, p) : null });
    }
    return /* @__PURE__ */ k.jsx(t, { ...l, ref: o, children: a });
  });
  return n.displayName = `${e}.Slot`, n;
}
// @__NO_SIDE_EFFECTS__
function _V(e) {
  const t = _.forwardRef((n, r) => {
    const { children: o, ...a } = n;
    if (_.isValidElement(o)) {
      const l = NV(o), u = OV(a, o.props);
      return o.type !== _.Fragment && (u.ref = r ? xh(r, l) : l), _.cloneElement(o, u);
    }
    return _.Children.count(o) > 1 ? _.Children.only(null) : null;
  });
  return t.displayName = `${e}.SlotClone`, t;
}
var EV = Symbol("radix.slottable");
function CV(e) {
  return _.isValidElement(e) && typeof e.type == "function" && "__radixId" in e.type && e.type.__radixId === EV;
}
function OV(e, t) {
  const n = { ...t };
  for (const r in t) {
    const o = e[r], a = t[r];
    /^on[A-Z]/.test(r) ? o && a ? n[r] = (...l) => {
      a(...l), o(...l);
    } : o && (n[r] = o) : r === "style" ? n[r] = { ...o, ...a } : r === "className" && (n[r] = [o, a].filter(Boolean).join(" "));
  }
  return { ...e, ...n };
}
function NV(e) {
  var t, n;
  let r = (t = Object.getOwnPropertyDescriptor(e.props, "ref")) == null ? void 0 : t.get, o = r && "isReactWarning" in r && r.isReactWarning;
  return o ? e.ref : (r = (n = Object.getOwnPropertyDescriptor(e, "ref")) == null ? void 0 : n.get, o = r && "isReactWarning" in r && r.isReactWarning, o ? e.props.ref : e.props.ref || e.ref);
}
var MV = [
  "a",
  "button",
  "div",
  "form",
  "h2",
  "h3",
  "img",
  "input",
  "label",
  "li",
  "nav",
  "ol",
  "p",
  "span",
  "svg",
  "ul"
], vt = MV.reduce((e, t) => {
  const n = /* @__PURE__ */ ss(`Primitive.${t}`), r = _.forwardRef((o, a) => {
    const { asChild: l, ...u } = o, d = l ? n : t;
    return typeof window < "u" && (window[Symbol.for("radix-ui")] = !0), /* @__PURE__ */ k.jsx(d, { ...u, ref: a });
  });
  return r.displayName = `Primitive.${t}`, { ...e, [t]: r };
}, {});
function Q4(e, t) {
  e && Mc.flushSync(() => e.dispatchEvent(t));
}
function AV(e, t = globalThis?.document) {
  const n = yr(e);
  _.useEffect(() => {
    const r = (o) => {
      o.key === "Escape" && n(o);
    };
    return t.addEventListener("keydown", r, { capture: !0 }), () => t.removeEventListener("keydown", r, { capture: !0 });
  }, [n, t]);
}
var RV = "DismissableLayer", rb = "dismissableLayer.update", jV = "dismissableLayer.pointerDownOutside", DV = "dismissableLayer.focusOutside", wE, J4 = _.createContext({
  layers: /* @__PURE__ */ new Set(),
  layersWithOutsidePointerEventsDisabled: /* @__PURE__ */ new Set(),
  branches: /* @__PURE__ */ new Set()
}), Sh = _.forwardRef(
  (e, t) => {
    const {
      disableOutsidePointerEvents: n = !1,
      onEscapeKeyDown: r,
      onPointerDownOutside: o,
      onFocusOutside: a,
      onInteractOutside: l,
      onDismiss: u,
      ...d
    } = e, f = _.useContext(J4), [p, m] = _.useState(null), g = p?.ownerDocument ?? globalThis?.document, [, y] = _.useState({}), w = kt(t, (T) => m(T)), v = Array.from(f.layers), [x] = [...f.layersWithOutsidePointerEventsDisabled].slice(-1), E = v.indexOf(x), N = p ? v.indexOf(p) : -1, C = f.layersWithOutsidePointerEventsDisabled.size > 0, A = N >= E, R = PV((T) => {
      const V = T.target, F = [...f.branches].some((O) => O.contains(V));
      !A || F || (o?.(T), l?.(T), T.defaultPrevented || u == null || u());
    }, g), D = LV((T) => {
      const V = T.target;
      [...f.branches].some((F) => F.contains(V)) || (a?.(T), l?.(T), T.defaultPrevented || u == null || u());
    }, g);
    return AV((T) => {
      N === f.layers.size - 1 && (r?.(T), !T.defaultPrevented && u && (T.preventDefault(), u()));
    }, g), _.useEffect(() => {
      if (p)
        return n && (f.layersWithOutsidePointerEventsDisabled.size === 0 && (wE = g.body.style.pointerEvents, g.body.style.pointerEvents = "none"), f.layersWithOutsidePointerEventsDisabled.add(p)), f.layers.add(p), xE(), () => {
          n && f.layersWithOutsidePointerEventsDisabled.size === 1 && (g.body.style.pointerEvents = wE);
        };
    }, [p, g, n, f]), _.useEffect(() => () => {
      p && (f.layers.delete(p), f.layersWithOutsidePointerEventsDisabled.delete(p), xE());
    }, [p, f]), _.useEffect(() => {
      const T = () => y({});
      return document.addEventListener(rb, T), () => document.removeEventListener(rb, T);
    }, []), /* @__PURE__ */ k.jsx(
      vt.div,
      {
        ...d,
        ref: w,
        style: {
          pointerEvents: C ? A ? "auto" : "none" : void 0,
          ...e.style
        },
        onFocusCapture: Te(e.onFocusCapture, D.onFocusCapture),
        onBlurCapture: Te(e.onBlurCapture, D.onBlurCapture),
        onPointerDownCapture: Te(
          e.onPointerDownCapture,
          R.onPointerDownCapture
        )
      }
    );
  }
);
Sh.displayName = RV;
var TV = "DismissableLayerBranch", zV = _.forwardRef((e, t) => {
  const n = _.useContext(J4), r = _.useRef(null), o = kt(t, r);
  return _.useEffect(() => {
    const a = r.current;
    if (a)
      return n.branches.add(a), () => {
        n.branches.delete(a);
      };
  }, [n.branches]), /* @__PURE__ */ k.jsx(vt.div, { ...e, ref: o });
});
zV.displayName = TV;
function PV(e, t = globalThis?.document) {
  const n = yr(e), r = _.useRef(!1), o = _.useRef(() => {
  });
  return _.useEffect(() => {
    const a = (u) => {
      if (u.target && !r.current) {
        let d = function() {
          eN(
            jV,
            n,
            f,
            { discrete: !0 }
          );
        };
        const f = { originalEvent: u };
        u.pointerType === "touch" ? (t.removeEventListener("click", o.current), o.current = d, t.addEventListener("click", o.current, { once: !0 })) : d();
      } else
        t.removeEventListener("click", o.current);
      r.current = !1;
    }, l = window.setTimeout(() => {
      t.addEventListener("pointerdown", a);
    }, 0);
    return () => {
      window.clearTimeout(l), t.removeEventListener("pointerdown", a), t.removeEventListener("click", o.current);
    };
  }, [t, n]), {
    // ensures we check React component tree (not just DOM tree)
    onPointerDownCapture: () => r.current = !0
  };
}
function LV(e, t = globalThis?.document) {
  const n = yr(e), r = _.useRef(!1);
  return _.useEffect(() => {
    const o = (a) => {
      a.target && !r.current && eN(DV, n, { originalEvent: a }, {
        discrete: !1
      });
    };
    return t.addEventListener("focusin", o), () => t.removeEventListener("focusin", o);
  }, [t, n]), {
    onFocusCapture: () => r.current = !0,
    onBlurCapture: () => r.current = !1
  };
}
function xE() {
  const e = new CustomEvent(rb);
  document.dispatchEvent(e);
}
function eN(e, t, n, { discrete: r }) {
  const o = n.originalEvent.target, a = new CustomEvent(e, { bubbles: !1, cancelable: !0, detail: n });
  t && o.addEventListener(e, t, { once: !0 }), r ? Q4(o, a) : o.dispatchEvent(a);
}
var Hy = "focusScope.autoFocusOnMount", Uy = "focusScope.autoFocusOnUnmount", SE = { bubbles: !1, cancelable: !0 }, IV = "FocusScope", kh = _.forwardRef((e, t) => {
  const {
    loop: n = !1,
    trapped: r = !1,
    onMountAutoFocus: o,
    onUnmountAutoFocus: a,
    ...l
  } = e, [u, d] = _.useState(null), f = yr(o), p = yr(a), m = _.useRef(null), g = kt(t, (v) => d(v)), y = _.useRef({
    paused: !1,
    pause() {
      this.paused = !0;
    },
    resume() {
      this.paused = !1;
    }
  }).current;
  _.useEffect(() => {
    if (r) {
      let v = function(C) {
        if (y.paused || !u) return;
        const A = C.target;
        u.contains(A) ? m.current = A : Di(m.current, { select: !0 });
      }, x = function(C) {
        if (y.paused || !u) return;
        const A = C.relatedTarget;
        A !== null && (u.contains(A) || Di(m.current, { select: !0 }));
      }, E = function(C) {
        if (document.activeElement === document.body)
          for (const A of C)
            A.removedNodes.length > 0 && Di(u);
      };
      document.addEventListener("focusin", v), document.addEventListener("focusout", x);
      const N = new MutationObserver(E);
      return u && N.observe(u, { childList: !0, subtree: !0 }), () => {
        document.removeEventListener("focusin", v), document.removeEventListener("focusout", x), N.disconnect();
      };
    }
  }, [r, u, y.paused]), _.useEffect(() => {
    if (u) {
      _E.add(y);
      const v = document.activeElement;
      if (!u.contains(v)) {
        const x = new CustomEvent(Hy, SE);
        u.addEventListener(Hy, f), u.dispatchEvent(x), x.defaultPrevented || (BV($V(tN(u)), { select: !0 }), document.activeElement === v && Di(u));
      }
      return () => {
        u.removeEventListener(Hy, f), setTimeout(() => {
          const x = new CustomEvent(Uy, SE);
          u.addEventListener(Uy, p), u.dispatchEvent(x), x.defaultPrevented || Di(v ?? document.body, { select: !0 }), u.removeEventListener(Uy, p), _E.remove(y);
        }, 0);
      };
    }
  }, [u, f, p, y]);
  const w = _.useCallback(
    (v) => {
      if (!n && !r || y.paused) return;
      const x = v.key === "Tab" && !v.altKey && !v.ctrlKey && !v.metaKey, E = document.activeElement;
      if (x && E) {
        const N = v.currentTarget, [C, A] = VV(N);
        C && A ? !v.shiftKey && E === A ? (v.preventDefault(), n && Di(C, { select: !0 })) : v.shiftKey && E === C && (v.preventDefault(), n && Di(A, { select: !0 })) : E === N && v.preventDefault();
      }
    },
    [n, r, y.paused]
  );
  return /* @__PURE__ */ k.jsx(vt.div, { tabIndex: -1, ...l, ref: g, onKeyDown: w });
});
kh.displayName = IV;
function BV(e, { select: t = !1 } = {}) {
  const n = document.activeElement;
  for (const r of e)
    if (Di(r, { select: t }), document.activeElement !== n) return;
}
function VV(e) {
  const t = tN(e), n = kE(t, e), r = kE(t.reverse(), e);
  return [n, r];
}
function tN(e) {
  const t = [], n = document.createTreeWalker(e, NodeFilter.SHOW_ELEMENT, {
    acceptNode: (r) => {
      const o = r.tagName === "INPUT" && r.type === "hidden";
      return r.disabled || r.hidden || o ? NodeFilter.FILTER_SKIP : r.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
    }
  });
  for (; n.nextNode(); ) t.push(n.currentNode);
  return t;
}
function kE(e, t) {
  for (const n of e)
    if (!HV(n, { upTo: t })) return n;
}
function HV(e, { upTo: t }) {
  if (getComputedStyle(e).visibility === "hidden") return !0;
  for (; e; ) {
    if (t !== void 0 && e === t) return !1;
    if (getComputedStyle(e).display === "none") return !0;
    e = e.parentElement;
  }
  return !1;
}
function UV(e) {
  return e instanceof HTMLInputElement && "select" in e;
}
function Di(e, { select: t = !1 } = {}) {
  if (e && e.focus) {
    const n = document.activeElement;
    e.focus({ preventScroll: !0 }), e !== n && UV(e) && t && e.select();
  }
}
var _E = FV();
function FV() {
  let e = [];
  return {
    add(t) {
      const n = e[0];
      t !== n && n?.pause(), e = EE(e, t), e.unshift(t);
    },
    remove(t) {
      var n;
      e = EE(e, t), (n = e[0]) == null || n.resume();
    }
  };
}
function EE(e, t) {
  const n = [...e], r = n.indexOf(t);
  return r !== -1 && n.splice(r, 1), n;
}
function $V(e) {
  return e.filter((t) => t.tagName !== "A");
}
var YV = "Portal", Ew = _.forwardRef((e, t) => {
  var n;
  const { container: r, ...o } = e, [a, l] = _.useState(!1);
  ja(() => l(!0), []);
  const u = r || a && ((n = globalThis?.document) == null ? void 0 : n.body);
  return u ? J6.createPortal(/* @__PURE__ */ k.jsx(vt.div, { ...o, ref: t }), u) : null;
});
Ew.displayName = YV;
function qV(e, t) {
  return _.useReducer((n, r) => t[n][r] ?? n, e);
}
var Wo = (e) => {
  const { present: t, children: n } = e, r = XV(t), o = typeof n == "function" ? n({ present: r.isPresent }) : _.Children.only(n), a = kt(r.ref, GV(o));
  return typeof n == "function" || r.isPresent ? _.cloneElement(o, { ref: a }) : null;
};
Wo.displayName = "Presence";
function XV(e) {
  const [t, n] = _.useState(), r = _.useRef({}), o = _.useRef(e), a = _.useRef("none"), l = e ? "mounted" : "unmounted", [u, d] = qV(l, {
    mounted: {
      UNMOUNT: "unmounted",
      ANIMATION_OUT: "unmountSuspended"
    },
    unmountSuspended: {
      MOUNT: "mounted",
      ANIMATION_END: "unmounted"
    },
    unmounted: {
      MOUNT: "mounted"
    }
  });
  return _.useEffect(() => {
    const f = Nf(r.current);
    a.current = u === "mounted" ? f : "none";
  }, [u]), ja(() => {
    const f = r.current, p = o.current;
    if (p !== e) {
      const m = a.current, g = Nf(f);
      e ? d("MOUNT") : g === "none" || f?.display === "none" ? d("UNMOUNT") : d(p && m !== g ? "ANIMATION_OUT" : "UNMOUNT"), o.current = e;
    }
  }, [e, d]), ja(() => {
    if (t) {
      let f;
      const p = t.ownerDocument.defaultView ?? window, m = (y) => {
        const w = Nf(r.current).includes(y.animationName);
        if (y.target === t && w && (d("ANIMATION_END"), !o.current)) {
          const v = t.style.animationFillMode;
          t.style.animationFillMode = "forwards", f = p.setTimeout(() => {
            t.style.animationFillMode === "forwards" && (t.style.animationFillMode = v);
          });
        }
      }, g = (y) => {
        y.target === t && (a.current = Nf(r.current));
      };
      return t.addEventListener("animationstart", g), t.addEventListener("animationcancel", m), t.addEventListener("animationend", m), () => {
        p.clearTimeout(f), t.removeEventListener("animationstart", g), t.removeEventListener("animationcancel", m), t.removeEventListener("animationend", m);
      };
    } else
      d("ANIMATION_END");
  }, [t, d]), {
    isPresent: ["mounted", "unmountSuspended"].includes(u),
    ref: _.useCallback((f) => {
      f && (r.current = getComputedStyle(f)), n(f);
    }, [])
  };
}
function Nf(e) {
  return e?.animationName || "none";
}
function GV(e) {
  var t, n;
  let r = (t = Object.getOwnPropertyDescriptor(e.props, "ref")) == null ? void 0 : t.get, o = r && "isReactWarning" in r && r.isReactWarning;
  return o ? e.ref : (r = (n = Object.getOwnPropertyDescriptor(e, "ref")) == null ? void 0 : n.get, o = r && "isReactWarning" in r && r.isReactWarning, o ? e.props.ref : e.props.ref || e.ref);
}
var Fy = 0;
function Cw() {
  _.useEffect(() => {
    const e = document.querySelectorAll("[data-radix-focus-guard]");
    return document.body.insertAdjacentElement("afterbegin", e[0] ?? CE()), document.body.insertAdjacentElement("beforeend", e[1] ?? CE()), Fy++, () => {
      Fy === 1 && document.querySelectorAll("[data-radix-focus-guard]").forEach((t) => t.remove()), Fy--;
    };
  }, []);
}
function CE() {
  const e = document.createElement("span");
  return e.setAttribute("data-radix-focus-guard", ""), e.tabIndex = 0, e.style.outline = "none", e.style.opacity = "0", e.style.position = "fixed", e.style.pointerEvents = "none", e;
}
var Jr = function() {
  return Jr = Object.assign || function(e) {
    for (var t, n = 1, r = arguments.length; n < r; n++) {
      t = arguments[n];
      for (var o in t) Object.prototype.hasOwnProperty.call(t, o) && (e[o] = t[o]);
    }
    return e;
  }, Jr.apply(this, arguments);
};
function nN(e, t) {
  var n = {};
  for (var r in e) Object.prototype.hasOwnProperty.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function")
    for (var o = 0, r = Object.getOwnPropertySymbols(e); o < r.length; o++)
      t.indexOf(r[o]) < 0 && Object.prototype.propertyIsEnumerable.call(e, r[o]) && (n[r[o]] = e[r[o]]);
  return n;
}
function rp(e, t, n) {
  if (n || arguments.length === 2) for (var r = 0, o = t.length, a; r < o; r++)
    (a || !(r in t)) && (a || (a = Array.prototype.slice.call(t, 0, r)), a[r] = t[r]);
  return e.concat(a || Array.prototype.slice.call(t));
}
var op = "right-scroll-bar-position", ip = "width-before-scroll-bar", ZV = "with-scroll-bars-hidden", WV = "--removed-body-scroll-bar-size";
function $y(e, t) {
  return typeof e == "function" ? e(t) : e && (e.current = t), e;
}
function KV(e, t) {
  var n = _.useState(function() {
    return {
      // value
      value: e,
      // last callback
      callback: t,
      // "memoized" public interface
      facade: {
        get current() {
          return n.value;
        },
        set current(r) {
          var o = n.value;
          o !== r && (n.value = r, n.callback(r, o));
        }
      }
    };
  })[0];
  return n.callback = t, n.facade;
}
var QV = typeof window < "u" ? _.useLayoutEffect : _.useEffect, OE = /* @__PURE__ */ new WeakMap();
function JV(e, t) {
  var n = KV(null, function(r) {
    return e.forEach(function(o) {
      return $y(o, r);
    });
  });
  return QV(function() {
    var r = OE.get(n);
    if (r) {
      var o = new Set(r), a = new Set(e), l = n.current;
      o.forEach(function(u) {
        a.has(u) || $y(u, null);
      }), a.forEach(function(u) {
        o.has(u) || $y(u, l);
      });
    }
    OE.set(n, e);
  }, [e]), n;
}
function eH(e) {
  return e;
}
function tH(e, t) {
  t === void 0 && (t = eH);
  var n = [], r = !1, o = {
    read: function() {
      if (r)
        throw new Error("Sidecar: could not `read` from an `assigned` medium. `read` could be used only with `useMedium`.");
      return n.length ? n[n.length - 1] : e;
    },
    useMedium: function(a) {
      var l = t(a, r);
      return n.push(l), function() {
        n = n.filter(function(u) {
          return u !== l;
        });
      };
    },
    assignSyncMedium: function(a) {
      for (r = !0; n.length; ) {
        var l = n;
        n = [], l.forEach(a);
      }
      n = {
        push: function(u) {
          return a(u);
        },
        filter: function() {
          return n;
        }
      };
    },
    assignMedium: function(a) {
      r = !0;
      var l = [];
      if (n.length) {
        var u = n;
        n = [], u.forEach(a), l = n;
      }
      var d = function() {
        var p = l;
        l = [], p.forEach(a);
      }, f = function() {
        return Promise.resolve().then(d);
      };
      f(), n = {
        push: function(p) {
          l.push(p), f();
        },
        filter: function(p) {
          return l = l.filter(p), n;
        }
      };
    }
  };
  return o;
}
function nH(e) {
  e === void 0 && (e = {});
  var t = tH(null);
  return t.options = Jr({ async: !0, ssr: !1 }, e), t;
}
var rN = function(e) {
  var t = e.sideCar, n = nN(e, ["sideCar"]);
  if (!t)
    throw new Error("Sidecar: please provide `sideCar` property to import the right car");
  var r = t.read();
  if (!r)
    throw new Error("Sidecar medium not found");
  return _.createElement(r, Jr({}, n));
};
rN.isSideCarExport = !0;
function rH(e, t) {
  return e.useMedium(t), rN;
}
var oN = nH(), Yy = function() {
}, _h = _.forwardRef(function(e, t) {
  var n = _.useRef(null), r = _.useState({
    onScrollCapture: Yy,
    onWheelCapture: Yy,
    onTouchMoveCapture: Yy
  }), o = r[0], a = r[1], l = e.forwardProps, u = e.children, d = e.className, f = e.removeScrollBar, p = e.enabled, m = e.shards, g = e.sideCar, y = e.noIsolation, w = e.inert, v = e.allowPinchZoom, x = e.as, E = x === void 0 ? "div" : x, N = e.gapMode, C = nN(e, ["forwardProps", "children", "className", "removeScrollBar", "enabled", "shards", "sideCar", "noIsolation", "inert", "allowPinchZoom", "as", "gapMode"]), A = g, R = JV([n, t]), D = Jr(Jr({}, C), o);
  return _.createElement(
    _.Fragment,
    null,
    p && _.createElement(A, { sideCar: oN, removeScrollBar: f, shards: m, noIsolation: y, inert: w, setCallbacks: a, allowPinchZoom: !!v, lockRef: n, gapMode: N }),
    l ? _.cloneElement(_.Children.only(u), Jr(Jr({}, D), { ref: R })) : _.createElement(E, Jr({}, D, { className: d, ref: R }), u)
  );
});
_h.defaultProps = {
  enabled: !0,
  removeScrollBar: !0,
  inert: !1
};
_h.classNames = {
  fullWidth: ip,
  zeroRight: op
};
var oH = function() {
  if (typeof __webpack_nonce__ < "u")
    return __webpack_nonce__;
};
function iH() {
  if (!document)
    return null;
  var e = document.createElement("style");
  e.type = "text/css";
  var t = oH();
  return t && e.setAttribute("nonce", t), e;
}
function aH(e, t) {
  e.styleSheet ? e.styleSheet.cssText = t : e.appendChild(document.createTextNode(t));
}
function lH(e) {
  var t = document.head || document.getElementsByTagName("head")[0];
  t.appendChild(e);
}
var sH = function() {
  var e = 0, t = null;
  return {
    add: function(n) {
      e == 0 && (t = iH()) && (aH(t, n), lH(t)), e++;
    },
    remove: function() {
      e--, !e && t && (t.parentNode && t.parentNode.removeChild(t), t = null);
    }
  };
}, uH = function() {
  var e = sH();
  return function(t, n) {
    _.useEffect(function() {
      return e.add(t), function() {
        e.remove();
      };
    }, [t && n]);
  };
}, iN = function() {
  var e = uH(), t = function(n) {
    var r = n.styles, o = n.dynamic;
    return e(r, o), null;
  };
  return t;
}, cH = {
  left: 0,
  top: 0,
  right: 0,
  gap: 0
}, qy = function(e) {
  return parseInt(e || "", 10) || 0;
}, dH = function(e) {
  var t = window.getComputedStyle(document.body), n = t[e === "padding" ? "paddingLeft" : "marginLeft"], r = t[e === "padding" ? "paddingTop" : "marginTop"], o = t[e === "padding" ? "paddingRight" : "marginRight"];
  return [qy(n), qy(r), qy(o)];
}, fH = function(e) {
  if (e === void 0 && (e = "margin"), typeof window > "u")
    return cH;
  var t = dH(e), n = document.documentElement.clientWidth, r = window.innerWidth;
  return {
    left: t[0],
    top: t[1],
    right: t[2],
    gap: Math.max(0, r - n + t[2] - t[0])
  };
}, pH = iN(), Gl = "data-scroll-locked", hH = function(e, t, n, r) {
  var o = e.left, a = e.top, l = e.right, u = e.gap;
  return n === void 0 && (n = "margin"), `
  .`.concat(ZV, ` {
   overflow: hidden `).concat(r, `;
   padding-right: `).concat(u, "px ").concat(r, `;
  }
  body[`).concat(Gl, `] {
    overflow: hidden `).concat(r, `;
    overscroll-behavior: contain;
    `).concat([
    t && "position: relative ".concat(r, ";"),
    n === "margin" && `
    padding-left: `.concat(o, `px;
    padding-top: `).concat(a, `px;
    padding-right: `).concat(l, `px;
    margin-left:0;
    margin-top:0;
    margin-right: `).concat(u, "px ").concat(r, `;
    `),
    n === "padding" && "padding-right: ".concat(u, "px ").concat(r, ";")
  ].filter(Boolean).join(""), `
  }

  .`).concat(op, ` {
    right: `).concat(u, "px ").concat(r, `;
  }

  .`).concat(ip, ` {
    margin-right: `).concat(u, "px ").concat(r, `;
  }

  .`).concat(op, " .").concat(op, ` {
    right: 0 `).concat(r, `;
  }

  .`).concat(ip, " .").concat(ip, ` {
    margin-right: 0 `).concat(r, `;
  }

  body[`).concat(Gl, `] {
    `).concat(WV, ": ").concat(u, `px;
  }
`);
}, NE = function() {
  var e = parseInt(document.body.getAttribute(Gl) || "0", 10);
  return isFinite(e) ? e : 0;
}, mH = function() {
  _.useEffect(function() {
    return document.body.setAttribute(Gl, (NE() + 1).toString()), function() {
      var e = NE() - 1;
      e <= 0 ? document.body.removeAttribute(Gl) : document.body.setAttribute(Gl, e.toString());
    };
  }, []);
}, gH = function(e) {
  var t = e.noRelative, n = e.noImportant, r = e.gapMode, o = r === void 0 ? "margin" : r;
  mH();
  var a = _.useMemo(function() {
    return fH(o);
  }, [o]);
  return _.createElement(pH, { styles: hH(a, !t, o, n ? "" : "!important") });
}, ob = !1;
if (typeof window < "u")
  try {
    var Mf = Object.defineProperty({}, "passive", {
      get: function() {
        return ob = !0, !0;
      }
    });
    window.addEventListener("test", Mf, Mf), window.removeEventListener("test", Mf, Mf);
  } catch {
    ob = !1;
  }
var Ml = ob ? { passive: !1 } : !1, yH = function(e) {
  return e.tagName === "TEXTAREA";
}, aN = function(e, t) {
  if (!(e instanceof Element))
    return !1;
  var n = window.getComputedStyle(e);
  return (
    // not-not-scrollable
    n[t] !== "hidden" && // contains scroll inside self
    !(n.overflowY === n.overflowX && !yH(e) && n[t] === "visible")
  );
}, vH = function(e) {
  return aN(e, "overflowY");
}, bH = function(e) {
  return aN(e, "overflowX");
}, ME = function(e, t) {
  var n = t.ownerDocument, r = t;
  do {
    typeof ShadowRoot < "u" && r instanceof ShadowRoot && (r = r.host);
    var o = lN(e, r);
    if (o) {
      var a = sN(e, r), l = a[1], u = a[2];
      if (l > u)
        return !0;
    }
    r = r.parentNode;
  } while (r && r !== n.body);
  return !1;
}, wH = function(e) {
  var t = e.scrollTop, n = e.scrollHeight, r = e.clientHeight;
  return [
    t,
    n,
    r
  ];
}, xH = function(e) {
  var t = e.scrollLeft, n = e.scrollWidth, r = e.clientWidth;
  return [
    t,
    n,
    r
  ];
}, lN = function(e, t) {
  return e === "v" ? vH(t) : bH(t);
}, sN = function(e, t) {
  return e === "v" ? wH(t) : xH(t);
}, SH = function(e, t) {
  return e === "h" && t === "rtl" ? -1 : 1;
}, kH = function(e, t, n, r, o) {
  var a = SH(e, window.getComputedStyle(t).direction), l = a * r, u = n.target, d = t.contains(u), f = !1, p = l > 0, m = 0, g = 0;
  do {
    var y = sN(e, u), w = y[0], v = y[1], x = y[2], E = v - x - a * w;
    (w || E) && lN(e, u) && (m += E, g += w), u instanceof ShadowRoot ? u = u.host : u = u.parentNode;
  } while (
    // portaled content
    !d && u !== document.body || // self content
    d && (t.contains(u) || t === u)
  );
  return (p && Math.abs(m) < 1 || !p && Math.abs(g) < 1) && (f = !0), f;
}, Af = function(e) {
  return "changedTouches" in e ? [e.changedTouches[0].clientX, e.changedTouches[0].clientY] : [0, 0];
}, AE = function(e) {
  return [e.deltaX, e.deltaY];
}, RE = function(e) {
  return e && "current" in e ? e.current : e;
}, _H = function(e, t) {
  return e[0] === t[0] && e[1] === t[1];
}, EH = function(e) {
  return `
  .block-interactivity-`.concat(e, ` {pointer-events: none;}
  .allow-interactivity-`).concat(e, ` {pointer-events: all;}
`);
}, CH = 0, Al = [];
function OH(e) {
  var t = _.useRef([]), n = _.useRef([0, 0]), r = _.useRef(), o = _.useState(CH++)[0], a = _.useState(iN)[0], l = _.useRef(e);
  _.useEffect(function() {
    l.current = e;
  }, [e]), _.useEffect(function() {
    if (e.inert) {
      document.body.classList.add("block-interactivity-".concat(o));
      var v = rp([e.lockRef.current], (e.shards || []).map(RE), !0).filter(Boolean);
      return v.forEach(function(x) {
        return x.classList.add("allow-interactivity-".concat(o));
      }), function() {
        document.body.classList.remove("block-interactivity-".concat(o)), v.forEach(function(x) {
          return x.classList.remove("allow-interactivity-".concat(o));
        });
      };
    }
  }, [e.inert, e.lockRef.current, e.shards]);
  var u = _.useCallback(function(v, x) {
    if ("touches" in v && v.touches.length === 2 || v.type === "wheel" && v.ctrlKey)
      return !l.current.allowPinchZoom;
    var E = Af(v), N = n.current, C = "deltaX" in v ? v.deltaX : N[0] - E[0], A = "deltaY" in v ? v.deltaY : N[1] - E[1], R, D = v.target, T = Math.abs(C) > Math.abs(A) ? "h" : "v";
    if ("touches" in v && T === "h" && D.type === "range")
      return !1;
    var V = ME(T, D);
    if (!V)
      return !0;
    if (V ? R = T : (R = T === "v" ? "h" : "v", V = ME(T, D)), !V)
      return !1;
    if (!r.current && "changedTouches" in v && (C || A) && (r.current = R), !R)
      return !0;
    var F = r.current || R;
    return kH(F, x, v, F === "h" ? C : A);
  }, []), d = _.useCallback(function(v) {
    var x = v;
    if (!(!Al.length || Al[Al.length - 1] !== a)) {
      var E = "deltaY" in x ? AE(x) : Af(x), N = t.current.filter(function(R) {
        return R.name === x.type && (R.target === x.target || x.target === R.shadowParent) && _H(R.delta, E);
      })[0];
      if (N && N.should) {
        x.cancelable && x.preventDefault();
        return;
      }
      if (!N) {
        var C = (l.current.shards || []).map(RE).filter(Boolean).filter(function(R) {
          return R.contains(x.target);
        }), A = C.length > 0 ? u(x, C[0]) : !l.current.noIsolation;
        A && x.cancelable && x.preventDefault();
      }
    }
  }, []), f = _.useCallback(function(v, x, E, N) {
    var C = { name: v, delta: x, target: E, should: N, shadowParent: NH(E) };
    t.current.push(C), setTimeout(function() {
      t.current = t.current.filter(function(A) {
        return A !== C;
      });
    }, 1);
  }, []), p = _.useCallback(function(v) {
    n.current = Af(v), r.current = void 0;
  }, []), m = _.useCallback(function(v) {
    f(v.type, AE(v), v.target, u(v, e.lockRef.current));
  }, []), g = _.useCallback(function(v) {
    f(v.type, Af(v), v.target, u(v, e.lockRef.current));
  }, []);
  _.useEffect(function() {
    return Al.push(a), e.setCallbacks({
      onScrollCapture: m,
      onWheelCapture: m,
      onTouchMoveCapture: g
    }), document.addEventListener("wheel", d, Ml), document.addEventListener("touchmove", d, Ml), document.addEventListener("touchstart", p, Ml), function() {
      Al = Al.filter(function(v) {
        return v !== a;
      }), document.removeEventListener("wheel", d, Ml), document.removeEventListener("touchmove", d, Ml), document.removeEventListener("touchstart", p, Ml);
    };
  }, []);
  var y = e.removeScrollBar, w = e.inert;
  return _.createElement(
    _.Fragment,
    null,
    w ? _.createElement(a, { styles: EH(o) }) : null,
    y ? _.createElement(gH, { gapMode: e.gapMode }) : null
  );
}
function NH(e) {
  for (var t = null; e !== null; )
    e instanceof ShadowRoot && (t = e.host, e = e.host), e = e.parentNode;
  return t;
}
const MH = rH(oN, OH);
var Eh = _.forwardRef(function(e, t) {
  return _.createElement(_h, Jr({}, e, { ref: t, sideCar: MH }));
});
Eh.classNames = _h.classNames;
var AH = function(e) {
  if (typeof document > "u")
    return null;
  var t = Array.isArray(e) ? e[0] : e;
  return t.ownerDocument.body;
}, Rl = /* @__PURE__ */ new WeakMap(), Rf = /* @__PURE__ */ new WeakMap(), jf = {}, Xy = 0, uN = function(e) {
  return e && (e.host || uN(e.parentNode));
}, RH = function(e, t) {
  return t.map(function(n) {
    if (e.contains(n))
      return n;
    var r = uN(n);
    return r && e.contains(r) ? r : (console.error("aria-hidden", n, "in not contained inside", e, ". Doing nothing"), null);
  }).filter(function(n) {
    return !!n;
  });
}, jH = function(e, t, n, r) {
  var o = RH(t, Array.isArray(e) ? e : [e]);
  jf[n] || (jf[n] = /* @__PURE__ */ new WeakMap());
  var a = jf[n], l = [], u = /* @__PURE__ */ new Set(), d = new Set(o), f = function(m) {
    !m || u.has(m) || (u.add(m), f(m.parentNode));
  };
  o.forEach(f);
  var p = function(m) {
    !m || d.has(m) || Array.prototype.forEach.call(m.children, function(g) {
      if (u.has(g))
        p(g);
      else
        try {
          var y = g.getAttribute(r), w = y !== null && y !== "false", v = (Rl.get(g) || 0) + 1, x = (a.get(g) || 0) + 1;
          Rl.set(g, v), a.set(g, x), l.push(g), v === 1 && w && Rf.set(g, !0), x === 1 && g.setAttribute(n, "true"), w || g.setAttribute(r, "true");
        } catch (E) {
          console.error("aria-hidden: cannot operate on ", g, E);
        }
    });
  };
  return p(t), u.clear(), Xy++, function() {
    l.forEach(function(m) {
      var g = Rl.get(m) - 1, y = a.get(m) - 1;
      Rl.set(m, g), a.set(m, y), g || (Rf.has(m) || m.removeAttribute(r), Rf.delete(m)), y || m.removeAttribute(n);
    }), Xy--, Xy || (Rl = /* @__PURE__ */ new WeakMap(), Rl = /* @__PURE__ */ new WeakMap(), Rf = /* @__PURE__ */ new WeakMap(), jf = {});
  };
}, Ow = function(e, t, n) {
  n === void 0 && (n = "data-aria-hidden");
  var r = Array.from(Array.isArray(e) ? e : [e]), o = AH(e);
  return o ? (r.push.apply(r, Array.from(o.querySelectorAll("[aria-live]"))), jH(r, o, n, "aria-hidden")) : function() {
    return null;
  };
}, Nw = "Dialog", [cN, Kue] = Gi(Nw), [DH, Pr] = cN(Nw), dN = (e) => {
  const {
    __scopeDialog: t,
    children: n,
    open: r,
    defaultOpen: o,
    onOpenChange: a,
    modal: l = !0
  } = e, u = _.useRef(null), d = _.useRef(null), [f = !1, p] = ys({
    prop: r,
    defaultProp: o,
    onChange: a
  });
  return /* @__PURE__ */ k.jsx(
    DH,
    {
      scope: t,
      triggerRef: u,
      contentRef: d,
      contentId: Vo(),
      titleId: Vo(),
      descriptionId: Vo(),
      open: f,
      onOpenChange: p,
      onOpenToggle: _.useCallback(() => p((m) => !m), [p]),
      modal: l,
      children: n
    }
  );
};
dN.displayName = Nw;
var fN = "DialogTrigger", pN = _.forwardRef(
  (e, t) => {
    const { __scopeDialog: n, ...r } = e, o = Pr(fN, n), a = kt(t, o.triggerRef);
    return /* @__PURE__ */ k.jsx(
      vt.button,
      {
        type: "button",
        "aria-haspopup": "dialog",
        "aria-expanded": o.open,
        "aria-controls": o.contentId,
        "data-state": Rw(o.open),
        ...r,
        ref: a,
        onClick: Te(e.onClick, o.onOpenToggle)
      }
    );
  }
);
pN.displayName = fN;
var Mw = "DialogPortal", [TH, hN] = cN(Mw, {
  forceMount: void 0
}), mN = (e) => {
  const { __scopeDialog: t, forceMount: n, children: r, container: o } = e, a = Pr(Mw, t);
  return /* @__PURE__ */ k.jsx(TH, { scope: t, forceMount: n, children: _.Children.map(r, (l) => /* @__PURE__ */ k.jsx(Wo, { present: n || a.open, children: /* @__PURE__ */ k.jsx(Ew, { asChild: !0, container: o, children: l }) })) });
};
mN.displayName = Mw;
var Mp = "DialogOverlay", gN = _.forwardRef(
  (e, t) => {
    const n = hN(Mp, e.__scopeDialog), { forceMount: r = n.forceMount, ...o } = e, a = Pr(Mp, e.__scopeDialog);
    return a.modal ? /* @__PURE__ */ k.jsx(Wo, { present: r || a.open, children: /* @__PURE__ */ k.jsx(PH, { ...o, ref: t }) }) : null;
  }
);
gN.displayName = Mp;
var zH = /* @__PURE__ */ ss("DialogOverlay.RemoveScroll"), PH = _.forwardRef(
  (e, t) => {
    const { __scopeDialog: n, ...r } = e, o = Pr(Mp, n);
    return (
      // Make sure `Content` is scrollable even when it doesn't live inside `RemoveScroll`
      // ie. when `Overlay` and `Content` are siblings
      /* @__PURE__ */ k.jsx(Eh, { as: zH, allowPinchZoom: !0, shards: [o.contentRef], children: /* @__PURE__ */ k.jsx(
        vt.div,
        {
          "data-state": Rw(o.open),
          ...r,
          ref: t,
          style: { pointerEvents: "auto", ...r.style }
        }
      ) })
    );
  }
), Da = "DialogContent", yN = _.forwardRef(
  (e, t) => {
    const n = hN(Da, e.__scopeDialog), { forceMount: r = n.forceMount, ...o } = e, a = Pr(Da, e.__scopeDialog);
    return /* @__PURE__ */ k.jsx(Wo, { present: r || a.open, children: a.modal ? /* @__PURE__ */ k.jsx(LH, { ...o, ref: t }) : /* @__PURE__ */ k.jsx(IH, { ...o, ref: t }) });
  }
);
yN.displayName = Da;
var LH = _.forwardRef(
  (e, t) => {
    const n = Pr(Da, e.__scopeDialog), r = _.useRef(null), o = kt(t, n.contentRef, r);
    return _.useEffect(() => {
      const a = r.current;
      if (a) return Ow(a);
    }, []), /* @__PURE__ */ k.jsx(
      vN,
      {
        ...e,
        ref: o,
        trapFocus: n.open,
        disableOutsidePointerEvents: !0,
        onCloseAutoFocus: Te(e.onCloseAutoFocus, (a) => {
          var l;
          a.preventDefault(), (l = n.triggerRef.current) == null || l.focus();
        }),
        onPointerDownOutside: Te(e.onPointerDownOutside, (a) => {
          const l = a.detail.originalEvent, u = l.button === 0 && l.ctrlKey === !0;
          (l.button === 2 || u) && a.preventDefault();
        }),
        onFocusOutside: Te(
          e.onFocusOutside,
          (a) => a.preventDefault()
        )
      }
    );
  }
), IH = _.forwardRef(
  (e, t) => {
    const n = Pr(Da, e.__scopeDialog), r = _.useRef(!1), o = _.useRef(!1);
    return /* @__PURE__ */ k.jsx(
      vN,
      {
        ...e,
        ref: t,
        trapFocus: !1,
        disableOutsidePointerEvents: !1,
        onCloseAutoFocus: (a) => {
          var l, u;
          (l = e.onCloseAutoFocus) == null || l.call(e, a), a.defaultPrevented || (r.current || (u = n.triggerRef.current) == null || u.focus(), a.preventDefault()), r.current = !1, o.current = !1;
        },
        onInteractOutside: (a) => {
          var l, u;
          (l = e.onInteractOutside) == null || l.call(e, a), a.defaultPrevented || (r.current = !0, a.detail.originalEvent.type === "pointerdown" && (o.current = !0));
          const d = a.target;
          (u = n.triggerRef.current) != null && u.contains(d) && a.preventDefault(), a.detail.originalEvent.type === "focusin" && o.current && a.preventDefault();
        }
      }
    );
  }
), vN = _.forwardRef(
  (e, t) => {
    const { __scopeDialog: n, trapFocus: r, onOpenAutoFocus: o, onCloseAutoFocus: a, ...l } = e, u = Pr(Da, n), d = _.useRef(null), f = kt(t, d);
    return Cw(), /* @__PURE__ */ k.jsxs(k.Fragment, { children: [
      /* @__PURE__ */ k.jsx(
        kh,
        {
          asChild: !0,
          loop: !0,
          trapped: r,
          onMountAutoFocus: o,
          onUnmountAutoFocus: a,
          children: /* @__PURE__ */ k.jsx(
            Sh,
            {
              role: "dialog",
              id: u.contentId,
              "aria-describedby": u.descriptionId,
              "aria-labelledby": u.titleId,
              "data-state": Rw(u.open),
              ...l,
              ref: f,
              onDismiss: () => u.onOpenChange(!1)
            }
          )
        }
      ),
      /* @__PURE__ */ k.jsxs(k.Fragment, { children: [
        /* @__PURE__ */ k.jsx(BH, { titleId: u.titleId }),
        /* @__PURE__ */ k.jsx(HH, { contentRef: d, descriptionId: u.descriptionId })
      ] })
    ] });
  }
), Aw = "DialogTitle", bN = _.forwardRef(
  (e, t) => {
    const { __scopeDialog: n, ...r } = e, o = Pr(Aw, n);
    return /* @__PURE__ */ k.jsx(vt.h2, { id: o.titleId, ...r, ref: t });
  }
);
bN.displayName = Aw;
var wN = "DialogDescription", xN = _.forwardRef(
  (e, t) => {
    const { __scopeDialog: n, ...r } = e, o = Pr(wN, n);
    return /* @__PURE__ */ k.jsx(vt.p, { id: o.descriptionId, ...r, ref: t });
  }
);
xN.displayName = wN;
var SN = "DialogClose", kN = _.forwardRef(
  (e, t) => {
    const { __scopeDialog: n, ...r } = e, o = Pr(SN, n);
    return /* @__PURE__ */ k.jsx(
      vt.button,
      {
        type: "button",
        ...r,
        ref: t,
        onClick: Te(e.onClick, () => o.onOpenChange(!1))
      }
    );
  }
);
kN.displayName = SN;
function Rw(e) {
  return e ? "open" : "closed";
}
var _N = "DialogTitleWarning", [Que, EN] = bV(_N, {
  contentName: Da,
  titleName: Aw,
  docsSlug: "dialog"
}), BH = ({ titleId: e }) => {
  const t = EN(_N), n = `\`${t.contentName}\` requires a \`${t.titleName}\` for the component to be accessible for screen reader users.

If you want to hide the \`${t.titleName}\`, you can wrap it with our VisuallyHidden component.

For more information, see https://radix-ui.com/primitives/docs/components/${t.docsSlug}`;
  return _.useEffect(() => {
    e && (document.getElementById(e) || console.error(n));
  }, [n, e]), null;
}, VH = "DialogDescriptionWarning", HH = ({ contentRef: e, descriptionId: t }) => {
  const n = `Warning: Missing \`Description\` or \`aria-describedby={undefined}\` for {${EN(VH).contentName}}.`;
  return _.useEffect(() => {
    var r;
    const o = (r = e.current) == null ? void 0 : r.getAttribute("aria-describedby");
    t && o && (document.getElementById(t) || console.warn(n));
  }, [n, e, t]), null;
}, UH = dN, FH = pN, $H = mN, YH = gN, qH = yN, XH = bN, GH = xN, jE = kN;
/*!
 * Font Awesome Free 6.7.2 by @fontawesome - https://fontawesome.com
 * License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License)
 * Copyright 2024 Fonticons, Inc.
 */
function ZH(e, t, n) {
  return (t = KH(t)) in e ? Object.defineProperty(e, t, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = n, e;
}
function DE(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function me(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? DE(Object(n), !0).forEach(function(r) {
      ZH(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : DE(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function WH(e, t) {
  if (typeof e != "object" || !e) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t);
    if (typeof r != "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function KH(e) {
  var t = WH(e, "string");
  return typeof t == "symbol" ? t : t + "";
}
const TE = () => {
};
let jw = {}, CN = {}, ON = null, NN = {
  mark: TE,
  measure: TE
};
try {
  typeof window < "u" && (jw = window), typeof document < "u" && (CN = document), typeof MutationObserver < "u" && (ON = MutationObserver), typeof performance < "u" && (NN = performance);
} catch {
}
const {
  userAgent: zE = ""
} = jw.navigator || {}, Hi = jw, bt = CN, PE = ON, Df = NN;
Hi.document;
const Ko = !!bt.documentElement && !!bt.head && typeof bt.addEventListener == "function" && typeof bt.createElement == "function", MN = ~zE.indexOf("MSIE") || ~zE.indexOf("Trident/");
var QH = /fa(s|r|l|t|d|dr|dl|dt|b|k|kd|ss|sr|sl|st|sds|sdr|sdl|sdt)?[\-\ ]/, JH = /Font ?Awesome ?([56 ]*)(Solid|Regular|Light|Thin|Duotone|Brands|Free|Pro|Sharp Duotone|Sharp|Kit)?.*/i, AN = {
  classic: {
    fa: "solid",
    fas: "solid",
    "fa-solid": "solid",
    far: "regular",
    "fa-regular": "regular",
    fal: "light",
    "fa-light": "light",
    fat: "thin",
    "fa-thin": "thin",
    fab: "brands",
    "fa-brands": "brands"
  },
  duotone: {
    fa: "solid",
    fad: "solid",
    "fa-solid": "solid",
    "fa-duotone": "solid",
    fadr: "regular",
    "fa-regular": "regular",
    fadl: "light",
    "fa-light": "light",
    fadt: "thin",
    "fa-thin": "thin"
  },
  sharp: {
    fa: "solid",
    fass: "solid",
    "fa-solid": "solid",
    fasr: "regular",
    "fa-regular": "regular",
    fasl: "light",
    "fa-light": "light",
    fast: "thin",
    "fa-thin": "thin"
  },
  "sharp-duotone": {
    fa: "solid",
    fasds: "solid",
    "fa-solid": "solid",
    fasdr: "regular",
    "fa-regular": "regular",
    fasdl: "light",
    "fa-light": "light",
    fasdt: "thin",
    "fa-thin": "thin"
  }
}, eU = {
  GROUP: "duotone-group",
  PRIMARY: "primary",
  SECONDARY: "secondary"
}, RN = ["fa-classic", "fa-duotone", "fa-sharp", "fa-sharp-duotone"], gn = "classic", Ch = "duotone", tU = "sharp", nU = "sharp-duotone", jN = [gn, Ch, tU, nU], rU = {
  classic: {
    900: "fas",
    400: "far",
    normal: "far",
    300: "fal",
    100: "fat"
  },
  duotone: {
    900: "fad",
    400: "fadr",
    300: "fadl",
    100: "fadt"
  },
  sharp: {
    900: "fass",
    400: "fasr",
    300: "fasl",
    100: "fast"
  },
  "sharp-duotone": {
    900: "fasds",
    400: "fasdr",
    300: "fasdl",
    100: "fasdt"
  }
}, oU = {
  "Font Awesome 6 Free": {
    900: "fas",
    400: "far"
  },
  "Font Awesome 6 Pro": {
    900: "fas",
    400: "far",
    normal: "far",
    300: "fal",
    100: "fat"
  },
  "Font Awesome 6 Brands": {
    400: "fab",
    normal: "fab"
  },
  "Font Awesome 6 Duotone": {
    900: "fad",
    400: "fadr",
    normal: "fadr",
    300: "fadl",
    100: "fadt"
  },
  "Font Awesome 6 Sharp": {
    900: "fass",
    400: "fasr",
    normal: "fasr",
    300: "fasl",
    100: "fast"
  },
  "Font Awesome 6 Sharp Duotone": {
    900: "fasds",
    400: "fasdr",
    normal: "fasdr",
    300: "fasdl",
    100: "fasdt"
  }
}, iU = /* @__PURE__ */ new Map([["classic", {
  defaultShortPrefixId: "fas",
  defaultStyleId: "solid",
  styleIds: ["solid", "regular", "light", "thin", "brands"],
  futureStyleIds: [],
  defaultFontWeight: 900
}], ["sharp", {
  defaultShortPrefixId: "fass",
  defaultStyleId: "solid",
  styleIds: ["solid", "regular", "light", "thin"],
  futureStyleIds: [],
  defaultFontWeight: 900
}], ["duotone", {
  defaultShortPrefixId: "fad",
  defaultStyleId: "solid",
  styleIds: ["solid", "regular", "light", "thin"],
  futureStyleIds: [],
  defaultFontWeight: 900
}], ["sharp-duotone", {
  defaultShortPrefixId: "fasds",
  defaultStyleId: "solid",
  styleIds: ["solid", "regular", "light", "thin"],
  futureStyleIds: [],
  defaultFontWeight: 900
}]]), aU = {
  classic: {
    solid: "fas",
    regular: "far",
    light: "fal",
    thin: "fat",
    brands: "fab"
  },
  duotone: {
    solid: "fad",
    regular: "fadr",
    light: "fadl",
    thin: "fadt"
  },
  sharp: {
    solid: "fass",
    regular: "fasr",
    light: "fasl",
    thin: "fast"
  },
  "sharp-duotone": {
    solid: "fasds",
    regular: "fasdr",
    light: "fasdl",
    thin: "fasdt"
  }
}, lU = ["fak", "fa-kit", "fakd", "fa-kit-duotone"], LE = {
  kit: {
    fak: "kit",
    "fa-kit": "kit"
  },
  "kit-duotone": {
    fakd: "kit-duotone",
    "fa-kit-duotone": "kit-duotone"
  }
}, sU = ["kit"], uU = {
  kit: {
    "fa-kit": "fak"
  }
}, cU = ["fak", "fakd"], dU = {
  kit: {
    fak: "fa-kit"
  }
}, IE = {
  kit: {
    kit: "fak"
  },
  "kit-duotone": {
    "kit-duotone": "fakd"
  }
}, Tf = {
  GROUP: "duotone-group",
  SWAP_OPACITY: "swap-opacity",
  PRIMARY: "primary",
  SECONDARY: "secondary"
}, fU = ["fa-classic", "fa-duotone", "fa-sharp", "fa-sharp-duotone"], pU = ["fak", "fa-kit", "fakd", "fa-kit-duotone"], hU = {
  "Font Awesome Kit": {
    400: "fak",
    normal: "fak"
  },
  "Font Awesome Kit Duotone": {
    400: "fakd",
    normal: "fakd"
  }
}, mU = {
  classic: {
    "fa-brands": "fab",
    "fa-duotone": "fad",
    "fa-light": "fal",
    "fa-regular": "far",
    "fa-solid": "fas",
    "fa-thin": "fat"
  },
  duotone: {
    "fa-regular": "fadr",
    "fa-light": "fadl",
    "fa-thin": "fadt"
  },
  sharp: {
    "fa-solid": "fass",
    "fa-regular": "fasr",
    "fa-light": "fasl",
    "fa-thin": "fast"
  },
  "sharp-duotone": {
    "fa-solid": "fasds",
    "fa-regular": "fasdr",
    "fa-light": "fasdl",
    "fa-thin": "fasdt"
  }
}, gU = {
  classic: ["fas", "far", "fal", "fat", "fad"],
  duotone: ["fadr", "fadl", "fadt"],
  sharp: ["fass", "fasr", "fasl", "fast"],
  "sharp-duotone": ["fasds", "fasdr", "fasdl", "fasdt"]
}, ib = {
  classic: {
    fab: "fa-brands",
    fad: "fa-duotone",
    fal: "fa-light",
    far: "fa-regular",
    fas: "fa-solid",
    fat: "fa-thin"
  },
  duotone: {
    fadr: "fa-regular",
    fadl: "fa-light",
    fadt: "fa-thin"
  },
  sharp: {
    fass: "fa-solid",
    fasr: "fa-regular",
    fasl: "fa-light",
    fast: "fa-thin"
  },
  "sharp-duotone": {
    fasds: "fa-solid",
    fasdr: "fa-regular",
    fasdl: "fa-light",
    fasdt: "fa-thin"
  }
}, yU = ["fa-solid", "fa-regular", "fa-light", "fa-thin", "fa-duotone", "fa-brands"], ab = ["fa", "fas", "far", "fal", "fat", "fad", "fadr", "fadl", "fadt", "fab", "fass", "fasr", "fasl", "fast", "fasds", "fasdr", "fasdl", "fasdt", ...fU, ...yU], vU = ["solid", "regular", "light", "thin", "duotone", "brands"], DN = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10], bU = DN.concat([11, 12, 13, 14, 15, 16, 17, 18, 19, 20]), wU = [...Object.keys(gU), ...vU, "2xs", "xs", "sm", "lg", "xl", "2xl", "beat", "border", "fade", "beat-fade", "bounce", "flip-both", "flip-horizontal", "flip-vertical", "flip", "fw", "inverse", "layers-counter", "layers-text", "layers", "li", "pull-left", "pull-right", "pulse", "rotate-180", "rotate-270", "rotate-90", "rotate-by", "shake", "spin-pulse", "spin-reverse", "spin", "stack-1x", "stack-2x", "stack", "ul", Tf.GROUP, Tf.SWAP_OPACITY, Tf.PRIMARY, Tf.SECONDARY].concat(DN.map((e) => "".concat(e, "x"))).concat(bU.map((e) => "w-".concat(e))), xU = {
  "Font Awesome 5 Free": {
    900: "fas",
    400: "far"
  },
  "Font Awesome 5 Pro": {
    900: "fas",
    400: "far",
    normal: "far",
    300: "fal"
  },
  "Font Awesome 5 Brands": {
    400: "fab",
    normal: "fab"
  },
  "Font Awesome 5 Duotone": {
    900: "fad"
  }
};
const $o = "___FONT_AWESOME___", lb = 16, TN = "fa", zN = "svg-inline--fa", Ta = "data-fa-i2svg", sb = "data-fa-pseudo-element", SU = "data-fa-pseudo-element-pending", Dw = "data-prefix", Tw = "data-icon", BE = "fontawesome-i2svg", kU = "async", _U = ["HTML", "HEAD", "STYLE", "SCRIPT"], PN = (() => {
  try {
    return !0;
  } catch {
    return !1;
  }
})();
function Bc(e) {
  return new Proxy(e, {
    get(t, n) {
      return n in t ? t[n] : t[gn];
    }
  });
}
const LN = me({}, AN);
LN[gn] = me(me(me(me({}, {
  "fa-duotone": "duotone"
}), AN[gn]), LE.kit), LE["kit-duotone"]);
const EU = Bc(LN), ub = me({}, aU);
ub[gn] = me(me(me(me({}, {
  duotone: "fad"
}), ub[gn]), IE.kit), IE["kit-duotone"]);
const VE = Bc(ub), cb = me({}, ib);
cb[gn] = me(me({}, cb[gn]), dU.kit);
const zw = Bc(cb), db = me({}, mU);
db[gn] = me(me({}, db[gn]), uU.kit);
Bc(db);
const CU = QH, IN = "fa-layers-text", OU = JH, NU = me({}, rU);
Bc(NU);
const MU = ["class", "data-prefix", "data-icon", "data-fa-transform", "data-fa-mask"], Gy = eU, AU = [...sU, ...wU], Qu = Hi.FontAwesomeConfig || {};
function RU(e) {
  var t = bt.querySelector("script[" + e + "]");
  if (t)
    return t.getAttribute(e);
}
function jU(e) {
  return e === "" ? !0 : e === "false" ? !1 : e === "true" ? !0 : e;
}
bt && typeof bt.querySelector == "function" && [["data-family-prefix", "familyPrefix"], ["data-css-prefix", "cssPrefix"], ["data-family-default", "familyDefault"], ["data-style-default", "styleDefault"], ["data-replacement-class", "replacementClass"], ["data-auto-replace-svg", "autoReplaceSvg"], ["data-auto-add-css", "autoAddCss"], ["data-auto-a11y", "autoA11y"], ["data-search-pseudo-elements", "searchPseudoElements"], ["data-observe-mutations", "observeMutations"], ["data-mutate-approach", "mutateApproach"], ["data-keep-original-source", "keepOriginalSource"], ["data-measure-performance", "measurePerformance"], ["data-show-missing-icons", "showMissingIcons"]].forEach((e) => {
  let [t, n] = e;
  const r = jU(RU(t));
  r != null && (Qu[n] = r);
});
const BN = {
  styleDefault: "solid",
  familyDefault: gn,
  cssPrefix: TN,
  replacementClass: zN,
  autoReplaceSvg: !0,
  autoAddCss: !0,
  autoA11y: !0,
  searchPseudoElements: !1,
  observeMutations: !0,
  mutateApproach: "async",
  keepOriginalSource: !0,
  measurePerformance: !1,
  showMissingIcons: !0
};
Qu.familyPrefix && (Qu.cssPrefix = Qu.familyPrefix);
const us = me(me({}, BN), Qu);
us.autoReplaceSvg || (us.observeMutations = !1);
const Se = {};
Object.keys(BN).forEach((e) => {
  Object.defineProperty(Se, e, {
    enumerable: !0,
    set: function(t) {
      us[e] = t, Ju.forEach((n) => n(Se));
    },
    get: function() {
      return us[e];
    }
  });
});
Object.defineProperty(Se, "familyPrefix", {
  enumerable: !0,
  set: function(e) {
    us.cssPrefix = e, Ju.forEach((t) => t(Se));
  },
  get: function() {
    return us.cssPrefix;
  }
});
Hi.FontAwesomeConfig = Se;
const Ju = [];
function DU(e) {
  return Ju.push(e), () => {
    Ju.splice(Ju.indexOf(e), 1);
  };
}
const Ri = lb, eo = {
  size: 16,
  x: 0,
  y: 0,
  rotate: 0,
  flipX: !1,
  flipY: !1
};
function TU(e) {
  if (!e || !Ko)
    return;
  const t = bt.createElement("style");
  t.setAttribute("type", "text/css"), t.innerHTML = e;
  const n = bt.head.childNodes;
  let r = null;
  for (let o = n.length - 1; o > -1; o--) {
    const a = n[o], l = (a.tagName || "").toUpperCase();
    ["STYLE", "LINK"].indexOf(l) > -1 && (r = a);
  }
  return bt.head.insertBefore(t, r), e;
}
const zU = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ";
function mc() {
  let e = 12, t = "";
  for (; e-- > 0; )
    t += zU[Math.random() * 62 | 0];
  return t;
}
function vs(e) {
  const t = [];
  for (let n = (e || []).length >>> 0; n--; )
    t[n] = e[n];
  return t;
}
function Pw(e) {
  return e.classList ? vs(e.classList) : (e.getAttribute("class") || "").split(" ").filter((t) => t);
}
function VN(e) {
  return "".concat(e).replace(/&/g, "&amp;").replace(/"/g, "&quot;").replace(/'/g, "&#39;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
}
function PU(e) {
  return Object.keys(e || {}).reduce((t, n) => t + "".concat(n, '="').concat(VN(e[n]), '" '), "").trim();
}
function Oh(e) {
  return Object.keys(e || {}).reduce((t, n) => t + "".concat(n, ": ").concat(e[n].trim(), ";"), "");
}
function Lw(e) {
  return e.size !== eo.size || e.x !== eo.x || e.y !== eo.y || e.rotate !== eo.rotate || e.flipX || e.flipY;
}
function LU(e) {
  let {
    transform: t,
    containerWidth: n,
    iconWidth: r
  } = e;
  const o = {
    transform: "translate(".concat(n / 2, " 256)")
  }, a = "translate(".concat(t.x * 32, ", ").concat(t.y * 32, ") "), l = "scale(".concat(t.size / 16 * (t.flipX ? -1 : 1), ", ").concat(t.size / 16 * (t.flipY ? -1 : 1), ") "), u = "rotate(".concat(t.rotate, " 0 0)"), d = {
    transform: "".concat(a, " ").concat(l, " ").concat(u)
  }, f = {
    transform: "translate(".concat(r / 2 * -1, " -256)")
  };
  return {
    outer: o,
    inner: d,
    path: f
  };
}
function IU(e) {
  let {
    transform: t,
    width: n = lb,
    height: r = lb,
    startCentered: o = !1
  } = e, a = "";
  return o && MN ? a += "translate(".concat(t.x / Ri - n / 2, "em, ").concat(t.y / Ri - r / 2, "em) ") : o ? a += "translate(calc(-50% + ".concat(t.x / Ri, "em), calc(-50% + ").concat(t.y / Ri, "em)) ") : a += "translate(".concat(t.x / Ri, "em, ").concat(t.y / Ri, "em) "), a += "scale(".concat(t.size / Ri * (t.flipX ? -1 : 1), ", ").concat(t.size / Ri * (t.flipY ? -1 : 1), ") "), a += "rotate(".concat(t.rotate, "deg) "), a;
}
var BU = `:root, :host {
  --fa-font-solid: normal 900 1em/1 "Font Awesome 6 Free";
  --fa-font-regular: normal 400 1em/1 "Font Awesome 6 Free";
  --fa-font-light: normal 300 1em/1 "Font Awesome 6 Pro";
  --fa-font-thin: normal 100 1em/1 "Font Awesome 6 Pro";
  --fa-font-duotone: normal 900 1em/1 "Font Awesome 6 Duotone";
  --fa-font-duotone-regular: normal 400 1em/1 "Font Awesome 6 Duotone";
  --fa-font-duotone-light: normal 300 1em/1 "Font Awesome 6 Duotone";
  --fa-font-duotone-thin: normal 100 1em/1 "Font Awesome 6 Duotone";
  --fa-font-brands: normal 400 1em/1 "Font Awesome 6 Brands";
  --fa-font-sharp-solid: normal 900 1em/1 "Font Awesome 6 Sharp";
  --fa-font-sharp-regular: normal 400 1em/1 "Font Awesome 6 Sharp";
  --fa-font-sharp-light: normal 300 1em/1 "Font Awesome 6 Sharp";
  --fa-font-sharp-thin: normal 100 1em/1 "Font Awesome 6 Sharp";
  --fa-font-sharp-duotone-solid: normal 900 1em/1 "Font Awesome 6 Sharp Duotone";
  --fa-font-sharp-duotone-regular: normal 400 1em/1 "Font Awesome 6 Sharp Duotone";
  --fa-font-sharp-duotone-light: normal 300 1em/1 "Font Awesome 6 Sharp Duotone";
  --fa-font-sharp-duotone-thin: normal 100 1em/1 "Font Awesome 6 Sharp Duotone";
}

svg:not(:root).svg-inline--fa, svg:not(:host).svg-inline--fa {
  overflow: visible;
  box-sizing: content-box;
}

.svg-inline--fa {
  display: var(--fa-display, inline-block);
  height: 1em;
  overflow: visible;
  vertical-align: -0.125em;
}
.svg-inline--fa.fa-2xs {
  vertical-align: 0.1em;
}
.svg-inline--fa.fa-xs {
  vertical-align: 0em;
}
.svg-inline--fa.fa-sm {
  vertical-align: -0.0714285705em;
}
.svg-inline--fa.fa-lg {
  vertical-align: -0.2em;
}
.svg-inline--fa.fa-xl {
  vertical-align: -0.25em;
}
.svg-inline--fa.fa-2xl {
  vertical-align: -0.3125em;
}
.svg-inline--fa.fa-pull-left {
  margin-right: var(--fa-pull-margin, 0.3em);
  width: auto;
}
.svg-inline--fa.fa-pull-right {
  margin-left: var(--fa-pull-margin, 0.3em);
  width: auto;
}
.svg-inline--fa.fa-li {
  width: var(--fa-li-width, 2em);
  top: 0.25em;
}
.svg-inline--fa.fa-fw {
  width: var(--fa-fw-width, 1.25em);
}

.fa-layers svg.svg-inline--fa {
  bottom: 0;
  left: 0;
  margin: auto;
  position: absolute;
  right: 0;
  top: 0;
}

.fa-layers-counter, .fa-layers-text {
  display: inline-block;
  position: absolute;
  text-align: center;
}

.fa-layers {
  display: inline-block;
  height: 1em;
  position: relative;
  text-align: center;
  vertical-align: -0.125em;
  width: 1em;
}
.fa-layers svg.svg-inline--fa {
  transform-origin: center center;
}

.fa-layers-text {
  left: 50%;
  top: 50%;
  transform: translate(-50%, -50%);
  transform-origin: center center;
}

.fa-layers-counter {
  background-color: var(--fa-counter-background-color, #ff253a);
  border-radius: var(--fa-counter-border-radius, 1em);
  box-sizing: border-box;
  color: var(--fa-inverse, #fff);
  line-height: var(--fa-counter-line-height, 1);
  max-width: var(--fa-counter-max-width, 5em);
  min-width: var(--fa-counter-min-width, 1.5em);
  overflow: hidden;
  padding: var(--fa-counter-padding, 0.25em 0.5em);
  right: var(--fa-right, 0);
  text-overflow: ellipsis;
  top: var(--fa-top, 0);
  transform: scale(var(--fa-counter-scale, 0.25));
  transform-origin: top right;
}

.fa-layers-bottom-right {
  bottom: var(--fa-bottom, 0);
  right: var(--fa-right, 0);
  top: auto;
  transform: scale(var(--fa-layers-scale, 0.25));
  transform-origin: bottom right;
}

.fa-layers-bottom-left {
  bottom: var(--fa-bottom, 0);
  left: var(--fa-left, 0);
  right: auto;
  top: auto;
  transform: scale(var(--fa-layers-scale, 0.25));
  transform-origin: bottom left;
}

.fa-layers-top-right {
  top: var(--fa-top, 0);
  right: var(--fa-right, 0);
  transform: scale(var(--fa-layers-scale, 0.25));
  transform-origin: top right;
}

.fa-layers-top-left {
  left: var(--fa-left, 0);
  right: auto;
  top: var(--fa-top, 0);
  transform: scale(var(--fa-layers-scale, 0.25));
  transform-origin: top left;
}

.fa-1x {
  font-size: 1em;
}

.fa-2x {
  font-size: 2em;
}

.fa-3x {
  font-size: 3em;
}

.fa-4x {
  font-size: 4em;
}

.fa-5x {
  font-size: 5em;
}

.fa-6x {
  font-size: 6em;
}

.fa-7x {
  font-size: 7em;
}

.fa-8x {
  font-size: 8em;
}

.fa-9x {
  font-size: 9em;
}

.fa-10x {
  font-size: 10em;
}

.fa-2xs {
  font-size: 0.625em;
  line-height: 0.1em;
  vertical-align: 0.225em;
}

.fa-xs {
  font-size: 0.75em;
  line-height: 0.0833333337em;
  vertical-align: 0.125em;
}

.fa-sm {
  font-size: 0.875em;
  line-height: 0.0714285718em;
  vertical-align: 0.0535714295em;
}

.fa-lg {
  font-size: 1.25em;
  line-height: 0.05em;
  vertical-align: -0.075em;
}

.fa-xl {
  font-size: 1.5em;
  line-height: 0.0416666682em;
  vertical-align: -0.125em;
}

.fa-2xl {
  font-size: 2em;
  line-height: 0.03125em;
  vertical-align: -0.1875em;
}

.fa-fw {
  text-align: center;
  width: 1.25em;
}

.fa-ul {
  list-style-type: none;
  margin-left: var(--fa-li-margin, 2.5em);
  padding-left: 0;
}
.fa-ul > li {
  position: relative;
}

.fa-li {
  left: calc(-1 * var(--fa-li-width, 2em));
  position: absolute;
  text-align: center;
  width: var(--fa-li-width, 2em);
  line-height: inherit;
}

.fa-border {
  border-color: var(--fa-border-color, #eee);
  border-radius: var(--fa-border-radius, 0.1em);
  border-style: var(--fa-border-style, solid);
  border-width: var(--fa-border-width, 0.08em);
  padding: var(--fa-border-padding, 0.2em 0.25em 0.15em);
}

.fa-pull-left {
  float: left;
  margin-right: var(--fa-pull-margin, 0.3em);
}

.fa-pull-right {
  float: right;
  margin-left: var(--fa-pull-margin, 0.3em);
}

.fa-beat {
  animation-name: fa-beat;
  animation-delay: var(--fa-animation-delay, 0s);
  animation-direction: var(--fa-animation-direction, normal);
  animation-duration: var(--fa-animation-duration, 1s);
  animation-iteration-count: var(--fa-animation-iteration-count, infinite);
  animation-timing-function: var(--fa-animation-timing, ease-in-out);
}

.fa-bounce {
  animation-name: fa-bounce;
  animation-delay: var(--fa-animation-delay, 0s);
  animation-direction: var(--fa-animation-direction, normal);
  animation-duration: var(--fa-animation-duration, 1s);
  animation-iteration-count: var(--fa-animation-iteration-count, infinite);
  animation-timing-function: var(--fa-animation-timing, cubic-bezier(0.28, 0.84, 0.42, 1));
}

.fa-fade {
  animation-name: fa-fade;
  animation-delay: var(--fa-animation-delay, 0s);
  animation-direction: var(--fa-animation-direction, normal);
  animation-duration: var(--fa-animation-duration, 1s);
  animation-iteration-count: var(--fa-animation-iteration-count, infinite);
  animation-timing-function: var(--fa-animation-timing, cubic-bezier(0.4, 0, 0.6, 1));
}

.fa-beat-fade {
  animation-name: fa-beat-fade;
  animation-delay: var(--fa-animation-delay, 0s);
  animation-direction: var(--fa-animation-direction, normal);
  animation-duration: var(--fa-animation-duration, 1s);
  animation-iteration-count: var(--fa-animation-iteration-count, infinite);
  animation-timing-function: var(--fa-animation-timing, cubic-bezier(0.4, 0, 0.6, 1));
}

.fa-flip {
  animation-name: fa-flip;
  animation-delay: var(--fa-animation-delay, 0s);
  animation-direction: var(--fa-animation-direction, normal);
  animation-duration: var(--fa-animation-duration, 1s);
  animation-iteration-count: var(--fa-animation-iteration-count, infinite);
  animation-timing-function: var(--fa-animation-timing, ease-in-out);
}

.fa-shake {
  animation-name: fa-shake;
  animation-delay: var(--fa-animation-delay, 0s);
  animation-direction: var(--fa-animation-direction, normal);
  animation-duration: var(--fa-animation-duration, 1s);
  animation-iteration-count: var(--fa-animation-iteration-count, infinite);
  animation-timing-function: var(--fa-animation-timing, linear);
}

.fa-spin {
  animation-name: fa-spin;
  animation-delay: var(--fa-animation-delay, 0s);
  animation-direction: var(--fa-animation-direction, normal);
  animation-duration: var(--fa-animation-duration, 2s);
  animation-iteration-count: var(--fa-animation-iteration-count, infinite);
  animation-timing-function: var(--fa-animation-timing, linear);
}

.fa-spin-reverse {
  --fa-animation-direction: reverse;
}

.fa-pulse,
.fa-spin-pulse {
  animation-name: fa-spin;
  animation-direction: var(--fa-animation-direction, normal);
  animation-duration: var(--fa-animation-duration, 1s);
  animation-iteration-count: var(--fa-animation-iteration-count, infinite);
  animation-timing-function: var(--fa-animation-timing, steps(8));
}

@media (prefers-reduced-motion: reduce) {
  .fa-beat,
.fa-bounce,
.fa-fade,
.fa-beat-fade,
.fa-flip,
.fa-pulse,
.fa-shake,
.fa-spin,
.fa-spin-pulse {
    animation-delay: -1ms;
    animation-duration: 1ms;
    animation-iteration-count: 1;
    transition-delay: 0s;
    transition-duration: 0s;
  }
}
@keyframes fa-beat {
  0%, 90% {
    transform: scale(1);
  }
  45% {
    transform: scale(var(--fa-beat-scale, 1.25));
  }
}
@keyframes fa-bounce {
  0% {
    transform: scale(1, 1) translateY(0);
  }
  10% {
    transform: scale(var(--fa-bounce-start-scale-x, 1.1), var(--fa-bounce-start-scale-y, 0.9)) translateY(0);
  }
  30% {
    transform: scale(var(--fa-bounce-jump-scale-x, 0.9), var(--fa-bounce-jump-scale-y, 1.1)) translateY(var(--fa-bounce-height, -0.5em));
  }
  50% {
    transform: scale(var(--fa-bounce-land-scale-x, 1.05), var(--fa-bounce-land-scale-y, 0.95)) translateY(0);
  }
  57% {
    transform: scale(1, 1) translateY(var(--fa-bounce-rebound, -0.125em));
  }
  64% {
    transform: scale(1, 1) translateY(0);
  }
  100% {
    transform: scale(1, 1) translateY(0);
  }
}
@keyframes fa-fade {
  50% {
    opacity: var(--fa-fade-opacity, 0.4);
  }
}
@keyframes fa-beat-fade {
  0%, 100% {
    opacity: var(--fa-beat-fade-opacity, 0.4);
    transform: scale(1);
  }
  50% {
    opacity: 1;
    transform: scale(var(--fa-beat-fade-scale, 1.125));
  }
}
@keyframes fa-flip {
  50% {
    transform: rotate3d(var(--fa-flip-x, 0), var(--fa-flip-y, 1), var(--fa-flip-z, 0), var(--fa-flip-angle, -180deg));
  }
}
@keyframes fa-shake {
  0% {
    transform: rotate(-15deg);
  }
  4% {
    transform: rotate(15deg);
  }
  8%, 24% {
    transform: rotate(-18deg);
  }
  12%, 28% {
    transform: rotate(18deg);
  }
  16% {
    transform: rotate(-22deg);
  }
  20% {
    transform: rotate(22deg);
  }
  32% {
    transform: rotate(-12deg);
  }
  36% {
    transform: rotate(12deg);
  }
  40%, 100% {
    transform: rotate(0deg);
  }
}
@keyframes fa-spin {
  0% {
    transform: rotate(0deg);
  }
  100% {
    transform: rotate(360deg);
  }
}
.fa-rotate-90 {
  transform: rotate(90deg);
}

.fa-rotate-180 {
  transform: rotate(180deg);
}

.fa-rotate-270 {
  transform: rotate(270deg);
}

.fa-flip-horizontal {
  transform: scale(-1, 1);
}

.fa-flip-vertical {
  transform: scale(1, -1);
}

.fa-flip-both,
.fa-flip-horizontal.fa-flip-vertical {
  transform: scale(-1, -1);
}

.fa-rotate-by {
  transform: rotate(var(--fa-rotate-angle, 0));
}

.fa-stack {
  display: inline-block;
  vertical-align: middle;
  height: 2em;
  position: relative;
  width: 2.5em;
}

.fa-stack-1x,
.fa-stack-2x {
  bottom: 0;
  left: 0;
  margin: auto;
  position: absolute;
  right: 0;
  top: 0;
  z-index: var(--fa-stack-z-index, auto);
}

.svg-inline--fa.fa-stack-1x {
  height: 1em;
  width: 1.25em;
}
.svg-inline--fa.fa-stack-2x {
  height: 2em;
  width: 2.5em;
}

.fa-inverse {
  color: var(--fa-inverse, #fff);
}

.sr-only,
.fa-sr-only {
  position: absolute;
  width: 1px;
  height: 1px;
  padding: 0;
  margin: -1px;
  overflow: hidden;
  clip: rect(0, 0, 0, 0);
  white-space: nowrap;
  border-width: 0;
}

.sr-only-focusable:not(:focus),
.fa-sr-only-focusable:not(:focus) {
  position: absolute;
  width: 1px;
  height: 1px;
  padding: 0;
  margin: -1px;
  overflow: hidden;
  clip: rect(0, 0, 0, 0);
  white-space: nowrap;
  border-width: 0;
}

.svg-inline--fa .fa-primary {
  fill: var(--fa-primary-color, currentColor);
  opacity: var(--fa-primary-opacity, 1);
}

.svg-inline--fa .fa-secondary {
  fill: var(--fa-secondary-color, currentColor);
  opacity: var(--fa-secondary-opacity, 0.4);
}

.svg-inline--fa.fa-swap-opacity .fa-primary {
  opacity: var(--fa-secondary-opacity, 0.4);
}

.svg-inline--fa.fa-swap-opacity .fa-secondary {
  opacity: var(--fa-primary-opacity, 1);
}

.svg-inline--fa mask .fa-primary,
.svg-inline--fa mask .fa-secondary {
  fill: black;
}`;
function HN() {
  const e = TN, t = zN, n = Se.cssPrefix, r = Se.replacementClass;
  let o = BU;
  if (n !== e || r !== t) {
    const a = new RegExp("\\.".concat(e, "\\-"), "g"), l = new RegExp("\\--".concat(e, "\\-"), "g"), u = new RegExp("\\.".concat(t), "g");
    o = o.replace(a, ".".concat(n, "-")).replace(l, "--".concat(n, "-")).replace(u, ".".concat(r));
  }
  return o;
}
let HE = !1;
function Zy() {
  Se.autoAddCss && !HE && (TU(HN()), HE = !0);
}
var VU = {
  mixout() {
    return {
      dom: {
        css: HN,
        insertCss: Zy
      }
    };
  },
  hooks() {
    return {
      beforeDOMElementCreation() {
        Zy();
      },
      beforeI2svg() {
        Zy();
      }
    };
  }
};
const Yo = Hi || {};
Yo[$o] || (Yo[$o] = {});
Yo[$o].styles || (Yo[$o].styles = {});
Yo[$o].hooks || (Yo[$o].hooks = {});
Yo[$o].shims || (Yo[$o].shims = []);
var to = Yo[$o];
const UN = [], FN = function() {
  bt.removeEventListener("DOMContentLoaded", FN), Ap = 1, UN.map((e) => e());
};
let Ap = !1;
Ko && (Ap = (bt.documentElement.doScroll ? /^loaded|^c/ : /^loaded|^i|^c/).test(bt.readyState), Ap || bt.addEventListener("DOMContentLoaded", FN));
function HU(e) {
  Ko && (Ap ? setTimeout(e, 0) : UN.push(e));
}
function Vc(e) {
  const {
    tag: t,
    attributes: n = {},
    children: r = []
  } = e;
  return typeof e == "string" ? VN(e) : "<".concat(t, " ").concat(PU(n), ">").concat(r.map(Vc).join(""), "</").concat(t, ">");
}
function UE(e, t, n) {
  if (e && e[t] && e[t][n])
    return {
      prefix: t,
      iconName: n,
      icon: e[t][n]
    };
}
var Wy = function(e, t, n, r) {
  var o = Object.keys(e), a = o.length, l = t, u, d, f;
  for (n === void 0 ? (u = 1, f = e[o[0]]) : (u = 0, f = n); u < a; u++)
    d = o[u], f = l(f, e[d], d, e);
  return f;
};
function UU(e) {
  const t = [];
  let n = 0;
  const r = e.length;
  for (; n < r; ) {
    const o = e.charCodeAt(n++);
    if (o >= 55296 && o <= 56319 && n < r) {
      const a = e.charCodeAt(n++);
      (a & 64512) == 56320 ? t.push(((o & 1023) << 10) + (a & 1023) + 65536) : (t.push(o), n--);
    } else
      t.push(o);
  }
  return t;
}
function $N(e) {
  const t = UU(e);
  return t.length === 1 ? t[0].toString(16) : null;
}
function FU(e, t) {
  const n = e.length;
  let r = e.charCodeAt(t), o;
  return r >= 55296 && r <= 56319 && n > t + 1 && (o = e.charCodeAt(t + 1), o >= 56320 && o <= 57343) ? (r - 55296) * 1024 + o - 56320 + 65536 : r;
}
function FE(e) {
  return Object.keys(e).reduce((t, n) => {
    const r = e[n];
    return r.icon ? t[r.iconName] = r.icon : t[n] = r, t;
  }, {});
}
function fb(e, t) {
  let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  const {
    skipHooks: r = !1
  } = n, o = FE(t);
  typeof to.hooks.addPack == "function" && !r ? to.hooks.addPack(e, FE(t)) : to.styles[e] = me(me({}, to.styles[e] || {}), o), e === "fas" && fb("fa", t);
}
const {
  styles: gc,
  shims: $U
} = to, YN = Object.keys(zw), YU = YN.reduce((e, t) => (e[t] = Object.keys(zw[t]), e), {});
let Iw = null, qN = {}, XN = {}, GN = {}, ZN = {}, WN = {};
function qU(e) {
  return ~AU.indexOf(e);
}
function XU(e, t) {
  const n = t.split("-"), r = n[0], o = n.slice(1).join("-");
  return r === e && o !== "" && !qU(o) ? o : null;
}
const KN = () => {
  const e = (r) => Wy(gc, (o, a, l) => (o[l] = Wy(a, r, {}), o), {});
  qN = e((r, o, a) => (o[3] && (r[o[3]] = a), o[2] && o[2].filter((l) => typeof l == "number").forEach((l) => {
    r[l.toString(16)] = a;
  }), r)), XN = e((r, o, a) => (r[a] = a, o[2] && o[2].filter((l) => typeof l == "string").forEach((l) => {
    r[l] = a;
  }), r)), WN = e((r, o, a) => {
    const l = o[2];
    return r[a] = a, l.forEach((u) => {
      r[u] = a;
    }), r;
  });
  const t = "far" in gc || Se.autoFetchSvg, n = Wy($U, (r, o) => {
    const a = o[0];
    let l = o[1];
    const u = o[2];
    return l === "far" && !t && (l = "fas"), typeof a == "string" && (r.names[a] = {
      prefix: l,
      iconName: u
    }), typeof a == "number" && (r.unicodes[a.toString(16)] = {
      prefix: l,
      iconName: u
    }), r;
  }, {
    names: {},
    unicodes: {}
  });
  GN = n.names, ZN = n.unicodes, Iw = Nh(Se.styleDefault, {
    family: Se.familyDefault
  });
};
DU((e) => {
  Iw = Nh(e.styleDefault, {
    family: Se.familyDefault
  });
});
KN();
function Bw(e, t) {
  return (qN[e] || {})[t];
}
function GU(e, t) {
  return (XN[e] || {})[t];
}
function ka(e, t) {
  return (WN[e] || {})[t];
}
function QN(e) {
  return GN[e] || {
    prefix: null,
    iconName: null
  };
}
function ZU(e) {
  const t = ZN[e], n = Bw("fas", e);
  return t || (n ? {
    prefix: "fas",
    iconName: n
  } : null) || {
    prefix: null,
    iconName: null
  };
}
function Ui() {
  return Iw;
}
const JN = () => ({
  prefix: null,
  iconName: null,
  rest: []
});
function WU(e) {
  let t = gn;
  const n = YN.reduce((r, o) => (r[o] = "".concat(Se.cssPrefix, "-").concat(o), r), {});
  return jN.forEach((r) => {
    (e.includes(n[r]) || e.some((o) => YU[r].includes(o))) && (t = r);
  }), t;
}
function Nh(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  const {
    family: n = gn
  } = t, r = EU[n][e];
  if (n === Ch && !e)
    return "fad";
  const o = VE[n][e] || VE[n][r], a = e in to.styles ? e : null;
  return o || a || null;
}
function KU(e) {
  let t = [], n = null;
  return e.forEach((r) => {
    const o = XU(Se.cssPrefix, r);
    o ? n = o : r && t.push(r);
  }), {
    iconName: n,
    rest: t
  };
}
function $E(e) {
  return e.sort().filter((t, n, r) => r.indexOf(t) === n);
}
function Mh(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  const {
    skipLookups: n = !1
  } = t;
  let r = null;
  const o = ab.concat(pU), a = $E(e.filter((m) => o.includes(m))), l = $E(e.filter((m) => !ab.includes(m))), u = a.filter((m) => (r = m, !RN.includes(m))), [d = null] = u, f = WU(a), p = me(me({}, KU(l)), {}, {
    prefix: Nh(d, {
      family: f
    })
  });
  return me(me(me({}, p), tF({
    values: e,
    family: f,
    styles: gc,
    config: Se,
    canonical: p,
    givenPrefix: r
  })), QU(n, r, p));
}
function QU(e, t, n) {
  let {
    prefix: r,
    iconName: o
  } = n;
  if (e || !r || !o)
    return {
      prefix: r,
      iconName: o
    };
  const a = t === "fa" ? QN(o) : {}, l = ka(r, o);
  return o = a.iconName || l || o, r = a.prefix || r, r === "far" && !gc.far && gc.fas && !Se.autoFetchSvg && (r = "fas"), {
    prefix: r,
    iconName: o
  };
}
const JU = jN.filter((e) => e !== gn || e !== Ch), eF = Object.keys(ib).filter((e) => e !== gn).map((e) => Object.keys(ib[e])).flat();
function tF(e) {
  const {
    values: t,
    family: n,
    canonical: r,
    givenPrefix: o = "",
    styles: a = {},
    config: l = {}
  } = e, u = n === Ch, d = t.includes("fa-duotone") || t.includes("fad"), f = l.familyDefault === "duotone", p = r.prefix === "fad" || r.prefix === "fa-duotone";
  if (!u && (d || f || p) && (r.prefix = "fad"), (t.includes("fa-brands") || t.includes("fab")) && (r.prefix = "fab"), !r.prefix && JU.includes(n) && (Object.keys(a).find((m) => eF.includes(m)) || l.autoFetchSvg)) {
    const m = iU.get(n).defaultShortPrefixId;
    r.prefix = m, r.iconName = ka(r.prefix, r.iconName) || r.iconName;
  }
  return (r.prefix === "fa" || o === "fa") && (r.prefix = Ui() || "fas"), r;
}
let nF = class {
  constructor() {
    this.definitions = {};
  }
  add() {
    for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)
      t[n] = arguments[n];
    const r = t.reduce(this._pullDefinitions, {});
    Object.keys(r).forEach((o) => {
      this.definitions[o] = me(me({}, this.definitions[o] || {}), r[o]), fb(o, r[o]);
      const a = zw[gn][o];
      a && fb(a, r[o]), KN();
    });
  }
  reset() {
    this.definitions = {};
  }
  _pullDefinitions(e, t) {
    const n = t.prefix && t.iconName && t.icon ? {
      0: t
    } : t;
    return Object.keys(n).map((r) => {
      const {
        prefix: o,
        iconName: a,
        icon: l
      } = n[r], u = l[2];
      e[o] || (e[o] = {}), u.length > 0 && u.forEach((d) => {
        typeof d == "string" && (e[o][d] = l);
      }), e[o][a] = l;
    }), e;
  }
}, YE = [], $l = {};
const Zl = {}, rF = Object.keys(Zl);
function oF(e, t) {
  let {
    mixoutsTo: n
  } = t;
  return YE = e, $l = {}, Object.keys(Zl).forEach((r) => {
    rF.indexOf(r) === -1 && delete Zl[r];
  }), YE.forEach((r) => {
    const o = r.mixout ? r.mixout() : {};
    if (Object.keys(o).forEach((a) => {
      typeof o[a] == "function" && (n[a] = o[a]), typeof o[a] == "object" && Object.keys(o[a]).forEach((l) => {
        n[a] || (n[a] = {}), n[a][l] = o[a][l];
      });
    }), r.hooks) {
      const a = r.hooks();
      Object.keys(a).forEach((l) => {
        $l[l] || ($l[l] = []), $l[l].push(a[l]);
      });
    }
    r.provides && r.provides(Zl);
  }), n;
}
function pb(e, t) {
  for (var n = arguments.length, r = new Array(n > 2 ? n - 2 : 0), o = 2; o < n; o++)
    r[o - 2] = arguments[o];
  return ($l[e] || []).forEach((a) => {
    t = a.apply(null, [t, ...r]);
  }), t;
}
function za(e) {
  for (var t = arguments.length, n = new Array(t > 1 ? t - 1 : 0), r = 1; r < t; r++)
    n[r - 1] = arguments[r];
  ($l[e] || []).forEach((o) => {
    o.apply(null, n);
  });
}
function Fi() {
  const e = arguments[0], t = Array.prototype.slice.call(arguments, 1);
  return Zl[e] ? Zl[e].apply(null, t) : void 0;
}
function hb(e) {
  e.prefix === "fa" && (e.prefix = "fas");
  let {
    iconName: t
  } = e;
  const n = e.prefix || Ui();
  if (t)
    return t = ka(n, t) || t, UE(eM.definitions, n, t) || UE(to.styles, n, t);
}
const eM = new nF(), iF = () => {
  Se.autoReplaceSvg = !1, Se.observeMutations = !1, za("noAuto");
}, aF = {
  i2svg: function() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    return Ko ? (za("beforeI2svg", e), Fi("pseudoElements2svg", e), Fi("i2svg", e)) : Promise.reject(new Error("Operation requires a DOM of some kind."));
  },
  watch: function() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    const {
      autoReplaceSvgRoot: t
    } = e;
    Se.autoReplaceSvg === !1 && (Se.autoReplaceSvg = !0), Se.observeMutations = !0, HU(() => {
      sF({
        autoReplaceSvgRoot: t
      }), za("watch", e);
    });
  }
}, lF = {
  icon: (e) => {
    if (e === null)
      return null;
    if (typeof e == "object" && e.prefix && e.iconName)
      return {
        prefix: e.prefix,
        iconName: ka(e.prefix, e.iconName) || e.iconName
      };
    if (Array.isArray(e) && e.length === 2) {
      const t = e[1].indexOf("fa-") === 0 ? e[1].slice(3) : e[1], n = Nh(e[0]);
      return {
        prefix: n,
        iconName: ka(n, t) || t
      };
    }
    if (typeof e == "string" && (e.indexOf("".concat(Se.cssPrefix, "-")) > -1 || e.match(CU))) {
      const t = Mh(e.split(" "), {
        skipLookups: !0
      });
      return {
        prefix: t.prefix || Ui(),
        iconName: ka(t.prefix, t.iconName) || t.iconName
      };
    }
    if (typeof e == "string") {
      const t = Ui();
      return {
        prefix: t,
        iconName: ka(t, e) || e
      };
    }
  }
}, or = {
  noAuto: iF,
  config: Se,
  dom: aF,
  parse: lF,
  library: eM,
  findIconDefinition: hb,
  toHtml: Vc
}, sF = function() {
  let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
  const {
    autoReplaceSvgRoot: t = bt
  } = e;
  (Object.keys(to.styles).length > 0 || Se.autoFetchSvg) && Ko && Se.autoReplaceSvg && or.dom.i2svg({
    node: t
  });
};
function Ah(e, t) {
  return Object.defineProperty(e, "abstract", {
    get: t
  }), Object.defineProperty(e, "html", {
    get: function() {
      return e.abstract.map((n) => Vc(n));
    }
  }), Object.defineProperty(e, "node", {
    get: function() {
      if (!Ko) return;
      const n = bt.createElement("div");
      return n.innerHTML = e.html, n.children;
    }
  }), e;
}
function uF(e) {
  let {
    children: t,
    main: n,
    mask: r,
    attributes: o,
    styles: a,
    transform: l
  } = e;
  if (Lw(l) && n.found && !r.found) {
    const {
      width: u,
      height: d
    } = n, f = {
      x: u / d / 2,
      y: 0.5
    };
    o.style = Oh(me(me({}, a), {}, {
      "transform-origin": "".concat(f.x + l.x / 16, "em ").concat(f.y + l.y / 16, "em")
    }));
  }
  return [{
    tag: "svg",
    attributes: o,
    children: t
  }];
}
function cF(e) {
  let {
    prefix: t,
    iconName: n,
    children: r,
    attributes: o,
    symbol: a
  } = e;
  const l = a === !0 ? "".concat(t, "-").concat(Se.cssPrefix, "-").concat(n) : a;
  return [{
    tag: "svg",
    attributes: {
      style: "display: none;"
    },
    children: [{
      tag: "symbol",
      attributes: me(me({}, o), {}, {
        id: l
      }),
      children: r
    }]
  }];
}
function Vw(e) {
  const {
    icons: {
      main: t,
      mask: n
    },
    prefix: r,
    iconName: o,
    transform: a,
    symbol: l,
    title: u,
    maskId: d,
    titleId: f,
    extra: p,
    watchable: m = !1
  } = e, {
    width: g,
    height: y
  } = n.found ? n : t, w = cU.includes(r), v = [Se.replacementClass, o ? "".concat(Se.cssPrefix, "-").concat(o) : ""].filter((R) => p.classes.indexOf(R) === -1).filter((R) => R !== "" || !!R).concat(p.classes).join(" ");
  let x = {
    children: [],
    attributes: me(me({}, p.attributes), {}, {
      "data-prefix": r,
      "data-icon": o,
      class: v,
      role: p.attributes.role || "img",
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 ".concat(g, " ").concat(y)
    })
  };
  const E = w && !~p.classes.indexOf("fa-fw") ? {
    width: "".concat(g / y * 16 * 0.0625, "em")
  } : {};
  m && (x.attributes[Ta] = ""), u && (x.children.push({
    tag: "title",
    attributes: {
      id: x.attributes["aria-labelledby"] || "title-".concat(f || mc())
    },
    children: [u]
  }), delete x.attributes.title);
  const N = me(me({}, x), {}, {
    prefix: r,
    iconName: o,
    main: t,
    mask: n,
    maskId: d,
    transform: a,
    symbol: l,
    styles: me(me({}, E), p.styles)
  }), {
    children: C,
    attributes: A
  } = n.found && t.found ? Fi("generateAbstractMask", N) || {
    children: [],
    attributes: {}
  } : Fi("generateAbstractIcon", N) || {
    children: [],
    attributes: {}
  };
  return N.children = C, N.attributes = A, l ? cF(N) : uF(N);
}
function qE(e) {
  const {
    content: t,
    width: n,
    height: r,
    transform: o,
    title: a,
    extra: l,
    watchable: u = !1
  } = e, d = me(me(me({}, l.attributes), a ? {
    title: a
  } : {}), {}, {
    class: l.classes.join(" ")
  });
  u && (d[Ta] = "");
  const f = me({}, l.styles);
  Lw(o) && (f.transform = IU({
    transform: o,
    startCentered: !0,
    width: n,
    height: r
  }), f["-webkit-transform"] = f.transform);
  const p = Oh(f);
  p.length > 0 && (d.style = p);
  const m = [];
  return m.push({
    tag: "span",
    attributes: d,
    children: [t]
  }), a && m.push({
    tag: "span",
    attributes: {
      class: "sr-only"
    },
    children: [a]
  }), m;
}
function dF(e) {
  const {
    content: t,
    title: n,
    extra: r
  } = e, o = me(me(me({}, r.attributes), n ? {
    title: n
  } : {}), {}, {
    class: r.classes.join(" ")
  }), a = Oh(r.styles);
  a.length > 0 && (o.style = a);
  const l = [];
  return l.push({
    tag: "span",
    attributes: o,
    children: [t]
  }), n && l.push({
    tag: "span",
    attributes: {
      class: "sr-only"
    },
    children: [n]
  }), l;
}
const {
  styles: Ky
} = to;
function mb(e) {
  const t = e[0], n = e[1], [r] = e.slice(4);
  let o = null;
  return Array.isArray(r) ? o = {
    tag: "g",
    attributes: {
      class: "".concat(Se.cssPrefix, "-").concat(Gy.GROUP)
    },
    children: [{
      tag: "path",
      attributes: {
        class: "".concat(Se.cssPrefix, "-").concat(Gy.SECONDARY),
        fill: "currentColor",
        d: r[0]
      }
    }, {
      tag: "path",
      attributes: {
        class: "".concat(Se.cssPrefix, "-").concat(Gy.PRIMARY),
        fill: "currentColor",
        d: r[1]
      }
    }]
  } : o = {
    tag: "path",
    attributes: {
      fill: "currentColor",
      d: r
    }
  }, {
    found: !0,
    width: t,
    height: n,
    icon: o
  };
}
const fF = {
  found: !1,
  width: 512,
  height: 512
};
function pF(e, t) {
  !PN && !Se.showMissingIcons && e && console.error('Icon with name "'.concat(e, '" and prefix "').concat(t, '" is missing.'));
}
function gb(e, t) {
  let n = t;
  return t === "fa" && Se.styleDefault !== null && (t = Ui()), new Promise((r, o) => {
    if (n === "fa") {
      const a = QN(e) || {};
      e = a.iconName || e, t = a.prefix || t;
    }
    if (e && t && Ky[t] && Ky[t][e]) {
      const a = Ky[t][e];
      return r(mb(a));
    }
    pF(e, t), r(me(me({}, fF), {}, {
      icon: Se.showMissingIcons && e ? Fi("missingIconAbstract") || {} : {}
    }));
  });
}
const XE = () => {
}, yb = Se.measurePerformance && Df && Df.mark && Df.measure ? Df : {
  mark: XE,
  measure: XE
}, Yu = 'FA "6.7.2"', hF = (e) => (yb.mark("".concat(Yu, " ").concat(e, " begins")), () => tM(e)), tM = (e) => {
  yb.mark("".concat(Yu, " ").concat(e, " ends")), yb.measure("".concat(Yu, " ").concat(e), "".concat(Yu, " ").concat(e, " begins"), "".concat(Yu, " ").concat(e, " ends"));
};
var Hw = {
  begin: hF,
  end: tM
};
const ap = () => {
};
function GE(e) {
  return typeof (e.getAttribute ? e.getAttribute(Ta) : null) == "string";
}
function mF(e) {
  const t = e.getAttribute ? e.getAttribute(Dw) : null, n = e.getAttribute ? e.getAttribute(Tw) : null;
  return t && n;
}
function gF(e) {
  return e && e.classList && e.classList.contains && e.classList.contains(Se.replacementClass);
}
function yF() {
  return Se.autoReplaceSvg === !0 ? lp.replace : lp[Se.autoReplaceSvg] || lp.replace;
}
function vF(e) {
  return bt.createElementNS("http://www.w3.org/2000/svg", e);
}
function bF(e) {
  return bt.createElement(e);
}
function nM(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  const {
    ceFn: n = e.tag === "svg" ? vF : bF
  } = t;
  if (typeof e == "string")
    return bt.createTextNode(e);
  const r = n(e.tag);
  return Object.keys(e.attributes || []).forEach(function(o) {
    r.setAttribute(o, e.attributes[o]);
  }), (e.children || []).forEach(function(o) {
    r.appendChild(nM(o, {
      ceFn: n
    }));
  }), r;
}
function wF(e) {
  let t = " ".concat(e.outerHTML, " ");
  return t = "".concat(t, "Font Awesome fontawesome.com "), t;
}
const lp = {
  replace: function(e) {
    const t = e[0];
    if (t.parentNode)
      if (e[1].forEach((n) => {
        t.parentNode.insertBefore(nM(n), t);
      }), t.getAttribute(Ta) === null && Se.keepOriginalSource) {
        let n = bt.createComment(wF(t));
        t.parentNode.replaceChild(n, t);
      } else
        t.remove();
  },
  nest: function(e) {
    const t = e[0], n = e[1];
    if (~Pw(t).indexOf(Se.replacementClass))
      return lp.replace(e);
    const r = new RegExp("".concat(Se.cssPrefix, "-.*"));
    if (delete n[0].attributes.id, n[0].attributes.class) {
      const a = n[0].attributes.class.split(" ").reduce((l, u) => (u === Se.replacementClass || u.match(r) ? l.toSvg.push(u) : l.toNode.push(u), l), {
        toNode: [],
        toSvg: []
      });
      n[0].attributes.class = a.toSvg.join(" "), a.toNode.length === 0 ? t.removeAttribute("class") : t.setAttribute("class", a.toNode.join(" "));
    }
    const o = n.map((a) => Vc(a)).join(`
`);
    t.setAttribute(Ta, ""), t.innerHTML = o;
  }
};
function ZE(e) {
  e();
}
function rM(e, t) {
  const n = typeof t == "function" ? t : ap;
  if (e.length === 0)
    n();
  else {
    let r = ZE;
    Se.mutateApproach === kU && (r = Hi.requestAnimationFrame || ZE), r(() => {
      const o = yF(), a = Hw.begin("mutate");
      e.map(o), a(), n();
    });
  }
}
let Uw = !1;
function oM() {
  Uw = !0;
}
function vb() {
  Uw = !1;
}
let Rp = null;
function WE(e) {
  if (!PE || !Se.observeMutations)
    return;
  const {
    treeCallback: t = ap,
    nodeCallback: n = ap,
    pseudoElementsCallback: r = ap,
    observeMutationsRoot: o = bt
  } = e;
  Rp = new PE((a) => {
    if (Uw) return;
    const l = Ui();
    vs(a).forEach((u) => {
      if (u.type === "childList" && u.addedNodes.length > 0 && !GE(u.addedNodes[0]) && (Se.searchPseudoElements && r(u.target), t(u.target)), u.type === "attributes" && u.target.parentNode && Se.searchPseudoElements && r(u.target.parentNode), u.type === "attributes" && GE(u.target) && ~MU.indexOf(u.attributeName))
        if (u.attributeName === "class" && mF(u.target)) {
          const {
            prefix: d,
            iconName: f
          } = Mh(Pw(u.target));
          u.target.setAttribute(Dw, d || l), f && u.target.setAttribute(Tw, f);
        } else gF(u.target) && n(u.target);
    });
  }), Ko && Rp.observe(o, {
    childList: !0,
    attributes: !0,
    characterData: !0,
    subtree: !0
  });
}
function xF() {
  Rp && Rp.disconnect();
}
function SF(e) {
  const t = e.getAttribute("style");
  let n = [];
  return t && (n = t.split(";").reduce((r, o) => {
    const a = o.split(":"), l = a[0], u = a.slice(1);
    return l && u.length > 0 && (r[l] = u.join(":").trim()), r;
  }, {})), n;
}
function kF(e) {
  const t = e.getAttribute("data-prefix"), n = e.getAttribute("data-icon"), r = e.innerText !== void 0 ? e.innerText.trim() : "";
  let o = Mh(Pw(e));
  return o.prefix || (o.prefix = Ui()), t && n && (o.prefix = t, o.iconName = n), o.iconName && o.prefix || (o.prefix && r.length > 0 && (o.iconName = GU(o.prefix, e.innerText) || Bw(o.prefix, $N(e.innerText))), !o.iconName && Se.autoFetchSvg && e.firstChild && e.firstChild.nodeType === Node.TEXT_NODE && (o.iconName = e.firstChild.data)), o;
}
function _F(e) {
  const t = vs(e.attributes).reduce((o, a) => (o.name !== "class" && o.name !== "style" && (o[a.name] = a.value), o), {}), n = e.getAttribute("title"), r = e.getAttribute("data-fa-title-id");
  return Se.autoA11y && (n ? t["aria-labelledby"] = "".concat(Se.replacementClass, "-title-").concat(r || mc()) : (t["aria-hidden"] = "true", t.focusable = "false")), t;
}
function EF() {
  return {
    iconName: null,
    title: null,
    titleId: null,
    prefix: null,
    transform: eo,
    symbol: !1,
    mask: {
      iconName: null,
      prefix: null,
      rest: []
    },
    maskId: null,
    extra: {
      classes: [],
      styles: {},
      attributes: {}
    }
  };
}
function KE(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
    styleParser: !0
  };
  const {
    iconName: n,
    prefix: r,
    rest: o
  } = kF(e), a = _F(e), l = pb("parseNodeAttributes", {}, e);
  let u = t.styleParser ? SF(e) : [];
  return me({
    iconName: n,
    title: e.getAttribute("title"),
    titleId: e.getAttribute("data-fa-title-id"),
    prefix: r,
    transform: eo,
    mask: {
      iconName: null,
      prefix: null,
      rest: []
    },
    maskId: null,
    symbol: !1,
    extra: {
      classes: o,
      styles: u,
      attributes: a
    }
  }, l);
}
const {
  styles: CF
} = to;
function iM(e) {
  const t = Se.autoReplaceSvg === "nest" ? KE(e, {
    styleParser: !1
  }) : KE(e);
  return ~t.extra.classes.indexOf(IN) ? Fi("generateLayersText", e, t) : Fi("generateSvgReplacementMutation", e, t);
}
function OF() {
  return [...lU, ...ab];
}
function QE(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
  if (!Ko) return Promise.resolve();
  const n = bt.documentElement.classList, r = (p) => n.add("".concat(BE, "-").concat(p)), o = (p) => n.remove("".concat(BE, "-").concat(p)), a = Se.autoFetchSvg ? OF() : RN.concat(Object.keys(CF));
  a.includes("fa") || a.push("fa");
  const l = [".".concat(IN, ":not([").concat(Ta, "])")].concat(a.map((p) => ".".concat(p, ":not([").concat(Ta, "])"))).join(", ");
  if (l.length === 0)
    return Promise.resolve();
  let u = [];
  try {
    u = vs(e.querySelectorAll(l));
  } catch {
  }
  if (u.length > 0)
    r("pending"), o("complete");
  else
    return Promise.resolve();
  const d = Hw.begin("onTree"), f = u.reduce((p, m) => {
    try {
      const g = iM(m);
      g && p.push(g);
    } catch (g) {
      PN || g.name === "MissingIcon" && console.error(g);
    }
    return p;
  }, []);
  return new Promise((p, m) => {
    Promise.all(f).then((g) => {
      rM(g, () => {
        r("active"), r("complete"), o("pending"), typeof t == "function" && t(), d(), p();
      });
    }).catch((g) => {
      d(), m(g);
    });
  });
}
function NF(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
  iM(e).then((n) => {
    n && rM([n], t);
  });
}
function MF(e) {
  return function(t) {
    let n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    const r = (t || {}).icon ? t : hb(t || {});
    let {
      mask: o
    } = n;
    return o && (o = (o || {}).icon ? o : hb(o || {})), e(r, me(me({}, n), {}, {
      mask: o
    }));
  };
}
const AF = function(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  const {
    transform: n = eo,
    symbol: r = !1,
    mask: o = null,
    maskId: a = null,
    title: l = null,
    titleId: u = null,
    classes: d = [],
    attributes: f = {},
    styles: p = {}
  } = t;
  if (!e) return;
  const {
    prefix: m,
    iconName: g,
    icon: y
  } = e;
  return Ah(me({
    type: "icon"
  }, e), () => (za("beforeDOMElementCreation", {
    iconDefinition: e,
    params: t
  }), Se.autoA11y && (l ? f["aria-labelledby"] = "".concat(Se.replacementClass, "-title-").concat(u || mc()) : (f["aria-hidden"] = "true", f.focusable = "false")), Vw({
    icons: {
      main: mb(y),
      mask: o ? mb(o.icon) : {
        found: !1,
        width: null,
        height: null,
        icon: {}
      }
    },
    prefix: m,
    iconName: g,
    transform: me(me({}, eo), n),
    symbol: r,
    title: l,
    maskId: a,
    titleId: u,
    extra: {
      attributes: f,
      styles: p,
      classes: d
    }
  })));
};
var RF = {
  mixout() {
    return {
      icon: MF(AF)
    };
  },
  hooks() {
    return {
      mutationObserverCallbacks(e) {
        return e.treeCallback = QE, e.nodeCallback = NF, e;
      }
    };
  },
  provides(e) {
    e.i2svg = function(t) {
      const {
        node: n = bt,
        callback: r = () => {
        }
      } = t;
      return QE(n, r);
    }, e.generateSvgReplacementMutation = function(t, n) {
      const {
        iconName: r,
        title: o,
        titleId: a,
        prefix: l,
        transform: u,
        symbol: d,
        mask: f,
        maskId: p,
        extra: m
      } = n;
      return new Promise((g, y) => {
        Promise.all([gb(r, l), f.iconName ? gb(f.iconName, f.prefix) : Promise.resolve({
          found: !1,
          width: 512,
          height: 512,
          icon: {}
        })]).then((w) => {
          let [v, x] = w;
          g([t, Vw({
            icons: {
              main: v,
              mask: x
            },
            prefix: l,
            iconName: r,
            transform: u,
            symbol: d,
            maskId: p,
            title: o,
            titleId: a,
            extra: m,
            watchable: !0
          })]);
        }).catch(y);
      });
    }, e.generateAbstractIcon = function(t) {
      let {
        children: n,
        attributes: r,
        main: o,
        transform: a,
        styles: l
      } = t;
      const u = Oh(l);
      u.length > 0 && (r.style = u);
      let d;
      return Lw(a) && (d = Fi("generateAbstractTransformGrouping", {
        main: o,
        transform: a,
        containerWidth: o.width,
        iconWidth: o.width
      })), n.push(d || o.icon), {
        children: n,
        attributes: r
      };
    };
  }
}, jF = {
  mixout() {
    return {
      layer(e) {
        let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        const {
          classes: n = []
        } = t;
        return Ah({
          type: "layer"
        }, () => {
          za("beforeDOMElementCreation", {
            assembler: e,
            params: t
          });
          let r = [];
          return e((o) => {
            Array.isArray(o) ? o.map((a) => {
              r = r.concat(a.abstract);
            }) : r = r.concat(o.abstract);
          }), [{
            tag: "span",
            attributes: {
              class: ["".concat(Se.cssPrefix, "-layers"), ...n].join(" ")
            },
            children: r
          }];
        });
      }
    };
  }
}, DF = {
  mixout() {
    return {
      counter(e) {
        let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        const {
          title: n = null,
          classes: r = [],
          attributes: o = {},
          styles: a = {}
        } = t;
        return Ah({
          type: "counter",
          content: e
        }, () => (za("beforeDOMElementCreation", {
          content: e,
          params: t
        }), dF({
          content: e.toString(),
          title: n,
          extra: {
            attributes: o,
            styles: a,
            classes: ["".concat(Se.cssPrefix, "-layers-counter"), ...r]
          }
        })));
      }
    };
  }
}, TF = {
  mixout() {
    return {
      text(e) {
        let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        const {
          transform: n = eo,
          title: r = null,
          classes: o = [],
          attributes: a = {},
          styles: l = {}
        } = t;
        return Ah({
          type: "text",
          content: e
        }, () => (za("beforeDOMElementCreation", {
          content: e,
          params: t
        }), qE({
          content: e,
          transform: me(me({}, eo), n),
          title: r,
          extra: {
            attributes: a,
            styles: l,
            classes: ["".concat(Se.cssPrefix, "-layers-text"), ...o]
          }
        })));
      }
    };
  },
  provides(e) {
    e.generateLayersText = function(t, n) {
      const {
        title: r,
        transform: o,
        extra: a
      } = n;
      let l = null, u = null;
      if (MN) {
        const d = parseInt(getComputedStyle(t).fontSize, 10), f = t.getBoundingClientRect();
        l = f.width / d, u = f.height / d;
      }
      return Se.autoA11y && !r && (a.attributes["aria-hidden"] = "true"), Promise.resolve([t, qE({
        content: t.innerHTML,
        width: l,
        height: u,
        transform: o,
        title: r,
        extra: a,
        watchable: !0
      })]);
    };
  }
};
const zF = new RegExp('"', "ug"), JE = [1105920, 1112319], eC = me(me(me(me({}, {
  FontAwesome: {
    normal: "fas",
    400: "fas"
  }
}), oU), xU), hU), bb = Object.keys(eC).reduce((e, t) => (e[t.toLowerCase()] = eC[t], e), {}), PF = Object.keys(bb).reduce((e, t) => {
  const n = bb[t];
  return e[t] = n[900] || [...Object.entries(n)][0][1], e;
}, {});
function LF(e) {
  const t = e.replace(zF, ""), n = FU(t, 0), r = n >= JE[0] && n <= JE[1], o = t.length === 2 ? t[0] === t[1] : !1;
  return {
    value: $N(o ? t[0] : t),
    isSecondary: r || o
  };
}
function IF(e, t) {
  const n = e.replace(/^['"]|['"]$/g, "").toLowerCase(), r = parseInt(t), o = isNaN(r) ? "normal" : r;
  return (bb[n] || {})[o] || PF[n];
}
function tC(e, t) {
  const n = "".concat(SU).concat(t.replace(":", "-"));
  return new Promise((r, o) => {
    if (e.getAttribute(n) !== null)
      return r();
    const a = vs(e.children).filter((m) => m.getAttribute(sb) === t)[0], l = Hi.getComputedStyle(e, t), u = l.getPropertyValue("font-family"), d = u.match(OU), f = l.getPropertyValue("font-weight"), p = l.getPropertyValue("content");
    if (a && !d)
      return e.removeChild(a), r();
    if (d && p !== "none" && p !== "") {
      const m = l.getPropertyValue("content");
      let g = IF(u, f);
      const {
        value: y,
        isSecondary: w
      } = LF(m), v = d[0].startsWith("FontAwesome");
      let x = Bw(g, y), E = x;
      if (v) {
        const N = ZU(y);
        N.iconName && N.prefix && (x = N.iconName, g = N.prefix);
      }
      if (x && !w && (!a || a.getAttribute(Dw) !== g || a.getAttribute(Tw) !== E)) {
        e.setAttribute(n, E), a && e.removeChild(a);
        const N = EF(), {
          extra: C
        } = N;
        C.attributes[sb] = t, gb(x, g).then((A) => {
          const R = Vw(me(me({}, N), {}, {
            icons: {
              main: A,
              mask: JN()
            },
            prefix: g,
            iconName: E,
            extra: C,
            watchable: !0
          })), D = bt.createElementNS("http://www.w3.org/2000/svg", "svg");
          t === "::before" ? e.insertBefore(D, e.firstChild) : e.appendChild(D), D.outerHTML = R.map((T) => Vc(T)).join(`
`), e.removeAttribute(n), r();
        }).catch(o);
      } else
        r();
    } else
      r();
  });
}
function BF(e) {
  return Promise.all([tC(e, "::before"), tC(e, "::after")]);
}
function VF(e) {
  return e.parentNode !== document.head && !~_U.indexOf(e.tagName.toUpperCase()) && !e.getAttribute(sb) && (!e.parentNode || e.parentNode.tagName !== "svg");
}
function nC(e) {
  if (Ko)
    return new Promise((t, n) => {
      const r = vs(e.querySelectorAll("*")).filter(VF).map(BF), o = Hw.begin("searchPseudoElements");
      oM(), Promise.all(r).then(() => {
        o(), vb(), t();
      }).catch(() => {
        o(), vb(), n();
      });
    });
}
var HF = {
  hooks() {
    return {
      mutationObserverCallbacks(e) {
        return e.pseudoElementsCallback = nC, e;
      }
    };
  },
  provides(e) {
    e.pseudoElements2svg = function(t) {
      const {
        node: n = bt
      } = t;
      Se.searchPseudoElements && nC(n);
    };
  }
};
let rC = !1;
var UF = {
  mixout() {
    return {
      dom: {
        unwatch() {
          oM(), rC = !0;
        }
      }
    };
  },
  hooks() {
    return {
      bootstrap() {
        WE(pb("mutationObserverCallbacks", {}));
      },
      noAuto() {
        xF();
      },
      watch(e) {
        const {
          observeMutationsRoot: t
        } = e;
        rC ? vb() : WE(pb("mutationObserverCallbacks", {
          observeMutationsRoot: t
        }));
      }
    };
  }
};
const oC = (e) => {
  let t = {
    size: 16,
    x: 0,
    y: 0,
    flipX: !1,
    flipY: !1,
    rotate: 0
  };
  return e.toLowerCase().split(" ").reduce((n, r) => {
    const o = r.toLowerCase().split("-"), a = o[0];
    let l = o.slice(1).join("-");
    if (a && l === "h")
      return n.flipX = !0, n;
    if (a && l === "v")
      return n.flipY = !0, n;
    if (l = parseFloat(l), isNaN(l))
      return n;
    switch (a) {
      case "grow":
        n.size = n.size + l;
        break;
      case "shrink":
        n.size = n.size - l;
        break;
      case "left":
        n.x = n.x - l;
        break;
      case "right":
        n.x = n.x + l;
        break;
      case "up":
        n.y = n.y - l;
        break;
      case "down":
        n.y = n.y + l;
        break;
      case "rotate":
        n.rotate = n.rotate + l;
        break;
    }
    return n;
  }, t);
};
var FF = {
  mixout() {
    return {
      parse: {
        transform: (e) => oC(e)
      }
    };
  },
  hooks() {
    return {
      parseNodeAttributes(e, t) {
        const n = t.getAttribute("data-fa-transform");
        return n && (e.transform = oC(n)), e;
      }
    };
  },
  provides(e) {
    e.generateAbstractTransformGrouping = function(t) {
      let {
        main: n,
        transform: r,
        containerWidth: o,
        iconWidth: a
      } = t;
      const l = {
        transform: "translate(".concat(o / 2, " 256)")
      }, u = "translate(".concat(r.x * 32, ", ").concat(r.y * 32, ") "), d = "scale(".concat(r.size / 16 * (r.flipX ? -1 : 1), ", ").concat(r.size / 16 * (r.flipY ? -1 : 1), ") "), f = "rotate(".concat(r.rotate, " 0 0)"), p = {
        transform: "".concat(u, " ").concat(d, " ").concat(f)
      }, m = {
        transform: "translate(".concat(a / 2 * -1, " -256)")
      }, g = {
        outer: l,
        inner: p,
        path: m
      };
      return {
        tag: "g",
        attributes: me({}, g.outer),
        children: [{
          tag: "g",
          attributes: me({}, g.inner),
          children: [{
            tag: n.icon.tag,
            children: n.icon.children,
            attributes: me(me({}, n.icon.attributes), g.path)
          }]
        }]
      };
    };
  }
};
const Qy = {
  x: 0,
  y: 0,
  width: "100%",
  height: "100%"
};
function iC(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0;
  return e.attributes && (e.attributes.fill || t) && (e.attributes.fill = "black"), e;
}
function $F(e) {
  return e.tag === "g" ? e.children : [e];
}
var YF = {
  hooks() {
    return {
      parseNodeAttributes(e, t) {
        const n = t.getAttribute("data-fa-mask"), r = n ? Mh(n.split(" ").map((o) => o.trim())) : JN();
        return r.prefix || (r.prefix = Ui()), e.mask = r, e.maskId = t.getAttribute("data-fa-mask-id"), e;
      }
    };
  },
  provides(e) {
    e.generateAbstractMask = function(t) {
      let {
        children: n,
        attributes: r,
        main: o,
        mask: a,
        maskId: l,
        transform: u
      } = t;
      const {
        width: d,
        icon: f
      } = o, {
        width: p,
        icon: m
      } = a, g = LU({
        transform: u,
        containerWidth: p,
        iconWidth: d
      }), y = {
        tag: "rect",
        attributes: me(me({}, Qy), {}, {
          fill: "white"
        })
      }, w = f.children ? {
        children: f.children.map(iC)
      } : {}, v = {
        tag: "g",
        attributes: me({}, g.inner),
        children: [iC(me({
          tag: f.tag,
          attributes: me(me({}, f.attributes), g.path)
        }, w))]
      }, x = {
        tag: "g",
        attributes: me({}, g.outer),
        children: [v]
      }, E = "mask-".concat(l || mc()), N = "clip-".concat(l || mc()), C = {
        tag: "mask",
        attributes: me(me({}, Qy), {}, {
          id: E,
          maskUnits: "userSpaceOnUse",
          maskContentUnits: "userSpaceOnUse"
        }),
        children: [y, x]
      }, A = {
        tag: "defs",
        children: [{
          tag: "clipPath",
          attributes: {
            id: N
          },
          children: $F(m)
        }, C]
      };
      return n.push(A, {
        tag: "rect",
        attributes: me({
          fill: "currentColor",
          "clip-path": "url(#".concat(N, ")"),
          mask: "url(#".concat(E, ")")
        }, Qy)
      }), {
        children: n,
        attributes: r
      };
    };
  }
}, qF = {
  provides(e) {
    let t = !1;
    Hi.matchMedia && (t = Hi.matchMedia("(prefers-reduced-motion: reduce)").matches), e.missingIconAbstract = function() {
      const n = [], r = {
        fill: "currentColor"
      }, o = {
        attributeType: "XML",
        repeatCount: "indefinite",
        dur: "2s"
      };
      n.push({
        tag: "path",
        attributes: me(me({}, r), {}, {
          d: "M156.5,447.7l-12.6,29.5c-18.7-9.5-35.9-21.2-51.5-34.9l22.7-22.7C127.6,430.5,141.5,440,156.5,447.7z M40.6,272H8.5 c1.4,21.2,5.4,41.7,11.7,61.1L50,321.2C45.1,305.5,41.8,289,40.6,272z M40.6,240c1.4-18.8,5.2-37,11.1-54.1l-29.5-12.6 C14.7,194.3,10,216.7,8.5,240H40.6z M64.3,156.5c7.8-14.9,17.2-28.8,28.1-41.5L69.7,92.3c-13.7,15.6-25.5,32.8-34.9,51.5 L64.3,156.5z M397,419.6c-13.9,12-29.4,22.3-46.1,30.4l11.9,29.8c20.7-9.9,39.8-22.6,56.9-37.6L397,419.6z M115,92.4 c13.9-12,29.4-22.3,46.1-30.4l-11.9-29.8c-20.7,9.9-39.8,22.6-56.8,37.6L115,92.4z M447.7,355.5c-7.8,14.9-17.2,28.8-28.1,41.5 l22.7,22.7c13.7-15.6,25.5-32.9,34.9-51.5L447.7,355.5z M471.4,272c-1.4,18.8-5.2,37-11.1,54.1l29.5,12.6 c7.5-21.1,12.2-43.5,13.6-66.8H471.4z M321.2,462c-15.7,5-32.2,8.2-49.2,9.4v32.1c21.2-1.4,41.7-5.4,61.1-11.7L321.2,462z M240,471.4c-18.8-1.4-37-5.2-54.1-11.1l-12.6,29.5c21.1,7.5,43.5,12.2,66.8,13.6V471.4z M462,190.8c5,15.7,8.2,32.2,9.4,49.2h32.1 c-1.4-21.2-5.4-41.7-11.7-61.1L462,190.8z M92.4,397c-12-13.9-22.3-29.4-30.4-46.1l-29.8,11.9c9.9,20.7,22.6,39.8,37.6,56.9 L92.4,397z M272,40.6c18.8,1.4,36.9,5.2,54.1,11.1l12.6-29.5C317.7,14.7,295.3,10,272,8.5V40.6z M190.8,50 c15.7-5,32.2-8.2,49.2-9.4V8.5c-21.2,1.4-41.7,5.4-61.1,11.7L190.8,50z M442.3,92.3L419.6,115c12,13.9,22.3,29.4,30.5,46.1 l29.8-11.9C470,128.5,457.3,109.4,442.3,92.3z M397,92.4l22.7-22.7c-15.6-13.7-32.8-25.5-51.5-34.9l-12.6,29.5 C370.4,72.1,384.4,81.5,397,92.4z"
        })
      });
      const a = me(me({}, o), {}, {
        attributeName: "opacity"
      }), l = {
        tag: "circle",
        attributes: me(me({}, r), {}, {
          cx: "256",
          cy: "364",
          r: "28"
        }),
        children: []
      };
      return t || l.children.push({
        tag: "animate",
        attributes: me(me({}, o), {}, {
          attributeName: "r",
          values: "28;14;28;28;14;28;"
        })
      }, {
        tag: "animate",
        attributes: me(me({}, a), {}, {
          values: "1;0;1;1;0;1;"
        })
      }), n.push(l), n.push({
        tag: "path",
        attributes: me(me({}, r), {}, {
          opacity: "1",
          d: "M263.7,312h-16c-6.6,0-12-5.4-12-12c0-71,77.4-63.9,77.4-107.8c0-20-17.8-40.2-57.4-40.2c-29.1,0-44.3,9.6-59.2,28.7 c-3.9,5-11.1,6-16.2,2.4l-13.1-9.2c-5.6-3.9-6.9-11.8-2.6-17.2c21.2-27.2,46.4-44.7,91.2-44.7c52.3,0,97.4,29.8,97.4,80.2 c0,67.6-77.4,63.5-77.4,107.8C275.7,306.6,270.3,312,263.7,312z"
        }),
        children: t ? [] : [{
          tag: "animate",
          attributes: me(me({}, a), {}, {
            values: "1;0;0;0;0;1;"
          })
        }]
      }), t || n.push({
        tag: "path",
        attributes: me(me({}, r), {}, {
          opacity: "0",
          d: "M232.5,134.5l7,168c0.3,6.4,5.6,11.5,12,11.5h9c6.4,0,11.7-5.1,12-11.5l7-168c0.3-6.8-5.2-12.5-12-12.5h-23 C237.7,122,232.2,127.7,232.5,134.5z"
        }),
        children: [{
          tag: "animate",
          attributes: me(me({}, a), {}, {
            values: "0;0;1;1;0;0;"
          })
        }]
      }), {
        tag: "g",
        attributes: {
          class: "missing"
        },
        children: n
      };
    };
  }
}, XF = {
  hooks() {
    return {
      parseNodeAttributes(e, t) {
        const n = t.getAttribute("data-fa-symbol"), r = n === null ? !1 : n === "" ? !0 : n;
        return e.symbol = r, e;
      }
    };
  }
}, GF = [VU, RF, jF, DF, TF, HF, UF, FF, YF, qF, XF];
oF(GF, {
  mixoutsTo: or
});
or.noAuto;
const ZF = or.config;
or.library;
or.dom;
const wb = or.parse;
or.findIconDefinition;
or.toHtml;
const WF = or.icon;
or.layer;
or.text;
or.counter;
var Jy = { exports: {} }, aC = { exports: {} }, nt = {};
/** @license React v16.13.1
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var lC;
function KF() {
  if (lC) return nt;
  lC = 1;
  var e = typeof Symbol == "function" && Symbol.for, t = e ? Symbol.for("react.element") : 60103, n = e ? Symbol.for("react.portal") : 60106, r = e ? Symbol.for("react.fragment") : 60107, o = e ? Symbol.for("react.strict_mode") : 60108, a = e ? Symbol.for("react.profiler") : 60114, l = e ? Symbol.for("react.provider") : 60109, u = e ? Symbol.for("react.context") : 60110, d = e ? Symbol.for("react.async_mode") : 60111, f = e ? Symbol.for("react.concurrent_mode") : 60111, p = e ? Symbol.for("react.forward_ref") : 60112, m = e ? Symbol.for("react.suspense") : 60113, g = e ? Symbol.for("react.suspense_list") : 60120, y = e ? Symbol.for("react.memo") : 60115, w = e ? Symbol.for("react.lazy") : 60116, v = e ? Symbol.for("react.block") : 60121, x = e ? Symbol.for("react.fundamental") : 60117, E = e ? Symbol.for("react.responder") : 60118, N = e ? Symbol.for("react.scope") : 60119;
  function C(R) {
    if (typeof R == "object" && R !== null) {
      var D = R.$$typeof;
      switch (D) {
        case t:
          switch (R = R.type, R) {
            case d:
            case f:
            case r:
            case a:
            case o:
            case m:
              return R;
            default:
              switch (R = R && R.$$typeof, R) {
                case u:
                case p:
                case w:
                case y:
                case l:
                  return R;
                default:
                  return D;
              }
          }
        case n:
          return D;
      }
    }
  }
  function A(R) {
    return C(R) === f;
  }
  return nt.AsyncMode = d, nt.ConcurrentMode = f, nt.ContextConsumer = u, nt.ContextProvider = l, nt.Element = t, nt.ForwardRef = p, nt.Fragment = r, nt.Lazy = w, nt.Memo = y, nt.Portal = n, nt.Profiler = a, nt.StrictMode = o, nt.Suspense = m, nt.isAsyncMode = function(R) {
    return A(R) || C(R) === d;
  }, nt.isConcurrentMode = A, nt.isContextConsumer = function(R) {
    return C(R) === u;
  }, nt.isContextProvider = function(R) {
    return C(R) === l;
  }, nt.isElement = function(R) {
    return typeof R == "object" && R !== null && R.$$typeof === t;
  }, nt.isForwardRef = function(R) {
    return C(R) === p;
  }, nt.isFragment = function(R) {
    return C(R) === r;
  }, nt.isLazy = function(R) {
    return C(R) === w;
  }, nt.isMemo = function(R) {
    return C(R) === y;
  }, nt.isPortal = function(R) {
    return C(R) === n;
  }, nt.isProfiler = function(R) {
    return C(R) === a;
  }, nt.isStrictMode = function(R) {
    return C(R) === o;
  }, nt.isSuspense = function(R) {
    return C(R) === m;
  }, nt.isValidElementType = function(R) {
    return typeof R == "string" || typeof R == "function" || R === r || R === f || R === a || R === o || R === m || R === g || typeof R == "object" && R !== null && (R.$$typeof === w || R.$$typeof === y || R.$$typeof === l || R.$$typeof === u || R.$$typeof === p || R.$$typeof === x || R.$$typeof === E || R.$$typeof === N || R.$$typeof === v);
  }, nt.typeOf = C, nt;
}
var sC;
function QF() {
  return sC || (sC = 1, aC.exports = KF()), aC.exports;
}
var ev, uC;
function JF() {
  if (uC) return ev;
  uC = 1;
  var e = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
  return ev = e, ev;
}
var tv, cC;
function e$() {
  if (cC) return tv;
  cC = 1;
  var e = /* @__PURE__ */ JF();
  function t() {
  }
  function n() {
  }
  return n.resetWarningCache = t, tv = function() {
    function r(l, u, d, f, p, m) {
      if (m !== e) {
        var g = new Error(
          "Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types"
        );
        throw g.name = "Invariant Violation", g;
      }
    }
    r.isRequired = r;
    function o() {
      return r;
    }
    var a = {
      array: r,
      bigint: r,
      bool: r,
      func: r,
      number: r,
      object: r,
      string: r,
      symbol: r,
      any: r,
      arrayOf: o,
      element: r,
      elementType: r,
      instanceOf: o,
      node: r,
      objectOf: o,
      oneOf: o,
      oneOfType: o,
      shape: o,
      exact: o,
      checkPropTypes: n,
      resetWarningCache: t
    };
    return a.PropTypes = a, a;
  }, tv;
}
var dC;
function t$() {
  return dC || (dC = 1, Jy.exports = /* @__PURE__ */ e$()()), Jy.exports;
}
var Ht = /* @__PURE__ */ t$();
const Ue = /* @__PURE__ */ th(Ht);
function fC(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Wr(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? fC(Object(n), !0).forEach(function(r) {
      Yl(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : fC(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function jp(e) {
  "@babel/helpers - typeof";
  return jp = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, jp(e);
}
function Yl(e, t, n) {
  return t in e ? Object.defineProperty(e, t, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = n, e;
}
function n$(e, t) {
  if (e == null) return {};
  var n = {}, r = Object.keys(e), o, a;
  for (a = 0; a < r.length; a++)
    o = r[a], !(t.indexOf(o) >= 0) && (n[o] = e[o]);
  return n;
}
function r$(e, t) {
  if (e == null) return {};
  var n = n$(e, t), r, o;
  if (Object.getOwnPropertySymbols) {
    var a = Object.getOwnPropertySymbols(e);
    for (o = 0; o < a.length; o++)
      r = a[o], !(t.indexOf(r) >= 0) && Object.prototype.propertyIsEnumerable.call(e, r) && (n[r] = e[r]);
  }
  return n;
}
function xb(e) {
  return o$(e) || i$(e) || a$(e) || l$();
}
function o$(e) {
  if (Array.isArray(e)) return Sb(e);
}
function i$(e) {
  if (typeof Symbol < "u" && e[Symbol.iterator] != null || e["@@iterator"] != null) return Array.from(e);
}
function a$(e, t) {
  if (e) {
    if (typeof e == "string") return Sb(e, t);
    var n = Object.prototype.toString.call(e).slice(8, -1);
    if (n === "Object" && e.constructor && (n = e.constructor.name), n === "Map" || n === "Set") return Array.from(e);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return Sb(e, t);
  }
}
function Sb(e, t) {
  (t == null || t > e.length) && (t = e.length);
  for (var n = 0, r = new Array(t); n < t; n++) r[n] = e[n];
  return r;
}
function l$() {
  throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function s$(e) {
  var t, n = e.beat, r = e.fade, o = e.beatFade, a = e.bounce, l = e.shake, u = e.flash, d = e.spin, f = e.spinPulse, p = e.spinReverse, m = e.pulse, g = e.fixedWidth, y = e.inverse, w = e.border, v = e.listItem, x = e.flip, E = e.size, N = e.rotation, C = e.pull, A = (t = {
    "fa-beat": n,
    "fa-fade": r,
    "fa-beat-fade": o,
    "fa-bounce": a,
    "fa-shake": l,
    "fa-flash": u,
    "fa-spin": d,
    "fa-spin-reverse": p,
    "fa-spin-pulse": f,
    "fa-pulse": m,
    "fa-fw": g,
    "fa-inverse": y,
    "fa-border": w,
    "fa-li": v,
    "fa-flip": x === !0,
    "fa-flip-horizontal": x === "horizontal" || x === "both",
    "fa-flip-vertical": x === "vertical" || x === "both"
  }, Yl(t, "fa-".concat(E), typeof E < "u" && E !== null), Yl(t, "fa-rotate-".concat(N), typeof N < "u" && N !== null && N !== 0), Yl(t, "fa-pull-".concat(C), typeof C < "u" && C !== null), Yl(t, "fa-swap-opacity", e.swapOpacity), t);
  return Object.keys(A).map(function(R) {
    return A[R] ? R : null;
  }).filter(function(R) {
    return R;
  });
}
function u$(e) {
  return e = e - 0, e === e;
}
function aM(e) {
  return u$(e) ? e : (e = e.replace(/[\-_\s]+(.)?/g, function(t, n) {
    return n ? n.toUpperCase() : "";
  }), e.substr(0, 1).toLowerCase() + e.substr(1));
}
var c$ = ["style"];
function d$(e) {
  return e.charAt(0).toUpperCase() + e.slice(1);
}
function f$(e) {
  return e.split(";").map(function(t) {
    return t.trim();
  }).filter(function(t) {
    return t;
  }).reduce(function(t, n) {
    var r = n.indexOf(":"), o = aM(n.slice(0, r)), a = n.slice(r + 1).trim();
    return o.startsWith("webkit") ? t[d$(o)] = a : t[o] = a, t;
  }, {});
}
function lM(e, t) {
  var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  if (typeof t == "string")
    return t;
  var r = (t.children || []).map(function(d) {
    return lM(e, d);
  }), o = Object.keys(t.attributes || {}).reduce(function(d, f) {
    var p = t.attributes[f];
    switch (f) {
      case "class":
        d.attrs.className = p, delete t.attributes.class;
        break;
      case "style":
        d.attrs.style = f$(p);
        break;
      default:
        f.indexOf("aria-") === 0 || f.indexOf("data-") === 0 ? d.attrs[f.toLowerCase()] = p : d.attrs[aM(f)] = p;
    }
    return d;
  }, {
    attrs: {}
  }), a = n.style, l = a === void 0 ? {} : a, u = r$(n, c$);
  return o.attrs.style = Wr(Wr({}, o.attrs.style), l), e.apply(void 0, [t.tag, Wr(Wr({}, o.attrs), u)].concat(xb(r)));
}
var sM = !1;
try {
  sM = !0;
} catch {
}
function p$() {
  if (!sM && console && typeof console.error == "function") {
    var e;
    (e = console).error.apply(e, arguments);
  }
}
function pC(e) {
  if (e && jp(e) === "object" && e.prefix && e.iconName && e.icon)
    return e;
  if (wb.icon)
    return wb.icon(e);
  if (e === null)
    return null;
  if (e && jp(e) === "object" && e.prefix && e.iconName)
    return e;
  if (Array.isArray(e) && e.length === 2)
    return {
      prefix: e[0],
      iconName: e[1]
    };
  if (typeof e == "string")
    return {
      prefix: "fas",
      iconName: e
    };
}
function nv(e, t) {
  return Array.isArray(t) && t.length > 0 || !Array.isArray(t) && t ? Yl({}, e, t) : {};
}
var hC = {
  border: !1,
  className: "",
  mask: null,
  maskId: null,
  fixedWidth: !1,
  inverse: !1,
  flip: !1,
  icon: null,
  listItem: !1,
  pull: null,
  pulse: !1,
  rotation: null,
  size: null,
  spin: !1,
  spinPulse: !1,
  spinReverse: !1,
  beat: !1,
  fade: !1,
  beatFade: !1,
  bounce: !1,
  shake: !1,
  symbol: !1,
  title: "",
  titleId: null,
  transform: null,
  swapOpacity: !1
}, Fw = /* @__PURE__ */ $t.forwardRef(function(e, t) {
  var n = Wr(Wr({}, hC), e), r = n.icon, o = n.mask, a = n.symbol, l = n.className, u = n.title, d = n.titleId, f = n.maskId, p = pC(r), m = nv("classes", [].concat(xb(s$(n)), xb((l || "").split(" ")))), g = nv("transform", typeof n.transform == "string" ? wb.transform(n.transform) : n.transform), y = nv("mask", pC(o)), w = WF(p, Wr(Wr(Wr(Wr({}, m), g), y), {}, {
    symbol: a,
    title: u,
    titleId: d,
    maskId: f
  }));
  if (!w)
    return p$("Could not find icon", p), null;
  var v = w.abstract, x = {
    ref: t
  };
  return Object.keys(n).forEach(function(E) {
    hC.hasOwnProperty(E) || (x[E] = n[E]);
  }), h$(v[0], x);
});
Fw.displayName = "FontAwesomeIcon";
Fw.propTypes = {
  beat: Ue.bool,
  border: Ue.bool,
  beatFade: Ue.bool,
  bounce: Ue.bool,
  className: Ue.string,
  fade: Ue.bool,
  flash: Ue.bool,
  mask: Ue.oneOfType([Ue.object, Ue.array, Ue.string]),
  maskId: Ue.string,
  fixedWidth: Ue.bool,
  inverse: Ue.bool,
  flip: Ue.oneOf([!0, !1, "horizontal", "vertical", "both"]),
  icon: Ue.oneOfType([Ue.object, Ue.array, Ue.string]),
  listItem: Ue.bool,
  pull: Ue.oneOf(["right", "left"]),
  pulse: Ue.bool,
  rotation: Ue.oneOf([0, 90, 180, 270]),
  shake: Ue.bool,
  size: Ue.oneOf(["2xs", "xs", "sm", "lg", "xl", "2xl", "1x", "2x", "3x", "4x", "5x", "6x", "7x", "8x", "9x", "10x"]),
  spin: Ue.bool,
  spinPulse: Ue.bool,
  spinReverse: Ue.bool,
  symbol: Ue.oneOfType([Ue.bool, Ue.string]),
  title: Ue.string,
  titleId: Ue.string,
  transform: Ue.oneOfType([Ue.string, Ue.object]),
  swapOpacity: Ue.bool
};
var h$ = lM.bind(null, $t.createElement);
/*!
 * Font Awesome Free 6.7.2 by @fontawesome - https://fontawesome.com
 * License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License)
 * Copyright 2024 Fonticons, Inc.
 */
const m$ = {
  prefix: "fas",
  iconName: "down-left-and-up-right-to-center",
  icon: [512, 512, ["compress-alt"], "f422", "M439 7c9.4-9.4 24.6-9.4 33.9 0l32 32c9.4 9.4 9.4 24.6 0 33.9l-87 87 39 39c6.9 6.9 8.9 17.2 5.2 26.2s-12.5 14.8-22.2 14.8l-144 0c-13.3 0-24-10.7-24-24l0-144c0-9.7 5.8-18.5 14.8-22.2s19.3-1.7 26.2 5.2l39 39L439 7zM72 272l144 0c13.3 0 24 10.7 24 24l0 144c0 9.7-5.8 18.5-14.8 22.2s-19.3 1.7-26.2-5.2l-39-39L73 505c-9.4 9.4-24.6 9.4-33.9 0L7 473c-9.4-9.4-9.4-24.6 0-33.9l87-87L55 313c-6.9-6.9-8.9-17.2-5.2-26.2s12.5-14.8 22.2-14.8z"]
}, g$ = {
  prefix: "fas",
  iconName: "bars",
  icon: [448, 512, ["navicon"], "f0c9", "M0 96C0 78.3 14.3 64 32 64l384 0c17.7 0 32 14.3 32 32s-14.3 32-32 32L32 128C14.3 128 0 113.7 0 96zM0 256c0-17.7 14.3-32 32-32l384 0c17.7 0 32 14.3 32 32s-14.3 32-32 32L32 288c-17.7 0-32-14.3-32-32zM448 416c0 17.7-14.3 32-32 32L32 448c-17.7 0-32-14.3-32-32s14.3-32 32-32l384 0c17.7 0 32 14.3 32 32z"]
}, y$ = {
  prefix: "fas",
  iconName: "compress",
  icon: [448, 512, [], "f066", "M160 64c0-17.7-14.3-32-32-32s-32 14.3-32 32l0 64-64 0c-17.7 0-32 14.3-32 32s14.3 32 32 32l96 0c17.7 0 32-14.3 32-32l0-96zM32 320c-17.7 0-32 14.3-32 32s14.3 32 32 32l64 0 0 64c0 17.7 14.3 32 32 32s32-14.3 32-32l0-96c0-17.7-14.3-32-32-32l-96 0zM352 64c0-17.7-14.3-32-32-32s-32 14.3-32 32l0 96c0 17.7 14.3 32 32 32l96 0c17.7 0 32-14.3 32-32s-14.3-32-32-32l-64 0 0-64zM320 320c-17.7 0-32 14.3-32 32l0 96c0 17.7 14.3 32 32 32s32-14.3 32-32l0-64 64 0c17.7 0 32-14.3 32-32s-14.3-32-32-32l-96 0z"]
}, v$ = {
  prefix: "fas",
  iconName: "lock",
  icon: [448, 512, [128274], "f023", "M144 144l0 48 160 0 0-48c0-44.2-35.8-80-80-80s-80 35.8-80 80zM80 192l0-48C80 64.5 144.5 0 224 0s144 64.5 144 144l0 48 16 0c35.3 0 64 28.7 64 64l0 192c0 35.3-28.7 64-64 64L64 512c-35.3 0-64-28.7-64-64L0 256c0-35.3 28.7-64 64-64l16 0z"]
}, b$ = {
  prefix: "fas",
  iconName: "chevron-up",
  icon: [512, 512, [], "f077", "M233.4 105.4c12.5-12.5 32.8-12.5 45.3 0l192 192c12.5 12.5 12.5 32.8 0 45.3s-32.8 12.5-45.3 0L256 173.3 86.6 342.6c-12.5 12.5-32.8 12.5-45.3 0s-12.5-32.8 0-45.3l192-192z"]
}, w$ = {
  prefix: "fas",
  iconName: "circle-play",
  icon: [512, 512, [61469, "play-circle"], "f144", "M0 256a256 256 0 1 1 512 0A256 256 0 1 1 0 256zM188.3 147.1c-7.6 4.2-12.3 12.3-12.3 20.9l0 176c0 8.7 4.7 16.7 12.3 20.9s16.8 4.1 24.3-.5l144-88c7.1-4.4 11.5-12.1 11.5-20.5s-4.4-16.1-11.5-20.5l-144-88c-7.4-4.5-16.7-4.7-24.3-.5z"]
}, x$ = {
  prefix: "fas",
  iconName: "lock-open",
  icon: [576, 512, [], "f3c1", "M352 144c0-44.2 35.8-80 80-80s80 35.8 80 80l0 48c0 17.7 14.3 32 32 32s32-14.3 32-32l0-48C576 64.5 511.5 0 432 0S288 64.5 288 144l0 48L64 192c-35.3 0-64 28.7-64 64L0 448c0 35.3 28.7 64 64 64l320 0c35.3 0 64-28.7 64-64l0-192c0-35.3-28.7-64-64-64l-32 0 0-48z"]
}, S$ = {
  prefix: "fas",
  iconName: "network-wired",
  icon: [640, 512, [], "f6ff", "M256 64l128 0 0 64-128 0 0-64zM240 0c-26.5 0-48 21.5-48 48l0 96c0 26.5 21.5 48 48 48l48 0 0 32L32 224c-17.7 0-32 14.3-32 32s14.3 32 32 32l96 0 0 32-48 0c-26.5 0-48 21.5-48 48l0 96c0 26.5 21.5 48 48 48l160 0c26.5 0 48-21.5 48-48l0-96c0-26.5-21.5-48-48-48l-48 0 0-32 256 0 0 32-48 0c-26.5 0-48 21.5-48 48l0 96c0 26.5 21.5 48 48 48l160 0c26.5 0 48-21.5 48-48l0-96c0-26.5-21.5-48-48-48l-48 0 0-32 96 0c17.7 0 32-14.3 32-32s-14.3-32-32-32l-256 0 0-32 48 0c26.5 0 48-21.5 48-48l0-96c0-26.5-21.5-48-48-48L240 0zM96 448l0-64 128 0 0 64L96 448zm320-64l128 0 0 64-128 0 0-64z"]
}, k$ = {
  prefix: "fas",
  iconName: "magnifying-glass",
  icon: [512, 512, [128269, "search"], "f002", "M416 208c0 45.9-14.9 88.3-40 122.7L502.6 457.4c12.5 12.5 12.5 32.8 0 45.3s-32.8 12.5-45.3 0L330.7 376c-34.4 25.2-76.8 40-122.7 40C93.1 416 0 322.9 0 208S93.1 0 208 0S416 93.1 416 208zM208 352a144 144 0 1 0 0-288 144 144 0 1 0 0 288z"]
}, _$ = {
  prefix: "fas",
  iconName: "chevron-down",
  icon: [512, 512, [], "f078", "M233.4 406.6c12.5 12.5 32.8 12.5 45.3 0l192-192c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0L256 338.7 86.6 169.4c-12.5-12.5-32.8-12.5-45.3 0s-12.5 32.8 0 45.3l192 192z"]
}, E$ = {
  prefix: "fas",
  iconName: "expand",
  icon: [448, 512, [], "f065", "M32 32C14.3 32 0 46.3 0 64l0 96c0 17.7 14.3 32 32 32s32-14.3 32-32l0-64 64 0c17.7 0 32-14.3 32-32s-14.3-32-32-32L32 32zM64 352c0-17.7-14.3-32-32-32s-32 14.3-32 32l0 96c0 17.7 14.3 32 32 32l96 0c17.7 0 32-14.3 32-32s-14.3-32-32-32l-64 0 0-64zM320 32c-17.7 0-32 14.3-32 32s14.3 32 32 32l64 0 0 64c0 17.7 14.3 32 32 32s32-14.3 32-32l0-96c0-17.7-14.3-32-32-32l-96 0zM448 352c0-17.7-14.3-32-32-32s-32 14.3-32 32l0 64-64 0c-17.7 0-32 14.3-32 32s14.3 32 32 32l96 0c17.7 0 32-14.3 32-32l0-96z"]
}, C$ = {
  prefix: "fas",
  iconName: "xmark",
  icon: [384, 512, [128473, 10005, 10006, 10060, 215, "close", "multiply", "remove", "times"], "f00d", "M342.6 150.6c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0L192 210.7 86.6 105.4c-12.5-12.5-32.8-12.5-45.3 0s-12.5 32.8 0 45.3L146.7 256 41.4 361.4c-12.5 12.5-12.5 32.8 0 45.3s32.8 12.5 45.3 0L192 301.3 297.4 406.6c12.5 12.5 32.8 12.5 45.3 0s12.5-32.8 0-45.3L237.3 256 342.6 150.6z"]
}, O$ = {
  prefix: "fas",
  iconName: "chevron-left",
  icon: [320, 512, [9001], "f053", "M9.4 233.4c-12.5 12.5-12.5 32.8 0 45.3l192 192c12.5 12.5 32.8 12.5 45.3 0s12.5-32.8 0-45.3L77.3 256 246.6 86.6c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0l-192 192z"]
}, N$ = {
  prefix: "fas",
  iconName: "chevron-right",
  icon: [320, 512, [9002], "f054", "M310.6 233.4c12.5 12.5 12.5 32.8 0 45.3l-192 192c-12.5 12.5-32.8 12.5-45.3 0s-12.5-32.8 0-45.3L242.7 256 73.4 86.6c-12.5-12.5-12.5-32.8 0-45.3s32.8-12.5 45.3 0l192 192z"]
}, M$ = {
  prefix: "fas",
  iconName: "up-right-and-down-left-from-center",
  icon: [512, 512, ["expand-alt"], "f424", "M344 0L488 0c13.3 0 24 10.7 24 24l0 144c0 9.7-5.8 18.5-14.8 22.2s-19.3 1.7-26.2-5.2l-39-39-87 87c-9.4 9.4-24.6 9.4-33.9 0l-32-32c-9.4-9.4-9.4-24.6 0-33.9l87-87L327 41c-6.9-6.9-8.9-17.2-5.2-26.2S334.3 0 344 0zM168 512L24 512c-13.3 0-24-10.7-24-24L0 344c0-9.7 5.8-18.5 14.8-22.2s19.3-1.7 26.2 5.2l39 39 87-87c9.4-9.4 24.6-9.4 33.9 0l32 32c9.4 9.4 9.4 24.6 0 33.9l-87 87 39 39c6.9 6.9 8.9 17.2 5.2 26.2s-12.5 14.8-22.2 14.8z"]
};
ZF.autoAddCss = !1;
const kn = (e) => {
  const { style: t, ...n } = e;
  return /* @__PURE__ */ k.jsx("span", { style: { marginLeft: "5px", ...t }, children: /* @__PURE__ */ k.jsx(Fw, { ...n }) });
}, uM = (e) => /* @__PURE__ */ k.jsx(kn, { ...e, icon: g$ }), kb = (e) => /* @__PURE__ */ k.jsx(kn, { ...e, icon: N$ }), mC = (e) => /* @__PURE__ */ k.jsx(kn, { ...e, icon: O$ }), cM = (e) => /* @__PURE__ */ k.jsx(kn, { ...e, icon: E$ }), A$ = (e) => /* @__PURE__ */ k.jsx(kn, { ...e, icon: y$ }), R$ = (e) => /* @__PURE__ */ k.jsx(kn, { ...e, icon: m$ }), j$ = (e) => /* @__PURE__ */ k.jsx(kn, { ...e, icon: M$ }), gC = (e) => /* @__PURE__ */ k.jsx(kn, { ...e, icon: _$ }), _b = (e) => /* @__PURE__ */ k.jsx(kn, { ...e, icon: b$ }), Hc = _b, dM = (e) => /* @__PURE__ */ k.jsx(kn, { ...e, icon: C$ }), D$ = (e) => /* @__PURE__ */ k.jsx(kn, { ...e, icon: x$ }), T$ = (e) => /* @__PURE__ */ k.jsx(kn, { ...e, icon: v$ }), z$ = (e) => /* @__PURE__ */ k.jsx(kn, { ...e, icon: S$ }), P$ = (e) => /* @__PURE__ */ k.jsx(kn, { ...e, icon: w$ }), L$ = (e) => /* @__PURE__ */ k.jsx(kn, { ...e, icon: k$ }), bs = ({
  trigger: e,
  title: t,
  description: n,
  children: r,
  closebutton: o = !0,
  onOpenChange: a,
  buttons: l = [],
  open: u,
  setOpen: d,
  modal: f = !0
}) => {
  const p = (y) => {
    d && d(y), a && a(y);
  }, m = _.useContext(Ge).local_state((y) => y.funcnodescontainerRef), g = /* @__PURE__ */ k.jsx(qH, { asChild: !0, children: /* @__PURE__ */ k.jsxs("div", { className: "dialogconent funcnodescontainer", children: [
    t && /* @__PURE__ */ k.jsx(XH, { className: "dialogtitle", children: t }),
    /* @__PURE__ */ k.jsx(GH, { className: "dialogdescription", children: n }),
    /* @__PURE__ */ k.jsx("div", { className: "dialogchildren", children: r }),
    /* @__PURE__ */ k.jsx(
      "div",
      {
        style: {
          display: "flex",
          marginTop: 25,
          justifyContent: "flex-end"
        },
        children: (l || []).map((y, w) => /* @__PURE__ */ k.jsx(jE, { asChild: !0, children: /* @__PURE__ */ k.jsx("button", { className: "dialogsendbutton", onClick: y.onClick, children: y.text }) }, w))
      }
    ),
    o && /* @__PURE__ */ k.jsx(jE, { asChild: !0, children: /* @__PURE__ */ k.jsx("button", { className: "dialogclosebutton", "aria-label": "Close", children: /* @__PURE__ */ k.jsx(dM, {}) }) })
  ] }) });
  return /* @__PURE__ */ k.jsxs(UH, { open: u, onOpenChange: p, modal: f, children: [
    e && /* @__PURE__ */ k.jsx(FH, { asChild: !0, children: e }),
    /* @__PURE__ */ k.jsxs($H, { container: m, children: [
      /* @__PURE__ */ k.jsx(YH, { className: "dialogoverlay funcnodescontainer" }),
      g
    ] })
  ] });
};
function $w(e) {
  const t = e + "CollectionProvider", [n, r] = Gi(t), [o, a] = n(
    t,
    { collectionRef: { current: null }, itemMap: /* @__PURE__ */ new Map() }
  ), l = (v) => {
    const { scope: x, children: E } = v, N = $t.useRef(null), C = $t.useRef(/* @__PURE__ */ new Map()).current;
    return /* @__PURE__ */ k.jsx(o, { scope: x, itemMap: C, collectionRef: N, children: E });
  };
  l.displayName = t;
  const u = e + "CollectionSlot", d = /* @__PURE__ */ ss(u), f = $t.forwardRef(
    (v, x) => {
      const { scope: E, children: N } = v, C = a(u, E), A = kt(x, C.collectionRef);
      return /* @__PURE__ */ k.jsx(d, { ref: A, children: N });
    }
  );
  f.displayName = u;
  const p = e + "CollectionItemSlot", m = "data-radix-collection-item", g = /* @__PURE__ */ ss(p), y = $t.forwardRef(
    (v, x) => {
      const { scope: E, children: N, ...C } = v, A = $t.useRef(null), R = kt(x, A), D = a(p, E);
      return $t.useEffect(() => (D.itemMap.set(A, { ref: A, ...C }), () => void D.itemMap.delete(A))), /* @__PURE__ */ k.jsx(g, { [m]: "", ref: R, children: N });
    }
  );
  y.displayName = p;
  function w(v) {
    const x = a(e + "CollectionConsumer", v);
    return $t.useCallback(() => {
      const E = x.collectionRef.current;
      if (!E) return [];
      const N = Array.from(E.querySelectorAll(`[${m}]`));
      return Array.from(x.itemMap.values()).sort(
        (C, A) => N.indexOf(C.ref.current) - N.indexOf(A.ref.current)
      );
    }, [x.collectionRef, x.itemMap]);
  }
  return [
    { Provider: l, Slot: f, ItemSlot: y },
    w,
    r
  ];
}
var I$ = _.createContext(void 0);
function Yw(e) {
  const t = _.useContext(I$);
  return e || t || "ltr";
}
const B$ = ["top", "right", "bottom", "left"], $i = Math.min, Zn = Math.max, Dp = Math.round, zf = Math.floor, ro = (e) => ({
  x: e,
  y: e
}), V$ = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
}, H$ = {
  start: "end",
  end: "start"
};
function Eb(e, t, n) {
  return Zn(e, $i(t, n));
}
function qo(e, t) {
  return typeof e == "function" ? e(t) : e;
}
function Xo(e) {
  return e.split("-")[0];
}
function ws(e) {
  return e.split("-")[1];
}
function qw(e) {
  return e === "x" ? "y" : "x";
}
function Xw(e) {
  return e === "y" ? "height" : "width";
}
function Yi(e) {
  return ["top", "bottom"].includes(Xo(e)) ? "y" : "x";
}
function Gw(e) {
  return qw(Yi(e));
}
function U$(e, t, n) {
  n === void 0 && (n = !1);
  const r = ws(e), o = Gw(e), a = Xw(o);
  let l = o === "x" ? r === (n ? "end" : "start") ? "right" : "left" : r === "start" ? "bottom" : "top";
  return t.reference[a] > t.floating[a] && (l = Tp(l)), [l, Tp(l)];
}
function F$(e) {
  const t = Tp(e);
  return [Cb(e), t, Cb(t)];
}
function Cb(e) {
  return e.replace(/start|end/g, (t) => H$[t]);
}
function $$(e, t, n) {
  const r = ["left", "right"], o = ["right", "left"], a = ["top", "bottom"], l = ["bottom", "top"];
  switch (e) {
    case "top":
    case "bottom":
      return n ? t ? o : r : t ? r : o;
    case "left":
    case "right":
      return t ? a : l;
    default:
      return [];
  }
}
function Y$(e, t, n, r) {
  const o = ws(e);
  let a = $$(Xo(e), n === "start", r);
  return o && (a = a.map((l) => l + "-" + o), t && (a = a.concat(a.map(Cb)))), a;
}
function Tp(e) {
  return e.replace(/left|right|bottom|top/g, (t) => V$[t]);
}
function q$(e) {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    ...e
  };
}
function fM(e) {
  return typeof e != "number" ? q$(e) : {
    top: e,
    right: e,
    bottom: e,
    left: e
  };
}
function zp(e) {
  const {
    x: t,
    y: n,
    width: r,
    height: o
  } = e;
  return {
    width: r,
    height: o,
    top: n,
    left: t,
    right: t + r,
    bottom: n + o,
    x: t,
    y: n
  };
}
function yC(e, t, n) {
  let {
    reference: r,
    floating: o
  } = e;
  const a = Yi(t), l = Gw(t), u = Xw(l), d = Xo(t), f = a === "y", p = r.x + r.width / 2 - o.width / 2, m = r.y + r.height / 2 - o.height / 2, g = r[u] / 2 - o[u] / 2;
  let y;
  switch (d) {
    case "top":
      y = {
        x: p,
        y: r.y - o.height
      };
      break;
    case "bottom":
      y = {
        x: p,
        y: r.y + r.height
      };
      break;
    case "right":
      y = {
        x: r.x + r.width,
        y: m
      };
      break;
    case "left":
      y = {
        x: r.x - o.width,
        y: m
      };
      break;
    default:
      y = {
        x: r.x,
        y: r.y
      };
  }
  switch (ws(t)) {
    case "start":
      y[l] -= g * (n && f ? -1 : 1);
      break;
    case "end":
      y[l] += g * (n && f ? -1 : 1);
      break;
  }
  return y;
}
const X$ = async (e, t, n) => {
  const {
    placement: r = "bottom",
    strategy: o = "absolute",
    middleware: a = [],
    platform: l
  } = n, u = a.filter(Boolean), d = await (l.isRTL == null ? void 0 : l.isRTL(t));
  let f = await l.getElementRects({
    reference: e,
    floating: t,
    strategy: o
  }), {
    x: p,
    y: m
  } = yC(f, r, d), g = r, y = {}, w = 0;
  for (let v = 0; v < u.length; v++) {
    const {
      name: x,
      fn: E
    } = u[v], {
      x: N,
      y: C,
      data: A,
      reset: R
    } = await E({
      x: p,
      y: m,
      initialPlacement: r,
      placement: g,
      strategy: o,
      middlewareData: y,
      rects: f,
      platform: l,
      elements: {
        reference: e,
        floating: t
      }
    });
    p = N ?? p, m = C ?? m, y = {
      ...y,
      [x]: {
        ...y[x],
        ...A
      }
    }, R && w <= 50 && (w++, typeof R == "object" && (R.placement && (g = R.placement), R.rects && (f = R.rects === !0 ? await l.getElementRects({
      reference: e,
      floating: t,
      strategy: o
    }) : R.rects), {
      x: p,
      y: m
    } = yC(f, g, d)), v = -1);
  }
  return {
    x: p,
    y: m,
    placement: g,
    strategy: o,
    middlewareData: y
  };
};
async function yc(e, t) {
  var n;
  t === void 0 && (t = {});
  const {
    x: r,
    y: o,
    platform: a,
    rects: l,
    elements: u,
    strategy: d
  } = e, {
    boundary: f = "clippingAncestors",
    rootBoundary: p = "viewport",
    elementContext: m = "floating",
    altBoundary: g = !1,
    padding: y = 0
  } = qo(t, e), w = fM(y), v = u[g ? m === "floating" ? "reference" : "floating" : m], x = zp(await a.getClippingRect({
    element: (n = await (a.isElement == null ? void 0 : a.isElement(v))) == null || n ? v : v.contextElement || await (a.getDocumentElement == null ? void 0 : a.getDocumentElement(u.floating)),
    boundary: f,
    rootBoundary: p,
    strategy: d
  })), E = m === "floating" ? {
    x: r,
    y: o,
    width: l.floating.width,
    height: l.floating.height
  } : l.reference, N = await (a.getOffsetParent == null ? void 0 : a.getOffsetParent(u.floating)), C = await (a.isElement == null ? void 0 : a.isElement(N)) ? await (a.getScale == null ? void 0 : a.getScale(N)) || {
    x: 1,
    y: 1
  } : {
    x: 1,
    y: 1
  }, A = zp(a.convertOffsetParentRelativeRectToViewportRelativeRect ? await a.convertOffsetParentRelativeRectToViewportRelativeRect({
    elements: u,
    rect: E,
    offsetParent: N,
    strategy: d
  }) : E);
  return {
    top: (x.top - A.top + w.top) / C.y,
    bottom: (A.bottom - x.bottom + w.bottom) / C.y,
    left: (x.left - A.left + w.left) / C.x,
    right: (A.right - x.right + w.right) / C.x
  };
}
const G$ = (e) => ({
  name: "arrow",
  options: e,
  async fn(t) {
    const {
      x: n,
      y: r,
      placement: o,
      rects: a,
      platform: l,
      elements: u,
      middlewareData: d
    } = t, {
      element: f,
      padding: p = 0
    } = qo(e, t) || {};
    if (f == null)
      return {};
    const m = fM(p), g = {
      x: n,
      y: r
    }, y = Gw(o), w = Xw(y), v = await l.getDimensions(f), x = y === "y", E = x ? "top" : "left", N = x ? "bottom" : "right", C = x ? "clientHeight" : "clientWidth", A = a.reference[w] + a.reference[y] - g[y] - a.floating[w], R = g[y] - a.reference[y], D = await (l.getOffsetParent == null ? void 0 : l.getOffsetParent(f));
    let T = D ? D[C] : 0;
    (!T || !await (l.isElement == null ? void 0 : l.isElement(D))) && (T = u.floating[C] || a.floating[w]);
    const V = A / 2 - R / 2, F = T / 2 - v[w] / 2 - 1, O = $i(m[E], F), B = $i(m[N], F), U = O, G = T - v[w] - B, z = T / 2 - v[w] / 2 + V, $ = Eb(U, z, G), L = !d.arrow && ws(o) != null && z !== $ && a.reference[w] / 2 - (z < U ? O : B) - v[w] / 2 < 0, H = L ? z < U ? z - U : z - G : 0;
    return {
      [y]: g[y] + H,
      data: {
        [y]: $,
        centerOffset: z - $ - H,
        ...L && {
          alignmentOffset: H
        }
      },
      reset: L
    };
  }
}), Z$ = function(e) {
  return e === void 0 && (e = {}), {
    name: "flip",
    options: e,
    async fn(t) {
      var n, r;
      const {
        placement: o,
        middlewareData: a,
        rects: l,
        initialPlacement: u,
        platform: d,
        elements: f
      } = t, {
        mainAxis: p = !0,
        crossAxis: m = !0,
        fallbackPlacements: g,
        fallbackStrategy: y = "bestFit",
        fallbackAxisSideDirection: w = "none",
        flipAlignment: v = !0,
        ...x
      } = qo(e, t);
      if ((n = a.arrow) != null && n.alignmentOffset)
        return {};
      const E = Xo(o), N = Yi(u), C = Xo(u) === u, A = await (d.isRTL == null ? void 0 : d.isRTL(f.floating)), R = g || (C || !v ? [Tp(u)] : F$(u)), D = w !== "none";
      !g && D && R.push(...Y$(u, v, w, A));
      const T = [u, ...R], V = await yc(t, x), F = [];
      let O = ((r = a.flip) == null ? void 0 : r.overflows) || [];
      if (p && F.push(V[E]), m) {
        const z = U$(o, l, A);
        F.push(V[z[0]], V[z[1]]);
      }
      if (O = [...O, {
        placement: o,
        overflows: F
      }], !F.every((z) => z <= 0)) {
        var B, U;
        const z = (((B = a.flip) == null ? void 0 : B.index) || 0) + 1, $ = T[z];
        if ($)
          return {
            data: {
              index: z,
              overflows: O
            },
            reset: {
              placement: $
            }
          };
        let L = (U = O.filter((H) => H.overflows[0] <= 0).sort((H, q) => H.overflows[1] - q.overflows[1])[0]) == null ? void 0 : U.placement;
        if (!L)
          switch (y) {
            case "bestFit": {
              var G;
              const H = (G = O.filter((q) => {
                if (D) {
                  const Y = Yi(q.placement);
                  return Y === N || // Create a bias to the `y` side axis due to horizontal
                  // reading directions favoring greater width.
                  Y === "y";
                }
                return !0;
              }).map((q) => [q.placement, q.overflows.filter((Y) => Y > 0).reduce((Y, M) => Y + M, 0)]).sort((q, Y) => q[1] - Y[1])[0]) == null ? void 0 : G[0];
              H && (L = H);
              break;
            }
            case "initialPlacement":
              L = u;
              break;
          }
        if (o !== L)
          return {
            reset: {
              placement: L
            }
          };
      }
      return {};
    }
  };
};
function vC(e, t) {
  return {
    top: e.top - t.height,
    right: e.right - t.width,
    bottom: e.bottom - t.height,
    left: e.left - t.width
  };
}
function bC(e) {
  return B$.some((t) => e[t] >= 0);
}
const W$ = function(e) {
  return e === void 0 && (e = {}), {
    name: "hide",
    options: e,
    async fn(t) {
      const {
        rects: n
      } = t, {
        strategy: r = "referenceHidden",
        ...o
      } = qo(e, t);
      switch (r) {
        case "referenceHidden": {
          const a = await yc(t, {
            ...o,
            elementContext: "reference"
          }), l = vC(a, n.reference);
          return {
            data: {
              referenceHiddenOffsets: l,
              referenceHidden: bC(l)
            }
          };
        }
        case "escaped": {
          const a = await yc(t, {
            ...o,
            altBoundary: !0
          }), l = vC(a, n.floating);
          return {
            data: {
              escapedOffsets: l,
              escaped: bC(l)
            }
          };
        }
        default:
          return {};
      }
    }
  };
};
async function K$(e, t) {
  const {
    placement: n,
    platform: r,
    elements: o
  } = e, a = await (r.isRTL == null ? void 0 : r.isRTL(o.floating)), l = Xo(n), u = ws(n), d = Yi(n) === "y", f = ["left", "top"].includes(l) ? -1 : 1, p = a && d ? -1 : 1, m = qo(t, e);
  let {
    mainAxis: g,
    crossAxis: y,
    alignmentAxis: w
  } = typeof m == "number" ? {
    mainAxis: m,
    crossAxis: 0,
    alignmentAxis: null
  } : {
    mainAxis: m.mainAxis || 0,
    crossAxis: m.crossAxis || 0,
    alignmentAxis: m.alignmentAxis
  };
  return u && typeof w == "number" && (y = u === "end" ? w * -1 : w), d ? {
    x: y * p,
    y: g * f
  } : {
    x: g * f,
    y: y * p
  };
}
const Q$ = function(e) {
  return e === void 0 && (e = 0), {
    name: "offset",
    options: e,
    async fn(t) {
      var n, r;
      const {
        x: o,
        y: a,
        placement: l,
        middlewareData: u
      } = t, d = await K$(t, e);
      return l === ((n = u.offset) == null ? void 0 : n.placement) && (r = u.arrow) != null && r.alignmentOffset ? {} : {
        x: o + d.x,
        y: a + d.y,
        data: {
          ...d,
          placement: l
        }
      };
    }
  };
}, J$ = function(e) {
  return e === void 0 && (e = {}), {
    name: "shift",
    options: e,
    async fn(t) {
      const {
        x: n,
        y: r,
        placement: o
      } = t, {
        mainAxis: a = !0,
        crossAxis: l = !1,
        limiter: u = {
          fn: (x) => {
            let {
              x: E,
              y: N
            } = x;
            return {
              x: E,
              y: N
            };
          }
        },
        ...d
      } = qo(e, t), f = {
        x: n,
        y: r
      }, p = await yc(t, d), m = Yi(Xo(o)), g = qw(m);
      let y = f[g], w = f[m];
      if (a) {
        const x = g === "y" ? "top" : "left", E = g === "y" ? "bottom" : "right", N = y + p[x], C = y - p[E];
        y = Eb(N, y, C);
      }
      if (l) {
        const x = m === "y" ? "top" : "left", E = m === "y" ? "bottom" : "right", N = w + p[x], C = w - p[E];
        w = Eb(N, w, C);
      }
      const v = u.fn({
        ...t,
        [g]: y,
        [m]: w
      });
      return {
        ...v,
        data: {
          x: v.x - n,
          y: v.y - r,
          enabled: {
            [g]: a,
            [m]: l
          }
        }
      };
    }
  };
}, eY = function(e) {
  return e === void 0 && (e = {}), {
    options: e,
    fn(t) {
      const {
        x: n,
        y: r,
        placement: o,
        rects: a,
        middlewareData: l
      } = t, {
        offset: u = 0,
        mainAxis: d = !0,
        crossAxis: f = !0
      } = qo(e, t), p = {
        x: n,
        y: r
      }, m = Yi(o), g = qw(m);
      let y = p[g], w = p[m];
      const v = qo(u, t), x = typeof v == "number" ? {
        mainAxis: v,
        crossAxis: 0
      } : {
        mainAxis: 0,
        crossAxis: 0,
        ...v
      };
      if (d) {
        const C = g === "y" ? "height" : "width", A = a.reference[g] - a.floating[C] + x.mainAxis, R = a.reference[g] + a.reference[C] - x.mainAxis;
        y < A ? y = A : y > R && (y = R);
      }
      if (f) {
        var E, N;
        const C = g === "y" ? "width" : "height", A = ["top", "left"].includes(Xo(o)), R = a.reference[m] - a.floating[C] + (A && ((E = l.offset) == null ? void 0 : E[m]) || 0) + (A ? 0 : x.crossAxis), D = a.reference[m] + a.reference[C] + (A ? 0 : ((N = l.offset) == null ? void 0 : N[m]) || 0) - (A ? x.crossAxis : 0);
        w < R ? w = R : w > D && (w = D);
      }
      return {
        [g]: y,
        [m]: w
      };
    }
  };
}, tY = function(e) {
  return e === void 0 && (e = {}), {
    name: "size",
    options: e,
    async fn(t) {
      var n, r;
      const {
        placement: o,
        rects: a,
        platform: l,
        elements: u
      } = t, {
        apply: d = () => {
        },
        ...f
      } = qo(e, t), p = await yc(t, f), m = Xo(o), g = ws(o), y = Yi(o) === "y", {
        width: w,
        height: v
      } = a.floating;
      let x, E;
      m === "top" || m === "bottom" ? (x = m, E = g === (await (l.isRTL == null ? void 0 : l.isRTL(u.floating)) ? "start" : "end") ? "left" : "right") : (E = m, x = g === "end" ? "top" : "bottom");
      const N = v - p.top - p.bottom, C = w - p.left - p.right, A = $i(v - p[x], N), R = $i(w - p[E], C), D = !t.middlewareData.shift;
      let T = A, V = R;
      if ((n = t.middlewareData.shift) != null && n.enabled.x && (V = C), (r = t.middlewareData.shift) != null && r.enabled.y && (T = N), D && !g) {
        const O = Zn(p.left, 0), B = Zn(p.right, 0), U = Zn(p.top, 0), G = Zn(p.bottom, 0);
        y ? V = w - 2 * (O !== 0 || B !== 0 ? O + B : Zn(p.left, p.right)) : T = v - 2 * (U !== 0 || G !== 0 ? U + G : Zn(p.top, p.bottom));
      }
      await d({
        ...t,
        availableWidth: V,
        availableHeight: T
      });
      const F = await l.getDimensions(u.floating);
      return w !== F.width || v !== F.height ? {
        reset: {
          rects: !0
        }
      } : {};
    }
  };
};
function Rh() {
  return typeof window < "u";
}
function xs(e) {
  return pM(e) ? (e.nodeName || "").toLowerCase() : "#document";
}
function Jn(e) {
  var t;
  return (e == null || (t = e.ownerDocument) == null ? void 0 : t.defaultView) || window;
}
function so(e) {
  var t;
  return (t = (pM(e) ? e.ownerDocument : e.document) || window.document) == null ? void 0 : t.documentElement;
}
function pM(e) {
  return Rh() ? e instanceof Node || e instanceof Jn(e).Node : !1;
}
function jr(e) {
  return Rh() ? e instanceof Element || e instanceof Jn(e).Element : !1;
}
function ao(e) {
  return Rh() ? e instanceof HTMLElement || e instanceof Jn(e).HTMLElement : !1;
}
function wC(e) {
  return !Rh() || typeof ShadowRoot > "u" ? !1 : e instanceof ShadowRoot || e instanceof Jn(e).ShadowRoot;
}
function Uc(e) {
  const {
    overflow: t,
    overflowX: n,
    overflowY: r,
    display: o
  } = Dr(e);
  return /auto|scroll|overlay|hidden|clip/.test(t + r + n) && !["inline", "contents"].includes(o);
}
function nY(e) {
  return ["table", "td", "th"].includes(xs(e));
}
function jh(e) {
  return [":popover-open", ":modal"].some((t) => {
    try {
      return e.matches(t);
    } catch {
      return !1;
    }
  });
}
function Zw(e) {
  const t = Ww(), n = jr(e) ? Dr(e) : e;
  return ["transform", "translate", "scale", "rotate", "perspective"].some((r) => n[r] ? n[r] !== "none" : !1) || (n.containerType ? n.containerType !== "normal" : !1) || !t && (n.backdropFilter ? n.backdropFilter !== "none" : !1) || !t && (n.filter ? n.filter !== "none" : !1) || ["transform", "translate", "scale", "rotate", "perspective", "filter"].some((r) => (n.willChange || "").includes(r)) || ["paint", "layout", "strict", "content"].some((r) => (n.contain || "").includes(r));
}
function rY(e) {
  let t = qi(e);
  for (; ao(t) && !cs(t); ) {
    if (Zw(t))
      return t;
    if (jh(t))
      return null;
    t = qi(t);
  }
  return null;
}
function Ww() {
  return typeof CSS > "u" || !CSS.supports ? !1 : CSS.supports("-webkit-backdrop-filter", "none");
}
function cs(e) {
  return ["html", "body", "#document"].includes(xs(e));
}
function Dr(e) {
  return Jn(e).getComputedStyle(e);
}
function Dh(e) {
  return jr(e) ? {
    scrollLeft: e.scrollLeft,
    scrollTop: e.scrollTop
  } : {
    scrollLeft: e.scrollX,
    scrollTop: e.scrollY
  };
}
function qi(e) {
  if (xs(e) === "html")
    return e;
  const t = (
    // Step into the shadow DOM of the parent of a slotted node.
    e.assignedSlot || // DOM Element detected.
    e.parentNode || // ShadowRoot detected.
    wC(e) && e.host || // Fallback.
    so(e)
  );
  return wC(t) ? t.host : t;
}
function hM(e) {
  const t = qi(e);
  return cs(t) ? e.ownerDocument ? e.ownerDocument.body : e.body : ao(t) && Uc(t) ? t : hM(t);
}
function vc(e, t, n) {
  var r;
  t === void 0 && (t = []), n === void 0 && (n = !0);
  const o = hM(e), a = o === ((r = e.ownerDocument) == null ? void 0 : r.body), l = Jn(o);
  if (a) {
    const u = Ob(l);
    return t.concat(l, l.visualViewport || [], Uc(o) ? o : [], u && n ? vc(u) : []);
  }
  return t.concat(o, vc(o, [], n));
}
function Ob(e) {
  return e.parent && Object.getPrototypeOf(e.parent) ? e.frameElement : null;
}
function mM(e) {
  const t = Dr(e);
  let n = parseFloat(t.width) || 0, r = parseFloat(t.height) || 0;
  const o = ao(e), a = o ? e.offsetWidth : n, l = o ? e.offsetHeight : r, u = Dp(n) !== a || Dp(r) !== l;
  return u && (n = a, r = l), {
    width: n,
    height: r,
    $: u
  };
}
function Kw(e) {
  return jr(e) ? e : e.contextElement;
}
function Wl(e) {
  const t = Kw(e);
  if (!ao(t))
    return ro(1);
  const n = t.getBoundingClientRect(), {
    width: r,
    height: o,
    $: a
  } = mM(t);
  let l = (a ? Dp(n.width) : n.width) / r, u = (a ? Dp(n.height) : n.height) / o;
  return (!l || !Number.isFinite(l)) && (l = 1), (!u || !Number.isFinite(u)) && (u = 1), {
    x: l,
    y: u
  };
}
const oY = /* @__PURE__ */ ro(0);
function gM(e) {
  const t = Jn(e);
  return !Ww() || !t.visualViewport ? oY : {
    x: t.visualViewport.offsetLeft,
    y: t.visualViewport.offsetTop
  };
}
function iY(e, t, n) {
  return t === void 0 && (t = !1), !n || t && n !== Jn(e) ? !1 : t;
}
function Pa(e, t, n, r) {
  t === void 0 && (t = !1), n === void 0 && (n = !1);
  const o = e.getBoundingClientRect(), a = Kw(e);
  let l = ro(1);
  t && (r ? jr(r) && (l = Wl(r)) : l = Wl(e));
  const u = iY(a, n, r) ? gM(a) : ro(0);
  let d = (o.left + u.x) / l.x, f = (o.top + u.y) / l.y, p = o.width / l.x, m = o.height / l.y;
  if (a) {
    const g = Jn(a), y = r && jr(r) ? Jn(r) : r;
    let w = g, v = Ob(w);
    for (; v && r && y !== w; ) {
      const x = Wl(v), E = v.getBoundingClientRect(), N = Dr(v), C = E.left + (v.clientLeft + parseFloat(N.paddingLeft)) * x.x, A = E.top + (v.clientTop + parseFloat(N.paddingTop)) * x.y;
      d *= x.x, f *= x.y, p *= x.x, m *= x.y, d += C, f += A, w = Jn(v), v = Ob(w);
    }
  }
  return zp({
    width: p,
    height: m,
    x: d,
    y: f
  });
}
function Qw(e, t) {
  const n = Dh(e).scrollLeft;
  return t ? t.left + n : Pa(so(e)).left + n;
}
function yM(e, t, n) {
  n === void 0 && (n = !1);
  const r = e.getBoundingClientRect(), o = r.left + t.scrollLeft - (n ? 0 : (
    // RTL <body> scrollbar.
    Qw(e, r)
  )), a = r.top + t.scrollTop;
  return {
    x: o,
    y: a
  };
}
function aY(e) {
  let {
    elements: t,
    rect: n,
    offsetParent: r,
    strategy: o
  } = e;
  const a = o === "fixed", l = so(r), u = t ? jh(t.floating) : !1;
  if (r === l || u && a)
    return n;
  let d = {
    scrollLeft: 0,
    scrollTop: 0
  }, f = ro(1);
  const p = ro(0), m = ao(r);
  if ((m || !m && !a) && ((xs(r) !== "body" || Uc(l)) && (d = Dh(r)), ao(r))) {
    const y = Pa(r);
    f = Wl(r), p.x = y.x + r.clientLeft, p.y = y.y + r.clientTop;
  }
  const g = l && !m && !a ? yM(l, d, !0) : ro(0);
  return {
    width: n.width * f.x,
    height: n.height * f.y,
    x: n.x * f.x - d.scrollLeft * f.x + p.x + g.x,
    y: n.y * f.y - d.scrollTop * f.y + p.y + g.y
  };
}
function lY(e) {
  return Array.from(e.getClientRects());
}
function sY(e) {
  const t = so(e), n = Dh(e), r = e.ownerDocument.body, o = Zn(t.scrollWidth, t.clientWidth, r.scrollWidth, r.clientWidth), a = Zn(t.scrollHeight, t.clientHeight, r.scrollHeight, r.clientHeight);
  let l = -n.scrollLeft + Qw(e);
  const u = -n.scrollTop;
  return Dr(r).direction === "rtl" && (l += Zn(t.clientWidth, r.clientWidth) - o), {
    width: o,
    height: a,
    x: l,
    y: u
  };
}
function uY(e, t) {
  const n = Jn(e), r = so(e), o = n.visualViewport;
  let a = r.clientWidth, l = r.clientHeight, u = 0, d = 0;
  if (o) {
    a = o.width, l = o.height;
    const f = Ww();
    (!f || f && t === "fixed") && (u = o.offsetLeft, d = o.offsetTop);
  }
  return {
    width: a,
    height: l,
    x: u,
    y: d
  };
}
function cY(e, t) {
  const n = Pa(e, !0, t === "fixed"), r = n.top + e.clientTop, o = n.left + e.clientLeft, a = ao(e) ? Wl(e) : ro(1), l = e.clientWidth * a.x, u = e.clientHeight * a.y, d = o * a.x, f = r * a.y;
  return {
    width: l,
    height: u,
    x: d,
    y: f
  };
}
function xC(e, t, n) {
  let r;
  if (t === "viewport")
    r = uY(e, n);
  else if (t === "document")
    r = sY(so(e));
  else if (jr(t))
    r = cY(t, n);
  else {
    const o = gM(e);
    r = {
      x: t.x - o.x,
      y: t.y - o.y,
      width: t.width,
      height: t.height
    };
  }
  return zp(r);
}
function vM(e, t) {
  const n = qi(e);
  return n === t || !jr(n) || cs(n) ? !1 : Dr(n).position === "fixed" || vM(n, t);
}
function dY(e, t) {
  const n = t.get(e);
  if (n)
    return n;
  let r = vc(e, [], !1).filter((u) => jr(u) && xs(u) !== "body"), o = null;
  const a = Dr(e).position === "fixed";
  let l = a ? qi(e) : e;
  for (; jr(l) && !cs(l); ) {
    const u = Dr(l), d = Zw(l);
    !d && u.position === "fixed" && (o = null), (a ? !d && !o : !d && u.position === "static" && o && ["absolute", "fixed"].includes(o.position) || Uc(l) && !d && vM(e, l)) ? r = r.filter((f) => f !== l) : o = u, l = qi(l);
  }
  return t.set(e, r), r;
}
function fY(e) {
  let {
    element: t,
    boundary: n,
    rootBoundary: r,
    strategy: o
  } = e;
  const a = [...n === "clippingAncestors" ? jh(t) ? [] : dY(t, this._c) : [].concat(n), r], l = a[0], u = a.reduce((d, f) => {
    const p = xC(t, f, o);
    return d.top = Zn(p.top, d.top), d.right = $i(p.right, d.right), d.bottom = $i(p.bottom, d.bottom), d.left = Zn(p.left, d.left), d;
  }, xC(t, l, o));
  return {
    width: u.right - u.left,
    height: u.bottom - u.top,
    x: u.left,
    y: u.top
  };
}
function pY(e) {
  const {
    width: t,
    height: n
  } = mM(e);
  return {
    width: t,
    height: n
  };
}
function hY(e, t, n) {
  const r = ao(t), o = so(t), a = n === "fixed", l = Pa(e, !0, a, t);
  let u = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const d = ro(0);
  if (r || !r && !a)
    if ((xs(t) !== "body" || Uc(o)) && (u = Dh(t)), r) {
      const g = Pa(t, !0, a, t);
      d.x = g.x + t.clientLeft, d.y = g.y + t.clientTop;
    } else o && (d.x = Qw(o));
  const f = o && !r && !a ? yM(o, u) : ro(0), p = l.left + u.scrollLeft - d.x - f.x, m = l.top + u.scrollTop - d.y - f.y;
  return {
    x: p,
    y: m,
    width: l.width,
    height: l.height
  };
}
function rv(e) {
  return Dr(e).position === "static";
}
function SC(e, t) {
  if (!ao(e) || Dr(e).position === "fixed")
    return null;
  if (t)
    return t(e);
  let n = e.offsetParent;
  return so(e) === n && (n = n.ownerDocument.body), n;
}
function bM(e, t) {
  const n = Jn(e);
  if (jh(e))
    return n;
  if (!ao(e)) {
    let o = qi(e);
    for (; o && !cs(o); ) {
      if (jr(o) && !rv(o))
        return o;
      o = qi(o);
    }
    return n;
  }
  let r = SC(e, t);
  for (; r && nY(r) && rv(r); )
    r = SC(r, t);
  return r && cs(r) && rv(r) && !Zw(r) ? n : r || rY(e) || n;
}
const mY = async function(e) {
  const t = this.getOffsetParent || bM, n = this.getDimensions, r = await n(e.floating);
  return {
    reference: hY(e.reference, await t(e.floating), e.strategy),
    floating: {
      x: 0,
      y: 0,
      width: r.width,
      height: r.height
    }
  };
};
function gY(e) {
  return Dr(e).direction === "rtl";
}
const yY = {
  convertOffsetParentRelativeRectToViewportRelativeRect: aY,
  getDocumentElement: so,
  getClippingRect: fY,
  getOffsetParent: bM,
  getElementRects: mY,
  getClientRects: lY,
  getDimensions: pY,
  getScale: Wl,
  isElement: jr,
  isRTL: gY
};
function wM(e, t) {
  return e.x === t.x && e.y === t.y && e.width === t.width && e.height === t.height;
}
function vY(e, t) {
  let n = null, r;
  const o = so(e);
  function a() {
    var u;
    clearTimeout(r), (u = n) == null || u.disconnect(), n = null;
  }
  function l(u, d) {
    u === void 0 && (u = !1), d === void 0 && (d = 1), a();
    const f = e.getBoundingClientRect(), {
      left: p,
      top: m,
      width: g,
      height: y
    } = f;
    if (u || t(), !g || !y)
      return;
    const w = zf(m), v = zf(o.clientWidth - (p + g)), x = zf(o.clientHeight - (m + y)), E = zf(p), N = {
      rootMargin: -w + "px " + -v + "px " + -x + "px " + -E + "px",
      threshold: Zn(0, $i(1, d)) || 1
    };
    let C = !0;
    function A(R) {
      const D = R[0].intersectionRatio;
      if (D !== d) {
        if (!C)
          return l();
        D ? l(!1, D) : r = setTimeout(() => {
          l(!1, 1e-7);
        }, 1e3);
      }
      D === 1 && !wM(f, e.getBoundingClientRect()) && l(), C = !1;
    }
    try {
      n = new IntersectionObserver(A, {
        ...N,
        // Handle <iframe>s
        root: o.ownerDocument
      });
    } catch {
      n = new IntersectionObserver(A, N);
    }
    n.observe(e);
  }
  return l(!0), a;
}
function xM(e, t, n, r) {
  r === void 0 && (r = {});
  const {
    ancestorScroll: o = !0,
    ancestorResize: a = !0,
    elementResize: l = typeof ResizeObserver == "function",
    layoutShift: u = typeof IntersectionObserver == "function",
    animationFrame: d = !1
  } = r, f = Kw(e), p = o || a ? [...f ? vc(f) : [], ...vc(t)] : [];
  p.forEach((E) => {
    o && E.addEventListener("scroll", n, {
      passive: !0
    }), a && E.addEventListener("resize", n);
  });
  const m = f && u ? vY(f, n) : null;
  let g = -1, y = null;
  l && (y = new ResizeObserver((E) => {
    let [N] = E;
    N && N.target === f && y && (y.unobserve(t), cancelAnimationFrame(g), g = requestAnimationFrame(() => {
      var C;
      (C = y) == null || C.observe(t);
    })), n();
  }), f && !d && y.observe(f), y.observe(t));
  let w, v = d ? Pa(e) : null;
  d && x();
  function x() {
    const E = Pa(e);
    v && !wM(v, E) && n(), v = E, w = requestAnimationFrame(x);
  }
  return n(), () => {
    var E;
    p.forEach((N) => {
      o && N.removeEventListener("scroll", n), a && N.removeEventListener("resize", n);
    }), m?.(), (E = y) == null || E.disconnect(), y = null, d && cancelAnimationFrame(w);
  };
}
const bY = Q$, wY = J$, xY = Z$, SY = tY, kY = W$, kC = G$, _Y = eY, EY = (e, t, n) => {
  const r = /* @__PURE__ */ new Map(), o = {
    platform: yY,
    ...n
  }, a = {
    ...o.platform,
    _c: r
  };
  return X$(e, t, {
    ...o,
    platform: a
  });
};
var sp = typeof document < "u" ? _.useLayoutEffect : _.useEffect;
function Pp(e, t) {
  if (e === t)
    return !0;
  if (typeof e != typeof t)
    return !1;
  if (typeof e == "function" && e.toString() === t.toString())
    return !0;
  let n, r, o;
  if (e && t && typeof e == "object") {
    if (Array.isArray(e)) {
      if (n = e.length, n !== t.length) return !1;
      for (r = n; r-- !== 0; )
        if (!Pp(e[r], t[r]))
          return !1;
      return !0;
    }
    if (o = Object.keys(e), n = o.length, n !== Object.keys(t).length)
      return !1;
    for (r = n; r-- !== 0; )
      if (!{}.hasOwnProperty.call(t, o[r]))
        return !1;
    for (r = n; r-- !== 0; ) {
      const a = o[r];
      if (!(a === "_owner" && e.$$typeof) && !Pp(e[a], t[a]))
        return !1;
    }
    return !0;
  }
  return e !== e && t !== t;
}
function SM(e) {
  return typeof window > "u" ? 1 : (e.ownerDocument.defaultView || window).devicePixelRatio || 1;
}
function _C(e, t) {
  const n = SM(e);
  return Math.round(t * n) / n;
}
function ov(e) {
  const t = _.useRef(e);
  return sp(() => {
    t.current = e;
  }), t;
}
function CY(e) {
  e === void 0 && (e = {});
  const {
    placement: t = "bottom",
    strategy: n = "absolute",
    middleware: r = [],
    platform: o,
    elements: {
      reference: a,
      floating: l
    } = {},
    transform: u = !0,
    whileElementsMounted: d,
    open: f
  } = e, [p, m] = _.useState({
    x: 0,
    y: 0,
    strategy: n,
    placement: t,
    middlewareData: {},
    isPositioned: !1
  }), [g, y] = _.useState(r);
  Pp(g, r) || y(r);
  const [w, v] = _.useState(null), [x, E] = _.useState(null), N = _.useCallback((q) => {
    q !== D.current && (D.current = q, v(q));
  }, []), C = _.useCallback((q) => {
    q !== T.current && (T.current = q, E(q));
  }, []), A = a || w, R = l || x, D = _.useRef(null), T = _.useRef(null), V = _.useRef(p), F = d != null, O = ov(d), B = ov(o), U = ov(f), G = _.useCallback(() => {
    if (!D.current || !T.current)
      return;
    const q = {
      placement: t,
      strategy: n,
      middleware: g
    };
    B.current && (q.platform = B.current), EY(D.current, T.current, q).then((Y) => {
      const M = {
        ...Y,
        // The floating element's position may be recomputed while it's closed
        // but still mounted (such as when transitioning out). To ensure
        // `isPositioned` will be `false` initially on the next open, avoid
        // setting it to `true` when `open === false` (must be specified).
        isPositioned: U.current !== !1
      };
      z.current && !Pp(V.current, M) && (V.current = M, Mc.flushSync(() => {
        m(M);
      }));
    });
  }, [g, t, n, B, U]);
  sp(() => {
    f === !1 && V.current.isPositioned && (V.current.isPositioned = !1, m((q) => ({
      ...q,
      isPositioned: !1
    })));
  }, [f]);
  const z = _.useRef(!1);
  sp(() => (z.current = !0, () => {
    z.current = !1;
  }), []), sp(() => {
    if (A && (D.current = A), R && (T.current = R), A && R) {
      if (O.current)
        return O.current(A, R, G);
      G();
    }
  }, [A, R, G, O, F]);
  const $ = _.useMemo(() => ({
    reference: D,
    floating: T,
    setReference: N,
    setFloating: C
  }), [N, C]), L = _.useMemo(() => ({
    reference: A,
    floating: R
  }), [A, R]), H = _.useMemo(() => {
    const q = {
      position: n,
      left: 0,
      top: 0
    };
    if (!L.floating)
      return q;
    const Y = _C(L.floating, p.x), M = _C(L.floating, p.y);
    return u ? {
      ...q,
      transform: "translate(" + Y + "px, " + M + "px)",
      ...SM(L.floating) >= 1.5 && {
        willChange: "transform"
      }
    } : {
      position: n,
      left: Y,
      top: M
    };
  }, [n, u, L.floating, p.x, p.y]);
  return _.useMemo(() => ({
    ...p,
    update: G,
    refs: $,
    elements: L,
    floatingStyles: H
  }), [p, G, $, L, H]);
}
const OY = (e) => {
  function t(n) {
    return {}.hasOwnProperty.call(n, "current");
  }
  return {
    name: "arrow",
    options: e,
    fn(n) {
      const {
        element: r,
        padding: o
      } = typeof e == "function" ? e(n) : e;
      return r && t(r) ? r.current != null ? kC({
        element: r.current,
        padding: o
      }).fn(n) : {} : r ? kC({
        element: r,
        padding: o
      }).fn(n) : {};
    }
  };
}, NY = (e, t) => ({
  ...bY(e),
  options: [e, t]
}), MY = (e, t) => ({
  ...wY(e),
  options: [e, t]
}), AY = (e, t) => ({
  ..._Y(e),
  options: [e, t]
}), RY = (e, t) => ({
  ...xY(e),
  options: [e, t]
}), jY = (e, t) => ({
  ...SY(e),
  options: [e, t]
}), DY = (e, t) => ({
  ...kY(e),
  options: [e, t]
}), TY = (e, t) => ({
  ...OY(e),
  options: [e, t]
});
var zY = "Arrow", kM = _.forwardRef((e, t) => {
  const { children: n, width: r = 10, height: o = 5, ...a } = e;
  return /* @__PURE__ */ k.jsx(
    vt.svg,
    {
      ...a,
      ref: t,
      width: r,
      height: o,
      viewBox: "0 0 30 10",
      preserveAspectRatio: "none",
      children: e.asChild ? n : /* @__PURE__ */ k.jsx("polygon", { points: "0,0 30,0 15,10" })
    }
  );
});
kM.displayName = zY;
var PY = kM;
function _M(e) {
  const [t, n] = _.useState(void 0);
  return ja(() => {
    if (e) {
      n({ width: e.offsetWidth, height: e.offsetHeight });
      const r = new ResizeObserver((o) => {
        if (!Array.isArray(o) || !o.length)
          return;
        const a = o[0];
        let l, u;
        if ("borderBoxSize" in a) {
          const d = a.borderBoxSize, f = Array.isArray(d) ? d[0] : d;
          l = f.inlineSize, u = f.blockSize;
        } else
          l = e.offsetWidth, u = e.offsetHeight;
        n({ width: l, height: u });
      });
      return r.observe(e, { box: "border-box" }), () => r.unobserve(e);
    } else
      n(void 0);
  }, [e]), t;
}
var Jw = "Popper", [EM, Th] = Gi(Jw), [LY, CM] = EM(Jw), OM = (e) => {
  const { __scopePopper: t, children: n } = e, [r, o] = _.useState(null);
  return /* @__PURE__ */ k.jsx(LY, { scope: t, anchor: r, onAnchorChange: o, children: n });
};
OM.displayName = Jw;
var NM = "PopperAnchor", MM = _.forwardRef(
  (e, t) => {
    const { __scopePopper: n, virtualRef: r, ...o } = e, a = CM(NM, n), l = _.useRef(null), u = kt(t, l);
    return _.useEffect(() => {
      a.onAnchorChange(r?.current || l.current);
    }), r ? null : /* @__PURE__ */ k.jsx(vt.div, { ...o, ref: u });
  }
);
MM.displayName = NM;
var ex = "PopperContent", [IY, BY] = EM(ex), AM = _.forwardRef(
  (e, t) => {
    var n, r, o, a, l, u;
    const {
      __scopePopper: d,
      side: f = "bottom",
      sideOffset: p = 0,
      align: m = "center",
      alignOffset: g = 0,
      arrowPadding: y = 0,
      avoidCollisions: w = !0,
      collisionBoundary: v = [],
      collisionPadding: x = 0,
      sticky: E = "partial",
      hideWhenDetached: N = !1,
      updatePositionStrategy: C = "optimized",
      onPlaced: A,
      ...R
    } = e, D = CM(ex, d), [T, V] = _.useState(null), F = kt(t, (Pe) => V(Pe)), [O, B] = _.useState(null), U = _M(O), G = U?.width ?? 0, z = U?.height ?? 0, $ = f + (m !== "center" ? "-" + m : ""), L = typeof x == "number" ? x : { top: 0, right: 0, bottom: 0, left: 0, ...x }, H = Array.isArray(v) ? v : [v], q = H.length > 0, Y = {
      padding: L,
      boundary: H.filter(HY),
      // with `strategy: 'fixed'`, this is the only way to get it to respect boundaries
      altBoundary: q
    }, { refs: M, floatingStyles: X, placement: Q, isPositioned: P, middlewareData: te } = CY({
      // default to `fixed` strategy so users don't have to pick and we also avoid focus scroll issues
      strategy: "fixed",
      placement: $,
      whileElementsMounted: (...Pe) => xM(...Pe, {
        animationFrame: C === "always"
      }),
      elements: {
        reference: D.anchor
      },
      middleware: [
        NY({ mainAxis: p + z, alignmentAxis: g }),
        w && MY({
          mainAxis: !0,
          crossAxis: !1,
          limiter: E === "partial" ? AY() : void 0,
          ...Y
        }),
        w && RY({ ...Y }),
        jY({
          ...Y,
          apply: ({ elements: Pe, rects: Ve, availableWidth: Rt, availableHeight: Pt }) => {
            const { width: lt, height: wr } = Ve.reference, en = Pe.floating.style;
            en.setProperty("--radix-popper-available-width", `${Rt}px`), en.setProperty("--radix-popper-available-height", `${Pt}px`), en.setProperty("--radix-popper-anchor-width", `${lt}px`), en.setProperty("--radix-popper-anchor-height", `${wr}px`);
          }
        }),
        O && TY({ element: O, padding: y }),
        UY({ arrowWidth: G, arrowHeight: z }),
        N && DY({ strategy: "referenceHidden", ...Y })
      ]
    }), [ie, ae] = DM(Q), fe = yr(A);
    ja(() => {
      P && fe?.();
    }, [P, fe]);
    const he = (n = te.arrow) == null ? void 0 : n.x, ye = (r = te.arrow) == null ? void 0 : r.y, Ee = ((o = te.arrow) == null ? void 0 : o.centerOffset) !== 0, [we, xe] = _.useState();
    return ja(() => {
      T && xe(window.getComputedStyle(T).zIndex);
    }, [T]), /* @__PURE__ */ k.jsx(
      "div",
      {
        ref: M.setFloating,
        "data-radix-popper-content-wrapper": "",
        style: {
          ...X,
          transform: P ? X.transform : "translate(0, -200%)",
          // keep off the page when measuring
          minWidth: "max-content",
          zIndex: we,
          "--radix-popper-transform-origin": [
            (a = te.transformOrigin) == null ? void 0 : a.x,
            (l = te.transformOrigin) == null ? void 0 : l.y
          ].join(" "),
          // hide the content if using the hide middleware and should be hidden
          // set visibility to hidden and disable pointer events so the UI behaves
          // as if the PopperContent isn't there at all
          ...((u = te.hide) == null ? void 0 : u.referenceHidden) && {
            visibility: "hidden",
            pointerEvents: "none"
          }
        },
        dir: e.dir,
        children: /* @__PURE__ */ k.jsx(
          IY,
          {
            scope: d,
            placedSide: ie,
            onArrowChange: B,
            arrowX: he,
            arrowY: ye,
            shouldHideArrow: Ee,
            children: /* @__PURE__ */ k.jsx(
              vt.div,
              {
                "data-side": ie,
                "data-align": ae,
                ...R,
                ref: F,
                style: {
                  ...R.style,
                  // if the PopperContent hasn't been placed yet (not all measurements done)
                  // we prevent animations so that users's animation don't kick in too early referring wrong sides
                  animation: P ? void 0 : "none"
                }
              }
            )
          }
        )
      }
    );
  }
);
AM.displayName = ex;
var RM = "PopperArrow", VY = {
  top: "bottom",
  right: "left",
  bottom: "top",
  left: "right"
}, jM = _.forwardRef(function(e, t) {
  const { __scopePopper: n, ...r } = e, o = BY(RM, n), a = VY[o.placedSide];
  return (
    // we have to use an extra wrapper because `ResizeObserver` (used by `useSize`)
    // doesn't report size as we'd expect on SVG elements.
    // it reports their bounding box which is effectively the largest path inside the SVG.
    /* @__PURE__ */ k.jsx(
      "span",
      {
        ref: o.onArrowChange,
        style: {
          position: "absolute",
          left: o.arrowX,
          top: o.arrowY,
          [a]: 0,
          transformOrigin: {
            top: "",
            right: "0 0",
            bottom: "center 0",
            left: "100% 0"
          }[o.placedSide],
          transform: {
            top: "translateY(100%)",
            right: "translateY(50%) rotate(90deg) translateX(-50%)",
            bottom: "rotate(180deg)",
            left: "translateY(50%) rotate(-90deg) translateX(50%)"
          }[o.placedSide],
          visibility: o.shouldHideArrow ? "hidden" : void 0
        },
        children: /* @__PURE__ */ k.jsx(
          PY,
          {
            ...r,
            ref: t,
            style: {
              ...r.style,
              // ensures the element can be measured correctly (mostly for if SVG)
              display: "block"
            }
          }
        )
      }
    )
  );
});
jM.displayName = RM;
function HY(e) {
  return e !== null;
}
var UY = (e) => ({
  name: "transformOrigin",
  options: e,
  fn(t) {
    var n, r, o;
    const { placement: a, rects: l, middlewareData: u } = t, d = ((n = u.arrow) == null ? void 0 : n.centerOffset) !== 0, f = d ? 0 : e.arrowWidth, p = d ? 0 : e.arrowHeight, [m, g] = DM(a), y = { start: "0%", center: "50%", end: "100%" }[g], w = (((r = u.arrow) == null ? void 0 : r.x) ?? 0) + f / 2, v = (((o = u.arrow) == null ? void 0 : o.y) ?? 0) + p / 2;
    let x = "", E = "";
    return m === "bottom" ? (x = d ? y : `${w}px`, E = `${-p}px`) : m === "top" ? (x = d ? y : `${w}px`, E = `${l.floating.height + p}px`) : m === "right" ? (x = `${-p}px`, E = d ? y : `${v}px`) : m === "left" && (x = `${l.floating.width + p}px`, E = d ? y : `${v}px`), { data: { x, y: E } };
  }
});
function DM(e) {
  const [t, n = "center"] = e.split("-");
  return [t, n];
}
var tx = OM, nx = MM, TM = AM, zM = jM, iv = "rovingFocusGroup.onEntryFocus", FY = { bubbles: !1, cancelable: !0 }, zh = "RovingFocusGroup", [Nb, PM, $Y] = $w(zh), [YY, LM] = Gi(
  zh,
  [$Y]
), [qY, XY] = YY(zh), IM = _.forwardRef(
  (e, t) => /* @__PURE__ */ k.jsx(Nb.Provider, { scope: e.__scopeRovingFocusGroup, children: /* @__PURE__ */ k.jsx(Nb.Slot, { scope: e.__scopeRovingFocusGroup, children: /* @__PURE__ */ k.jsx(GY, { ...e, ref: t }) }) })
);
IM.displayName = zh;
var GY = _.forwardRef((e, t) => {
  const {
    __scopeRovingFocusGroup: n,
    orientation: r,
    loop: o = !1,
    dir: a,
    currentTabStopId: l,
    defaultCurrentTabStopId: u,
    onCurrentTabStopIdChange: d,
    onEntryFocus: f,
    preventScrollOnEntryFocus: p = !1,
    ...m
  } = e, g = _.useRef(null), y = kt(t, g), w = Yw(a), [v = null, x] = ys({
    prop: l,
    defaultProp: u,
    onChange: d
  }), [E, N] = _.useState(!1), C = yr(f), A = PM(n), R = _.useRef(!1), [D, T] = _.useState(0);
  return _.useEffect(() => {
    const V = g.current;
    if (V)
      return V.addEventListener(iv, C), () => V.removeEventListener(iv, C);
  }, [C]), /* @__PURE__ */ k.jsx(
    qY,
    {
      scope: n,
      orientation: r,
      dir: w,
      loop: o,
      currentTabStopId: v,
      onItemFocus: _.useCallback(
        (V) => x(V),
        [x]
      ),
      onItemShiftTab: _.useCallback(() => N(!0), []),
      onFocusableItemAdd: _.useCallback(
        () => T((V) => V + 1),
        []
      ),
      onFocusableItemRemove: _.useCallback(
        () => T((V) => V - 1),
        []
      ),
      children: /* @__PURE__ */ k.jsx(
        vt.div,
        {
          tabIndex: E || D === 0 ? -1 : 0,
          "data-orientation": r,
          ...m,
          ref: y,
          style: { outline: "none", ...e.style },
          onMouseDown: Te(e.onMouseDown, () => {
            R.current = !0;
          }),
          onFocus: Te(e.onFocus, (V) => {
            const F = !R.current;
            if (V.target === V.currentTarget && F && !E) {
              const O = new CustomEvent(iv, FY);
              if (V.currentTarget.dispatchEvent(O), !O.defaultPrevented) {
                const B = A().filter(($) => $.focusable), U = B.find(($) => $.active), G = B.find(($) => $.id === v), z = [U, G, ...B].filter(
                  Boolean
                ).map(($) => $.ref.current);
                HM(z, p);
              }
            }
            R.current = !1;
          }),
          onBlur: Te(e.onBlur, () => N(!1))
        }
      )
    }
  );
}), BM = "RovingFocusGroupItem", VM = _.forwardRef(
  (e, t) => {
    const {
      __scopeRovingFocusGroup: n,
      focusable: r = !0,
      active: o = !1,
      tabStopId: a,
      ...l
    } = e, u = Vo(), d = a || u, f = XY(BM, n), p = f.currentTabStopId === d, m = PM(n), { onFocusableItemAdd: g, onFocusableItemRemove: y } = f;
    return _.useEffect(() => {
      if (r)
        return g(), () => y();
    }, [r, g, y]), /* @__PURE__ */ k.jsx(
      Nb.ItemSlot,
      {
        scope: n,
        id: d,
        focusable: r,
        active: o,
        children: /* @__PURE__ */ k.jsx(
          vt.span,
          {
            tabIndex: p ? 0 : -1,
            "data-orientation": f.orientation,
            ...l,
            ref: t,
            onMouseDown: Te(e.onMouseDown, (w) => {
              r ? f.onItemFocus(d) : w.preventDefault();
            }),
            onFocus: Te(e.onFocus, () => f.onItemFocus(d)),
            onKeyDown: Te(e.onKeyDown, (w) => {
              if (w.key === "Tab" && w.shiftKey) {
                f.onItemShiftTab();
                return;
              }
              if (w.target !== w.currentTarget) return;
              const v = KY(w, f.orientation, f.dir);
              if (v !== void 0) {
                if (w.metaKey || w.ctrlKey || w.altKey || w.shiftKey) return;
                w.preventDefault();
                let x = m().filter((E) => E.focusable).map((E) => E.ref.current);
                if (v === "last") x.reverse();
                else if (v === "prev" || v === "next") {
                  v === "prev" && x.reverse();
                  const E = x.indexOf(w.currentTarget);
                  x = f.loop ? QY(x, E + 1) : x.slice(E + 1);
                }
                setTimeout(() => HM(x));
              }
            })
          }
        )
      }
    );
  }
);
VM.displayName = BM;
var ZY = {
  ArrowLeft: "prev",
  ArrowUp: "prev",
  ArrowRight: "next",
  ArrowDown: "next",
  PageUp: "first",
  Home: "first",
  PageDown: "last",
  End: "last"
};
function WY(e, t) {
  return t !== "rtl" ? e : e === "ArrowLeft" ? "ArrowRight" : e === "ArrowRight" ? "ArrowLeft" : e;
}
function KY(e, t, n) {
  const r = WY(e.key, n);
  if (!(t === "vertical" && ["ArrowLeft", "ArrowRight"].includes(r)) && !(t === "horizontal" && ["ArrowUp", "ArrowDown"].includes(r)))
    return ZY[r];
}
function HM(e, t = !1) {
  const n = document.activeElement;
  for (const r of e)
    if (r === n || (r.focus({ preventScroll: t }), document.activeElement !== n)) return;
}
function QY(e, t) {
  return e.map((n, r) => e[(t + r) % e.length]);
}
var JY = IM, eq = VM, Mb = ["Enter", " "], tq = ["ArrowDown", "PageUp", "Home"], UM = ["ArrowUp", "PageDown", "End"], nq = [...tq, ...UM], rq = {
  ltr: [...Mb, "ArrowRight"],
  rtl: [...Mb, "ArrowLeft"]
}, oq = {
  ltr: ["ArrowLeft"],
  rtl: ["ArrowRight"]
}, Fc = "Menu", [bc, iq, aq] = $w(Fc), [Va, FM] = Gi(Fc, [
  aq,
  Th,
  LM
]), $c = Th(), $M = LM(), [YM, Ha] = Va(Fc), [lq, Yc] = Va(Fc), qM = (e) => {
  const { __scopeMenu: t, open: n = !1, children: r, dir: o, onOpenChange: a, modal: l = !0 } = e, u = $c(t), [d, f] = _.useState(null), p = _.useRef(!1), m = yr(a), g = Yw(o);
  return _.useEffect(() => {
    const y = () => {
      p.current = !0, document.addEventListener("pointerdown", w, { capture: !0, once: !0 }), document.addEventListener("pointermove", w, { capture: !0, once: !0 });
    }, w = () => p.current = !1;
    return document.addEventListener("keydown", y, { capture: !0 }), () => {
      document.removeEventListener("keydown", y, { capture: !0 }), document.removeEventListener("pointerdown", w, { capture: !0 }), document.removeEventListener("pointermove", w, { capture: !0 });
    };
  }, []), /* @__PURE__ */ k.jsx(tx, { ...u, children: /* @__PURE__ */ k.jsx(
    YM,
    {
      scope: t,
      open: n,
      onOpenChange: m,
      content: d,
      onContentChange: f,
      children: /* @__PURE__ */ k.jsx(
        lq,
        {
          scope: t,
          onClose: _.useCallback(() => m(!1), [m]),
          isUsingKeyboardRef: p,
          dir: g,
          modal: l,
          children: r
        }
      )
    }
  ) });
};
qM.displayName = Fc;
var sq = "MenuAnchor", rx = _.forwardRef(
  (e, t) => {
    const { __scopeMenu: n, ...r } = e, o = $c(n);
    return /* @__PURE__ */ k.jsx(nx, { ...o, ...r, ref: t });
  }
);
rx.displayName = sq;
var uq = "MenuPortal", [Jue, XM] = Va(uq, {
  forceMount: void 0
}), gr = "MenuContent", [cq, ox] = Va(gr), GM = _.forwardRef(
  (e, t) => {
    const n = XM(gr, e.__scopeMenu), { forceMount: r = n.forceMount, ...o } = e, a = Ha(gr, e.__scopeMenu), l = Yc(gr, e.__scopeMenu);
    return /* @__PURE__ */ k.jsx(bc.Provider, { scope: e.__scopeMenu, children: /* @__PURE__ */ k.jsx(Wo, { present: r || a.open, children: /* @__PURE__ */ k.jsx(bc.Slot, { scope: e.__scopeMenu, children: l.modal ? /* @__PURE__ */ k.jsx(dq, { ...o, ref: t }) : /* @__PURE__ */ k.jsx(fq, { ...o, ref: t }) }) }) });
  }
), dq = _.forwardRef(
  (e, t) => {
    const n = Ha(gr, e.__scopeMenu), r = _.useRef(null), o = kt(t, r);
    return _.useEffect(() => {
      const a = r.current;
      if (a) return Ow(a);
    }, []), /* @__PURE__ */ k.jsx(
      ix,
      {
        ...e,
        ref: o,
        trapFocus: n.open,
        disableOutsidePointerEvents: n.open,
        disableOutsideScroll: !0,
        onFocusOutside: Te(
          e.onFocusOutside,
          (a) => a.preventDefault(),
          { checkForDefaultPrevented: !1 }
        ),
        onDismiss: () => n.onOpenChange(!1)
      }
    );
  }
), fq = _.forwardRef((e, t) => {
  const n = Ha(gr, e.__scopeMenu);
  return /* @__PURE__ */ k.jsx(
    ix,
    {
      ...e,
      ref: t,
      trapFocus: !1,
      disableOutsidePointerEvents: !1,
      disableOutsideScroll: !1,
      onDismiss: () => n.onOpenChange(!1)
    }
  );
}), pq = /* @__PURE__ */ ss("MenuContent.ScrollLock"), ix = _.forwardRef(
  (e, t) => {
    const {
      __scopeMenu: n,
      loop: r = !1,
      trapFocus: o,
      onOpenAutoFocus: a,
      onCloseAutoFocus: l,
      disableOutsidePointerEvents: u,
      onEntryFocus: d,
      onEscapeKeyDown: f,
      onPointerDownOutside: p,
      onFocusOutside: m,
      onInteractOutside: g,
      onDismiss: y,
      disableOutsideScroll: w,
      ...v
    } = e, x = Ha(gr, n), E = Yc(gr, n), N = $c(n), C = $M(n), A = iq(n), [R, D] = _.useState(null), T = _.useRef(null), V = kt(t, T, x.onContentChange), F = _.useRef(0), O = _.useRef(""), B = _.useRef(0), U = _.useRef(null), G = _.useRef("right"), z = _.useRef(0), $ = w ? Eh : _.Fragment, L = w ? { as: pq, allowPinchZoom: !0 } : void 0, H = (Y) => {
      var M, X;
      const Q = O.current + Y, P = A().filter((ye) => !ye.disabled), te = document.activeElement, ie = (M = P.find((ye) => ye.ref.current === te)) == null ? void 0 : M.textValue, ae = P.map((ye) => ye.textValue), fe = Eq(ae, Q, ie), he = (X = P.find((ye) => ye.textValue === fe)) == null ? void 0 : X.ref.current;
      (function ye(Ee) {
        O.current = Ee, window.clearTimeout(F.current), Ee !== "" && (F.current = window.setTimeout(() => ye(""), 1e3));
      })(Q), he && setTimeout(() => he.focus());
    };
    _.useEffect(() => () => window.clearTimeout(F.current), []), Cw();
    const q = _.useCallback((Y) => {
      var M, X;
      return G.current === ((M = U.current) == null ? void 0 : M.side) && Oq(Y, (X = U.current) == null ? void 0 : X.area);
    }, []);
    return /* @__PURE__ */ k.jsx(
      cq,
      {
        scope: n,
        searchRef: O,
        onItemEnter: _.useCallback(
          (Y) => {
            q(Y) && Y.preventDefault();
          },
          [q]
        ),
        onItemLeave: _.useCallback(
          (Y) => {
            var M;
            q(Y) || ((M = T.current) == null || M.focus(), D(null));
          },
          [q]
        ),
        onTriggerLeave: _.useCallback(
          (Y) => {
            q(Y) && Y.preventDefault();
          },
          [q]
        ),
        pointerGraceTimerRef: B,
        onPointerGraceIntentChange: _.useCallback((Y) => {
          U.current = Y;
        }, []),
        children: /* @__PURE__ */ k.jsx($, { ...L, children: /* @__PURE__ */ k.jsx(
          kh,
          {
            asChild: !0,
            trapped: o,
            onMountAutoFocus: Te(a, (Y) => {
              var M;
              Y.preventDefault(), (M = T.current) == null || M.focus({ preventScroll: !0 });
            }),
            onUnmountAutoFocus: l,
            children: /* @__PURE__ */ k.jsx(
              Sh,
              {
                asChild: !0,
                disableOutsidePointerEvents: u,
                onEscapeKeyDown: f,
                onPointerDownOutside: p,
                onFocusOutside: m,
                onInteractOutside: g,
                onDismiss: y,
                children: /* @__PURE__ */ k.jsx(
                  JY,
                  {
                    asChild: !0,
                    ...C,
                    dir: E.dir,
                    orientation: "vertical",
                    loop: r,
                    currentTabStopId: R,
                    onCurrentTabStopIdChange: D,
                    onEntryFocus: Te(d, (Y) => {
                      E.isUsingKeyboardRef.current || Y.preventDefault();
                    }),
                    preventScrollOnEntryFocus: !0,
                    children: /* @__PURE__ */ k.jsx(
                      TM,
                      {
                        role: "menu",
                        "aria-orientation": "vertical",
                        "data-state": dA(x.open),
                        "data-radix-menu-content": "",
                        dir: E.dir,
                        ...N,
                        ...v,
                        ref: V,
                        style: { outline: "none", ...v.style },
                        onKeyDown: Te(v.onKeyDown, (Y) => {
                          const M = Y.target.closest("[data-radix-menu-content]") === Y.currentTarget, X = Y.ctrlKey || Y.altKey || Y.metaKey, Q = Y.key.length === 1;
                          M && (Y.key === "Tab" && Y.preventDefault(), !X && Q && H(Y.key));
                          const P = T.current;
                          if (Y.target !== P || !nq.includes(Y.key)) return;
                          Y.preventDefault();
                          const te = A().filter((ie) => !ie.disabled).map((ie) => ie.ref.current);
                          UM.includes(Y.key) && te.reverse(), kq(te);
                        }),
                        onBlur: Te(e.onBlur, (Y) => {
                          Y.currentTarget.contains(Y.target) || (window.clearTimeout(F.current), O.current = "");
                        }),
                        onPointerMove: Te(
                          e.onPointerMove,
                          wc((Y) => {
                            const M = Y.target, X = z.current !== Y.clientX;
                            if (Y.currentTarget.contains(M) && X) {
                              const Q = Y.clientX > z.current ? "right" : "left";
                              G.current = Q, z.current = Y.clientX;
                            }
                          })
                        )
                      }
                    )
                  }
                )
              }
            )
          }
        ) })
      }
    );
  }
);
GM.displayName = gr;
var hq = "MenuGroup", ax = _.forwardRef(
  (e, t) => {
    const { __scopeMenu: n, ...r } = e;
    return /* @__PURE__ */ k.jsx(vt.div, { role: "group", ...r, ref: t });
  }
);
ax.displayName = hq;
var mq = "MenuLabel", ZM = _.forwardRef(
  (e, t) => {
    const { __scopeMenu: n, ...r } = e;
    return /* @__PURE__ */ k.jsx(vt.div, { ...r, ref: t });
  }
);
ZM.displayName = mq;
var Lp = "MenuItem", EC = "menu.itemSelect", Ph = _.forwardRef(
  (e, t) => {
    const { disabled: n = !1, onSelect: r, ...o } = e, a = _.useRef(null), l = Yc(Lp, e.__scopeMenu), u = ox(Lp, e.__scopeMenu), d = kt(t, a), f = _.useRef(!1), p = () => {
      const m = a.current;
      if (!n && m) {
        const g = new CustomEvent(EC, { bubbles: !0, cancelable: !0 });
        m.addEventListener(EC, (y) => r?.(y), { once: !0 }), Q4(m, g), g.defaultPrevented ? f.current = !1 : l.onClose();
      }
    };
    return /* @__PURE__ */ k.jsx(
      WM,
      {
        ...o,
        ref: d,
        disabled: n,
        onClick: Te(e.onClick, p),
        onPointerDown: (m) => {
          var g;
          (g = e.onPointerDown) == null || g.call(e, m), f.current = !0;
        },
        onPointerUp: Te(e.onPointerUp, (m) => {
          var g;
          f.current || (g = m.currentTarget) == null || g.click();
        }),
        onKeyDown: Te(e.onKeyDown, (m) => {
          const g = u.searchRef.current !== "";
          n || g && m.key === " " || Mb.includes(m.key) && (m.currentTarget.click(), m.preventDefault());
        })
      }
    );
  }
);
Ph.displayName = Lp;
var WM = _.forwardRef(
  (e, t) => {
    const { __scopeMenu: n, disabled: r = !1, textValue: o, ...a } = e, l = ox(Lp, n), u = $M(n), d = _.useRef(null), f = kt(t, d), [p, m] = _.useState(!1), [g, y] = _.useState("");
    return _.useEffect(() => {
      const w = d.current;
      w && y((w.textContent ?? "").trim());
    }, [a.children]), /* @__PURE__ */ k.jsx(
      bc.ItemSlot,
      {
        scope: n,
        disabled: r,
        textValue: o ?? g,
        children: /* @__PURE__ */ k.jsx(eq, { asChild: !0, ...u, focusable: !r, children: /* @__PURE__ */ k.jsx(
          vt.div,
          {
            role: "menuitem",
            "data-highlighted": p ? "" : void 0,
            "aria-disabled": r || void 0,
            "data-disabled": r ? "" : void 0,
            ...a,
            ref: f,
            onPointerMove: Te(
              e.onPointerMove,
              wc((w) => {
                r ? l.onItemLeave(w) : (l.onItemEnter(w), w.defaultPrevented || w.currentTarget.focus({ preventScroll: !0 }));
              })
            ),
            onPointerLeave: Te(
              e.onPointerLeave,
              wc((w) => l.onItemLeave(w))
            ),
            onFocus: Te(e.onFocus, () => m(!0)),
            onBlur: Te(e.onBlur, () => m(!1))
          }
        ) })
      }
    );
  }
), gq = "MenuCheckboxItem", KM = _.forwardRef(
  (e, t) => {
    const { checked: n = !1, onCheckedChange: r, ...o } = e;
    return /* @__PURE__ */ k.jsx(nA, { scope: e.__scopeMenu, checked: n, children: /* @__PURE__ */ k.jsx(
      Ph,
      {
        role: "menuitemcheckbox",
        "aria-checked": Ip(n) ? "mixed" : n,
        ...o,
        ref: t,
        "data-state": ux(n),
        onSelect: Te(
          o.onSelect,
          () => r?.(Ip(n) ? !0 : !n),
          { checkForDefaultPrevented: !1 }
        )
      }
    ) });
  }
);
KM.displayName = gq;
var QM = "MenuRadioGroup", [yq, vq] = Va(
  QM,
  { value: void 0, onValueChange: () => {
  } }
), JM = _.forwardRef(
  (e, t) => {
    const { value: n, onValueChange: r, ...o } = e, a = yr(r);
    return /* @__PURE__ */ k.jsx(yq, { scope: e.__scopeMenu, value: n, onValueChange: a, children: /* @__PURE__ */ k.jsx(ax, { ...o, ref: t }) });
  }
);
JM.displayName = QM;
var eA = "MenuRadioItem", tA = _.forwardRef(
  (e, t) => {
    const { value: n, ...r } = e, o = vq(eA, e.__scopeMenu), a = n === o.value;
    return /* @__PURE__ */ k.jsx(nA, { scope: e.__scopeMenu, checked: a, children: /* @__PURE__ */ k.jsx(
      Ph,
      {
        role: "menuitemradio",
        "aria-checked": a,
        ...r,
        ref: t,
        "data-state": ux(a),
        onSelect: Te(
          r.onSelect,
          () => {
            var l;
            return (l = o.onValueChange) == null ? void 0 : l.call(o, n);
          },
          { checkForDefaultPrevented: !1 }
        )
      }
    ) });
  }
);
tA.displayName = eA;
var lx = "MenuItemIndicator", [nA, bq] = Va(
  lx,
  { checked: !1 }
), rA = _.forwardRef(
  (e, t) => {
    const { __scopeMenu: n, forceMount: r, ...o } = e, a = bq(lx, n);
    return /* @__PURE__ */ k.jsx(
      Wo,
      {
        present: r || Ip(a.checked) || a.checked === !0,
        children: /* @__PURE__ */ k.jsx(
          vt.span,
          {
            ...o,
            ref: t,
            "data-state": ux(a.checked)
          }
        )
      }
    );
  }
);
rA.displayName = lx;
var wq = "MenuSeparator", oA = _.forwardRef(
  (e, t) => {
    const { __scopeMenu: n, ...r } = e;
    return /* @__PURE__ */ k.jsx(
      vt.div,
      {
        role: "separator",
        "aria-orientation": "horizontal",
        ...r,
        ref: t
      }
    );
  }
);
oA.displayName = wq;
var xq = "MenuArrow", iA = _.forwardRef(
  (e, t) => {
    const { __scopeMenu: n, ...r } = e, o = $c(n);
    return /* @__PURE__ */ k.jsx(zM, { ...o, ...r, ref: t });
  }
);
iA.displayName = xq;
var sx = "MenuSub", [Sq, aA] = Va(sx), lA = (e) => {
  const { __scopeMenu: t, children: n, open: r = !1, onOpenChange: o } = e, a = Ha(sx, t), l = $c(t), [u, d] = _.useState(null), [f, p] = _.useState(null), m = yr(o);
  return _.useEffect(() => (a.open === !1 && m(!1), () => m(!1)), [a.open, m]), /* @__PURE__ */ k.jsx(tx, { ...l, children: /* @__PURE__ */ k.jsx(
    YM,
    {
      scope: t,
      open: r,
      onOpenChange: m,
      content: f,
      onContentChange: p,
      children: /* @__PURE__ */ k.jsx(
        Sq,
        {
          scope: t,
          contentId: Vo(),
          triggerId: Vo(),
          trigger: u,
          onTriggerChange: d,
          children: n
        }
      )
    }
  ) });
};
lA.displayName = sx;
var qu = "MenuSubTrigger", sA = _.forwardRef(
  (e, t) => {
    const n = Ha(qu, e.__scopeMenu), r = Yc(qu, e.__scopeMenu), o = aA(qu, e.__scopeMenu), a = ox(qu, e.__scopeMenu), l = _.useRef(null), { pointerGraceTimerRef: u, onPointerGraceIntentChange: d } = a, f = { __scopeMenu: e.__scopeMenu }, p = _.useCallback(() => {
      l.current && window.clearTimeout(l.current), l.current = null;
    }, []);
    return _.useEffect(() => p, [p]), _.useEffect(() => {
      const m = u.current;
      return () => {
        window.clearTimeout(m), d(null);
      };
    }, [u, d]), /* @__PURE__ */ k.jsx(rx, { asChild: !0, ...f, children: /* @__PURE__ */ k.jsx(
      WM,
      {
        id: o.triggerId,
        "aria-haspopup": "menu",
        "aria-expanded": n.open,
        "aria-controls": o.contentId,
        "data-state": dA(n.open),
        ...e,
        ref: xh(t, o.onTriggerChange),
        onClick: (m) => {
          var g;
          (g = e.onClick) == null || g.call(e, m), !(e.disabled || m.defaultPrevented) && (m.currentTarget.focus(), n.open || n.onOpenChange(!0));
        },
        onPointerMove: Te(
          e.onPointerMove,
          wc((m) => {
            a.onItemEnter(m), !m.defaultPrevented && !e.disabled && !n.open && !l.current && (a.onPointerGraceIntentChange(null), l.current = window.setTimeout(() => {
              n.onOpenChange(!0), p();
            }, 100));
          })
        ),
        onPointerLeave: Te(
          e.onPointerLeave,
          wc((m) => {
            var g, y;
            p();
            const w = (g = n.content) == null ? void 0 : g.getBoundingClientRect();
            if (w) {
              const v = (y = n.content) == null ? void 0 : y.dataset.side, x = v === "right", E = x ? -5 : 5, N = w[x ? "left" : "right"], C = w[x ? "right" : "left"];
              a.onPointerGraceIntentChange({
                area: [
                  // Apply a bleed on clientX to ensure that our exit point is
                  // consistently within polygon bounds
                  { x: m.clientX + E, y: m.clientY },
                  { x: N, y: w.top },
                  { x: C, y: w.top },
                  { x: C, y: w.bottom },
                  { x: N, y: w.bottom }
                ],
                side: v
              }), window.clearTimeout(u.current), u.current = window.setTimeout(
                () => a.onPointerGraceIntentChange(null),
                300
              );
            } else {
              if (a.onTriggerLeave(m), m.defaultPrevented) return;
              a.onPointerGraceIntentChange(null);
            }
          })
        ),
        onKeyDown: Te(e.onKeyDown, (m) => {
          var g;
          const y = a.searchRef.current !== "";
          e.disabled || y && m.key === " " || rq[r.dir].includes(m.key) && (n.onOpenChange(!0), (g = n.content) == null || g.focus(), m.preventDefault());
        })
      }
    ) });
  }
);
sA.displayName = qu;
var uA = "MenuSubContent", cA = _.forwardRef(
  (e, t) => {
    const n = XM(gr, e.__scopeMenu), { forceMount: r = n.forceMount, ...o } = e, a = Ha(gr, e.__scopeMenu), l = Yc(gr, e.__scopeMenu), u = aA(uA, e.__scopeMenu), d = _.useRef(null), f = kt(t, d);
    return /* @__PURE__ */ k.jsx(bc.Provider, { scope: e.__scopeMenu, children: /* @__PURE__ */ k.jsx(Wo, { present: r || a.open, children: /* @__PURE__ */ k.jsx(bc.Slot, { scope: e.__scopeMenu, children: /* @__PURE__ */ k.jsx(
      ix,
      {
        id: u.contentId,
        "aria-labelledby": u.triggerId,
        ...o,
        ref: f,
        align: "start",
        side: l.dir === "rtl" ? "left" : "right",
        disableOutsidePointerEvents: !1,
        disableOutsideScroll: !1,
        trapFocus: !1,
        onOpenAutoFocus: (p) => {
          var m;
          l.isUsingKeyboardRef.current && ((m = d.current) == null || m.focus()), p.preventDefault();
        },
        onCloseAutoFocus: (p) => p.preventDefault(),
        onFocusOutside: Te(e.onFocusOutside, (p) => {
          p.target !== u.trigger && a.onOpenChange(!1);
        }),
        onEscapeKeyDown: Te(e.onEscapeKeyDown, (p) => {
          l.onClose(), p.preventDefault();
        }),
        onKeyDown: Te(e.onKeyDown, (p) => {
          var m;
          const g = p.currentTarget.contains(p.target), y = oq[l.dir].includes(p.key);
          g && y && (a.onOpenChange(!1), (m = u.trigger) == null || m.focus(), p.preventDefault());
        })
      }
    ) }) }) });
  }
);
cA.displayName = uA;
function dA(e) {
  return e ? "open" : "closed";
}
function Ip(e) {
  return e === "indeterminate";
}
function ux(e) {
  return Ip(e) ? "indeterminate" : e ? "checked" : "unchecked";
}
function kq(e) {
  const t = document.activeElement;
  for (const n of e)
    if (n === t || (n.focus(), document.activeElement !== t)) return;
}
function _q(e, t) {
  return e.map((n, r) => e[(t + r) % e.length]);
}
function Eq(e, t, n) {
  const r = t.length > 1 && Array.from(t).every((u) => u === t[0]) ? t[0] : t, o = n ? e.indexOf(n) : -1;
  let a = _q(e, Math.max(o, 0));
  r.length === 1 && (a = a.filter((u) => u !== n));
  const l = a.find(
    (u) => u.toLowerCase().startsWith(r.toLowerCase())
  );
  return l !== n ? l : void 0;
}
function Cq(e, t) {
  const { x: n, y: r } = e;
  let o = !1;
  for (let a = 0, l = t.length - 1; a < t.length; l = a++) {
    const u = t[a].x, d = t[a].y, f = t[l].x, p = t[l].y;
    d > r != p > r && n < (f - u) * (r - d) / (p - d) + u && (o = !o);
  }
  return o;
}
function Oq(e, t) {
  if (!t) return !1;
  const n = { x: e.clientX, y: e.clientY };
  return Cq(n, t);
}
function wc(e) {
  return (t) => t.pointerType === "mouse" ? e(t) : void 0;
}
var Nq = qM, Mq = rx, Aq = GM, Rq = ax, jq = ZM, Dq = Ph, Tq = KM, zq = JM, Pq = tA, Lq = rA, Iq = oA, Bq = iA, Vq = lA, Hq = sA, Uq = cA, cx = "DropdownMenu", [Fq, ece] = Gi(
  cx,
  [FM]
), _n = FM(), [$q, fA] = Fq(cx), pA = (e) => {
  const {
    __scopeDropdownMenu: t,
    children: n,
    dir: r,
    open: o,
    defaultOpen: a,
    onOpenChange: l,
    modal: u = !0
  } = e, d = _n(t), f = _.useRef(null), [p = !1, m] = ys({
    prop: o,
    defaultProp: a,
    onChange: l
  });
  return /* @__PURE__ */ k.jsx(
    $q,
    {
      scope: t,
      triggerId: Vo(),
      triggerRef: f,
      contentId: Vo(),
      open: p,
      onOpenChange: m,
      onOpenToggle: _.useCallback(() => m((g) => !g), [m]),
      modal: u,
      children: /* @__PURE__ */ k.jsx(Nq, { ...d, open: p, onOpenChange: m, dir: r, modal: u, children: n })
    }
  );
};
pA.displayName = cx;
var hA = "DropdownMenuTrigger", mA = _.forwardRef(
  (e, t) => {
    const { __scopeDropdownMenu: n, disabled: r = !1, ...o } = e, a = fA(hA, n), l = _n(n);
    return /* @__PURE__ */ k.jsx(Mq, { asChild: !0, ...l, children: /* @__PURE__ */ k.jsx(
      vt.button,
      {
        type: "button",
        id: a.triggerId,
        "aria-haspopup": "menu",
        "aria-expanded": a.open,
        "aria-controls": a.open ? a.contentId : void 0,
        "data-state": a.open ? "open" : "closed",
        "data-disabled": r ? "" : void 0,
        disabled: r,
        ...o,
        ref: xh(t, a.triggerRef),
        onPointerDown: Te(e.onPointerDown, (u) => {
          !r && u.button === 0 && u.ctrlKey === !1 && (a.onOpenToggle(), a.open || u.preventDefault());
        }),
        onKeyDown: Te(e.onKeyDown, (u) => {
          r || (["Enter", " "].includes(u.key) && a.onOpenToggle(), u.key === "ArrowDown" && a.onOpenChange(!0), ["Enter", " ", "ArrowDown"].includes(u.key) && u.preventDefault());
        })
      }
    ) });
  }
);
mA.displayName = hA;
var gA = "DropdownMenuContent", yA = _.forwardRef(
  (e, t) => {
    const { __scopeDropdownMenu: n, ...r } = e, o = fA(gA, n), a = _n(n), l = _.useRef(!1);
    return /* @__PURE__ */ k.jsx(
      Aq,
      {
        id: o.contentId,
        "aria-labelledby": o.triggerId,
        ...a,
        ...r,
        ref: t,
        onCloseAutoFocus: Te(e.onCloseAutoFocus, (u) => {
          var d;
          l.current || (d = o.triggerRef.current) == null || d.focus(), l.current = !1, u.preventDefault();
        }),
        onInteractOutside: Te(e.onInteractOutside, (u) => {
          const d = u.detail.originalEvent, f = d.button === 0 && d.ctrlKey === !0, p = d.button === 2 || f;
          (!o.modal || p) && (l.current = !0);
        }),
        style: {
          ...e.style,
          "--radix-dropdown-menu-content-transform-origin": "var(--radix-popper-transform-origin)",
          "--radix-dropdown-menu-content-available-width": "var(--radix-popper-available-width)",
          "--radix-dropdown-menu-content-available-height": "var(--radix-popper-available-height)",
          "--radix-dropdown-menu-trigger-width": "var(--radix-popper-anchor-width)",
          "--radix-dropdown-menu-trigger-height": "var(--radix-popper-anchor-height)"
        }
      }
    );
  }
);
yA.displayName = gA;
var Yq = "DropdownMenuGroup", vA = _.forwardRef(
  (e, t) => {
    const { __scopeDropdownMenu: n, ...r } = e, o = _n(n);
    return /* @__PURE__ */ k.jsx(Rq, { ...o, ...r, ref: t });
  }
);
vA.displayName = Yq;
var qq = "DropdownMenuLabel", Xq = _.forwardRef(
  (e, t) => {
    const { __scopeDropdownMenu: n, ...r } = e, o = _n(n);
    return /* @__PURE__ */ k.jsx(jq, { ...o, ...r, ref: t });
  }
);
Xq.displayName = qq;
var Gq = "DropdownMenuItem", bA = _.forwardRef(
  (e, t) => {
    const { __scopeDropdownMenu: n, ...r } = e, o = _n(n);
    return /* @__PURE__ */ k.jsx(Dq, { ...o, ...r, ref: t });
  }
);
bA.displayName = Gq;
var Zq = "DropdownMenuCheckboxItem", Wq = _.forwardRef((e, t) => {
  const { __scopeDropdownMenu: n, ...r } = e, o = _n(n);
  return /* @__PURE__ */ k.jsx(Tq, { ...o, ...r, ref: t });
});
Wq.displayName = Zq;
var Kq = "DropdownMenuRadioGroup", wA = _.forwardRef((e, t) => {
  const { __scopeDropdownMenu: n, ...r } = e, o = _n(n);
  return /* @__PURE__ */ k.jsx(zq, { ...o, ...r, ref: t });
});
wA.displayName = Kq;
var Qq = "DropdownMenuRadioItem", xA = _.forwardRef((e, t) => {
  const { __scopeDropdownMenu: n, ...r } = e, o = _n(n);
  return /* @__PURE__ */ k.jsx(Pq, { ...o, ...r, ref: t });
});
xA.displayName = Qq;
var Jq = "DropdownMenuItemIndicator", eX = _.forwardRef((e, t) => {
  const { __scopeDropdownMenu: n, ...r } = e, o = _n(n);
  return /* @__PURE__ */ k.jsx(Lq, { ...o, ...r, ref: t });
});
eX.displayName = Jq;
var tX = "DropdownMenuSeparator", nX = _.forwardRef((e, t) => {
  const { __scopeDropdownMenu: n, ...r } = e, o = _n(n);
  return /* @__PURE__ */ k.jsx(Iq, { ...o, ...r, ref: t });
});
nX.displayName = tX;
var rX = "DropdownMenuArrow", oX = _.forwardRef(
  (e, t) => {
    const { __scopeDropdownMenu: n, ...r } = e, o = _n(n);
    return /* @__PURE__ */ k.jsx(Bq, { ...o, ...r, ref: t });
  }
);
oX.displayName = rX;
var iX = (e) => {
  const { __scopeDropdownMenu: t, children: n, open: r, onOpenChange: o, defaultOpen: a } = e, l = _n(t), [u = !1, d] = ys({
    prop: r,
    defaultProp: a,
    onChange: o
  });
  return /* @__PURE__ */ k.jsx(Vq, { ...l, open: u, onOpenChange: d, children: n });
}, aX = "DropdownMenuSubTrigger", SA = _.forwardRef((e, t) => {
  const { __scopeDropdownMenu: n, ...r } = e, o = _n(n);
  return /* @__PURE__ */ k.jsx(Hq, { ...o, ...r, ref: t });
});
SA.displayName = aX;
var lX = "DropdownMenuSubContent", kA = _.forwardRef((e, t) => {
  const { __scopeDropdownMenu: n, ...r } = e, o = _n(n);
  return /* @__PURE__ */ k.jsx(
    Uq,
    {
      ...o,
      ...r,
      ref: t,
      style: {
        ...e.style,
        "--radix-dropdown-menu-content-transform-origin": "var(--radix-popper-transform-origin)",
        "--radix-dropdown-menu-content-available-width": "var(--radix-popper-available-width)",
        "--radix-dropdown-menu-content-available-height": "var(--radix-popper-available-height)",
        "--radix-dropdown-menu-trigger-width": "var(--radix-popper-anchor-width)",
        "--radix-dropdown-menu-trigger-height": "var(--radix-popper-anchor-height)"
      }
    }
  );
});
kA.displayName = lX;
var _A = pA, EA = mA, CA = yA, OA = vA, Pi = bA, sX = wA, uX = xA, cX = iX, dX = SA, fX = kA;
const Ab = {
  xxs: 0,
  xs: 320,
  s: 480,
  m: 768,
  l: 960,
  xl: 1280,
  xxl: 1920
}, NA = _.createContext(void 0), pX = _.forwardRef((e, t) => {
  const { className: n, children: r, ...o } = e, [a, l] = _.useState("m"), [u, d] = _.useState(0), [f, p] = _.useState(0), m = _.useRef(null);
  _.useImperativeHandle(
    t,
    () => m.current,
    []
  );
  const g = _.useCallback((y) => {
    const w = y.width, v = y.height;
    let x = "xxs";
    Object.entries(Ab).forEach(([E, N]) => {
      w >= N && (x = E);
    }), l((E) => E !== x ? x : E), d(w), p(v);
  }, []);
  return _.useEffect(() => {
    const y = m.current;
    if (!y)
      return;
    const w = new ResizeObserver((v) => {
      for (let x of v)
        g(x.contentRect);
    });
    return w.observe(y), g(y.getBoundingClientRect()), () => {
      w.disconnect();
    };
  }, []), /* @__PURE__ */ k.jsx(NA.Provider, { value: { wKey: a, w: u, h: f }, children: /* @__PURE__ */ k.jsx(
    "div",
    {
      ref: m,
      className: `size-context w-${a} ${n || ""}`.trim(),
      ...o,
      children: r
    }
  ) });
}), hX = () => {
  const e = _.useContext(NA);
  if (!e)
    throw new Error(
      "useSizeContext must be used within a SizeContextContainerContext"
    );
  return e;
}, mX = (e, t) => e == t ? !1 : e == "" ? !0 : Ab[e] < Ab[t], gX = (e) => mX(hX().wKey, e), Kl = ({
  direction: e,
  className: t = "",
  children: n,
  wrap: r = !1,
  grow: o = !1,
  ...a
}) => {
  const l = "float-container";
  let u = "";
  typeof e == "string" ? u = `direction-${e} ` : typeof e == "object" && e !== null && Object.entries(e).forEach(([p, m]) => {
    p === "" ? u += `direction-${m} ` : u += `${p}-direction-${m} `;
  });
  let d = "";
  typeof o == "boolean" ? d = o ? "grow " : "" : typeof o == "object" && o !== null && Object.entries(o).forEach(([p, m]) => {
    p === "" ? d += m ? "grow " : "no-grow" : d += m ? `${p}-grow ` : `${p}-no-grow`;
  }), u += d, r && (u += "flex-wrap "), u = u.trim();
  const f = `${l} ${u} ${t}`.trim();
  return /* @__PURE__ */ k.jsx("div", { className: f, ...a, children: n });
}, MA = ({
  direction: e,
  expanded: t = !0,
  children: n,
  className: r,
  maxSize: o = "18.75rem",
  expanderSize: a = "2rem",
  containerStyle: l,
  style: u,
  containerClassName: d,
  onExpandChange: f,
  ...p
}) => {
  const m = {
    up: _b,
    down: gC,
    left: mC,
    right: kb
  }[e], g = {
    up: gC,
    down: _b,
    left: kb,
    right: mC
  }[e], [y, w] = _.useState(t), v = (V) => {
    y !== V && (w(V), f && f(V));
  }, x = `${e} ${y ? "expanded" : "collapsed"}`, E = e === "right" || e === "left" ? { width: y ? o : a } : { height: y ? o : a }, N = e === "right" || e === "left" ? { width: y ? o : 0 } : { height: y ? o : 0 }, C = e === "right" || e === "left" ? { width: a } : { height: a }, A = /* @__PURE__ */ k.jsx(
    "div",
    {
      className: `expanding_container_content ${x} ${r || ""}`.trim(),
      style: { ...u, ...N },
      ...p,
      children: n
    }
  ), R = /* @__PURE__ */ k.jsx(
    "div",
    {
      className: `expanding_container_expander ${x}`,
      onClick: () => v(!y),
      style: C,
      children: y ? /* @__PURE__ */ k.jsx(g, {}) : /* @__PURE__ */ k.jsx(m, {})
    }
  ), D = e === "right" || e === "down" ? A : R, T = e === "left" || e === "up" ? A : R;
  return /* @__PURE__ */ k.jsxs(
    "div",
    {
      className: `expanding_container ${x} ${d || ""}`,
      style: { ...l, ...E },
      children: [
        D,
        T
      ]
    }
  );
}, yX = ({
  trigger: e,
  setOpen: t,
  open: n
}) => {
  const [r, o] = _.useState(""), a = _.useContext(Ge);
  return a.options.useWorkerManager ? /* @__PURE__ */ k.jsxs(
    bs,
    {
      setOpen: t,
      open: n,
      trigger: e,
      title: "New Worker",
      description: "Create a new worker",
      children: [
        /* @__PURE__ */ k.jsxs("div", { children: [
          "Name:",
          /* @__PURE__ */ k.jsx("br", {}),
          /* @__PURE__ */ k.jsx(
            "input",
            {
              className: "styledinput",
              onChange: (l) => {
                o(l.currentTarget.value);
              },
              value: r
            }
          )
        ] }),
        /* @__PURE__ */ k.jsx("div", { children: r && /* @__PURE__ */ k.jsx("div", { children: /* @__PURE__ */ k.jsx(
          "button",
          {
            className: "styledbtn",
            onClick: () => {
              var l;
              (l = a.workermanager) == null || l.new_worker({
                name: r
                // reference: reference.uuid,
                // copyLib,
                // copyNS,
              }), t(!1);
            },
            children: "Create"
          }
        ) }) })
      ]
    }
  ) : null;
}, vX = ({
  trigger: e,
  setOpen: t,
  open: n
}) => {
  var r, o;
  const a = _.useContext(Ge), [l, u] = _.useState(!1), d = a.workers(), f = (r = a.worker) == null ? void 0 : r.uuid, p = (f ? (o = d[f]) == null ? void 0 : o.name : void 0) || f || "worker", m = async () => {
    if (!a.worker) return;
    const g = await a.worker.export({ withFiles: l });
    hV(g, p + ".fnw", "application/zip"), t(!1);
  };
  return /* @__PURE__ */ k.jsx(
    bs,
    {
      setOpen: t,
      open: n,
      trigger: e,
      title: "Export Worker",
      description: "Export the worker as a .fnw file",
      children: /* @__PURE__ */ k.jsxs("div", { children: [
        /* @__PURE__ */ k.jsxs("div", { children: [
          /* @__PURE__ */ k.jsx(
            "input",
            {
              type: "checkbox",
              className: "styledcheckbox",
              checked: l,
              onChange: (g) => {
                u(g.currentTarget.checked);
              }
            }
          ),
          "Include Files"
        ] }),
        /* @__PURE__ */ k.jsx("button", { className: "styledbtn", onClick: m, children: "Export" })
      ] })
    }
  );
}, bX = () => {
  const e = _.useContext(Ge).progress_state();
  return /* @__PURE__ */ k.jsxs("div", { className: "statusbar", children: [
    /* @__PURE__ */ k.jsx(
      "span",
      {
        className: "statusbar-progressbar",
        style: { width: Math.min(100, 100 * e.progress) + "%" }
      }
    ),
    /* @__PURE__ */ k.jsx("span", { className: "statusbar-message", children: e.message })
  ] });
}, wX = () => {
  var e;
  const t = _.useContext(Ge), n = t.workers(), [r, o] = _.useState(!1), [a, l] = _.useState(!1), u = (y) => {
    y !== "__select__" && t.workers && t.workermanager && n[y] && (!n[y].active && !window.confirm(
      "this is an inactive worker, selecting it will start it, continue?"
    ) || t.workermanager.set_active(y));
  }, d = async () => {
    if (!t.worker || !window.confirm(
      "Updateing the worker might replace the current nodespace, continue?"
    )) return;
    const y = await yV(".fnw");
    t.worker.update_from_export(y);
  }, f = t.options.useWorkerManager && t.workermanager && t.workermanager.open || Wv, p = f && Object.keys(n).length > 0, m = t.worker && t.worker.is_open, g = m && f;
  return f || m ? /* @__PURE__ */ k.jsxs(k.Fragment, { children: [
    /* @__PURE__ */ k.jsxs(_A, { children: [
      /* @__PURE__ */ k.jsx(EA, { asChild: !0, children: /* @__PURE__ */ k.jsx("button", { className: "styledbtn", children: /* @__PURE__ */ k.jsxs(Kl, { direction: "row", children: [
        "Worker ",
        /* @__PURE__ */ k.jsx(uM, {})
      ] }) }) }),
      /* @__PURE__ */ k.jsx(CA, { className: "headermenucontent funcnodescontainer", children: /* @__PURE__ */ k.jsxs(OA, { children: [
        p && /* @__PURE__ */ k.jsxs(cX, { children: [
          /* @__PURE__ */ k.jsx(dX, { className: "headermenuitem submenuitem", children: /* @__PURE__ */ k.jsxs(Kl, { direction: "row", children: [
            "Select",
            /* @__PURE__ */ k.jsx(kb, {})
          ] }) }),
          /* @__PURE__ */ k.jsx(
            fX,
            {
              className: "headermenucontent funcnodescontainer",
              sideOffset: 2,
              alignOffset: -5,
              children: /* @__PURE__ */ k.jsx(
                sX,
                {
                  value: (e = t.worker) == null ? void 0 : e.uuid,
                  onValueChange: (y) => {
                    u(y);
                  },
                  children: Object.keys(n).sort((y, w) => {
                    if (n[y].active && !n[w].active)
                      return -1;
                    if (!n[y].active && n[w].active)
                      return 1;
                    const v = n[y].name || y, x = n[w].name || w;
                    return v.localeCompare(x);
                  }).map((y) => {
                    var w, v, x;
                    return /* @__PURE__ */ k.jsx(
                      uX,
                      {
                        className: "headermenuitem workerselectoption" + ((w = n[y]) != null && w.active ? " active" : " inactive") + " headermenuitem",
                        value: y,
                        disabled: y === ((v = t.worker) == null ? void 0 : v.uuid),
                        children: ((x = n[y]) == null ? void 0 : x.name) || y
                      },
                      y
                    );
                  })
                }
              )
            }
          )
        ] }),
        m && /* @__PURE__ */ k.jsxs(k.Fragment, { children: [
          g && /* @__PURE__ */ k.jsx(
            Pi,
            {
              className: "headermenuitem",
              onClick: () => {
                var y;
                if (t.worker) {
                  if (!t.workermanager)
                    return t.logger.error("no workermanager");
                  (y = t.workermanager) == null || y.restart_worker(
                    t.worker.uuid
                  );
                }
              },
              children: "Restart"
            }
          ),
          /* @__PURE__ */ k.jsx(
            Pi,
            {
              className: "headermenuitem",
              onClick: () => {
                t.worker && t.worker.stop();
              },
              children: "Stop"
            }
          ),
          /* @__PURE__ */ k.jsx(
            Pi,
            {
              className: "headermenuitem",
              onClick: () => l(!0),
              children: "Export"
            }
          ),
          /* @__PURE__ */ k.jsx(
            Pi,
            {
              className: "headermenuitem",
              onClick: d,
              children: "Update"
            }
          )
        ] }),
        f && /* @__PURE__ */ k.jsx(k.Fragment, { children: /* @__PURE__ */ k.jsx(
          Pi,
          {
            className: "headermenuitem",
            onClick: () => o(!0),
            children: "New"
          }
        ) })
      ] }) })
    ] }),
    /* @__PURE__ */ k.jsx(
      yX,
      {
        open: r,
        setOpen: o
      }
    ),
    /* @__PURE__ */ k.jsx(
      vX,
      {
        open: a,
        setOpen: l
      }
    )
  ] }) : null;
}, xX = () => {
  const e = _.useContext(Ge), t = () => {
    var o;
    window.confirm("Are you sure you want to start a new flow?") && ((o = e.worker) == null || o.clear());
  }, n = async () => {
    var o;
    const a = await ((o = e.worker) == null ? void 0 : o.save());
    if (!a) return;
    const l = new Blob([JSON.stringify(a)], {
      type: "application/json"
    }), u = URL.createObjectURL(l), d = document.createElement("a");
    d.href = u, d.download = "flow.json", d.click(), URL.revokeObjectURL(u), d.remove();
  }, r = async () => {
    const o = document.createElement("input");
    o.type = "file", o.accept = ".json", o.onchange = async (a) => {
      var l;
      const u = (l = a.target.files) == null ? void 0 : l[0];
      if (!u) return;
      const d = new FileReader();
      d.onload = async (f) => {
        var p, m;
        const g = (p = f.target) == null ? void 0 : p.result;
        if (!g) return;
        const y = JSON.parse(g);
        await ((m = e.worker) == null ? void 0 : m.load(y));
      }, d.readAsText(u);
    }, o.click();
  };
  return /* @__PURE__ */ k.jsx(k.Fragment, { children: /* @__PURE__ */ k.jsxs(_A, { children: [
    /* @__PURE__ */ k.jsx(EA, { asChild: !0, children: /* @__PURE__ */ k.jsx("button", { className: "styledbtn", children: /* @__PURE__ */ k.jsxs(Kl, { direction: "row", children: [
      "Nodespace ",
      /* @__PURE__ */ k.jsx(uM, {})
    ] }) }) }),
    /* @__PURE__ */ k.jsx(CA, { className: "headermenucontent funcnodescontainer", children: /* @__PURE__ */ k.jsxs(OA, { children: [
      /* @__PURE__ */ k.jsx(Pi, { className: "headermenuitem", onClick: t, children: "New" }),
      /* @__PURE__ */ k.jsx(Pi, { className: "headermenuitem", onClick: n, children: "Save" }),
      /* @__PURE__ */ k.jsx(Pi, { className: "headermenuitem", onClick: r, children: "Load" })
    ] }) })
  ] }) });
}, SX = ({ ...e }) => {
  const t = _.useContext(Ge), n = t.workerstate();
  return Object.keys(e).length > 0 && t.logger.debug("headerprops", e), /* @__PURE__ */ k.jsxs(Kl, { className: "funcnodesreactflowheader", direction: "row", wrap: !0, children: [
    /* @__PURE__ */ k.jsx(
      Kl,
      {
        className: "headerelement m-w-6",
        grow: {
          "": !0,
          m: !1
        },
        children: /* @__PURE__ */ k.jsx(bX, {})
      }
    ),
    (e.showmenu || Wv) && /* @__PURE__ */ k.jsxs(Kl, { direction: "row", wrap: !0, children: [
      /* @__PURE__ */ k.jsx("div", { className: "headerelement", children: /* @__PURE__ */ k.jsx(wX, {}) }),
      (t.worker && n.is_open || Wv) && /* @__PURE__ */ k.jsx("div", { className: "headerelement", children: /* @__PURE__ */ k.jsx(xX, {}) })
    ] })
  ] });
};
function kX(e, t) {
  const n = {};
  return (e[e.length - 1] === "" ? [...e, ""] : e).join(
    (n.padRight ? " " : "") + "," + (n.padLeft === !1 ? "" : " ")
  ).trim();
}
const _X = /^[$_\p{ID_Start}][$_\u{200C}\u{200D}\p{ID_Continue}]*$/u, EX = /^[$_\p{ID_Start}][-$_\u{200C}\u{200D}\p{ID_Continue}]*$/u, CX = {};
function CC(e, t) {
  return (CX.jsx ? EX : _X).test(e);
}
const OX = /[ \t\n\f\r]/g;
function NX(e) {
  return typeof e == "object" ? e.type === "text" ? OC(e.value) : !1 : OC(e);
}
function OC(e) {
  return e.replace(OX, "") === "";
}
class qc {
  /**
   * @param {SchemaType['property']} property
   *   Property.
   * @param {SchemaType['normal']} normal
   *   Normal.
   * @param {Space | undefined} [space]
   *   Space.
   * @returns
   *   Schema.
   */
  constructor(t, n, r) {
    this.normal = n, this.property = t, r && (this.space = r);
  }
}
qc.prototype.normal = {};
qc.prototype.property = {};
qc.prototype.space = void 0;
function AA(e, t) {
  const n = {}, r = {};
  for (const o of e)
    Object.assign(n, o.property), Object.assign(r, o.normal);
  return new qc(n, r, t);
}
function Rb(e) {
  return e.toLowerCase();
}
class In {
  /**
   * @param {string} property
   *   Property.
   * @param {string} attribute
   *   Attribute.
   * @returns
   *   Info.
   */
  constructor(t, n) {
    this.attribute = n, this.property = t;
  }
}
In.prototype.attribute = "";
In.prototype.booleanish = !1;
In.prototype.boolean = !1;
In.prototype.commaOrSpaceSeparated = !1;
In.prototype.commaSeparated = !1;
In.prototype.defined = !1;
In.prototype.mustUseProperty = !1;
In.prototype.number = !1;
In.prototype.overloadedBoolean = !1;
In.prototype.property = "";
In.prototype.spaceSeparated = !1;
In.prototype.space = void 0;
let MX = 0;
const Ie = Ua(), Ft = Ua(), RA = Ua(), ge = Ua(), yt = Ua(), Ql = Ua(), Gn = Ua();
function Ua() {
  return 2 ** ++MX;
}
const jb = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  boolean: Ie,
  booleanish: Ft,
  commaOrSpaceSeparated: Gn,
  commaSeparated: Ql,
  number: ge,
  overloadedBoolean: RA,
  spaceSeparated: yt
}, Symbol.toStringTag, { value: "Module" })), av = (
  /** @type {ReadonlyArray<keyof typeof types>} */
  Object.keys(jb)
);
class dx extends In {
  /**
   * @constructor
   * @param {string} property
   *   Property.
   * @param {string} attribute
   *   Attribute.
   * @param {number | null | undefined} [mask]
   *   Mask.
   * @param {Space | undefined} [space]
   *   Space.
   * @returns
   *   Info.
   */
  constructor(t, n, r, o) {
    let a = -1;
    if (super(t, n), NC(this, "space", o), typeof r == "number")
      for (; ++a < av.length; ) {
        const l = av[a];
        NC(this, av[a], (r & jb[l]) === jb[l]);
      }
  }
}
dx.prototype.defined = !0;
function NC(e, t, n) {
  n && (e[t] = n);
}
function Ss(e) {
  const t = {}, n = {};
  for (const [r, o] of Object.entries(e.properties)) {
    const a = new dx(
      r,
      e.transform(e.attributes || {}, r),
      o,
      e.space
    );
    e.mustUseProperty && e.mustUseProperty.includes(r) && (a.mustUseProperty = !0), t[r] = a, n[Rb(r)] = r, n[Rb(a.attribute)] = r;
  }
  return new qc(t, n, e.space);
}
const jA = Ss({
  properties: {
    ariaActiveDescendant: null,
    ariaAtomic: Ft,
    ariaAutoComplete: null,
    ariaBusy: Ft,
    ariaChecked: Ft,
    ariaColCount: ge,
    ariaColIndex: ge,
    ariaColSpan: ge,
    ariaControls: yt,
    ariaCurrent: null,
    ariaDescribedBy: yt,
    ariaDetails: null,
    ariaDisabled: Ft,
    ariaDropEffect: yt,
    ariaErrorMessage: null,
    ariaExpanded: Ft,
    ariaFlowTo: yt,
    ariaGrabbed: Ft,
    ariaHasPopup: null,
    ariaHidden: Ft,
    ariaInvalid: null,
    ariaKeyShortcuts: null,
    ariaLabel: null,
    ariaLabelledBy: yt,
    ariaLevel: ge,
    ariaLive: null,
    ariaModal: Ft,
    ariaMultiLine: Ft,
    ariaMultiSelectable: Ft,
    ariaOrientation: null,
    ariaOwns: yt,
    ariaPlaceholder: null,
    ariaPosInSet: ge,
    ariaPressed: Ft,
    ariaReadOnly: Ft,
    ariaRelevant: null,
    ariaRequired: Ft,
    ariaRoleDescription: yt,
    ariaRowCount: ge,
    ariaRowIndex: ge,
    ariaRowSpan: ge,
    ariaSelected: Ft,
    ariaSetSize: ge,
    ariaSort: null,
    ariaValueMax: ge,
    ariaValueMin: ge,
    ariaValueNow: ge,
    ariaValueText: null,
    role: null
  },
  transform(e, t) {
    return t === "role" ? t : "aria-" + t.slice(4).toLowerCase();
  }
});
function DA(e, t) {
  return t in e ? e[t] : t;
}
function TA(e, t) {
  return DA(e, t.toLowerCase());
}
const AX = Ss({
  attributes: {
    acceptcharset: "accept-charset",
    classname: "class",
    htmlfor: "for",
    httpequiv: "http-equiv"
  },
  mustUseProperty: ["checked", "multiple", "muted", "selected"],
  properties: {
    // Standard Properties.
    abbr: null,
    accept: Ql,
    acceptCharset: yt,
    accessKey: yt,
    action: null,
    allow: null,
    allowFullScreen: Ie,
    allowPaymentRequest: Ie,
    allowUserMedia: Ie,
    alt: null,
    as: null,
    async: Ie,
    autoCapitalize: null,
    autoComplete: yt,
    autoFocus: Ie,
    autoPlay: Ie,
    blocking: yt,
    capture: null,
    charSet: null,
    checked: Ie,
    cite: null,
    className: yt,
    cols: ge,
    colSpan: null,
    content: null,
    contentEditable: Ft,
    controls: Ie,
    controlsList: yt,
    coords: ge | Ql,
    crossOrigin: null,
    data: null,
    dateTime: null,
    decoding: null,
    default: Ie,
    defer: Ie,
    dir: null,
    dirName: null,
    disabled: Ie,
    download: RA,
    draggable: Ft,
    encType: null,
    enterKeyHint: null,
    fetchPriority: null,
    form: null,
    formAction: null,
    formEncType: null,
    formMethod: null,
    formNoValidate: Ie,
    formTarget: null,
    headers: yt,
    height: ge,
    hidden: Ie,
    high: ge,
    href: null,
    hrefLang: null,
    htmlFor: yt,
    httpEquiv: yt,
    id: null,
    imageSizes: null,
    imageSrcSet: null,
    inert: Ie,
    inputMode: null,
    integrity: null,
    is: null,
    isMap: Ie,
    itemId: null,
    itemProp: yt,
    itemRef: yt,
    itemScope: Ie,
    itemType: yt,
    kind: null,
    label: null,
    lang: null,
    language: null,
    list: null,
    loading: null,
    loop: Ie,
    low: ge,
    manifest: null,
    max: null,
    maxLength: ge,
    media: null,
    method: null,
    min: null,
    minLength: ge,
    multiple: Ie,
    muted: Ie,
    name: null,
    nonce: null,
    noModule: Ie,
    noValidate: Ie,
    onAbort: null,
    onAfterPrint: null,
    onAuxClick: null,
    onBeforeMatch: null,
    onBeforePrint: null,
    onBeforeToggle: null,
    onBeforeUnload: null,
    onBlur: null,
    onCancel: null,
    onCanPlay: null,
    onCanPlayThrough: null,
    onChange: null,
    onClick: null,
    onClose: null,
    onContextLost: null,
    onContextMenu: null,
    onContextRestored: null,
    onCopy: null,
    onCueChange: null,
    onCut: null,
    onDblClick: null,
    onDrag: null,
    onDragEnd: null,
    onDragEnter: null,
    onDragExit: null,
    onDragLeave: null,
    onDragOver: null,
    onDragStart: null,
    onDrop: null,
    onDurationChange: null,
    onEmptied: null,
    onEnded: null,
    onError: null,
    onFocus: null,
    onFormData: null,
    onHashChange: null,
    onInput: null,
    onInvalid: null,
    onKeyDown: null,
    onKeyPress: null,
    onKeyUp: null,
    onLanguageChange: null,
    onLoad: null,
    onLoadedData: null,
    onLoadedMetadata: null,
    onLoadEnd: null,
    onLoadStart: null,
    onMessage: null,
    onMessageError: null,
    onMouseDown: null,
    onMouseEnter: null,
    onMouseLeave: null,
    onMouseMove: null,
    onMouseOut: null,
    onMouseOver: null,
    onMouseUp: null,
    onOffline: null,
    onOnline: null,
    onPageHide: null,
    onPageShow: null,
    onPaste: null,
    onPause: null,
    onPlay: null,
    onPlaying: null,
    onPopState: null,
    onProgress: null,
    onRateChange: null,
    onRejectionHandled: null,
    onReset: null,
    onResize: null,
    onScroll: null,
    onScrollEnd: null,
    onSecurityPolicyViolation: null,
    onSeeked: null,
    onSeeking: null,
    onSelect: null,
    onSlotChange: null,
    onStalled: null,
    onStorage: null,
    onSubmit: null,
    onSuspend: null,
    onTimeUpdate: null,
    onToggle: null,
    onUnhandledRejection: null,
    onUnload: null,
    onVolumeChange: null,
    onWaiting: null,
    onWheel: null,
    open: Ie,
    optimum: ge,
    pattern: null,
    ping: yt,
    placeholder: null,
    playsInline: Ie,
    popover: null,
    popoverTarget: null,
    popoverTargetAction: null,
    poster: null,
    preload: null,
    readOnly: Ie,
    referrerPolicy: null,
    rel: yt,
    required: Ie,
    reversed: Ie,
    rows: ge,
    rowSpan: ge,
    sandbox: yt,
    scope: null,
    scoped: Ie,
    seamless: Ie,
    selected: Ie,
    shadowRootClonable: Ie,
    shadowRootDelegatesFocus: Ie,
    shadowRootMode: null,
    shape: null,
    size: ge,
    sizes: null,
    slot: null,
    span: ge,
    spellCheck: Ft,
    src: null,
    srcDoc: null,
    srcLang: null,
    srcSet: null,
    start: ge,
    step: null,
    style: null,
    tabIndex: ge,
    target: null,
    title: null,
    translate: null,
    type: null,
    typeMustMatch: Ie,
    useMap: null,
    value: Ft,
    width: ge,
    wrap: null,
    writingSuggestions: null,
    // Legacy.
    // See: https://html.spec.whatwg.org/#other-elements,-attributes-and-apis
    align: null,
    // Several. Use CSS `text-align` instead,
    aLink: null,
    // `<body>`. Use CSS `a:active {color}` instead
    archive: yt,
    // `<object>`. List of URIs to archives
    axis: null,
    // `<td>` and `<th>`. Use `scope` on `<th>`
    background: null,
    // `<body>`. Use CSS `background-image` instead
    bgColor: null,
    // `<body>` and table elements. Use CSS `background-color` instead
    border: ge,
    // `<table>`. Use CSS `border-width` instead,
    borderColor: null,
    // `<table>`. Use CSS `border-color` instead,
    bottomMargin: ge,
    // `<body>`
    cellPadding: null,
    // `<table>`
    cellSpacing: null,
    // `<table>`
    char: null,
    // Several table elements. When `align=char`, sets the character to align on
    charOff: null,
    // Several table elements. When `char`, offsets the alignment
    classId: null,
    // `<object>`
    clear: null,
    // `<br>`. Use CSS `clear` instead
    code: null,
    // `<object>`
    codeBase: null,
    // `<object>`
    codeType: null,
    // `<object>`
    color: null,
    // `<font>` and `<hr>`. Use CSS instead
    compact: Ie,
    // Lists. Use CSS to reduce space between items instead
    declare: Ie,
    // `<object>`
    event: null,
    // `<script>`
    face: null,
    // `<font>`. Use CSS instead
    frame: null,
    // `<table>`
    frameBorder: null,
    // `<iframe>`. Use CSS `border` instead
    hSpace: ge,
    // `<img>` and `<object>`
    leftMargin: ge,
    // `<body>`
    link: null,
    // `<body>`. Use CSS `a:link {color: *}` instead
    longDesc: null,
    // `<frame>`, `<iframe>`, and `<img>`. Use an `<a>`
    lowSrc: null,
    // `<img>`. Use a `<picture>`
    marginHeight: ge,
    // `<body>`
    marginWidth: ge,
    // `<body>`
    noResize: Ie,
    // `<frame>`
    noHref: Ie,
    // `<area>`. Use no href instead of an explicit `nohref`
    noShade: Ie,
    // `<hr>`. Use background-color and height instead of borders
    noWrap: Ie,
    // `<td>` and `<th>`
    object: null,
    // `<applet>`
    profile: null,
    // `<head>`
    prompt: null,
    // `<isindex>`
    rev: null,
    // `<link>`
    rightMargin: ge,
    // `<body>`
    rules: null,
    // `<table>`
    scheme: null,
    // `<meta>`
    scrolling: Ft,
    // `<frame>`. Use overflow in the child context
    standby: null,
    // `<object>`
    summary: null,
    // `<table>`
    text: null,
    // `<body>`. Use CSS `color` instead
    topMargin: ge,
    // `<body>`
    valueType: null,
    // `<param>`
    version: null,
    // `<html>`. Use a doctype.
    vAlign: null,
    // Several. Use CSS `vertical-align` instead
    vLink: null,
    // `<body>`. Use CSS `a:visited {color}` instead
    vSpace: ge,
    // `<img>` and `<object>`
    // Non-standard Properties.
    allowTransparency: null,
    autoCorrect: null,
    autoSave: null,
    disablePictureInPicture: Ie,
    disableRemotePlayback: Ie,
    prefix: null,
    property: null,
    results: ge,
    security: null,
    unselectable: null
  },
  space: "html",
  transform: TA
}), RX = Ss({
  attributes: {
    accentHeight: "accent-height",
    alignmentBaseline: "alignment-baseline",
    arabicForm: "arabic-form",
    baselineShift: "baseline-shift",
    capHeight: "cap-height",
    className: "class",
    clipPath: "clip-path",
    clipRule: "clip-rule",
    colorInterpolation: "color-interpolation",
    colorInterpolationFilters: "color-interpolation-filters",
    colorProfile: "color-profile",
    colorRendering: "color-rendering",
    crossOrigin: "crossorigin",
    dataType: "datatype",
    dominantBaseline: "dominant-baseline",
    enableBackground: "enable-background",
    fillOpacity: "fill-opacity",
    fillRule: "fill-rule",
    floodColor: "flood-color",
    floodOpacity: "flood-opacity",
    fontFamily: "font-family",
    fontSize: "font-size",
    fontSizeAdjust: "font-size-adjust",
    fontStretch: "font-stretch",
    fontStyle: "font-style",
    fontVariant: "font-variant",
    fontWeight: "font-weight",
    glyphName: "glyph-name",
    glyphOrientationHorizontal: "glyph-orientation-horizontal",
    glyphOrientationVertical: "glyph-orientation-vertical",
    hrefLang: "hreflang",
    horizAdvX: "horiz-adv-x",
    horizOriginX: "horiz-origin-x",
    horizOriginY: "horiz-origin-y",
    imageRendering: "image-rendering",
    letterSpacing: "letter-spacing",
    lightingColor: "lighting-color",
    markerEnd: "marker-end",
    markerMid: "marker-mid",
    markerStart: "marker-start",
    navDown: "nav-down",
    navDownLeft: "nav-down-left",
    navDownRight: "nav-down-right",
    navLeft: "nav-left",
    navNext: "nav-next",
    navPrev: "nav-prev",
    navRight: "nav-right",
    navUp: "nav-up",
    navUpLeft: "nav-up-left",
    navUpRight: "nav-up-right",
    onAbort: "onabort",
    onActivate: "onactivate",
    onAfterPrint: "onafterprint",
    onBeforePrint: "onbeforeprint",
    onBegin: "onbegin",
    onCancel: "oncancel",
    onCanPlay: "oncanplay",
    onCanPlayThrough: "oncanplaythrough",
    onChange: "onchange",
    onClick: "onclick",
    onClose: "onclose",
    onCopy: "oncopy",
    onCueChange: "oncuechange",
    onCut: "oncut",
    onDblClick: "ondblclick",
    onDrag: "ondrag",
    onDragEnd: "ondragend",
    onDragEnter: "ondragenter",
    onDragExit: "ondragexit",
    onDragLeave: "ondragleave",
    onDragOver: "ondragover",
    onDragStart: "ondragstart",
    onDrop: "ondrop",
    onDurationChange: "ondurationchange",
    onEmptied: "onemptied",
    onEnd: "onend",
    onEnded: "onended",
    onError: "onerror",
    onFocus: "onfocus",
    onFocusIn: "onfocusin",
    onFocusOut: "onfocusout",
    onHashChange: "onhashchange",
    onInput: "oninput",
    onInvalid: "oninvalid",
    onKeyDown: "onkeydown",
    onKeyPress: "onkeypress",
    onKeyUp: "onkeyup",
    onLoad: "onload",
    onLoadedData: "onloadeddata",
    onLoadedMetadata: "onloadedmetadata",
    onLoadStart: "onloadstart",
    onMessage: "onmessage",
    onMouseDown: "onmousedown",
    onMouseEnter: "onmouseenter",
    onMouseLeave: "onmouseleave",
    onMouseMove: "onmousemove",
    onMouseOut: "onmouseout",
    onMouseOver: "onmouseover",
    onMouseUp: "onmouseup",
    onMouseWheel: "onmousewheel",
    onOffline: "onoffline",
    onOnline: "ononline",
    onPageHide: "onpagehide",
    onPageShow: "onpageshow",
    onPaste: "onpaste",
    onPause: "onpause",
    onPlay: "onplay",
    onPlaying: "onplaying",
    onPopState: "onpopstate",
    onProgress: "onprogress",
    onRateChange: "onratechange",
    onRepeat: "onrepeat",
    onReset: "onreset",
    onResize: "onresize",
    onScroll: "onscroll",
    onSeeked: "onseeked",
    onSeeking: "onseeking",
    onSelect: "onselect",
    onShow: "onshow",
    onStalled: "onstalled",
    onStorage: "onstorage",
    onSubmit: "onsubmit",
    onSuspend: "onsuspend",
    onTimeUpdate: "ontimeupdate",
    onToggle: "ontoggle",
    onUnload: "onunload",
    onVolumeChange: "onvolumechange",
    onWaiting: "onwaiting",
    onZoom: "onzoom",
    overlinePosition: "overline-position",
    overlineThickness: "overline-thickness",
    paintOrder: "paint-order",
    panose1: "panose-1",
    pointerEvents: "pointer-events",
    referrerPolicy: "referrerpolicy",
    renderingIntent: "rendering-intent",
    shapeRendering: "shape-rendering",
    stopColor: "stop-color",
    stopOpacity: "stop-opacity",
    strikethroughPosition: "strikethrough-position",
    strikethroughThickness: "strikethrough-thickness",
    strokeDashArray: "stroke-dasharray",
    strokeDashOffset: "stroke-dashoffset",
    strokeLineCap: "stroke-linecap",
    strokeLineJoin: "stroke-linejoin",
    strokeMiterLimit: "stroke-miterlimit",
    strokeOpacity: "stroke-opacity",
    strokeWidth: "stroke-width",
    tabIndex: "tabindex",
    textAnchor: "text-anchor",
    textDecoration: "text-decoration",
    textRendering: "text-rendering",
    transformOrigin: "transform-origin",
    typeOf: "typeof",
    underlinePosition: "underline-position",
    underlineThickness: "underline-thickness",
    unicodeBidi: "unicode-bidi",
    unicodeRange: "unicode-range",
    unitsPerEm: "units-per-em",
    vAlphabetic: "v-alphabetic",
    vHanging: "v-hanging",
    vIdeographic: "v-ideographic",
    vMathematical: "v-mathematical",
    vectorEffect: "vector-effect",
    vertAdvY: "vert-adv-y",
    vertOriginX: "vert-origin-x",
    vertOriginY: "vert-origin-y",
    wordSpacing: "word-spacing",
    writingMode: "writing-mode",
    xHeight: "x-height",
    // These were camelcased in Tiny. Now lowercased in SVG 2
    playbackOrder: "playbackorder",
    timelineBegin: "timelinebegin"
  },
  properties: {
    about: Gn,
    accentHeight: ge,
    accumulate: null,
    additive: null,
    alignmentBaseline: null,
    alphabetic: ge,
    amplitude: ge,
    arabicForm: null,
    ascent: ge,
    attributeName: null,
    attributeType: null,
    azimuth: ge,
    bandwidth: null,
    baselineShift: null,
    baseFrequency: null,
    baseProfile: null,
    bbox: null,
    begin: null,
    bias: ge,
    by: null,
    calcMode: null,
    capHeight: ge,
    className: yt,
    clip: null,
    clipPath: null,
    clipPathUnits: null,
    clipRule: null,
    color: null,
    colorInterpolation: null,
    colorInterpolationFilters: null,
    colorProfile: null,
    colorRendering: null,
    content: null,
    contentScriptType: null,
    contentStyleType: null,
    crossOrigin: null,
    cursor: null,
    cx: null,
    cy: null,
    d: null,
    dataType: null,
    defaultAction: null,
    descent: ge,
    diffuseConstant: ge,
    direction: null,
    display: null,
    dur: null,
    divisor: ge,
    dominantBaseline: null,
    download: Ie,
    dx: null,
    dy: null,
    edgeMode: null,
    editable: null,
    elevation: ge,
    enableBackground: null,
    end: null,
    event: null,
    exponent: ge,
    externalResourcesRequired: null,
    fill: null,
    fillOpacity: ge,
    fillRule: null,
    filter: null,
    filterRes: null,
    filterUnits: null,
    floodColor: null,
    floodOpacity: null,
    focusable: null,
    focusHighlight: null,
    fontFamily: null,
    fontSize: null,
    fontSizeAdjust: null,
    fontStretch: null,
    fontStyle: null,
    fontVariant: null,
    fontWeight: null,
    format: null,
    fr: null,
    from: null,
    fx: null,
    fy: null,
    g1: Ql,
    g2: Ql,
    glyphName: Ql,
    glyphOrientationHorizontal: null,
    glyphOrientationVertical: null,
    glyphRef: null,
    gradientTransform: null,
    gradientUnits: null,
    handler: null,
    hanging: ge,
    hatchContentUnits: null,
    hatchUnits: null,
    height: null,
    href: null,
    hrefLang: null,
    horizAdvX: ge,
    horizOriginX: ge,
    horizOriginY: ge,
    id: null,
    ideographic: ge,
    imageRendering: null,
    initialVisibility: null,
    in: null,
    in2: null,
    intercept: ge,
    k: ge,
    k1: ge,
    k2: ge,
    k3: ge,
    k4: ge,
    kernelMatrix: Gn,
    kernelUnitLength: null,
    keyPoints: null,
    // SEMI_COLON_SEPARATED
    keySplines: null,
    // SEMI_COLON_SEPARATED
    keyTimes: null,
    // SEMI_COLON_SEPARATED
    kerning: null,
    lang: null,
    lengthAdjust: null,
    letterSpacing: null,
    lightingColor: null,
    limitingConeAngle: ge,
    local: null,
    markerEnd: null,
    markerMid: null,
    markerStart: null,
    markerHeight: null,
    markerUnits: null,
    markerWidth: null,
    mask: null,
    maskContentUnits: null,
    maskUnits: null,
    mathematical: null,
    max: null,
    media: null,
    mediaCharacterEncoding: null,
    mediaContentEncodings: null,
    mediaSize: ge,
    mediaTime: null,
    method: null,
    min: null,
    mode: null,
    name: null,
    navDown: null,
    navDownLeft: null,
    navDownRight: null,
    navLeft: null,
    navNext: null,
    navPrev: null,
    navRight: null,
    navUp: null,
    navUpLeft: null,
    navUpRight: null,
    numOctaves: null,
    observer: null,
    offset: null,
    onAbort: null,
    onActivate: null,
    onAfterPrint: null,
    onBeforePrint: null,
    onBegin: null,
    onCancel: null,
    onCanPlay: null,
    onCanPlayThrough: null,
    onChange: null,
    onClick: null,
    onClose: null,
    onCopy: null,
    onCueChange: null,
    onCut: null,
    onDblClick: null,
    onDrag: null,
    onDragEnd: null,
    onDragEnter: null,
    onDragExit: null,
    onDragLeave: null,
    onDragOver: null,
    onDragStart: null,
    onDrop: null,
    onDurationChange: null,
    onEmptied: null,
    onEnd: null,
    onEnded: null,
    onError: null,
    onFocus: null,
    onFocusIn: null,
    onFocusOut: null,
    onHashChange: null,
    onInput: null,
    onInvalid: null,
    onKeyDown: null,
    onKeyPress: null,
    onKeyUp: null,
    onLoad: null,
    onLoadedData: null,
    onLoadedMetadata: null,
    onLoadStart: null,
    onMessage: null,
    onMouseDown: null,
    onMouseEnter: null,
    onMouseLeave: null,
    onMouseMove: null,
    onMouseOut: null,
    onMouseOver: null,
    onMouseUp: null,
    onMouseWheel: null,
    onOffline: null,
    onOnline: null,
    onPageHide: null,
    onPageShow: null,
    onPaste: null,
    onPause: null,
    onPlay: null,
    onPlaying: null,
    onPopState: null,
    onProgress: null,
    onRateChange: null,
    onRepeat: null,
    onReset: null,
    onResize: null,
    onScroll: null,
    onSeeked: null,
    onSeeking: null,
    onSelect: null,
    onShow: null,
    onStalled: null,
    onStorage: null,
    onSubmit: null,
    onSuspend: null,
    onTimeUpdate: null,
    onToggle: null,
    onUnload: null,
    onVolumeChange: null,
    onWaiting: null,
    onZoom: null,
    opacity: null,
    operator: null,
    order: null,
    orient: null,
    orientation: null,
    origin: null,
    overflow: null,
    overlay: null,
    overlinePosition: ge,
    overlineThickness: ge,
    paintOrder: null,
    panose1: null,
    path: null,
    pathLength: ge,
    patternContentUnits: null,
    patternTransform: null,
    patternUnits: null,
    phase: null,
    ping: yt,
    pitch: null,
    playbackOrder: null,
    pointerEvents: null,
    points: null,
    pointsAtX: ge,
    pointsAtY: ge,
    pointsAtZ: ge,
    preserveAlpha: null,
    preserveAspectRatio: null,
    primitiveUnits: null,
    propagate: null,
    property: Gn,
    r: null,
    radius: null,
    referrerPolicy: null,
    refX: null,
    refY: null,
    rel: Gn,
    rev: Gn,
    renderingIntent: null,
    repeatCount: null,
    repeatDur: null,
    requiredExtensions: Gn,
    requiredFeatures: Gn,
    requiredFonts: Gn,
    requiredFormats: Gn,
    resource: null,
    restart: null,
    result: null,
    rotate: null,
    rx: null,
    ry: null,
    scale: null,
    seed: null,
    shapeRendering: null,
    side: null,
    slope: null,
    snapshotTime: null,
    specularConstant: ge,
    specularExponent: ge,
    spreadMethod: null,
    spacing: null,
    startOffset: null,
    stdDeviation: null,
    stemh: null,
    stemv: null,
    stitchTiles: null,
    stopColor: null,
    stopOpacity: null,
    strikethroughPosition: ge,
    strikethroughThickness: ge,
    string: null,
    stroke: null,
    strokeDashArray: Gn,
    strokeDashOffset: null,
    strokeLineCap: null,
    strokeLineJoin: null,
    strokeMiterLimit: ge,
    strokeOpacity: ge,
    strokeWidth: null,
    style: null,
    surfaceScale: ge,
    syncBehavior: null,
    syncBehaviorDefault: null,
    syncMaster: null,
    syncTolerance: null,
    syncToleranceDefault: null,
    systemLanguage: Gn,
    tabIndex: ge,
    tableValues: null,
    target: null,
    targetX: ge,
    targetY: ge,
    textAnchor: null,
    textDecoration: null,
    textRendering: null,
    textLength: null,
    timelineBegin: null,
    title: null,
    transformBehavior: null,
    type: null,
    typeOf: Gn,
    to: null,
    transform: null,
    transformOrigin: null,
    u1: null,
    u2: null,
    underlinePosition: ge,
    underlineThickness: ge,
    unicode: null,
    unicodeBidi: null,
    unicodeRange: null,
    unitsPerEm: ge,
    values: null,
    vAlphabetic: ge,
    vMathematical: ge,
    vectorEffect: null,
    vHanging: ge,
    vIdeographic: ge,
    version: null,
    vertAdvY: ge,
    vertOriginX: ge,
    vertOriginY: ge,
    viewBox: null,
    viewTarget: null,
    visibility: null,
    width: null,
    widths: null,
    wordSpacing: null,
    writingMode: null,
    x: null,
    x1: null,
    x2: null,
    xChannelSelector: null,
    xHeight: ge,
    y: null,
    y1: null,
    y2: null,
    yChannelSelector: null,
    z: null,
    zoomAndPan: null
  },
  space: "svg",
  transform: DA
}), zA = Ss({
  properties: {
    xLinkActuate: null,
    xLinkArcRole: null,
    xLinkHref: null,
    xLinkRole: null,
    xLinkShow: null,
    xLinkTitle: null,
    xLinkType: null
  },
  space: "xlink",
  transform(e, t) {
    return "xlink:" + t.slice(5).toLowerCase();
  }
}), PA = Ss({
  attributes: { xmlnsxlink: "xmlns:xlink" },
  properties: { xmlnsXLink: null, xmlns: null },
  space: "xmlns",
  transform: TA
}), LA = Ss({
  properties: { xmlBase: null, xmlLang: null, xmlSpace: null },
  space: "xml",
  transform(e, t) {
    return "xml:" + t.slice(3).toLowerCase();
  }
}), jX = {
  classId: "classID",
  dataType: "datatype",
  itemId: "itemID",
  strokeDashArray: "strokeDasharray",
  strokeDashOffset: "strokeDashoffset",
  strokeLineCap: "strokeLinecap",
  strokeLineJoin: "strokeLinejoin",
  strokeMiterLimit: "strokeMiterlimit",
  typeOf: "typeof",
  xLinkActuate: "xlinkActuate",
  xLinkArcRole: "xlinkArcrole",
  xLinkHref: "xlinkHref",
  xLinkRole: "xlinkRole",
  xLinkShow: "xlinkShow",
  xLinkTitle: "xlinkTitle",
  xLinkType: "xlinkType",
  xmlnsXLink: "xmlnsXlink"
}, DX = /[A-Z]/g, MC = /-[a-z]/g, TX = /^data[-\w.:]+$/i;
function zX(e, t) {
  const n = Rb(t);
  let r = t, o = In;
  if (n in e.normal)
    return e.property[e.normal[n]];
  if (n.length > 4 && n.slice(0, 4) === "data" && TX.test(t)) {
    if (t.charAt(4) === "-") {
      const a = t.slice(5).replace(MC, LX);
      r = "data" + a.charAt(0).toUpperCase() + a.slice(1);
    } else {
      const a = t.slice(4);
      if (!MC.test(a)) {
        let l = a.replace(DX, PX);
        l.charAt(0) !== "-" && (l = "-" + l), t = "data" + l;
      }
    }
    o = dx;
  }
  return new o(r, t);
}
function PX(e) {
  return "-" + e.toLowerCase();
}
function LX(e) {
  return e.charAt(1).toUpperCase();
}
const IX = AA([jA, AX, zA, PA, LA], "html"), fx = AA([jA, RX, zA, PA, LA], "svg");
function BX(e) {
  return e.join(" ").trim();
}
var jl = {}, lv, AC;
function VX() {
  if (AC) return lv;
  AC = 1;
  var e = /\/\*[^*]*\*+([^/*][^*]*\*+)*\//g, t = /\n/g, n = /^\s*/, r = /^(\*?[-#/*\\\w]+(\[[0-9a-z_-]+\])?)\s*/, o = /^:\s*/, a = /^((?:'(?:\\'|.)*?'|"(?:\\"|.)*?"|\([^)]*?\)|[^};])+)/, l = /^[;\s]*/, u = /^\s+|\s+$/g, d = `
`, f = "/", p = "*", m = "", g = "comment", y = "declaration";
  lv = function(v, x) {
    if (typeof v != "string")
      throw new TypeError("First argument must be a string");
    if (!v) return [];
    x = x || {};
    var E = 1, N = 1;
    function C(G) {
      var z = G.match(t);
      z && (E += z.length);
      var $ = G.lastIndexOf(d);
      N = ~$ ? G.length - $ : N + G.length;
    }
    function A() {
      var G = { line: E, column: N };
      return function(z) {
        return z.position = new R(G), V(), z;
      };
    }
    function R(G) {
      this.start = G, this.end = { line: E, column: N }, this.source = x.source;
    }
    R.prototype.content = v;
    function D(G) {
      var z = new Error(
        x.source + ":" + E + ":" + N + ": " + G
      );
      if (z.reason = G, z.filename = x.source, z.line = E, z.column = N, z.source = v, !x.silent) throw z;
    }
    function T(G) {
      var z = G.exec(v);
      if (z) {
        var $ = z[0];
        return C($), v = v.slice($.length), z;
      }
    }
    function V() {
      T(n);
    }
    function F(G) {
      var z;
      for (G = G || []; z = O(); )
        z !== !1 && G.push(z);
      return G;
    }
    function O() {
      var G = A();
      if (!(f != v.charAt(0) || p != v.charAt(1))) {
        for (var z = 2; m != v.charAt(z) && (p != v.charAt(z) || f != v.charAt(z + 1)); )
          ++z;
        if (z += 2, m === v.charAt(z - 1))
          return D("End of comment missing");
        var $ = v.slice(2, z - 2);
        return N += 2, C($), v = v.slice(z), N += 2, G({
          type: g,
          comment: $
        });
      }
    }
    function B() {
      var G = A(), z = T(r);
      if (z) {
        if (O(), !T(o)) return D("property missing ':'");
        var $ = T(a), L = G({
          type: y,
          property: w(z[0].replace(e, m)),
          value: $ ? w($[0].replace(e, m)) : m
        });
        return T(l), L;
      }
    }
    function U() {
      var G = [];
      F(G);
      for (var z; z = B(); )
        z !== !1 && (G.push(z), F(G));
      return G;
    }
    return V(), U();
  };
  function w(v) {
    return v ? v.replace(u, m) : m;
  }
  return lv;
}
var RC;
function HX() {
  if (RC) return jl;
  RC = 1;
  var e = jl && jl.__importDefault || function(r) {
    return r && r.__esModule ? r : { default: r };
  };
  Object.defineProperty(jl, "__esModule", { value: !0 }), jl.default = n;
  var t = e(VX());
  function n(r, o) {
    var a = null;
    if (!r || typeof r != "string")
      return a;
    var l = (0, t.default)(r), u = typeof o == "function";
    return l.forEach(function(d) {
      if (d.type === "declaration") {
        var f = d.property, p = d.value;
        u ? o(f, p, d) : p && (a = a || {}, a[f] = p);
      }
    }), a;
  }
  return jl;
}
var Pu = {}, jC;
function UX() {
  if (jC) return Pu;
  jC = 1, Object.defineProperty(Pu, "__esModule", { value: !0 }), Pu.camelCase = void 0;
  var e = /^--[a-zA-Z0-9_-]+$/, t = /-([a-z])/g, n = /^[^-]+$/, r = /^-(webkit|moz|ms|o|khtml)-/, o = /^-(ms)-/, a = function(f) {
    return !f || n.test(f) || e.test(f);
  }, l = function(f, p) {
    return p.toUpperCase();
  }, u = function(f, p) {
    return "".concat(p, "-");
  }, d = function(f, p) {
    return p === void 0 && (p = {}), a(f) ? f : (f = f.toLowerCase(), p.reactCompat ? f = f.replace(o, u) : f = f.replace(r, u), f.replace(t, l));
  };
  return Pu.camelCase = d, Pu;
}
var Lu, DC;
function FX() {
  if (DC) return Lu;
  DC = 1;
  var e = Lu && Lu.__importDefault || function(o) {
    return o && o.__esModule ? o : { default: o };
  }, t = e(HX()), n = UX();
  function r(o, a) {
    var l = {};
    return !o || typeof o != "string" || (0, t.default)(o, function(u, d) {
      u && d && (l[(0, n.camelCase)(u, a)] = d);
    }), l;
  }
  return r.default = r, Lu = r, Lu;
}
var $X = FX();
const YX = /* @__PURE__ */ th($X), IA = BA("end"), px = BA("start");
function BA(e) {
  return t;
  function t(n) {
    const r = n && n.position && n.position[e] || {};
    if (typeof r.line == "number" && r.line > 0 && typeof r.column == "number" && r.column > 0)
      return {
        line: r.line,
        column: r.column,
        offset: typeof r.offset == "number" && r.offset > -1 ? r.offset : void 0
      };
  }
}
function qX(e) {
  const t = px(e), n = IA(e);
  if (t && n)
    return { start: t, end: n };
}
function ec(e) {
  return !e || typeof e != "object" ? "" : "position" in e || "type" in e ? TC(e.position) : "start" in e || "end" in e ? TC(e) : "line" in e || "column" in e ? Db(e) : "";
}
function Db(e) {
  return zC(e && e.line) + ":" + zC(e && e.column);
}
function TC(e) {
  return Db(e && e.start) + "-" + Db(e && e.end);
}
function zC(e) {
  return e && typeof e == "number" ? e : 1;
}
class yn extends Error {
  /**
   * Create a message for `reason`.
   *
   * >  **Note**: also has obsolete signatures.
   *
   * @overload
   * @param {string} reason
   * @param {Options | null | undefined} [options]
   * @returns
   *
   * @overload
   * @param {string} reason
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @overload
   * @param {string} reason
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @overload
   * @param {string} reason
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @param {Error | VFileMessage | string} causeOrReason
   *   Reason for message, should use markdown.
   * @param {Node | NodeLike | Options | Point | Position | string | null | undefined} [optionsOrParentOrPlace]
   *   Configuration (optional).
   * @param {string | null | undefined} [origin]
   *   Place in code where the message originates (example:
   *   `'my-package:my-rule'` or `'my-rule'`).
   * @returns
   *   Instance of `VFileMessage`.
   */
  // eslint-disable-next-line complexity
  constructor(t, n, r) {
    super(), typeof n == "string" && (r = n, n = void 0);
    let o = "", a = {}, l = !1;
    if (n && ("line" in n && "column" in n ? a = { place: n } : "start" in n && "end" in n ? a = { place: n } : "type" in n ? a = {
      ancestors: [n],
      place: n.position
    } : a = { ...n }), typeof t == "string" ? o = t : !a.cause && t && (l = !0, o = t.message, a.cause = t), !a.ruleId && !a.source && typeof r == "string") {
      const d = r.indexOf(":");
      d === -1 ? a.ruleId = r : (a.source = r.slice(0, d), a.ruleId = r.slice(d + 1));
    }
    if (!a.place && a.ancestors && a.ancestors) {
      const d = a.ancestors[a.ancestors.length - 1];
      d && (a.place = d.position);
    }
    const u = a.place && "start" in a.place ? a.place.start : a.place;
    this.ancestors = a.ancestors || void 0, this.cause = a.cause || void 0, this.column = u ? u.column : void 0, this.fatal = void 0, this.file, this.message = o, this.line = u ? u.line : void 0, this.name = ec(a.place) || "1:1", this.place = a.place || void 0, this.reason = this.message, this.ruleId = a.ruleId || void 0, this.source = a.source || void 0, this.stack = l && a.cause && typeof a.cause.stack == "string" ? a.cause.stack : "", this.actual, this.expected, this.note, this.url;
  }
}
yn.prototype.file = "";
yn.prototype.name = "";
yn.prototype.reason = "";
yn.prototype.message = "";
yn.prototype.stack = "";
yn.prototype.column = void 0;
yn.prototype.line = void 0;
yn.prototype.ancestors = void 0;
yn.prototype.cause = void 0;
yn.prototype.fatal = void 0;
yn.prototype.place = void 0;
yn.prototype.ruleId = void 0;
yn.prototype.source = void 0;
const hx = {}.hasOwnProperty, XX = /* @__PURE__ */ new Map(), GX = /[A-Z]/g, ZX = /* @__PURE__ */ new Set(["table", "tbody", "thead", "tfoot", "tr"]), WX = /* @__PURE__ */ new Set(["td", "th"]), VA = "https://github.com/syntax-tree/hast-util-to-jsx-runtime";
function KX(e, t) {
  if (!t || t.Fragment === void 0)
    throw new TypeError("Expected `Fragment` in options");
  const n = t.filePath || void 0;
  let r;
  if (t.development) {
    if (typeof t.jsxDEV != "function")
      throw new TypeError(
        "Expected `jsxDEV` in options when `development: true`"
      );
    r = iG(n, t.jsxDEV);
  } else {
    if (typeof t.jsx != "function")
      throw new TypeError("Expected `jsx` in production options");
    if (typeof t.jsxs != "function")
      throw new TypeError("Expected `jsxs` in production options");
    r = oG(n, t.jsx, t.jsxs);
  }
  const o = {
    Fragment: t.Fragment,
    ancestors: [],
    components: t.components || {},
    create: r,
    elementAttributeNameCase: t.elementAttributeNameCase || "react",
    evaluater: t.createEvaluater ? t.createEvaluater() : void 0,
    filePath: n,
    ignoreInvalidStyle: t.ignoreInvalidStyle || !1,
    passKeys: t.passKeys !== !1,
    passNode: t.passNode || !1,
    schema: t.space === "svg" ? fx : IX,
    stylePropertyNameCase: t.stylePropertyNameCase || "dom",
    tableCellAlignToStyle: t.tableCellAlignToStyle !== !1
  }, a = HA(o, e, void 0);
  return a && typeof a != "string" ? a : o.create(
    e,
    o.Fragment,
    { children: a || void 0 },
    void 0
  );
}
function HA(e, t, n) {
  if (t.type === "element")
    return QX(e, t, n);
  if (t.type === "mdxFlowExpression" || t.type === "mdxTextExpression")
    return JX(e, t);
  if (t.type === "mdxJsxFlowElement" || t.type === "mdxJsxTextElement")
    return tG(e, t, n);
  if (t.type === "mdxjsEsm")
    return eG(e, t);
  if (t.type === "root")
    return nG(e, t, n);
  if (t.type === "text")
    return rG(e, t);
}
function QX(e, t, n) {
  const r = e.schema;
  let o = r;
  t.tagName.toLowerCase() === "svg" && r.space === "html" && (o = fx, e.schema = o), e.ancestors.push(t);
  const a = FA(e, t.tagName, !1), l = aG(e, t);
  let u = gx(e, t);
  return ZX.has(t.tagName) && (u = u.filter(function(d) {
    return typeof d == "string" ? !NX(d) : !0;
  })), UA(e, l, a, t), mx(l, u), e.ancestors.pop(), e.schema = r, e.create(t, a, l, n);
}
function JX(e, t) {
  if (t.data && t.data.estree && e.evaluater) {
    const n = t.data.estree.body[0];
    return n.type, /** @type {Child | undefined} */
    e.evaluater.evaluateExpression(n.expression);
  }
  xc(e, t.position);
}
function eG(e, t) {
  if (t.data && t.data.estree && e.evaluater)
    return (
      /** @type {Child | undefined} */
      e.evaluater.evaluateProgram(t.data.estree)
    );
  xc(e, t.position);
}
function tG(e, t, n) {
  const r = e.schema;
  let o = r;
  t.name === "svg" && r.space === "html" && (o = fx, e.schema = o), e.ancestors.push(t);
  const a = t.name === null ? e.Fragment : FA(e, t.name, !0), l = lG(e, t), u = gx(e, t);
  return UA(e, l, a, t), mx(l, u), e.ancestors.pop(), e.schema = r, e.create(t, a, l, n);
}
function nG(e, t, n) {
  const r = {};
  return mx(r, gx(e, t)), e.create(t, e.Fragment, r, n);
}
function rG(e, t) {
  return t.value;
}
function UA(e, t, n, r) {
  typeof n != "string" && n !== e.Fragment && e.passNode && (t.node = r);
}
function mx(e, t) {
  if (t.length > 0) {
    const n = t.length > 1 ? t : t[0];
    n && (e.children = n);
  }
}
function oG(e, t, n) {
  return r;
  function r(o, a, l, u) {
    const d = Array.isArray(l.children) ? n : t;
    return u ? d(a, l, u) : d(a, l);
  }
}
function iG(e, t) {
  return n;
  function n(r, o, a, l) {
    const u = Array.isArray(a.children), d = px(r);
    return t(
      o,
      a,
      l,
      u,
      {
        columnNumber: d ? d.column - 1 : void 0,
        fileName: e,
        lineNumber: d ? d.line : void 0
      },
      void 0
    );
  }
}
function aG(e, t) {
  const n = {};
  let r, o;
  for (o in t.properties)
    if (o !== "children" && hx.call(t.properties, o)) {
      const a = sG(e, o, t.properties[o]);
      if (a) {
        const [l, u] = a;
        e.tableCellAlignToStyle && l === "align" && typeof u == "string" && WX.has(t.tagName) ? r = u : n[l] = u;
      }
    }
  if (r) {
    const a = (
      /** @type {Style} */
      n.style || (n.style = {})
    );
    a[e.stylePropertyNameCase === "css" ? "text-align" : "textAlign"] = r;
  }
  return n;
}
function lG(e, t) {
  const n = {};
  for (const r of t.attributes)
    if (r.type === "mdxJsxExpressionAttribute")
      if (r.data && r.data.estree && e.evaluater) {
        const o = r.data.estree.body[0];
        o.type;
        const a = o.expression;
        a.type;
        const l = a.properties[0];
        l.type, Object.assign(
          n,
          e.evaluater.evaluateExpression(l.argument)
        );
      } else
        xc(e, t.position);
    else {
      const o = r.name;
      let a;
      if (r.value && typeof r.value == "object")
        if (r.value.data && r.value.data.estree && e.evaluater) {
          const l = r.value.data.estree.body[0];
          l.type, a = e.evaluater.evaluateExpression(l.expression);
        } else
          xc(e, t.position);
      else
        a = r.value === null ? !0 : r.value;
      n[o] = /** @type {Props[keyof Props]} */
      a;
    }
  return n;
}
function gx(e, t) {
  const n = [];
  let r = -1;
  const o = e.passKeys ? /* @__PURE__ */ new Map() : XX;
  for (; ++r < t.children.length; ) {
    const a = t.children[r];
    let l;
    if (e.passKeys) {
      const d = a.type === "element" ? a.tagName : a.type === "mdxJsxFlowElement" || a.type === "mdxJsxTextElement" ? a.name : void 0;
      if (d) {
        const f = o.get(d) || 0;
        l = d + "-" + f, o.set(d, f + 1);
      }
    }
    const u = HA(e, a, l);
    u !== void 0 && n.push(u);
  }
  return n;
}
function sG(e, t, n) {
  const r = zX(e.schema, t);
  if (!(n == null || typeof n == "number" && Number.isNaN(n))) {
    if (Array.isArray(n) && (n = r.commaSeparated ? kX(n) : BX(n)), r.property === "style") {
      let o = typeof n == "object" ? n : uG(e, String(n));
      return e.stylePropertyNameCase === "css" && (o = cG(o)), ["style", o];
    }
    return [
      e.elementAttributeNameCase === "react" && r.space ? jX[r.property] || r.property : r.attribute,
      n
    ];
  }
}
function uG(e, t) {
  try {
    return YX(t, { reactCompat: !0 });
  } catch (n) {
    if (e.ignoreInvalidStyle)
      return {};
    const r = (
      /** @type {Error} */
      n
    ), o = new yn("Cannot parse `style` attribute", {
      ancestors: e.ancestors,
      cause: r,
      ruleId: "style",
      source: "hast-util-to-jsx-runtime"
    });
    throw o.file = e.filePath || void 0, o.url = VA + "#cannot-parse-style-attribute", o;
  }
}
function FA(e, t, n) {
  let r;
  if (!n)
    r = { type: "Literal", value: t };
  else if (t.includes(".")) {
    const o = t.split(".");
    let a = -1, l;
    for (; ++a < o.length; ) {
      const u = CC(o[a]) ? { type: "Identifier", name: o[a] } : { type: "Literal", value: o[a] };
      l = l ? {
        type: "MemberExpression",
        object: l,
        property: u,
        computed: !!(a && u.type === "Literal"),
        optional: !1
      } : u;
    }
    r = l;
  } else
    r = CC(t) && !/^[a-z]/.test(t) ? { type: "Identifier", name: t } : { type: "Literal", value: t };
  if (r.type === "Literal") {
    const o = (
      /** @type {string | number} */
      r.value
    );
    return hx.call(e.components, o) ? e.components[o] : o;
  }
  if (e.evaluater)
    return e.evaluater.evaluateExpression(r);
  xc(e);
}
function xc(e, t) {
  const n = new yn(
    "Cannot handle MDX estrees without `createEvaluater`",
    {
      ancestors: e.ancestors,
      place: t,
      ruleId: "mdx-estree",
      source: "hast-util-to-jsx-runtime"
    }
  );
  throw n.file = e.filePath || void 0, n.url = VA + "#cannot-handle-mdx-estrees-without-createevaluater", n;
}
function cG(e) {
  const t = {};
  let n;
  for (n in e)
    hx.call(e, n) && (t[dG(n)] = e[n]);
  return t;
}
function dG(e) {
  let t = e.replace(GX, fG);
  return t.slice(0, 3) === "ms-" && (t = "-" + t), t;
}
function fG(e) {
  return "-" + e.toLowerCase();
}
const sv = {
  action: ["form"],
  cite: ["blockquote", "del", "ins", "q"],
  data: ["object"],
  formAction: ["button", "input"],
  href: ["a", "area", "base", "link"],
  icon: ["menuitem"],
  itemId: null,
  manifest: ["html"],
  ping: ["a", "area"],
  poster: ["video"],
  src: [
    "audio",
    "embed",
    "iframe",
    "img",
    "input",
    "script",
    "source",
    "track",
    "video"
  ]
}, pG = {};
function yx(e, t) {
  const n = pG, r = typeof n.includeImageAlt == "boolean" ? n.includeImageAlt : !0, o = typeof n.includeHtml == "boolean" ? n.includeHtml : !0;
  return $A(e, r, o);
}
function $A(e, t, n) {
  if (hG(e)) {
    if ("value" in e)
      return e.type === "html" && !n ? "" : e.value;
    if (t && "alt" in e && e.alt)
      return e.alt;
    if ("children" in e)
      return PC(e.children, t, n);
  }
  return Array.isArray(e) ? PC(e, t, n) : "";
}
function PC(e, t, n) {
  const r = [];
  let o = -1;
  for (; ++o < e.length; )
    r[o] = $A(e[o], t, n);
  return r.join("");
}
function hG(e) {
  return !!(e && typeof e == "object");
}
const LC = document.createElement("i");
function vx(e) {
  const t = "&" + e + ";";
  LC.innerHTML = t;
  const n = LC.textContent;
  return (
    // @ts-expect-error: TypeScript is wrong that `textContent` on elements can
    // yield `null`.
    n.charCodeAt(n.length - 1) === 59 && e !== "semi" || n === t ? !1 : n
  );
}
function er(e, t, n, r) {
  const o = e.length;
  let a = 0, l;
  if (t < 0 ? t = -t > o ? 0 : o + t : t = t > o ? o : t, n = n > 0 ? n : 0, r.length < 1e4)
    l = Array.from(r), l.unshift(t, n), e.splice(...l);
  else
    for (n && e.splice(t, n); a < r.length; )
      l = r.slice(a, a + 1e4), l.unshift(t, 0), e.splice(...l), a += 1e4, t += 1e4;
}
function hr(e, t) {
  return e.length > 0 ? (er(e, e.length, 0, t), e) : t;
}
const IC = {}.hasOwnProperty;
function YA(e) {
  const t = {};
  let n = -1;
  for (; ++n < e.length; )
    mG(t, e[n]);
  return t;
}
function mG(e, t) {
  let n;
  for (n in t) {
    const r = (IC.call(e, n) ? e[n] : void 0) || (e[n] = {}), o = t[n];
    let a;
    if (o)
      for (a in o) {
        IC.call(r, a) || (r[a] = []);
        const l = o[a];
        gG(
          // @ts-expect-error Looks like a list.
          r[a],
          Array.isArray(l) ? l : l ? [l] : []
        );
      }
  }
}
function gG(e, t) {
  let n = -1;
  const r = [];
  for (; ++n < t.length; )
    (t[n].add === "after" ? e : r).push(t[n]);
  er(e, 0, 0, r);
}
function qA(e, t) {
  const n = Number.parseInt(e, t);
  return (
    // C0 except for HT, LF, FF, CR, space.
    n < 9 || n === 11 || n > 13 && n < 32 || // Control character (DEL) of C0, and C1 controls.
    n > 126 && n < 160 || // Lone high surrogates and low surrogates.
    n > 55295 && n < 57344 || // Noncharacters.
    n > 64975 && n < 65008 || /* eslint-disable no-bitwise */
    (n & 65535) === 65535 || (n & 65535) === 65534 || /* eslint-enable no-bitwise */
    // Out of range
    n > 1114111 ? "" : String.fromCodePoint(n)
  );
}
function Rr(e) {
  return e.replace(/[\t\n\r ]+/g, " ").replace(/^ | $/g, "").toLowerCase().toUpperCase();
}
const xn = Zi(/[A-Za-z]/), mn = Zi(/[\dA-Za-z]/), yG = Zi(/[#-'*+\--9=?A-Z^-~]/);
function Bp(e) {
  return (
    // Special whitespace codes (which have negative values), C0 and Control
    // character DEL
    e !== null && (e < 32 || e === 127)
  );
}
const Tb = Zi(/\d/), vG = Zi(/[\dA-Fa-f]/), bG = Zi(/[!-/:-@[-`{-~]/);
function Me(e) {
  return e !== null && e < -2;
}
function mt(e) {
  return e !== null && (e < 0 || e === 32);
}
function Xe(e) {
  return e === -2 || e === -1 || e === 32;
}
const Lh = Zi(new RegExp("\\p{P}|\\p{S}", "u")), La = Zi(/\s/);
function Zi(e) {
  return t;
  function t(n) {
    return n !== null && n > -1 && e.test(String.fromCharCode(n));
  }
}
function ks(e) {
  const t = [];
  let n = -1, r = 0, o = 0;
  for (; ++n < e.length; ) {
    const a = e.charCodeAt(n);
    let l = "";
    if (a === 37 && mn(e.charCodeAt(n + 1)) && mn(e.charCodeAt(n + 2)))
      o = 2;
    else if (a < 128)
      /[!#$&-;=?-Z_a-z~]/.test(String.fromCharCode(a)) || (l = String.fromCharCode(a));
    else if (a > 55295 && a < 57344) {
      const u = e.charCodeAt(n + 1);
      a < 56320 && u > 56319 && u < 57344 ? (l = String.fromCharCode(a, u), o = 1) : l = "";
    } else
      l = String.fromCharCode(a);
    l && (t.push(e.slice(r, n), encodeURIComponent(l)), r = n + o + 1, l = ""), o && (n += o, o = 0);
  }
  return t.join("") + e.slice(r);
}
function Ke(e, t, n, r) {
  const o = r ? r - 1 : Number.POSITIVE_INFINITY;
  let a = 0;
  return l;
  function l(d) {
    return Xe(d) ? (e.enter(n), u(d)) : t(d);
  }
  function u(d) {
    return Xe(d) && a++ < o ? (e.consume(d), u) : (e.exit(n), t(d));
  }
}
const wG = {
  tokenize: xG
};
function xG(e) {
  const t = e.attempt(this.parser.constructs.contentInitial, r, o);
  let n;
  return t;
  function r(u) {
    if (u === null) {
      e.consume(u);
      return;
    }
    return e.enter("lineEnding"), e.consume(u), e.exit("lineEnding"), Ke(e, t, "linePrefix");
  }
  function o(u) {
    return e.enter("paragraph"), a(u);
  }
  function a(u) {
    const d = e.enter("chunkText", {
      contentType: "text",
      previous: n
    });
    return n && (n.next = d), n = d, l(u);
  }
  function l(u) {
    if (u === null) {
      e.exit("chunkText"), e.exit("paragraph"), e.consume(u);
      return;
    }
    return Me(u) ? (e.consume(u), e.exit("chunkText"), a) : (e.consume(u), l);
  }
}
const SG = {
  tokenize: kG
}, BC = {
  tokenize: _G
};
function kG(e) {
  const t = this, n = [];
  let r = 0, o, a, l;
  return u;
  function u(C) {
    if (r < n.length) {
      const A = n[r];
      return t.containerState = A[1], e.attempt(A[0].continuation, d, f)(C);
    }
    return f(C);
  }
  function d(C) {
    if (r++, t.containerState._closeFlow) {
      t.containerState._closeFlow = void 0, o && N();
      const A = t.events.length;
      let R = A, D;
      for (; R--; )
        if (t.events[R][0] === "exit" && t.events[R][1].type === "chunkFlow") {
          D = t.events[R][1].end;
          break;
        }
      E(r);
      let T = A;
      for (; T < t.events.length; )
        t.events[T][1].end = {
          ...D
        }, T++;
      return er(t.events, R + 1, 0, t.events.slice(A)), t.events.length = T, f(C);
    }
    return u(C);
  }
  function f(C) {
    if (r === n.length) {
      if (!o)
        return g(C);
      if (o.currentConstruct && o.currentConstruct.concrete)
        return w(C);
      t.interrupt = !!(o.currentConstruct && !o._gfmTableDynamicInterruptHack);
    }
    return t.containerState = {}, e.check(BC, p, m)(C);
  }
  function p(C) {
    return o && N(), E(r), g(C);
  }
  function m(C) {
    return t.parser.lazy[t.now().line] = r !== n.length, l = t.now().offset, w(C);
  }
  function g(C) {
    return t.containerState = {}, e.attempt(BC, y, w)(C);
  }
  function y(C) {
    return r++, n.push([t.currentConstruct, t.containerState]), g(C);
  }
  function w(C) {
    if (C === null) {
      o && N(), E(0), e.consume(C);
      return;
    }
    return o = o || t.parser.flow(t.now()), e.enter("chunkFlow", {
      _tokenizer: o,
      contentType: "flow",
      previous: a
    }), v(C);
  }
  function v(C) {
    if (C === null) {
      x(e.exit("chunkFlow"), !0), E(0), e.consume(C);
      return;
    }
    return Me(C) ? (e.consume(C), x(e.exit("chunkFlow")), r = 0, t.interrupt = void 0, u) : (e.consume(C), v);
  }
  function x(C, A) {
    const R = t.sliceStream(C);
    if (A && R.push(null), C.previous = a, a && (a.next = C), a = C, o.defineSkip(C.start), o.write(R), t.parser.lazy[C.start.line]) {
      let D = o.events.length;
      for (; D--; )
        if (
          // The token starts before the line ending
          o.events[D][1].start.offset < l && // and either is not ended yet
          (!o.events[D][1].end || // or ends after it.
          o.events[D][1].end.offset > l)
        )
          return;
      const T = t.events.length;
      let V = T, F, O;
      for (; V--; )
        if (t.events[V][0] === "exit" && t.events[V][1].type === "chunkFlow") {
          if (F) {
            O = t.events[V][1].end;
            break;
          }
          F = !0;
        }
      for (E(r), D = T; D < t.events.length; )
        t.events[D][1].end = {
          ...O
        }, D++;
      er(t.events, V + 1, 0, t.events.slice(T)), t.events.length = D;
    }
  }
  function E(C) {
    let A = n.length;
    for (; A-- > C; ) {
      const R = n[A];
      t.containerState = R[1], R[0].exit.call(t, e);
    }
    n.length = C;
  }
  function N() {
    o.write([null]), a = void 0, o = void 0, t.containerState._closeFlow = void 0;
  }
}
function _G(e, t, n) {
  return Ke(e, e.attempt(this.parser.constructs.document, t, n), "linePrefix", this.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4);
}
function ds(e) {
  if (e === null || mt(e) || La(e))
    return 1;
  if (Lh(e))
    return 2;
}
function Ih(e, t, n) {
  const r = [];
  let o = -1;
  for (; ++o < e.length; ) {
    const a = e[o].resolveAll;
    a && !r.includes(a) && (t = a(t, n), r.push(a));
  }
  return t;
}
const zb = {
  name: "attention",
  resolveAll: EG,
  tokenize: CG
};
function EG(e, t) {
  let n = -1, r, o, a, l, u, d, f, p;
  for (; ++n < e.length; )
    if (e[n][0] === "enter" && e[n][1].type === "attentionSequence" && e[n][1]._close) {
      for (r = n; r--; )
        if (e[r][0] === "exit" && e[r][1].type === "attentionSequence" && e[r][1]._open && // If the markers are the same:
        t.sliceSerialize(e[r][1]).charCodeAt(0) === t.sliceSerialize(e[n][1]).charCodeAt(0)) {
          if ((e[r][1]._close || e[n][1]._open) && (e[n][1].end.offset - e[n][1].start.offset) % 3 && !((e[r][1].end.offset - e[r][1].start.offset + e[n][1].end.offset - e[n][1].start.offset) % 3))
            continue;
          d = e[r][1].end.offset - e[r][1].start.offset > 1 && e[n][1].end.offset - e[n][1].start.offset > 1 ? 2 : 1;
          const m = {
            ...e[r][1].end
          }, g = {
            ...e[n][1].start
          };
          VC(m, -d), VC(g, d), l = {
            type: d > 1 ? "strongSequence" : "emphasisSequence",
            start: m,
            end: {
              ...e[r][1].end
            }
          }, u = {
            type: d > 1 ? "strongSequence" : "emphasisSequence",
            start: {
              ...e[n][1].start
            },
            end: g
          }, a = {
            type: d > 1 ? "strongText" : "emphasisText",
            start: {
              ...e[r][1].end
            },
            end: {
              ...e[n][1].start
            }
          }, o = {
            type: d > 1 ? "strong" : "emphasis",
            start: {
              ...l.start
            },
            end: {
              ...u.end
            }
          }, e[r][1].end = {
            ...l.start
          }, e[n][1].start = {
            ...u.end
          }, f = [], e[r][1].end.offset - e[r][1].start.offset && (f = hr(f, [["enter", e[r][1], t], ["exit", e[r][1], t]])), f = hr(f, [["enter", o, t], ["enter", l, t], ["exit", l, t], ["enter", a, t]]), f = hr(f, Ih(t.parser.constructs.insideSpan.null, e.slice(r + 1, n), t)), f = hr(f, [["exit", a, t], ["enter", u, t], ["exit", u, t], ["exit", o, t]]), e[n][1].end.offset - e[n][1].start.offset ? (p = 2, f = hr(f, [["enter", e[n][1], t], ["exit", e[n][1], t]])) : p = 0, er(e, r - 1, n - r + 3, f), n = r + f.length - p - 2;
          break;
        }
    }
  for (n = -1; ++n < e.length; )
    e[n][1].type === "attentionSequence" && (e[n][1].type = "data");
  return e;
}
function CG(e, t) {
  const n = this.parser.constructs.attentionMarkers.null, r = this.previous, o = ds(r);
  let a;
  return l;
  function l(d) {
    return a = d, e.enter("attentionSequence"), u(d);
  }
  function u(d) {
    if (d === a)
      return e.consume(d), u;
    const f = e.exit("attentionSequence"), p = ds(d), m = !p || p === 2 && o || n.includes(d), g = !o || o === 2 && p || n.includes(r);
    return f._open = !!(a === 42 ? m : m && (o || !g)), f._close = !!(a === 42 ? g : g && (p || !m)), t(d);
  }
}
function VC(e, t) {
  e.column += t, e.offset += t, e._bufferIndex += t;
}
const OG = {
  name: "autolink",
  tokenize: NG
};
function NG(e, t, n) {
  let r = 0;
  return o;
  function o(y) {
    return e.enter("autolink"), e.enter("autolinkMarker"), e.consume(y), e.exit("autolinkMarker"), e.enter("autolinkProtocol"), a;
  }
  function a(y) {
    return xn(y) ? (e.consume(y), l) : y === 64 ? n(y) : f(y);
  }
  function l(y) {
    return y === 43 || y === 45 || y === 46 || mn(y) ? (r = 1, u(y)) : f(y);
  }
  function u(y) {
    return y === 58 ? (e.consume(y), r = 0, d) : (y === 43 || y === 45 || y === 46 || mn(y)) && r++ < 32 ? (e.consume(y), u) : (r = 0, f(y));
  }
  function d(y) {
    return y === 62 ? (e.exit("autolinkProtocol"), e.enter("autolinkMarker"), e.consume(y), e.exit("autolinkMarker"), e.exit("autolink"), t) : y === null || y === 32 || y === 60 || Bp(y) ? n(y) : (e.consume(y), d);
  }
  function f(y) {
    return y === 64 ? (e.consume(y), p) : yG(y) ? (e.consume(y), f) : n(y);
  }
  function p(y) {
    return mn(y) ? m(y) : n(y);
  }
  function m(y) {
    return y === 46 ? (e.consume(y), r = 0, p) : y === 62 ? (e.exit("autolinkProtocol").type = "autolinkEmail", e.enter("autolinkMarker"), e.consume(y), e.exit("autolinkMarker"), e.exit("autolink"), t) : g(y);
  }
  function g(y) {
    if ((y === 45 || mn(y)) && r++ < 63) {
      const w = y === 45 ? g : m;
      return e.consume(y), w;
    }
    return n(y);
  }
}
const Xc = {
  partial: !0,
  tokenize: MG
};
function MG(e, t, n) {
  return r;
  function r(a) {
    return Xe(a) ? Ke(e, o, "linePrefix")(a) : o(a);
  }
  function o(a) {
    return a === null || Me(a) ? t(a) : n(a);
  }
}
const XA = {
  continuation: {
    tokenize: RG
  },
  exit: jG,
  name: "blockQuote",
  tokenize: AG
};
function AG(e, t, n) {
  const r = this;
  return o;
  function o(l) {
    if (l === 62) {
      const u = r.containerState;
      return u.open || (e.enter("blockQuote", {
        _container: !0
      }), u.open = !0), e.enter("blockQuotePrefix"), e.enter("blockQuoteMarker"), e.consume(l), e.exit("blockQuoteMarker"), a;
    }
    return n(l);
  }
  function a(l) {
    return Xe(l) ? (e.enter("blockQuotePrefixWhitespace"), e.consume(l), e.exit("blockQuotePrefixWhitespace"), e.exit("blockQuotePrefix"), t) : (e.exit("blockQuotePrefix"), t(l));
  }
}
function RG(e, t, n) {
  const r = this;
  return o;
  function o(l) {
    return Xe(l) ? Ke(e, a, "linePrefix", r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(l) : a(l);
  }
  function a(l) {
    return e.attempt(XA, t, n)(l);
  }
}
function jG(e) {
  e.exit("blockQuote");
}
const GA = {
  name: "characterEscape",
  tokenize: DG
};
function DG(e, t, n) {
  return r;
  function r(a) {
    return e.enter("characterEscape"), e.enter("escapeMarker"), e.consume(a), e.exit("escapeMarker"), o;
  }
  function o(a) {
    return bG(a) ? (e.enter("characterEscapeValue"), e.consume(a), e.exit("characterEscapeValue"), e.exit("characterEscape"), t) : n(a);
  }
}
const ZA = {
  name: "characterReference",
  tokenize: TG
};
function TG(e, t, n) {
  const r = this;
  let o = 0, a, l;
  return u;
  function u(m) {
    return e.enter("characterReference"), e.enter("characterReferenceMarker"), e.consume(m), e.exit("characterReferenceMarker"), d;
  }
  function d(m) {
    return m === 35 ? (e.enter("characterReferenceMarkerNumeric"), e.consume(m), e.exit("characterReferenceMarkerNumeric"), f) : (e.enter("characterReferenceValue"), a = 31, l = mn, p(m));
  }
  function f(m) {
    return m === 88 || m === 120 ? (e.enter("characterReferenceMarkerHexadecimal"), e.consume(m), e.exit("characterReferenceMarkerHexadecimal"), e.enter("characterReferenceValue"), a = 6, l = vG, p) : (e.enter("characterReferenceValue"), a = 7, l = Tb, p(m));
  }
  function p(m) {
    if (m === 59 && o) {
      const g = e.exit("characterReferenceValue");
      return l === mn && !vx(r.sliceSerialize(g)) ? n(m) : (e.enter("characterReferenceMarker"), e.consume(m), e.exit("characterReferenceMarker"), e.exit("characterReference"), t);
    }
    return l(m) && o++ < a ? (e.consume(m), p) : n(m);
  }
}
const HC = {
  partial: !0,
  tokenize: PG
}, UC = {
  concrete: !0,
  name: "codeFenced",
  tokenize: zG
};
function zG(e, t, n) {
  const r = this, o = {
    partial: !0,
    tokenize: R
  };
  let a = 0, l = 0, u;
  return d;
  function d(D) {
    return f(D);
  }
  function f(D) {
    const T = r.events[r.events.length - 1];
    return a = T && T[1].type === "linePrefix" ? T[2].sliceSerialize(T[1], !0).length : 0, u = D, e.enter("codeFenced"), e.enter("codeFencedFence"), e.enter("codeFencedFenceSequence"), p(D);
  }
  function p(D) {
    return D === u ? (l++, e.consume(D), p) : l < 3 ? n(D) : (e.exit("codeFencedFenceSequence"), Xe(D) ? Ke(e, m, "whitespace")(D) : m(D));
  }
  function m(D) {
    return D === null || Me(D) ? (e.exit("codeFencedFence"), r.interrupt ? t(D) : e.check(HC, v, A)(D)) : (e.enter("codeFencedFenceInfo"), e.enter("chunkString", {
      contentType: "string"
    }), g(D));
  }
  function g(D) {
    return D === null || Me(D) ? (e.exit("chunkString"), e.exit("codeFencedFenceInfo"), m(D)) : Xe(D) ? (e.exit("chunkString"), e.exit("codeFencedFenceInfo"), Ke(e, y, "whitespace")(D)) : D === 96 && D === u ? n(D) : (e.consume(D), g);
  }
  function y(D) {
    return D === null || Me(D) ? m(D) : (e.enter("codeFencedFenceMeta"), e.enter("chunkString", {
      contentType: "string"
    }), w(D));
  }
  function w(D) {
    return D === null || Me(D) ? (e.exit("chunkString"), e.exit("codeFencedFenceMeta"), m(D)) : D === 96 && D === u ? n(D) : (e.consume(D), w);
  }
  function v(D) {
    return e.attempt(o, A, x)(D);
  }
  function x(D) {
    return e.enter("lineEnding"), e.consume(D), e.exit("lineEnding"), E;
  }
  function E(D) {
    return a > 0 && Xe(D) ? Ke(e, N, "linePrefix", a + 1)(D) : N(D);
  }
  function N(D) {
    return D === null || Me(D) ? e.check(HC, v, A)(D) : (e.enter("codeFlowValue"), C(D));
  }
  function C(D) {
    return D === null || Me(D) ? (e.exit("codeFlowValue"), N(D)) : (e.consume(D), C);
  }
  function A(D) {
    return e.exit("codeFenced"), t(D);
  }
  function R(D, T, V) {
    let F = 0;
    return O;
    function O($) {
      return D.enter("lineEnding"), D.consume($), D.exit("lineEnding"), B;
    }
    function B($) {
      return D.enter("codeFencedFence"), Xe($) ? Ke(D, U, "linePrefix", r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)($) : U($);
    }
    function U($) {
      return $ === u ? (D.enter("codeFencedFenceSequence"), G($)) : V($);
    }
    function G($) {
      return $ === u ? (F++, D.consume($), G) : F >= l ? (D.exit("codeFencedFenceSequence"), Xe($) ? Ke(D, z, "whitespace")($) : z($)) : V($);
    }
    function z($) {
      return $ === null || Me($) ? (D.exit("codeFencedFence"), T($)) : V($);
    }
  }
}
function PG(e, t, n) {
  const r = this;
  return o;
  function o(l) {
    return l === null ? n(l) : (e.enter("lineEnding"), e.consume(l), e.exit("lineEnding"), a);
  }
  function a(l) {
    return r.parser.lazy[r.now().line] ? n(l) : t(l);
  }
}
const uv = {
  name: "codeIndented",
  tokenize: IG
}, LG = {
  partial: !0,
  tokenize: BG
};
function IG(e, t, n) {
  const r = this;
  return o;
  function o(f) {
    return e.enter("codeIndented"), Ke(e, a, "linePrefix", 5)(f);
  }
  function a(f) {
    const p = r.events[r.events.length - 1];
    return p && p[1].type === "linePrefix" && p[2].sliceSerialize(p[1], !0).length >= 4 ? l(f) : n(f);
  }
  function l(f) {
    return f === null ? d(f) : Me(f) ? e.attempt(LG, l, d)(f) : (e.enter("codeFlowValue"), u(f));
  }
  function u(f) {
    return f === null || Me(f) ? (e.exit("codeFlowValue"), l(f)) : (e.consume(f), u);
  }
  function d(f) {
    return e.exit("codeIndented"), t(f);
  }
}
function BG(e, t, n) {
  const r = this;
  return o;
  function o(l) {
    return r.parser.lazy[r.now().line] ? n(l) : Me(l) ? (e.enter("lineEnding"), e.consume(l), e.exit("lineEnding"), o) : Ke(e, a, "linePrefix", 5)(l);
  }
  function a(l) {
    const u = r.events[r.events.length - 1];
    return u && u[1].type === "linePrefix" && u[2].sliceSerialize(u[1], !0).length >= 4 ? t(l) : Me(l) ? o(l) : n(l);
  }
}
const VG = {
  name: "codeText",
  previous: UG,
  resolve: HG,
  tokenize: FG
};
function HG(e) {
  let t = e.length - 4, n = 3, r, o;
  if ((e[n][1].type === "lineEnding" || e[n][1].type === "space") && (e[t][1].type === "lineEnding" || e[t][1].type === "space")) {
    for (r = n; ++r < t; )
      if (e[r][1].type === "codeTextData") {
        e[n][1].type = "codeTextPadding", e[t][1].type = "codeTextPadding", n += 2, t -= 2;
        break;
      }
  }
  for (r = n - 1, t++; ++r <= t; )
    o === void 0 ? r !== t && e[r][1].type !== "lineEnding" && (o = r) : (r === t || e[r][1].type === "lineEnding") && (e[o][1].type = "codeTextData", r !== o + 2 && (e[o][1].end = e[r - 1][1].end, e.splice(o + 2, r - o - 2), t -= r - o - 2, r = o + 2), o = void 0);
  return e;
}
function UG(e) {
  return e !== 96 || this.events[this.events.length - 1][1].type === "characterEscape";
}
function FG(e, t, n) {
  let r = 0, o, a;
  return l;
  function l(m) {
    return e.enter("codeText"), e.enter("codeTextSequence"), u(m);
  }
  function u(m) {
    return m === 96 ? (e.consume(m), r++, u) : (e.exit("codeTextSequence"), d(m));
  }
  function d(m) {
    return m === null ? n(m) : m === 32 ? (e.enter("space"), e.consume(m), e.exit("space"), d) : m === 96 ? (a = e.enter("codeTextSequence"), o = 0, p(m)) : Me(m) ? (e.enter("lineEnding"), e.consume(m), e.exit("lineEnding"), d) : (e.enter("codeTextData"), f(m));
  }
  function f(m) {
    return m === null || m === 32 || m === 96 || Me(m) ? (e.exit("codeTextData"), d(m)) : (e.consume(m), f);
  }
  function p(m) {
    return m === 96 ? (e.consume(m), o++, p) : o === r ? (e.exit("codeTextSequence"), e.exit("codeText"), t(m)) : (a.type = "codeTextData", f(m));
  }
}
class $G {
  /**
   * @param {ReadonlyArray<T> | null | undefined} [initial]
   *   Initial items (optional).
   * @returns
   *   Splice buffer.
   */
  constructor(t) {
    this.left = t ? [...t] : [], this.right = [];
  }
  /**
   * Array access;
   * does not move the cursor.
   *
   * @param {number} index
   *   Index.
   * @return {T}
   *   Item.
   */
  get(t) {
    if (t < 0 || t >= this.left.length + this.right.length)
      throw new RangeError("Cannot access index `" + t + "` in a splice buffer of size `" + (this.left.length + this.right.length) + "`");
    return t < this.left.length ? this.left[t] : this.right[this.right.length - t + this.left.length - 1];
  }
  /**
   * The length of the splice buffer, one greater than the largest index in the
   * array.
   */
  get length() {
    return this.left.length + this.right.length;
  }
  /**
   * Remove and return `list[0]`;
   * moves the cursor to `0`.
   *
   * @returns {T | undefined}
   *   Item, optional.
   */
  shift() {
    return this.setCursor(0), this.right.pop();
  }
  /**
   * Slice the buffer to get an array;
   * does not move the cursor.
   *
   * @param {number} start
   *   Start.
   * @param {number | null | undefined} [end]
   *   End (optional).
   * @returns {Array<T>}
   *   Array of items.
   */
  slice(t, n) {
    const r = n ?? Number.POSITIVE_INFINITY;
    return r < this.left.length ? this.left.slice(t, r) : t > this.left.length ? this.right.slice(this.right.length - r + this.left.length, this.right.length - t + this.left.length).reverse() : this.left.slice(t).concat(this.right.slice(this.right.length - r + this.left.length).reverse());
  }
  /**
   * Mimics the behavior of Array.prototype.splice() except for the change of
   * interface necessary to avoid segfaults when patching in very large arrays.
   *
   * This operation moves cursor is moved to `start` and results in the cursor
   * placed after any inserted items.
   *
   * @param {number} start
   *   Start;
   *   zero-based index at which to start changing the array;
   *   negative numbers count backwards from the end of the array and values
   *   that are out-of bounds are clamped to the appropriate end of the array.
   * @param {number | null | undefined} [deleteCount=0]
   *   Delete count (default: `0`);
   *   maximum number of elements to delete, starting from start.
   * @param {Array<T> | null | undefined} [items=[]]
   *   Items to include in place of the deleted items (default: `[]`).
   * @return {Array<T>}
   *   Any removed items.
   */
  splice(t, n, r) {
    const o = n || 0;
    this.setCursor(Math.trunc(t));
    const a = this.right.splice(this.right.length - o, Number.POSITIVE_INFINITY);
    return r && Iu(this.left, r), a.reverse();
  }
  /**
   * Remove and return the highest-numbered item in the array, so
   * `list[list.length - 1]`;
   * Moves the cursor to `length`.
   *
   * @returns {T | undefined}
   *   Item, optional.
   */
  pop() {
    return this.setCursor(Number.POSITIVE_INFINITY), this.left.pop();
  }
  /**
   * Inserts a single item to the high-numbered side of the array;
   * moves the cursor to `length`.
   *
   * @param {T} item
   *   Item.
   * @returns {undefined}
   *   Nothing.
   */
  push(t) {
    this.setCursor(Number.POSITIVE_INFINITY), this.left.push(t);
  }
  /**
   * Inserts many items to the high-numbered side of the array.
   * Moves the cursor to `length`.
   *
   * @param {Array<T>} items
   *   Items.
   * @returns {undefined}
   *   Nothing.
   */
  pushMany(t) {
    this.setCursor(Number.POSITIVE_INFINITY), Iu(this.left, t);
  }
  /**
   * Inserts a single item to the low-numbered side of the array;
   * Moves the cursor to `0`.
   *
   * @param {T} item
   *   Item.
   * @returns {undefined}
   *   Nothing.
   */
  unshift(t) {
    this.setCursor(0), this.right.push(t);
  }
  /**
   * Inserts many items to the low-numbered side of the array;
   * moves the cursor to `0`.
   *
   * @param {Array<T>} items
   *   Items.
   * @returns {undefined}
   *   Nothing.
   */
  unshiftMany(t) {
    this.setCursor(0), Iu(this.right, t.reverse());
  }
  /**
   * Move the cursor to a specific position in the array. Requires
   * time proportional to the distance moved.
   *
   * If `n < 0`, the cursor will end up at the beginning.
   * If `n > length`, the cursor will end up at the end.
   *
   * @param {number} n
   *   Position.
   * @return {undefined}
   *   Nothing.
   */
  setCursor(t) {
    if (!(t === this.left.length || t > this.left.length && this.right.length === 0 || t < 0 && this.left.length === 0))
      if (t < this.left.length) {
        const n = this.left.splice(t, Number.POSITIVE_INFINITY);
        Iu(this.right, n.reverse());
      } else {
        const n = this.right.splice(this.left.length + this.right.length - t, Number.POSITIVE_INFINITY);
        Iu(this.left, n.reverse());
      }
  }
}
function Iu(e, t) {
  let n = 0;
  if (t.length < 1e4)
    e.push(...t);
  else
    for (; n < t.length; )
      e.push(...t.slice(n, n + 1e4)), n += 1e4;
}
function WA(e) {
  const t = {};
  let n = -1, r, o, a, l, u, d, f;
  const p = new $G(e);
  for (; ++n < p.length; ) {
    for (; n in t; )
      n = t[n];
    if (r = p.get(n), n && r[1].type === "chunkFlow" && p.get(n - 1)[1].type === "listItemPrefix" && (d = r[1]._tokenizer.events, a = 0, a < d.length && d[a][1].type === "lineEndingBlank" && (a += 2), a < d.length && d[a][1].type === "content"))
      for (; ++a < d.length && d[a][1].type !== "content"; )
        d[a][1].type === "chunkText" && (d[a][1]._isInFirstContentOfListItem = !0, a++);
    if (r[0] === "enter")
      r[1].contentType && (Object.assign(t, YG(p, n)), n = t[n], f = !0);
    else if (r[1]._container) {
      for (a = n, o = void 0; a--; )
        if (l = p.get(a), l[1].type === "lineEnding" || l[1].type === "lineEndingBlank")
          l[0] === "enter" && (o && (p.get(o)[1].type = "lineEndingBlank"), l[1].type = "lineEnding", o = a);
        else if (!(l[1].type === "linePrefix" || l[1].type === "listItemIndent")) break;
      o && (r[1].end = {
        ...p.get(o)[1].start
      }, u = p.slice(o, n), u.unshift(r), p.splice(o, n - o + 1, u));
    }
  }
  return er(e, 0, Number.POSITIVE_INFINITY, p.slice(0)), !f;
}
function YG(e, t) {
  const n = e.get(t)[1], r = e.get(t)[2];
  let o = t - 1;
  const a = [];
  let l = n._tokenizer;
  l || (l = r.parser[n.contentType](n.start), n._contentTypeTextTrailing && (l._contentTypeTextTrailing = !0));
  const u = l.events, d = [], f = {};
  let p, m, g = -1, y = n, w = 0, v = 0;
  const x = [v];
  for (; y; ) {
    for (; e.get(++o)[1] !== y; )
      ;
    a.push(o), y._tokenizer || (p = r.sliceStream(y), y.next || p.push(null), m && l.defineSkip(y.start), y._isInFirstContentOfListItem && (l._gfmTasklistFirstContentOfListItem = !0), l.write(p), y._isInFirstContentOfListItem && (l._gfmTasklistFirstContentOfListItem = void 0)), m = y, y = y.next;
  }
  for (y = n; ++g < u.length; )
    u[g][0] === "exit" && u[g - 1][0] === "enter" && u[g][1].type === u[g - 1][1].type && u[g][1].start.line !== u[g][1].end.line && (v = g + 1, x.push(v), y._tokenizer = void 0, y.previous = void 0, y = y.next);
  for (l.events = [], y ? (y._tokenizer = void 0, y.previous = void 0) : x.pop(), g = x.length; g--; ) {
    const E = u.slice(x[g], x[g + 1]), N = a.pop();
    d.push([N, N + E.length - 1]), e.splice(N, 2, E);
  }
  for (d.reverse(), g = -1; ++g < d.length; )
    f[w + d[g][0]] = w + d[g][1], w += d[g][1] - d[g][0] - 1;
  return f;
}
const qG = {
  resolve: GG,
  tokenize: ZG
}, XG = {
  partial: !0,
  tokenize: WG
};
function GG(e) {
  return WA(e), e;
}
function ZG(e, t) {
  let n;
  return r;
  function r(u) {
    return e.enter("content"), n = e.enter("chunkContent", {
      contentType: "content"
    }), o(u);
  }
  function o(u) {
    return u === null ? a(u) : Me(u) ? e.check(XG, l, a)(u) : (e.consume(u), o);
  }
  function a(u) {
    return e.exit("chunkContent"), e.exit("content"), t(u);
  }
  function l(u) {
    return e.consume(u), e.exit("chunkContent"), n.next = e.enter("chunkContent", {
      contentType: "content",
      previous: n
    }), n = n.next, o;
  }
}
function WG(e, t, n) {
  const r = this;
  return o;
  function o(l) {
    return e.exit("chunkContent"), e.enter("lineEnding"), e.consume(l), e.exit("lineEnding"), Ke(e, a, "linePrefix");
  }
  function a(l) {
    if (l === null || Me(l))
      return n(l);
    const u = r.events[r.events.length - 1];
    return !r.parser.constructs.disable.null.includes("codeIndented") && u && u[1].type === "linePrefix" && u[2].sliceSerialize(u[1], !0).length >= 4 ? t(l) : e.interrupt(r.parser.constructs.flow, n, t)(l);
  }
}
function KA(e, t, n, r, o, a, l, u, d) {
  const f = d || Number.POSITIVE_INFINITY;
  let p = 0;
  return m;
  function m(E) {
    return E === 60 ? (e.enter(r), e.enter(o), e.enter(a), e.consume(E), e.exit(a), g) : E === null || E === 32 || E === 41 || Bp(E) ? n(E) : (e.enter(r), e.enter(l), e.enter(u), e.enter("chunkString", {
      contentType: "string"
    }), v(E));
  }
  function g(E) {
    return E === 62 ? (e.enter(a), e.consume(E), e.exit(a), e.exit(o), e.exit(r), t) : (e.enter(u), e.enter("chunkString", {
      contentType: "string"
    }), y(E));
  }
  function y(E) {
    return E === 62 ? (e.exit("chunkString"), e.exit(u), g(E)) : E === null || E === 60 || Me(E) ? n(E) : (e.consume(E), E === 92 ? w : y);
  }
  function w(E) {
    return E === 60 || E === 62 || E === 92 ? (e.consume(E), y) : y(E);
  }
  function v(E) {
    return !p && (E === null || E === 41 || mt(E)) ? (e.exit("chunkString"), e.exit(u), e.exit(l), e.exit(r), t(E)) : p < f && E === 40 ? (e.consume(E), p++, v) : E === 41 ? (e.consume(E), p--, v) : E === null || E === 32 || E === 40 || Bp(E) ? n(E) : (e.consume(E), E === 92 ? x : v);
  }
  function x(E) {
    return E === 40 || E === 41 || E === 92 ? (e.consume(E), v) : v(E);
  }
}
function QA(e, t, n, r, o, a) {
  const l = this;
  let u = 0, d;
  return f;
  function f(y) {
    return e.enter(r), e.enter(o), e.consume(y), e.exit(o), e.enter(a), p;
  }
  function p(y) {
    return u > 999 || y === null || y === 91 || y === 93 && !d || // To do: remove in the future once weve switched from
    // `micromark-extension-footnote` to `micromark-extension-gfm-footnote`,
    // which doesnt need this.
    // Hidden footnotes hook.
    /* c8 ignore next 3 */
    y === 94 && !u && "_hiddenFootnoteSupport" in l.parser.constructs ? n(y) : y === 93 ? (e.exit(a), e.enter(o), e.consume(y), e.exit(o), e.exit(r), t) : Me(y) ? (e.enter("lineEnding"), e.consume(y), e.exit("lineEnding"), p) : (e.enter("chunkString", {
      contentType: "string"
    }), m(y));
  }
  function m(y) {
    return y === null || y === 91 || y === 93 || Me(y) || u++ > 999 ? (e.exit("chunkString"), p(y)) : (e.consume(y), d || (d = !Xe(y)), y === 92 ? g : m);
  }
  function g(y) {
    return y === 91 || y === 92 || y === 93 ? (e.consume(y), u++, m) : m(y);
  }
}
function JA(e, t, n, r, o, a) {
  let l;
  return u;
  function u(g) {
    return g === 34 || g === 39 || g === 40 ? (e.enter(r), e.enter(o), e.consume(g), e.exit(o), l = g === 40 ? 41 : g, d) : n(g);
  }
  function d(g) {
    return g === l ? (e.enter(o), e.consume(g), e.exit(o), e.exit(r), t) : (e.enter(a), f(g));
  }
  function f(g) {
    return g === l ? (e.exit(a), d(l)) : g === null ? n(g) : Me(g) ? (e.enter("lineEnding"), e.consume(g), e.exit("lineEnding"), Ke(e, f, "linePrefix")) : (e.enter("chunkString", {
      contentType: "string"
    }), p(g));
  }
  function p(g) {
    return g === l || g === null || Me(g) ? (e.exit("chunkString"), f(g)) : (e.consume(g), g === 92 ? m : p);
  }
  function m(g) {
    return g === l || g === 92 ? (e.consume(g), p) : p(g);
  }
}
function tc(e, t) {
  let n;
  return r;
  function r(o) {
    return Me(o) ? (e.enter("lineEnding"), e.consume(o), e.exit("lineEnding"), n = !0, r) : Xe(o) ? Ke(e, r, n ? "linePrefix" : "lineSuffix")(o) : t(o);
  }
}
const KG = {
  name: "definition",
  tokenize: JG
}, QG = {
  partial: !0,
  tokenize: eZ
};
function JG(e, t, n) {
  const r = this;
  let o;
  return a;
  function a(y) {
    return e.enter("definition"), l(y);
  }
  function l(y) {
    return QA.call(
      r,
      e,
      u,
      // Note: we dont need to reset the way `markdown-rs` does.
      n,
      "definitionLabel",
      "definitionLabelMarker",
      "definitionLabelString"
    )(y);
  }
  function u(y) {
    return o = Rr(r.sliceSerialize(r.events[r.events.length - 1][1]).slice(1, -1)), y === 58 ? (e.enter("definitionMarker"), e.consume(y), e.exit("definitionMarker"), d) : n(y);
  }
  function d(y) {
    return mt(y) ? tc(e, f)(y) : f(y);
  }
  function f(y) {
    return KA(
      e,
      p,
      // Note: we dont need to reset the way `markdown-rs` does.
      n,
      "definitionDestination",
      "definitionDestinationLiteral",
      "definitionDestinationLiteralMarker",
      "definitionDestinationRaw",
      "definitionDestinationString"
    )(y);
  }
  function p(y) {
    return e.attempt(QG, m, m)(y);
  }
  function m(y) {
    return Xe(y) ? Ke(e, g, "whitespace")(y) : g(y);
  }
  function g(y) {
    return y === null || Me(y) ? (e.exit("definition"), r.parser.defined.push(o), t(y)) : n(y);
  }
}
function eZ(e, t, n) {
  return r;
  function r(u) {
    return mt(u) ? tc(e, o)(u) : n(u);
  }
  function o(u) {
    return JA(e, a, n, "definitionTitle", "definitionTitleMarker", "definitionTitleString")(u);
  }
  function a(u) {
    return Xe(u) ? Ke(e, l, "whitespace")(u) : l(u);
  }
  function l(u) {
    return u === null || Me(u) ? t(u) : n(u);
  }
}
const tZ = {
  name: "hardBreakEscape",
  tokenize: nZ
};
function nZ(e, t, n) {
  return r;
  function r(a) {
    return e.enter("hardBreakEscape"), e.consume(a), o;
  }
  function o(a) {
    return Me(a) ? (e.exit("hardBreakEscape"), t(a)) : n(a);
  }
}
const rZ = {
  name: "headingAtx",
  resolve: oZ,
  tokenize: iZ
};
function oZ(e, t) {
  let n = e.length - 2, r = 3, o, a;
  return e[r][1].type === "whitespace" && (r += 2), n - 2 > r && e[n][1].type === "whitespace" && (n -= 2), e[n][1].type === "atxHeadingSequence" && (r === n - 1 || n - 4 > r && e[n - 2][1].type === "whitespace") && (n -= r + 1 === n ? 2 : 4), n > r && (o = {
    type: "atxHeadingText",
    start: e[r][1].start,
    end: e[n][1].end
  }, a = {
    type: "chunkText",
    start: e[r][1].start,
    end: e[n][1].end,
    contentType: "text"
  }, er(e, r, n - r + 1, [["enter", o, t], ["enter", a, t], ["exit", a, t], ["exit", o, t]])), e;
}
function iZ(e, t, n) {
  let r = 0;
  return o;
  function o(p) {
    return e.enter("atxHeading"), a(p);
  }
  function a(p) {
    return e.enter("atxHeadingSequence"), l(p);
  }
  function l(p) {
    return p === 35 && r++ < 6 ? (e.consume(p), l) : p === null || mt(p) ? (e.exit("atxHeadingSequence"), u(p)) : n(p);
  }
  function u(p) {
    return p === 35 ? (e.enter("atxHeadingSequence"), d(p)) : p === null || Me(p) ? (e.exit("atxHeading"), t(p)) : Xe(p) ? Ke(e, u, "whitespace")(p) : (e.enter("atxHeadingText"), f(p));
  }
  function d(p) {
    return p === 35 ? (e.consume(p), d) : (e.exit("atxHeadingSequence"), u(p));
  }
  function f(p) {
    return p === null || p === 35 || mt(p) ? (e.exit("atxHeadingText"), u(p)) : (e.consume(p), f);
  }
}
const aZ = [
  "address",
  "article",
  "aside",
  "base",
  "basefont",
  "blockquote",
  "body",
  "caption",
  "center",
  "col",
  "colgroup",
  "dd",
  "details",
  "dialog",
  "dir",
  "div",
  "dl",
  "dt",
  "fieldset",
  "figcaption",
  "figure",
  "footer",
  "form",
  "frame",
  "frameset",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "head",
  "header",
  "hr",
  "html",
  "iframe",
  "legend",
  "li",
  "link",
  "main",
  "menu",
  "menuitem",
  "nav",
  "noframes",
  "ol",
  "optgroup",
  "option",
  "p",
  "param",
  "search",
  "section",
  "summary",
  "table",
  "tbody",
  "td",
  "tfoot",
  "th",
  "thead",
  "title",
  "tr",
  "track",
  "ul"
], FC = ["pre", "script", "style", "textarea"], lZ = {
  concrete: !0,
  name: "htmlFlow",
  resolveTo: cZ,
  tokenize: dZ
}, sZ = {
  partial: !0,
  tokenize: pZ
}, uZ = {
  partial: !0,
  tokenize: fZ
};
function cZ(e) {
  let t = e.length;
  for (; t-- && !(e[t][0] === "enter" && e[t][1].type === "htmlFlow"); )
    ;
  return t > 1 && e[t - 2][1].type === "linePrefix" && (e[t][1].start = e[t - 2][1].start, e[t + 1][1].start = e[t - 2][1].start, e.splice(t - 2, 2)), e;
}
function dZ(e, t, n) {
  const r = this;
  let o, a, l, u, d;
  return f;
  function f(P) {
    return p(P);
  }
  function p(P) {
    return e.enter("htmlFlow"), e.enter("htmlFlowData"), e.consume(P), m;
  }
  function m(P) {
    return P === 33 ? (e.consume(P), g) : P === 47 ? (e.consume(P), a = !0, v) : P === 63 ? (e.consume(P), o = 3, r.interrupt ? t : M) : xn(P) ? (e.consume(P), l = String.fromCharCode(P), x) : n(P);
  }
  function g(P) {
    return P === 45 ? (e.consume(P), o = 2, y) : P === 91 ? (e.consume(P), o = 5, u = 0, w) : xn(P) ? (e.consume(P), o = 4, r.interrupt ? t : M) : n(P);
  }
  function y(P) {
    return P === 45 ? (e.consume(P), r.interrupt ? t : M) : n(P);
  }
  function w(P) {
    const te = "CDATA[";
    return P === te.charCodeAt(u++) ? (e.consume(P), u === te.length ? r.interrupt ? t : U : w) : n(P);
  }
  function v(P) {
    return xn(P) ? (e.consume(P), l = String.fromCharCode(P), x) : n(P);
  }
  function x(P) {
    if (P === null || P === 47 || P === 62 || mt(P)) {
      const te = P === 47, ie = l.toLowerCase();
      return !te && !a && FC.includes(ie) ? (o = 1, r.interrupt ? t(P) : U(P)) : aZ.includes(l.toLowerCase()) ? (o = 6, te ? (e.consume(P), E) : r.interrupt ? t(P) : U(P)) : (o = 7, r.interrupt && !r.parser.lazy[r.now().line] ? n(P) : a ? N(P) : C(P));
    }
    return P === 45 || mn(P) ? (e.consume(P), l += String.fromCharCode(P), x) : n(P);
  }
  function E(P) {
    return P === 62 ? (e.consume(P), r.interrupt ? t : U) : n(P);
  }
  function N(P) {
    return Xe(P) ? (e.consume(P), N) : O(P);
  }
  function C(P) {
    return P === 47 ? (e.consume(P), O) : P === 58 || P === 95 || xn(P) ? (e.consume(P), A) : Xe(P) ? (e.consume(P), C) : O(P);
  }
  function A(P) {
    return P === 45 || P === 46 || P === 58 || P === 95 || mn(P) ? (e.consume(P), A) : R(P);
  }
  function R(P) {
    return P === 61 ? (e.consume(P), D) : Xe(P) ? (e.consume(P), R) : C(P);
  }
  function D(P) {
    return P === null || P === 60 || P === 61 || P === 62 || P === 96 ? n(P) : P === 34 || P === 39 ? (e.consume(P), d = P, T) : Xe(P) ? (e.consume(P), D) : V(P);
  }
  function T(P) {
    return P === d ? (e.consume(P), d = null, F) : P === null || Me(P) ? n(P) : (e.consume(P), T);
  }
  function V(P) {
    return P === null || P === 34 || P === 39 || P === 47 || P === 60 || P === 61 || P === 62 || P === 96 || mt(P) ? R(P) : (e.consume(P), V);
  }
  function F(P) {
    return P === 47 || P === 62 || Xe(P) ? C(P) : n(P);
  }
  function O(P) {
    return P === 62 ? (e.consume(P), B) : n(P);
  }
  function B(P) {
    return P === null || Me(P) ? U(P) : Xe(P) ? (e.consume(P), B) : n(P);
  }
  function U(P) {
    return P === 45 && o === 2 ? (e.consume(P), L) : P === 60 && o === 1 ? (e.consume(P), H) : P === 62 && o === 4 ? (e.consume(P), X) : P === 63 && o === 3 ? (e.consume(P), M) : P === 93 && o === 5 ? (e.consume(P), Y) : Me(P) && (o === 6 || o === 7) ? (e.exit("htmlFlowData"), e.check(sZ, Q, G)(P)) : P === null || Me(P) ? (e.exit("htmlFlowData"), G(P)) : (e.consume(P), U);
  }
  function G(P) {
    return e.check(uZ, z, Q)(P);
  }
  function z(P) {
    return e.enter("lineEnding"), e.consume(P), e.exit("lineEnding"), $;
  }
  function $(P) {
    return P === null || Me(P) ? G(P) : (e.enter("htmlFlowData"), U(P));
  }
  function L(P) {
    return P === 45 ? (e.consume(P), M) : U(P);
  }
  function H(P) {
    return P === 47 ? (e.consume(P), l = "", q) : U(P);
  }
  function q(P) {
    if (P === 62) {
      const te = l.toLowerCase();
      return FC.includes(te) ? (e.consume(P), X) : U(P);
    }
    return xn(P) && l.length < 8 ? (e.consume(P), l += String.fromCharCode(P), q) : U(P);
  }
  function Y(P) {
    return P === 93 ? (e.consume(P), M) : U(P);
  }
  function M(P) {
    return P === 62 ? (e.consume(P), X) : P === 45 && o === 2 ? (e.consume(P), M) : U(P);
  }
  function X(P) {
    return P === null || Me(P) ? (e.exit("htmlFlowData"), Q(P)) : (e.consume(P), X);
  }
  function Q(P) {
    return e.exit("htmlFlow"), t(P);
  }
}
function fZ(e, t, n) {
  const r = this;
  return o;
  function o(l) {
    return Me(l) ? (e.enter("lineEnding"), e.consume(l), e.exit("lineEnding"), a) : n(l);
  }
  function a(l) {
    return r.parser.lazy[r.now().line] ? n(l) : t(l);
  }
}
function pZ(e, t, n) {
  return r;
  function r(o) {
    return e.enter("lineEnding"), e.consume(o), e.exit("lineEnding"), e.attempt(Xc, t, n);
  }
}
const hZ = {
  name: "htmlText",
  tokenize: mZ
};
function mZ(e, t, n) {
  const r = this;
  let o, a, l;
  return u;
  function u(M) {
    return e.enter("htmlText"), e.enter("htmlTextData"), e.consume(M), d;
  }
  function d(M) {
    return M === 33 ? (e.consume(M), f) : M === 47 ? (e.consume(M), R) : M === 63 ? (e.consume(M), C) : xn(M) ? (e.consume(M), V) : n(M);
  }
  function f(M) {
    return M === 45 ? (e.consume(M), p) : M === 91 ? (e.consume(M), a = 0, w) : xn(M) ? (e.consume(M), N) : n(M);
  }
  function p(M) {
    return M === 45 ? (e.consume(M), y) : n(M);
  }
  function m(M) {
    return M === null ? n(M) : M === 45 ? (e.consume(M), g) : Me(M) ? (l = m, H(M)) : (e.consume(M), m);
  }
  function g(M) {
    return M === 45 ? (e.consume(M), y) : m(M);
  }
  function y(M) {
    return M === 62 ? L(M) : M === 45 ? g(M) : m(M);
  }
  function w(M) {
    const X = "CDATA[";
    return M === X.charCodeAt(a++) ? (e.consume(M), a === X.length ? v : w) : n(M);
  }
  function v(M) {
    return M === null ? n(M) : M === 93 ? (e.consume(M), x) : Me(M) ? (l = v, H(M)) : (e.consume(M), v);
  }
  function x(M) {
    return M === 93 ? (e.consume(M), E) : v(M);
  }
  function E(M) {
    return M === 62 ? L(M) : M === 93 ? (e.consume(M), E) : v(M);
  }
  function N(M) {
    return M === null || M === 62 ? L(M) : Me(M) ? (l = N, H(M)) : (e.consume(M), N);
  }
  function C(M) {
    return M === null ? n(M) : M === 63 ? (e.consume(M), A) : Me(M) ? (l = C, H(M)) : (e.consume(M), C);
  }
  function A(M) {
    return M === 62 ? L(M) : C(M);
  }
  function R(M) {
    return xn(M) ? (e.consume(M), D) : n(M);
  }
  function D(M) {
    return M === 45 || mn(M) ? (e.consume(M), D) : T(M);
  }
  function T(M) {
    return Me(M) ? (l = T, H(M)) : Xe(M) ? (e.consume(M), T) : L(M);
  }
  function V(M) {
    return M === 45 || mn(M) ? (e.consume(M), V) : M === 47 || M === 62 || mt(M) ? F(M) : n(M);
  }
  function F(M) {
    return M === 47 ? (e.consume(M), L) : M === 58 || M === 95 || xn(M) ? (e.consume(M), O) : Me(M) ? (l = F, H(M)) : Xe(M) ? (e.consume(M), F) : L(M);
  }
  function O(M) {
    return M === 45 || M === 46 || M === 58 || M === 95 || mn(M) ? (e.consume(M), O) : B(M);
  }
  function B(M) {
    return M === 61 ? (e.consume(M), U) : Me(M) ? (l = B, H(M)) : Xe(M) ? (e.consume(M), B) : F(M);
  }
  function U(M) {
    return M === null || M === 60 || M === 61 || M === 62 || M === 96 ? n(M) : M === 34 || M === 39 ? (e.consume(M), o = M, G) : Me(M) ? (l = U, H(M)) : Xe(M) ? (e.consume(M), U) : (e.consume(M), z);
  }
  function G(M) {
    return M === o ? (e.consume(M), o = void 0, $) : M === null ? n(M) : Me(M) ? (l = G, H(M)) : (e.consume(M), G);
  }
  function z(M) {
    return M === null || M === 34 || M === 39 || M === 60 || M === 61 || M === 96 ? n(M) : M === 47 || M === 62 || mt(M) ? F(M) : (e.consume(M), z);
  }
  function $(M) {
    return M === 47 || M === 62 || mt(M) ? F(M) : n(M);
  }
  function L(M) {
    return M === 62 ? (e.consume(M), e.exit("htmlTextData"), e.exit("htmlText"), t) : n(M);
  }
  function H(M) {
    return e.exit("htmlTextData"), e.enter("lineEnding"), e.consume(M), e.exit("lineEnding"), q;
  }
  function q(M) {
    return Xe(M) ? Ke(e, Y, "linePrefix", r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(M) : Y(M);
  }
  function Y(M) {
    return e.enter("htmlTextData"), l(M);
  }
}
const bx = {
  name: "labelEnd",
  resolveAll: bZ,
  resolveTo: wZ,
  tokenize: xZ
}, gZ = {
  tokenize: SZ
}, yZ = {
  tokenize: kZ
}, vZ = {
  tokenize: _Z
};
function bZ(e) {
  let t = -1;
  const n = [];
  for (; ++t < e.length; ) {
    const r = e[t][1];
    if (n.push(e[t]), r.type === "labelImage" || r.type === "labelLink" || r.type === "labelEnd") {
      const o = r.type === "labelImage" ? 4 : 2;
      r.type = "data", t += o;
    }
  }
  return e.length !== n.length && er(e, 0, e.length, n), e;
}
function wZ(e, t) {
  let n = e.length, r = 0, o, a, l, u;
  for (; n--; )
    if (o = e[n][1], a) {
      if (o.type === "link" || o.type === "labelLink" && o._inactive)
        break;
      e[n][0] === "enter" && o.type === "labelLink" && (o._inactive = !0);
    } else if (l) {
      if (e[n][0] === "enter" && (o.type === "labelImage" || o.type === "labelLink") && !o._balanced && (a = n, o.type !== "labelLink")) {
        r = 2;
        break;
      }
    } else o.type === "labelEnd" && (l = n);
  const d = {
    type: e[a][1].type === "labelLink" ? "link" : "image",
    start: {
      ...e[a][1].start
    },
    end: {
      ...e[e.length - 1][1].end
    }
  }, f = {
    type: "label",
    start: {
      ...e[a][1].start
    },
    end: {
      ...e[l][1].end
    }
  }, p = {
    type: "labelText",
    start: {
      ...e[a + r + 2][1].end
    },
    end: {
      ...e[l - 2][1].start
    }
  };
  return u = [["enter", d, t], ["enter", f, t]], u = hr(u, e.slice(a + 1, a + r + 3)), u = hr(u, [["enter", p, t]]), u = hr(u, Ih(t.parser.constructs.insideSpan.null, e.slice(a + r + 4, l - 3), t)), u = hr(u, [["exit", p, t], e[l - 2], e[l - 1], ["exit", f, t]]), u = hr(u, e.slice(l + 1)), u = hr(u, [["exit", d, t]]), er(e, a, e.length, u), e;
}
function xZ(e, t, n) {
  const r = this;
  let o = r.events.length, a, l;
  for (; o--; )
    if ((r.events[o][1].type === "labelImage" || r.events[o][1].type === "labelLink") && !r.events[o][1]._balanced) {
      a = r.events[o][1];
      break;
    }
  return u;
  function u(g) {
    return a ? a._inactive ? m(g) : (l = r.parser.defined.includes(Rr(r.sliceSerialize({
      start: a.end,
      end: r.now()
    }))), e.enter("labelEnd"), e.enter("labelMarker"), e.consume(g), e.exit("labelMarker"), e.exit("labelEnd"), d) : n(g);
  }
  function d(g) {
    return g === 40 ? e.attempt(gZ, p, l ? p : m)(g) : g === 91 ? e.attempt(yZ, p, l ? f : m)(g) : l ? p(g) : m(g);
  }
  function f(g) {
    return e.attempt(vZ, p, m)(g);
  }
  function p(g) {
    return t(g);
  }
  function m(g) {
    return a._balanced = !0, n(g);
  }
}
function SZ(e, t, n) {
  return r;
  function r(m) {
    return e.enter("resource"), e.enter("resourceMarker"), e.consume(m), e.exit("resourceMarker"), o;
  }
  function o(m) {
    return mt(m) ? tc(e, a)(m) : a(m);
  }
  function a(m) {
    return m === 41 ? p(m) : KA(e, l, u, "resourceDestination", "resourceDestinationLiteral", "resourceDestinationLiteralMarker", "resourceDestinationRaw", "resourceDestinationString", 32)(m);
  }
  function l(m) {
    return mt(m) ? tc(e, d)(m) : p(m);
  }
  function u(m) {
    return n(m);
  }
  function d(m) {
    return m === 34 || m === 39 || m === 40 ? JA(e, f, n, "resourceTitle", "resourceTitleMarker", "resourceTitleString")(m) : p(m);
  }
  function f(m) {
    return mt(m) ? tc(e, p)(m) : p(m);
  }
  function p(m) {
    return m === 41 ? (e.enter("resourceMarker"), e.consume(m), e.exit("resourceMarker"), e.exit("resource"), t) : n(m);
  }
}
function kZ(e, t, n) {
  const r = this;
  return o;
  function o(u) {
    return QA.call(r, e, a, l, "reference", "referenceMarker", "referenceString")(u);
  }
  function a(u) {
    return r.parser.defined.includes(Rr(r.sliceSerialize(r.events[r.events.length - 1][1]).slice(1, -1))) ? t(u) : n(u);
  }
  function l(u) {
    return n(u);
  }
}
function _Z(e, t, n) {
  return r;
  function r(a) {
    return e.enter("reference"), e.enter("referenceMarker"), e.consume(a), e.exit("referenceMarker"), o;
  }
  function o(a) {
    return a === 93 ? (e.enter("referenceMarker"), e.consume(a), e.exit("referenceMarker"), e.exit("reference"), t) : n(a);
  }
}
const EZ = {
  name: "labelStartImage",
  resolveAll: bx.resolveAll,
  tokenize: CZ
};
function CZ(e, t, n) {
  const r = this;
  return o;
  function o(u) {
    return e.enter("labelImage"), e.enter("labelImageMarker"), e.consume(u), e.exit("labelImageMarker"), a;
  }
  function a(u) {
    return u === 91 ? (e.enter("labelMarker"), e.consume(u), e.exit("labelMarker"), e.exit("labelImage"), l) : n(u);
  }
  function l(u) {
    return u === 94 && "_hiddenFootnoteSupport" in r.parser.constructs ? n(u) : t(u);
  }
}
const OZ = {
  name: "labelStartLink",
  resolveAll: bx.resolveAll,
  tokenize: NZ
};
function NZ(e, t, n) {
  const r = this;
  return o;
  function o(l) {
    return e.enter("labelLink"), e.enter("labelMarker"), e.consume(l), e.exit("labelMarker"), e.exit("labelLink"), a;
  }
  function a(l) {
    return l === 94 && "_hiddenFootnoteSupport" in r.parser.constructs ? n(l) : t(l);
  }
}
const cv = {
  name: "lineEnding",
  tokenize: MZ
};
function MZ(e, t) {
  return n;
  function n(r) {
    return e.enter("lineEnding"), e.consume(r), e.exit("lineEnding"), Ke(e, t, "linePrefix");
  }
}
const up = {
  name: "thematicBreak",
  tokenize: AZ
};
function AZ(e, t, n) {
  let r = 0, o;
  return a;
  function a(f) {
    return e.enter("thematicBreak"), l(f);
  }
  function l(f) {
    return o = f, u(f);
  }
  function u(f) {
    return f === o ? (e.enter("thematicBreakSequence"), d(f)) : r >= 3 && (f === null || Me(f)) ? (e.exit("thematicBreak"), t(f)) : n(f);
  }
  function d(f) {
    return f === o ? (e.consume(f), r++, d) : (e.exit("thematicBreakSequence"), Xe(f) ? Ke(e, u, "whitespace")(f) : u(f));
  }
}
const Dn = {
  continuation: {
    tokenize: TZ
  },
  exit: PZ,
  name: "list",
  tokenize: DZ
}, RZ = {
  partial: !0,
  tokenize: LZ
}, jZ = {
  partial: !0,
  tokenize: zZ
};
function DZ(e, t, n) {
  const r = this, o = r.events[r.events.length - 1];
  let a = o && o[1].type === "linePrefix" ? o[2].sliceSerialize(o[1], !0).length : 0, l = 0;
  return u;
  function u(y) {
    const w = r.containerState.type || (y === 42 || y === 43 || y === 45 ? "listUnordered" : "listOrdered");
    if (w === "listUnordered" ? !r.containerState.marker || y === r.containerState.marker : Tb(y)) {
      if (r.containerState.type || (r.containerState.type = w, e.enter(w, {
        _container: !0
      })), w === "listUnordered")
        return e.enter("listItemPrefix"), y === 42 || y === 45 ? e.check(up, n, f)(y) : f(y);
      if (!r.interrupt || y === 49)
        return e.enter("listItemPrefix"), e.enter("listItemValue"), d(y);
    }
    return n(y);
  }
  function d(y) {
    return Tb(y) && ++l < 10 ? (e.consume(y), d) : (!r.interrupt || l < 2) && (r.containerState.marker ? y === r.containerState.marker : y === 41 || y === 46) ? (e.exit("listItemValue"), f(y)) : n(y);
  }
  function f(y) {
    return e.enter("listItemMarker"), e.consume(y), e.exit("listItemMarker"), r.containerState.marker = r.containerState.marker || y, e.check(
      Xc,
      // Cant be empty when interrupting.
      r.interrupt ? n : p,
      e.attempt(RZ, g, m)
    );
  }
  function p(y) {
    return r.containerState.initialBlankLine = !0, a++, g(y);
  }
  function m(y) {
    return Xe(y) ? (e.enter("listItemPrefixWhitespace"), e.consume(y), e.exit("listItemPrefixWhitespace"), g) : n(y);
  }
  function g(y) {
    return r.containerState.size = a + r.sliceSerialize(e.exit("listItemPrefix"), !0).length, t(y);
  }
}
function TZ(e, t, n) {
  const r = this;
  return r.containerState._closeFlow = void 0, e.check(Xc, o, a);
  function o(u) {
    return r.containerState.furtherBlankLines = r.containerState.furtherBlankLines || r.containerState.initialBlankLine, Ke(e, t, "listItemIndent", r.containerState.size + 1)(u);
  }
  function a(u) {
    return r.containerState.furtherBlankLines || !Xe(u) ? (r.containerState.furtherBlankLines = void 0, r.containerState.initialBlankLine = void 0, l(u)) : (r.containerState.furtherBlankLines = void 0, r.containerState.initialBlankLine = void 0, e.attempt(jZ, t, l)(u));
  }
  function l(u) {
    return r.containerState._closeFlow = !0, r.interrupt = void 0, Ke(e, e.attempt(Dn, t, n), "linePrefix", r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(u);
  }
}
function zZ(e, t, n) {
  const r = this;
  return Ke(e, o, "listItemIndent", r.containerState.size + 1);
  function o(a) {
    const l = r.events[r.events.length - 1];
    return l && l[1].type === "listItemIndent" && l[2].sliceSerialize(l[1], !0).length === r.containerState.size ? t(a) : n(a);
  }
}
function PZ(e) {
  e.exit(this.containerState.type);
}
function LZ(e, t, n) {
  const r = this;
  return Ke(e, o, "listItemPrefixWhitespace", r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 5);
  function o(a) {
    const l = r.events[r.events.length - 1];
    return !Xe(a) && l && l[1].type === "listItemPrefixWhitespace" ? t(a) : n(a);
  }
}
const $C = {
  name: "setextUnderline",
  resolveTo: IZ,
  tokenize: BZ
};
function IZ(e, t) {
  let n = e.length, r, o, a;
  for (; n--; )
    if (e[n][0] === "enter") {
      if (e[n][1].type === "content") {
        r = n;
        break;
      }
      e[n][1].type === "paragraph" && (o = n);
    } else
      e[n][1].type === "content" && e.splice(n, 1), !a && e[n][1].type === "definition" && (a = n);
  const l = {
    type: "setextHeading",
    start: {
      ...e[r][1].start
    },
    end: {
      ...e[e.length - 1][1].end
    }
  };
  return e[o][1].type = "setextHeadingText", a ? (e.splice(o, 0, ["enter", l, t]), e.splice(a + 1, 0, ["exit", e[r][1], t]), e[r][1].end = {
    ...e[a][1].end
  }) : e[r][1] = l, e.push(["exit", l, t]), e;
}
function BZ(e, t, n) {
  const r = this;
  let o;
  return a;
  function a(f) {
    let p = r.events.length, m;
    for (; p--; )
      if (r.events[p][1].type !== "lineEnding" && r.events[p][1].type !== "linePrefix" && r.events[p][1].type !== "content") {
        m = r.events[p][1].type === "paragraph";
        break;
      }
    return !r.parser.lazy[r.now().line] && (r.interrupt || m) ? (e.enter("setextHeadingLine"), o = f, l(f)) : n(f);
  }
  function l(f) {
    return e.enter("setextHeadingLineSequence"), u(f);
  }
  function u(f) {
    return f === o ? (e.consume(f), u) : (e.exit("setextHeadingLineSequence"), Xe(f) ? Ke(e, d, "lineSuffix")(f) : d(f));
  }
  function d(f) {
    return f === null || Me(f) ? (e.exit("setextHeadingLine"), t(f)) : n(f);
  }
}
const VZ = {
  tokenize: HZ
};
function HZ(e) {
  const t = this, n = e.attempt(
    // Try to parse a blank line.
    Xc,
    r,
    // Try to parse initial flow (essentially, only code).
    e.attempt(this.parser.constructs.flowInitial, o, Ke(e, e.attempt(this.parser.constructs.flow, o, e.attempt(qG, o)), "linePrefix"))
  );
  return n;
  function r(a) {
    if (a === null) {
      e.consume(a);
      return;
    }
    return e.enter("lineEndingBlank"), e.consume(a), e.exit("lineEndingBlank"), t.currentConstruct = void 0, n;
  }
  function o(a) {
    if (a === null) {
      e.consume(a);
      return;
    }
    return e.enter("lineEnding"), e.consume(a), e.exit("lineEnding"), t.currentConstruct = void 0, n;
  }
}
const UZ = {
  resolveAll: tR()
}, FZ = eR("string"), $Z = eR("text");
function eR(e) {
  return {
    resolveAll: tR(e === "text" ? YZ : void 0),
    tokenize: t
  };
  function t(n) {
    const r = this, o = this.parser.constructs[e], a = n.attempt(o, l, u);
    return l;
    function l(p) {
      return f(p) ? a(p) : u(p);
    }
    function u(p) {
      if (p === null) {
        n.consume(p);
        return;
      }
      return n.enter("data"), n.consume(p), d;
    }
    function d(p) {
      return f(p) ? (n.exit("data"), a(p)) : (n.consume(p), d);
    }
    function f(p) {
      if (p === null)
        return !0;
      const m = o[p];
      let g = -1;
      if (m)
        for (; ++g < m.length; ) {
          const y = m[g];
          if (!y.previous || y.previous.call(r, r.previous))
            return !0;
        }
      return !1;
    }
  }
}
function tR(e) {
  return t;
  function t(n, r) {
    let o = -1, a;
    for (; ++o <= n.length; )
      a === void 0 ? n[o] && n[o][1].type === "data" && (a = o, o++) : (!n[o] || n[o][1].type !== "data") && (o !== a + 2 && (n[a][1].end = n[o - 1][1].end, n.splice(a + 2, o - a - 2), o = a + 2), a = void 0);
    return e ? e(n, r) : n;
  }
}
function YZ(e, t) {
  let n = 0;
  for (; ++n <= e.length; )
    if ((n === e.length || e[n][1].type === "lineEnding") && e[n - 1][1].type === "data") {
      const r = e[n - 1][1], o = t.sliceStream(r);
      let a = o.length, l = -1, u = 0, d;
      for (; a--; ) {
        const f = o[a];
        if (typeof f == "string") {
          for (l = f.length; f.charCodeAt(l - 1) === 32; )
            u++, l--;
          if (l) break;
          l = -1;
        } else if (f === -2)
          d = !0, u++;
        else if (f !== -1) {
          a++;
          break;
        }
      }
      if (t._contentTypeTextTrailing && n === e.length && (u = 0), u) {
        const f = {
          type: n === e.length || d || u < 2 ? "lineSuffix" : "hardBreakTrailing",
          start: {
            _bufferIndex: a ? l : r.start._bufferIndex + l,
            _index: r.start._index + a,
            line: r.end.line,
            column: r.end.column - u,
            offset: r.end.offset - u
          },
          end: {
            ...r.end
          }
        };
        r.end = {
          ...f.start
        }, r.start.offset === r.end.offset ? Object.assign(r, f) : (e.splice(n, 0, ["enter", f, t], ["exit", f, t]), n += 2);
      }
      n++;
    }
  return e;
}
const qZ = {
  42: Dn,
  43: Dn,
  45: Dn,
  48: Dn,
  49: Dn,
  50: Dn,
  51: Dn,
  52: Dn,
  53: Dn,
  54: Dn,
  55: Dn,
  56: Dn,
  57: Dn,
  62: XA
}, XZ = {
  91: KG
}, GZ = {
  [-2]: uv,
  [-1]: uv,
  32: uv
}, ZZ = {
  35: rZ,
  42: up,
  45: [$C, up],
  60: lZ,
  61: $C,
  95: up,
  96: UC,
  126: UC
}, WZ = {
  38: ZA,
  92: GA
}, KZ = {
  [-5]: cv,
  [-4]: cv,
  [-3]: cv,
  33: EZ,
  38: ZA,
  42: zb,
  60: [OG, hZ],
  91: OZ,
  92: [tZ, GA],
  93: bx,
  95: zb,
  96: VG
}, QZ = {
  null: [zb, UZ]
}, JZ = {
  null: [42, 95]
}, eW = {
  null: []
}, tW = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  attentionMarkers: JZ,
  contentInitial: XZ,
  disable: eW,
  document: qZ,
  flow: ZZ,
  flowInitial: GZ,
  insideSpan: QZ,
  string: WZ,
  text: KZ
}, Symbol.toStringTag, { value: "Module" }));
function nW(e, t, n) {
  let r = {
    _bufferIndex: -1,
    _index: 0,
    line: n && n.line || 1,
    column: n && n.column || 1,
    offset: n && n.offset || 0
  };
  const o = {}, a = [];
  let l = [], u = [];
  const d = {
    attempt: T(R),
    check: T(D),
    consume: N,
    enter: C,
    exit: A,
    interrupt: T(D, {
      interrupt: !0
    })
  }, f = {
    code: null,
    containerState: {},
    defineSkip: v,
    events: [],
    now: w,
    parser: e,
    previous: null,
    sliceSerialize: g,
    sliceStream: y,
    write: m
  };
  let p = t.tokenize.call(f, d);
  return t.resolveAll && a.push(t), f;
  function m(B) {
    return l = hr(l, B), x(), l[l.length - 1] !== null ? [] : (V(t, 0), f.events = Ih(a, f.events, f), f.events);
  }
  function g(B, U) {
    return oW(y(B), U);
  }
  function y(B) {
    return rW(l, B);
  }
  function w() {
    const {
      _bufferIndex: B,
      _index: U,
      line: G,
      column: z,
      offset: $
    } = r;
    return {
      _bufferIndex: B,
      _index: U,
      line: G,
      column: z,
      offset: $
    };
  }
  function v(B) {
    o[B.line] = B.column, O();
  }
  function x() {
    let B;
    for (; r._index < l.length; ) {
      const U = l[r._index];
      if (typeof U == "string")
        for (B = r._index, r._bufferIndex < 0 && (r._bufferIndex = 0); r._index === B && r._bufferIndex < U.length; )
          E(U.charCodeAt(r._bufferIndex));
      else
        E(U);
    }
  }
  function E(B) {
    p = p(B);
  }
  function N(B) {
    Me(B) ? (r.line++, r.column = 1, r.offset += B === -3 ? 2 : 1, O()) : B !== -1 && (r.column++, r.offset++), r._bufferIndex < 0 ? r._index++ : (r._bufferIndex++, r._bufferIndex === // Points w/ non-negative `_bufferIndex` reference
    // strings.
    /** @type {string} */
    l[r._index].length && (r._bufferIndex = -1, r._index++)), f.previous = B;
  }
  function C(B, U) {
    const G = U || {};
    return G.type = B, G.start = w(), f.events.push(["enter", G, f]), u.push(G), G;
  }
  function A(B) {
    const U = u.pop();
    return U.end = w(), f.events.push(["exit", U, f]), U;
  }
  function R(B, U) {
    V(B, U.from);
  }
  function D(B, U) {
    U.restore();
  }
  function T(B, U) {
    return G;
    function G(z, $, L) {
      let H, q, Y, M;
      return Array.isArray(z) ? (
        /* c8 ignore next 1 */
        Q(z)
      ) : "tokenize" in z ? (
        // Looks like a construct.
        Q([
          /** @type {Construct} */
          z
        ])
      ) : X(z);
      function X(ae) {
        return fe;
        function fe(he) {
          const ye = he !== null && ae[he], Ee = he !== null && ae.null, we = [
            // To do: add more extension tests.
            /* c8 ignore next 2 */
            ...Array.isArray(ye) ? ye : ye ? [ye] : [],
            ...Array.isArray(Ee) ? Ee : Ee ? [Ee] : []
          ];
          return Q(we)(he);
        }
      }
      function Q(ae) {
        return H = ae, q = 0, ae.length === 0 ? L : P(ae[q]);
      }
      function P(ae) {
        return fe;
        function fe(he) {
          return M = F(), Y = ae, ae.partial || (f.currentConstruct = ae), ae.name && f.parser.constructs.disable.null.includes(ae.name) ? ie() : ae.tokenize.call(
            // If we do have fields, create an object w/ `context` as its
            // prototype.
            // This allows a live binding, which is needed for `interrupt`.
            U ? Object.assign(Object.create(f), U) : f,
            d,
            te,
            ie
          )(he);
        }
      }
      function te(ae) {
        return B(Y, M), $;
      }
      function ie(ae) {
        return M.restore(), ++q < H.length ? P(H[q]) : L;
      }
    }
  }
  function V(B, U) {
    B.resolveAll && !a.includes(B) && a.push(B), B.resolve && er(f.events, U, f.events.length - U, B.resolve(f.events.slice(U), f)), B.resolveTo && (f.events = B.resolveTo(f.events, f));
  }
  function F() {
    const B = w(), U = f.previous, G = f.currentConstruct, z = f.events.length, $ = Array.from(u);
    return {
      from: z,
      restore: L
    };
    function L() {
      r = B, f.previous = U, f.currentConstruct = G, f.events.length = z, u = $, O();
    }
  }
  function O() {
    r.line in o && r.column < 2 && (r.column = o[r.line], r.offset += o[r.line] - 1);
  }
}
function rW(e, t) {
  const n = t.start._index, r = t.start._bufferIndex, o = t.end._index, a = t.end._bufferIndex;
  let l;
  if (n === o)
    l = [e[n].slice(r, a)];
  else {
    if (l = e.slice(n, o), r > -1) {
      const u = l[0];
      typeof u == "string" ? l[0] = u.slice(r) : l.shift();
    }
    a > 0 && l.push(e[o].slice(0, a));
  }
  return l;
}
function oW(e, t) {
  let n = -1;
  const r = [];
  let o;
  for (; ++n < e.length; ) {
    const a = e[n];
    let l;
    if (typeof a == "string")
      l = a;
    else switch (a) {
      case -5: {
        l = "\r";
        break;
      }
      case -4: {
        l = `
`;
        break;
      }
      case -3: {
        l = `\r
`;
        break;
      }
      case -2: {
        l = t ? " " : "	";
        break;
      }
      case -1: {
        if (!t && o) continue;
        l = " ";
        break;
      }
      default:
        l = String.fromCharCode(a);
    }
    o = a === -2, r.push(l);
  }
  return r.join("");
}
function iW(e) {
  const t = {
    constructs: (
      /** @type {FullNormalizedExtension} */
      YA([tW, ...(e || {}).extensions || []])
    ),
    content: n(wG),
    defined: [],
    document: n(SG),
    flow: n(VZ),
    lazy: {},
    string: n(FZ),
    text: n($Z)
  };
  return t;
  function n(r) {
    return o;
    function o(a) {
      return nW(t, r, a);
    }
  }
}
function aW(e) {
  for (; !WA(e); )
    ;
  return e;
}
const YC = /[\0\t\n\r]/g;
function lW() {
  let e = 1, t = "", n = !0, r;
  return o;
  function o(a, l, u) {
    const d = [];
    let f, p, m, g, y;
    for (a = t + (typeof a == "string" ? a.toString() : new TextDecoder(l || void 0).decode(a)), m = 0, t = "", n && (a.charCodeAt(0) === 65279 && m++, n = void 0); m < a.length; ) {
      if (YC.lastIndex = m, f = YC.exec(a), g = f && f.index !== void 0 ? f.index : a.length, y = a.charCodeAt(g), !f) {
        t = a.slice(m);
        break;
      }
      if (y === 10 && m === g && r)
        d.push(-3), r = void 0;
      else
        switch (r && (d.push(-5), r = void 0), m < g && (d.push(a.slice(m, g)), e += g - m), y) {
          case 0: {
            d.push(65533), e++;
            break;
          }
          case 9: {
            for (p = Math.ceil(e / 4) * 4, d.push(-2); e++ < p; ) d.push(-1);
            break;
          }
          case 10: {
            d.push(-4), e = 1;
            break;
          }
          default:
            r = !0, e = 1;
        }
      m = g + 1;
    }
    return u && (r && d.push(-5), t && d.push(t), d.push(null)), d;
  }
}
const sW = /\\([!-/:-@[-`{-~])|&(#(?:\d{1,7}|x[\da-f]{1,6})|[\da-z]{1,31});/gi;
function uW(e) {
  return e.replace(sW, cW);
}
function cW(e, t, n) {
  if (t)
    return t;
  if (n.charCodeAt(0) === 35) {
    const r = n.charCodeAt(1), o = r === 120 || r === 88;
    return qA(n.slice(o ? 2 : 1), o ? 16 : 10);
  }
  return vx(n) || e;
}
const nR = {}.hasOwnProperty;
function dW(e, t, n) {
  return typeof t != "string" && (n = t, t = void 0), fW(n)(aW(iW(n).document().write(lW()(e, t, !0))));
}
function fW(e) {
  const t = {
    transforms: [],
    canContainEols: ["emphasis", "fragment", "heading", "paragraph", "strong"],
    enter: {
      autolink: a(en),
      autolinkProtocol: F,
      autolinkEmail: F,
      atxHeading: a(Rt),
      blockQuote: a(Ee),
      characterEscape: F,
      characterReference: F,
      codeFenced: a(we),
      codeFencedFenceInfo: l,
      codeFencedFenceMeta: l,
      codeIndented: a(we, l),
      codeText: a(xe, l),
      codeTextData: F,
      data: F,
      codeFlowValue: F,
      definition: a(Pe),
      definitionDestinationString: l,
      definitionLabelString: l,
      definitionTitleString: l,
      emphasis: a(Ve),
      hardBreakEscape: a(Pt),
      hardBreakTrailing: a(Pt),
      htmlFlow: a(lt, l),
      htmlFlowData: F,
      htmlText: a(lt, l),
      htmlTextData: F,
      image: a(wr),
      label: l,
      link: a(en),
      listItem: a(je),
      listItemValue: g,
      listOrdered: a(Bn, m),
      listUnordered: a(Bn),
      paragraph: a(ho),
      reference: P,
      referenceString: l,
      resourceDestinationString: l,
      resourceTitleString: l,
      setextHeading: a(Rt),
      strong: a(Lr),
      thematicBreak: a(mo)
    },
    exit: {
      atxHeading: d(),
      atxHeadingSequence: R,
      autolink: d(),
      autolinkEmail: ye,
      autolinkProtocol: he,
      blockQuote: d(),
      characterEscapeValue: O,
      characterReferenceMarkerHexadecimal: ie,
      characterReferenceMarkerNumeric: ie,
      characterReferenceValue: ae,
      characterReference: fe,
      codeFenced: d(x),
      codeFencedFence: v,
      codeFencedFenceInfo: y,
      codeFencedFenceMeta: w,
      codeFlowValue: O,
      codeIndented: d(E),
      codeText: d($),
      codeTextData: O,
      data: O,
      definition: d(),
      definitionDestinationString: A,
      definitionLabelString: N,
      definitionTitleString: C,
      emphasis: d(),
      hardBreakEscape: d(U),
      hardBreakTrailing: d(U),
      htmlFlow: d(G),
      htmlFlowData: O,
      htmlText: d(z),
      htmlTextData: O,
      image: d(H),
      label: Y,
      labelText: q,
      lineEnding: B,
      link: d(L),
      listItem: d(),
      listOrdered: d(),
      listUnordered: d(),
      paragraph: d(),
      referenceString: te,
      resourceDestinationString: M,
      resourceTitleString: X,
      resource: Q,
      setextHeading: d(V),
      setextHeadingLineSequence: T,
      setextHeadingText: D,
      strong: d(),
      thematicBreak: d()
    }
  };
  rR(t, (e || {}).mdastExtensions || []);
  const n = {};
  return r;
  function r(le) {
    let pe = {
      type: "root",
      children: []
    };
    const ke = {
      stack: [pe],
      tokenStack: [],
      config: t,
      enter: u,
      exit: f,
      buffer: l,
      resume: p,
      data: n
    }, Le = [];
    let ot = -1;
    for (; ++ot < le.length; )
      if (le[ot][1].type === "listOrdered" || le[ot][1].type === "listUnordered")
        if (le[ot][0] === "enter")
          Le.push(ot);
        else {
          const En = Le.pop();
          ot = o(le, En, ot);
        }
    for (ot = -1; ++ot < le.length; ) {
      const En = t[le[ot][0]];
      nR.call(En, le[ot][1].type) && En[le[ot][1].type].call(Object.assign({
        sliceSerialize: le[ot][2].sliceSerialize
      }, ke), le[ot][1]);
    }
    if (ke.tokenStack.length > 0) {
      const En = ke.tokenStack[ke.tokenStack.length - 1];
      (En[1] || qC).call(ke, void 0, En[0]);
    }
    for (pe.position = {
      start: ji(le.length > 0 ? le[0][1].start : {
        line: 1,
        column: 1,
        offset: 0
      }),
      end: ji(le.length > 0 ? le[le.length - 2][1].end : {
        line: 1,
        column: 1,
        offset: 0
      })
    }, ot = -1; ++ot < t.transforms.length; )
      pe = t.transforms[ot](pe) || pe;
    return pe;
  }
  function o(le, pe, ke) {
    let Le = pe - 1, ot = -1, En = !1, Ir, sn, ir, vn;
    for (; ++Le <= ke; ) {
      const Lt = le[Le];
      switch (Lt[1].type) {
        case "listUnordered":
        case "listOrdered":
        case "blockQuote": {
          Lt[0] === "enter" ? ot++ : ot--, vn = void 0;
          break;
        }
        case "lineEndingBlank": {
          Lt[0] === "enter" && (Ir && !vn && !ot && !ir && (ir = Le), vn = void 0);
          break;
        }
        case "linePrefix":
        case "listItemValue":
        case "listItemMarker":
        case "listItemPrefix":
        case "listItemPrefixWhitespace":
          break;
        default:
          vn = void 0;
      }
      if (!ot && Lt[0] === "enter" && Lt[1].type === "listItemPrefix" || ot === -1 && Lt[0] === "exit" && (Lt[1].type === "listUnordered" || Lt[1].type === "listOrdered")) {
        if (Ir) {
          let Cn = Le;
          for (sn = void 0; Cn--; ) {
            const Vn = le[Cn];
            if (Vn[1].type === "lineEnding" || Vn[1].type === "lineEndingBlank") {
              if (Vn[0] === "exit") continue;
              sn && (le[sn][1].type = "lineEndingBlank", En = !0), Vn[1].type = "lineEnding", sn = Cn;
            } else if (!(Vn[1].type === "linePrefix" || Vn[1].type === "blockQuotePrefix" || Vn[1].type === "blockQuotePrefixWhitespace" || Vn[1].type === "blockQuoteMarker" || Vn[1].type === "listItemIndent")) break;
          }
          ir && (!sn || ir < sn) && (Ir._spread = !0), Ir.end = Object.assign({}, sn ? le[sn][1].start : Lt[1].end), le.splice(sn || Le, 0, ["exit", Ir, Lt[2]]), Le++, ke++;
        }
        if (Lt[1].type === "listItemPrefix") {
          const Cn = {
            type: "listItem",
            _spread: !1,
            start: Object.assign({}, Lt[1].start),
            // @ts-expect-error: well add `end` in a second.
            end: void 0
          };
          Ir = Cn, le.splice(Le, 0, ["enter", Cn, Lt[2]]), Le++, ke++, ir = void 0, vn = !0;
        }
      }
    }
    return le[pe][1]._spread = En, ke;
  }
  function a(le, pe) {
    return ke;
    function ke(Le) {
      u.call(this, le(Le), Le), pe && pe.call(this, Le);
    }
  }
  function l() {
    this.stack.push({
      type: "fragment",
      children: []
    });
  }
  function u(le, pe, ke) {
    this.stack[this.stack.length - 1].children.push(le), this.stack.push(le), this.tokenStack.push([pe, ke || void 0]), le.position = {
      start: ji(pe.start),
      // @ts-expect-error: `end` will be patched later.
      end: void 0
    };
  }
  function d(le) {
    return pe;
    function pe(ke) {
      le && le.call(this, ke), f.call(this, ke);
    }
  }
  function f(le, pe) {
    const ke = this.stack.pop(), Le = this.tokenStack.pop();
    if (Le)
      Le[0].type !== le.type && (pe ? pe.call(this, le, Le[0]) : (Le[1] || qC).call(this, le, Le[0]));
    else throw new Error("Cannot close `" + le.type + "` (" + ec({
      start: le.start,
      end: le.end
    }) + "): its not open");
    ke.position.end = ji(le.end);
  }
  function p() {
    return yx(this.stack.pop());
  }
  function m() {
    this.data.expectingFirstListItemValue = !0;
  }
  function g(le) {
    if (this.data.expectingFirstListItemValue) {
      const pe = this.stack[this.stack.length - 2];
      pe.start = Number.parseInt(this.sliceSerialize(le), 10), this.data.expectingFirstListItemValue = void 0;
    }
  }
  function y() {
    const le = this.resume(), pe = this.stack[this.stack.length - 1];
    pe.lang = le;
  }
  function w() {
    const le = this.resume(), pe = this.stack[this.stack.length - 1];
    pe.meta = le;
  }
  function v() {
    this.data.flowCodeInside || (this.buffer(), this.data.flowCodeInside = !0);
  }
  function x() {
    const le = this.resume(), pe = this.stack[this.stack.length - 1];
    pe.value = le.replace(/^(\r?\n|\r)|(\r?\n|\r)$/g, ""), this.data.flowCodeInside = void 0;
  }
  function E() {
    const le = this.resume(), pe = this.stack[this.stack.length - 1];
    pe.value = le.replace(/(\r?\n|\r)$/g, "");
  }
  function N(le) {
    const pe = this.resume(), ke = this.stack[this.stack.length - 1];
    ke.label = pe, ke.identifier = Rr(this.sliceSerialize(le)).toLowerCase();
  }
  function C() {
    const le = this.resume(), pe = this.stack[this.stack.length - 1];
    pe.title = le;
  }
  function A() {
    const le = this.resume(), pe = this.stack[this.stack.length - 1];
    pe.url = le;
  }
  function R(le) {
    const pe = this.stack[this.stack.length - 1];
    if (!pe.depth) {
      const ke = this.sliceSerialize(le).length;
      pe.depth = ke;
    }
  }
  function D() {
    this.data.setextHeadingSlurpLineEnding = !0;
  }
  function T(le) {
    const pe = this.stack[this.stack.length - 1];
    pe.depth = this.sliceSerialize(le).codePointAt(0) === 61 ? 1 : 2;
  }
  function V() {
    this.data.setextHeadingSlurpLineEnding = void 0;
  }
  function F(le) {
    const pe = this.stack[this.stack.length - 1].children;
    let ke = pe[pe.length - 1];
    (!ke || ke.type !== "text") && (ke = Ki(), ke.position = {
      start: ji(le.start),
      // @ts-expect-error: well add `end` later.
      end: void 0
    }, pe.push(ke)), this.stack.push(ke);
  }
  function O(le) {
    const pe = this.stack.pop();
    pe.value += this.sliceSerialize(le), pe.position.end = ji(le.end);
  }
  function B(le) {
    const pe = this.stack[this.stack.length - 1];
    if (this.data.atHardBreak) {
      const ke = pe.children[pe.children.length - 1];
      ke.position.end = ji(le.end), this.data.atHardBreak = void 0;
      return;
    }
    !this.data.setextHeadingSlurpLineEnding && t.canContainEols.includes(pe.type) && (F.call(this, le), O.call(this, le));
  }
  function U() {
    this.data.atHardBreak = !0;
  }
  function G() {
    const le = this.resume(), pe = this.stack[this.stack.length - 1];
    pe.value = le;
  }
  function z() {
    const le = this.resume(), pe = this.stack[this.stack.length - 1];
    pe.value = le;
  }
  function $() {
    const le = this.resume(), pe = this.stack[this.stack.length - 1];
    pe.value = le;
  }
  function L() {
    const le = this.stack[this.stack.length - 1];
    if (this.data.inReference) {
      const pe = this.data.referenceType || "shortcut";
      le.type += "Reference", le.referenceType = pe, delete le.url, delete le.title;
    } else
      delete le.identifier, delete le.label;
    this.data.referenceType = void 0;
  }
  function H() {
    const le = this.stack[this.stack.length - 1];
    if (this.data.inReference) {
      const pe = this.data.referenceType || "shortcut";
      le.type += "Reference", le.referenceType = pe, delete le.url, delete le.title;
    } else
      delete le.identifier, delete le.label;
    this.data.referenceType = void 0;
  }
  function q(le) {
    const pe = this.sliceSerialize(le), ke = this.stack[this.stack.length - 2];
    ke.label = uW(pe), ke.identifier = Rr(pe).toLowerCase();
  }
  function Y() {
    const le = this.stack[this.stack.length - 1], pe = this.resume(), ke = this.stack[this.stack.length - 1];
    if (this.data.inReference = !0, ke.type === "link") {
      const Le = le.children;
      ke.children = Le;
    } else
      ke.alt = pe;
  }
  function M() {
    const le = this.resume(), pe = this.stack[this.stack.length - 1];
    pe.url = le;
  }
  function X() {
    const le = this.resume(), pe = this.stack[this.stack.length - 1];
    pe.title = le;
  }
  function Q() {
    this.data.inReference = void 0;
  }
  function P() {
    this.data.referenceType = "collapsed";
  }
  function te(le) {
    const pe = this.resume(), ke = this.stack[this.stack.length - 1];
    ke.label = pe, ke.identifier = Rr(this.sliceSerialize(le)).toLowerCase(), this.data.referenceType = "full";
  }
  function ie(le) {
    this.data.characterReferenceType = le.type;
  }
  function ae(le) {
    const pe = this.sliceSerialize(le), ke = this.data.characterReferenceType;
    let Le;
    ke ? (Le = qA(pe, ke === "characterReferenceMarkerNumeric" ? 10 : 16), this.data.characterReferenceType = void 0) : Le = vx(pe);
    const ot = this.stack[this.stack.length - 1];
    ot.value += Le;
  }
  function fe(le) {
    const pe = this.stack.pop();
    pe.position.end = ji(le.end);
  }
  function he(le) {
    O.call(this, le);
    const pe = this.stack[this.stack.length - 1];
    pe.url = this.sliceSerialize(le);
  }
  function ye(le) {
    O.call(this, le);
    const pe = this.stack[this.stack.length - 1];
    pe.url = "mailto:" + this.sliceSerialize(le);
  }
  function Ee() {
    return {
      type: "blockquote",
      children: []
    };
  }
  function we() {
    return {
      type: "code",
      lang: null,
      meta: null,
      value: ""
    };
  }
  function xe() {
    return {
      type: "inlineCode",
      value: ""
    };
  }
  function Pe() {
    return {
      type: "definition",
      identifier: "",
      label: null,
      title: null,
      url: ""
    };
  }
  function Ve() {
    return {
      type: "emphasis",
      children: []
    };
  }
  function Rt() {
    return {
      type: "heading",
      // @ts-expect-error `depth` will be set later.
      depth: 0,
      children: []
    };
  }
  function Pt() {
    return {
      type: "break"
    };
  }
  function lt() {
    return {
      type: "html",
      value: ""
    };
  }
  function wr() {
    return {
      type: "image",
      title: null,
      url: "",
      alt: null
    };
  }
  function en() {
    return {
      type: "link",
      title: null,
      url: "",
      children: []
    };
  }
  function Bn(le) {
    return {
      type: "list",
      ordered: le.type === "listOrdered",
      start: null,
      spread: le._spread,
      children: []
    };
  }
  function je(le) {
    return {
      type: "listItem",
      spread: le._spread,
      checked: null,
      children: []
    };
  }
  function ho() {
    return {
      type: "paragraph",
      children: []
    };
  }
  function Lr() {
    return {
      type: "strong",
      children: []
    };
  }
  function Ki() {
    return {
      type: "text",
      value: ""
    };
  }
  function mo() {
    return {
      type: "thematicBreak"
    };
  }
}
function ji(e) {
  return {
    line: e.line,
    column: e.column,
    offset: e.offset
  };
}
function rR(e, t) {
  let n = -1;
  for (; ++n < t.length; ) {
    const r = t[n];
    Array.isArray(r) ? rR(e, r) : pW(e, r);
  }
}
function pW(e, t) {
  let n;
  for (n in t)
    if (nR.call(t, n))
      switch (n) {
        case "canContainEols": {
          const r = t[n];
          r && e[n].push(...r);
          break;
        }
        case "transforms": {
          const r = t[n];
          r && e[n].push(...r);
          break;
        }
        case "enter":
        case "exit": {
          const r = t[n];
          r && Object.assign(e[n], r);
          break;
        }
      }
}
function qC(e, t) {
  throw e ? new Error("Cannot close `" + e.type + "` (" + ec({
    start: e.start,
    end: e.end
  }) + "): a different token (`" + t.type + "`, " + ec({
    start: t.start,
    end: t.end
  }) + ") is open") : new Error("Cannot close document, a token (`" + t.type + "`, " + ec({
    start: t.start,
    end: t.end
  }) + ") is still open");
}
function hW(e) {
  const t = this;
  t.parser = n;
  function n(r) {
    return dW(r, {
      ...t.data("settings"),
      ...e,
      // Note: these options are not in the readme.
      // The goal is for them to be set by plugins on `data` instead of being
      // passed by users.
      extensions: t.data("micromarkExtensions") || [],
      mdastExtensions: t.data("fromMarkdownExtensions") || []
    });
  }
}
function mW(e, t) {
  const n = {
    type: "element",
    tagName: "blockquote",
    properties: {},
    children: e.wrap(e.all(t), !0)
  };
  return e.patch(t, n), e.applyData(t, n);
}
function gW(e, t) {
  const n = { type: "element", tagName: "br", properties: {}, children: [] };
  return e.patch(t, n), [e.applyData(t, n), { type: "text", value: `
` }];
}
function yW(e, t) {
  const n = t.value ? t.value + `
` : "", r = {};
  t.lang && (r.className = ["language-" + t.lang]);
  let o = {
    type: "element",
    tagName: "code",
    properties: r,
    children: [{ type: "text", value: n }]
  };
  return t.meta && (o.data = { meta: t.meta }), e.patch(t, o), o = e.applyData(t, o), o = { type: "element", tagName: "pre", properties: {}, children: [o] }, e.patch(t, o), o;
}
function vW(e, t) {
  const n = {
    type: "element",
    tagName: "del",
    properties: {},
    children: e.all(t)
  };
  return e.patch(t, n), e.applyData(t, n);
}
function bW(e, t) {
  const n = {
    type: "element",
    tagName: "em",
    properties: {},
    children: e.all(t)
  };
  return e.patch(t, n), e.applyData(t, n);
}
function wW(e, t) {
  const n = typeof e.options.clobberPrefix == "string" ? e.options.clobberPrefix : "user-content-", r = String(t.identifier).toUpperCase(), o = ks(r.toLowerCase()), a = e.footnoteOrder.indexOf(r);
  let l, u = e.footnoteCounts.get(r);
  u === void 0 ? (u = 0, e.footnoteOrder.push(r), l = e.footnoteOrder.length) : l = a + 1, u += 1, e.footnoteCounts.set(r, u);
  const d = {
    type: "element",
    tagName: "a",
    properties: {
      href: "#" + n + "fn-" + o,
      id: n + "fnref-" + o + (u > 1 ? "-" + u : ""),
      dataFootnoteRef: !0,
      ariaDescribedBy: ["footnote-label"]
    },
    children: [{ type: "text", value: String(l) }]
  };
  e.patch(t, d);
  const f = {
    type: "element",
    tagName: "sup",
    properties: {},
    children: [d]
  };
  return e.patch(t, f), e.applyData(t, f);
}
function xW(e, t) {
  const n = {
    type: "element",
    tagName: "h" + t.depth,
    properties: {},
    children: e.all(t)
  };
  return e.patch(t, n), e.applyData(t, n);
}
function SW(e, t) {
  if (e.options.allowDangerousHtml) {
    const n = { type: "raw", value: t.value };
    return e.patch(t, n), e.applyData(t, n);
  }
}
function oR(e, t) {
  const n = t.referenceType;
  let r = "]";
  if (n === "collapsed" ? r += "[]" : n === "full" && (r += "[" + (t.label || t.identifier) + "]"), t.type === "imageReference")
    return [{ type: "text", value: "![" + t.alt + r }];
  const o = e.all(t), a = o[0];
  a && a.type === "text" ? a.value = "[" + a.value : o.unshift({ type: "text", value: "[" });
  const l = o[o.length - 1];
  return l && l.type === "text" ? l.value += r : o.push({ type: "text", value: r }), o;
}
function kW(e, t) {
  const n = String(t.identifier).toUpperCase(), r = e.definitionById.get(n);
  if (!r)
    return oR(e, t);
  const o = { src: ks(r.url || ""), alt: t.alt };
  r.title !== null && r.title !== void 0 && (o.title = r.title);
  const a = { type: "element", tagName: "img", properties: o, children: [] };
  return e.patch(t, a), e.applyData(t, a);
}
function _W(e, t) {
  const n = { src: ks(t.url) };
  t.alt !== null && t.alt !== void 0 && (n.alt = t.alt), t.title !== null && t.title !== void 0 && (n.title = t.title);
  const r = { type: "element", tagName: "img", properties: n, children: [] };
  return e.patch(t, r), e.applyData(t, r);
}
function EW(e, t) {
  const n = { type: "text", value: t.value.replace(/\r?\n|\r/g, " ") };
  e.patch(t, n);
  const r = {
    type: "element",
    tagName: "code",
    properties: {},
    children: [n]
  };
  return e.patch(t, r), e.applyData(t, r);
}
function CW(e, t) {
  const n = String(t.identifier).toUpperCase(), r = e.definitionById.get(n);
  if (!r)
    return oR(e, t);
  const o = { href: ks(r.url || "") };
  r.title !== null && r.title !== void 0 && (o.title = r.title);
  const a = {
    type: "element",
    tagName: "a",
    properties: o,
    children: e.all(t)
  };
  return e.patch(t, a), e.applyData(t, a);
}
function OW(e, t) {
  const n = { href: ks(t.url) };
  t.title !== null && t.title !== void 0 && (n.title = t.title);
  const r = {
    type: "element",
    tagName: "a",
    properties: n,
    children: e.all(t)
  };
  return e.patch(t, r), e.applyData(t, r);
}
function NW(e, t, n) {
  const r = e.all(t), o = n ? MW(n) : iR(t), a = {}, l = [];
  if (typeof t.checked == "boolean") {
    const p = r[0];
    let m;
    p && p.type === "element" && p.tagName === "p" ? m = p : (m = { type: "element", tagName: "p", properties: {}, children: [] }, r.unshift(m)), m.children.length > 0 && m.children.unshift({ type: "text", value: " " }), m.children.unshift({
      type: "element",
      tagName: "input",
      properties: { type: "checkbox", checked: t.checked, disabled: !0 },
      children: []
    }), a.className = ["task-list-item"];
  }
  let u = -1;
  for (; ++u < r.length; ) {
    const p = r[u];
    (o || u !== 0 || p.type !== "element" || p.tagName !== "p") && l.push({ type: "text", value: `
` }), p.type === "element" && p.tagName === "p" && !o ? l.push(...p.children) : l.push(p);
  }
  const d = r[r.length - 1];
  d && (o || d.type !== "element" || d.tagName !== "p") && l.push({ type: "text", value: `
` });
  const f = { type: "element", tagName: "li", properties: a, children: l };
  return e.patch(t, f), e.applyData(t, f);
}
function MW(e) {
  let t = !1;
  if (e.type === "list") {
    t = e.spread || !1;
    const n = e.children;
    let r = -1;
    for (; !t && ++r < n.length; )
      t = iR(n[r]);
  }
  return t;
}
function iR(e) {
  return e.spread ?? e.children.length > 1;
}
function AW(e, t) {
  const n = {}, r = e.all(t);
  let o = -1;
  for (typeof t.start == "number" && t.start !== 1 && (n.start = t.start); ++o < r.length; ) {
    const l = r[o];
    if (l.type === "element" && l.tagName === "li" && l.properties && Array.isArray(l.properties.className) && l.properties.className.includes("task-list-item")) {
      n.className = ["contains-task-list"];
      break;
    }
  }
  const a = {
    type: "element",
    tagName: t.ordered ? "ol" : "ul",
    properties: n,
    children: e.wrap(r, !0)
  };
  return e.patch(t, a), e.applyData(t, a);
}
function RW(e, t) {
  const n = {
    type: "element",
    tagName: "p",
    properties: {},
    children: e.all(t)
  };
  return e.patch(t, n), e.applyData(t, n);
}
function jW(e, t) {
  const n = { type: "root", children: e.wrap(e.all(t)) };
  return e.patch(t, n), e.applyData(t, n);
}
function DW(e, t) {
  const n = {
    type: "element",
    tagName: "strong",
    properties: {},
    children: e.all(t)
  };
  return e.patch(t, n), e.applyData(t, n);
}
function TW(e, t) {
  const n = e.all(t), r = n.shift(), o = [];
  if (r) {
    const l = {
      type: "element",
      tagName: "thead",
      properties: {},
      children: e.wrap([r], !0)
    };
    e.patch(t.children[0], l), o.push(l);
  }
  if (n.length > 0) {
    const l = {
      type: "element",
      tagName: "tbody",
      properties: {},
      children: e.wrap(n, !0)
    }, u = px(t.children[1]), d = IA(t.children[t.children.length - 1]);
    u && d && (l.position = { start: u, end: d }), o.push(l);
  }
  const a = {
    type: "element",
    tagName: "table",
    properties: {},
    children: e.wrap(o, !0)
  };
  return e.patch(t, a), e.applyData(t, a);
}
function zW(e, t, n) {
  const r = n ? n.children : void 0, o = (r ? r.indexOf(t) : 1) === 0 ? "th" : "td", a = n && n.type === "table" ? n.align : void 0, l = a ? a.length : t.children.length;
  let u = -1;
  const d = [];
  for (; ++u < l; ) {
    const p = t.children[u], m = {}, g = a ? a[u] : void 0;
    g && (m.align = g);
    let y = { type: "element", tagName: o, properties: m, children: [] };
    p && (y.children = e.all(p), e.patch(p, y), y = e.applyData(p, y)), d.push(y);
  }
  const f = {
    type: "element",
    tagName: "tr",
    properties: {},
    children: e.wrap(d, !0)
  };
  return e.patch(t, f), e.applyData(t, f);
}
function PW(e, t) {
  const n = {
    type: "element",
    tagName: "td",
    // Assume body cell.
    properties: {},
    children: e.all(t)
  };
  return e.patch(t, n), e.applyData(t, n);
}
const XC = 9, GC = 32;
function LW(e) {
  const t = String(e), n = /\r?\n|\r/g;
  let r = n.exec(t), o = 0;
  const a = [];
  for (; r; )
    a.push(
      ZC(t.slice(o, r.index), o > 0, !0),
      r[0]
    ), o = r.index + r[0].length, r = n.exec(t);
  return a.push(ZC(t.slice(o), o > 0, !1)), a.join("");
}
function ZC(e, t, n) {
  let r = 0, o = e.length;
  if (t) {
    let a = e.codePointAt(r);
    for (; a === XC || a === GC; )
      r++, a = e.codePointAt(r);
  }
  if (n) {
    let a = e.codePointAt(o - 1);
    for (; a === XC || a === GC; )
      o--, a = e.codePointAt(o - 1);
  }
  return o > r ? e.slice(r, o) : "";
}
function IW(e, t) {
  const n = { type: "text", value: LW(String(t.value)) };
  return e.patch(t, n), e.applyData(t, n);
}
function BW(e, t) {
  const n = {
    type: "element",
    tagName: "hr",
    properties: {},
    children: []
  };
  return e.patch(t, n), e.applyData(t, n);
}
const VW = {
  blockquote: mW,
  break: gW,
  code: yW,
  delete: vW,
  emphasis: bW,
  footnoteReference: wW,
  heading: xW,
  html: SW,
  imageReference: kW,
  image: _W,
  inlineCode: EW,
  linkReference: CW,
  link: OW,
  listItem: NW,
  list: AW,
  paragraph: RW,
  // @ts-expect-error: root is different, but hard to type.
  root: jW,
  strong: DW,
  table: TW,
  tableCell: PW,
  tableRow: zW,
  text: IW,
  thematicBreak: BW,
  toml: Pf,
  yaml: Pf,
  definition: Pf,
  footnoteDefinition: Pf
};
function Pf() {
}
const aR = -1, Bh = 0, nc = 1, Vp = 2, wx = 3, xx = 4, Sx = 5, kx = 6, lR = 7, sR = 8, WC = typeof self == "object" ? self : globalThis, HW = (e, t) => {
  const n = (o, a) => (e.set(a, o), o), r = (o) => {
    if (e.has(o))
      return e.get(o);
    const [a, l] = t[o];
    switch (a) {
      case Bh:
      case aR:
        return n(l, o);
      case nc: {
        const u = n([], o);
        for (const d of l)
          u.push(r(d));
        return u;
      }
      case Vp: {
        const u = n({}, o);
        for (const [d, f] of l)
          u[r(d)] = r(f);
        return u;
      }
      case wx:
        return n(new Date(l), o);
      case xx: {
        const { source: u, flags: d } = l;
        return n(new RegExp(u, d), o);
      }
      case Sx: {
        const u = n(/* @__PURE__ */ new Map(), o);
        for (const [d, f] of l)
          u.set(r(d), r(f));
        return u;
      }
      case kx: {
        const u = n(/* @__PURE__ */ new Set(), o);
        for (const d of l)
          u.add(r(d));
        return u;
      }
      case lR: {
        const { name: u, message: d } = l;
        return n(new WC[u](d), o);
      }
      case sR:
        return n(BigInt(l), o);
      case "BigInt":
        return n(Object(BigInt(l)), o);
      case "ArrayBuffer":
        return n(new Uint8Array(l).buffer, l);
      case "DataView": {
        const { buffer: u } = new Uint8Array(l);
        return n(new DataView(u), l);
      }
    }
    return n(new WC[a](l), o);
  };
  return r;
}, KC = (e) => HW(/* @__PURE__ */ new Map(), e)(0), Dl = "", { toString: UW } = {}, { keys: FW } = Object, Bu = (e) => {
  const t = typeof e;
  if (t !== "object" || !e)
    return [Bh, t];
  const n = UW.call(e).slice(8, -1);
  switch (n) {
    case "Array":
      return [nc, Dl];
    case "Object":
      return [Vp, Dl];
    case "Date":
      return [wx, Dl];
    case "RegExp":
      return [xx, Dl];
    case "Map":
      return [Sx, Dl];
    case "Set":
      return [kx, Dl];
    case "DataView":
      return [nc, n];
  }
  return n.includes("Array") ? [nc, n] : n.includes("Error") ? [lR, n] : [Vp, n];
}, Lf = ([e, t]) => e === Bh && (t === "function" || t === "symbol"), $W = (e, t, n, r) => {
  const o = (l, u) => {
    const d = r.push(l) - 1;
    return n.set(u, d), d;
  }, a = (l) => {
    if (n.has(l))
      return n.get(l);
    let [u, d] = Bu(l);
    switch (u) {
      case Bh: {
        let p = l;
        switch (d) {
          case "bigint":
            u = sR, p = l.toString();
            break;
          case "function":
          case "symbol":
            if (e)
              throw new TypeError("unable to serialize " + d);
            p = null;
            break;
          case "undefined":
            return o([aR], l);
        }
        return o([u, p], l);
      }
      case nc: {
        if (d) {
          let g = l;
          return d === "DataView" ? g = new Uint8Array(l.buffer) : d === "ArrayBuffer" && (g = new Uint8Array(l)), o([d, [...g]], l);
        }
        const p = [], m = o([u, p], l);
        for (const g of l)
          p.push(a(g));
        return m;
      }
      case Vp: {
        if (d)
          switch (d) {
            case "BigInt":
              return o([d, l.toString()], l);
            case "Boolean":
            case "Number":
            case "String":
              return o([d, l.valueOf()], l);
          }
        if (t && "toJSON" in l)
          return a(l.toJSON());
        const p = [], m = o([u, p], l);
        for (const g of FW(l))
          (e || !Lf(Bu(l[g]))) && p.push([a(g), a(l[g])]);
        return m;
      }
      case wx:
        return o([u, l.toISOString()], l);
      case xx: {
        const { source: p, flags: m } = l;
        return o([u, { source: p, flags: m }], l);
      }
      case Sx: {
        const p = [], m = o([u, p], l);
        for (const [g, y] of l)
          (e || !(Lf(Bu(g)) || Lf(Bu(y)))) && p.push([a(g), a(y)]);
        return m;
      }
      case kx: {
        const p = [], m = o([u, p], l);
        for (const g of l)
          (e || !Lf(Bu(g))) && p.push(a(g));
        return m;
      }
    }
    const { message: f } = l;
    return o([u, { name: d, message: f }], l);
  };
  return a;
}, QC = (e, { json: t, lossy: n } = {}) => {
  const r = [];
  return $W(!(t || n), !!t, /* @__PURE__ */ new Map(), r)(e), r;
}, Hp = typeof structuredClone == "function" ? (
  /* c8 ignore start */
  (e, t) => t && ("json" in t || "lossy" in t) ? KC(QC(e, t)) : structuredClone(e)
) : (e, t) => KC(QC(e, t));
function YW(e, t) {
  const n = [{ type: "text", value: "" }];
  return t > 1 && n.push({
    type: "element",
    tagName: "sup",
    properties: {},
    children: [{ type: "text", value: String(t) }]
  }), n;
}
function qW(e, t) {
  return "Back to reference " + (e + 1) + (t > 1 ? "-" + t : "");
}
function XW(e) {
  const t = typeof e.options.clobberPrefix == "string" ? e.options.clobberPrefix : "user-content-", n = e.options.footnoteBackContent || YW, r = e.options.footnoteBackLabel || qW, o = e.options.footnoteLabel || "Footnotes", a = e.options.footnoteLabelTagName || "h2", l = e.options.footnoteLabelProperties || {
    className: ["sr-only"]
  }, u = [];
  let d = -1;
  for (; ++d < e.footnoteOrder.length; ) {
    const f = e.footnoteById.get(
      e.footnoteOrder[d]
    );
    if (!f)
      continue;
    const p = e.all(f), m = String(f.identifier).toUpperCase(), g = ks(m.toLowerCase());
    let y = 0;
    const w = [], v = e.footnoteCounts.get(m);
    for (; v !== void 0 && ++y <= v; ) {
      w.length > 0 && w.push({ type: "text", value: " " });
      let N = typeof n == "string" ? n : n(d, y);
      typeof N == "string" && (N = { type: "text", value: N }), w.push({
        type: "element",
        tagName: "a",
        properties: {
          href: "#" + t + "fnref-" + g + (y > 1 ? "-" + y : ""),
          dataFootnoteBackref: "",
          ariaLabel: typeof r == "string" ? r : r(d, y),
          className: ["data-footnote-backref"]
        },
        children: Array.isArray(N) ? N : [N]
      });
    }
    const x = p[p.length - 1];
    if (x && x.type === "element" && x.tagName === "p") {
      const N = x.children[x.children.length - 1];
      N && N.type === "text" ? N.value += " " : x.children.push({ type: "text", value: " " }), x.children.push(...w);
    } else
      p.push(...w);
    const E = {
      type: "element",
      tagName: "li",
      properties: { id: t + "fn-" + g },
      children: e.wrap(p, !0)
    };
    e.patch(f, E), u.push(E);
  }
  if (u.length !== 0)
    return {
      type: "element",
      tagName: "section",
      properties: { dataFootnotes: !0, className: ["footnotes"] },
      children: [
        {
          type: "element",
          tagName: a,
          properties: {
            ...Hp(l),
            id: "footnote-label"
          },
          children: [{ type: "text", value: o }]
        },
        { type: "text", value: `
` },
        {
          type: "element",
          tagName: "ol",
          properties: {},
          children: e.wrap(u, !0)
        },
        { type: "text", value: `
` }
      ]
    };
}
const Vh = (
  // Note: overloads in JSDoc cant yet use different `@template`s.
  /**
   * @type {(
   *   (<Condition extends string>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & {type: Condition}) &
   *   (<Condition extends Props>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & Condition) &
   *   (<Condition extends TestFunction>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & Predicate<Condition, Node>) &
   *   ((test?: null | undefined) => (node?: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node) &
   *   ((test?: Test) => Check)
   * )}
   */
  /**
   * @param {Test} [test]
   * @returns {Check}
   */
  function(e) {
    if (e == null)
      return KW;
    if (typeof e == "function")
      return Hh(e);
    if (typeof e == "object")
      return Array.isArray(e) ? GW(e) : ZW(e);
    if (typeof e == "string")
      return WW(e);
    throw new Error("Expected function, string, or object as test");
  }
);
function GW(e) {
  const t = [];
  let n = -1;
  for (; ++n < e.length; )
    t[n] = Vh(e[n]);
  return Hh(r);
  function r(...o) {
    let a = -1;
    for (; ++a < t.length; )
      if (t[a].apply(this, o)) return !0;
    return !1;
  }
}
function ZW(e) {
  const t = (
    /** @type {Record<string, unknown>} */
    e
  );
  return Hh(n);
  function n(r) {
    const o = (
      /** @type {Record<string, unknown>} */
      /** @type {unknown} */
      r
    );
    let a;
    for (a in e)
      if (o[a] !== t[a]) return !1;
    return !0;
  }
}
function WW(e) {
  return Hh(t);
  function t(n) {
    return n && n.type === e;
  }
}
function Hh(e) {
  return t;
  function t(n, r, o) {
    return !!(QW(n) && e.call(
      this,
      n,
      typeof r == "number" ? r : void 0,
      o || void 0
    ));
  }
}
function KW() {
  return !0;
}
function QW(e) {
  return e !== null && typeof e == "object" && "type" in e;
}
const uR = [], JW = !0, Pb = !1, eK = "skip";
function cR(e, t, n, r) {
  let o;
  typeof t == "function" && typeof n != "function" ? (r = n, n = t) : o = t;
  const a = Vh(o), l = r ? -1 : 1;
  u(e, void 0, [])();
  function u(d, f, p) {
    const m = (
      /** @type {Record<string, unknown>} */
      d && typeof d == "object" ? d : {}
    );
    if (typeof m.type == "string") {
      const y = (
        // `hast`
        typeof m.tagName == "string" ? m.tagName : (
          // `xast`
          typeof m.name == "string" ? m.name : void 0
        )
      );
      Object.defineProperty(g, "name", {
        value: "node (" + (d.type + (y ? "<" + y + ">" : "")) + ")"
      });
    }
    return g;
    function g() {
      let y = uR, w, v, x;
      if ((!t || a(d, f, p[p.length - 1] || void 0)) && (y = tK(n(d, p)), y[0] === Pb))
        return y;
      if ("children" in d && d.children) {
        const E = (
          /** @type {UnistParent} */
          d
        );
        if (E.children && y[0] !== eK)
          for (v = (r ? E.children.length : -1) + l, x = p.concat(E); v > -1 && v < E.children.length; ) {
            const N = E.children[v];
            if (w = u(N, v, x)(), w[0] === Pb)
              return w;
            v = typeof w[1] == "number" ? w[1] : v + l;
          }
      }
      return y;
    }
  }
}
function tK(e) {
  return Array.isArray(e) ? e : typeof e == "number" ? [JW, e] : e == null ? uR : [e];
}
function _x(e, t, n, r) {
  let o, a, l;
  typeof t == "function" ? (a = void 0, l = t, o = n) : (a = t, l = n, o = r), cR(e, a, u, o);
  function u(d, f) {
    const p = f[f.length - 1], m = p ? p.children.indexOf(d) : void 0;
    return l(d, m, p);
  }
}
const Lb = {}.hasOwnProperty, nK = {};
function rK(e, t) {
  const n = t || nK, r = /* @__PURE__ */ new Map(), o = /* @__PURE__ */ new Map(), a = /* @__PURE__ */ new Map(), l = { ...VW, ...n.handlers }, u = {
    all: f,
    applyData: iK,
    definitionById: r,
    footnoteById: o,
    footnoteCounts: a,
    footnoteOrder: [],
    handlers: l,
    one: d,
    options: n,
    patch: oK,
    wrap: lK
  };
  return _x(e, function(p) {
    if (p.type === "definition" || p.type === "footnoteDefinition") {
      const m = p.type === "definition" ? r : o, g = String(p.identifier).toUpperCase();
      m.has(g) || m.set(g, p);
    }
  }), u;
  function d(p, m) {
    const g = p.type, y = u.handlers[g];
    if (Lb.call(u.handlers, g) && y)
      return y(u, p, m);
    if (u.options.passThrough && u.options.passThrough.includes(g)) {
      if ("children" in p) {
        const { children: w, ...v } = p, x = Hp(v);
        return x.children = u.all(p), x;
      }
      return Hp(p);
    }
    return (u.options.unknownHandler || aK)(u, p, m);
  }
  function f(p) {
    const m = [];
    if ("children" in p) {
      const g = p.children;
      let y = -1;
      for (; ++y < g.length; ) {
        const w = u.one(g[y], p);
        if (w) {
          if (y && g[y - 1].type === "break" && (!Array.isArray(w) && w.type === "text" && (w.value = JC(w.value)), !Array.isArray(w) && w.type === "element")) {
            const v = w.children[0];
            v && v.type === "text" && (v.value = JC(v.value));
          }
          Array.isArray(w) ? m.push(...w) : m.push(w);
        }
      }
    }
    return m;
  }
}
function oK(e, t) {
  e.position && (t.position = qX(e));
}
function iK(e, t) {
  let n = t;
  if (e && e.data) {
    const r = e.data.hName, o = e.data.hChildren, a = e.data.hProperties;
    if (typeof r == "string")
      if (n.type === "element")
        n.tagName = r;
      else {
        const l = "children" in n ? n.children : [n];
        n = { type: "element", tagName: r, properties: {}, children: l };
      }
    n.type === "element" && a && Object.assign(n.properties, Hp(a)), "children" in n && n.children && o !== null && o !== void 0 && (n.children = o);
  }
  return n;
}
function aK(e, t) {
  const n = t.data || {}, r = "value" in t && !(Lb.call(n, "hProperties") || Lb.call(n, "hChildren")) ? { type: "text", value: t.value } : {
    type: "element",
    tagName: "div",
    properties: {},
    children: e.all(t)
  };
  return e.patch(t, r), e.applyData(t, r);
}
function lK(e, t) {
  const n = [];
  let r = -1;
  for (t && n.push({ type: "text", value: `
` }); ++r < e.length; )
    r && n.push({ type: "text", value: `
` }), n.push(e[r]);
  return t && e.length > 0 && n.push({ type: "text", value: `
` }), n;
}
function JC(e) {
  let t = 0, n = e.charCodeAt(t);
  for (; n === 9 || n === 32; )
    t++, n = e.charCodeAt(t);
  return e.slice(t);
}
function e5(e, t) {
  const n = rK(e, t), r = n.one(e, void 0), o = XW(n), a = Array.isArray(r) ? { type: "root", children: r } : r || { type: "root", children: [] };
  return o && a.children.push({ type: "text", value: `
` }, o), a;
}
function sK(e, t) {
  return e && "run" in e ? async function(n, r) {
    const o = (
      /** @type {HastRoot} */
      e5(n, { file: r, ...t })
    );
    await e.run(o, r);
  } : function(n, r) {
    return (
      /** @type {HastRoot} */
      e5(n, { file: r, ...e || t })
    );
  };
}
function t5(e) {
  if (e)
    throw e;
}
var dv, n5;
function uK() {
  if (n5) return dv;
  n5 = 1;
  var e = Object.prototype.hasOwnProperty, t = Object.prototype.toString, n = Object.defineProperty, r = Object.getOwnPropertyDescriptor, o = function(d) {
    return typeof Array.isArray == "function" ? Array.isArray(d) : t.call(d) === "[object Array]";
  }, a = function(d) {
    if (!d || t.call(d) !== "[object Object]")
      return !1;
    var f = e.call(d, "constructor"), p = d.constructor && d.constructor.prototype && e.call(d.constructor.prototype, "isPrototypeOf");
    if (d.constructor && !f && !p)
      return !1;
    var m;
    for (m in d)
      ;
    return typeof m > "u" || e.call(d, m);
  }, l = function(d, f) {
    n && f.name === "__proto__" ? n(d, f.name, {
      enumerable: !0,
      configurable: !0,
      value: f.newValue,
      writable: !0
    }) : d[f.name] = f.newValue;
  }, u = function(d, f) {
    if (f === "__proto__")
      if (e.call(d, f)) {
        if (r)
          return r(d, f).value;
      } else return;
    return d[f];
  };
  return dv = function d() {
    var f, p, m, g, y, w, v = arguments[0], x = 1, E = arguments.length, N = !1;
    for (typeof v == "boolean" && (N = v, v = arguments[1] || {}, x = 2), (v == null || typeof v != "object" && typeof v != "function") && (v = {}); x < E; ++x)
      if (f = arguments[x], f != null)
        for (p in f)
          m = u(v, p), g = u(f, p), v !== g && (N && g && (a(g) || (y = o(g))) ? (y ? (y = !1, w = m && o(m) ? m : []) : w = m && a(m) ? m : {}, l(v, { name: p, newValue: d(N, w, g) })) : typeof g < "u" && l(v, { name: p, newValue: g }));
    return v;
  }, dv;
}
var cK = uK();
const fv = /* @__PURE__ */ th(cK);
function Ib(e) {
  if (typeof e != "object" || e === null)
    return !1;
  const t = Object.getPrototypeOf(e);
  return (t === null || t === Object.prototype || Object.getPrototypeOf(t) === null) && !(Symbol.toStringTag in e) && !(Symbol.iterator in e);
}
function dK() {
  const e = [], t = { run: n, use: r };
  return t;
  function n(...o) {
    let a = -1;
    const l = o.pop();
    if (typeof l != "function")
      throw new TypeError("Expected function as last argument, not " + l);
    u(null, ...o);
    function u(d, ...f) {
      const p = e[++a];
      let m = -1;
      if (d) {
        l(d);
        return;
      }
      for (; ++m < o.length; )
        (f[m] === null || f[m] === void 0) && (f[m] = o[m]);
      o = f, p ? fK(p, u)(...f) : l(null, ...f);
    }
  }
  function r(o) {
    if (typeof o != "function")
      throw new TypeError(
        "Expected `middelware` to be a function, not " + o
      );
    return e.push(o), t;
  }
}
function fK(e, t) {
  let n;
  return r;
  function r(...l) {
    const u = e.length > l.length;
    let d;
    u && l.push(o);
    try {
      d = e.apply(this, l);
    } catch (f) {
      const p = (
        /** @type {Error} */
        f
      );
      if (u && n)
        throw p;
      return o(p);
    }
    u || (d && d.then && typeof d.then == "function" ? d.then(a, o) : d instanceof Error ? o(d) : a(d));
  }
  function o(l, ...u) {
    n || (n = !0, t(l, ...u));
  }
  function a(l) {
    o(null, l);
  }
}
const Gr = { basename: pK, dirname: hK, extname: mK, join: gK, sep: "/" };
function pK(e, t) {
  if (t !== void 0 && typeof t != "string")
    throw new TypeError('"ext" argument must be a string');
  Gc(e);
  let n = 0, r = -1, o = e.length, a;
  if (t === void 0 || t.length === 0 || t.length > e.length) {
    for (; o--; )
      if (e.codePointAt(o) === 47) {
        if (a) {
          n = o + 1;
          break;
        }
      } else r < 0 && (a = !0, r = o + 1);
    return r < 0 ? "" : e.slice(n, r);
  }
  if (t === e)
    return "";
  let l = -1, u = t.length - 1;
  for (; o--; )
    if (e.codePointAt(o) === 47) {
      if (a) {
        n = o + 1;
        break;
      }
    } else
      l < 0 && (a = !0, l = o + 1), u > -1 && (e.codePointAt(o) === t.codePointAt(u--) ? u < 0 && (r = o) : (u = -1, r = l));
  return n === r ? r = l : r < 0 && (r = e.length), e.slice(n, r);
}
function hK(e) {
  if (Gc(e), e.length === 0)
    return ".";
  let t = -1, n = e.length, r;
  for (; --n; )
    if (e.codePointAt(n) === 47) {
      if (r) {
        t = n;
        break;
      }
    } else r || (r = !0);
  return t < 0 ? e.codePointAt(0) === 47 ? "/" : "." : t === 1 && e.codePointAt(0) === 47 ? "//" : e.slice(0, t);
}
function mK(e) {
  Gc(e);
  let t = e.length, n = -1, r = 0, o = -1, a = 0, l;
  for (; t--; ) {
    const u = e.codePointAt(t);
    if (u === 47) {
      if (l) {
        r = t + 1;
        break;
      }
      continue;
    }
    n < 0 && (l = !0, n = t + 1), u === 46 ? o < 0 ? o = t : a !== 1 && (a = 1) : o > -1 && (a = -1);
  }
  return o < 0 || n < 0 || // We saw a non-dot character immediately before the dot.
  a === 0 || // The (right-most) trimmed path component is exactly `..`.
  a === 1 && o === n - 1 && o === r + 1 ? "" : e.slice(o, n);
}
function gK(...e) {
  let t = -1, n;
  for (; ++t < e.length; )
    Gc(e[t]), e[t] && (n = n === void 0 ? e[t] : n + "/" + e[t]);
  return n === void 0 ? "." : yK(n);
}
function yK(e) {
  Gc(e);
  const t = e.codePointAt(0) === 47;
  let n = vK(e, !t);
  return n.length === 0 && !t && (n = "."), n.length > 0 && e.codePointAt(e.length - 1) === 47 && (n += "/"), t ? "/" + n : n;
}
function vK(e, t) {
  let n = "", r = 0, o = -1, a = 0, l = -1, u, d;
  for (; ++l <= e.length; ) {
    if (l < e.length)
      u = e.codePointAt(l);
    else {
      if (u === 47)
        break;
      u = 47;
    }
    if (u === 47) {
      if (!(o === l - 1 || a === 1)) if (o !== l - 1 && a === 2) {
        if (n.length < 2 || r !== 2 || n.codePointAt(n.length - 1) !== 46 || n.codePointAt(n.length - 2) !== 46) {
          if (n.length > 2) {
            if (d = n.lastIndexOf("/"), d !== n.length - 1) {
              d < 0 ? (n = "", r = 0) : (n = n.slice(0, d), r = n.length - 1 - n.lastIndexOf("/")), o = l, a = 0;
              continue;
            }
          } else if (n.length > 0) {
            n = "", r = 0, o = l, a = 0;
            continue;
          }
        }
        t && (n = n.length > 0 ? n + "/.." : "..", r = 2);
      } else
        n.length > 0 ? n += "/" + e.slice(o + 1, l) : n = e.slice(o + 1, l), r = l - o - 1;
      o = l, a = 0;
    } else u === 46 && a > -1 ? a++ : a = -1;
  }
  return n;
}
function Gc(e) {
  if (typeof e != "string")
    throw new TypeError(
      "Path must be a string. Received " + JSON.stringify(e)
    );
}
const bK = { cwd: wK };
function wK() {
  return "/";
}
function Bb(e) {
  return !!(e !== null && typeof e == "object" && "href" in e && e.href && "protocol" in e && e.protocol && // @ts-expect-error: indexing is fine.
  e.auth === void 0);
}
function xK(e) {
  if (typeof e == "string")
    e = new URL(e);
  else if (!Bb(e)) {
    const t = new TypeError(
      'The "path" argument must be of type string or an instance of URL. Received `' + e + "`"
    );
    throw t.code = "ERR_INVALID_ARG_TYPE", t;
  }
  if (e.protocol !== "file:") {
    const t = new TypeError("The URL must be of scheme file");
    throw t.code = "ERR_INVALID_URL_SCHEME", t;
  }
  return SK(e);
}
function SK(e) {
  if (e.hostname !== "") {
    const r = new TypeError(
      'File URL host must be "localhost" or empty on darwin'
    );
    throw r.code = "ERR_INVALID_FILE_URL_HOST", r;
  }
  const t = e.pathname;
  let n = -1;
  for (; ++n < t.length; )
    if (t.codePointAt(n) === 37 && t.codePointAt(n + 1) === 50) {
      const r = t.codePointAt(n + 2);
      if (r === 70 || r === 102) {
        const o = new TypeError(
          "File URL path must not include encoded / characters"
        );
        throw o.code = "ERR_INVALID_FILE_URL_PATH", o;
      }
    }
  return decodeURIComponent(t);
}
const pv = (
  /** @type {const} */
  [
    "history",
    "path",
    "basename",
    "stem",
    "extname",
    "dirname"
  ]
);
class dR {
  /**
   * Create a new virtual file.
   *
   * `options` is treated as:
   *
   * *   `string` or `Uint8Array`  `{value: options}`
   * *   `URL`  `{path: options}`
   * *   `VFile`  shallow copies its data over to the new file
   * *   `object`  all fields are shallow copied over to the new file
   *
   * Path related fields are set in the following order (least specific to
   * most specific): `history`, `path`, `basename`, `stem`, `extname`,
   * `dirname`.
   *
   * You cannot set `dirname` or `extname` without setting either `history`,
   * `path`, `basename`, or `stem` too.
   *
   * @param {Compatible | null | undefined} [value]
   *   File value.
   * @returns
   *   New instance.
   */
  constructor(t) {
    let n;
    t ? Bb(t) ? n = { path: t } : typeof t == "string" || kK(t) ? n = { value: t } : n = t : n = {}, this.cwd = "cwd" in n ? "" : bK.cwd(), this.data = {}, this.history = [], this.messages = [], this.value, this.map, this.result, this.stored;
    let r = -1;
    for (; ++r < pv.length; ) {
      const a = pv[r];
      a in n && n[a] !== void 0 && n[a] !== null && (this[a] = a === "history" ? [...n[a]] : n[a]);
    }
    let o;
    for (o in n)
      pv.includes(o) || (this[o] = n[o]);
  }
  /**
   * Get the basename (including extname) (example: `'index.min.js'`).
   *
   * @returns {string | undefined}
   *   Basename.
   */
  get basename() {
    return typeof this.path == "string" ? Gr.basename(this.path) : void 0;
  }
  /**
   * Set basename (including extname) (`'index.min.js'`).
   *
   * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\'`
   * on windows).
   * Cannot be nullified (use `file.path = file.dirname` instead).
   *
   * @param {string} basename
   *   Basename.
   * @returns {undefined}
   *   Nothing.
   */
  set basename(t) {
    mv(t, "basename"), hv(t, "basename"), this.path = Gr.join(this.dirname || "", t);
  }
  /**
   * Get the parent path (example: `'~'`).
   *
   * @returns {string | undefined}
   *   Dirname.
   */
  get dirname() {
    return typeof this.path == "string" ? Gr.dirname(this.path) : void 0;
  }
  /**
   * Set the parent path (example: `'~'`).
   *
   * Cannot be set if theres no `path` yet.
   *
   * @param {string | undefined} dirname
   *   Dirname.
   * @returns {undefined}
   *   Nothing.
   */
  set dirname(t) {
    r5(this.basename, "dirname"), this.path = Gr.join(t || "", this.basename);
  }
  /**
   * Get the extname (including dot) (example: `'.js'`).
   *
   * @returns {string | undefined}
   *   Extname.
   */
  get extname() {
    return typeof this.path == "string" ? Gr.extname(this.path) : void 0;
  }
  /**
   * Set the extname (including dot) (example: `'.js'`).
   *
   * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\'`
   * on windows).
   * Cannot be set if theres no `path` yet.
   *
   * @param {string | undefined} extname
   *   Extname.
   * @returns {undefined}
   *   Nothing.
   */
  set extname(t) {
    if (hv(t, "extname"), r5(this.dirname, "extname"), t) {
      if (t.codePointAt(0) !== 46)
        throw new Error("`extname` must start with `.`");
      if (t.includes(".", 1))
        throw new Error("`extname` cannot contain multiple dots");
    }
    this.path = Gr.join(this.dirname, this.stem + (t || ""));
  }
  /**
   * Get the full path (example: `'~/index.min.js'`).
   *
   * @returns {string}
   *   Path.
   */
  get path() {
    return this.history[this.history.length - 1];
  }
  /**
   * Set the full path (example: `'~/index.min.js'`).
   *
   * Cannot be nullified.
   * You can set a file URL (a `URL` object with a `file:` protocol) which will
   * be turned into a path with `url.fileURLToPath`.
   *
   * @param {URL | string} path
   *   Path.
   * @returns {undefined}
   *   Nothing.
   */
  set path(t) {
    Bb(t) && (t = xK(t)), mv(t, "path"), this.path !== t && this.history.push(t);
  }
  /**
   * Get the stem (basename w/o extname) (example: `'index.min'`).
   *
   * @returns {string | undefined}
   *   Stem.
   */
  get stem() {
    return typeof this.path == "string" ? Gr.basename(this.path, this.extname) : void 0;
  }
  /**
   * Set the stem (basename w/o extname) (example: `'index.min'`).
   *
   * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\'`
   * on windows).
   * Cannot be nullified (use `file.path = file.dirname` instead).
   *
   * @param {string} stem
   *   Stem.
   * @returns {undefined}
   *   Nothing.
   */
  set stem(t) {
    mv(t, "stem"), hv(t, "stem"), this.path = Gr.join(this.dirname || "", t + (this.extname || ""));
  }
  // Normal prototypal methods.
  /**
   * Create a fatal message for `reason` associated with the file.
   *
   * The `fatal` field of the message is set to `true` (error; file not usable)
   * and the `file` field is set to the current file path.
   * The message is added to the `messages` field on `file`.
   *
   * >  **Note**: also has obsolete signatures.
   *
   * @overload
   * @param {string} reason
   * @param {MessageOptions | null | undefined} [options]
   * @returns {never}
   *
   * @overload
   * @param {string} reason
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @overload
   * @param {string} reason
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @overload
   * @param {string} reason
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @param {Error | VFileMessage | string} causeOrReason
   *   Reason for message, should use markdown.
   * @param {Node | NodeLike | MessageOptions | Point | Position | string | null | undefined} [optionsOrParentOrPlace]
   *   Configuration (optional).
   * @param {string | null | undefined} [origin]
   *   Place in code where the message originates (example:
   *   `'my-package:my-rule'` or `'my-rule'`).
   * @returns {never}
   *   Never.
   * @throws {VFileMessage}
   *   Message.
   */
  fail(t, n, r) {
    const o = this.message(t, n, r);
    throw o.fatal = !0, o;
  }
  /**
   * Create an info message for `reason` associated with the file.
   *
   * The `fatal` field of the message is set to `undefined` (info; change
   * likely not needed) and the `file` field is set to the current file path.
   * The message is added to the `messages` field on `file`.
   *
   * >  **Note**: also has obsolete signatures.
   *
   * @overload
   * @param {string} reason
   * @param {MessageOptions | null | undefined} [options]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @param {Error | VFileMessage | string} causeOrReason
   *   Reason for message, should use markdown.
   * @param {Node | NodeLike | MessageOptions | Point | Position | string | null | undefined} [optionsOrParentOrPlace]
   *   Configuration (optional).
   * @param {string | null | undefined} [origin]
   *   Place in code where the message originates (example:
   *   `'my-package:my-rule'` or `'my-rule'`).
   * @returns {VFileMessage}
   *   Message.
   */
  info(t, n, r) {
    const o = this.message(t, n, r);
    return o.fatal = void 0, o;
  }
  /**
   * Create a message for `reason` associated with the file.
   *
   * The `fatal` field of the message is set to `false` (warning; change may be
   * needed) and the `file` field is set to the current file path.
   * The message is added to the `messages` field on `file`.
   *
   * >  **Note**: also has obsolete signatures.
   *
   * @overload
   * @param {string} reason
   * @param {MessageOptions | null | undefined} [options]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @param {Error | VFileMessage | string} causeOrReason
   *   Reason for message, should use markdown.
   * @param {Node | NodeLike | MessageOptions | Point | Position | string | null | undefined} [optionsOrParentOrPlace]
   *   Configuration (optional).
   * @param {string | null | undefined} [origin]
   *   Place in code where the message originates (example:
   *   `'my-package:my-rule'` or `'my-rule'`).
   * @returns {VFileMessage}
   *   Message.
   */
  message(t, n, r) {
    const o = new yn(
      // @ts-expect-error: the overloads are fine.
      t,
      n,
      r
    );
    return this.path && (o.name = this.path + ":" + o.name, o.file = this.path), o.fatal = !1, this.messages.push(o), o;
  }
  /**
   * Serialize the file.
   *
   * > **Note**: which encodings are supported depends on the engine.
   * > For info on Node.js, see:
   * > <https://nodejs.org/api/util.html#whatwg-supported-encodings>.
   *
   * @param {string | null | undefined} [encoding='utf8']
   *   Character encoding to understand `value` as when its a `Uint8Array`
   *   (default: `'utf-8'`).
   * @returns {string}
   *   Serialized file.
   */
  toString(t) {
    return this.value === void 0 ? "" : typeof this.value == "string" ? this.value : new TextDecoder(t || void 0).decode(this.value);
  }
}
function hv(e, t) {
  if (e && e.includes(Gr.sep))
    throw new Error(
      "`" + t + "` cannot be a path: did not expect `" + Gr.sep + "`"
    );
}
function mv(e, t) {
  if (!e)
    throw new Error("`" + t + "` cannot be empty");
}
function r5(e, t) {
  if (!e)
    throw new Error("Setting `" + t + "` requires `path` to be set too");
}
function kK(e) {
  return !!(e && typeof e == "object" && "byteLength" in e && "byteOffset" in e);
}
const _K = (
  /**
   * @type {new <Parameters extends Array<unknown>, Result>(property: string | symbol) => (...parameters: Parameters) => Result}
   */
  /** @type {unknown} */
  /**
   * @this {Function}
   * @param {string | symbol} property
   * @returns {(...parameters: Array<unknown>) => unknown}
   */
  function(e) {
    const t = (
      /** @type {Record<string | symbol, Function>} */
      // Prototypes do exist.
      // type-coverage:ignore-next-line
      this.constructor.prototype
    ), n = t[e], r = function() {
      return n.apply(r, arguments);
    };
    return Object.setPrototypeOf(r, t), r;
  }
), EK = {}.hasOwnProperty;
class Ex extends _K {
  /**
   * Create a processor.
   */
  constructor() {
    super("copy"), this.Compiler = void 0, this.Parser = void 0, this.attachers = [], this.compiler = void 0, this.freezeIndex = -1, this.frozen = void 0, this.namespace = {}, this.parser = void 0, this.transformers = dK();
  }
  /**
   * Copy a processor.
   *
   * @deprecated
   *   This is a private internal method and should not be used.
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *   New *unfrozen* processor ({@linkcode Processor}) that is
   *   configured to work the same as its ancestor.
   *   When the descendant processor is configured in the future it does not
   *   affect the ancestral processor.
   */
  copy() {
    const t = (
      /** @type {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>} */
      new Ex()
    );
    let n = -1;
    for (; ++n < this.attachers.length; ) {
      const r = this.attachers[n];
      t.use(...r);
    }
    return t.data(fv(!0, {}, this.namespace)), t;
  }
  /**
   * Configure the processor with info available to all plugins.
   * Information is stored in an object.
   *
   * Typically, options can be given to a specific plugin, but sometimes it
   * makes sense to have information shared with several plugins.
   * For example, a list of HTML elements that are self-closing, which is
   * needed during all phases.
   *
   * > **Note**: setting information cannot occur on *frozen* processors.
   * > Call the processor first to create a new unfrozen processor.
   *
   * > **Note**: to register custom data in TypeScript, augment the
   * > {@linkcode Data} interface.
   *
   * @example
   *   This example show how to get and set info:
   *
   *   ```js
   *   import {unified} from 'unified'
   *
   *   const processor = unified().data('alpha', 'bravo')
   *
   *   processor.data('alpha') // => 'bravo'
   *
   *   processor.data() // => {alpha: 'bravo'}
   *
   *   processor.data({charlie: 'delta'})
   *
   *   processor.data() // => {charlie: 'delta'}
   *   ```
   *
   * @template {keyof Data} Key
   *
   * @overload
   * @returns {Data}
   *
   * @overload
   * @param {Data} dataset
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *
   * @overload
   * @param {Key} key
   * @returns {Data[Key]}
   *
   * @overload
   * @param {Key} key
   * @param {Data[Key]} value
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *
   * @param {Data | Key} [key]
   *   Key to get or set, or entire dataset to set, or nothing to get the
   *   entire dataset (optional).
   * @param {Data[Key]} [value]
   *   Value to set (optional).
   * @returns {unknown}
   *   The current processor when setting, the value at `key` when getting, or
   *   the entire dataset when getting without key.
   */
  data(t, n) {
    return typeof t == "string" ? arguments.length === 2 ? (vv("data", this.frozen), this.namespace[t] = n, this) : EK.call(this.namespace, t) && this.namespace[t] || void 0 : t ? (vv("data", this.frozen), this.namespace = t, this) : this.namespace;
  }
  /**
   * Freeze a processor.
   *
   * Frozen processors are meant to be extended and not to be configured
   * directly.
   *
   * When a processor is frozen it cannot be unfrozen.
   * New processors working the same way can be created by calling the
   * processor.
   *
   * Its possible to freeze processors explicitly by calling `.freeze()`.
   * Processors freeze automatically when `.parse()`, `.run()`, `.runSync()`,
   * `.stringify()`, `.process()`, or `.processSync()` are called.
   *
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *   The current processor.
   */
  freeze() {
    if (this.frozen)
      return this;
    const t = (
      /** @type {Processor} */
      /** @type {unknown} */
      this
    );
    for (; ++this.freezeIndex < this.attachers.length; ) {
      const [n, ...r] = this.attachers[this.freezeIndex];
      if (r[0] === !1)
        continue;
      r[0] === !0 && (r[0] = void 0);
      const o = n.call(t, ...r);
      typeof o == "function" && this.transformers.use(o);
    }
    return this.frozen = !0, this.freezeIndex = Number.POSITIVE_INFINITY, this;
  }
  /**
   * Parse text to a syntax tree.
   *
   * > **Note**: `parse` freezes the processor if not already *frozen*.
   *
   * > **Note**: `parse` performs the parse phase, not the run phase or other
   * > phases.
   *
   * @param {Compatible | undefined} [file]
   *   file to parse (optional); typically `string` or `VFile`; any value
   *   accepted as `x` in `new VFile(x)`.
   * @returns {ParseTree extends undefined ? Node : ParseTree}
   *   Syntax tree representing `file`.
   */
  parse(t) {
    this.freeze();
    const n = If(t), r = this.parser || this.Parser;
    return gv("parse", r), r(String(n), n);
  }
  /**
   * Process the given file as configured on the processor.
   *
   * > **Note**: `process` freezes the processor if not already *frozen*.
   *
   * > **Note**: `process` performs the parse, run, and stringify phases.
   *
   * @overload
   * @param {Compatible | undefined} file
   * @param {ProcessCallback<VFileWithOutput<CompileResult>>} done
   * @returns {undefined}
   *
   * @overload
   * @param {Compatible | undefined} [file]
   * @returns {Promise<VFileWithOutput<CompileResult>>}
   *
   * @param {Compatible | undefined} [file]
   *   File (optional); typically `string` or `VFile`]; any value accepted as
   *   `x` in `new VFile(x)`.
   * @param {ProcessCallback<VFileWithOutput<CompileResult>> | undefined} [done]
   *   Callback (optional).
   * @returns {Promise<VFile> | undefined}
   *   Nothing if `done` is given.
   *   Otherwise a promise, rejected with a fatal error or resolved with the
   *   processed file.
   *
   *   The parsed, transformed, and compiled value is available at
   *   `file.value` (see note).
   *
   *   > **Note**: unified typically compiles by serializing: most
   *   > compilers return `string` (or `Uint8Array`).
   *   > Some compilers, such as the one configured with
   *   > [`rehype-react`][rehype-react], return other values (in this case, a
   *   > React tree).
   *   > If youre using a compiler that doesnt serialize, expect different
   *   > result values.
   *   >
   *   > To register custom results in TypeScript, add them to
   *   > {@linkcode CompileResultMap}.
   *
   *   [rehype-react]: https://github.com/rehypejs/rehype-react
   */
  process(t, n) {
    const r = this;
    return this.freeze(), gv("process", this.parser || this.Parser), yv("process", this.compiler || this.Compiler), n ? o(void 0, n) : new Promise(o);
    function o(a, l) {
      const u = If(t), d = (
        /** @type {HeadTree extends undefined ? Node : HeadTree} */
        /** @type {unknown} */
        r.parse(u)
      );
      r.run(d, u, function(p, m, g) {
        if (p || !m || !g)
          return f(p);
        const y = (
          /** @type {CompileTree extends undefined ? Node : CompileTree} */
          /** @type {unknown} */
          m
        ), w = r.stringify(y, g);
        NK(w) ? g.value = w : g.result = w, f(
          p,
          /** @type {VFileWithOutput<CompileResult>} */
          g
        );
      });
      function f(p, m) {
        p || !m ? l(p) : a ? a(m) : n(void 0, m);
      }
    }
  }
  /**
   * Process the given file as configured on the processor.
   *
   * An error is thrown if asynchronous transforms are configured.
   *
   * > **Note**: `processSync` freezes the processor if not already *frozen*.
   *
   * > **Note**: `processSync` performs the parse, run, and stringify phases.
   *
   * @param {Compatible | undefined} [file]
   *   File (optional); typically `string` or `VFile`; any value accepted as
   *   `x` in `new VFile(x)`.
   * @returns {VFileWithOutput<CompileResult>}
   *   The processed file.
   *
   *   The parsed, transformed, and compiled value is available at
   *   `file.value` (see note).
   *
   *   > **Note**: unified typically compiles by serializing: most
   *   > compilers return `string` (or `Uint8Array`).
   *   > Some compilers, such as the one configured with
   *   > [`rehype-react`][rehype-react], return other values (in this case, a
   *   > React tree).
   *   > If youre using a compiler that doesnt serialize, expect different
   *   > result values.
   *   >
   *   > To register custom results in TypeScript, add them to
   *   > {@linkcode CompileResultMap}.
   *
   *   [rehype-react]: https://github.com/rehypejs/rehype-react
   */
  processSync(t) {
    let n = !1, r;
    return this.freeze(), gv("processSync", this.parser || this.Parser), yv("processSync", this.compiler || this.Compiler), this.process(t, o), i5("processSync", "process", n), r;
    function o(a, l) {
      n = !0, t5(a), r = l;
    }
  }
  /**
   * Run *transformers* on a syntax tree.
   *
   * > **Note**: `run` freezes the processor if not already *frozen*.
   *
   * > **Note**: `run` performs the run phase, not other phases.
   *
   * @overload
   * @param {HeadTree extends undefined ? Node : HeadTree} tree
   * @param {RunCallback<TailTree extends undefined ? Node : TailTree>} done
   * @returns {undefined}
   *
   * @overload
   * @param {HeadTree extends undefined ? Node : HeadTree} tree
   * @param {Compatible | undefined} file
   * @param {RunCallback<TailTree extends undefined ? Node : TailTree>} done
   * @returns {undefined}
   *
   * @overload
   * @param {HeadTree extends undefined ? Node : HeadTree} tree
   * @param {Compatible | undefined} [file]
   * @returns {Promise<TailTree extends undefined ? Node : TailTree>}
   *
   * @param {HeadTree extends undefined ? Node : HeadTree} tree
   *   Tree to transform and inspect.
   * @param {(
   *   RunCallback<TailTree extends undefined ? Node : TailTree> |
   *   Compatible
   * )} [file]
   *   File associated with `node` (optional); any value accepted as `x` in
   *   `new VFile(x)`.
   * @param {RunCallback<TailTree extends undefined ? Node : TailTree>} [done]
   *   Callback (optional).
   * @returns {Promise<TailTree extends undefined ? Node : TailTree> | undefined}
   *   Nothing if `done` is given.
   *   Otherwise, a promise rejected with a fatal error or resolved with the
   *   transformed tree.
   */
  run(t, n, r) {
    o5(t), this.freeze();
    const o = this.transformers;
    return !r && typeof n == "function" && (r = n, n = void 0), r ? a(void 0, r) : new Promise(a);
    function a(l, u) {
      const d = If(n);
      o.run(t, d, f);
      function f(p, m, g) {
        const y = (
          /** @type {TailTree extends undefined ? Node : TailTree} */
          m || t
        );
        p ? u(p) : l ? l(y) : r(void 0, y, g);
      }
    }
  }
  /**
   * Run *transformers* on a syntax tree.
   *
   * An error is thrown if asynchronous transforms are configured.
   *
   * > **Note**: `runSync` freezes the processor if not already *frozen*.
   *
   * > **Note**: `runSync` performs the run phase, not other phases.
   *
   * @param {HeadTree extends undefined ? Node : HeadTree} tree
   *   Tree to transform and inspect.
   * @param {Compatible | undefined} [file]
   *   File associated with `node` (optional); any value accepted as `x` in
   *   `new VFile(x)`.
   * @returns {TailTree extends undefined ? Node : TailTree}
   *   Transformed tree.
   */
  runSync(t, n) {
    let r = !1, o;
    return this.run(t, n, a), i5("runSync", "run", r), o;
    function a(l, u) {
      t5(l), o = u, r = !0;
    }
  }
  /**
   * Compile a syntax tree.
   *
   * > **Note**: `stringify` freezes the processor if not already *frozen*.
   *
   * > **Note**: `stringify` performs the stringify phase, not the run phase
   * > or other phases.
   *
   * @param {CompileTree extends undefined ? Node : CompileTree} tree
   *   Tree to compile.
   * @param {Compatible | undefined} [file]
   *   File associated with `node` (optional); any value accepted as `x` in
   *   `new VFile(x)`.
   * @returns {CompileResult extends undefined ? Value : CompileResult}
   *   Textual representation of the tree (see note).
   *
   *   > **Note**: unified typically compiles by serializing: most compilers
   *   > return `string` (or `Uint8Array`).
   *   > Some compilers, such as the one configured with
   *   > [`rehype-react`][rehype-react], return other values (in this case, a
   *   > React tree).
   *   > If youre using a compiler that doesnt serialize, expect different
   *   > result values.
   *   >
   *   > To register custom results in TypeScript, add them to
   *   > {@linkcode CompileResultMap}.
   *
   *   [rehype-react]: https://github.com/rehypejs/rehype-react
   */
  stringify(t, n) {
    this.freeze();
    const r = If(n), o = this.compiler || this.Compiler;
    return yv("stringify", o), o5(t), o(t, r);
  }
  /**
   * Configure the processor to use a plugin, a list of usable values, or a
   * preset.
   *
   * If the processor is already using a plugin, the previous plugin
   * configuration is changed based on the options that are passed in.
   * In other words, the plugin is not added a second time.
   *
   * > **Note**: `use` cannot be called on *frozen* processors.
   * > Call the processor first to create a new unfrozen processor.
   *
   * @example
   *   There are many ways to pass plugins to `.use()`.
   *   This example gives an overview:
   *
   *   ```js
   *   import {unified} from 'unified'
   *
   *   unified()
   *     // Plugin with options:
   *     .use(pluginA, {x: true, y: true})
   *     // Passing the same plugin again merges configuration (to `{x: true, y: false, z: true}`):
   *     .use(pluginA, {y: false, z: true})
   *     // Plugins:
   *     .use([pluginB, pluginC])
   *     // Two plugins, the second with options:
   *     .use([pluginD, [pluginE, {}]])
   *     // Preset with plugins and settings:
   *     .use({plugins: [pluginF, [pluginG, {}]], settings: {position: false}})
   *     // Settings only:
   *     .use({settings: {position: false}})
   *   ```
   *
   * @template {Array<unknown>} [Parameters=[]]
   * @template {Node | string | undefined} [Input=undefined]
   * @template [Output=Input]
   *
   * @overload
   * @param {Preset | null | undefined} [preset]
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *
   * @overload
   * @param {PluggableList} list
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *
   * @overload
   * @param {Plugin<Parameters, Input, Output>} plugin
   * @param {...(Parameters | [boolean])} parameters
   * @returns {UsePlugin<ParseTree, HeadTree, TailTree, CompileTree, CompileResult, Input, Output>}
   *
   * @param {PluggableList | Plugin | Preset | null | undefined} value
   *   Usable value.
   * @param {...unknown} parameters
   *   Parameters, when a plugin is given as a usable value.
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *   Current processor.
   */
  use(t, ...n) {
    const r = this.attachers, o = this.namespace;
    if (vv("use", this.frozen), t != null) if (typeof t == "function")
      d(t, n);
    else if (typeof t == "object")
      Array.isArray(t) ? u(t) : l(t);
    else
      throw new TypeError("Expected usable value, not `" + t + "`");
    return this;
    function a(f) {
      if (typeof f == "function")
        d(f, []);
      else if (typeof f == "object")
        if (Array.isArray(f)) {
          const [p, ...m] = (
            /** @type {PluginTuple<Array<unknown>>} */
            f
          );
          d(p, m);
        } else
          l(f);
      else
        throw new TypeError("Expected usable value, not `" + f + "`");
    }
    function l(f) {
      if (!("plugins" in f) && !("settings" in f))
        throw new Error(
          "Expected usable value but received an empty preset, which is probably a mistake: presets typically come with `plugins` and sometimes with `settings`, but this has neither"
        );
      u(f.plugins), f.settings && (o.settings = fv(!0, o.settings, f.settings));
    }
    function u(f) {
      let p = -1;
      if (f != null) if (Array.isArray(f))
        for (; ++p < f.length; ) {
          const m = f[p];
          a(m);
        }
      else
        throw new TypeError("Expected a list of plugins, not `" + f + "`");
    }
    function d(f, p) {
      let m = -1, g = -1;
      for (; ++m < r.length; )
        if (r[m][0] === f) {
          g = m;
          break;
        }
      if (g === -1)
        r.push([f, ...p]);
      else if (p.length > 0) {
        let [y, ...w] = p;
        const v = r[g][1];
        Ib(v) && Ib(y) && (y = fv(!0, v, y)), r[g] = [f, y, ...w];
      }
    }
  }
}
const CK = new Ex().freeze();
function gv(e, t) {
  if (typeof t != "function")
    throw new TypeError("Cannot `" + e + "` without `parser`");
}
function yv(e, t) {
  if (typeof t != "function")
    throw new TypeError("Cannot `" + e + "` without `compiler`");
}
function vv(e, t) {
  if (t)
    throw new Error(
      "Cannot call `" + e + "` on a frozen processor.\nCreate a new processor first, by calling it: use `processor()` instead of `processor`."
    );
}
function o5(e) {
  if (!Ib(e) || typeof e.type != "string")
    throw new TypeError("Expected node, got `" + e + "`");
}
function i5(e, t, n) {
  if (!n)
    throw new Error(
      "`" + e + "` finished async. Use `" + t + "` instead"
    );
}
function If(e) {
  return OK(e) ? e : new dR(e);
}
function OK(e) {
  return !!(e && typeof e == "object" && "message" in e && "messages" in e);
}
function NK(e) {
  return typeof e == "string" || MK(e);
}
function MK(e) {
  return !!(e && typeof e == "object" && "byteLength" in e && "byteOffset" in e);
}
const AK = "https://github.com/remarkjs/react-markdown/blob/main/changelog.md", a5 = [], l5 = { allowDangerousHtml: !0 }, RK = /^(https?|ircs?|mailto|xmpp)$/i, jK = [
  { from: "astPlugins", id: "remove-buggy-html-in-markdown-parser" },
  { from: "allowDangerousHtml", id: "remove-buggy-html-in-markdown-parser" },
  {
    from: "allowNode",
    id: "replace-allownode-allowedtypes-and-disallowedtypes",
    to: "allowElement"
  },
  {
    from: "allowedTypes",
    id: "replace-allownode-allowedtypes-and-disallowedtypes",
    to: "allowedElements"
  },
  { from: "className", id: "remove-classname" },
  {
    from: "disallowedTypes",
    id: "replace-allownode-allowedtypes-and-disallowedtypes",
    to: "disallowedElements"
  },
  { from: "escapeHtml", id: "remove-buggy-html-in-markdown-parser" },
  { from: "includeElementIndex", id: "#remove-includeelementindex" },
  {
    from: "includeNodeIndex",
    id: "change-includenodeindex-to-includeelementindex"
  },
  { from: "linkTarget", id: "remove-linktarget" },
  { from: "plugins", id: "change-plugins-to-remarkplugins", to: "remarkPlugins" },
  { from: "rawSourcePos", id: "#remove-rawsourcepos" },
  { from: "renderers", id: "change-renderers-to-components", to: "components" },
  { from: "source", id: "change-source-to-children", to: "children" },
  { from: "sourcePos", id: "#remove-sourcepos" },
  { from: "transformImageUri", id: "#add-urltransform", to: "urlTransform" },
  { from: "transformLinkUri", id: "#add-urltransform", to: "urlTransform" }
];
function DK(e) {
  const t = TK(e), n = zK(e);
  return PK(t.runSync(t.parse(n), n), e);
}
function TK(e) {
  const t = e.rehypePlugins || a5, n = e.remarkPlugins || a5, r = e.remarkRehypeOptions ? { ...e.remarkRehypeOptions, ...l5 } : l5;
  return CK().use(hW).use(n).use(sK, r).use(t);
}
function zK(e) {
  const t = e.children || "", n = new dR();
  return typeof t == "string" && (n.value = t), n;
}
function PK(e, t) {
  const n = t.allowedElements, r = t.allowElement, o = t.components, a = t.disallowedElements, l = t.skipHtml, u = t.unwrapDisallowed, d = t.urlTransform || LK;
  for (const p of jK)
    Object.hasOwn(t, p.from) && "" + p.from + (p.to ? "use `" + p.to + "` instead" : "remove it") + AK + p.id;
  return _x(e, f), KX(e, {
    Fragment: k.Fragment,
    components: o,
    ignoreInvalidStyle: !0,
    jsx: k.jsx,
    jsxs: k.jsxs,
    passKeys: !0,
    passNode: !0
  });
  function f(p, m, g) {
    if (p.type === "raw" && g && typeof m == "number")
      return l ? g.children.splice(m, 1) : g.children[m] = { type: "text", value: p.value }, m;
    if (p.type === "element") {
      let y;
      for (y in sv)
        if (Object.hasOwn(sv, y) && Object.hasOwn(p.properties, y)) {
          const w = p.properties[y], v = sv[y];
          (v === null || v.includes(p.tagName)) && (p.properties[y] = d(String(w || ""), y, p));
        }
    }
    if (p.type === "element") {
      let y = n ? !n.includes(p.tagName) : a ? a.includes(p.tagName) : !1;
      if (!y && r && typeof m == "number" && (y = !r(p, m, g)), y && g && typeof m == "number")
        return u && p.children ? g.children.splice(m, 1, ...p.children) : g.children.splice(m, 1), m;
    }
  }
}
function LK(e) {
  const t = e.indexOf(":"), n = e.indexOf("?"), r = e.indexOf("#"), o = e.indexOf("/");
  return (
    // If there is no protocol, its relative.
    t === -1 || // If the first colon is after a `?`, `#`, or `/`, its not a protocol.
    o !== -1 && t > o || n !== -1 && t > n || r !== -1 && t > r || // It is a protocol, it should be allowed.
    RK.test(e.slice(0, t)) ? e : ""
  );
}
function s5(e, t) {
  const n = String(e);
  if (typeof t != "string")
    throw new TypeError("Expected character");
  let r = 0, o = n.indexOf(t);
  for (; o !== -1; )
    r++, o = n.indexOf(t, o + t.length);
  return r;
}
function IK(e) {
  if (typeof e != "string")
    throw new TypeError("Expected a string");
  return e.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d");
}
function BK(e, t, n) {
  const r = Vh((n || {}).ignore || []), o = VK(t);
  let a = -1;
  for (; ++a < o.length; )
    cR(e, "text", l);
  function l(d, f) {
    let p = -1, m;
    for (; ++p < f.length; ) {
      const g = f[p], y = m ? m.children : void 0;
      if (r(
        g,
        y ? y.indexOf(g) : void 0,
        m
      ))
        return;
      m = g;
    }
    if (m)
      return u(d, f);
  }
  function u(d, f) {
    const p = f[f.length - 1], m = o[a][0], g = o[a][1];
    let y = 0;
    const w = p.children.indexOf(d);
    let v = !1, x = [];
    m.lastIndex = 0;
    let E = m.exec(d.value);
    for (; E; ) {
      const N = E.index, C = {
        index: E.index,
        input: E.input,
        stack: [...f, d]
      };
      let A = g(...E, C);
      if (typeof A == "string" && (A = A.length > 0 ? { type: "text", value: A } : void 0), A === !1 ? m.lastIndex = N + 1 : (y !== N && x.push({
        type: "text",
        value: d.value.slice(y, N)
      }), Array.isArray(A) ? x.push(...A) : A && x.push(A), y = N + E[0].length, v = !0), !m.global)
        break;
      E = m.exec(d.value);
    }
    return v ? (y < d.value.length && x.push({ type: "text", value: d.value.slice(y) }), p.children.splice(w, 1, ...x)) : x = [d], w + x.length;
  }
}
function VK(e) {
  const t = [];
  if (!Array.isArray(e))
    throw new TypeError("Expected find and replace tuple or list of tuples");
  const n = !e[0] || Array.isArray(e[0]) ? e : [e];
  let r = -1;
  for (; ++r < n.length; ) {
    const o = n[r];
    t.push([HK(o[0]), UK(o[1])]);
  }
  return t;
}
function HK(e) {
  return typeof e == "string" ? new RegExp(IK(e), "g") : e;
}
function UK(e) {
  return typeof e == "function" ? e : function() {
    return e;
  };
}
const bv = "phrasing", wv = ["autolink", "link", "image", "label"];
function FK() {
  return {
    transforms: [WK],
    enter: {
      literalAutolink: YK,
      literalAutolinkEmail: xv,
      literalAutolinkHttp: xv,
      literalAutolinkWww: xv
    },
    exit: {
      literalAutolink: ZK,
      literalAutolinkEmail: GK,
      literalAutolinkHttp: qK,
      literalAutolinkWww: XK
    }
  };
}
function $K() {
  return {
    unsafe: [
      {
        character: "@",
        before: "[+\\-.\\w]",
        after: "[\\-.\\w]",
        inConstruct: bv,
        notInConstruct: wv
      },
      {
        character: ".",
        before: "[Ww]",
        after: "[\\-.\\w]",
        inConstruct: bv,
        notInConstruct: wv
      },
      {
        character: ":",
        before: "[ps]",
        after: "\\/",
        inConstruct: bv,
        notInConstruct: wv
      }
    ]
  };
}
function YK(e) {
  this.enter({ type: "link", title: null, url: "", children: [] }, e);
}
function xv(e) {
  this.config.enter.autolinkProtocol.call(this, e);
}
function qK(e) {
  this.config.exit.autolinkProtocol.call(this, e);
}
function XK(e) {
  this.config.exit.data.call(this, e);
  const t = this.stack[this.stack.length - 1];
  t.type, t.url = "http://" + this.sliceSerialize(e);
}
function GK(e) {
  this.config.exit.autolinkEmail.call(this, e);
}
function ZK(e) {
  this.exit(e);
}
function WK(e) {
  BK(
    e,
    [
      [/(https?:\/\/|www(?=\.))([-.\w]+)([^ \t\r\n]*)/gi, KK],
      [new RegExp("(?<=^|\\s|\\p{P}|\\p{S})([-.\\w+]+)@([-\\w]+(?:\\.[-\\w]+)+)", "gu"), QK]
    ],
    { ignore: ["link", "linkReference"] }
  );
}
function KK(e, t, n, r, o) {
  let a = "";
  if (!fR(o) || (/^w/i.test(t) && (n = t + n, t = "", a = "http://"), !JK(n)))
    return !1;
  const l = eQ(n + r);
  if (!l[0]) return !1;
  const u = {
    type: "link",
    title: null,
    url: a + t + l[0],
    children: [{ type: "text", value: t + l[0] }]
  };
  return l[1] ? [u, { type: "text", value: l[1] }] : u;
}
function QK(e, t, n, r) {
  return (
    // Not an expected previous character.
    !fR(r, !0) || // Label ends in not allowed character.
    /[-\d_]$/.test(n) ? !1 : {
      type: "link",
      title: null,
      url: "mailto:" + t + "@" + n,
      children: [{ type: "text", value: t + "@" + n }]
    }
  );
}
function JK(e) {
  const t = e.split(".");
  return !(t.length < 2 || t[t.length - 1] && (/_/.test(t[t.length - 1]) || !/[a-zA-Z\d]/.test(t[t.length - 1])) || t[t.length - 2] && (/_/.test(t[t.length - 2]) || !/[a-zA-Z\d]/.test(t[t.length - 2])));
}
function eQ(e) {
  const t = /[!"&'),.:;<>?\]}]+$/.exec(e);
  if (!t)
    return [e, void 0];
  e = e.slice(0, t.index);
  let n = t[0], r = n.indexOf(")");
  const o = s5(e, "(");
  let a = s5(e, ")");
  for (; r !== -1 && o > a; )
    e += n.slice(0, r + 1), n = n.slice(r + 1), r = n.indexOf(")"), a++;
  return [e, n];
}
function fR(e, t) {
  const n = e.input.charCodeAt(e.index - 1);
  return (e.index === 0 || La(n) || Lh(n)) && // If its an email, the previous character should not be a slash.
  (!t || n !== 47);
}
pR.peek = uQ;
function tQ() {
  this.buffer();
}
function nQ(e) {
  this.enter({ type: "footnoteReference", identifier: "", label: "" }, e);
}
function rQ() {
  this.buffer();
}
function oQ(e) {
  this.enter(
    { type: "footnoteDefinition", identifier: "", label: "", children: [] },
    e
  );
}
function iQ(e) {
  const t = this.resume(), n = this.stack[this.stack.length - 1];
  n.type, n.identifier = Rr(
    this.sliceSerialize(e)
  ).toLowerCase(), n.label = t;
}
function aQ(e) {
  this.exit(e);
}
function lQ(e) {
  const t = this.resume(), n = this.stack[this.stack.length - 1];
  n.type, n.identifier = Rr(
    this.sliceSerialize(e)
  ).toLowerCase(), n.label = t;
}
function sQ(e) {
  this.exit(e);
}
function uQ() {
  return "[";
}
function pR(e, t, n, r) {
  const o = n.createTracker(r);
  let a = o.move("[^");
  const l = n.enter("footnoteReference"), u = n.enter("reference");
  return a += o.move(
    n.safe(n.associationId(e), { after: "]", before: a })
  ), u(), l(), a += o.move("]"), a;
}
function cQ() {
  return {
    enter: {
      gfmFootnoteCallString: tQ,
      gfmFootnoteCall: nQ,
      gfmFootnoteDefinitionLabelString: rQ,
      gfmFootnoteDefinition: oQ
    },
    exit: {
      gfmFootnoteCallString: iQ,
      gfmFootnoteCall: aQ,
      gfmFootnoteDefinitionLabelString: lQ,
      gfmFootnoteDefinition: sQ
    }
  };
}
function dQ(e) {
  let t = !1;
  return e && e.firstLineBlank && (t = !0), {
    handlers: { footnoteDefinition: n, footnoteReference: pR },
    // This is on by default already.
    unsafe: [{ character: "[", inConstruct: ["label", "phrasing", "reference"] }]
  };
  function n(r, o, a, l) {
    const u = a.createTracker(l);
    let d = u.move("[^");
    const f = a.enter("footnoteDefinition"), p = a.enter("label");
    return d += u.move(
      a.safe(a.associationId(r), { before: d, after: "]" })
    ), p(), d += u.move("]:"), r.children && r.children.length > 0 && (u.shift(4), d += u.move(
      (t ? `
` : " ") + a.indentLines(
        a.containerFlow(r, u.current()),
        t ? hR : fQ
      )
    )), f(), d;
  }
}
function fQ(e, t, n) {
  return t === 0 ? e : hR(e, t, n);
}
function hR(e, t, n) {
  return (n ? "" : "    ") + e;
}
const pQ = [
  "autolink",
  "destinationLiteral",
  "destinationRaw",
  "reference",
  "titleQuote",
  "titleApostrophe"
];
mR.peek = vQ;
function hQ() {
  return {
    canContainEols: ["delete"],
    enter: { strikethrough: gQ },
    exit: { strikethrough: yQ }
  };
}
function mQ() {
  return {
    unsafe: [
      {
        character: "~",
        inConstruct: "phrasing",
        notInConstruct: pQ
      }
    ],
    handlers: { delete: mR }
  };
}
function gQ(e) {
  this.enter({ type: "delete", children: [] }, e);
}
function yQ(e) {
  this.exit(e);
}
function mR(e, t, n, r) {
  const o = n.createTracker(r), a = n.enter("strikethrough");
  let l = o.move("~~");
  return l += n.containerPhrasing(e, {
    ...o.current(),
    before: l,
    after: "~"
  }), l += o.move("~~"), a(), l;
}
function vQ() {
  return "~";
}
function bQ(e) {
  return e.length;
}
function wQ(e, t) {
  const n = t || {}, r = (n.align || []).concat(), o = n.stringLength || bQ, a = [], l = [], u = [], d = [];
  let f = 0, p = -1;
  for (; ++p < e.length; ) {
    const v = [], x = [];
    let E = -1;
    for (e[p].length > f && (f = e[p].length); ++E < e[p].length; ) {
      const N = xQ(e[p][E]);
      if (n.alignDelimiters !== !1) {
        const C = o(N);
        x[E] = C, (d[E] === void 0 || C > d[E]) && (d[E] = C);
      }
      v.push(N);
    }
    l[p] = v, u[p] = x;
  }
  let m = -1;
  if (typeof r == "object" && "length" in r)
    for (; ++m < f; )
      a[m] = u5(r[m]);
  else {
    const v = u5(r);
    for (; ++m < f; )
      a[m] = v;
  }
  m = -1;
  const g = [], y = [];
  for (; ++m < f; ) {
    const v = a[m];
    let x = "", E = "";
    v === 99 ? (x = ":", E = ":") : v === 108 ? x = ":" : v === 114 && (E = ":");
    let N = n.alignDelimiters === !1 ? 1 : Math.max(
      1,
      d[m] - x.length - E.length
    );
    const C = x + "-".repeat(N) + E;
    n.alignDelimiters !== !1 && (N = x.length + N + E.length, N > d[m] && (d[m] = N), y[m] = N), g[m] = C;
  }
  l.splice(1, 0, g), u.splice(1, 0, y), p = -1;
  const w = [];
  for (; ++p < l.length; ) {
    const v = l[p], x = u[p];
    m = -1;
    const E = [];
    for (; ++m < f; ) {
      const N = v[m] || "";
      let C = "", A = "";
      if (n.alignDelimiters !== !1) {
        const R = d[m] - (x[m] || 0), D = a[m];
        D === 114 ? C = " ".repeat(R) : D === 99 ? R % 2 ? (C = " ".repeat(R / 2 + 0.5), A = " ".repeat(R / 2 - 0.5)) : (C = " ".repeat(R / 2), A = C) : A = " ".repeat(R);
      }
      n.delimiterStart !== !1 && !m && E.push("|"), n.padding !== !1 && // Dont add the opening space if were not aligning and the cell is
      // empty: there will be a closing space.
      !(n.alignDelimiters === !1 && N === "") && (n.delimiterStart !== !1 || m) && E.push(" "), n.alignDelimiters !== !1 && E.push(C), E.push(N), n.alignDelimiters !== !1 && E.push(A), n.padding !== !1 && E.push(" "), (n.delimiterEnd !== !1 || m !== f - 1) && E.push("|");
    }
    w.push(
      n.delimiterEnd === !1 ? E.join("").replace(/ +$/, "") : E.join("")
    );
  }
  return w.join(`
`);
}
function xQ(e) {
  return e == null ? "" : String(e);
}
function u5(e) {
  const t = typeof e == "string" ? e.codePointAt(0) : 0;
  return t === 67 || t === 99 ? 99 : t === 76 || t === 108 ? 108 : t === 82 || t === 114 ? 114 : 0;
}
function SQ(e, t, n, r) {
  const o = n.enter("blockquote"), a = n.createTracker(r);
  a.move("> "), a.shift(2);
  const l = n.indentLines(
    n.containerFlow(e, a.current()),
    kQ
  );
  return o(), l;
}
function kQ(e, t, n) {
  return ">" + (n ? "" : " ") + e;
}
function _Q(e, t) {
  return c5(e, t.inConstruct, !0) && !c5(e, t.notInConstruct, !1);
}
function c5(e, t, n) {
  if (typeof t == "string" && (t = [t]), !t || t.length === 0)
    return n;
  let r = -1;
  for (; ++r < t.length; )
    if (e.includes(t[r]))
      return !0;
  return !1;
}
function d5(e, t, n, r) {
  let o = -1;
  for (; ++o < n.unsafe.length; )
    if (n.unsafe[o].character === `
` && _Q(n.stack, n.unsafe[o]))
      return /[ \t]/.test(r.before) ? "" : " ";
  return `\\
`;
}
function EQ(e, t) {
  const n = String(e);
  let r = n.indexOf(t), o = r, a = 0, l = 0;
  if (typeof t != "string")
    throw new TypeError("Expected substring");
  for (; r !== -1; )
    r === o ? ++a > l && (l = a) : a = 1, o = r + t.length, r = n.indexOf(t, o);
  return l;
}
function CQ(e, t) {
  return !!(t.options.fences === !1 && e.value && // If theres no info
  !e.lang && // And theres a non-whitespace character
  /[^ \r\n]/.test(e.value) && // And the value doesnt start or end in a blank
  !/^[\t ]*(?:[\r\n]|$)|(?:^|[\r\n])[\t ]*$/.test(e.value));
}
function OQ(e) {
  const t = e.options.fence || "`";
  if (t !== "`" && t !== "~")
    throw new Error(
      "Cannot serialize code with `" + t + "` for `options.fence`, expected `` ` `` or `~`"
    );
  return t;
}
function NQ(e, t, n, r) {
  const o = OQ(n), a = e.value || "", l = o === "`" ? "GraveAccent" : "Tilde";
  if (CQ(e, n)) {
    const m = n.enter("codeIndented"), g = n.indentLines(a, MQ);
    return m(), g;
  }
  const u = n.createTracker(r), d = o.repeat(Math.max(EQ(a, o) + 1, 3)), f = n.enter("codeFenced");
  let p = u.move(d);
  if (e.lang) {
    const m = n.enter(`codeFencedLang${l}`);
    p += u.move(
      n.safe(e.lang, {
        before: p,
        after: " ",
        encode: ["`"],
        ...u.current()
      })
    ), m();
  }
  if (e.lang && e.meta) {
    const m = n.enter(`codeFencedMeta${l}`);
    p += u.move(" "), p += u.move(
      n.safe(e.meta, {
        before: p,
        after: `
`,
        encode: ["`"],
        ...u.current()
      })
    ), m();
  }
  return p += u.move(`
`), a && (p += u.move(a + `
`)), p += u.move(d), f(), p;
}
function MQ(e, t, n) {
  return (n ? "" : "    ") + e;
}
function Cx(e) {
  const t = e.options.quote || '"';
  if (t !== '"' && t !== "'")
    throw new Error(
      "Cannot serialize title with `" + t + "` for `options.quote`, expected `\"`, or `'`"
    );
  return t;
}
function AQ(e, t, n, r) {
  const o = Cx(n), a = o === '"' ? "Quote" : "Apostrophe", l = n.enter("definition");
  let u = n.enter("label");
  const d = n.createTracker(r);
  let f = d.move("[");
  return f += d.move(
    n.safe(n.associationId(e), {
      before: f,
      after: "]",
      ...d.current()
    })
  ), f += d.move("]: "), u(), // If theres no url, or
  !e.url || // If there are control characters or whitespace.
  /[\0- \u007F]/.test(e.url) ? (u = n.enter("destinationLiteral"), f += d.move("<"), f += d.move(
    n.safe(e.url, { before: f, after: ">", ...d.current() })
  ), f += d.move(">")) : (u = n.enter("destinationRaw"), f += d.move(
    n.safe(e.url, {
      before: f,
      after: e.title ? " " : `
`,
      ...d.current()
    })
  )), u(), e.title && (u = n.enter(`title${a}`), f += d.move(" " + o), f += d.move(
    n.safe(e.title, {
      before: f,
      after: o,
      ...d.current()
    })
  ), f += d.move(o), u()), l(), f;
}
function RQ(e) {
  const t = e.options.emphasis || "*";
  if (t !== "*" && t !== "_")
    throw new Error(
      "Cannot serialize emphasis with `" + t + "` for `options.emphasis`, expected `*`, or `_`"
    );
  return t;
}
function Sc(e) {
  return "&#x" + e.toString(16).toUpperCase() + ";";
}
function Up(e, t, n) {
  const r = ds(e), o = ds(t);
  return r === void 0 ? o === void 0 ? (
    // Letter inside:
    // we have to encode *both* letters for `_` as it is looser.
    // it already forms for `*` (and GFMs `~`).
    n === "_" ? { inside: !0, outside: !0 } : { inside: !1, outside: !1 }
  ) : o === 1 ? (
    // Whitespace inside: encode both (letter, whitespace).
    { inside: !0, outside: !0 }
  ) : (
    // Punctuation inside: encode outer (letter)
    { inside: !1, outside: !0 }
  ) : r === 1 ? o === void 0 ? (
    // Letter inside: already forms.
    { inside: !1, outside: !1 }
  ) : o === 1 ? (
    // Whitespace inside: encode both (whitespace).
    { inside: !0, outside: !0 }
  ) : (
    // Punctuation inside: already forms.
    { inside: !1, outside: !1 }
  ) : o === void 0 ? (
    // Letter inside: already forms.
    { inside: !1, outside: !1 }
  ) : o === 1 ? (
    // Whitespace inside: encode inner (whitespace).
    { inside: !0, outside: !1 }
  ) : (
    // Punctuation inside: already forms.
    { inside: !1, outside: !1 }
  );
}
gR.peek = jQ;
function gR(e, t, n, r) {
  const o = RQ(n), a = n.enter("emphasis"), l = n.createTracker(r), u = l.move(o);
  let d = l.move(
    n.containerPhrasing(e, {
      after: o,
      before: u,
      ...l.current()
    })
  );
  const f = d.charCodeAt(0), p = Up(
    r.before.charCodeAt(r.before.length - 1),
    f,
    o
  );
  p.inside && (d = Sc(f) + d.slice(1));
  const m = d.charCodeAt(d.length - 1), g = Up(r.after.charCodeAt(0), m, o);
  g.inside && (d = d.slice(0, -1) + Sc(m));
  const y = l.move(o);
  return a(), n.attentionEncodeSurroundingInfo = {
    after: g.outside,
    before: p.outside
  }, u + d + y;
}
function jQ(e, t, n) {
  return n.options.emphasis || "*";
}
function DQ(e, t) {
  let n = !1;
  return _x(e, function(r) {
    if ("value" in r && /\r?\n|\r/.test(r.value) || r.type === "break")
      return n = !0, Pb;
  }), !!((!e.depth || e.depth < 3) && yx(e) && (t.options.setext || n));
}
function TQ(e, t, n, r) {
  const o = Math.max(Math.min(6, e.depth || 1), 1), a = n.createTracker(r);
  if (DQ(e, n)) {
    const p = n.enter("headingSetext"), m = n.enter("phrasing"), g = n.containerPhrasing(e, {
      ...a.current(),
      before: `
`,
      after: `
`
    });
    return m(), p(), g + `
` + (o === 1 ? "=" : "-").repeat(
      // The whole size
      g.length - // Minus the position of the character after the last EOL (or
      // 0 if there is none)
      (Math.max(g.lastIndexOf("\r"), g.lastIndexOf(`
`)) + 1)
    );
  }
  const l = "#".repeat(o), u = n.enter("headingAtx"), d = n.enter("phrasing");
  a.move(l + " ");
  let f = n.containerPhrasing(e, {
    before: "# ",
    after: `
`,
    ...a.current()
  });
  return /^[\t ]/.test(f) && (f = Sc(f.charCodeAt(0)) + f.slice(1)), f = f ? l + " " + f : l, n.options.closeAtx && (f += " " + l), d(), u(), f;
}
yR.peek = zQ;
function yR(e) {
  return e.value || "";
}
function zQ() {
  return "<";
}
vR.peek = PQ;
function vR(e, t, n, r) {
  const o = Cx(n), a = o === '"' ? "Quote" : "Apostrophe", l = n.enter("image");
  let u = n.enter("label");
  const d = n.createTracker(r);
  let f = d.move("![");
  return f += d.move(
    n.safe(e.alt, { before: f, after: "]", ...d.current() })
  ), f += d.move("]("), u(), // If theres no url but there is a title
  !e.url && e.title || // If there are control characters or whitespace.
  /[\0- \u007F]/.test(e.url) ? (u = n.enter("destinationLiteral"), f += d.move("<"), f += d.move(
    n.safe(e.url, { before: f, after: ">", ...d.current() })
  ), f += d.move(">")) : (u = n.enter("destinationRaw"), f += d.move(
    n.safe(e.url, {
      before: f,
      after: e.title ? " " : ")",
      ...d.current()
    })
  )), u(), e.title && (u = n.enter(`title${a}`), f += d.move(" " + o), f += d.move(
    n.safe(e.title, {
      before: f,
      after: o,
      ...d.current()
    })
  ), f += d.move(o), u()), f += d.move(")"), l(), f;
}
function PQ() {
  return "!";
}
bR.peek = LQ;
function bR(e, t, n, r) {
  const o = e.referenceType, a = n.enter("imageReference");
  let l = n.enter("label");
  const u = n.createTracker(r);
  let d = u.move("![");
  const f = n.safe(e.alt, {
    before: d,
    after: "]",
    ...u.current()
  });
  d += u.move(f + "]["), l();
  const p = n.stack;
  n.stack = [], l = n.enter("reference");
  const m = n.safe(n.associationId(e), {
    before: d,
    after: "]",
    ...u.current()
  });
  return l(), n.stack = p, a(), o === "full" || !f || f !== m ? d += u.move(m + "]") : o === "shortcut" ? d = d.slice(0, -1) : d += u.move("]"), d;
}
function LQ() {
  return "!";
}
wR.peek = IQ;
function wR(e, t, n) {
  let r = e.value || "", o = "`", a = -1;
  for (; new RegExp("(^|[^`])" + o + "([^`]|$)").test(r); )
    o += "`";
  for (/[^ \r\n]/.test(r) && (/^[ \r\n]/.test(r) && /[ \r\n]$/.test(r) || /^`|`$/.test(r)) && (r = " " + r + " "); ++a < n.unsafe.length; ) {
    const l = n.unsafe[a], u = n.compilePattern(l);
    let d;
    if (l.atBreak)
      for (; d = u.exec(r); ) {
        let f = d.index;
        r.charCodeAt(f) === 10 && r.charCodeAt(f - 1) === 13 && f--, r = r.slice(0, f) + " " + r.slice(d.index + 1);
      }
  }
  return o + r + o;
}
function IQ() {
  return "`";
}
function xR(e, t) {
  const n = yx(e);
  return !!(!t.options.resourceLink && // If theres a url
  e.url && // And theres a no title
  !e.title && // And the content of `node` is a single text node
  e.children && e.children.length === 1 && e.children[0].type === "text" && // And if the url is the same as the content
  (n === e.url || "mailto:" + n === e.url) && // And that starts w/ a protocol
  /^[a-z][a-z+.-]+:/i.test(e.url) && // And that doesnt contain ASCII control codes (character escapes and
  // references dont work), space, or angle brackets
  !/[\0- <>\u007F]/.test(e.url));
}
SR.peek = BQ;
function SR(e, t, n, r) {
  const o = Cx(n), a = o === '"' ? "Quote" : "Apostrophe", l = n.createTracker(r);
  let u, d;
  if (xR(e, n)) {
    const p = n.stack;
    n.stack = [], u = n.enter("autolink");
    let m = l.move("<");
    return m += l.move(
      n.containerPhrasing(e, {
        before: m,
        after: ">",
        ...l.current()
      })
    ), m += l.move(">"), u(), n.stack = p, m;
  }
  u = n.enter("link"), d = n.enter("label");
  let f = l.move("[");
  return f += l.move(
    n.containerPhrasing(e, {
      before: f,
      after: "](",
      ...l.current()
    })
  ), f += l.move("]("), d(), // If theres no url but there is a title
  !e.url && e.title || // If there are control characters or whitespace.
  /[\0- \u007F]/.test(e.url) ? (d = n.enter("destinationLiteral"), f += l.move("<"), f += l.move(
    n.safe(e.url, { before: f, after: ">", ...l.current() })
  ), f += l.move(">")) : (d = n.enter("destinationRaw"), f += l.move(
    n.safe(e.url, {
      before: f,
      after: e.title ? " " : ")",
      ...l.current()
    })
  )), d(), e.title && (d = n.enter(`title${a}`), f += l.move(" " + o), f += l.move(
    n.safe(e.title, {
      before: f,
      after: o,
      ...l.current()
    })
  ), f += l.move(o), d()), f += l.move(")"), u(), f;
}
function BQ(e, t, n) {
  return xR(e, n) ? "<" : "[";
}
kR.peek = VQ;
function kR(e, t, n, r) {
  const o = e.referenceType, a = n.enter("linkReference");
  let l = n.enter("label");
  const u = n.createTracker(r);
  let d = u.move("[");
  const f = n.containerPhrasing(e, {
    before: d,
    after: "]",
    ...u.current()
  });
  d += u.move(f + "]["), l();
  const p = n.stack;
  n.stack = [], l = n.enter("reference");
  const m = n.safe(n.associationId(e), {
    before: d,
    after: "]",
    ...u.current()
  });
  return l(), n.stack = p, a(), o === "full" || !f || f !== m ? d += u.move(m + "]") : o === "shortcut" ? d = d.slice(0, -1) : d += u.move("]"), d;
}
function VQ() {
  return "[";
}
function Ox(e) {
  const t = e.options.bullet || "*";
  if (t !== "*" && t !== "+" && t !== "-")
    throw new Error(
      "Cannot serialize items with `" + t + "` for `options.bullet`, expected `*`, `+`, or `-`"
    );
  return t;
}
function HQ(e) {
  const t = Ox(e), n = e.options.bulletOther;
  if (!n)
    return t === "*" ? "-" : "*";
  if (n !== "*" && n !== "+" && n !== "-")
    throw new Error(
      "Cannot serialize items with `" + n + "` for `options.bulletOther`, expected `*`, `+`, or `-`"
    );
  if (n === t)
    throw new Error(
      "Expected `bullet` (`" + t + "`) and `bulletOther` (`" + n + "`) to be different"
    );
  return n;
}
function UQ(e) {
  const t = e.options.bulletOrdered || ".";
  if (t !== "." && t !== ")")
    throw new Error(
      "Cannot serialize items with `" + t + "` for `options.bulletOrdered`, expected `.` or `)`"
    );
  return t;
}
function _R(e) {
  const t = e.options.rule || "*";
  if (t !== "*" && t !== "-" && t !== "_")
    throw new Error(
      "Cannot serialize rules with `" + t + "` for `options.rule`, expected `*`, `-`, or `_`"
    );
  return t;
}
function FQ(e, t, n, r) {
  const o = n.enter("list"), a = n.bulletCurrent;
  let l = e.ordered ? UQ(n) : Ox(n);
  const u = e.ordered ? l === "." ? ")" : "." : HQ(n);
  let d = t && n.bulletLastUsed ? l === n.bulletLastUsed : !1;
  if (!e.ordered) {
    const p = e.children ? e.children[0] : void 0;
    if (
      // Bullet could be used as a thematic break marker:
      (l === "*" || l === "-") && // Empty first list item:
      p && (!p.children || !p.children[0]) && // Directly in two other list items:
      n.stack[n.stack.length - 1] === "list" && n.stack[n.stack.length - 2] === "listItem" && n.stack[n.stack.length - 3] === "list" && n.stack[n.stack.length - 4] === "listItem" && // That are each the first child.
      n.indexStack[n.indexStack.length - 1] === 0 && n.indexStack[n.indexStack.length - 2] === 0 && n.indexStack[n.indexStack.length - 3] === 0 && (d = !0), _R(n) === l && p
    ) {
      let m = -1;
      for (; ++m < e.children.length; ) {
        const g = e.children[m];
        if (g && g.type === "listItem" && g.children && g.children[0] && g.children[0].type === "thematicBreak") {
          d = !0;
          break;
        }
      }
    }
  }
  d && (l = u), n.bulletCurrent = l;
  const f = n.containerFlow(e, r);
  return n.bulletLastUsed = l, n.bulletCurrent = a, o(), f;
}
function $Q(e) {
  const t = e.options.listItemIndent || "one";
  if (t !== "tab" && t !== "one" && t !== "mixed")
    throw new Error(
      "Cannot serialize items with `" + t + "` for `options.listItemIndent`, expected `tab`, `one`, or `mixed`"
    );
  return t;
}
function YQ(e, t, n, r) {
  const o = $Q(n);
  let a = n.bulletCurrent || Ox(n);
  t && t.type === "list" && t.ordered && (a = (typeof t.start == "number" && t.start > -1 ? t.start : 1) + (n.options.incrementListMarker === !1 ? 0 : t.children.indexOf(e)) + a);
  let l = a.length + 1;
  (o === "tab" || o === "mixed" && (t && t.type === "list" && t.spread || e.spread)) && (l = Math.ceil(l / 4) * 4);
  const u = n.createTracker(r);
  u.move(a + " ".repeat(l - a.length)), u.shift(l);
  const d = n.enter("listItem"), f = n.indentLines(
    n.containerFlow(e, u.current()),
    p
  );
  return d(), f;
  function p(m, g, y) {
    return g ? (y ? "" : " ".repeat(l)) + m : (y ? a : a + " ".repeat(l - a.length)) + m;
  }
}
function qQ(e, t, n, r) {
  const o = n.enter("paragraph"), a = n.enter("phrasing"), l = n.containerPhrasing(e, r);
  return a(), o(), l;
}
const XQ = (
  /** @type {(node?: unknown) => node is Exclude<PhrasingContent, Html>} */
  Vh([
    "break",
    "delete",
    "emphasis",
    // To do: next major: removed since footnotes were added to GFM.
    "footnote",
    "footnoteReference",
    "image",
    "imageReference",
    "inlineCode",
    // Enabled by `mdast-util-math`:
    "inlineMath",
    "link",
    "linkReference",
    // Enabled by `mdast-util-mdx`:
    "mdxJsxTextElement",
    // Enabled by `mdast-util-mdx`:
    "mdxTextExpression",
    "strong",
    "text",
    // Enabled by `mdast-util-directive`:
    "textDirective"
  ])
);
function GQ(e, t, n, r) {
  return (e.children.some(function(o) {
    return XQ(o);
  }) ? n.containerPhrasing : n.containerFlow).call(n, e, r);
}
function ZQ(e) {
  const t = e.options.strong || "*";
  if (t !== "*" && t !== "_")
    throw new Error(
      "Cannot serialize strong with `" + t + "` for `options.strong`, expected `*`, or `_`"
    );
  return t;
}
ER.peek = WQ;
function ER(e, t, n, r) {
  const o = ZQ(n), a = n.enter("strong"), l = n.createTracker(r), u = l.move(o + o);
  let d = l.move(
    n.containerPhrasing(e, {
      after: o,
      before: u,
      ...l.current()
    })
  );
  const f = d.charCodeAt(0), p = Up(
    r.before.charCodeAt(r.before.length - 1),
    f,
    o
  );
  p.inside && (d = Sc(f) + d.slice(1));
  const m = d.charCodeAt(d.length - 1), g = Up(r.after.charCodeAt(0), m, o);
  g.inside && (d = d.slice(0, -1) + Sc(m));
  const y = l.move(o + o);
  return a(), n.attentionEncodeSurroundingInfo = {
    after: g.outside,
    before: p.outside
  }, u + d + y;
}
function WQ(e, t, n) {
  return n.options.strong || "*";
}
function KQ(e, t, n, r) {
  return n.safe(e.value, r);
}
function QQ(e) {
  const t = e.options.ruleRepetition || 3;
  if (t < 3)
    throw new Error(
      "Cannot serialize rules with repetition `" + t + "` for `options.ruleRepetition`, expected `3` or more"
    );
  return t;
}
function JQ(e, t, n) {
  const r = (_R(n) + (n.options.ruleSpaces ? " " : "")).repeat(QQ(n));
  return n.options.ruleSpaces ? r.slice(0, -1) : r;
}
const CR = {
  blockquote: SQ,
  break: d5,
  code: NQ,
  definition: AQ,
  emphasis: gR,
  hardBreak: d5,
  heading: TQ,
  html: yR,
  image: vR,
  imageReference: bR,
  inlineCode: wR,
  link: SR,
  linkReference: kR,
  list: FQ,
  listItem: YQ,
  paragraph: qQ,
  root: GQ,
  strong: ER,
  text: KQ,
  thematicBreak: JQ
};
function eJ() {
  return {
    enter: {
      table: tJ,
      tableData: f5,
      tableHeader: f5,
      tableRow: rJ
    },
    exit: {
      codeText: oJ,
      table: nJ,
      tableData: Sv,
      tableHeader: Sv,
      tableRow: Sv
    }
  };
}
function tJ(e) {
  const t = e._align;
  this.enter(
    {
      type: "table",
      align: t.map(function(n) {
        return n === "none" ? null : n;
      }),
      children: []
    },
    e
  ), this.data.inTable = !0;
}
function nJ(e) {
  this.exit(e), this.data.inTable = void 0;
}
function rJ(e) {
  this.enter({ type: "tableRow", children: [] }, e);
}
function Sv(e) {
  this.exit(e);
}
function f5(e) {
  this.enter({ type: "tableCell", children: [] }, e);
}
function oJ(e) {
  let t = this.resume();
  this.data.inTable && (t = t.replace(/\\([\\|])/g, iJ));
  const n = this.stack[this.stack.length - 1];
  n.type, n.value = t, this.exit(e);
}
function iJ(e, t) {
  return t === "|" ? t : e;
}
function aJ(e) {
  const t = e || {}, n = t.tableCellPadding, r = t.tablePipeAlign, o = t.stringLength, a = n ? " " : "|";
  return {
    unsafe: [
      { character: "\r", inConstruct: "tableCell" },
      { character: `
`, inConstruct: "tableCell" },
      // A pipe, when followed by a tab or space (padding), or a dash or colon
      // (unpadded delimiter row), could result in a table.
      { atBreak: !0, character: "|", after: "[	 :-]" },
      // A pipe in a cell must be encoded.
      { character: "|", inConstruct: "tableCell" },
      // A colon must be followed by a dash, in which case it could start a
      // delimiter row.
      { atBreak: !0, character: ":", after: "-" },
      // A delimiter row can also start with a dash, when followed by more
      // dashes, a colon, or a pipe.
      // This is a stricter version than the built in check for lists, thematic
      // breaks, and setex heading underlines though:
      // <https://github.com/syntax-tree/mdast-util-to-markdown/blob/51a2038/lib/unsafe.js#L57>
      { atBreak: !0, character: "-", after: "[:|-]" }
    ],
    handlers: {
      inlineCode: g,
      table: l,
      tableCell: d,
      tableRow: u
    }
  };
  function l(y, w, v, x) {
    return f(p(y, v, x), y.align);
  }
  function u(y, w, v, x) {
    const E = m(y, v, x), N = f([E]);
    return N.slice(0, N.indexOf(`
`));
  }
  function d(y, w, v, x) {
    const E = v.enter("tableCell"), N = v.enter("phrasing"), C = v.containerPhrasing(y, {
      ...x,
      before: a,
      after: a
    });
    return N(), E(), C;
  }
  function f(y, w) {
    return wQ(y, {
      align: w,
      // @ts-expect-error: `markdown-table` types should support `null`.
      alignDelimiters: r,
      // @ts-expect-error: `markdown-table` types should support `null`.
      padding: n,
      // @ts-expect-error: `markdown-table` types should support `null`.
      stringLength: o
    });
  }
  function p(y, w, v) {
    const x = y.children;
    let E = -1;
    const N = [], C = w.enter("table");
    for (; ++E < x.length; )
      N[E] = m(x[E], w, v);
    return C(), N;
  }
  function m(y, w, v) {
    const x = y.children;
    let E = -1;
    const N = [], C = w.enter("tableRow");
    for (; ++E < x.length; )
      N[E] = d(x[E], y, w, v);
    return C(), N;
  }
  function g(y, w, v) {
    let x = CR.inlineCode(y, w, v);
    return v.stack.includes("tableCell") && (x = x.replace(/\|/g, "\\$&")), x;
  }
}
function lJ() {
  return {
    exit: {
      taskListCheckValueChecked: p5,
      taskListCheckValueUnchecked: p5,
      paragraph: uJ
    }
  };
}
function sJ() {
  return {
    unsafe: [{ atBreak: !0, character: "-", after: "[:|-]" }],
    handlers: { listItem: cJ }
  };
}
function p5(e) {
  const t = this.stack[this.stack.length - 2];
  t.type, t.checked = e.type === "taskListCheckValueChecked";
}
function uJ(e) {
  const t = this.stack[this.stack.length - 2];
  if (t && t.type === "listItem" && typeof t.checked == "boolean") {
    const n = this.stack[this.stack.length - 1];
    n.type;
    const r = n.children[0];
    if (r && r.type === "text") {
      const o = t.children;
      let a = -1, l;
      for (; ++a < o.length; ) {
        const u = o[a];
        if (u.type === "paragraph") {
          l = u;
          break;
        }
      }
      l === n && (r.value = r.value.slice(1), r.value.length === 0 ? n.children.shift() : n.position && r.position && typeof r.position.start.offset == "number" && (r.position.start.column++, r.position.start.offset++, n.position.start = Object.assign({}, r.position.start)));
    }
  }
  this.exit(e);
}
function cJ(e, t, n, r) {
  const o = e.children[0], a = typeof e.checked == "boolean" && o && o.type === "paragraph", l = "[" + (e.checked ? "x" : " ") + "] ", u = n.createTracker(r);
  a && u.move(l);
  let d = CR.listItem(e, t, n, {
    ...r,
    ...u.current()
  });
  return a && (d = d.replace(/^(?:[*+-]|\d+\.)([\r\n]| {1,3})/, f)), d;
  function f(p) {
    return p + l;
  }
}
function dJ() {
  return [
    FK(),
    cQ(),
    hQ(),
    eJ(),
    lJ()
  ];
}
function fJ(e) {
  return {
    extensions: [
      $K(),
      dQ(e),
      mQ(),
      aJ(e),
      sJ()
    ]
  };
}
const pJ = {
  tokenize: bJ,
  partial: !0
}, OR = {
  tokenize: wJ,
  partial: !0
}, NR = {
  tokenize: xJ,
  partial: !0
}, MR = {
  tokenize: SJ,
  partial: !0
}, hJ = {
  tokenize: kJ,
  partial: !0
}, AR = {
  name: "wwwAutolink",
  tokenize: yJ,
  previous: jR
}, RR = {
  name: "protocolAutolink",
  tokenize: vJ,
  previous: DR
}, Qo = {
  name: "emailAutolink",
  tokenize: gJ,
  previous: TR
}, uo = {};
function mJ() {
  return {
    text: uo
  };
}
let ya = 48;
for (; ya < 123; )
  uo[ya] = Qo, ya++, ya === 58 ? ya = 65 : ya === 91 && (ya = 97);
uo[43] = Qo;
uo[45] = Qo;
uo[46] = Qo;
uo[95] = Qo;
uo[72] = [Qo, RR];
uo[104] = [Qo, RR];
uo[87] = [Qo, AR];
uo[119] = [Qo, AR];
function gJ(e, t, n) {
  const r = this;
  let o, a;
  return l;
  function l(m) {
    return !Vb(m) || !TR.call(r, r.previous) || Nx(r.events) ? n(m) : (e.enter("literalAutolink"), e.enter("literalAutolinkEmail"), u(m));
  }
  function u(m) {
    return Vb(m) ? (e.consume(m), u) : m === 64 ? (e.consume(m), d) : n(m);
  }
  function d(m) {
    return m === 46 ? e.check(hJ, p, f)(m) : m === 45 || m === 95 || mn(m) ? (a = !0, e.consume(m), d) : p(m);
  }
  function f(m) {
    return e.consume(m), o = !0, d;
  }
  function p(m) {
    return a && o && xn(r.previous) ? (e.exit("literalAutolinkEmail"), e.exit("literalAutolink"), t(m)) : n(m);
  }
}
function yJ(e, t, n) {
  const r = this;
  return o;
  function o(l) {
    return l !== 87 && l !== 119 || !jR.call(r, r.previous) || Nx(r.events) ? n(l) : (e.enter("literalAutolink"), e.enter("literalAutolinkWww"), e.check(pJ, e.attempt(OR, e.attempt(NR, a), n), n)(l));
  }
  function a(l) {
    return e.exit("literalAutolinkWww"), e.exit("literalAutolink"), t(l);
  }
}
function vJ(e, t, n) {
  const r = this;
  let o = "", a = !1;
  return l;
  function l(m) {
    return (m === 72 || m === 104) && DR.call(r, r.previous) && !Nx(r.events) ? (e.enter("literalAutolink"), e.enter("literalAutolinkHttp"), o += String.fromCodePoint(m), e.consume(m), u) : n(m);
  }
  function u(m) {
    if (xn(m) && o.length < 5)
      return o += String.fromCodePoint(m), e.consume(m), u;
    if (m === 58) {
      const g = o.toLowerCase();
      if (g === "http" || g === "https")
        return e.consume(m), d;
    }
    return n(m);
  }
  function d(m) {
    return m === 47 ? (e.consume(m), a ? f : (a = !0, d)) : n(m);
  }
  function f(m) {
    return m === null || Bp(m) || mt(m) || La(m) || Lh(m) ? n(m) : e.attempt(OR, e.attempt(NR, p), n)(m);
  }
  function p(m) {
    return e.exit("literalAutolinkHttp"), e.exit("literalAutolink"), t(m);
  }
}
function bJ(e, t, n) {
  let r = 0;
  return o;
  function o(l) {
    return (l === 87 || l === 119) && r < 3 ? (r++, e.consume(l), o) : l === 46 && r === 3 ? (e.consume(l), a) : n(l);
  }
  function a(l) {
    return l === null ? n(l) : t(l);
  }
}
function wJ(e, t, n) {
  let r, o, a;
  return l;
  function l(f) {
    return f === 46 || f === 95 ? e.check(MR, d, u)(f) : f === null || mt(f) || La(f) || f !== 45 && Lh(f) ? d(f) : (a = !0, e.consume(f), l);
  }
  function u(f) {
    return f === 95 ? r = !0 : (o = r, r = void 0), e.consume(f), l;
  }
  function d(f) {
    return o || r || !a ? n(f) : t(f);
  }
}
function xJ(e, t) {
  let n = 0, r = 0;
  return o;
  function o(l) {
    return l === 40 ? (n++, e.consume(l), o) : l === 41 && r < n ? a(l) : l === 33 || l === 34 || l === 38 || l === 39 || l === 41 || l === 42 || l === 44 || l === 46 || l === 58 || l === 59 || l === 60 || l === 63 || l === 93 || l === 95 || l === 126 ? e.check(MR, t, a)(l) : l === null || mt(l) || La(l) ? t(l) : (e.consume(l), o);
  }
  function a(l) {
    return l === 41 && r++, e.consume(l), o;
  }
}
function SJ(e, t, n) {
  return r;
  function r(u) {
    return u === 33 || u === 34 || u === 39 || u === 41 || u === 42 || u === 44 || u === 46 || u === 58 || u === 59 || u === 63 || u === 95 || u === 126 ? (e.consume(u), r) : u === 38 ? (e.consume(u), a) : u === 93 ? (e.consume(u), o) : (
      // `<` is an end.
      u === 60 || // So is whitespace.
      u === null || mt(u) || La(u) ? t(u) : n(u)
    );
  }
  function o(u) {
    return u === null || u === 40 || u === 91 || mt(u) || La(u) ? t(u) : r(u);
  }
  function a(u) {
    return xn(u) ? l(u) : n(u);
  }
  function l(u) {
    return u === 59 ? (e.consume(u), r) : xn(u) ? (e.consume(u), l) : n(u);
  }
}
function kJ(e, t, n) {
  return r;
  function r(a) {
    return e.consume(a), o;
  }
  function o(a) {
    return mn(a) ? n(a) : t(a);
  }
}
function jR(e) {
  return e === null || e === 40 || e === 42 || e === 95 || e === 91 || e === 93 || e === 126 || mt(e);
}
function DR(e) {
  return !xn(e);
}
function TR(e) {
  return !(e === 47 || Vb(e));
}
function Vb(e) {
  return e === 43 || e === 45 || e === 46 || e === 95 || mn(e);
}
function Nx(e) {
  let t = e.length, n = !1;
  for (; t--; ) {
    const r = e[t][1];
    if ((r.type === "labelLink" || r.type === "labelImage") && !r._balanced) {
      n = !0;
      break;
    }
    if (r._gfmAutolinkLiteralWalkedInto) {
      n = !1;
      break;
    }
  }
  return e.length > 0 && !n && (e[e.length - 1][1]._gfmAutolinkLiteralWalkedInto = !0), n;
}
const _J = {
  tokenize: jJ,
  partial: !0
};
function EJ() {
  return {
    document: {
      91: {
        name: "gfmFootnoteDefinition",
        tokenize: MJ,
        continuation: {
          tokenize: AJ
        },
        exit: RJ
      }
    },
    text: {
      91: {
        name: "gfmFootnoteCall",
        tokenize: NJ
      },
      93: {
        name: "gfmPotentialFootnoteCall",
        add: "after",
        tokenize: CJ,
        resolveTo: OJ
      }
    }
  };
}
function CJ(e, t, n) {
  const r = this;
  let o = r.events.length;
  const a = r.parser.gfmFootnotes || (r.parser.gfmFootnotes = []);
  let l;
  for (; o--; ) {
    const d = r.events[o][1];
    if (d.type === "labelImage") {
      l = d;
      break;
    }
    if (d.type === "gfmFootnoteCall" || d.type === "labelLink" || d.type === "label" || d.type === "image" || d.type === "link")
      break;
  }
  return u;
  function u(d) {
    if (!l || !l._balanced)
      return n(d);
    const f = Rr(r.sliceSerialize({
      start: l.end,
      end: r.now()
    }));
    return f.codePointAt(0) !== 94 || !a.includes(f.slice(1)) ? n(d) : (e.enter("gfmFootnoteCallLabelMarker"), e.consume(d), e.exit("gfmFootnoteCallLabelMarker"), t(d));
  }
}
function OJ(e, t) {
  let n = e.length;
  for (; n--; )
    if (e[n][1].type === "labelImage" && e[n][0] === "enter") {
      e[n][1];
      break;
    }
  e[n + 1][1].type = "data", e[n + 3][1].type = "gfmFootnoteCallLabelMarker";
  const r = {
    type: "gfmFootnoteCall",
    start: Object.assign({}, e[n + 3][1].start),
    end: Object.assign({}, e[e.length - 1][1].end)
  }, o = {
    type: "gfmFootnoteCallMarker",
    start: Object.assign({}, e[n + 3][1].end),
    end: Object.assign({}, e[n + 3][1].end)
  };
  o.end.column++, o.end.offset++, o.end._bufferIndex++;
  const a = {
    type: "gfmFootnoteCallString",
    start: Object.assign({}, o.end),
    end: Object.assign({}, e[e.length - 1][1].start)
  }, l = {
    type: "chunkString",
    contentType: "string",
    start: Object.assign({}, a.start),
    end: Object.assign({}, a.end)
  }, u = [
    // Take the `labelImageMarker` (now `data`, the `!`)
    e[n + 1],
    e[n + 2],
    ["enter", r, t],
    // The `[`
    e[n + 3],
    e[n + 4],
    // The `^`.
    ["enter", o, t],
    ["exit", o, t],
    // Everything in between.
    ["enter", a, t],
    ["enter", l, t],
    ["exit", l, t],
    ["exit", a, t],
    // The ending (`]`, properly parsed and labelled).
    e[e.length - 2],
    e[e.length - 1],
    ["exit", r, t]
  ];
  return e.splice(n, e.length - n + 1, ...u), e;
}
function NJ(e, t, n) {
  const r = this, o = r.parser.gfmFootnotes || (r.parser.gfmFootnotes = []);
  let a = 0, l;
  return u;
  function u(m) {
    return e.enter("gfmFootnoteCall"), e.enter("gfmFootnoteCallLabelMarker"), e.consume(m), e.exit("gfmFootnoteCallLabelMarker"), d;
  }
  function d(m) {
    return m !== 94 ? n(m) : (e.enter("gfmFootnoteCallMarker"), e.consume(m), e.exit("gfmFootnoteCallMarker"), e.enter("gfmFootnoteCallString"), e.enter("chunkString").contentType = "string", f);
  }
  function f(m) {
    if (
      // Too long.
      a > 999 || // Closing brace with nothing.
      m === 93 && !l || // Space or tab is not supported by GFM for some reason.
      // `\n` and `[` not being supported makes sense.
      m === null || m === 91 || mt(m)
    )
      return n(m);
    if (m === 93) {
      e.exit("chunkString");
      const g = e.exit("gfmFootnoteCallString");
      return o.includes(Rr(r.sliceSerialize(g))) ? (e.enter("gfmFootnoteCallLabelMarker"), e.consume(m), e.exit("gfmFootnoteCallLabelMarker"), e.exit("gfmFootnoteCall"), t) : n(m);
    }
    return mt(m) || (l = !0), a++, e.consume(m), m === 92 ? p : f;
  }
  function p(m) {
    return m === 91 || m === 92 || m === 93 ? (e.consume(m), a++, f) : f(m);
  }
}
function MJ(e, t, n) {
  const r = this, o = r.parser.gfmFootnotes || (r.parser.gfmFootnotes = []);
  let a, l = 0, u;
  return d;
  function d(w) {
    return e.enter("gfmFootnoteDefinition")._container = !0, e.enter("gfmFootnoteDefinitionLabel"), e.enter("gfmFootnoteDefinitionLabelMarker"), e.consume(w), e.exit("gfmFootnoteDefinitionLabelMarker"), f;
  }
  function f(w) {
    return w === 94 ? (e.enter("gfmFootnoteDefinitionMarker"), e.consume(w), e.exit("gfmFootnoteDefinitionMarker"), e.enter("gfmFootnoteDefinitionLabelString"), e.enter("chunkString").contentType = "string", p) : n(w);
  }
  function p(w) {
    if (
      // Too long.
      l > 999 || // Closing brace with nothing.
      w === 93 && !u || // Space or tab is not supported by GFM for some reason.
      // `\n` and `[` not being supported makes sense.
      w === null || w === 91 || mt(w)
    )
      return n(w);
    if (w === 93) {
      e.exit("chunkString");
      const v = e.exit("gfmFootnoteDefinitionLabelString");
      return a = Rr(r.sliceSerialize(v)), e.enter("gfmFootnoteDefinitionLabelMarker"), e.consume(w), e.exit("gfmFootnoteDefinitionLabelMarker"), e.exit("gfmFootnoteDefinitionLabel"), g;
    }
    return mt(w) || (u = !0), l++, e.consume(w), w === 92 ? m : p;
  }
  function m(w) {
    return w === 91 || w === 92 || w === 93 ? (e.consume(w), l++, p) : p(w);
  }
  function g(w) {
    return w === 58 ? (e.enter("definitionMarker"), e.consume(w), e.exit("definitionMarker"), o.includes(a) || o.push(a), Ke(e, y, "gfmFootnoteDefinitionWhitespace")) : n(w);
  }
  function y(w) {
    return t(w);
  }
}
function AJ(e, t, n) {
  return e.check(Xc, t, e.attempt(_J, t, n));
}
function RJ(e) {
  e.exit("gfmFootnoteDefinition");
}
function jJ(e, t, n) {
  const r = this;
  return Ke(e, o, "gfmFootnoteDefinitionIndent", 5);
  function o(a) {
    const l = r.events[r.events.length - 1];
    return l && l[1].type === "gfmFootnoteDefinitionIndent" && l[2].sliceSerialize(l[1], !0).length === 4 ? t(a) : n(a);
  }
}
function DJ(e) {
  let t = (e || {}).singleTilde;
  const n = {
    name: "strikethrough",
    tokenize: o,
    resolveAll: r
  };
  return t == null && (t = !0), {
    text: {
      126: n
    },
    insideSpan: {
      null: [n]
    },
    attentionMarkers: {
      null: [126]
    }
  };
  function r(a, l) {
    let u = -1;
    for (; ++u < a.length; )
      if (a[u][0] === "enter" && a[u][1].type === "strikethroughSequenceTemporary" && a[u][1]._close) {
        let d = u;
        for (; d--; )
          if (a[d][0] === "exit" && a[d][1].type === "strikethroughSequenceTemporary" && a[d][1]._open && // If the sizes are the same:
          a[u][1].end.offset - a[u][1].start.offset === a[d][1].end.offset - a[d][1].start.offset) {
            a[u][1].type = "strikethroughSequence", a[d][1].type = "strikethroughSequence";
            const f = {
              type: "strikethrough",
              start: Object.assign({}, a[d][1].start),
              end: Object.assign({}, a[u][1].end)
            }, p = {
              type: "strikethroughText",
              start: Object.assign({}, a[d][1].end),
              end: Object.assign({}, a[u][1].start)
            }, m = [["enter", f, l], ["enter", a[d][1], l], ["exit", a[d][1], l], ["enter", p, l]], g = l.parser.constructs.insideSpan.null;
            g && er(m, m.length, 0, Ih(g, a.slice(d + 1, u), l)), er(m, m.length, 0, [["exit", p, l], ["enter", a[u][1], l], ["exit", a[u][1], l], ["exit", f, l]]), er(a, d - 1, u - d + 3, m), u = d + m.length - 2;
            break;
          }
      }
    for (u = -1; ++u < a.length; )
      a[u][1].type === "strikethroughSequenceTemporary" && (a[u][1].type = "data");
    return a;
  }
  function o(a, l, u) {
    const d = this.previous, f = this.events;
    let p = 0;
    return m;
    function m(y) {
      return d === 126 && f[f.length - 1][1].type !== "characterEscape" ? u(y) : (a.enter("strikethroughSequenceTemporary"), g(y));
    }
    function g(y) {
      const w = ds(d);
      if (y === 126)
        return p > 1 ? u(y) : (a.consume(y), p++, g);
      if (p < 2 && !t) return u(y);
      const v = a.exit("strikethroughSequenceTemporary"), x = ds(y);
      return v._open = !x || x === 2 && !!w, v._close = !w || w === 2 && !!x, l(y);
    }
  }
}
class TJ {
  /**
   * Create a new edit map.
   */
  constructor() {
    this.map = [];
  }
  /**
   * Create an edit: a remove and/or add at a certain place.
   *
   * @param {number} index
   * @param {number} remove
   * @param {Array<Event>} add
   * @returns {undefined}
   */
  add(t, n, r) {
    zJ(this, t, n, r);
  }
  // To do: add this when moving to `micromark`.
  // /**
  //  * Create an edit: but insert `add` before existing additions.
  //  *
  //  * @param {number} index
  //  * @param {number} remove
  //  * @param {Array<Event>} add
  //  * @returns {undefined}
  //  */
  // addBefore(index, remove, add) {
  //   addImplementation(this, index, remove, add, true)
  // }
  /**
   * Done, change the events.
   *
   * @param {Array<Event>} events
   * @returns {undefined}
   */
  consume(t) {
    if (this.map.sort(function(a, l) {
      return a[0] - l[0];
    }), this.map.length === 0)
      return;
    let n = this.map.length;
    const r = [];
    for (; n > 0; )
      n -= 1, r.push(t.slice(this.map[n][0] + this.map[n][1]), this.map[n][2]), t.length = this.map[n][0];
    r.push(t.slice()), t.length = 0;
    let o = r.pop();
    for (; o; ) {
      for (const a of o)
        t.push(a);
      o = r.pop();
    }
    this.map.length = 0;
  }
}
function zJ(e, t, n, r) {
  let o = 0;
  if (!(n === 0 && r.length === 0)) {
    for (; o < e.map.length; ) {
      if (e.map[o][0] === t) {
        e.map[o][1] += n, e.map[o][2].push(...r);
        return;
      }
      o += 1;
    }
    e.map.push([t, n, r]);
  }
}
function PJ(e, t) {
  let n = !1;
  const r = [];
  for (; t < e.length; ) {
    const o = e[t];
    if (n) {
      if (o[0] === "enter")
        o[1].type === "tableContent" && r.push(e[t + 1][1].type === "tableDelimiterMarker" ? "left" : "none");
      else if (o[1].type === "tableContent") {
        if (e[t - 1][1].type === "tableDelimiterMarker") {
          const a = r.length - 1;
          r[a] = r[a] === "left" ? "center" : "right";
        }
      } else if (o[1].type === "tableDelimiterRow")
        break;
    } else o[0] === "enter" && o[1].type === "tableDelimiterRow" && (n = !0);
    t += 1;
  }
  return r;
}
function LJ() {
  return {
    flow: {
      null: {
        name: "table",
        tokenize: IJ,
        resolveAll: BJ
      }
    }
  };
}
function IJ(e, t, n) {
  const r = this;
  let o = 0, a = 0, l;
  return u;
  function u(O) {
    let B = r.events.length - 1;
    for (; B > -1; ) {
      const z = r.events[B][1].type;
      if (z === "lineEnding" || // Note: markdown-rs uses `whitespace` instead of `linePrefix`
      z === "linePrefix") B--;
      else break;
    }
    const U = B > -1 ? r.events[B][1].type : null, G = U === "tableHead" || U === "tableRow" ? D : d;
    return G === D && r.parser.lazy[r.now().line] ? n(O) : G(O);
  }
  function d(O) {
    return e.enter("tableHead"), e.enter("tableRow"), f(O);
  }
  function f(O) {
    return O === 124 || (l = !0, a += 1), p(O);
  }
  function p(O) {
    return O === null ? n(O) : Me(O) ? a > 1 ? (a = 0, r.interrupt = !0, e.exit("tableRow"), e.enter("lineEnding"), e.consume(O), e.exit("lineEnding"), y) : n(O) : Xe(O) ? Ke(e, p, "whitespace")(O) : (a += 1, l && (l = !1, o += 1), O === 124 ? (e.enter("tableCellDivider"), e.consume(O), e.exit("tableCellDivider"), l = !0, p) : (e.enter("data"), m(O)));
  }
  function m(O) {
    return O === null || O === 124 || mt(O) ? (e.exit("data"), p(O)) : (e.consume(O), O === 92 ? g : m);
  }
  function g(O) {
    return O === 92 || O === 124 ? (e.consume(O), m) : m(O);
  }
  function y(O) {
    return r.interrupt = !1, r.parser.lazy[r.now().line] ? n(O) : (e.enter("tableDelimiterRow"), l = !1, Xe(O) ? Ke(e, w, "linePrefix", r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(O) : w(O));
  }
  function w(O) {
    return O === 45 || O === 58 ? x(O) : O === 124 ? (l = !0, e.enter("tableCellDivider"), e.consume(O), e.exit("tableCellDivider"), v) : R(O);
  }
  function v(O) {
    return Xe(O) ? Ke(e, x, "whitespace")(O) : x(O);
  }
  function x(O) {
    return O === 58 ? (a += 1, l = !0, e.enter("tableDelimiterMarker"), e.consume(O), e.exit("tableDelimiterMarker"), E) : O === 45 ? (a += 1, E(O)) : O === null || Me(O) ? A(O) : R(O);
  }
  function E(O) {
    return O === 45 ? (e.enter("tableDelimiterFiller"), N(O)) : R(O);
  }
  function N(O) {
    return O === 45 ? (e.consume(O), N) : O === 58 ? (l = !0, e.exit("tableDelimiterFiller"), e.enter("tableDelimiterMarker"), e.consume(O), e.exit("tableDelimiterMarker"), C) : (e.exit("tableDelimiterFiller"), C(O));
  }
  function C(O) {
    return Xe(O) ? Ke(e, A, "whitespace")(O) : A(O);
  }
  function A(O) {
    return O === 124 ? w(O) : O === null || Me(O) ? !l || o !== a ? R(O) : (e.exit("tableDelimiterRow"), e.exit("tableHead"), t(O)) : R(O);
  }
  function R(O) {
    return n(O);
  }
  function D(O) {
    return e.enter("tableRow"), T(O);
  }
  function T(O) {
    return O === 124 ? (e.enter("tableCellDivider"), e.consume(O), e.exit("tableCellDivider"), T) : O === null || Me(O) ? (e.exit("tableRow"), t(O)) : Xe(O) ? Ke(e, T, "whitespace")(O) : (e.enter("data"), V(O));
  }
  function V(O) {
    return O === null || O === 124 || mt(O) ? (e.exit("data"), T(O)) : (e.consume(O), O === 92 ? F : V);
  }
  function F(O) {
    return O === 92 || O === 124 ? (e.consume(O), V) : V(O);
  }
}
function BJ(e, t) {
  let n = -1, r = !0, o = 0, a = [0, 0, 0, 0], l = [0, 0, 0, 0], u = !1, d = 0, f, p, m;
  const g = new TJ();
  for (; ++n < e.length; ) {
    const y = e[n], w = y[1];
    y[0] === "enter" ? w.type === "tableHead" ? (u = !1, d !== 0 && (h5(g, t, d, f, p), p = void 0, d = 0), f = {
      type: "table",
      start: Object.assign({}, w.start),
      // Note: correct end is set later.
      end: Object.assign({}, w.end)
    }, g.add(n, 0, [["enter", f, t]])) : w.type === "tableRow" || w.type === "tableDelimiterRow" ? (r = !0, m = void 0, a = [0, 0, 0, 0], l = [0, n + 1, 0, 0], u && (u = !1, p = {
      type: "tableBody",
      start: Object.assign({}, w.start),
      // Note: correct end is set later.
      end: Object.assign({}, w.end)
    }, g.add(n, 0, [["enter", p, t]])), o = w.type === "tableDelimiterRow" ? 2 : p ? 3 : 1) : o && (w.type === "data" || w.type === "tableDelimiterMarker" || w.type === "tableDelimiterFiller") ? (r = !1, l[2] === 0 && (a[1] !== 0 && (l[0] = l[1], m = Bf(g, t, a, o, void 0, m), a = [0, 0, 0, 0]), l[2] = n)) : w.type === "tableCellDivider" && (r ? r = !1 : (a[1] !== 0 && (l[0] = l[1], m = Bf(g, t, a, o, void 0, m)), a = l, l = [a[1], n, 0, 0])) : w.type === "tableHead" ? (u = !0, d = n) : w.type === "tableRow" || w.type === "tableDelimiterRow" ? (d = n, a[1] !== 0 ? (l[0] = l[1], m = Bf(g, t, a, o, n, m)) : l[1] !== 0 && (m = Bf(g, t, l, o, n, m)), o = 0) : o && (w.type === "data" || w.type === "tableDelimiterMarker" || w.type === "tableDelimiterFiller") && (l[3] = n);
  }
  for (d !== 0 && h5(g, t, d, f, p), g.consume(t.events), n = -1; ++n < t.events.length; ) {
    const y = t.events[n];
    y[0] === "enter" && y[1].type === "table" && (y[1]._align = PJ(t.events, n));
  }
  return e;
}
function Bf(e, t, n, r, o, a) {
  const l = r === 1 ? "tableHeader" : r === 2 ? "tableDelimiter" : "tableData", u = "tableContent";
  n[0] !== 0 && (a.end = Object.assign({}, Vl(t.events, n[0])), e.add(n[0], 0, [["exit", a, t]]));
  const d = Vl(t.events, n[1]);
  if (a = {
    type: l,
    start: Object.assign({}, d),
    // Note: correct end is set later.
    end: Object.assign({}, d)
  }, e.add(n[1], 0, [["enter", a, t]]), n[2] !== 0) {
    const f = Vl(t.events, n[2]), p = Vl(t.events, n[3]), m = {
      type: u,
      start: Object.assign({}, f),
      end: Object.assign({}, p)
    };
    if (e.add(n[2], 0, [["enter", m, t]]), r !== 2) {
      const g = t.events[n[2]], y = t.events[n[3]];
      if (g[1].end = Object.assign({}, y[1].end), g[1].type = "chunkText", g[1].contentType = "text", n[3] > n[2] + 1) {
        const w = n[2] + 1, v = n[3] - n[2] - 1;
        e.add(w, v, []);
      }
    }
    e.add(n[3] + 1, 0, [["exit", m, t]]);
  }
  return o !== void 0 && (a.end = Object.assign({}, Vl(t.events, o)), e.add(o, 0, [["exit", a, t]]), a = void 0), a;
}
function h5(e, t, n, r, o) {
  const a = [], l = Vl(t.events, n);
  o && (o.end = Object.assign({}, l), a.push(["exit", o, t])), r.end = Object.assign({}, l), a.push(["exit", r, t]), e.add(n + 1, 0, a);
}
function Vl(e, t) {
  const n = e[t], r = n[0] === "enter" ? "start" : "end";
  return n[1][r];
}
const VJ = {
  name: "tasklistCheck",
  tokenize: UJ
};
function HJ() {
  return {
    text: {
      91: VJ
    }
  };
}
function UJ(e, t, n) {
  const r = this;
  return o;
  function o(d) {
    return (
      // Exit if theres stuff before.
      r.previous !== null || // Exit if not in the first content that is the first child of a list
      // item.
      !r._gfmTasklistFirstContentOfListItem ? n(d) : (e.enter("taskListCheck"), e.enter("taskListCheckMarker"), e.consume(d), e.exit("taskListCheckMarker"), a)
    );
  }
  function a(d) {
    return mt(d) ? (e.enter("taskListCheckValueUnchecked"), e.consume(d), e.exit("taskListCheckValueUnchecked"), l) : d === 88 || d === 120 ? (e.enter("taskListCheckValueChecked"), e.consume(d), e.exit("taskListCheckValueChecked"), l) : n(d);
  }
  function l(d) {
    return d === 93 ? (e.enter("taskListCheckMarker"), e.consume(d), e.exit("taskListCheckMarker"), e.exit("taskListCheck"), u) : n(d);
  }
  function u(d) {
    return Me(d) ? t(d) : Xe(d) ? e.check({
      tokenize: FJ
    }, t, n)(d) : n(d);
  }
}
function FJ(e, t, n) {
  return Ke(e, r, "whitespace");
  function r(o) {
    return o === null ? n(o) : t(o);
  }
}
function $J(e) {
  return YA([
    mJ(),
    EJ(),
    DJ(e),
    LJ(),
    HJ()
  ]);
}
const YJ = {};
function qJ(e) {
  const t = (
    /** @type {Processor<Root>} */
    this
  ), n = e || YJ, r = t.data(), o = r.micromarkExtensions || (r.micromarkExtensions = []), a = r.fromMarkdownExtensions || (r.fromMarkdownExtensions = []), l = r.toMarkdownExtensions || (r.toMarkdownExtensions = []);
  o.push($J(n)), a.push(dJ()), l.push(fJ(n));
}
const zR = ({ item: e }) => {
  const t = _.useContext(Ge), n = () => {
    var o;
    (o = t.worker) == null || o.add_node(e.node_id);
  }, r = (o) => {
    o.detail === 2 && n();
  };
  return /* @__PURE__ */ k.jsx("div", { className: "libnodeentry", onClick: r, title: e.description, children: e.node_name || e.node_id });
}, PR = (e, t) => {
  var n, r;
  const o = ((n = e.nodes) == null ? void 0 : n.some(
    (l) => l.node_id.toLowerCase().includes(t.toLowerCase())
  )) ?? !1, a = ((r = e.subshelves) == null ? void 0 : r.some((l) => PR(l, t))) ?? !1;
  return o || a;
}, Mx = ({
  item: e,
  filter: t,
  parentkey: n
}) => {
  var r;
  const [o, a] = _.useState(!1), l = () => a(!o), u = (r = e.nodes) == null ? void 0 : r.filter(
    (f) => f.node_id.toLowerCase().includes(t.toLowerCase())
  ), d = o || t.length > 0;
  return PR(e, t) ? /* @__PURE__ */ k.jsxs("div", { className: "shelfcontainer", children: [
    /* @__PURE__ */ k.jsxs(
      "div",
      {
        className: "shelftitle",
        onClick: l,
        style: { cursor: "pointer" },
        title: e.description,
        children: [
          /* @__PURE__ */ k.jsx("div", { className: "shelftitle_text", children: e.name }),
          /* @__PURE__ */ k.jsx("div", { className: "expandicon " + (d ? "open" : "close"), children: /* @__PURE__ */ k.jsx(Hc, {}) })
        ]
      }
    ),
    /* @__PURE__ */ k.jsx("div", { className: "libnodecontainer " + (d ? "open" : "close"), children: /* @__PURE__ */ k.jsxs("div", { className: "libnodecontainer_inner", children: [
      u && /* @__PURE__ */ k.jsx(k.Fragment, { children: u.map((f) => /* @__PURE__ */ k.jsx(zR, { item: f }, f.node_id)) }),
      e.subshelves && /* @__PURE__ */ k.jsx(k.Fragment, { children: e.subshelves.map((f) => /* @__PURE__ */ k.jsx(
        Mx,
        {
          item: f,
          filter: t,
          parentkey: n + f.name
        },
        n + f.name
      )) })
    ] }) }),
    /* @__PURE__ */ k.jsx("hr", {})
  ] }) : /* @__PURE__ */ k.jsx(k.Fragment, {});
}, XJ = ({
  filter: e,
  setFilter: t
}) => /* @__PURE__ */ k.jsxs("div", { className: "libfilter", children: [
  /* @__PURE__ */ k.jsx(L$, { fontSize: "inherit" }),
  /* @__PURE__ */ k.jsx(
    "input",
    {
      type: "text",
      placeholder: "Filter",
      value: e,
      onChange: (n) => {
        t(n.target.value);
      }
    }
  ),
  e && /* @__PURE__ */ k.jsx(
    dM,
    {
      fontSize: "inherit",
      onClick: () => {
        t("");
      }
    }
  )
] }), m5 = [">=", "==", "<=", "<", ">"], Uh = ">=", Ax = ({
  availableModule: e
}) => /* @__PURE__ */ k.jsxs("div", { className: "module-links", children: [
  e.homepage && /* @__PURE__ */ k.jsx(k.Fragment, { children: /* @__PURE__ */ k.jsx(
    "a",
    {
      href: e.homepage,
      target: "_blank",
      rel: "noopener noreferrer",
      children: "Homepage"
    }
  ) }),
  e.source && e.homepage && " | ",
  e.source && /* @__PURE__ */ k.jsx(k.Fragment, { children: /* @__PURE__ */ k.jsx(
    "a",
    {
      href: e.source,
      target: "_blank",
      rel: "noopener noreferrer",
      children: "Source"
    }
  ) })
] }), Rx = ({
  availableModule: e
}) => {
  const [t, n] = _.useState(!1), r = () => n(!t), o = 150, a = e.description.length > o ? e.description.substring(0, o) + "..." : e.description;
  return /* @__PURE__ */ k.jsxs("div", { className: "module-description", children: [
    /* @__PURE__ */ k.jsx(DK, { remarkPlugins: [qJ], children: t ? e.description.replace(/\\n/g, `
`) : a.replace(/\\n/g, `
`) }),
    e.description.length > o && /* @__PURE__ */ k.jsx("button", { onClick: r, className: "toggle-description", children: t ? "Show less" : "Show more" })
  ] });
}, jx = ({
  availableModule: e,
  on_change: t
}) => {
  const [n, r] = _.useState(
    e.version || "latest"
  ), [o, a] = _.useState(Uh), l = (d) => {
    const f = d.target.value;
    r(f), t(f !== "latest" ? o + f : f);
  }, u = (d) => {
    d.target.value !== o && m5.includes(d.target.value) && (a(d.target.value), n !== "latest" && t(d.target.value + n));
  };
  return e.releases && !e.releases.includes(n) && e.releases.unshift(n), /* @__PURE__ */ k.jsxs(k.Fragment, { children: [
    /* @__PURE__ */ k.jsx("select", { value: o, onChange: u, children: m5.map((d) => /* @__PURE__ */ k.jsx("option", { value: d, children: d }, d)) }),
    /* @__PURE__ */ k.jsx("select", { onChange: l, value: n, children: e.releases && e.releases.map((d) => /* @__PURE__ */ k.jsx("option", { value: d, children: d }, d)) })
  ] });
}, GJ = ({
  availableModule: e,
  on_remove: t,
  on_update: n
}) => {
  const [r, o] = _.useState(
    Uh + e.version || "latest"
  );
  return /* @__PURE__ */ k.jsxs("div", { className: "addable-module", children: [
    /* @__PURE__ */ k.jsx("div", { className: "module-name", children: e.name + (e.version ? ` (${e.version})` : "") }),
    /* @__PURE__ */ k.jsx(Ax, { availableModule: e }),
    /* @__PURE__ */ k.jsx(Rx, { availableModule: e }),
    /* @__PURE__ */ k.jsxs("div", { children: [
      /* @__PURE__ */ k.jsx(
        jx,
        {
          availableModule: e,
          on_change: o
        }
      ),
      /* @__PURE__ */ k.jsx(
        "button",
        {
          className: "update-button",
          disabled: r === e.version,
          onClick: () => {
            n(e, r);
          },
          children: "Update"
        }
      ),
      /* @__PURE__ */ k.jsx(
        "button",
        {
          className: "remove-button",
          onClick: () => {
            t(e);
          },
          children: "Remove"
        }
      )
    ] })
  ] });
}, ZJ = ({
  availableModule: e,
  on_add: t
}) => {
  const [n, r] = _.useState(
    Uh + e.version || "latest"
  );
  return /* @__PURE__ */ k.jsxs("div", { className: "addable-module", children: [
    /* @__PURE__ */ k.jsx("div", { className: "module-name", children: e.name + (e.version ? ` (${e.version})` : "") }),
    /* @__PURE__ */ k.jsx(Ax, { availableModule: e }),
    /* @__PURE__ */ k.jsx(Rx, { availableModule: e }),
    /* @__PURE__ */ k.jsxs("div", { children: [
      /* @__PURE__ */ k.jsx(
        jx,
        {
          availableModule: e,
          on_change: r
        }
      ),
      /* @__PURE__ */ k.jsx(
        "button",
        {
          className: "add-button",
          onClick: () => {
            t(e, n);
          },
          children: "Add"
        }
      )
    ] })
  ] });
}, WJ = ({
  availableModule: e,
  on_add: t
}) => {
  const [n, r] = _.useState(
    Uh + e.version || "latest"
  );
  return /* @__PURE__ */ k.jsxs("div", { className: "addable-module", children: [
    /* @__PURE__ */ k.jsx("div", { className: "module-name", children: e.name }),
    /* @__PURE__ */ k.jsx(Ax, { availableModule: e }),
    /* @__PURE__ */ k.jsx(Rx, { availableModule: e }),
    /* @__PURE__ */ k.jsxs("div", { children: [
      /* @__PURE__ */ k.jsx(
        jx,
        {
          availableModule: e,
          on_change: r
        }
      ),
      /* @__PURE__ */ k.jsx(
        "button",
        {
          className: "add-button",
          onClick: () => {
            t(e, n);
          },
          children: "Add"
        }
      )
    ] })
  ] });
}, KJ = ({ children: e }) => {
  const [t, n] = _.useState(""), r = _.useContext(Ge), [o, a] = _.useState(!0), [l, u] = _.useState(!0), [d, f] = _.useState(!0), [p, m] = _.useState({
    installed: [],
    available: [],
    active: []
  }), [g, y] = _.useState(!1), w = (T) => {
    T && (r.worker === void 0 || !r.worker.is_open || r.worker.get_available_modules().then((V) => {
      m(V);
    }));
  };
  if (!r.worker)
    return /* @__PURE__ */ k.jsx(k.Fragment, {});
  const v = (T, V) => {
    y(!1), r.worker !== void 0 && r.worker.add_lib(T.name, V);
  }, x = (T, V) => {
    y(!1), r.worker !== void 0 && r.worker.add_lib(T.name, V);
  }, E = (T) => {
    y(!1), r.worker !== void 0 && r.worker.remove_lib(T.name);
  }, N = (T, V) => {
    y(!1), r.worker !== void 0 && r.worker.add_lib(T.name, V);
  }, C = (T) => T.filter(
    (V) => V.name.toLowerCase().includes(t.toLowerCase()) || V.description.toLowerCase().includes(t.toLowerCase())
  ), A = C(p.available), R = C(p.installed), D = C(p.active);
  return /* @__PURE__ */ k.jsxs(
    bs,
    {
      title: "Manage Library",
      trigger: e,
      description: "Add or remove libraries to the current worker.",
      onOpenChange: w,
      open: g,
      setOpen: y,
      children: [
        /* @__PURE__ */ k.jsx(
          "input",
          {
            className: "filter-input styledinput",
            type: "text",
            placeholder: "Filter modules...",
            value: t,
            onChange: (T) => n(T.target.value)
          }
        ),
        /* @__PURE__ */ k.jsxs(
          "div",
          {
            className: "packagelist",
            style: { maxHeight: "70%", overflow: "auto" },
            children: [
              R.length > 0 && /* @__PURE__ */ k.jsx(
                "h3",
                {
                  onClick: () => {
                    f(!d);
                  },
                  children: "Installed"
                }
              ),
              d && R.map((T) => /* @__PURE__ */ k.jsx(
                ZJ,
                {
                  availableModule: T,
                  on_add: v
                },
                T.name + T.source
              )),
              A.length > 0 && /* @__PURE__ */ k.jsx(
                "h3",
                {
                  onClick: () => {
                    u(!l);
                  },
                  children: "Available"
                }
              ),
              l && A.map((T) => /* @__PURE__ */ k.jsx(
                WJ,
                {
                  availableModule: T,
                  on_add: x
                },
                T.name + T.source
              )),
              D.length > 0 && /* @__PURE__ */ k.jsx(
                "h3",
                {
                  onClick: () => {
                    a(!o);
                  },
                  children: "Active"
                }
              ),
              o && D.map((T) => /* @__PURE__ */ k.jsx(
                GJ,
                {
                  availableModule: T,
                  on_remove: E,
                  on_update: N
                },
                T.name + T.source
              ))
            ]
          }
        )
      ]
    }
  );
}, QJ = ({
  ins: e
}) => {
  const [t, n] = _.useState(e.name), r = _.useContext(Ge), o = () => {
    r.worker && r.worker.remove_external_worker(e.uuid, e.nodeclassid);
  }, a = () => {
    r.worker && (r.worker.update_external_worker(e.uuid, e.nodeclassid, {
      name: t
    }), e.name = t);
  };
  return /* @__PURE__ */ k.jsx(k.Fragment, { children: /* @__PURE__ */ k.jsx(
    bs,
    {
      title: e.name,
      description: "Settings for" + e.name,
      trigger: /* @__PURE__ */ k.jsx("div", { children: "Settings" }),
      buttons: [
        {
          text: "Save",
          onClick: a,
          close: !0
        },
        {
          text: "Delete",
          onClick: o,
          close: !0
        }
      ],
      children: /* @__PURE__ */ k.jsx("div", { children: /* @__PURE__ */ k.jsxs("div", { children: [
        /* @__PURE__ */ k.jsx("label", { htmlFor: "name", children: "Name: " }),
        /* @__PURE__ */ k.jsx(
          "input",
          {
            type: "text",
            name: "name",
            value: t,
            onChange: (l) => n(l.target.value),
            className: "styledinput"
          }
        )
      ] }) })
    }
  ) });
}, JJ = ({
  ins: e,
  lib: t,
  filter: n = "",
  parentkey: r
}) => {
  var o;
  const [a, l] = _.useState(!1), u = () => l(!a), d = (o = t?.nodes) == null ? void 0 : o.filter(
    (f) => f.node_id.toLowerCase().includes(n.toLowerCase())
  );
  return /* @__PURE__ */ k.jsxs("div", { className: "shelfcontainer", children: [
    /* @__PURE__ */ k.jsxs(
      "div",
      {
        className: "shelftitle",
        onClick: u,
        style: { cursor: "pointer" },
        title: e.name,
        children: [
          /* @__PURE__ */ k.jsx("div", { className: "shelftitle_text", children: e.name }),
          /* @__PURE__ */ k.jsx("div", { className: "expandicon " + (a ? "open" : "close"), children: /* @__PURE__ */ k.jsx(Hc, {}) })
        ]
      }
    ),
    /* @__PURE__ */ k.jsx("div", { className: "libnodecontainer " + (a ? "open" : "close"), children: /* @__PURE__ */ k.jsx("div", { className: "libnodecontainer_inner", children: a && /* @__PURE__ */ k.jsxs(k.Fragment, { children: [
      /* @__PURE__ */ k.jsx("div", { className: "libnodeentry", title: e.uuid, children: /* @__PURE__ */ k.jsx(QJ, { ins: e }) }),
      t && /* @__PURE__ */ k.jsxs(k.Fragment, { children: [
        d && /* @__PURE__ */ k.jsx(k.Fragment, { children: d.map((f) => /* @__PURE__ */ k.jsx(
          zR,
          {
            item: f
          },
          r + f.node_id
        )) }),
        t.subshelves.map((f) => /* @__PURE__ */ k.jsx(
          Mx,
          {
            item: f,
            filter: n,
            parentkey: r + f.name
          },
          r + f.name
        ))
      ] })
    ] }) }) })
  ] });
}, eee = ({
  item: e,
  mod: t,
  lib: n
}) => {
  const r = _.useContext(Ge), [o, a] = _.useState(!1), l = () => a(!o), u = () => {
    var p;
    (p = r.worker) == null || p.add_external_worker({
      module: t,
      cls_module: e.module,
      cls_name: e.class_name
    });
  }, d = (p) => {
    p.detail === 2 && u();
  }, f = e.name || e.module + "." + e.class_name;
  return /* @__PURE__ */ k.jsxs("div", { className: "shelfcontainer", children: [
    /* @__PURE__ */ k.jsxs(
      "div",
      {
        className: "shelftitle",
        onClick: l,
        style: { cursor: "pointer" },
        title: f,
        children: [
          /* @__PURE__ */ k.jsx("div", { className: "shelftitle_text", children: f }),
          /* @__PURE__ */ k.jsx("div", { className: "expandicon " + (o ? "open" : "close"), children: /* @__PURE__ */ k.jsx(Hc, {}) })
        ]
      }
    ),
    /* @__PURE__ */ k.jsx("div", { className: "libnodecontainer " + (o ? "open" : "close"), children: /* @__PURE__ */ k.jsx("div", { className: "libnodecontainer_inner", children: o && /* @__PURE__ */ k.jsxs(k.Fragment, { children: [
      /* @__PURE__ */ k.jsx(
        "div",
        {
          className: "libnodeentry",
          onClick: d,
          title: e.name,
          children: "New Instance"
        }
      ),
      e.instances.map((p) => /* @__PURE__ */ k.jsx(
        JJ,
        {
          ins: p,
          lib: n?.subshelves.find(
            (m) => m.name === p.uuid
          ),
          parentkey: p.uuid
        },
        p.uuid
      ))
    ] }) }) })
  ] });
}, tee = ({
  externalworkermod: e,
  lib: t
}) => {
  const [n, r] = _.useState(!1), o = () => r(!n), a = n;
  return /* @__PURE__ */ k.jsxs("div", { className: "shelfcontainer", children: [
    /* @__PURE__ */ k.jsxs(
      "div",
      {
        className: "shelftitle",
        onClick: o,
        style: { cursor: "pointer" },
        title: e.module,
        children: [
          /* @__PURE__ */ k.jsx("div", { className: "shelftitle_text", children: e.module }),
          /* @__PURE__ */ k.jsx("div", { className: "expandicon " + (a ? "open" : "close"), children: /* @__PURE__ */ k.jsx(Hc, {}) })
        ]
      }
    ),
    /* @__PURE__ */ k.jsx("div", { className: "libnodecontainer " + (a ? "open" : "close"), children: /* @__PURE__ */ k.jsx("div", { className: "libnodecontainer_inner", children: e.worker_classes.map((l) => /* @__PURE__ */ k.jsx(
      eee,
      {
        item: l,
        mod: e.module,
        lib: t
      },
      l.module + l.class_name
    )) }) }),
    /* @__PURE__ */ k.jsx("hr", {})
  ] });
}, nee = () => {
  var e, t;
  const n = _.useContext(Ge), r = n.lib.libstate(), o = _.useContext(Ge), a = o.local_settings(
    (g) => g.view_settings.expand_lib
  ), l = o.local_settings(
    (g) => g.update_view_settings
  ), u = (g) => {
    l({ expand_lib: g });
  }, d = gX("m"), [f, p] = _.useState(""), m = ((e = n.worker) == null ? void 0 : e.state((g) => g.is_open)) ?? !1;
  return /* @__PURE__ */ k.jsx(
    MA,
    {
      maxSize: d ? "100%" : "18.75rem",
      direction: d ? "down" : "right",
      containerClassName: "pos-left pos-top bg1 h-12",
      onExpandChange: u,
      expanded: a === void 0 ? !0 : a,
      children: /* @__PURE__ */ k.jsxs("div", { className: "libcontainer", children: [
        /* @__PURE__ */ k.jsxs("div", { className: "library", children: [
          /* @__PURE__ */ k.jsx("div", { className: "libtitle", children: "Lib" }),
          /* @__PURE__ */ k.jsx("hr", { className: "hr_prominent" }),
          /* @__PURE__ */ k.jsx(XJ, { filter: f, setFilter: p }),
          /* @__PURE__ */ k.jsx("div", { className: "vscrollcontainer", children: r.lib.shelves.filter((g) => g.name !== "_external_worker").map((g) => /* @__PURE__ */ k.jsx(
            Mx,
            {
              item: g,
              filter: f,
              parentkey: g.name
            },
            g.name
          )) }),
          /* @__PURE__ */ k.jsx("hr", {}),
          /* @__PURE__ */ k.jsx("div", { className: "libtitle", children: "External Worker" }),
          /* @__PURE__ */ k.jsx("hr", { className: "hr_prominent" }),
          /* @__PURE__ */ k.jsx("div", { className: "vscrollcontainer", children: (t = r.external_worker) == null ? void 0 : t.map((g) => /* @__PURE__ */ k.jsx(
            tee,
            {
              externalworkermod: g,
              lib: r.lib.shelves.find(
                (y) => y.name === "_external_worker"
              )
            },
            g.module
          )) }),
          /* @__PURE__ */ k.jsx("hr", {})
        ] }),
        /* @__PURE__ */ k.jsx("div", { style: { paddingTop: "0.5rem" } }),
        m && /* @__PURE__ */ k.jsx("div", { className: "addlib", children: /* @__PURE__ */ k.jsx(KJ, { children: /* @__PURE__ */ k.jsx("button", { children: "Manage Libraries" }) }) })
      ] })
    }
  );
};
function ree(e, t) {
  if (Object.is(e, t))
    return !0;
  if (typeof e != "object" || e === null || typeof t != "object" || t === null)
    return !1;
  if (e instanceof Map && t instanceof Map) {
    if (e.size !== t.size) return !1;
    for (const [r, o] of e)
      if (!Object.is(o, t.get(r)))
        return !1;
    return !0;
  }
  if (e instanceof Set && t instanceof Set) {
    if (e.size !== t.size) return !1;
    for (const r of e)
      if (!t.has(r))
        return !1;
    return !0;
  }
  const n = Object.keys(e);
  if (n.length !== Object.keys(t).length)
    return !1;
  for (const r of n)
    if (!Object.prototype.hasOwnProperty.call(t, r) || !Object.is(e[r], t[r]))
      return !1;
  return !0;
}
const { useRef: oee } = $t;
function iee(e) {
  const t = oee();
  return (n) => {
    const r = e(n);
    return ree(t.current, r) ? t.current : t.current = r;
  };
}
var Dx = "Popover", [LR, tce] = Gi(Dx, [
  Th
]), Zc = Th(), [aee, Wi] = LR(Dx), IR = (e) => {
  const {
    __scopePopover: t,
    children: n,
    open: r,
    defaultOpen: o,
    onOpenChange: a,
    modal: l = !1
  } = e, u = Zc(t), d = _.useRef(null), [f, p] = _.useState(!1), [m = !1, g] = ys({
    prop: r,
    defaultProp: o,
    onChange: a
  });
  return /* @__PURE__ */ k.jsx(tx, { ...u, children: /* @__PURE__ */ k.jsx(
    aee,
    {
      scope: t,
      contentId: Vo(),
      triggerRef: d,
      open: m,
      onOpenChange: g,
      onOpenToggle: _.useCallback(() => g((y) => !y), [g]),
      hasCustomAnchor: f,
      onCustomAnchorAdd: _.useCallback(() => p(!0), []),
      onCustomAnchorRemove: _.useCallback(() => p(!1), []),
      modal: l,
      children: n
    }
  ) });
};
IR.displayName = Dx;
var BR = "PopoverAnchor", lee = _.forwardRef(
  (e, t) => {
    const { __scopePopover: n, ...r } = e, o = Wi(BR, n), a = Zc(n), { onCustomAnchorAdd: l, onCustomAnchorRemove: u } = o;
    return _.useEffect(() => (l(), () => u()), [l, u]), /* @__PURE__ */ k.jsx(nx, { ...a, ...r, ref: t });
  }
);
lee.displayName = BR;
var VR = "PopoverTrigger", HR = _.forwardRef(
  (e, t) => {
    const { __scopePopover: n, ...r } = e, o = Wi(VR, n), a = Zc(n), l = kt(t, o.triggerRef), u = /* @__PURE__ */ k.jsx(
      vt.button,
      {
        type: "button",
        "aria-haspopup": "dialog",
        "aria-expanded": o.open,
        "aria-controls": o.contentId,
        "data-state": XR(o.open),
        ...r,
        ref: l,
        onClick: Te(e.onClick, o.onOpenToggle)
      }
    );
    return o.hasCustomAnchor ? u : /* @__PURE__ */ k.jsx(nx, { asChild: !0, ...a, children: u });
  }
);
HR.displayName = VR;
var Tx = "PopoverPortal", [see, uee] = LR(Tx, {
  forceMount: void 0
}), UR = (e) => {
  const { __scopePopover: t, forceMount: n, children: r, container: o } = e, a = Wi(Tx, t);
  return /* @__PURE__ */ k.jsx(see, { scope: t, forceMount: n, children: /* @__PURE__ */ k.jsx(Wo, { present: n || a.open, children: /* @__PURE__ */ k.jsx(Ew, { asChild: !0, container: o, children: r }) }) });
};
UR.displayName = Tx;
var fs = "PopoverContent", FR = _.forwardRef(
  (e, t) => {
    const n = uee(fs, e.__scopePopover), { forceMount: r = n.forceMount, ...o } = e, a = Wi(fs, e.__scopePopover);
    return /* @__PURE__ */ k.jsx(Wo, { present: r || a.open, children: a.modal ? /* @__PURE__ */ k.jsx(dee, { ...o, ref: t }) : /* @__PURE__ */ k.jsx(fee, { ...o, ref: t }) });
  }
);
FR.displayName = fs;
var cee = /* @__PURE__ */ ss("PopoverContent.RemoveScroll"), dee = _.forwardRef(
  (e, t) => {
    const n = Wi(fs, e.__scopePopover), r = _.useRef(null), o = kt(t, r), a = _.useRef(!1);
    return _.useEffect(() => {
      const l = r.current;
      if (l) return Ow(l);
    }, []), /* @__PURE__ */ k.jsx(Eh, { as: cee, allowPinchZoom: !0, children: /* @__PURE__ */ k.jsx(
      $R,
      {
        ...e,
        ref: o,
        trapFocus: n.open,
        disableOutsidePointerEvents: !0,
        onCloseAutoFocus: Te(e.onCloseAutoFocus, (l) => {
          var u;
          l.preventDefault(), a.current || (u = n.triggerRef.current) == null || u.focus();
        }),
        onPointerDownOutside: Te(
          e.onPointerDownOutside,
          (l) => {
            const u = l.detail.originalEvent, d = u.button === 0 && u.ctrlKey === !0, f = u.button === 2 || d;
            a.current = f;
          },
          { checkForDefaultPrevented: !1 }
        ),
        onFocusOutside: Te(
          e.onFocusOutside,
          (l) => l.preventDefault(),
          { checkForDefaultPrevented: !1 }
        )
      }
    ) });
  }
), fee = _.forwardRef(
  (e, t) => {
    const n = Wi(fs, e.__scopePopover), r = _.useRef(!1), o = _.useRef(!1);
    return /* @__PURE__ */ k.jsx(
      $R,
      {
        ...e,
        ref: t,
        trapFocus: !1,
        disableOutsidePointerEvents: !1,
        onCloseAutoFocus: (a) => {
          var l, u;
          (l = e.onCloseAutoFocus) == null || l.call(e, a), a.defaultPrevented || (r.current || (u = n.triggerRef.current) == null || u.focus(), a.preventDefault()), r.current = !1, o.current = !1;
        },
        onInteractOutside: (a) => {
          var l, u;
          (l = e.onInteractOutside) == null || l.call(e, a), a.defaultPrevented || (r.current = !0, a.detail.originalEvent.type === "pointerdown" && (o.current = !0));
          const d = a.target;
          (u = n.triggerRef.current) != null && u.contains(d) && a.preventDefault(), a.detail.originalEvent.type === "focusin" && o.current && a.preventDefault();
        }
      }
    );
  }
), $R = _.forwardRef(
  (e, t) => {
    const {
      __scopePopover: n,
      trapFocus: r,
      onOpenAutoFocus: o,
      onCloseAutoFocus: a,
      disableOutsidePointerEvents: l,
      onEscapeKeyDown: u,
      onPointerDownOutside: d,
      onFocusOutside: f,
      onInteractOutside: p,
      ...m
    } = e, g = Wi(fs, n), y = Zc(n);
    return Cw(), /* @__PURE__ */ k.jsx(
      kh,
      {
        asChild: !0,
        loop: !0,
        trapped: r,
        onMountAutoFocus: o,
        onUnmountAutoFocus: a,
        children: /* @__PURE__ */ k.jsx(
          Sh,
          {
            asChild: !0,
            disableOutsidePointerEvents: l,
            onInteractOutside: p,
            onEscapeKeyDown: u,
            onPointerDownOutside: d,
            onFocusOutside: f,
            onDismiss: () => g.onOpenChange(!1),
            children: /* @__PURE__ */ k.jsx(
              TM,
              {
                "data-state": XR(g.open),
                role: "dialog",
                id: g.contentId,
                ...y,
                ...m,
                ref: t,
                style: {
                  ...m.style,
                  "--radix-popover-content-transform-origin": "var(--radix-popper-transform-origin)",
                  "--radix-popover-content-available-width": "var(--radix-popper-available-width)",
                  "--radix-popover-content-available-height": "var(--radix-popper-available-height)",
                  "--radix-popover-trigger-width": "var(--radix-popper-anchor-width)",
                  "--radix-popover-trigger-height": "var(--radix-popper-anchor-height)"
                }
              }
            )
          }
        )
      }
    );
  }
), YR = "PopoverClose", pee = _.forwardRef(
  (e, t) => {
    const { __scopePopover: n, ...r } = e, o = Wi(YR, n);
    return /* @__PURE__ */ k.jsx(
      vt.button,
      {
        type: "button",
        ...r,
        ref: t,
        onClick: Te(e.onClick, () => o.onOpenChange(!1))
      }
    );
  }
);
pee.displayName = YR;
var hee = "PopoverArrow", qR = _.forwardRef(
  (e, t) => {
    const { __scopePopover: n, ...r } = e, o = Zc(n);
    return /* @__PURE__ */ k.jsx(zM, { ...o, ...r, ref: t });
  }
);
qR.displayName = hee;
function XR(e) {
  return e ? "open" : "closed";
}
var GR = IR, ZR = HR, WR = UR, KR = FR, mee = qR;
const gee = ({
  iostore: e
}) => {
  const { full: t, preview: n } = e.valuestore(), r = JSON.stringify(t?.value || n?.value) || "";
  return `Bytes(${Math.round(3 * r.length / 4)})`;
}, yee = {
  bytes: gee
}, vee = (e) => typeof e == "boolean" || e instanceof Boolean, bee = (e) => typeof e == "number" || e instanceof Number, wee = (e) => typeof e == "bigint" || e instanceof BigInt, QR = (e) => !!e && e instanceof Date, xee = (e) => typeof e == "string" || e instanceof String, See = (e) => Array.isArray(e), kee = (e) => typeof e == "object" && e !== null, JR = (e) => !!e && e instanceof Object && typeof e == "function";
function Fp(e, t) {
  return t === void 0 && (t = !1), !e || t ? `"${e}"` : e;
}
function _ee(e, t, n) {
  return n ? JSON.stringify(e) : t ? `"${e}"` : e;
}
function ej(e) {
  let {
    field: t,
    value: n,
    data: r,
    lastElement: o,
    openBracket: a,
    closeBracket: l,
    level: u,
    style: d,
    shouldExpandNode: f,
    clickToExpandNode: p,
    outerRef: m,
    beforeExpandChange: g
  } = e;
  const y = _.useRef(!1), [w, v] = _.useState(() => f(u, n, t)), x = _.useRef(null);
  _.useEffect(() => {
    y.current ? v(f(u, n, t)) : y.current = !0;
  }, [f]);
  const E = _.useId();
  if (r.length === 0)
    return Eee({
      field: t,
      openBracket: a,
      closeBracket: l,
      lastElement: o,
      style: d
    });
  const N = w ? d.collapseIcon : d.expandIcon, C = w ? d.ariaLables.collapseJson : d.ariaLables.expandJson, A = u + 1, R = r.length - 1, D = (F) => {
    w !== F && (!g || g({
      level: u,
      value: n,
      field: t,
      newExpandValue: F
    })) && v(F);
  }, T = (F) => {
    if (F.key === "ArrowRight" || F.key === "ArrowLeft")
      F.preventDefault(), D(F.key === "ArrowRight");
    else if (F.key === "ArrowUp" || F.key === "ArrowDown") {
      F.preventDefault();
      const O = F.key === "ArrowUp" ? -1 : 1;
      if (!m.current) return;
      const B = m.current.querySelectorAll("[role=button]");
      let U = -1;
      for (let z = 0; z < B.length; z++)
        if (B[z].tabIndex === 0) {
          U = z;
          break;
        }
      if (U < 0)
        return;
      const G = (U + O + B.length) % B.length;
      B[U].tabIndex = -1, B[G].tabIndex = 0, B[G].focus();
    }
  }, V = () => {
    var F;
    D(!w);
    const O = x.current;
    if (!O) return;
    const B = (F = m.current) === null || F === void 0 ? void 0 : F.querySelector('[role=button][tabindex="0"]');
    B && (B.tabIndex = -1), O.tabIndex = 0, O.focus();
  };
  return /* @__PURE__ */ _.createElement("div", {
    className: d.basicChildStyle,
    role: "treeitem",
    "aria-expanded": w,
    "aria-selected": void 0
  }, /* @__PURE__ */ _.createElement("span", {
    className: N,
    onClick: V,
    onKeyDown: T,
    role: "button",
    "aria-label": C,
    "aria-expanded": w,
    "aria-controls": w ? E : void 0,
    ref: x,
    tabIndex: u === 0 ? 0 : -1
  }), (t || t === "") && (p ? /* @__PURE__ */ _.createElement("span", {
    className: d.clickableLabel,
    onClick: V,
    onKeyDown: T
  }, Fp(t, d.quotesForFieldNames), ":") : /* @__PURE__ */ _.createElement("span", {
    className: d.label
  }, Fp(t, d.quotesForFieldNames), ":")), /* @__PURE__ */ _.createElement("span", {
    className: d.punctuation
  }, a), w ? /* @__PURE__ */ _.createElement("ul", {
    id: E,
    role: "group",
    className: d.childFieldsContainer
  }, r.map((F, O) => /* @__PURE__ */ _.createElement(tj, {
    key: F[0] || O,
    field: F[0],
    value: F[1],
    style: d,
    lastElement: O === R,
    level: A,
    shouldExpandNode: f,
    clickToExpandNode: p,
    outerRef: m
  }))) : /* @__PURE__ */ _.createElement("span", {
    className: d.collapsedContent,
    onClick: V,
    onKeyDown: T
  }), /* @__PURE__ */ _.createElement("span", {
    className: d.punctuation
  }, l), !o && /* @__PURE__ */ _.createElement("span", {
    className: d.punctuation
  }, ","));
}
function Eee(e) {
  let {
    field: t,
    openBracket: n,
    closeBracket: r,
    lastElement: o,
    style: a
  } = e;
  return /* @__PURE__ */ _.createElement("div", {
    className: a.basicChildStyle,
    role: "treeitem",
    "aria-selected": void 0
  }, (t || t === "") && /* @__PURE__ */ _.createElement("span", {
    className: a.label
  }, Fp(t, a.quotesForFieldNames), ":"), /* @__PURE__ */ _.createElement("span", {
    className: a.punctuation
  }, n), /* @__PURE__ */ _.createElement("span", {
    className: a.punctuation
  }, r), !o && /* @__PURE__ */ _.createElement("span", {
    className: a.punctuation
  }, ","));
}
function Cee(e) {
  let {
    field: t,
    value: n,
    style: r,
    lastElement: o,
    shouldExpandNode: a,
    clickToExpandNode: l,
    level: u,
    outerRef: d,
    beforeExpandChange: f
  } = e;
  return ej({
    field: t,
    value: n,
    lastElement: o || !1,
    level: u,
    openBracket: "{",
    closeBracket: "}",
    style: r,
    shouldExpandNode: a,
    clickToExpandNode: l,
    data: Object.keys(n).map((p) => [p, n[p]]),
    outerRef: d,
    beforeExpandChange: f
  });
}
function Oee(e) {
  let {
    field: t,
    value: n,
    style: r,
    lastElement: o,
    level: a,
    shouldExpandNode: l,
    clickToExpandNode: u,
    outerRef: d,
    beforeExpandChange: f
  } = e;
  return ej({
    field: t,
    value: n,
    lastElement: o || !1,
    level: a,
    openBracket: "[",
    closeBracket: "]",
    style: r,
    shouldExpandNode: l,
    clickToExpandNode: u,
    data: n.map((p) => [void 0, p]),
    outerRef: d,
    beforeExpandChange: f
  });
}
function Nee(e) {
  let {
    field: t,
    value: n,
    style: r,
    lastElement: o
  } = e, a, l = r.otherValue;
  return n === null ? (a = "null", l = r.nullValue) : n === void 0 ? (a = "undefined", l = r.undefinedValue) : xee(n) ? (a = _ee(n, !r.noQuotesForStringValues, r.stringifyStringValues), l = r.stringValue) : vee(n) ? (a = n ? "true" : "false", l = r.booleanValue) : bee(n) ? (a = n.toString(), l = r.numberValue) : wee(n) ? (a = `${n.toString()}n`, l = r.numberValue) : QR(n) ? a = n.toISOString() : JR(n) ? a = "function() { }" : a = n.toString(), /* @__PURE__ */ _.createElement("div", {
    className: r.basicChildStyle,
    role: "treeitem",
    "aria-selected": void 0
  }, (t || t === "") && /* @__PURE__ */ _.createElement("span", {
    className: r.label
  }, Fp(t, r.quotesForFieldNames), ":"), /* @__PURE__ */ _.createElement("span", {
    className: l
  }, a), !o && /* @__PURE__ */ _.createElement("span", {
    className: r.punctuation
  }, ","));
}
function tj(e) {
  const t = e.value;
  return See(t) ? /* @__PURE__ */ _.createElement(Oee, Object.assign({}, e)) : kee(t) && !QR(t) && !JR(t) ? /* @__PURE__ */ _.createElement(Cee, Object.assign({}, e)) : /* @__PURE__ */ _.createElement(Nee, Object.assign({}, e));
}
var rt = { "container-light": "_2IvMF _GzYRV", "basic-element-style": "_2bkNM", "child-fields-container": "_1BXBN", "label-light": "_1MGIk", "clickable-label-light": "_2YKJg _1MGIk _1MFti", "punctuation-light": "_3uHL6 _3eOF8", "value-null-light": "_2T6PJ", "value-undefined-light": "_1Gho6", "value-string-light": "_vGjyY", "value-number-light": "_1bQdo", "value-boolean-light": "_3zQKs", "value-other-light": "_1xvuR", "collapse-icon-light": "_oLqym _f10Tu _1MFti _1LId0", "expand-icon-light": "_2AXVT _f10Tu _1MFti _1UmXx", "collapsed-content-light": "_2KJWg _1pNG9 _1MFti", "container-dark": "_11RoI _GzYRV", "expand-icon-dark": "_17H2C _f10Tu _1MFti _1UmXx", "collapse-icon-dark": "_3QHg2 _f10Tu _1MFti _1LId0", "collapsed-content-dark": "_3fDAz _1pNG9 _1MFti", "label-dark": "_2bSDX", "clickable-label-dark": "_1RQEj _2bSDX _1MFti", "punctuation-dark": "_gsbQL _3eOF8", "value-null-dark": "_LaAZe", "value-undefined-dark": "_GTKgm", "value-string-dark": "_Chy1W", "value-number-dark": "_2bveF", "value-boolean-dark": "_2vRm-", "value-other-dark": "_1prJR" };
const nj = {
  collapseJson: "collapse JSON",
  expandJson: "expand JSON"
}, g5 = {
  container: rt["container-light"],
  basicChildStyle: rt["basic-element-style"],
  childFieldsContainer: rt["child-fields-container"],
  label: rt["label-light"],
  clickableLabel: rt["clickable-label-light"],
  nullValue: rt["value-null-light"],
  undefinedValue: rt["value-undefined-light"],
  stringValue: rt["value-string-light"],
  booleanValue: rt["value-boolean-light"],
  numberValue: rt["value-number-light"],
  otherValue: rt["value-other-light"],
  punctuation: rt["punctuation-light"],
  collapseIcon: rt["collapse-icon-light"],
  expandIcon: rt["expand-icon-light"],
  collapsedContent: rt["collapsed-content-light"],
  noQuotesForStringValues: !1,
  quotesForFieldNames: !1,
  ariaLables: nj,
  stringifyStringValues: !1
}, Mee = {
  container: rt["container-dark"],
  basicChildStyle: rt["basic-element-style"],
  childFieldsContainer: rt["child-fields-container"],
  label: rt["label-dark"],
  clickableLabel: rt["clickable-label-dark"],
  nullValue: rt["value-null-dark"],
  undefinedValue: rt["value-undefined-dark"],
  stringValue: rt["value-string-dark"],
  booleanValue: rt["value-boolean-dark"],
  numberValue: rt["value-number-dark"],
  otherValue: rt["value-other-dark"],
  punctuation: rt["punctuation-dark"],
  collapseIcon: rt["collapse-icon-dark"],
  expandIcon: rt["expand-icon-dark"],
  collapsedContent: rt["collapsed-content-dark"],
  noQuotesForStringValues: !1,
  quotesForFieldNames: !1,
  ariaLables: nj,
  stringifyStringValues: !1
}, Aee = () => !0, Ree = (e) => e < 1, jee = (e) => {
  let {
    data: t,
    style: n = g5,
    shouldExpandNode: r = Aee,
    clickToExpandNode: o = !1,
    beforeExpandChange: a,
    ...l
  } = e;
  const u = _.useRef(null);
  return /* @__PURE__ */ _.createElement("div", Object.assign({
    "aria-label": "JSON view"
  }, l, {
    className: n.container,
    ref: u,
    role: "tree"
  }), /* @__PURE__ */ _.createElement(tj, {
    value: t,
    style: {
      ...g5,
      ...n
    },
    lastElement: !0,
    level: 0,
    shouldExpandNode: r,
    clickToExpandNode: o,
    outerRef: u,
    beforeExpandChange: a
  }));
};
function Dee(e) {
  for (const t in e)
    if (Object.hasOwn(e, t))
      return !1;
  return !0;
}
function Tee(e) {
  if (e == null || typeof e != "object")
    return !1;
  const t = Object.getPrototypeOf(e);
  return t !== null && t !== Object.prototype ? !1 : Dee(e);
}
const zee = ({ data: e }) => /* @__PURE__ */ k.jsx(
  jee,
  {
    data: Tee(e) ? "" : e,
    style: Mee,
    shouldExpandNode: Ree
  }
);
function rj(e) {
  var t, n, r = "";
  if (typeof e == "string" || typeof e == "number") r += e;
  else if (typeof e == "object") if (Array.isArray(e)) {
    var o = e.length;
    for (t = 0; t < o; t++) e[t] && (n = rj(e[t])) && (r && (r += " "), r += n);
  } else for (n in e) e[n] && (r && (r += " "), r += n);
  return r;
}
function Yt() {
  for (var e, t, n = 0, r = "", o = arguments.length; n < o; n++) (e = arguments[n]) && (t = rj(e)) && (r && (r += " "), r += t);
  return r;
}
function Jo(e, t, n = void 0) {
  const r = {};
  for (const o in e) {
    const a = e[o];
    let l = "", u = !0;
    for (let d = 0; d < a.length; d += 1) {
      const f = a[d];
      f && (l += (u === !0 ? "" : " ") + t(f), u = !1, n && n[f] && (l += " " + n[f]));
    }
    r[o] = l;
  }
  return r;
}
const oj = /* @__PURE__ */ _.createContext();
function Ia(e, ...t) {
  const n = new URL(`https://mui.com/production-error/?code=${e}`);
  return t.forEach((r) => n.searchParams.append("args[]", r)), `Minified MUI error #${e}; visit ${n} for the full message.`;
}
function Sn(e) {
  if (typeof e != "string")
    throw new Error(Ia(7));
  return e.charAt(0).toUpperCase() + e.slice(1);
}
var y5 = { exports: {} }, dt = {};
/**
 * @license React
 * react-is.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var v5;
function Pee() {
  if (v5) return dt;
  v5 = 1;
  var e = Symbol.for("react.transitional.element"), t = Symbol.for("react.portal"), n = Symbol.for("react.fragment"), r = Symbol.for("react.strict_mode"), o = Symbol.for("react.profiler"), a = Symbol.for("react.consumer"), l = Symbol.for("react.context"), u = Symbol.for("react.forward_ref"), d = Symbol.for("react.suspense"), f = Symbol.for("react.suspense_list"), p = Symbol.for("react.memo"), m = Symbol.for("react.lazy"), g = Symbol.for("react.view_transition"), y = Symbol.for("react.client.reference");
  function w(v) {
    if (typeof v == "object" && v !== null) {
      var x = v.$$typeof;
      switch (x) {
        case e:
          switch (v = v.type, v) {
            case n:
            case o:
            case r:
            case d:
            case f:
            case g:
              return v;
            default:
              switch (v = v && v.$$typeof, v) {
                case l:
                case u:
                case m:
                case p:
                  return v;
                case a:
                  return v;
                default:
                  return x;
              }
          }
        case t:
          return x;
      }
    }
  }
  return dt.ContextConsumer = a, dt.ContextProvider = l, dt.Element = e, dt.ForwardRef = u, dt.Fragment = n, dt.Lazy = m, dt.Memo = p, dt.Portal = t, dt.Profiler = o, dt.StrictMode = r, dt.Suspense = d, dt.SuspenseList = f, dt.isContextConsumer = function(v) {
    return w(v) === a;
  }, dt.isContextProvider = function(v) {
    return w(v) === l;
  }, dt.isElement = function(v) {
    return typeof v == "object" && v !== null && v.$$typeof === e;
  }, dt.isForwardRef = function(v) {
    return w(v) === u;
  }, dt.isFragment = function(v) {
    return w(v) === n;
  }, dt.isLazy = function(v) {
    return w(v) === m;
  }, dt.isMemo = function(v) {
    return w(v) === p;
  }, dt.isPortal = function(v) {
    return w(v) === t;
  }, dt.isProfiler = function(v) {
    return w(v) === o;
  }, dt.isStrictMode = function(v) {
    return w(v) === r;
  }, dt.isSuspense = function(v) {
    return w(v) === d;
  }, dt.isSuspenseList = function(v) {
    return w(v) === f;
  }, dt.isValidElementType = function(v) {
    return typeof v == "string" || typeof v == "function" || v === n || v === o || v === r || v === d || v === f || typeof v == "object" && v !== null && (v.$$typeof === m || v.$$typeof === p || v.$$typeof === l || v.$$typeof === a || v.$$typeof === u || v.$$typeof === y || v.getModuleId !== void 0);
  }, dt.typeOf = w, dt;
}
var b5;
function Lee() {
  return b5 || (b5 = 1, y5.exports = /* @__PURE__ */ Pee()), y5.exports;
}
var ij = /* @__PURE__ */ Lee();
function Po(e) {
  if (typeof e != "object" || e === null)
    return !1;
  const t = Object.getPrototypeOf(e);
  return (t === null || t === Object.prototype || Object.getPrototypeOf(t) === null) && !(Symbol.toStringTag in e) && !(Symbol.iterator in e);
}
function aj(e) {
  if (/* @__PURE__ */ _.isValidElement(e) || ij.isValidElementType(e) || !Po(e))
    return e;
  const t = {};
  return Object.keys(e).forEach((n) => {
    t[n] = aj(e[n]);
  }), t;
}
function tr(e, t, n = {
  clone: !0
}) {
  const r = n.clone ? {
    ...e
  } : e;
  return Po(e) && Po(t) && Object.keys(t).forEach((o) => {
    /* @__PURE__ */ _.isValidElement(t[o]) || ij.isValidElementType(t[o]) ? r[o] = t[o] : Po(t[o]) && // Avoid prototype pollution
    Object.prototype.hasOwnProperty.call(e, o) && Po(e[o]) ? r[o] = tr(e[o], t[o], n) : n.clone ? r[o] = Po(t[o]) ? aj(t[o]) : t[o] : r[o] = t[o];
  }), r;
}
function rc(e, t) {
  return t ? tr(e, t, {
    clone: !1
    // No need to clone deep, it's way faster.
  }) : e;
}
function Iee(e, t) {
  if (!e.containerQueries)
    return t;
  const n = Object.keys(t).filter((r) => r.startsWith("@container")).sort((r, o) => {
    var a, l;
    const u = /min-width:\s*([0-9.]+)/;
    return +(((a = r.match(u)) == null ? void 0 : a[1]) || 0) - +(((l = o.match(u)) == null ? void 0 : l[1]) || 0);
  });
  return n.length ? n.reduce((r, o) => {
    const a = t[o];
    return delete r[o], r[o] = a, r;
  }, {
    ...t
  }) : t;
}
function Bee(e, t) {
  return t === "@" || t.startsWith("@") && (e.some((n) => t.startsWith(`@${n}`)) || !!t.match(/^@\d/));
}
function Vee(e, t) {
  const n = t.match(/^@([^/]+)?\/?(.+)?$/);
  if (!n)
    return null;
  const [, r, o] = n, a = Number.isNaN(+r) ? r || 0 : +r;
  return e.containerQueries(o).up(a);
}
function Hee(e) {
  const t = (a, l) => a.replace("@media", l ? `@container ${l}` : "@container");
  function n(a, l) {
    a.up = (...u) => t(e.breakpoints.up(...u), l), a.down = (...u) => t(e.breakpoints.down(...u), l), a.between = (...u) => t(e.breakpoints.between(...u), l), a.only = (...u) => t(e.breakpoints.only(...u), l), a.not = (...u) => {
      const d = t(e.breakpoints.not(...u), l);
      return d.includes("not all and") ? d.replace("not all and ", "").replace("min-width:", "width<").replace("max-width:", "width>").replace("and", "or") : d;
    };
  }
  const r = {}, o = (a) => (n(r, a), r);
  return n(o), {
    ...e,
    containerQueries: o
  };
}
const Fh = {
  xs: 0,
  // phone
  sm: 600,
  // tablet
  md: 900,
  // small laptop
  lg: 1200,
  // desktop
  xl: 1536
  // large screen
}, w5 = {
  // Sorted ASC by size. That's important.
  // It can't be configured as it's used statically for propTypes.
  keys: ["xs", "sm", "md", "lg", "xl"],
  up: (e) => `@media (min-width:${Fh[e]}px)`
}, Uee = {
  containerQueries: (e) => ({
    up: (t) => {
      let n = typeof t == "number" ? t : Fh[t] || t;
      return typeof n == "number" && (n = `${n}px`), e ? `@container ${e} (min-width:${n})` : `@container (min-width:${n})`;
    }
  })
};
function Go(e, t, n) {
  const r = e.theme || {};
  if (Array.isArray(t)) {
    const o = r.breakpoints || w5;
    return t.reduce((a, l, u) => (a[o.up(o.keys[u])] = n(t[u]), a), {});
  }
  if (typeof t == "object") {
    const o = r.breakpoints || w5;
    return Object.keys(t).reduce((a, l) => {
      if (Bee(o.keys, l)) {
        const u = Vee(r.containerQueries ? r : Uee, l);
        u && (a[u] = n(t[l], l));
      } else if (Object.keys(o.values || Fh).includes(l)) {
        const u = o.up(l);
        a[u] = n(t[l], l);
      } else {
        const u = l;
        a[u] = t[u];
      }
      return a;
    }, {});
  }
  return n(t);
}
function Fee(e = {}) {
  var t;
  return ((t = e.keys) == null ? void 0 : t.reduce((n, r) => {
    const o = e.up(r);
    return n[o] = {}, n;
  }, {})) || {};
}
function $ee(e, t) {
  return e.reduce((n, r) => {
    const o = n[r];
    return (!o || Object.keys(o).length === 0) && delete n[r], n;
  }, t);
}
function $h(e, t, n = !0) {
  if (!t || typeof t != "string")
    return null;
  if (e && e.vars && n) {
    const r = `vars.${t}`.split(".").reduce((o, a) => o && o[a] ? o[a] : null, e);
    if (r != null)
      return r;
  }
  return t.split(".").reduce((r, o) => r && r[o] != null ? r[o] : null, e);
}
function $p(e, t, n, r = n) {
  let o;
  return typeof e == "function" ? o = e(n) : Array.isArray(e) ? o = e[n] || r : o = $h(e, n) || r, t && (o = t(o, r, e)), o;
}
function zt(e) {
  const {
    prop: t,
    cssProperty: n = e.prop,
    themeKey: r,
    transform: o
  } = e, a = (l) => {
    if (l[t] == null)
      return null;
    const u = l[t], d = l.theme, f = $h(d, r) || {};
    return Go(l, u, (p) => {
      let m = $p(f, o, p);
      return p === m && typeof p == "string" && (m = $p(f, o, `${t}${p === "default" ? "" : Sn(p)}`, p)), n === !1 ? m : {
        [n]: m
      };
    });
  };
  return a.propTypes = {}, a.filterProps = [t], a;
}
function Yee(e) {
  const t = {};
  return (n) => (t[n] === void 0 && (t[n] = e(n)), t[n]);
}
const qee = {
  m: "margin",
  p: "padding"
}, Xee = {
  t: "Top",
  r: "Right",
  b: "Bottom",
  l: "Left",
  x: ["Left", "Right"],
  y: ["Top", "Bottom"]
}, x5 = {
  marginX: "mx",
  marginY: "my",
  paddingX: "px",
  paddingY: "py"
}, Gee = Yee((e) => {
  if (e.length > 2)
    if (x5[e])
      e = x5[e];
    else
      return [e];
  const [t, n] = e.split(""), r = qee[t], o = Xee[n] || "";
  return Array.isArray(o) ? o.map((a) => r + a) : [r + o];
}), zx = ["m", "mt", "mr", "mb", "ml", "mx", "my", "margin", "marginTop", "marginRight", "marginBottom", "marginLeft", "marginX", "marginY", "marginInline", "marginInlineStart", "marginInlineEnd", "marginBlock", "marginBlockStart", "marginBlockEnd"], Px = ["p", "pt", "pr", "pb", "pl", "px", "py", "padding", "paddingTop", "paddingRight", "paddingBottom", "paddingLeft", "paddingX", "paddingY", "paddingInline", "paddingInlineStart", "paddingInlineEnd", "paddingBlock", "paddingBlockStart", "paddingBlockEnd"];
[...zx, ...Px];
function Wc(e, t, n, r) {
  const o = $h(e, t, !0) ?? n;
  return typeof o == "number" || typeof o == "string" ? (a) => typeof a == "string" ? a : typeof o == "string" ? o.startsWith("var(") && a === 0 ? 0 : o.startsWith("var(") && a === 1 ? o : `calc(${a} * ${o})` : o * a : Array.isArray(o) ? (a) => {
    if (typeof a == "string")
      return a;
    const l = Math.abs(a), u = o[l];
    return a >= 0 ? u : typeof u == "number" ? -u : typeof u == "string" && u.startsWith("var(") ? `calc(-1 * ${u})` : `-${u}`;
  } : typeof o == "function" ? o : () => {
  };
}
function Lx(e) {
  return Wc(e, "spacing", 8);
}
function Kc(e, t) {
  return typeof t == "string" || t == null ? t : e(t);
}
function Zee(e, t) {
  return (n) => e.reduce((r, o) => (r[o] = Kc(t, n), r), {});
}
function Wee(e, t, n, r) {
  if (!t.includes(n))
    return null;
  const o = Gee(n), a = Zee(o, r), l = e[n];
  return Go(e, l, a);
}
function lj(e, t) {
  const n = Lx(e.theme);
  return Object.keys(e).map((r) => Wee(e, t, r, n)).reduce(rc, {});
}
function Nt(e) {
  return lj(e, zx);
}
Nt.propTypes = {};
Nt.filterProps = zx;
function Mt(e) {
  return lj(e, Px);
}
Mt.propTypes = {};
Mt.filterProps = Px;
function Yh(...e) {
  const t = e.reduce((r, o) => (o.filterProps.forEach((a) => {
    r[a] = o;
  }), r), {}), n = (r) => Object.keys(r).reduce((o, a) => t[a] ? rc(o, t[a](r)) : o, {});
  return n.propTypes = {}, n.filterProps = e.reduce((r, o) => r.concat(o.filterProps), []), n;
}
function mr(e) {
  return typeof e != "number" ? e : `${e}px solid`;
}
function vr(e, t) {
  return zt({
    prop: e,
    themeKey: "borders",
    transform: t
  });
}
const Kee = vr("border", mr), Qee = vr("borderTop", mr), Jee = vr("borderRight", mr), ete = vr("borderBottom", mr), tte = vr("borderLeft", mr), nte = vr("borderColor"), rte = vr("borderTopColor"), ote = vr("borderRightColor"), ite = vr("borderBottomColor"), ate = vr("borderLeftColor"), lte = vr("outline", mr), ste = vr("outlineColor"), qh = (e) => {
  if (e.borderRadius !== void 0 && e.borderRadius !== null) {
    const t = Wc(e.theme, "shape.borderRadius", 4), n = (r) => ({
      borderRadius: Kc(t, r)
    });
    return Go(e, e.borderRadius, n);
  }
  return null;
};
qh.propTypes = {};
qh.filterProps = ["borderRadius"];
Yh(Kee, Qee, Jee, ete, tte, nte, rte, ote, ite, ate, qh, lte, ste);
const Xh = (e) => {
  if (e.gap !== void 0 && e.gap !== null) {
    const t = Wc(e.theme, "spacing", 8), n = (r) => ({
      gap: Kc(t, r)
    });
    return Go(e, e.gap, n);
  }
  return null;
};
Xh.propTypes = {};
Xh.filterProps = ["gap"];
const Gh = (e) => {
  if (e.columnGap !== void 0 && e.columnGap !== null) {
    const t = Wc(e.theme, "spacing", 8), n = (r) => ({
      columnGap: Kc(t, r)
    });
    return Go(e, e.columnGap, n);
  }
  return null;
};
Gh.propTypes = {};
Gh.filterProps = ["columnGap"];
const Zh = (e) => {
  if (e.rowGap !== void 0 && e.rowGap !== null) {
    const t = Wc(e.theme, "spacing", 8), n = (r) => ({
      rowGap: Kc(t, r)
    });
    return Go(e, e.rowGap, n);
  }
  return null;
};
Zh.propTypes = {};
Zh.filterProps = ["rowGap"];
const ute = zt({
  prop: "gridColumn"
}), cte = zt({
  prop: "gridRow"
}), dte = zt({
  prop: "gridAutoFlow"
}), fte = zt({
  prop: "gridAutoColumns"
}), pte = zt({
  prop: "gridAutoRows"
}), hte = zt({
  prop: "gridTemplateColumns"
}), mte = zt({
  prop: "gridTemplateRows"
}), gte = zt({
  prop: "gridTemplateAreas"
}), yte = zt({
  prop: "gridArea"
});
Yh(Xh, Gh, Zh, ute, cte, dte, fte, pte, hte, mte, gte, yte);
function Jl(e, t) {
  return t === "grey" ? t : e;
}
const vte = zt({
  prop: "color",
  themeKey: "palette",
  transform: Jl
}), bte = zt({
  prop: "bgcolor",
  cssProperty: "backgroundColor",
  themeKey: "palette",
  transform: Jl
}), wte = zt({
  prop: "backgroundColor",
  themeKey: "palette",
  transform: Jl
});
Yh(vte, bte, wte);
function Kn(e) {
  return e <= 1 && e !== 0 ? `${e * 100}%` : e;
}
const xte = zt({
  prop: "width",
  transform: Kn
}), Ix = (e) => {
  if (e.maxWidth !== void 0 && e.maxWidth !== null) {
    const t = (n) => {
      var r, o, a, l, u;
      const d = ((a = (o = (r = e.theme) == null ? void 0 : r.breakpoints) == null ? void 0 : o.values) == null ? void 0 : a[n]) || Fh[n];
      return d ? ((u = (l = e.theme) == null ? void 0 : l.breakpoints) == null ? void 0 : u.unit) !== "px" ? {
        maxWidth: `${d}${e.theme.breakpoints.unit}`
      } : {
        maxWidth: d
      } : {
        maxWidth: Kn(n)
      };
    };
    return Go(e, e.maxWidth, t);
  }
  return null;
};
Ix.filterProps = ["maxWidth"];
const Ste = zt({
  prop: "minWidth",
  transform: Kn
}), kte = zt({
  prop: "height",
  transform: Kn
}), _te = zt({
  prop: "maxHeight",
  transform: Kn
}), Ete = zt({
  prop: "minHeight",
  transform: Kn
});
zt({
  prop: "size",
  cssProperty: "width",
  transform: Kn
});
zt({
  prop: "size",
  cssProperty: "height",
  transform: Kn
});
const Cte = zt({
  prop: "boxSizing"
});
Yh(xte, Ix, Ste, kte, _te, Ete, Cte);
const Wh = {
  // borders
  border: {
    themeKey: "borders",
    transform: mr
  },
  borderTop: {
    themeKey: "borders",
    transform: mr
  },
  borderRight: {
    themeKey: "borders",
    transform: mr
  },
  borderBottom: {
    themeKey: "borders",
    transform: mr
  },
  borderLeft: {
    themeKey: "borders",
    transform: mr
  },
  borderColor: {
    themeKey: "palette"
  },
  borderTopColor: {
    themeKey: "palette"
  },
  borderRightColor: {
    themeKey: "palette"
  },
  borderBottomColor: {
    themeKey: "palette"
  },
  borderLeftColor: {
    themeKey: "palette"
  },
  outline: {
    themeKey: "borders",
    transform: mr
  },
  outlineColor: {
    themeKey: "palette"
  },
  borderRadius: {
    themeKey: "shape.borderRadius",
    style: qh
  },
  // palette
  color: {
    themeKey: "palette",
    transform: Jl
  },
  bgcolor: {
    themeKey: "palette",
    cssProperty: "backgroundColor",
    transform: Jl
  },
  backgroundColor: {
    themeKey: "palette",
    transform: Jl
  },
  // spacing
  p: {
    style: Mt
  },
  pt: {
    style: Mt
  },
  pr: {
    style: Mt
  },
  pb: {
    style: Mt
  },
  pl: {
    style: Mt
  },
  px: {
    style: Mt
  },
  py: {
    style: Mt
  },
  padding: {
    style: Mt
  },
  paddingTop: {
    style: Mt
  },
  paddingRight: {
    style: Mt
  },
  paddingBottom: {
    style: Mt
  },
  paddingLeft: {
    style: Mt
  },
  paddingX: {
    style: Mt
  },
  paddingY: {
    style: Mt
  },
  paddingInline: {
    style: Mt
  },
  paddingInlineStart: {
    style: Mt
  },
  paddingInlineEnd: {
    style: Mt
  },
  paddingBlock: {
    style: Mt
  },
  paddingBlockStart: {
    style: Mt
  },
  paddingBlockEnd: {
    style: Mt
  },
  m: {
    style: Nt
  },
  mt: {
    style: Nt
  },
  mr: {
    style: Nt
  },
  mb: {
    style: Nt
  },
  ml: {
    style: Nt
  },
  mx: {
    style: Nt
  },
  my: {
    style: Nt
  },
  margin: {
    style: Nt
  },
  marginTop: {
    style: Nt
  },
  marginRight: {
    style: Nt
  },
  marginBottom: {
    style: Nt
  },
  marginLeft: {
    style: Nt
  },
  marginX: {
    style: Nt
  },
  marginY: {
    style: Nt
  },
  marginInline: {
    style: Nt
  },
  marginInlineStart: {
    style: Nt
  },
  marginInlineEnd: {
    style: Nt
  },
  marginBlock: {
    style: Nt
  },
  marginBlockStart: {
    style: Nt
  },
  marginBlockEnd: {
    style: Nt
  },
  // display
  displayPrint: {
    cssProperty: !1,
    transform: (e) => ({
      "@media print": {
        display: e
      }
    })
  },
  display: {},
  overflow: {},
  textOverflow: {},
  visibility: {},
  whiteSpace: {},
  // flexbox
  flexBasis: {},
  flexDirection: {},
  flexWrap: {},
  justifyContent: {},
  alignItems: {},
  alignContent: {},
  order: {},
  flex: {},
  flexGrow: {},
  flexShrink: {},
  alignSelf: {},
  justifyItems: {},
  justifySelf: {},
  // grid
  gap: {
    style: Xh
  },
  rowGap: {
    style: Zh
  },
  columnGap: {
    style: Gh
  },
  gridColumn: {},
  gridRow: {},
  gridAutoFlow: {},
  gridAutoColumns: {},
  gridAutoRows: {},
  gridTemplateColumns: {},
  gridTemplateRows: {},
  gridTemplateAreas: {},
  gridArea: {},
  // positions
  position: {},
  zIndex: {
    themeKey: "zIndex"
  },
  top: {},
  right: {},
  bottom: {},
  left: {},
  // shadows
  boxShadow: {
    themeKey: "shadows"
  },
  // sizing
  width: {
    transform: Kn
  },
  maxWidth: {
    style: Ix
  },
  minWidth: {
    transform: Kn
  },
  height: {
    transform: Kn
  },
  maxHeight: {
    transform: Kn
  },
  minHeight: {
    transform: Kn
  },
  boxSizing: {},
  // typography
  font: {
    themeKey: "font"
  },
  fontFamily: {
    themeKey: "typography"
  },
  fontSize: {
    themeKey: "typography"
  },
  fontStyle: {
    themeKey: "typography"
  },
  fontWeight: {
    themeKey: "typography"
  },
  letterSpacing: {},
  textTransform: {},
  lineHeight: {},
  textAlign: {},
  typography: {
    cssProperty: !1,
    themeKey: "typography"
  }
};
function Ote(...e) {
  const t = e.reduce((r, o) => r.concat(Object.keys(o)), []), n = new Set(t);
  return e.every((r) => n.size === Object.keys(r).length);
}
function Nte(e, t) {
  return typeof e == "function" ? e(t) : e;
}
function Mte() {
  function e(n, r, o, a) {
    const l = {
      [n]: r,
      theme: o
    }, u = a[n];
    if (!u)
      return {
        [n]: r
      };
    const {
      cssProperty: d = n,
      themeKey: f,
      transform: p,
      style: m
    } = u;
    if (r == null)
      return null;
    if (f === "typography" && r === "inherit")
      return {
        [n]: r
      };
    const g = $h(o, f) || {};
    return m ? m(l) : Go(l, r, (y) => {
      let w = $p(g, p, y);
      return y === w && typeof y == "string" && (w = $p(g, p, `${n}${y === "default" ? "" : Sn(y)}`, y)), d === !1 ? w : {
        [d]: w
      };
    });
  }
  function t(n) {
    const {
      sx: r,
      theme: o = {}
    } = n || {};
    if (!r)
      return null;
    const a = o.unstable_sxConfig ?? Wh;
    function l(u) {
      let d = u;
      if (typeof u == "function")
        d = u(o);
      else if (typeof u != "object")
        return u;
      if (!d)
        return null;
      const f = Fee(o.breakpoints), p = Object.keys(f);
      let m = f;
      return Object.keys(d).forEach((g) => {
        const y = Nte(d[g], o);
        if (y != null)
          if (typeof y == "object")
            if (a[g])
              m = rc(m, e(g, y, o, a));
            else {
              const w = Go({
                theme: o
              }, y, (v) => ({
                [g]: v
              }));
              Ote(w, y) ? m[g] = t({
                sx: y,
                theme: o
              }) : m = rc(m, w);
            }
          else
            m = rc(m, e(g, y, o, a));
      }), Iee(o, $ee(p, m));
    }
    return Array.isArray(r) ? r.map(l) : l(r);
  }
  return t;
}
const ps = Mte();
ps.filterProps = ["sx"];
function Ne() {
  return Ne = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var r in n) ({}).hasOwnProperty.call(n, r) && (e[r] = n[r]);
    }
    return e;
  }, Ne.apply(null, arguments);
}
function Ate(e) {
  if (e.sheet)
    return e.sheet;
  for (var t = 0; t < document.styleSheets.length; t++)
    if (document.styleSheets[t].ownerNode === e)
      return document.styleSheets[t];
}
function Rte(e) {
  var t = document.createElement("style");
  return t.setAttribute("data-emotion", e.key), e.nonce !== void 0 && t.setAttribute("nonce", e.nonce), t.appendChild(document.createTextNode("")), t.setAttribute("data-s", ""), t;
}
var jte = /* @__PURE__ */ function() {
  function e(n) {
    var r = this;
    this._insertTag = function(o) {
      var a;
      r.tags.length === 0 ? r.insertionPoint ? a = r.insertionPoint.nextSibling : r.prepend ? a = r.container.firstChild : a = r.before : a = r.tags[r.tags.length - 1].nextSibling, r.container.insertBefore(o, a), r.tags.push(o);
    }, this.isSpeedy = n.speedy === void 0 ? !0 : n.speedy, this.tags = [], this.ctr = 0, this.nonce = n.nonce, this.key = n.key, this.container = n.container, this.prepend = n.prepend, this.insertionPoint = n.insertionPoint, this.before = null;
  }
  var t = e.prototype;
  return t.hydrate = function(n) {
    n.forEach(this._insertTag);
  }, t.insert = function(n) {
    this.ctr % (this.isSpeedy ? 65e3 : 1) === 0 && this._insertTag(Rte(this));
    var r = this.tags[this.tags.length - 1];
    if (this.isSpeedy) {
      var o = Ate(r);
      try {
        o.insertRule(n, o.cssRules.length);
      } catch {
      }
    } else
      r.appendChild(document.createTextNode(n));
    this.ctr++;
  }, t.flush = function() {
    this.tags.forEach(function(n) {
      var r;
      return (r = n.parentNode) == null ? void 0 : r.removeChild(n);
    }), this.tags = [], this.ctr = 0;
  }, e;
}(), fn = "-ms-", Yp = "-moz-", et = "-webkit-", sj = "comm", Bx = "rule", Vx = "decl", Dte = "@import", uj = "@keyframes", Tte = "@layer", zte = Math.abs, Kh = String.fromCharCode, Pte = Object.assign;
function Lte(e, t) {
  return ln(e, 0) ^ 45 ? (((t << 2 ^ ln(e, 0)) << 2 ^ ln(e, 1)) << 2 ^ ln(e, 2)) << 2 ^ ln(e, 3) : 0;
}
function cj(e) {
  return e.trim();
}
function Ite(e, t) {
  return (e = t.exec(e)) ? e[0] : e;
}
function tt(e, t, n) {
  return e.replace(t, n);
}
function Hb(e, t) {
  return e.indexOf(t);
}
function ln(e, t) {
  return e.charCodeAt(t) | 0;
}
function kc(e, t, n) {
  return e.slice(t, n);
}
function Kr(e) {
  return e.length;
}
function Hx(e) {
  return e.length;
}
function Vf(e, t) {
  return t.push(e), e;
}
function Bte(e, t) {
  return e.map(t).join("");
}
var Qh = 1, hs = 1, dj = 0, Ln = 0, qt = 0, _s = "";
function Jh(e, t, n, r, o, a, l) {
  return { value: e, root: t, parent: n, type: r, props: o, children: a, line: Qh, column: hs, length: l, return: "" };
}
function Vu(e, t) {
  return Pte(Jh("", null, null, "", null, null, 0), e, { length: -e.length }, t);
}
function Vte() {
  return qt;
}
function Hte() {
  return qt = Ln > 0 ? ln(_s, --Ln) : 0, hs--, qt === 10 && (hs = 1, Qh--), qt;
}
function nr() {
  return qt = Ln < dj ? ln(_s, Ln++) : 0, hs++, qt === 10 && (hs = 1, Qh++), qt;
}
function oo() {
  return ln(_s, Ln);
}
function cp() {
  return Ln;
}
function Qc(e, t) {
  return kc(_s, e, t);
}
function _c(e) {
  switch (e) {
    // \0 \t \n \r \s whitespace token
    case 0:
    case 9:
    case 10:
    case 13:
    case 32:
      return 5;
    // ! + , / > @ ~ isolate token
    case 33:
    case 43:
    case 44:
    case 47:
    case 62:
    case 64:
    case 126:
    // ; { } breakpoint token
    case 59:
    case 123:
    case 125:
      return 4;
    // : accompanied token
    case 58:
      return 3;
    // " ' ( [ opening delimit token
    case 34:
    case 39:
    case 40:
    case 91:
      return 2;
    // ) ] closing delimit token
    case 41:
    case 93:
      return 1;
  }
  return 0;
}
function fj(e) {
  return Qh = hs = 1, dj = Kr(_s = e), Ln = 0, [];
}
function pj(e) {
  return _s = "", e;
}
function dp(e) {
  return cj(Qc(Ln - 1, Ub(e === 91 ? e + 2 : e === 40 ? e + 1 : e)));
}
function Ute(e) {
  for (; (qt = oo()) && qt < 33; )
    nr();
  return _c(e) > 2 || _c(qt) > 3 ? "" : " ";
}
function Fte(e, t) {
  for (; --t && nr() && !(qt < 48 || qt > 102 || qt > 57 && qt < 65 || qt > 70 && qt < 97); )
    ;
  return Qc(e, cp() + (t < 6 && oo() == 32 && nr() == 32));
}
function Ub(e) {
  for (; nr(); )
    switch (qt) {
      // ] ) " '
      case e:
        return Ln;
      // " '
      case 34:
      case 39:
        e !== 34 && e !== 39 && Ub(qt);
        break;
      // (
      case 40:
        e === 41 && Ub(e);
        break;
      // \
      case 92:
        nr();
        break;
    }
  return Ln;
}
function $te(e, t) {
  for (; nr() && e + qt !== 57 && !(e + qt === 84 && oo() === 47); )
    ;
  return "/*" + Qc(t, Ln - 1) + "*" + Kh(e === 47 ? e : nr());
}
function Yte(e) {
  for (; !_c(oo()); )
    nr();
  return Qc(e, Ln);
}
function qte(e) {
  return pj(fp("", null, null, null, [""], e = fj(e), 0, [0], e));
}
function fp(e, t, n, r, o, a, l, u, d) {
  for (var f = 0, p = 0, m = l, g = 0, y = 0, w = 0, v = 1, x = 1, E = 1, N = 0, C = "", A = o, R = a, D = r, T = C; x; )
    switch (w = N, N = nr()) {
      // (
      case 40:
        if (w != 108 && ln(T, m - 1) == 58) {
          Hb(T += tt(dp(N), "&", "&\f"), "&\f") != -1 && (E = -1);
          break;
        }
      // " ' [
      case 34:
      case 39:
      case 91:
        T += dp(N);
        break;
      // \t \n \r \s
      case 9:
      case 10:
      case 13:
      case 32:
        T += Ute(w);
        break;
      // \
      case 92:
        T += Fte(cp() - 1, 7);
        continue;
      // /
      case 47:
        switch (oo()) {
          case 42:
          case 47:
            Vf(Xte($te(nr(), cp()), t, n), d);
            break;
          default:
            T += "/";
        }
        break;
      // {
      case 123 * v:
        u[f++] = Kr(T) * E;
      // } ; \0
      case 125 * v:
      case 59:
      case 0:
        switch (N) {
          // \0 }
          case 0:
          case 125:
            x = 0;
          // ;
          case 59 + p:
            E == -1 && (T = tt(T, /\f/g, "")), y > 0 && Kr(T) - m && Vf(y > 32 ? k5(T + ";", r, n, m - 1) : k5(tt(T, " ", "") + ";", r, n, m - 2), d);
            break;
          // @ ;
          case 59:
            T += ";";
          // { rule/at-rule
          default:
            if (Vf(D = S5(T, t, n, f, p, o, u, C, A = [], R = [], m), a), N === 123)
              if (p === 0)
                fp(T, t, D, D, A, a, m, u, R);
              else
                switch (g === 99 && ln(T, 3) === 110 ? 100 : g) {
                  // d l m s
                  case 100:
                  case 108:
                  case 109:
                  case 115:
                    fp(e, D, D, r && Vf(S5(e, D, D, 0, 0, o, u, C, o, A = [], m), R), o, R, m, u, r ? A : R);
                    break;
                  default:
                    fp(T, D, D, D, [""], R, 0, u, R);
                }
        }
        f = p = y = 0, v = E = 1, C = T = "", m = l;
        break;
      // :
      case 58:
        m = 1 + Kr(T), y = w;
      default:
        if (v < 1) {
          if (N == 123)
            --v;
          else if (N == 125 && v++ == 0 && Hte() == 125)
            continue;
        }
        switch (T += Kh(N), N * v) {
          // &
          case 38:
            E = p > 0 ? 1 : (T += "\f", -1);
            break;
          // ,
          case 44:
            u[f++] = (Kr(T) - 1) * E, E = 1;
            break;
          // @
          case 64:
            oo() === 45 && (T += dp(nr())), g = oo(), p = m = Kr(C = T += Yte(cp())), N++;
            break;
          // -
          case 45:
            w === 45 && Kr(T) == 2 && (v = 0);
        }
    }
  return a;
}
function S5(e, t, n, r, o, a, l, u, d, f, p) {
  for (var m = o - 1, g = o === 0 ? a : [""], y = Hx(g), w = 0, v = 0, x = 0; w < r; ++w)
    for (var E = 0, N = kc(e, m + 1, m = zte(v = l[w])), C = e; E < y; ++E)
      (C = cj(v > 0 ? g[E] + " " + N : tt(N, /&\f/g, g[E]))) && (d[x++] = C);
  return Jh(e, t, n, o === 0 ? Bx : u, d, f, p);
}
function Xte(e, t, n) {
  return Jh(e, t, n, sj, Kh(Vte()), kc(e, 2, -2), 0);
}
function k5(e, t, n, r) {
  return Jh(e, t, n, Vx, kc(e, 0, r), kc(e, r + 1, -1), r);
}
function es(e, t) {
  for (var n = "", r = Hx(e), o = 0; o < r; o++)
    n += t(e[o], o, e, t) || "";
  return n;
}
function Gte(e, t, n, r) {
  switch (e.type) {
    case Tte:
      if (e.children.length) break;
    case Dte:
    case Vx:
      return e.return = e.return || e.value;
    case sj:
      return "";
    case uj:
      return e.return = e.value + "{" + es(e.children, r) + "}";
    case Bx:
      e.value = e.props.join(",");
  }
  return Kr(n = es(e.children, r)) ? e.return = e.value + "{" + n + "}" : "";
}
function Zte(e) {
  var t = Hx(e);
  return function(n, r, o, a) {
    for (var l = "", u = 0; u < t; u++)
      l += e[u](n, r, o, a) || "";
    return l;
  };
}
function Wte(e) {
  return function(t) {
    t.root || (t = t.return) && e(t);
  };
}
function hj(e) {
  var t = /* @__PURE__ */ Object.create(null);
  return function(n) {
    return t[n] === void 0 && (t[n] = e(n)), t[n];
  };
}
var Kte = function(e, t, n) {
  for (var r = 0, o = 0; r = o, o = oo(), r === 38 && o === 12 && (t[n] = 1), !_c(o); )
    nr();
  return Qc(e, Ln);
}, Qte = function(e, t) {
  var n = -1, r = 44;
  do
    switch (_c(r)) {
      case 0:
        r === 38 && oo() === 12 && (t[n] = 1), e[n] += Kte(Ln - 1, t, n);
        break;
      case 2:
        e[n] += dp(r);
        break;
      case 4:
        if (r === 44) {
          e[++n] = oo() === 58 ? "&\f" : "", t[n] = e[n].length;
          break;
        }
      // fallthrough
      default:
        e[n] += Kh(r);
    }
  while (r = nr());
  return e;
}, Jte = function(e, t) {
  return pj(Qte(fj(e), t));
}, _5 = /* @__PURE__ */ new WeakMap(), ene = function(e) {
  if (!(e.type !== "rule" || !e.parent || // positive .length indicates that this rule contains pseudo
  // negative .length indicates that this rule has been already prefixed
  e.length < 1)) {
    for (var t = e.value, n = e.parent, r = e.column === n.column && e.line === n.line; n.type !== "rule"; )
      if (n = n.parent, !n) return;
    if (!(e.props.length === 1 && t.charCodeAt(0) !== 58 && !_5.get(n)) && !r) {
      _5.set(e, !0);
      for (var o = [], a = Jte(t, o), l = n.props, u = 0, d = 0; u < a.length; u++)
        for (var f = 0; f < l.length; f++, d++)
          e.props[d] = o[u] ? a[u].replace(/&\f/g, l[f]) : l[f] + " " + a[u];
    }
  }
}, tne = function(e) {
  if (e.type === "decl") {
    var t = e.value;
    t.charCodeAt(0) === 108 && // charcode for b
    t.charCodeAt(2) === 98 && (e.return = "", e.value = "");
  }
};
function mj(e, t) {
  switch (Lte(e, t)) {
    // color-adjust
    case 5103:
      return et + "print-" + e + e;
    // animation, animation-(delay|direction|duration|fill-mode|iteration-count|name|play-state|timing-function)
    case 5737:
    case 4201:
    case 3177:
    case 3433:
    case 1641:
    case 4457:
    case 2921:
    // text-decoration, filter, clip-path, backface-visibility, column, box-decoration-break
    case 5572:
    case 6356:
    case 5844:
    case 3191:
    case 6645:
    case 3005:
    // mask, mask-image, mask-(mode|clip|size), mask-(repeat|origin), mask-position, mask-composite,
    case 6391:
    case 5879:
    case 5623:
    case 6135:
    case 4599:
    case 4855:
    // background-clip, columns, column-(count|fill|gap|rule|rule-color|rule-style|rule-width|span|width)
    case 4215:
    case 6389:
    case 5109:
    case 5365:
    case 5621:
    case 3829:
      return et + e + e;
    // appearance, user-select, transform, hyphens, text-size-adjust
    case 5349:
    case 4246:
    case 4810:
    case 6968:
    case 2756:
      return et + e + Yp + e + fn + e + e;
    // flex, flex-direction
    case 6828:
    case 4268:
      return et + e + fn + e + e;
    // order
    case 6165:
      return et + e + fn + "flex-" + e + e;
    // align-items
    case 5187:
      return et + e + tt(e, /(\w+).+(:[^]+)/, et + "box-$1$2" + fn + "flex-$1$2") + e;
    // align-self
    case 5443:
      return et + e + fn + "flex-item-" + tt(e, /flex-|-self/, "") + e;
    // align-content
    case 4675:
      return et + e + fn + "flex-line-pack" + tt(e, /align-content|flex-|-self/, "") + e;
    // flex-shrink
    case 5548:
      return et + e + fn + tt(e, "shrink", "negative") + e;
    // flex-basis
    case 5292:
      return et + e + fn + tt(e, "basis", "preferred-size") + e;
    // flex-grow
    case 6060:
      return et + "box-" + tt(e, "-grow", "") + et + e + fn + tt(e, "grow", "positive") + e;
    // transition
    case 4554:
      return et + tt(e, /([^-])(transform)/g, "$1" + et + "$2") + e;
    // cursor
    case 6187:
      return tt(tt(tt(e, /(zoom-|grab)/, et + "$1"), /(image-set)/, et + "$1"), e, "") + e;
    // background, background-image
    case 5495:
    case 3959:
      return tt(e, /(image-set\([^]*)/, et + "$1$`$1");
    // justify-content
    case 4968:
      return tt(tt(e, /(.+:)(flex-)?(.*)/, et + "box-pack:$3" + fn + "flex-pack:$3"), /s.+-b[^;]+/, "justify") + et + e + e;
    // (margin|padding)-inline-(start|end)
    case 4095:
    case 3583:
    case 4068:
    case 2532:
      return tt(e, /(.+)-inline(.+)/, et + "$1$2") + e;
    // (min|max)?(width|height|inline-size|block-size)
    case 8116:
    case 7059:
    case 5753:
    case 5535:
    case 5445:
    case 5701:
    case 4933:
    case 4677:
    case 5533:
    case 5789:
    case 5021:
    case 4765:
      if (Kr(e) - 1 - t > 6) switch (ln(e, t + 1)) {
        // (m)ax-content, (m)in-content
        case 109:
          if (ln(e, t + 4) !== 45) break;
        // (f)ill-available, (f)it-content
        case 102:
          return tt(e, /(.+:)(.+)-([^]+)/, "$1" + et + "$2-$3$1" + Yp + (ln(e, t + 3) == 108 ? "$3" : "$2-$3")) + e;
        // (s)tretch
        case 115:
          return ~Hb(e, "stretch") ? mj(tt(e, "stretch", "fill-available"), t) + e : e;
      }
      break;
    // position: sticky
    case 4949:
      if (ln(e, t + 1) !== 115) break;
    // display: (flex|inline-flex)
    case 6444:
      switch (ln(e, Kr(e) - 3 - (~Hb(e, "!important") && 10))) {
        // stic(k)y
        case 107:
          return tt(e, ":", ":" + et) + e;
        // (inline-)?fl(e)x
        case 101:
          return tt(e, /(.+:)([^;!]+)(;|!.+)?/, "$1" + et + (ln(e, 14) === 45 ? "inline-" : "") + "box$3$1" + et + "$2$3$1" + fn + "$2box$3") + e;
      }
      break;
    // writing-mode
    case 5936:
      switch (ln(e, t + 11)) {
        // vertical-l(r)
        case 114:
          return et + e + fn + tt(e, /[svh]\w+-[tblr]{2}/, "tb") + e;
        // vertical-r(l)
        case 108:
          return et + e + fn + tt(e, /[svh]\w+-[tblr]{2}/, "tb-rl") + e;
        // horizontal(-)tb
        case 45:
          return et + e + fn + tt(e, /[svh]\w+-[tblr]{2}/, "lr") + e;
      }
      return et + e + fn + e + e;
  }
  return e;
}
var nne = function(e, t, n, r) {
  if (e.length > -1 && !e.return) switch (e.type) {
    case Vx:
      e.return = mj(e.value, e.length);
      break;
    case uj:
      return es([Vu(e, {
        value: tt(e.value, "@", "@" + et)
      })], r);
    case Bx:
      if (e.length) return Bte(e.props, function(o) {
        switch (Ite(o, /(::plac\w+|:read-\w+)/)) {
          // :read-(only|write)
          case ":read-only":
          case ":read-write":
            return es([Vu(e, {
              props: [tt(o, /:(read-\w+)/, ":" + Yp + "$1")]
            })], r);
          // :placeholder
          case "::placeholder":
            return es([Vu(e, {
              props: [tt(o, /:(plac\w+)/, ":" + et + "input-$1")]
            }), Vu(e, {
              props: [tt(o, /:(plac\w+)/, ":" + Yp + "$1")]
            }), Vu(e, {
              props: [tt(o, /:(plac\w+)/, fn + "input-$1")]
            })], r);
        }
        return "";
      });
  }
}, rne = [nne], one = function(e) {
  var t = e.key;
  if (t === "css") {
    var n = document.querySelectorAll("style[data-emotion]:not([data-s])");
    Array.prototype.forEach.call(n, function(w) {
      var v = w.getAttribute("data-emotion");
      v.indexOf(" ") !== -1 && (document.head.appendChild(w), w.setAttribute("data-s", ""));
    });
  }
  var r = e.stylisPlugins || rne, o = {}, a, l = [];
  a = e.container || document.head, Array.prototype.forEach.call(
    // this means we will ignore elements which don't have a space in them which
    // means that the style elements we're looking at are only Emotion 11 server-rendered style elements
    document.querySelectorAll('style[data-emotion^="' + t + ' "]'),
    function(w) {
      for (var v = w.getAttribute("data-emotion").split(" "), x = 1; x < v.length; x++)
        o[v[x]] = !0;
      l.push(w);
    }
  );
  var u, d = [ene, tne];
  {
    var f, p = [Gte, Wte(function(w) {
      f.insert(w);
    })], m = Zte(d.concat(r, p)), g = function(w) {
      return es(qte(w), m);
    };
    u = function(w, v, x, E) {
      f = x, g(w ? w + "{" + v.styles + "}" : v.styles), E && (y.inserted[v.name] = !0);
    };
  }
  var y = {
    key: t,
    sheet: new jte({
      key: t,
      container: a,
      nonce: e.nonce,
      speedy: e.speedy,
      prepend: e.prepend,
      insertionPoint: e.insertionPoint
    }),
    nonce: e.nonce,
    inserted: o,
    registered: {},
    insert: u
  };
  return y.sheet.hydrate(l), y;
}, kv, E5;
function ine() {
  if (E5) return kv;
  E5 = 1;
  var e = QF(), t = {
    childContextTypes: !0,
    contextType: !0,
    contextTypes: !0,
    defaultProps: !0,
    displayName: !0,
    getDefaultProps: !0,
    getDerivedStateFromError: !0,
    getDerivedStateFromProps: !0,
    mixins: !0,
    propTypes: !0,
    type: !0
  }, n = {
    name: !0,
    length: !0,
    prototype: !0,
    caller: !0,
    callee: !0,
    arguments: !0,
    arity: !0
  }, r = {
    $$typeof: !0,
    render: !0,
    defaultProps: !0,
    displayName: !0,
    propTypes: !0
  }, o = {
    $$typeof: !0,
    compare: !0,
    defaultProps: !0,
    displayName: !0,
    propTypes: !0,
    type: !0
  }, a = {};
  a[e.ForwardRef] = r, a[e.Memo] = o;
  function l(w) {
    return e.isMemo(w) ? o : a[w.$$typeof] || t;
  }
  var u = Object.defineProperty, d = Object.getOwnPropertyNames, f = Object.getOwnPropertySymbols, p = Object.getOwnPropertyDescriptor, m = Object.getPrototypeOf, g = Object.prototype;
  function y(w, v, x) {
    if (typeof v != "string") {
      if (g) {
        var E = m(v);
        E && E !== g && y(w, E, x);
      }
      var N = d(v);
      f && (N = N.concat(f(v)));
      for (var C = l(w), A = l(v), R = 0; R < N.length; ++R) {
        var D = N[R];
        if (!n[D] && !(x && x[D]) && !(A && A[D]) && !(C && C[D])) {
          var T = p(v, D);
          try {
            u(w, D, T);
          } catch {
          }
        }
      }
    }
    return w;
  }
  return kv = y, kv;
}
ine();
var ane = !0;
function gj(e, t, n) {
  var r = "";
  return n.split(" ").forEach(function(o) {
    e[o] !== void 0 ? t.push(e[o] + ";") : o && (r += o + " ");
  }), r;
}
var Ux = function(e, t, n) {
  var r = e.key + "-" + t.name;
  (n === !1 || // we need to always store it if we're in compat mode and
  // in node since emotion-server relies on whether a style is in
  // the registered cache to know whether a style is global or not
  // also, note that this check will be dead code eliminated in the browser
  ane === !1) && e.registered[r] === void 0 && (e.registered[r] = t.styles);
}, yj = function(e, t, n) {
  Ux(e, t, n);
  var r = e.key + "-" + t.name;
  if (e.inserted[t.name] === void 0) {
    var o = t;
    do
      e.insert(t === o ? "." + r : "", o, e.sheet, !0), o = o.next;
    while (o !== void 0);
  }
};
function lne(e) {
  for (var t = 0, n, r = 0, o = e.length; o >= 4; ++r, o -= 4)
    n = e.charCodeAt(r) & 255 | (e.charCodeAt(++r) & 255) << 8 | (e.charCodeAt(++r) & 255) << 16 | (e.charCodeAt(++r) & 255) << 24, n = /* Math.imul(k, m): */
    (n & 65535) * 1540483477 + ((n >>> 16) * 59797 << 16), n ^= /* k >>> r: */
    n >>> 24, t = /* Math.imul(k, m): */
    (n & 65535) * 1540483477 + ((n >>> 16) * 59797 << 16) ^ /* Math.imul(h, m): */
    (t & 65535) * 1540483477 + ((t >>> 16) * 59797 << 16);
  switch (o) {
    case 3:
      t ^= (e.charCodeAt(r + 2) & 255) << 16;
    case 2:
      t ^= (e.charCodeAt(r + 1) & 255) << 8;
    case 1:
      t ^= e.charCodeAt(r) & 255, t = /* Math.imul(h, m): */
      (t & 65535) * 1540483477 + ((t >>> 16) * 59797 << 16);
  }
  return t ^= t >>> 13, t = /* Math.imul(h, m): */
  (t & 65535) * 1540483477 + ((t >>> 16) * 59797 << 16), ((t ^ t >>> 15) >>> 0).toString(36);
}
var sne = {
  animationIterationCount: 1,
  aspectRatio: 1,
  borderImageOutset: 1,
  borderImageSlice: 1,
  borderImageWidth: 1,
  boxFlex: 1,
  boxFlexGroup: 1,
  boxOrdinalGroup: 1,
  columnCount: 1,
  columns: 1,
  flex: 1,
  flexGrow: 1,
  flexPositive: 1,
  flexShrink: 1,
  flexNegative: 1,
  flexOrder: 1,
  gridRow: 1,
  gridRowEnd: 1,
  gridRowSpan: 1,
  gridRowStart: 1,
  gridColumn: 1,
  gridColumnEnd: 1,
  gridColumnSpan: 1,
  gridColumnStart: 1,
  msGridRow: 1,
  msGridRowSpan: 1,
  msGridColumn: 1,
  msGridColumnSpan: 1,
  fontWeight: 1,
  lineHeight: 1,
  opacity: 1,
  order: 1,
  orphans: 1,
  scale: 1,
  tabSize: 1,
  widows: 1,
  zIndex: 1,
  zoom: 1,
  WebkitLineClamp: 1,
  // SVG-related properties
  fillOpacity: 1,
  floodOpacity: 1,
  stopOpacity: 1,
  strokeDasharray: 1,
  strokeDashoffset: 1,
  strokeMiterlimit: 1,
  strokeOpacity: 1,
  strokeWidth: 1
}, une = /[A-Z]|^ms/g, cne = /_EMO_([^_]+?)_([^]*?)_EMO_/g, vj = function(e) {
  return e.charCodeAt(1) === 45;
}, C5 = function(e) {
  return e != null && typeof e != "boolean";
}, _v = /* @__PURE__ */ hj(function(e) {
  return vj(e) ? e : e.replace(une, "-$&").toLowerCase();
}), O5 = function(e, t) {
  switch (e) {
    case "animation":
    case "animationName":
      if (typeof t == "string")
        return t.replace(cne, function(n, r, o) {
          return Qr = {
            name: r,
            styles: o,
            next: Qr
          }, r;
        });
  }
  return sne[e] !== 1 && !vj(e) && typeof t == "number" && t !== 0 ? t + "px" : t;
};
function Ec(e, t, n) {
  if (n == null)
    return "";
  var r = n;
  if (r.__emotion_styles !== void 0)
    return r;
  switch (typeof n) {
    case "boolean":
      return "";
    case "object": {
      var o = n;
      if (o.anim === 1)
        return Qr = {
          name: o.name,
          styles: o.styles,
          next: Qr
        }, o.name;
      var a = n;
      if (a.styles !== void 0) {
        var l = a.next;
        if (l !== void 0)
          for (; l !== void 0; )
            Qr = {
              name: l.name,
              styles: l.styles,
              next: Qr
            }, l = l.next;
        var u = a.styles + ";";
        return u;
      }
      return dne(e, t, n);
    }
    case "function": {
      if (e !== void 0) {
        var d = Qr, f = n(e);
        return Qr = d, Ec(e, t, f);
      }
      break;
    }
  }
  var p = n;
  if (t == null)
    return p;
  var m = t[p];
  return m !== void 0 ? m : p;
}
function dne(e, t, n) {
  var r = "";
  if (Array.isArray(n))
    for (var o = 0; o < n.length; o++)
      r += Ec(e, t, n[o]) + ";";
  else
    for (var a in n) {
      var l = n[a];
      if (typeof l != "object") {
        var u = l;
        t != null && t[u] !== void 0 ? r += a + "{" + t[u] + "}" : C5(u) && (r += _v(a) + ":" + O5(a, u) + ";");
      } else if (Array.isArray(l) && typeof l[0] == "string" && (t == null || t[l[0]] === void 0))
        for (var d = 0; d < l.length; d++)
          C5(l[d]) && (r += _v(a) + ":" + O5(a, l[d]) + ";");
      else {
        var f = Ec(e, t, l);
        switch (a) {
          case "animation":
          case "animationName": {
            r += _v(a) + ":" + f + ";";
            break;
          }
          default:
            r += a + "{" + f + "}";
        }
      }
    }
  return r;
}
var N5 = /label:\s*([^\s;{]+)\s*(;|$)/g, Qr;
function em(e, t, n) {
  if (e.length === 1 && typeof e[0] == "object" && e[0] !== null && e[0].styles !== void 0)
    return e[0];
  var r = !0, o = "";
  Qr = void 0;
  var a = e[0];
  if (a == null || a.raw === void 0)
    r = !1, o += Ec(n, t, a);
  else {
    var l = a;
    o += l[0];
  }
  for (var u = 1; u < e.length; u++)
    if (o += Ec(n, t, e[u]), r) {
      var d = a;
      o += d[u];
    }
  N5.lastIndex = 0;
  for (var f = "", p; (p = N5.exec(o)) !== null; )
    f += "-" + p[1];
  var m = lne(o) + f;
  return {
    name: m,
    styles: o,
    next: Qr
  };
}
var fne = function(e) {
  return e();
}, pne = _.useInsertionEffect ? _.useInsertionEffect : !1, bj = pne || fne, wj = /* @__PURE__ */ _.createContext(
  // we're doing this to avoid preconstruct's dead code elimination in this one case
  // because this module is primarily intended for the browser and node
  // but it's also required in react native and similar environments sometimes
  // and we could have a special build just for that
  // but this is much easier and the native packages
  // might use a different theme context in the future anyway
  typeof HTMLElement < "u" ? /* @__PURE__ */ one({
    key: "css"
  }) : null
);
wj.Provider;
var xj = function(e) {
  return /* @__PURE__ */ _.forwardRef(function(t, n) {
    var r = _.useContext(wj);
    return e(t, r, n);
  });
}, Sj = /* @__PURE__ */ _.createContext({}), Fx = {}.hasOwnProperty, Fb = "__EMOTION_TYPE_PLEASE_DO_NOT_USE__", hne = function(e, t) {
  var n = {};
  for (var r in t)
    Fx.call(t, r) && (n[r] = t[r]);
  return n[Fb] = e, n;
}, mne = function(e) {
  var t = e.cache, n = e.serialized, r = e.isStringTag;
  return Ux(t, n, r), bj(function() {
    return yj(t, n, r);
  }), null;
}, gne = /* @__PURE__ */ xj(function(e, t, n) {
  var r = e.css;
  typeof r == "string" && t.registered[r] !== void 0 && (r = t.registered[r]);
  var o = e[Fb], a = [r], l = "";
  typeof e.className == "string" ? l = gj(t.registered, a, e.className) : e.className != null && (l = e.className + " ");
  var u = em(a, void 0, _.useContext(Sj));
  l += t.key + "-" + u.name;
  var d = {};
  for (var f in e)
    Fx.call(e, f) && f !== "css" && f !== Fb && (d[f] = e[f]);
  return d.className = l, n && (d.ref = n), /* @__PURE__ */ _.createElement(_.Fragment, null, /* @__PURE__ */ _.createElement(mne, {
    cache: t,
    serialized: u,
    isStringTag: typeof o == "string"
  }), /* @__PURE__ */ _.createElement(o, d));
}), yne = gne, Oe = function(e, t) {
  var n = arguments;
  if (t == null || !Fx.call(t, "css"))
    return _.createElement.apply(void 0, n);
  var r = n.length, o = new Array(r);
  o[0] = yne, o[1] = hne(e, t);
  for (var a = 2; a < r; a++)
    o[a] = n[a];
  return _.createElement.apply(null, o);
};
(function(e) {
  var t;
  t || (t = e.JSX || (e.JSX = {}));
})(Oe || (Oe = {}));
function $x() {
  for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)
    t[n] = arguments[n];
  return em(t);
}
function tm() {
  var e = $x.apply(void 0, arguments), t = "animation-" + e.name;
  return {
    name: t,
    styles: "@keyframes " + t + "{" + e.styles + "}",
    anim: 1,
    toString: function() {
      return "_EMO_" + this.name + "_" + this.styles + "_EMO_";
    }
  };
}
var vne = /^((children|dangerouslySetInnerHTML|key|ref|autoFocus|defaultValue|defaultChecked|innerHTML|suppressContentEditableWarning|suppressHydrationWarning|valueLink|abbr|accept|acceptCharset|accessKey|action|allow|allowUserMedia|allowPaymentRequest|allowFullScreen|allowTransparency|alt|async|autoComplete|autoPlay|capture|cellPadding|cellSpacing|challenge|charSet|checked|cite|classID|className|cols|colSpan|content|contentEditable|contextMenu|controls|controlsList|coords|crossOrigin|data|dateTime|decoding|default|defer|dir|disabled|disablePictureInPicture|disableRemotePlayback|download|draggable|encType|enterKeyHint|fetchpriority|fetchPriority|form|formAction|formEncType|formMethod|formNoValidate|formTarget|frameBorder|headers|height|hidden|high|href|hrefLang|htmlFor|httpEquiv|id|inputMode|integrity|is|keyParams|keyType|kind|label|lang|list|loading|loop|low|marginHeight|marginWidth|max|maxLength|media|mediaGroup|method|min|minLength|multiple|muted|name|nonce|noValidate|open|optimum|pattern|placeholder|playsInline|poster|preload|profile|radioGroup|readOnly|referrerPolicy|rel|required|reversed|role|rows|rowSpan|sandbox|scope|scoped|scrolling|seamless|selected|shape|size|sizes|slot|span|spellCheck|src|srcDoc|srcLang|srcSet|start|step|style|summary|tabIndex|target|title|translate|type|useMap|value|width|wmode|wrap|about|datatype|inlist|prefix|property|resource|typeof|vocab|autoCapitalize|autoCorrect|autoSave|color|incremental|fallback|inert|itemProp|itemScope|itemType|itemID|itemRef|on|option|results|security|unselectable|accentHeight|accumulate|additive|alignmentBaseline|allowReorder|alphabetic|amplitude|arabicForm|ascent|attributeName|attributeType|autoReverse|azimuth|baseFrequency|baselineShift|baseProfile|bbox|begin|bias|by|calcMode|capHeight|clip|clipPathUnits|clipPath|clipRule|colorInterpolation|colorInterpolationFilters|colorProfile|colorRendering|contentScriptType|contentStyleType|cursor|cx|cy|d|decelerate|descent|diffuseConstant|direction|display|divisor|dominantBaseline|dur|dx|dy|edgeMode|elevation|enableBackground|end|exponent|externalResourcesRequired|fill|fillOpacity|fillRule|filter|filterRes|filterUnits|floodColor|floodOpacity|focusable|fontFamily|fontSize|fontSizeAdjust|fontStretch|fontStyle|fontVariant|fontWeight|format|from|fr|fx|fy|g1|g2|glyphName|glyphOrientationHorizontal|glyphOrientationVertical|glyphRef|gradientTransform|gradientUnits|hanging|horizAdvX|horizOriginX|ideographic|imageRendering|in|in2|intercept|k|k1|k2|k3|k4|kernelMatrix|kernelUnitLength|kerning|keyPoints|keySplines|keyTimes|lengthAdjust|letterSpacing|lightingColor|limitingConeAngle|local|markerEnd|markerMid|markerStart|markerHeight|markerUnits|markerWidth|mask|maskContentUnits|maskUnits|mathematical|mode|numOctaves|offset|opacity|operator|order|orient|orientation|origin|overflow|overlinePosition|overlineThickness|panose1|paintOrder|pathLength|patternContentUnits|patternTransform|patternUnits|pointerEvents|points|pointsAtX|pointsAtY|pointsAtZ|preserveAlpha|preserveAspectRatio|primitiveUnits|r|radius|refX|refY|renderingIntent|repeatCount|repeatDur|requiredExtensions|requiredFeatures|restart|result|rotate|rx|ry|scale|seed|shapeRendering|slope|spacing|specularConstant|specularExponent|speed|spreadMethod|startOffset|stdDeviation|stemh|stemv|stitchTiles|stopColor|stopOpacity|strikethroughPosition|strikethroughThickness|string|stroke|strokeDasharray|strokeDashoffset|strokeLinecap|strokeLinejoin|strokeMiterlimit|strokeOpacity|strokeWidth|surfaceScale|systemLanguage|tableValues|targetX|targetY|textAnchor|textDecoration|textRendering|textLength|to|transform|u1|u2|underlinePosition|underlineThickness|unicode|unicodeBidi|unicodeRange|unitsPerEm|vAlphabetic|vHanging|vIdeographic|vMathematical|values|vectorEffect|version|vertAdvY|vertOriginX|vertOriginY|viewBox|viewTarget|visibility|widths|wordSpacing|writingMode|x|xHeight|x1|x2|xChannelSelector|xlinkActuate|xlinkArcrole|xlinkHref|xlinkRole|xlinkShow|xlinkTitle|xlinkType|xmlBase|xmlns|xmlnsXlink|xmlLang|xmlSpace|y|y1|y2|yChannelSelector|z|zoomAndPan|for|class|autofocus)|(([Dd][Aa][Tt][Aa]|[Aa][Rr][Ii][Aa]|x)-.*))$/, bne = /* @__PURE__ */ hj(
  function(e) {
    return vne.test(e) || e.charCodeAt(0) === 111 && e.charCodeAt(1) === 110 && e.charCodeAt(2) < 91;
  }
  /* Z+1 */
), wne = bne, xne = function(e) {
  return e !== "theme";
}, M5 = function(e) {
  return typeof e == "string" && // 96 is one less than the char code
  // for "a" so this is checking that
  // it's a lowercase character
  e.charCodeAt(0) > 96 ? wne : xne;
}, A5 = function(e, t, n) {
  var r;
  if (t) {
    var o = t.shouldForwardProp;
    r = e.__emotion_forwardProp && o ? function(a) {
      return e.__emotion_forwardProp(a) && o(a);
    } : o;
  }
  return typeof r != "function" && n && (r = e.__emotion_forwardProp), r;
}, Sne = function(e) {
  var t = e.cache, n = e.serialized, r = e.isStringTag;
  return Ux(t, n, r), bj(function() {
    return yj(t, n, r);
  }), null;
}, kne = function e(t, n) {
  var r = t.__emotion_real === t, o = r && t.__emotion_base || t, a, l;
  n !== void 0 && (a = n.label, l = n.target);
  var u = A5(t, n, r), d = u || M5(o), f = !d("as");
  return function() {
    var p = arguments, m = r && t.__emotion_styles !== void 0 ? t.__emotion_styles.slice(0) : [];
    if (a !== void 0 && m.push("label:" + a + ";"), p[0] == null || p[0].raw === void 0)
      m.push.apply(m, p);
    else {
      var g = p[0];
      m.push(g[0]);
      for (var y = p.length, w = 1; w < y; w++)
        m.push(p[w], g[w]);
    }
    var v = xj(function(x, E, N) {
      var C = f && x.as || o, A = "", R = [], D = x;
      if (x.theme == null) {
        D = {};
        for (var T in x)
          D[T] = x[T];
        D.theme = _.useContext(Sj);
      }
      typeof x.className == "string" ? A = gj(E.registered, R, x.className) : x.className != null && (A = x.className + " ");
      var V = em(m.concat(R), E.registered, D);
      A += E.key + "-" + V.name, l !== void 0 && (A += " " + l);
      var F = f && u === void 0 ? M5(C) : d, O = {};
      for (var B in x)
        f && B === "as" || F(B) && (O[B] = x[B]);
      return O.className = A, N && (O.ref = N), /* @__PURE__ */ _.createElement(_.Fragment, null, /* @__PURE__ */ _.createElement(Sne, {
        cache: E,
        serialized: V,
        isStringTag: typeof C == "string"
      }), /* @__PURE__ */ _.createElement(C, O));
    });
    return v.displayName = a !== void 0 ? a : "Styled(" + (typeof o == "string" ? o : o.displayName || o.name || "Component") + ")", v.defaultProps = t.defaultProps, v.__emotion_real = v, v.__emotion_base = o, v.__emotion_styles = m, v.__emotion_forwardProp = u, Object.defineProperty(v, "toString", {
      value: function() {
        return "." + l;
      }
    }), v.withComponent = function(x, E) {
      var N = e(x, Ne({}, n, E, {
        shouldForwardProp: A5(v, E, !0)
      }));
      return N.apply(void 0, m);
    }, v;
  };
}, _ne = [
  "a",
  "abbr",
  "address",
  "area",
  "article",
  "aside",
  "audio",
  "b",
  "base",
  "bdi",
  "bdo",
  "big",
  "blockquote",
  "body",
  "br",
  "button",
  "canvas",
  "caption",
  "cite",
  "code",
  "col",
  "colgroup",
  "data",
  "datalist",
  "dd",
  "del",
  "details",
  "dfn",
  "dialog",
  "div",
  "dl",
  "dt",
  "em",
  "embed",
  "fieldset",
  "figcaption",
  "figure",
  "footer",
  "form",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "head",
  "header",
  "hgroup",
  "hr",
  "html",
  "i",
  "iframe",
  "img",
  "input",
  "ins",
  "kbd",
  "keygen",
  "label",
  "legend",
  "li",
  "link",
  "main",
  "map",
  "mark",
  "marquee",
  "menu",
  "menuitem",
  "meta",
  "meter",
  "nav",
  "noscript",
  "object",
  "ol",
  "optgroup",
  "option",
  "output",
  "p",
  "param",
  "picture",
  "pre",
  "progress",
  "q",
  "rp",
  "rt",
  "ruby",
  "s",
  "samp",
  "script",
  "section",
  "select",
  "small",
  "source",
  "span",
  "strong",
  "style",
  "sub",
  "summary",
  "sup",
  "table",
  "tbody",
  "td",
  "textarea",
  "tfoot",
  "th",
  "thead",
  "time",
  "title",
  "tr",
  "track",
  "u",
  "ul",
  "var",
  "video",
  "wbr",
  // SVG
  "circle",
  "clipPath",
  "defs",
  "ellipse",
  "foreignObject",
  "g",
  "image",
  "line",
  "linearGradient",
  "mask",
  "path",
  "pattern",
  "polygon",
  "polyline",
  "radialGradient",
  "rect",
  "stop",
  "svg",
  "text",
  "tspan"
], $b = kne.bind(null);
_ne.forEach(function(e) {
  $b[e] = $b(e);
});
/**
 * @mui/styled-engine v7.0.2
 *
 * @license MIT
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
function Ene(e, t) {
  return $b(e, t);
}
function Cne(e, t) {
  Array.isArray(e.__emotion_styles) && (e.__emotion_styles = t(e.__emotion_styles));
}
const R5 = [];
function j5(e) {
  return R5[0] = e, em(R5);
}
const One = (e) => {
  const t = Object.keys(e).map((n) => ({
    key: n,
    val: e[n]
  })) || [];
  return t.sort((n, r) => n.val - r.val), t.reduce((n, r) => ({
    ...n,
    [r.key]: r.val
  }), {});
};
function Nne(e) {
  const {
    // The breakpoint **start** at this value.
    // For instance with the first breakpoint xs: [xs, sm).
    values: t = {
      xs: 0,
      // phone
      sm: 600,
      // tablet
      md: 900,
      // small laptop
      lg: 1200,
      // desktop
      xl: 1536
      // large screen
    },
    unit: n = "px",
    step: r = 5,
    ...o
  } = e, a = One(t), l = Object.keys(a);
  function u(g) {
    return `@media (min-width:${typeof t[g] == "number" ? t[g] : g}${n})`;
  }
  function d(g) {
    return `@media (max-width:${(typeof t[g] == "number" ? t[g] : g) - r / 100}${n})`;
  }
  function f(g, y) {
    const w = l.indexOf(y);
    return `@media (min-width:${typeof t[g] == "number" ? t[g] : g}${n}) and (max-width:${(w !== -1 && typeof t[l[w]] == "number" ? t[l[w]] : y) - r / 100}${n})`;
  }
  function p(g) {
    return l.indexOf(g) + 1 < l.length ? f(g, l[l.indexOf(g) + 1]) : u(g);
  }
  function m(g) {
    const y = l.indexOf(g);
    return y === 0 ? u(l[1]) : y === l.length - 1 ? d(l[y]) : f(g, l[l.indexOf(g) + 1]).replace("@media", "@media not all and");
  }
  return {
    keys: l,
    values: a,
    up: u,
    down: d,
    between: f,
    only: p,
    not: m,
    unit: n,
    ...o
  };
}
const Mne = {
  borderRadius: 4
};
function kj(e = 8, t = Lx({
  spacing: e
})) {
  if (e.mui)
    return e;
  const n = (...r) => (r.length === 0 ? [1] : r).map((o) => {
    const a = t(o);
    return typeof a == "number" ? `${a}px` : a;
  }).join(" ");
  return n.mui = !0, n;
}
function Ane(e, t) {
  var n;
  const r = this;
  if (r.vars) {
    if (!((n = r.colorSchemes) != null && n[e]) || typeof r.getColorSchemeSelector != "function")
      return {};
    let o = r.getColorSchemeSelector(e);
    return o === "&" ? t : ((o.includes("data-") || o.includes(".")) && (o = `*:where(${o.replace(/\s*&$/, "")}) &`), {
      [o]: t
    });
  }
  return r.palette.mode === e ? t : {};
}
function _j(e = {}, ...t) {
  const {
    breakpoints: n = {},
    palette: r = {},
    spacing: o,
    shape: a = {},
    ...l
  } = e, u = Nne(n), d = kj(o);
  let f = tr({
    breakpoints: u,
    direction: "ltr",
    components: {},
    // Inject component definitions.
    palette: {
      mode: "light",
      ...r
    },
    spacing: d,
    shape: {
      ...Mne,
      ...a
    }
  }, l);
  return f = Hee(f), f.applyStyles = Ane, f = t.reduce((p, m) => tr(p, m), f), f.unstable_sxConfig = {
    ...Wh,
    ...l?.unstable_sxConfig
  }, f.unstable_sx = function(p) {
    return ps({
      sx: p,
      theme: this
    });
  }, f;
}
const D5 = (e) => e, Rne = () => {
  let e = D5;
  return {
    configure(t) {
      e = t;
    },
    generate(t) {
      return e(t);
    },
    reset() {
      e = D5;
    }
  };
}, jne = Rne(), Dne = {
  active: "active",
  checked: "checked",
  completed: "completed",
  disabled: "disabled",
  error: "error",
  expanded: "expanded",
  focused: "focused",
  focusVisible: "focusVisible",
  open: "open",
  readOnly: "readOnly",
  required: "required",
  selected: "selected"
};
function co(e, t, n = "Mui") {
  const r = Dne[t];
  return r ? `${n}-${r}` : `${jne.generate(e)}-${t}`;
}
function fo(e, t, n = "Mui") {
  const r = {};
  return t.forEach((o) => {
    r[o] = co(e, o, n);
  }), r;
}
function Ej(e) {
  const {
    variants: t,
    ...n
  } = e, r = {
    variants: t,
    style: j5(n),
    isProcessed: !0
  };
  return r.style === n || t && t.forEach((o) => {
    typeof o.style != "function" && (o.style = j5(o.style));
  }), r;
}
const Tne = _j();
function Ev(e) {
  return e !== "ownerState" && e !== "theme" && e !== "sx" && e !== "as";
}
function zne(e) {
  return e ? (t, n) => n[e] : null;
}
function Pne(e, t, n) {
  e.theme = Bne(e.theme) ? n : e.theme[t] || e.theme;
}
function pp(e, t) {
  const n = typeof t == "function" ? t(e) : t;
  if (Array.isArray(n))
    return n.flatMap((r) => pp(e, r));
  if (Array.isArray(n?.variants)) {
    let r;
    if (n.isProcessed)
      r = n.style;
    else {
      const {
        variants: o,
        ...a
      } = n;
      r = a;
    }
    return Cj(e, n.variants, [r]);
  }
  return n != null && n.isProcessed ? n.style : n;
}
function Cj(e, t, n = []) {
  var r;
  let o;
  e: for (let a = 0; a < t.length; a += 1) {
    const l = t[a];
    if (typeof l.props == "function") {
      if (o ?? (o = {
        ...e,
        ...e.ownerState,
        ownerState: e.ownerState
      }), !l.props(o))
        continue;
    } else
      for (const u in l.props)
        if (e[u] !== l.props[u] && ((r = e.ownerState) == null ? void 0 : r[u]) !== l.props[u])
          continue e;
    typeof l.style == "function" ? (o ?? (o = {
      ...e,
      ...e.ownerState,
      ownerState: e.ownerState
    }), n.push(l.style(o))) : n.push(l.style);
  }
  return n;
}
function Lne(e = {}) {
  const {
    themeId: t,
    defaultTheme: n = Tne,
    rootShouldForwardProp: r = Ev,
    slotShouldForwardProp: o = Ev
  } = e;
  function a(l) {
    Pne(l, t, n);
  }
  return (l, u = {}) => {
    Cne(l, (A) => A.filter((R) => R !== ps));
    const {
      name: d,
      slot: f,
      skipVariantsResolver: p,
      skipSx: m,
      // TODO v6: remove `lowercaseFirstLetter()` in the next major release
      // For more details: https://github.com/mui/material-ui/pull/37908
      overridesResolver: g = zne(Hne(f)),
      ...y
    } = u, w = p !== void 0 ? p : (
      // TODO v6: remove `Root` in the next major release
      // For more details: https://github.com/mui/material-ui/pull/37908
      f && f !== "Root" && f !== "root" || !1
    ), v = m || !1;
    let x = Ev;
    f === "Root" || f === "root" ? x = r : f ? x = o : Vne(l) && (x = void 0);
    const E = Ene(l, {
      shouldForwardProp: x,
      label: Ine(),
      ...y
    }), N = (A) => {
      if (typeof A == "function" && A.__emotion_real !== A)
        return function(R) {
          return pp(R, A);
        };
      if (Po(A)) {
        const R = Ej(A);
        return R.variants ? function(D) {
          return pp(D, R);
        } : R.style;
      }
      return A;
    }, C = (...A) => {
      const R = [], D = A.map(N), T = [];
      if (R.push(a), d && g && T.push(function(O) {
        var B, U;
        const G = (U = (B = O.theme.components) == null ? void 0 : B[d]) == null ? void 0 : U.styleOverrides;
        if (!G)
          return null;
        const z = {};
        for (const $ in G)
          z[$] = pp(O, G[$]);
        return g(O, z);
      }), d && !w && T.push(function(O) {
        var B, U;
        const G = O.theme, z = (U = (B = G?.components) == null ? void 0 : B[d]) == null ? void 0 : U.variants;
        return z ? Cj(O, z) : null;
      }), v || T.push(ps), Array.isArray(D[0])) {
        const O = D.shift(), B = new Array(R.length).fill(""), U = new Array(T.length).fill("");
        let G;
        G = [...B, ...O, ...U], G.raw = [...B, ...O.raw, ...U], R.unshift(G);
      }
      const V = [...R, ...D, ...T], F = E(...V);
      return l.muiName && (F.muiName = l.muiName), F;
    };
    return E.withConfig && (C.withConfig = E.withConfig), C;
  };
}
function Ine(e, t) {
  return void 0;
}
function Bne(e) {
  for (const t in e)
    return !1;
  return !0;
}
function Vne(e) {
  return typeof e == "string" && // 96 is one less than the char code
  // for "a" so this is checking that
  // it's a lowercase character
  e.charCodeAt(0) > 96;
}
function Hne(e) {
  return e && e.charAt(0).toLowerCase() + e.slice(1);
}
function Yb(e, t) {
  const n = {
    ...t
  };
  for (const r in e)
    if (Object.prototype.hasOwnProperty.call(e, r)) {
      const o = r;
      if (o === "components" || o === "slots")
        n[o] = {
          ...e[o],
          ...n[o]
        };
      else if (o === "componentsProps" || o === "slotProps") {
        const a = e[o], l = t[o];
        if (!l)
          n[o] = a || {};
        else if (!a)
          n[o] = l;
        else {
          n[o] = {
            ...l
          };
          for (const u in a)
            if (Object.prototype.hasOwnProperty.call(a, u)) {
              const d = u;
              n[o][d] = Yb(a[d], l[d]);
            }
        }
      } else n[o] === void 0 && (n[o] = e[o]);
    }
  return n;
}
const Une = typeof window < "u" ? _.useLayoutEffect : _.useEffect;
function Fne(e, t = Number.MIN_SAFE_INTEGER, n = Number.MAX_SAFE_INTEGER) {
  return Math.max(t, Math.min(e, n));
}
function Yx(e, t = 0, n = 1) {
  return Fne(e, t, n);
}
function $ne(e) {
  e = e.slice(1);
  const t = new RegExp(`.{1,${e.length >= 6 ? 2 : 1}}`, "g");
  let n = e.match(t);
  return n && n[0].length === 1 && (n = n.map((r) => r + r)), n ? `rgb${n.length === 4 ? "a" : ""}(${n.map((r, o) => o < 3 ? parseInt(r, 16) : Math.round(parseInt(r, 16) / 255 * 1e3) / 1e3).join(", ")})` : "";
}
function Xi(e) {
  if (e.type)
    return e;
  if (e.charAt(0) === "#")
    return Xi($ne(e));
  const t = e.indexOf("("), n = e.substring(0, t);
  if (!["rgb", "rgba", "hsl", "hsla", "color"].includes(n))
    throw new Error(Ia(9, e));
  let r = e.substring(t + 1, e.length - 1), o;
  if (n === "color") {
    if (r = r.split(" "), o = r.shift(), r.length === 4 && r[3].charAt(0) === "/" && (r[3] = r[3].slice(1)), !["srgb", "display-p3", "a98-rgb", "prophoto-rgb", "rec-2020"].includes(o))
      throw new Error(Ia(10, o));
  } else
    r = r.split(",");
  return r = r.map((a) => parseFloat(a)), {
    type: n,
    values: r,
    colorSpace: o
  };
}
const Yne = (e) => {
  const t = Xi(e);
  return t.values.slice(0, 3).map((n, r) => t.type.includes("hsl") && r !== 0 ? `${n}%` : n).join(" ");
}, Xu = (e, t) => {
  try {
    return Yne(e);
  } catch {
    return e;
  }
};
function nm(e) {
  const {
    type: t,
    colorSpace: n
  } = e;
  let {
    values: r
  } = e;
  return t.includes("rgb") ? r = r.map((o, a) => a < 3 ? parseInt(o, 10) : o) : t.includes("hsl") && (r[1] = `${r[1]}%`, r[2] = `${r[2]}%`), t.includes("color") ? r = `${n} ${r.join(" ")}` : r = `${r.join(", ")}`, `${t}(${r})`;
}
function Oj(e) {
  e = Xi(e);
  const {
    values: t
  } = e, n = t[0], r = t[1] / 100, o = t[2] / 100, a = r * Math.min(o, 1 - o), l = (f, p = (f + n / 30) % 12) => o - a * Math.max(Math.min(p - 3, 9 - p, 1), -1);
  let u = "rgb";
  const d = [Math.round(l(0) * 255), Math.round(l(8) * 255), Math.round(l(4) * 255)];
  return e.type === "hsla" && (u += "a", d.push(t[3])), nm({
    type: u,
    values: d
  });
}
function qb(e) {
  e = Xi(e);
  let t = e.type === "hsl" || e.type === "hsla" ? Xi(Oj(e)).values : e.values;
  return t = t.map((n) => (e.type !== "color" && (n /= 255), n <= 0.03928 ? n / 12.92 : ((n + 0.055) / 1.055) ** 2.4)), Number((0.2126 * t[0] + 0.7152 * t[1] + 0.0722 * t[2]).toFixed(3));
}
function qne(e, t) {
  const n = qb(e), r = qb(t);
  return (Math.max(n, r) + 0.05) / (Math.min(n, r) + 0.05);
}
function Cc(e, t) {
  return e = Xi(e), t = Yx(t), (e.type === "rgb" || e.type === "hsl") && (e.type += "a"), e.type === "color" ? e.values[3] = `/${t}` : e.values[3] = t, nm(e);
}
function Hf(e, t, n) {
  try {
    return Cc(e, t);
  } catch {
    return e;
  }
}
function rm(e, t) {
  if (e = Xi(e), t = Yx(t), e.type.includes("hsl"))
    e.values[2] *= 1 - t;
  else if (e.type.includes("rgb") || e.type.includes("color"))
    for (let n = 0; n < 3; n += 1)
      e.values[n] *= 1 - t;
  return nm(e);
}
function pt(e, t, n) {
  try {
    return rm(e, t);
  } catch {
    return e;
  }
}
function om(e, t) {
  if (e = Xi(e), t = Yx(t), e.type.includes("hsl"))
    e.values[2] += (100 - e.values[2]) * t;
  else if (e.type.includes("rgb"))
    for (let n = 0; n < 3; n += 1)
      e.values[n] += (255 - e.values[n]) * t;
  else if (e.type.includes("color"))
    for (let n = 0; n < 3; n += 1)
      e.values[n] += (1 - e.values[n]) * t;
  return nm(e);
}
function ht(e, t, n) {
  try {
    return om(e, t);
  } catch {
    return e;
  }
}
function Xne(e, t = 0.15) {
  return qb(e) > 0.5 ? rm(e, t) : om(e, t);
}
function Uf(e, t, n) {
  try {
    return Xne(e, t);
  } catch {
    return e;
  }
}
function Gne(e, t) {
  return () => null;
}
Gne(Ue.elementType);
Ue.oneOfType([Ue.func, Ue.object]);
function hp(e) {
  const t = _.useRef(e);
  return Une(() => {
    t.current = e;
  }), _.useRef((...n) => (
    // @ts-expect-error hide `this`
    (0, t.current)(...n)
  )).current;
}
function Xb(...e) {
  const t = _.useRef(void 0), n = _.useCallback((r) => {
    const o = e.map((a) => {
      if (a == null)
        return null;
      if (typeof a == "function") {
        const l = a, u = l(r);
        return typeof u == "function" ? u : () => {
          l(null);
        };
      }
      return a.current = r, () => {
        a.current = null;
      };
    });
    return () => {
      o.forEach((a) => a?.());
    };
  }, e);
  return _.useMemo(() => e.every((r) => r == null) ? null : (r) => {
    t.current && (t.current(), t.current = void 0), r != null && (t.current = n(r));
  }, e);
}
const T5 = {};
function Nj(e, t) {
  const n = _.useRef(T5);
  return n.current === T5 && (n.current = e(t)), n;
}
const Zne = [];
function Wne(e) {
  _.useEffect(e, Zne);
}
class qx {
  constructor() {
    Zf(this, "currentId", null), Zf(this, "clear", () => {
      this.currentId !== null && (clearTimeout(this.currentId), this.currentId = null);
    }), Zf(this, "disposeEffect", () => this.clear);
  }
  static create() {
    return new qx();
  }
  /**
   * Executes `fn` after `delay`, clearing any previously scheduled call.
   */
  start(t, n) {
    this.clear(), this.currentId = setTimeout(() => {
      this.currentId = null, n();
    }, t);
  }
}
function Kne() {
  const e = Nj(qx.create).current;
  return Wne(e.disposeEffect), e;
}
function z5(e) {
  try {
    return e.matches(":focus-visible");
  } catch {
  }
  return !1;
}
function Qne(e) {
  return typeof e == "string";
}
function Jne(e, t, n) {
  return e === void 0 || Qne(e) ? t : {
    ...t,
    ownerState: {
      ...t.ownerState,
      ...n
    }
  };
}
function ere(e, t = []) {
  if (e === void 0)
    return {};
  const n = {};
  return Object.keys(e).filter((r) => r.match(/^on[A-Z]/) && typeof e[r] == "function" && !t.includes(r)).forEach((r) => {
    n[r] = e[r];
  }), n;
}
function P5(e) {
  if (e === void 0)
    return {};
  const t = {};
  return Object.keys(e).filter((n) => !(n.match(/^on[A-Z]/) && typeof e[n] == "function")).forEach((n) => {
    t[n] = e[n];
  }), t;
}
function tre(e) {
  const {
    getSlotProps: t,
    additionalProps: n,
    externalSlotProps: r,
    externalForwardedProps: o,
    className: a
  } = e;
  if (!t) {
    const y = Yt(n?.className, a, o?.className, r?.className), w = {
      ...n?.style,
      ...o?.style,
      ...r?.style
    }, v = {
      ...n,
      ...o,
      ...r
    };
    return y.length > 0 && (v.className = y), Object.keys(w).length > 0 && (v.style = w), {
      props: v,
      internalRef: void 0
    };
  }
  const l = ere({
    ...o,
    ...r
  }), u = P5(r), d = P5(o), f = t(l), p = Yt(f?.className, n?.className, a, o?.className, r?.className), m = {
    ...f?.style,
    ...n?.style,
    ...o?.style,
    ...r?.style
  }, g = {
    ...f,
    ...n,
    ...d,
    ...u
  };
  return p.length > 0 && (g.className = p), Object.keys(m).length > 0 && (g.style = m), {
    props: g,
    internalRef: f.ref
  };
}
function nre(e, t, n) {
  return typeof e == "function" ? e(t, n) : e;
}
const rre = /* @__PURE__ */ _.createContext(void 0);
function ore(e) {
  const {
    theme: t,
    name: n,
    props: r
  } = e;
  if (!t || !t.components || !t.components[n])
    return r;
  const o = t.components[n];
  return o.defaultProps ? Yb(o.defaultProps, r) : !o.styleOverrides && !o.variants ? Yb(o, r) : r;
}
function ire({
  props: e,
  name: t
}) {
  const n = _.useContext(rre);
  return ore({
    props: e,
    name: t,
    theme: {
      components: n
    }
  });
}
const L5 = {
  theme: void 0
};
function are(e) {
  let t, n;
  return function(r) {
    let o = t;
    return (o === void 0 || r.theme !== n) && (L5.theme = r.theme, o = Ej(e(L5)), t = o, n = r.theme), o;
  };
}
function lre(e = "") {
  function t(...n) {
    if (!n.length)
      return "";
    const r = n[0];
    return typeof r == "string" && !r.match(/(#|\(|\)|(-?(\d*\.)?\d+)(px|em|%|ex|ch|rem|vw|vh|vmin|vmax|cm|mm|in|pt|pc))|^(-?(\d*\.)?\d+)$|(\d+ \d+ \d+)/) ? `, var(--${e ? `${e}-` : ""}${r}${t(...n.slice(1))})` : `, ${r}`;
  }
  return (n, ...r) => `var(--${e ? `${e}-` : ""}${n}${t(...r)})`;
}
const I5 = (e, t, n, r = []) => {
  let o = e;
  t.forEach((a, l) => {
    l === t.length - 1 ? Array.isArray(o) ? o[Number(a)] = n : o && typeof o == "object" && (o[a] = n) : o && typeof o == "object" && (o[a] || (o[a] = r.includes(a) ? [] : {}), o = o[a]);
  });
}, sre = (e, t, n) => {
  function r(o, a = [], l = []) {
    Object.entries(o).forEach(([u, d]) => {
      (!n || n && !n([...a, u])) && d != null && (typeof d == "object" && Object.keys(d).length > 0 ? r(d, [...a, u], Array.isArray(d) ? [...l, u] : l) : t([...a, u], d, l));
    });
  }
  r(e);
}, ure = (e, t) => typeof t == "number" ? ["lineHeight", "fontWeight", "opacity", "zIndex"].some((n) => e.includes(n)) || e[e.length - 1].toLowerCase().includes("opacity") ? t : `${t}px` : t;
function Cv(e, t) {
  const {
    prefix: n,
    shouldSkipGeneratingVar: r
  } = t || {}, o = {}, a = {}, l = {};
  return sre(
    e,
    (u, d, f) => {
      if ((typeof d == "string" || typeof d == "number") && (!r || !r(u, d))) {
        const p = `--${n ? `${n}-` : ""}${u.join("-")}`, m = ure(u, d);
        Object.assign(o, {
          [p]: m
        }), I5(a, u, `var(${p})`, f), I5(l, u, `var(${p}, ${m})`, f);
      }
    },
    (u) => u[0] === "vars"
    // skip 'vars/*' paths
  ), {
    css: o,
    vars: a,
    varsWithDefaults: l
  };
}
function cre(e, t = {}) {
  const {
    getSelector: n = x,
    disableCssColorScheme: r,
    colorSchemeSelector: o
  } = t, {
    colorSchemes: a = {},
    components: l,
    defaultColorScheme: u = "light",
    ...d
  } = e, {
    vars: f,
    css: p,
    varsWithDefaults: m
  } = Cv(d, t);
  let g = m;
  const y = {}, {
    [u]: w,
    ...v
  } = a;
  if (Object.entries(v || {}).forEach(([E, N]) => {
    const {
      vars: C,
      css: A,
      varsWithDefaults: R
    } = Cv(N, t);
    g = tr(g, R), y[E] = {
      css: A,
      vars: C
    };
  }), w) {
    const {
      css: E,
      vars: N,
      varsWithDefaults: C
    } = Cv(w, t);
    g = tr(g, C), y[u] = {
      css: E,
      vars: N
    };
  }
  function x(E, N) {
    var C, A;
    let R = o;
    if (o === "class" && (R = ".%s"), o === "data" && (R = "[data-%s]"), o != null && o.startsWith("data-") && !o.includes("%s") && (R = `[${o}="%s"]`), E) {
      if (R === "media")
        return e.defaultColorScheme === E ? ":root" : {
          [`@media (prefers-color-scheme: ${((A = (C = a[E]) == null ? void 0 : C.palette) == null ? void 0 : A.mode) || E})`]: {
            ":root": N
          }
        };
      if (R)
        return e.defaultColorScheme === E ? `:root, ${R.replace("%s", String(E))}` : R.replace("%s", String(E));
    }
    return ":root";
  }
  return {
    vars: g,
    generateThemeVars: () => {
      let E = {
        ...f
      };
      return Object.entries(y).forEach(([, {
        vars: N
      }]) => {
        E = tr(E, N);
      }), E;
    },
    generateStyleSheets: () => {
      var E, N;
      const C = [], A = e.defaultColorScheme || "light";
      function R(V, F) {
        Object.keys(F).length && C.push(typeof V == "string" ? {
          [V]: {
            ...F
          }
        } : V);
      }
      R(n(void 0, {
        ...p
      }), p);
      const {
        [A]: D,
        ...T
      } = y;
      if (D) {
        const {
          css: V
        } = D, F = (N = (E = a[A]) == null ? void 0 : E.palette) == null ? void 0 : N.mode, O = !r && F ? {
          colorScheme: F,
          ...V
        } : {
          ...V
        };
        R(n(A, {
          ...O
        }), O);
      }
      return Object.entries(T).forEach(([V, {
        css: F
      }]) => {
        var O, B;
        const U = (B = (O = a[V]) == null ? void 0 : O.palette) == null ? void 0 : B.mode, G = !r && U ? {
          colorScheme: U,
          ...F
        } : {
          ...F
        };
        R(n(V, {
          ...G
        }), G);
      }), C;
    }
  };
}
function dre(e) {
  return function(t) {
    return e === "media" ? `@media (prefers-color-scheme: ${t})` : e ? e.startsWith("data-") && !e.includes("%s") ? `[${e}="${t}"] &` : e === "class" ? `.${t} &` : e === "data" ? `[data-${t}] &` : `${e.replace("%s", t)} &` : "&";
  };
}
const Oc = {
  black: "#000",
  white: "#fff"
}, fre = {
  50: "#fafafa",
  100: "#f5f5f5",
  200: "#eeeeee",
  300: "#e0e0e0",
  400: "#bdbdbd",
  500: "#9e9e9e",
  600: "#757575",
  700: "#616161",
  800: "#424242",
  900: "#212121",
  A100: "#f5f5f5",
  A200: "#eeeeee",
  A400: "#bdbdbd",
  A700: "#616161"
}, Tl = {
  50: "#f3e5f5",
  200: "#ce93d8",
  300: "#ba68c8",
  400: "#ab47bc",
  500: "#9c27b0",
  700: "#7b1fa2"
}, zl = {
  300: "#e57373",
  400: "#ef5350",
  500: "#f44336",
  700: "#d32f2f",
  800: "#c62828"
}, Hu = {
  300: "#ffb74d",
  400: "#ffa726",
  500: "#ff9800",
  700: "#f57c00",
  900: "#e65100"
}, Pl = {
  50: "#e3f2fd",
  200: "#90caf9",
  400: "#42a5f5",
  700: "#1976d2",
  800: "#1565c0"
}, Ll = {
  300: "#4fc3f7",
  400: "#29b6f6",
  500: "#03a9f4",
  700: "#0288d1",
  900: "#01579b"
}, Il = {
  300: "#81c784",
  400: "#66bb6a",
  500: "#4caf50",
  700: "#388e3c",
  800: "#2e7d32",
  900: "#1b5e20"
};
function Mj() {
  return {
    // The colors used to style the text.
    text: {
      // The most important text.
      primary: "rgba(0, 0, 0, 0.87)",
      // Secondary text.
      secondary: "rgba(0, 0, 0, 0.6)",
      // Disabled text have even lower visual prominence.
      disabled: "rgba(0, 0, 0, 0.38)"
    },
    // The color used to divide different elements.
    divider: "rgba(0, 0, 0, 0.12)",
    // The background colors used to style the surfaces.
    // Consistency between these values is important.
    background: {
      paper: Oc.white,
      default: Oc.white
    },
    // The colors used to style the action elements.
    action: {
      // The color of an active action like an icon button.
      active: "rgba(0, 0, 0, 0.54)",
      // The color of an hovered action.
      hover: "rgba(0, 0, 0, 0.04)",
      hoverOpacity: 0.04,
      // The color of a selected action.
      selected: "rgba(0, 0, 0, 0.08)",
      selectedOpacity: 0.08,
      // The color of a disabled action.
      disabled: "rgba(0, 0, 0, 0.26)",
      // The background color of a disabled action.
      disabledBackground: "rgba(0, 0, 0, 0.12)",
      disabledOpacity: 0.38,
      focus: "rgba(0, 0, 0, 0.12)",
      focusOpacity: 0.12,
      activatedOpacity: 0.12
    }
  };
}
const pre = Mj();
function Aj() {
  return {
    text: {
      primary: Oc.white,
      secondary: "rgba(255, 255, 255, 0.7)",
      disabled: "rgba(255, 255, 255, 0.5)",
      icon: "rgba(255, 255, 255, 0.5)"
    },
    divider: "rgba(255, 255, 255, 0.12)",
    background: {
      paper: "#121212",
      default: "#121212"
    },
    action: {
      active: Oc.white,
      hover: "rgba(255, 255, 255, 0.08)",
      hoverOpacity: 0.08,
      selected: "rgba(255, 255, 255, 0.16)",
      selectedOpacity: 0.16,
      disabled: "rgba(255, 255, 255, 0.3)",
      disabledBackground: "rgba(255, 255, 255, 0.12)",
      disabledOpacity: 0.38,
      focus: "rgba(255, 255, 255, 0.12)",
      focusOpacity: 0.12,
      activatedOpacity: 0.24
    }
  };
}
const B5 = Aj();
function V5(e, t, n, r) {
  const o = r.light || r, a = r.dark || r * 1.5;
  e[t] || (e.hasOwnProperty(n) ? e[t] = e[n] : t === "light" ? e.light = om(e.main, o) : t === "dark" && (e.dark = rm(e.main, a)));
}
function hre(e = "light") {
  return e === "dark" ? {
    main: Pl[200],
    light: Pl[50],
    dark: Pl[400]
  } : {
    main: Pl[700],
    light: Pl[400],
    dark: Pl[800]
  };
}
function mre(e = "light") {
  return e === "dark" ? {
    main: Tl[200],
    light: Tl[50],
    dark: Tl[400]
  } : {
    main: Tl[500],
    light: Tl[300],
    dark: Tl[700]
  };
}
function gre(e = "light") {
  return e === "dark" ? {
    main: zl[500],
    light: zl[300],
    dark: zl[700]
  } : {
    main: zl[700],
    light: zl[400],
    dark: zl[800]
  };
}
function yre(e = "light") {
  return e === "dark" ? {
    main: Ll[400],
    light: Ll[300],
    dark: Ll[700]
  } : {
    main: Ll[700],
    light: Ll[500],
    dark: Ll[900]
  };
}
function vre(e = "light") {
  return e === "dark" ? {
    main: Il[400],
    light: Il[300],
    dark: Il[700]
  } : {
    main: Il[800],
    light: Il[500],
    dark: Il[900]
  };
}
function bre(e = "light") {
  return e === "dark" ? {
    main: Hu[400],
    light: Hu[300],
    dark: Hu[700]
  } : {
    main: "#ed6c02",
    // closest to orange[800] that pass 3:1.
    light: Hu[500],
    dark: Hu[900]
  };
}
function Xx(e) {
  const {
    mode: t = "light",
    contrastThreshold: n = 3,
    tonalOffset: r = 0.2,
    ...o
  } = e, a = e.primary || hre(t), l = e.secondary || mre(t), u = e.error || gre(t), d = e.info || yre(t), f = e.success || vre(t), p = e.warning || bre(t);
  function m(w) {
    return qne(w, B5.text.primary) >= n ? B5.text.primary : pre.text.primary;
  }
  const g = ({
    color: w,
    name: v,
    mainShade: x = 500,
    lightShade: E = 300,
    darkShade: N = 700
  }) => {
    if (w = {
      ...w
    }, !w.main && w[x] && (w.main = w[x]), !w.hasOwnProperty("main"))
      throw new Error(Ia(11, v ? ` (${v})` : "", x));
    if (typeof w.main != "string")
      throw new Error(Ia(12, v ? ` (${v})` : "", JSON.stringify(w.main)));
    return V5(w, "light", E, r), V5(w, "dark", N, r), w.contrastText || (w.contrastText = m(w.main)), w;
  };
  let y;
  return t === "light" ? y = Mj() : t === "dark" && (y = Aj()), tr({
    // A collection of common colors.
    common: {
      ...Oc
    },
    // prevent mutable object.
    // The palette mode, can be light or dark.
    mode: t,
    // The colors used to represent primary interface elements for a user.
    primary: g({
      color: a,
      name: "primary"
    }),
    // The colors used to represent secondary interface elements for a user.
    secondary: g({
      color: l,
      name: "secondary",
      mainShade: "A400",
      lightShade: "A200",
      darkShade: "A700"
    }),
    // The colors used to represent interface elements that the user should be made aware of.
    error: g({
      color: u,
      name: "error"
    }),
    // The colors used to represent potentially dangerous actions or important messages.
    warning: g({
      color: p,
      name: "warning"
    }),
    // The colors used to present information to the user that is neutral and not necessarily important.
    info: g({
      color: d,
      name: "info"
    }),
    // The colors used to indicate the successful completion of an action that user triggered.
    success: g({
      color: f,
      name: "success"
    }),
    // The grey colors.
    grey: fre,
    // Used by `getContrastText()` to maximize the contrast between
    // the background and the text.
    contrastThreshold: n,
    // Takes a background color and returns the text color that maximizes the contrast.
    getContrastText: m,
    // Generate a rich color object.
    augmentColor: g,
    // Used by the functions below to shift a color's luminance by approximately
    // two indexes within its tonal palette.
    // E.g., shift from Red 500 to Red 300 or Red 700.
    tonalOffset: r,
    // The light and dark mode object.
    ...y
  }, o);
}
function wre(e) {
  const t = {};
  return Object.entries(e).forEach((n) => {
    const [r, o] = n;
    typeof o == "object" && (t[r] = `${o.fontStyle ? `${o.fontStyle} ` : ""}${o.fontVariant ? `${o.fontVariant} ` : ""}${o.fontWeight ? `${o.fontWeight} ` : ""}${o.fontStretch ? `${o.fontStretch} ` : ""}${o.fontSize || ""}${o.lineHeight ? `/${o.lineHeight} ` : ""}${o.fontFamily || ""}`);
  }), t;
}
function xre(e, t) {
  return {
    toolbar: {
      minHeight: 56,
      [e.up("xs")]: {
        "@media (orientation: landscape)": {
          minHeight: 48
        }
      },
      [e.up("sm")]: {
        minHeight: 64
      }
    },
    ...t
  };
}
function Sre(e) {
  return Math.round(e * 1e5) / 1e5;
}
const H5 = {
  textTransform: "uppercase"
}, U5 = '"Roboto", "Helvetica", "Arial", sans-serif';
function kre(e, t) {
  const {
    fontFamily: n = U5,
    // The default font size of the Material Specification.
    fontSize: r = 14,
    // px
    fontWeightLight: o = 300,
    fontWeightRegular: a = 400,
    fontWeightMedium: l = 500,
    fontWeightBold: u = 700,
    // Tell MUI what's the font-size on the html element.
    // 16px is the default font-size used by browsers.
    htmlFontSize: d = 16,
    // Apply the CSS properties to all the variants.
    allVariants: f,
    pxToRem: p,
    ...m
  } = typeof t == "function" ? t(e) : t, g = r / 14, y = p || ((x) => `${x / d * g}rem`), w = (x, E, N, C, A) => ({
    fontFamily: n,
    fontWeight: x,
    fontSize: y(E),
    // Unitless following https://meyerweb.com/eric/thoughts/2006/02/08/unitless-line-heights/
    lineHeight: N,
    // The letter spacing was designed for the Roboto font-family. Using the same letter-spacing
    // across font-families can cause issues with the kerning.
    ...n === U5 ? {
      letterSpacing: `${Sre(C / E)}em`
    } : {},
    ...A,
    ...f
  }), v = {
    h1: w(o, 96, 1.167, -1.5),
    h2: w(o, 60, 1.2, -0.5),
    h3: w(a, 48, 1.167, 0),
    h4: w(a, 34, 1.235, 0.25),
    h5: w(a, 24, 1.334, 0),
    h6: w(l, 20, 1.6, 0.15),
    subtitle1: w(a, 16, 1.75, 0.15),
    subtitle2: w(l, 14, 1.57, 0.1),
    body1: w(a, 16, 1.5, 0.15),
    body2: w(a, 14, 1.43, 0.15),
    button: w(l, 14, 1.75, 0.4, H5),
    caption: w(a, 12, 1.66, 0.4),
    overline: w(a, 12, 2.66, 1, H5),
    // TODO v6: Remove handling of 'inherit' variant from the theme as it is already handled in Material UI's Typography component. Also, remember to remove the associated types.
    inherit: {
      fontFamily: "inherit",
      fontWeight: "inherit",
      fontSize: "inherit",
      lineHeight: "inherit",
      letterSpacing: "inherit"
    }
  };
  return tr({
    htmlFontSize: d,
    pxToRem: y,
    fontFamily: n,
    fontSize: r,
    fontWeightLight: o,
    fontWeightRegular: a,
    fontWeightMedium: l,
    fontWeightBold: u,
    ...v
  }, m, {
    clone: !1
    // No need to clone deep
  });
}
const _re = 0.2, Ere = 0.14, Cre = 0.12;
function xt(...e) {
  return [`${e[0]}px ${e[1]}px ${e[2]}px ${e[3]}px rgba(0,0,0,${_re})`, `${e[4]}px ${e[5]}px ${e[6]}px ${e[7]}px rgba(0,0,0,${Ere})`, `${e[8]}px ${e[9]}px ${e[10]}px ${e[11]}px rgba(0,0,0,${Cre})`].join(",");
}
const Ore = ["none", xt(0, 2, 1, -1, 0, 1, 1, 0, 0, 1, 3, 0), xt(0, 3, 1, -2, 0, 2, 2, 0, 0, 1, 5, 0), xt(0, 3, 3, -2, 0, 3, 4, 0, 0, 1, 8, 0), xt(0, 2, 4, -1, 0, 4, 5, 0, 0, 1, 10, 0), xt(0, 3, 5, -1, 0, 5, 8, 0, 0, 1, 14, 0), xt(0, 3, 5, -1, 0, 6, 10, 0, 0, 1, 18, 0), xt(0, 4, 5, -2, 0, 7, 10, 1, 0, 2, 16, 1), xt(0, 5, 5, -3, 0, 8, 10, 1, 0, 3, 14, 2), xt(0, 5, 6, -3, 0, 9, 12, 1, 0, 3, 16, 2), xt(0, 6, 6, -3, 0, 10, 14, 1, 0, 4, 18, 3), xt(0, 6, 7, -4, 0, 11, 15, 1, 0, 4, 20, 3), xt(0, 7, 8, -4, 0, 12, 17, 2, 0, 5, 22, 4), xt(0, 7, 8, -4, 0, 13, 19, 2, 0, 5, 24, 4), xt(0, 7, 9, -4, 0, 14, 21, 2, 0, 5, 26, 4), xt(0, 8, 9, -5, 0, 15, 22, 2, 0, 6, 28, 5), xt(0, 8, 10, -5, 0, 16, 24, 2, 0, 6, 30, 5), xt(0, 8, 11, -5, 0, 17, 26, 2, 0, 6, 32, 5), xt(0, 9, 11, -5, 0, 18, 28, 2, 0, 7, 34, 6), xt(0, 9, 12, -6, 0, 19, 29, 2, 0, 7, 36, 6), xt(0, 10, 13, -6, 0, 20, 31, 3, 0, 8, 38, 7), xt(0, 10, 13, -6, 0, 21, 33, 3, 0, 8, 40, 7), xt(0, 10, 14, -6, 0, 22, 35, 3, 0, 8, 42, 7), xt(0, 11, 14, -7, 0, 23, 36, 3, 0, 9, 44, 8), xt(0, 11, 15, -7, 0, 24, 38, 3, 0, 9, 46, 8)], Nre = {
  // This is the most common easing curve.
  easeInOut: "cubic-bezier(0.4, 0, 0.2, 1)",
  // Objects enter the screen at full velocity from off-screen and
  // slowly decelerate to a resting point.
  easeOut: "cubic-bezier(0.0, 0, 0.2, 1)",
  // Objects leave the screen at full velocity. They do not decelerate when off-screen.
  easeIn: "cubic-bezier(0.4, 0, 1, 1)",
  // The sharp curve is used by objects that may return to the screen at any time.
  sharp: "cubic-bezier(0.4, 0, 0.6, 1)"
}, Mre = {
  shortest: 150,
  shorter: 200,
  short: 250,
  // most basic recommended timing
  standard: 300,
  // this is to be used in complex animations
  complex: 375,
  // recommended when something is entering screen
  enteringScreen: 225,
  // recommended when something is leaving screen
  leavingScreen: 195
};
function F5(e) {
  return `${Math.round(e)}ms`;
}
function Are(e) {
  if (!e)
    return 0;
  const t = e / 36;
  return Math.min(Math.round((4 + 15 * t ** 0.25 + t / 5) * 10), 3e3);
}
function Rre(e) {
  const t = {
    ...Nre,
    ...e.easing
  }, n = {
    ...Mre,
    ...e.duration
  };
  return {
    getAutoHeightDuration: Are,
    create: (r = ["all"], o = {}) => {
      const {
        duration: a = n.standard,
        easing: l = t.easeInOut,
        delay: u = 0,
        ...d
      } = o;
      return (Array.isArray(r) ? r : [r]).map((f) => `${f} ${typeof a == "string" ? a : F5(a)} ${l} ${typeof u == "string" ? u : F5(u)}`).join(",");
    },
    ...e,
    easing: t,
    duration: n
  };
}
const jre = {
  mobileStepper: 1e3,
  fab: 1050,
  speedDial: 1050,
  appBar: 1100,
  drawer: 1200,
  modal: 1300,
  snackbar: 1400,
  tooltip: 1500
};
function Dre(e) {
  return Po(e) || typeof e > "u" || typeof e == "string" || typeof e == "boolean" || typeof e == "number" || Array.isArray(e);
}
function Rj(e = {}) {
  const t = {
    ...e
  };
  function n(r) {
    const o = Object.entries(r);
    for (let a = 0; a < o.length; a++) {
      const [l, u] = o[a];
      !Dre(u) || l.startsWith("unstable_") ? delete r[l] : Po(u) && (r[l] = {
        ...u
      }, n(r[l]));
    }
  }
  return n(t), `import { unstable_createBreakpoints as createBreakpoints, createTransitions } from '@mui/material/styles';

const theme = ${JSON.stringify(t, null, 2)};

theme.breakpoints = createBreakpoints(theme.breakpoints || {});
theme.transitions = createTransitions(theme.transitions || {});

export default theme;`;
}
function Gb(e = {}, ...t) {
  const {
    breakpoints: n,
    mixins: r = {},
    spacing: o,
    palette: a = {},
    transitions: l = {},
    typography: u = {},
    shape: d,
    ...f
  } = e;
  if (e.vars && // The error should throw only for the root theme creation because user is not allowed to use a custom node `vars`.
  // `generateThemeVars` is the closest identifier for checking that the `options` is a result of `createTheme` with CSS variables so that user can create new theme for nested ThemeProvider.
  e.generateThemeVars === void 0)
    throw new Error(Ia(20));
  const p = Xx(a), m = _j(e);
  let g = tr(m, {
    mixins: xre(m.breakpoints, r),
    palette: p,
    // Don't use [...shadows] until you've verified its transpiled code is not invoking the iterator protocol.
    shadows: Ore.slice(),
    typography: kre(p, u),
    transitions: Rre(l),
    zIndex: {
      ...jre
    }
  });
  return g = tr(g, f), g = t.reduce((y, w) => tr(y, w), g), g.unstable_sxConfig = {
    ...Wh,
    ...f?.unstable_sxConfig
  }, g.unstable_sx = function(y) {
    return ps({
      sx: y,
      theme: this
    });
  }, g.toRuntimeSource = Rj, g;
}
function Tre(e) {
  let t;
  return e < 1 ? t = 5.11916 * e ** 2 : t = 4.5 * Math.log(e + 1) + 2, Math.round(t * 10) / 1e3;
}
const zre = [...Array(25)].map((e, t) => {
  if (t === 0)
    return "none";
  const n = Tre(t);
  return `linear-gradient(rgba(255 255 255 / ${n}), rgba(255 255 255 / ${n}))`;
});
function jj(e) {
  return {
    inputPlaceholder: e === "dark" ? 0.5 : 0.42,
    inputUnderline: e === "dark" ? 0.7 : 0.42,
    switchTrackDisabled: e === "dark" ? 0.2 : 0.12,
    switchTrack: e === "dark" ? 0.3 : 0.38
  };
}
function Dj(e) {
  return e === "dark" ? zre : [];
}
function Pre(e) {
  const {
    palette: t = {
      mode: "light"
    },
    // need to cast to avoid module augmentation test
    opacity: n,
    overlays: r,
    ...o
  } = e, a = Xx(t);
  return {
    palette: a,
    opacity: {
      ...jj(a.mode),
      ...n
    },
    overlays: r || Dj(a.mode),
    ...o
  };
}
function Lre(e) {
  var t;
  return !!e[0].match(/(cssVarPrefix|colorSchemeSelector|rootSelector|typography|mixins|breakpoints|direction|transitions)/) || !!e[0].match(/sxConfig$/) || // ends with sxConfig
  e[0] === "palette" && !!((t = e[1]) != null && t.match(/(mode|contrastThreshold|tonalOffset)/));
}
const Ire = (e) => [...[...Array(25)].map((t, n) => `--${e ? `${e}-` : ""}overlays-${n}`), `--${e ? `${e}-` : ""}palette-AppBar-darkBg`, `--${e ? `${e}-` : ""}palette-AppBar-darkColor`], Bre = (e) => (t, n) => {
  const r = e.rootSelector || ":root", o = e.colorSchemeSelector;
  let a = o;
  if (o === "class" && (a = ".%s"), o === "data" && (a = "[data-%s]"), o != null && o.startsWith("data-") && !o.includes("%s") && (a = `[${o}="%s"]`), e.defaultColorScheme === t) {
    if (t === "dark") {
      const l = {};
      return Ire(e.cssVarPrefix).forEach((u) => {
        l[u] = n[u], delete n[u];
      }), a === "media" ? {
        [r]: n,
        "@media (prefers-color-scheme: dark)": {
          [r]: l
        }
      } : a ? {
        [a.replace("%s", t)]: l,
        [`${r}, ${a.replace("%s", t)}`]: n
      } : {
        [r]: {
          ...n,
          ...l
        }
      };
    }
    if (a && a !== "media")
      return `${r}, ${a.replace("%s", String(t))}`;
  } else if (t) {
    if (a === "media")
      return {
        [`@media (prefers-color-scheme: ${String(t)})`]: {
          [r]: n
        }
      };
    if (a)
      return a.replace("%s", String(t));
  }
  return r;
};
function Vre(e, t) {
  t.forEach((n) => {
    e[n] || (e[n] = {});
  });
}
function se(e, t, n) {
  !e[t] && n && (e[t] = n);
}
function Gu(e) {
  return typeof e != "string" || !e.startsWith("hsl") ? e : Oj(e);
}
function To(e, t) {
  `${t}Channel` in e || (e[`${t}Channel`] = Xu(Gu(e[t])));
}
function Hre(e) {
  return typeof e == "number" ? `${e}px` : typeof e == "string" || typeof e == "function" || Array.isArray(e) ? e : "8px";
}
const qr = (e) => {
  try {
    return e();
  } catch {
  }
}, Ure = (e = "mui") => lre(e);
function Ov(e, t, n, r) {
  if (!t)
    return;
  t = t === !0 ? {} : t;
  const o = r === "dark" ? "dark" : "light";
  if (!n) {
    e[r] = Pre({
      ...t,
      palette: {
        mode: o,
        ...t?.palette
      }
    });
    return;
  }
  const {
    palette: a,
    ...l
  } = Gb({
    ...n,
    palette: {
      mode: o,
      ...t?.palette
    }
  });
  return e[r] = {
    ...t,
    palette: a,
    opacity: {
      ...jj(o),
      ...t?.opacity
    },
    overlays: t?.overlays || Dj(o)
  }, l;
}
function Fre(e = {}, ...t) {
  const {
    colorSchemes: n = {
      light: !0
    },
    defaultColorScheme: r,
    disableCssColorScheme: o = !1,
    cssVarPrefix: a = "mui",
    shouldSkipGeneratingVar: l = Lre,
    colorSchemeSelector: u = n.light && n.dark ? "media" : void 0,
    rootSelector: d = ":root",
    ...f
  } = e, p = Object.keys(n)[0], m = r || (n.light && p !== "light" ? "light" : p), g = Ure(a), {
    [m]: y,
    light: w,
    dark: v,
    ...x
  } = n, E = {
    ...x
  };
  let N = y;
  if ((m === "dark" && !("dark" in n) || m === "light" && !("light" in n)) && (N = !0), !N)
    throw new Error(Ia(21, m));
  const C = Ov(E, N, f, m);
  w && !E.light && Ov(E, w, void 0, "light"), v && !E.dark && Ov(E, v, void 0, "dark");
  let A = {
    defaultColorScheme: m,
    ...C,
    cssVarPrefix: a,
    colorSchemeSelector: u,
    rootSelector: d,
    getCssVar: g,
    colorSchemes: E,
    font: {
      ...wre(C.typography),
      ...C.font
    },
    spacing: Hre(f.spacing)
  };
  Object.keys(A.colorSchemes).forEach((F) => {
    const O = A.colorSchemes[F].palette, B = (U) => {
      const G = U.split("-"), z = G[1], $ = G[2];
      return g(U, O[z][$]);
    };
    if (O.mode === "light" && (se(O.common, "background", "#fff"), se(O.common, "onBackground", "#000")), O.mode === "dark" && (se(O.common, "background", "#000"), se(O.common, "onBackground", "#fff")), Vre(O, ["Alert", "AppBar", "Avatar", "Button", "Chip", "FilledInput", "LinearProgress", "Skeleton", "Slider", "SnackbarContent", "SpeedDialAction", "StepConnector", "StepContent", "Switch", "TableCell", "Tooltip"]), O.mode === "light") {
      se(O.Alert, "errorColor", pt(O.error.light, 0.6)), se(O.Alert, "infoColor", pt(O.info.light, 0.6)), se(O.Alert, "successColor", pt(O.success.light, 0.6)), se(O.Alert, "warningColor", pt(O.warning.light, 0.6)), se(O.Alert, "errorFilledBg", B("palette-error-main")), se(O.Alert, "infoFilledBg", B("palette-info-main")), se(O.Alert, "successFilledBg", B("palette-success-main")), se(O.Alert, "warningFilledBg", B("palette-warning-main")), se(O.Alert, "errorFilledColor", qr(() => O.getContrastText(O.error.main))), se(O.Alert, "infoFilledColor", qr(() => O.getContrastText(O.info.main))), se(O.Alert, "successFilledColor", qr(() => O.getContrastText(O.success.main))), se(O.Alert, "warningFilledColor", qr(() => O.getContrastText(O.warning.main))), se(O.Alert, "errorStandardBg", ht(O.error.light, 0.9)), se(O.Alert, "infoStandardBg", ht(O.info.light, 0.9)), se(O.Alert, "successStandardBg", ht(O.success.light, 0.9)), se(O.Alert, "warningStandardBg", ht(O.warning.light, 0.9)), se(O.Alert, "errorIconColor", B("palette-error-main")), se(O.Alert, "infoIconColor", B("palette-info-main")), se(O.Alert, "successIconColor", B("palette-success-main")), se(O.Alert, "warningIconColor", B("palette-warning-main")), se(O.AppBar, "defaultBg", B("palette-grey-100")), se(O.Avatar, "defaultBg", B("palette-grey-400")), se(O.Button, "inheritContainedBg", B("palette-grey-300")), se(O.Button, "inheritContainedHoverBg", B("palette-grey-A100")), se(O.Chip, "defaultBorder", B("palette-grey-400")), se(O.Chip, "defaultAvatarColor", B("palette-grey-700")), se(O.Chip, "defaultIconColor", B("palette-grey-700")), se(O.FilledInput, "bg", "rgba(0, 0, 0, 0.06)"), se(O.FilledInput, "hoverBg", "rgba(0, 0, 0, 0.09)"), se(O.FilledInput, "disabledBg", "rgba(0, 0, 0, 0.12)"), se(O.LinearProgress, "primaryBg", ht(O.primary.main, 0.62)), se(O.LinearProgress, "secondaryBg", ht(O.secondary.main, 0.62)), se(O.LinearProgress, "errorBg", ht(O.error.main, 0.62)), se(O.LinearProgress, "infoBg", ht(O.info.main, 0.62)), se(O.LinearProgress, "successBg", ht(O.success.main, 0.62)), se(O.LinearProgress, "warningBg", ht(O.warning.main, 0.62)), se(O.Skeleton, "bg", `rgba(${B("palette-text-primaryChannel")} / 0.11)`), se(O.Slider, "primaryTrack", ht(O.primary.main, 0.62)), se(O.Slider, "secondaryTrack", ht(O.secondary.main, 0.62)), se(O.Slider, "errorTrack", ht(O.error.main, 0.62)), se(O.Slider, "infoTrack", ht(O.info.main, 0.62)), se(O.Slider, "successTrack", ht(O.success.main, 0.62)), se(O.Slider, "warningTrack", ht(O.warning.main, 0.62));
      const U = Uf(O.background.default, 0.8);
      se(O.SnackbarContent, "bg", U), se(O.SnackbarContent, "color", qr(() => O.getContrastText(U))), se(O.SpeedDialAction, "fabHoverBg", Uf(O.background.paper, 0.15)), se(O.StepConnector, "border", B("palette-grey-400")), se(O.StepContent, "border", B("palette-grey-400")), se(O.Switch, "defaultColor", B("palette-common-white")), se(O.Switch, "defaultDisabledColor", B("palette-grey-100")), se(O.Switch, "primaryDisabledColor", ht(O.primary.main, 0.62)), se(O.Switch, "secondaryDisabledColor", ht(O.secondary.main, 0.62)), se(O.Switch, "errorDisabledColor", ht(O.error.main, 0.62)), se(O.Switch, "infoDisabledColor", ht(O.info.main, 0.62)), se(O.Switch, "successDisabledColor", ht(O.success.main, 0.62)), se(O.Switch, "warningDisabledColor", ht(O.warning.main, 0.62)), se(O.TableCell, "border", ht(Hf(O.divider, 1), 0.88)), se(O.Tooltip, "bg", Hf(O.grey[700], 0.92));
    }
    if (O.mode === "dark") {
      se(O.Alert, "errorColor", ht(O.error.light, 0.6)), se(O.Alert, "infoColor", ht(O.info.light, 0.6)), se(O.Alert, "successColor", ht(O.success.light, 0.6)), se(O.Alert, "warningColor", ht(O.warning.light, 0.6)), se(O.Alert, "errorFilledBg", B("palette-error-dark")), se(O.Alert, "infoFilledBg", B("palette-info-dark")), se(O.Alert, "successFilledBg", B("palette-success-dark")), se(O.Alert, "warningFilledBg", B("palette-warning-dark")), se(O.Alert, "errorFilledColor", qr(() => O.getContrastText(O.error.dark))), se(O.Alert, "infoFilledColor", qr(() => O.getContrastText(O.info.dark))), se(O.Alert, "successFilledColor", qr(() => O.getContrastText(O.success.dark))), se(O.Alert, "warningFilledColor", qr(() => O.getContrastText(O.warning.dark))), se(O.Alert, "errorStandardBg", pt(O.error.light, 0.9)), se(O.Alert, "infoStandardBg", pt(O.info.light, 0.9)), se(O.Alert, "successStandardBg", pt(O.success.light, 0.9)), se(O.Alert, "warningStandardBg", pt(O.warning.light, 0.9)), se(O.Alert, "errorIconColor", B("palette-error-main")), se(O.Alert, "infoIconColor", B("palette-info-main")), se(O.Alert, "successIconColor", B("palette-success-main")), se(O.Alert, "warningIconColor", B("palette-warning-main")), se(O.AppBar, "defaultBg", B("palette-grey-900")), se(O.AppBar, "darkBg", B("palette-background-paper")), se(O.AppBar, "darkColor", B("palette-text-primary")), se(O.Avatar, "defaultBg", B("palette-grey-600")), se(O.Button, "inheritContainedBg", B("palette-grey-800")), se(O.Button, "inheritContainedHoverBg", B("palette-grey-700")), se(O.Chip, "defaultBorder", B("palette-grey-700")), se(O.Chip, "defaultAvatarColor", B("palette-grey-300")), se(O.Chip, "defaultIconColor", B("palette-grey-300")), se(O.FilledInput, "bg", "rgba(255, 255, 255, 0.09)"), se(O.FilledInput, "hoverBg", "rgba(255, 255, 255, 0.13)"), se(O.FilledInput, "disabledBg", "rgba(255, 255, 255, 0.12)"), se(O.LinearProgress, "primaryBg", pt(O.primary.main, 0.5)), se(O.LinearProgress, "secondaryBg", pt(O.secondary.main, 0.5)), se(O.LinearProgress, "errorBg", pt(O.error.main, 0.5)), se(O.LinearProgress, "infoBg", pt(O.info.main, 0.5)), se(O.LinearProgress, "successBg", pt(O.success.main, 0.5)), se(O.LinearProgress, "warningBg", pt(O.warning.main, 0.5)), se(O.Skeleton, "bg", `rgba(${B("palette-text-primaryChannel")} / 0.13)`), se(O.Slider, "primaryTrack", pt(O.primary.main, 0.5)), se(O.Slider, "secondaryTrack", pt(O.secondary.main, 0.5)), se(O.Slider, "errorTrack", pt(O.error.main, 0.5)), se(O.Slider, "infoTrack", pt(O.info.main, 0.5)), se(O.Slider, "successTrack", pt(O.success.main, 0.5)), se(O.Slider, "warningTrack", pt(O.warning.main, 0.5));
      const U = Uf(O.background.default, 0.98);
      se(O.SnackbarContent, "bg", U), se(O.SnackbarContent, "color", qr(() => O.getContrastText(U))), se(O.SpeedDialAction, "fabHoverBg", Uf(O.background.paper, 0.15)), se(O.StepConnector, "border", B("palette-grey-600")), se(O.StepContent, "border", B("palette-grey-600")), se(O.Switch, "defaultColor", B("palette-grey-300")), se(O.Switch, "defaultDisabledColor", B("palette-grey-600")), se(O.Switch, "primaryDisabledColor", pt(O.primary.main, 0.55)), se(O.Switch, "secondaryDisabledColor", pt(O.secondary.main, 0.55)), se(O.Switch, "errorDisabledColor", pt(O.error.main, 0.55)), se(O.Switch, "infoDisabledColor", pt(O.info.main, 0.55)), se(O.Switch, "successDisabledColor", pt(O.success.main, 0.55)), se(O.Switch, "warningDisabledColor", pt(O.warning.main, 0.55)), se(O.TableCell, "border", pt(Hf(O.divider, 1), 0.68)), se(O.Tooltip, "bg", Hf(O.grey[700], 0.92));
    }
    To(O.background, "default"), To(O.background, "paper"), To(O.common, "background"), To(O.common, "onBackground"), To(O, "divider"), Object.keys(O).forEach((U) => {
      const G = O[U];
      U !== "tonalOffset" && G && typeof G == "object" && (G.main && se(O[U], "mainChannel", Xu(Gu(G.main))), G.light && se(O[U], "lightChannel", Xu(Gu(G.light))), G.dark && se(O[U], "darkChannel", Xu(Gu(G.dark))), G.contrastText && se(O[U], "contrastTextChannel", Xu(Gu(G.contrastText))), U === "text" && (To(O[U], "primary"), To(O[U], "secondary")), U === "action" && (G.active && To(O[U], "active"), G.selected && To(O[U], "selected")));
    });
  }), A = t.reduce((F, O) => tr(F, O), A);
  const R = {
    prefix: a,
    disableCssColorScheme: o,
    shouldSkipGeneratingVar: l,
    getSelector: Bre(A)
  }, {
    vars: D,
    generateThemeVars: T,
    generateStyleSheets: V
  } = cre(A, R);
  return A.vars = D, Object.entries(A.colorSchemes[A.defaultColorScheme]).forEach(([F, O]) => {
    A[F] = O;
  }), A.generateThemeVars = T, A.generateStyleSheets = V, A.generateSpacing = function() {
    return kj(f.spacing, Lx(this));
  }, A.getColorSchemeSelector = dre(u), A.spacing = A.generateSpacing(), A.shouldSkipGeneratingVar = l, A.unstable_sxConfig = {
    ...Wh,
    ...f?.unstable_sxConfig
  }, A.unstable_sx = function(F) {
    return ps({
      sx: F,
      theme: this
    });
  }, A.toRuntimeSource = Rj, A;
}
function $5(e, t, n) {
  e.colorSchemes && n && (e.colorSchemes[t] = {
    ...n !== !0 && n,
    palette: Xx({
      ...n === !0 ? {} : n.palette,
      mode: t
    })
    // cast type to skip module augmentation test
  });
}
function $re(e = {}, ...t) {
  const {
    palette: n,
    cssVariables: r = !1,
    colorSchemes: o = n ? void 0 : {
      light: !0
    },
    defaultColorScheme: a = n?.mode,
    ...l
  } = e, u = a || "light", d = o?.[u], f = {
    ...o,
    ...n ? {
      [u]: {
        ...typeof d != "boolean" && d,
        palette: n
      }
    } : void 0
  };
  if (r === !1) {
    if (!("colorSchemes" in e))
      return Gb(e, ...t);
    let p = n;
    "palette" in e || f[u] && (f[u] !== !0 ? p = f[u].palette : u === "dark" && (p = {
      mode: "dark"
    }));
    const m = Gb({
      ...e,
      palette: p
    }, ...t);
    return m.defaultColorScheme = u, m.colorSchemes = f, m.palette.mode === "light" && (m.colorSchemes.light = {
      ...f.light !== !0 && f.light,
      palette: m.palette
    }, $5(m, "dark", f.dark)), m.palette.mode === "dark" && (m.colorSchemes.dark = {
      ...f.dark !== !0 && f.dark,
      palette: m.palette
    }, $5(m, "light", f.light)), m;
  }
  return !n && !("light" in f) && u === "light" && (f.light = !0), Fre({
    ...l,
    colorSchemes: f,
    defaultColorScheme: u,
    ...typeof r != "boolean" && r
  }, ...t);
}
const Yre = $re(), qre = "$$material";
function Xre(e) {
  return e !== "ownerState" && e !== "theme" && e !== "sx" && e !== "as";
}
const Gre = (e) => Xre(e) && e !== "classes", br = Lne({
  themeId: qre,
  defaultTheme: Yre,
  rootShouldForwardProp: Gre
}), Es = are;
function po(e) {
  return ire(e);
}
function Zre(e) {
  return co("MuiTable", e);
}
fo("MuiTable", ["root", "stickyHeader"]);
const Wre = (e) => {
  const {
    classes: t,
    stickyHeader: n
  } = e;
  return Jo({
    root: ["root", n && "stickyHeader"]
  }, Zre, t);
}, Kre = br("table", {
  name: "MuiTable",
  slot: "Root",
  overridesResolver: (e, t) => {
    const {
      ownerState: n
    } = e;
    return [t.root, n.stickyHeader && t.stickyHeader];
  }
})(Es(({
  theme: e
}) => ({
  display: "table",
  width: "100%",
  borderCollapse: "collapse",
  borderSpacing: 0,
  "& caption": {
    ...e.typography.body2,
    padding: e.spacing(2),
    color: (e.vars || e).palette.text.secondary,
    textAlign: "left",
    captionSide: "bottom"
  },
  variants: [{
    props: ({
      ownerState: t
    }) => t.stickyHeader,
    style: {
      borderCollapse: "separate"
    }
  }]
}))), Y5 = "table", Qre = /* @__PURE__ */ _.forwardRef(function(e, t) {
  const n = po({
    props: e,
    name: "MuiTable"
  }), {
    className: r,
    component: o = Y5,
    padding: a = "normal",
    size: l = "medium",
    stickyHeader: u = !1,
    ...d
  } = n, f = {
    ...n,
    component: o,
    padding: a,
    size: l,
    stickyHeader: u
  }, p = Wre(f), m = _.useMemo(() => ({
    padding: a,
    size: l,
    stickyHeader: u
  }), [a, l, u]);
  return /* @__PURE__ */ k.jsx(oj.Provider, {
    value: m,
    children: /* @__PURE__ */ k.jsx(Kre, {
      as: o,
      role: o === Y5 ? null : "table",
      ref: t,
      className: Yt(p.root, r),
      ownerState: f,
      ...d
    })
  });
}), im = /* @__PURE__ */ _.createContext();
function Jre(e) {
  return co("MuiTableBody", e);
}
fo("MuiTableBody", ["root"]);
const eoe = (e) => {
  const {
    classes: t
  } = e;
  return Jo({
    root: ["root"]
  }, Jre, t);
}, toe = br("tbody", {
  name: "MuiTableBody",
  slot: "Root",
  overridesResolver: (e, t) => t.root
})({
  display: "table-row-group"
}), noe = {
  variant: "body"
}, q5 = "tbody", roe = /* @__PURE__ */ _.forwardRef(function(e, t) {
  const n = po({
    props: e,
    name: "MuiTableBody"
  }), {
    className: r,
    component: o = q5,
    ...a
  } = n, l = {
    ...n,
    component: o
  }, u = eoe(l);
  return /* @__PURE__ */ k.jsx(im.Provider, {
    value: noe,
    children: /* @__PURE__ */ k.jsx(toe, {
      className: Yt(u.root, r),
      as: o,
      ref: t,
      role: o === q5 ? null : "rowgroup",
      ownerState: l,
      ...a
    })
  });
});
function ooe(e) {
  return co("MuiTableCell", e);
}
const ioe = fo("MuiTableCell", ["root", "head", "body", "footer", "sizeSmall", "sizeMedium", "paddingCheckbox", "paddingNone", "alignLeft", "alignCenter", "alignRight", "alignJustify", "stickyHeader"]), aoe = (e) => {
  const {
    classes: t,
    variant: n,
    align: r,
    padding: o,
    size: a,
    stickyHeader: l
  } = e, u = {
    root: ["root", n, l && "stickyHeader", r !== "inherit" && `align${Sn(r)}`, o !== "normal" && `padding${Sn(o)}`, `size${Sn(a)}`]
  };
  return Jo(u, ooe, t);
}, loe = br("td", {
  name: "MuiTableCell",
  slot: "Root",
  overridesResolver: (e, t) => {
    const {
      ownerState: n
    } = e;
    return [t.root, t[n.variant], t[`size${Sn(n.size)}`], n.padding !== "normal" && t[`padding${Sn(n.padding)}`], n.align !== "inherit" && t[`align${Sn(n.align)}`], n.stickyHeader && t.stickyHeader];
  }
})(Es(({
  theme: e
}) => ({
  ...e.typography.body2,
  display: "table-cell",
  verticalAlign: "inherit",
  // Workaround for a rendering bug with spanned columns in Chrome 62.0.
  // Removes the alpha (sets it to 1), and lightens or darkens the theme color.
  borderBottom: e.vars ? `1px solid ${e.vars.palette.TableCell.border}` : `1px solid
    ${e.palette.mode === "light" ? om(Cc(e.palette.divider, 1), 0.88) : rm(Cc(e.palette.divider, 1), 0.68)}`,
  textAlign: "left",
  padding: 16,
  variants: [{
    props: {
      variant: "head"
    },
    style: {
      color: (e.vars || e).palette.text.primary,
      lineHeight: e.typography.pxToRem(24),
      fontWeight: e.typography.fontWeightMedium
    }
  }, {
    props: {
      variant: "body"
    },
    style: {
      color: (e.vars || e).palette.text.primary
    }
  }, {
    props: {
      variant: "footer"
    },
    style: {
      color: (e.vars || e).palette.text.secondary,
      lineHeight: e.typography.pxToRem(21),
      fontSize: e.typography.pxToRem(12)
    }
  }, {
    props: {
      size: "small"
    },
    style: {
      padding: "6px 16px",
      [`&.${ioe.paddingCheckbox}`]: {
        width: 24,
        // prevent the checkbox column from growing
        padding: "0 12px 0 16px",
        "& > *": {
          padding: 0
        }
      }
    }
  }, {
    props: {
      padding: "checkbox"
    },
    style: {
      width: 48,
      // prevent the checkbox column from growing
      padding: "0 0 0 4px"
    }
  }, {
    props: {
      padding: "none"
    },
    style: {
      padding: 0
    }
  }, {
    props: {
      align: "left"
    },
    style: {
      textAlign: "left"
    }
  }, {
    props: {
      align: "center"
    },
    style: {
      textAlign: "center"
    }
  }, {
    props: {
      align: "right"
    },
    style: {
      textAlign: "right",
      flexDirection: "row-reverse"
    }
  }, {
    props: {
      align: "justify"
    },
    style: {
      textAlign: "justify"
    }
  }, {
    props: ({
      ownerState: t
    }) => t.stickyHeader,
    style: {
      position: "sticky",
      top: 0,
      zIndex: 2,
      backgroundColor: (e.vars || e).palette.background.default
    }
  }]
}))), X5 = /* @__PURE__ */ _.forwardRef(function(e, t) {
  const n = po({
    props: e,
    name: "MuiTableCell"
  }), {
    align: r = "inherit",
    className: o,
    component: a,
    padding: l,
    scope: u,
    size: d,
    sortDirection: f,
    variant: p,
    ...m
  } = n, g = _.useContext(oj), y = _.useContext(im), w = y && y.variant === "head";
  let v;
  a ? v = a : v = w ? "th" : "td";
  let x = u;
  v === "td" ? x = void 0 : !x && w && (x = "col");
  const E = p || y && y.variant, N = {
    ...n,
    align: r,
    component: v,
    padding: l || (g && g.padding ? g.padding : "normal"),
    size: d || (g && g.size ? g.size : "medium"),
    sortDirection: f,
    stickyHeader: E === "head" && g && g.stickyHeader,
    variant: E
  }, C = aoe(N);
  let A = null;
  return f && (A = f === "asc" ? "ascending" : "descending"), /* @__PURE__ */ k.jsx(loe, {
    as: v,
    ref: t,
    className: Yt(C.root, o),
    "aria-sort": A,
    scope: x,
    ownerState: N,
    ...m
  });
});
function soe(e) {
  return co("MuiTableContainer", e);
}
fo("MuiTableContainer", ["root"]);
const uoe = (e) => {
  const {
    classes: t
  } = e;
  return Jo({
    root: ["root"]
  }, soe, t);
}, coe = br("div", {
  name: "MuiTableContainer",
  slot: "Root",
  overridesResolver: (e, t) => t.root
})({
  width: "100%",
  overflowX: "auto"
}), doe = /* @__PURE__ */ _.forwardRef(function(e, t) {
  const n = po({
    props: e,
    name: "MuiTableContainer"
  }), {
    className: r,
    component: o = "div",
    ...a
  } = n, l = {
    ...n,
    component: o
  }, u = uoe(l);
  return /* @__PURE__ */ k.jsx(coe, {
    ref: t,
    as: o,
    className: Yt(u.root, r),
    ownerState: l,
    ...a
  });
});
function foe(e) {
  return co("MuiTableHead", e);
}
fo("MuiTableHead", ["root"]);
const poe = (e) => {
  const {
    classes: t
  } = e;
  return Jo({
    root: ["root"]
  }, foe, t);
}, hoe = br("thead", {
  name: "MuiTableHead",
  slot: "Root",
  overridesResolver: (e, t) => t.root
})({
  display: "table-header-group"
}), moe = {
  variant: "head"
}, G5 = "thead", goe = /* @__PURE__ */ _.forwardRef(function(e, t) {
  const n = po({
    props: e,
    name: "MuiTableHead"
  }), {
    className: r,
    component: o = G5,
    ...a
  } = n, l = {
    ...n,
    component: o
  }, u = poe(l);
  return /* @__PURE__ */ k.jsx(im.Provider, {
    value: moe,
    children: /* @__PURE__ */ k.jsx(hoe, {
      as: o,
      className: Yt(u.root, r),
      ref: t,
      role: o === G5 ? null : "rowgroup",
      ownerState: l,
      ...a
    })
  });
});
function yoe(e) {
  return co("MuiTableRow", e);
}
const Z5 = fo("MuiTableRow", ["root", "selected", "hover", "head", "footer"]), voe = (e) => {
  const {
    classes: t,
    selected: n,
    hover: r,
    head: o,
    footer: a
  } = e;
  return Jo({
    root: ["root", n && "selected", r && "hover", o && "head", a && "footer"]
  }, yoe, t);
}, boe = br("tr", {
  name: "MuiTableRow",
  slot: "Root",
  overridesResolver: (e, t) => {
    const {
      ownerState: n
    } = e;
    return [t.root, n.head && t.head, n.footer && t.footer];
  }
})(Es(({
  theme: e
}) => ({
  color: "inherit",
  display: "table-row",
  verticalAlign: "middle",
  // We disable the focus ring for mouse, touch and keyboard users.
  outline: 0,
  [`&.${Z5.hover}:hover`]: {
    backgroundColor: (e.vars || e).palette.action.hover
  },
  [`&.${Z5.selected}`]: {
    backgroundColor: e.vars ? `rgba(${e.vars.palette.primary.mainChannel} / ${e.vars.palette.action.selectedOpacity})` : Cc(e.palette.primary.main, e.palette.action.selectedOpacity),
    "&:hover": {
      backgroundColor: e.vars ? `rgba(${e.vars.palette.primary.mainChannel} / calc(${e.vars.palette.action.selectedOpacity} + ${e.vars.palette.action.hoverOpacity}))` : Cc(e.palette.primary.main, e.palette.action.selectedOpacity + e.palette.action.hoverOpacity)
    }
  }
}))), W5 = "tr", K5 = /* @__PURE__ */ _.forwardRef(function(e, t) {
  const n = po({
    props: e,
    name: "MuiTableRow"
  }), {
    className: r,
    component: o = W5,
    hover: a = !1,
    selected: l = !1,
    ...u
  } = n, d = _.useContext(im), f = {
    ...n,
    component: o,
    hover: a,
    selected: l,
    head: d && d.variant === "head",
    footer: d && d.variant === "footer"
  }, p = voe(f);
  return /* @__PURE__ */ k.jsx(boe, {
    as: o,
    ref: t,
    className: Yt(p.root, r),
    role: o === W5 ? null : "row",
    ownerState: f,
    ...u
  });
});
class qp {
  constructor() {
    Zf(this, "mountEffect", () => {
      this.shouldMount && !this.didMount && this.ref.current !== null && (this.didMount = !0, this.mounted.resolve());
    }), this.ref = {
      current: null
    }, this.mounted = null, this.didMount = !1, this.shouldMount = !1, this.setShouldMount = null;
  }
  /** React ref to the ripple instance */
  /** If the ripple component should be mounted */
  /** Promise that resolves when the ripple component is mounted */
  /** If the ripple component has been mounted */
  /** React state hook setter */
  static create() {
    return new qp();
  }
  static use() {
    const t = Nj(qp.create).current, [n, r] = _.useState(!1);
    return t.shouldMount = n, t.setShouldMount = r, _.useEffect(t.mountEffect, [n]), t;
  }
  mount() {
    return this.mounted || (this.mounted = xoe(), this.shouldMount = !0, this.setShouldMount(this.shouldMount)), this.mounted;
  }
  /* Ripple API */
  start(...t) {
    this.mount().then(() => {
      var n;
      return (n = this.ref.current) == null ? void 0 : n.start(...t);
    });
  }
  stop(...t) {
    this.mount().then(() => {
      var n;
      return (n = this.ref.current) == null ? void 0 : n.stop(...t);
    });
  }
  pulsate(...t) {
    this.mount().then(() => {
      var n;
      return (n = this.ref.current) == null ? void 0 : n.pulsate(...t);
    });
  }
}
function woe() {
  return qp.use();
}
function xoe() {
  let e, t;
  const n = new Promise((r, o) => {
    e = r, t = o;
  });
  return n.resolve = e, n.reject = t, n;
}
function Gx(e, t) {
  if (e == null) return {};
  var n = {};
  for (var r in e) if ({}.hasOwnProperty.call(e, r)) {
    if (t.indexOf(r) !== -1) continue;
    n[r] = e[r];
  }
  return n;
}
function Xp(e, t) {
  return Xp = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(n, r) {
    return n.__proto__ = r, n;
  }, Xp(e, t);
}
function Tj(e, t) {
  e.prototype = Object.create(t.prototype), e.prototype.constructor = e, Xp(e, t);
}
const Q5 = $t.createContext(null);
function zj(e) {
  if (e === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return e;
}
function Zx(e, t) {
  var n = function(o) {
    return t && _.isValidElement(o) ? t(o) : o;
  }, r = /* @__PURE__ */ Object.create(null);
  return e && _.Children.map(e, function(o) {
    return o;
  }).forEach(function(o) {
    r[o.key] = n(o);
  }), r;
}
function Soe(e, t) {
  e = e || {}, t = t || {};
  function n(p) {
    return p in t ? t[p] : e[p];
  }
  var r = /* @__PURE__ */ Object.create(null), o = [];
  for (var a in e)
    a in t ? o.length && (r[a] = o, o = []) : o.push(a);
  var l, u = {};
  for (var d in t) {
    if (r[d])
      for (l = 0; l < r[d].length; l++) {
        var f = r[d][l];
        u[r[d][l]] = n(f);
      }
    u[d] = n(d);
  }
  for (l = 0; l < o.length; l++)
    u[o[l]] = n(o[l]);
  return u;
}
function _a(e, t, n) {
  return n[t] != null ? n[t] : e.props[t];
}
function koe(e, t) {
  return Zx(e.children, function(n) {
    return _.cloneElement(n, {
      onExited: t.bind(null, n),
      in: !0,
      appear: _a(n, "appear", e),
      enter: _a(n, "enter", e),
      exit: _a(n, "exit", e)
    });
  });
}
function _oe(e, t, n) {
  var r = Zx(e.children), o = Soe(t, r);
  return Object.keys(o).forEach(function(a) {
    var l = o[a];
    if (_.isValidElement(l)) {
      var u = a in t, d = a in r, f = t[a], p = _.isValidElement(f) && !f.props.in;
      d && (!u || p) ? o[a] = _.cloneElement(l, {
        onExited: n.bind(null, l),
        in: !0,
        exit: _a(l, "exit", e),
        enter: _a(l, "enter", e)
      }) : !d && u && !p ? o[a] = _.cloneElement(l, {
        in: !1
      }) : d && u && _.isValidElement(f) && (o[a] = _.cloneElement(l, {
        onExited: n.bind(null, l),
        in: f.props.in,
        exit: _a(l, "exit", e),
        enter: _a(l, "enter", e)
      }));
    }
  }), o;
}
var Eoe = Object.values || function(e) {
  return Object.keys(e).map(function(t) {
    return e[t];
  });
}, Coe = {
  component: "div",
  childFactory: function(e) {
    return e;
  }
}, Wx = /* @__PURE__ */ function(e) {
  Tj(t, e);
  function t(r, o) {
    var a;
    a = e.call(this, r, o) || this;
    var l = a.handleExited.bind(zj(a));
    return a.state = {
      contextValue: {
        isMounting: !0
      },
      handleExited: l,
      firstRender: !0
    }, a;
  }
  var n = t.prototype;
  return n.componentDidMount = function() {
    this.mounted = !0, this.setState({
      contextValue: {
        isMounting: !1
      }
    });
  }, n.componentWillUnmount = function() {
    this.mounted = !1;
  }, t.getDerivedStateFromProps = function(r, o) {
    var a = o.children, l = o.handleExited, u = o.firstRender;
    return {
      children: u ? koe(r, l) : _oe(r, a, l),
      firstRender: !1
    };
  }, n.handleExited = function(r, o) {
    var a = Zx(this.props.children);
    r.key in a || (r.props.onExited && r.props.onExited(o), this.mounted && this.setState(function(l) {
      var u = Ne({}, l.children);
      return delete u[r.key], {
        children: u
      };
    }));
  }, n.render = function() {
    var r = this.props, o = r.component, a = r.childFactory, l = Gx(r, ["component", "childFactory"]), u = this.state.contextValue, d = Eoe(this.state.children).map(a);
    return delete l.appear, delete l.enter, delete l.exit, o === null ? /* @__PURE__ */ $t.createElement(Q5.Provider, {
      value: u
    }, d) : /* @__PURE__ */ $t.createElement(Q5.Provider, {
      value: u
    }, /* @__PURE__ */ $t.createElement(o, l, d));
  }, t;
}($t.Component);
Wx.propTypes = {};
Wx.defaultProps = Coe;
function Ooe(e) {
  const {
    className: t,
    classes: n,
    pulsate: r = !1,
    rippleX: o,
    rippleY: a,
    rippleSize: l,
    in: u,
    onExited: d,
    timeout: f
  } = e, [p, m] = _.useState(!1), g = Yt(t, n.ripple, n.rippleVisible, r && n.ripplePulsate), y = {
    width: l,
    height: l,
    top: -(l / 2) + a,
    left: -(l / 2) + o
  }, w = Yt(n.child, p && n.childLeaving, r && n.childPulsate);
  return !u && !p && m(!0), _.useEffect(() => {
    if (!u && d != null) {
      const v = setTimeout(d, f);
      return () => {
        clearTimeout(v);
      };
    }
  }, [d, u, f]), /* @__PURE__ */ k.jsx("span", {
    className: g,
    style: y,
    children: /* @__PURE__ */ k.jsx("span", {
      className: w
    })
  });
}
const pr = fo("MuiTouchRipple", ["root", "ripple", "rippleVisible", "ripplePulsate", "child", "childLeaving", "childPulsate"]), Zb = 550, Noe = 80, Moe = tm`
  0% {
    transform: scale(0);
    opacity: 0.1;
  }

  100% {
    transform: scale(1);
    opacity: 0.3;
  }
`, Aoe = tm`
  0% {
    opacity: 1;
  }

  100% {
    opacity: 0;
  }
`, Roe = tm`
  0% {
    transform: scale(1);
  }

  50% {
    transform: scale(0.92);
  }

  100% {
    transform: scale(1);
  }
`, joe = br("span", {
  name: "MuiTouchRipple",
  slot: "Root"
})({
  overflow: "hidden",
  pointerEvents: "none",
  position: "absolute",
  zIndex: 0,
  top: 0,
  right: 0,
  bottom: 0,
  left: 0,
  borderRadius: "inherit"
}), Doe = br(Ooe, {
  name: "MuiTouchRipple",
  slot: "Ripple"
})`
  opacity: 0;
  position: absolute;

  &.${pr.rippleVisible} {
    opacity: 0.3;
    transform: scale(1);
    animation-name: ${Moe};
    animation-duration: ${Zb}ms;
    animation-timing-function: ${({
  theme: e
}) => e.transitions.easing.easeInOut};
  }

  &.${pr.ripplePulsate} {
    animation-duration: ${({
  theme: e
}) => e.transitions.duration.shorter}ms;
  }

  & .${pr.child} {
    opacity: 1;
    display: block;
    width: 100%;
    height: 100%;
    border-radius: 50%;
    background-color: currentColor;
  }

  & .${pr.childLeaving} {
    opacity: 0;
    animation-name: ${Aoe};
    animation-duration: ${Zb}ms;
    animation-timing-function: ${({
  theme: e
}) => e.transitions.easing.easeInOut};
  }

  & .${pr.childPulsate} {
    position: absolute;
    /* @noflip */
    left: 0px;
    top: 0;
    animation-name: ${Roe};
    animation-duration: 2500ms;
    animation-timing-function: ${({
  theme: e
}) => e.transitions.easing.easeInOut};
    animation-iteration-count: infinite;
    animation-delay: 200ms;
  }
`, Toe = /* @__PURE__ */ _.forwardRef(function(e, t) {
  const n = po({
    props: e,
    name: "MuiTouchRipple"
  }), {
    center: r = !1,
    classes: o = {},
    className: a,
    ...l
  } = n, [u, d] = _.useState([]), f = _.useRef(0), p = _.useRef(null);
  _.useEffect(() => {
    p.current && (p.current(), p.current = null);
  }, [u]);
  const m = _.useRef(!1), g = Kne(), y = _.useRef(null), w = _.useRef(null), v = _.useCallback((C) => {
    const {
      pulsate: A,
      rippleX: R,
      rippleY: D,
      rippleSize: T,
      cb: V
    } = C;
    d((F) => [...F, /* @__PURE__ */ k.jsx(Doe, {
      classes: {
        ripple: Yt(o.ripple, pr.ripple),
        rippleVisible: Yt(o.rippleVisible, pr.rippleVisible),
        ripplePulsate: Yt(o.ripplePulsate, pr.ripplePulsate),
        child: Yt(o.child, pr.child),
        childLeaving: Yt(o.childLeaving, pr.childLeaving),
        childPulsate: Yt(o.childPulsate, pr.childPulsate)
      },
      timeout: Zb,
      pulsate: A,
      rippleX: R,
      rippleY: D,
      rippleSize: T
    }, f.current)]), f.current += 1, p.current = V;
  }, [o]), x = _.useCallback((C = {}, A = {}, R = () => {
  }) => {
    const {
      pulsate: D = !1,
      center: T = r || A.pulsate,
      fakeElement: V = !1
      // For test purposes
    } = A;
    if (C?.type === "mousedown" && m.current) {
      m.current = !1;
      return;
    }
    C?.type === "touchstart" && (m.current = !0);
    const F = V ? null : w.current, O = F ? F.getBoundingClientRect() : {
      width: 0,
      height: 0,
      left: 0,
      top: 0
    };
    let B, U, G;
    if (T || C === void 0 || C.clientX === 0 && C.clientY === 0 || !C.clientX && !C.touches)
      B = Math.round(O.width / 2), U = Math.round(O.height / 2);
    else {
      const {
        clientX: z,
        clientY: $
      } = C.touches && C.touches.length > 0 ? C.touches[0] : C;
      B = Math.round(z - O.left), U = Math.round($ - O.top);
    }
    if (T)
      G = Math.sqrt((2 * O.width ** 2 + O.height ** 2) / 3), G % 2 === 0 && (G += 1);
    else {
      const z = Math.max(Math.abs((F ? F.clientWidth : 0) - B), B) * 2 + 2, $ = Math.max(Math.abs((F ? F.clientHeight : 0) - U), U) * 2 + 2;
      G = Math.sqrt(z ** 2 + $ ** 2);
    }
    C != null && C.touches ? y.current === null && (y.current = () => {
      v({
        pulsate: D,
        rippleX: B,
        rippleY: U,
        rippleSize: G,
        cb: R
      });
    }, g.start(Noe, () => {
      y.current && (y.current(), y.current = null);
    })) : v({
      pulsate: D,
      rippleX: B,
      rippleY: U,
      rippleSize: G,
      cb: R
    });
  }, [r, v, g]), E = _.useCallback(() => {
    x({}, {
      pulsate: !0
    });
  }, [x]), N = _.useCallback((C, A) => {
    if (g.clear(), C?.type === "touchend" && y.current) {
      y.current(), y.current = null, g.start(0, () => {
        N(C, A);
      });
      return;
    }
    y.current = null, d((R) => R.length > 0 ? R.slice(1) : R), p.current = A;
  }, [g]);
  return _.useImperativeHandle(t, () => ({
    pulsate: E,
    start: x,
    stop: N
  }), [E, x, N]), /* @__PURE__ */ k.jsx(joe, {
    className: Yt(pr.root, o.root, a),
    ref: w,
    ...l,
    children: /* @__PURE__ */ k.jsx(Wx, {
      component: null,
      exit: !0,
      children: u
    })
  });
});
function zoe(e) {
  return co("MuiButtonBase", e);
}
const Poe = fo("MuiButtonBase", ["root", "disabled", "focusVisible"]), Loe = (e) => {
  const {
    disabled: t,
    focusVisible: n,
    focusVisibleClassName: r,
    classes: o
  } = e, a = Jo({
    root: ["root", t && "disabled", n && "focusVisible"]
  }, zoe, o);
  return n && r && (a.root += ` ${r}`), a;
}, Ioe = br("button", {
  name: "MuiButtonBase",
  slot: "Root",
  overridesResolver: (e, t) => t.root
})({
  display: "inline-flex",
  alignItems: "center",
  justifyContent: "center",
  position: "relative",
  boxSizing: "border-box",
  WebkitTapHighlightColor: "transparent",
  backgroundColor: "transparent",
  // Reset default value
  // We disable the focus ring for mouse, touch and keyboard users.
  outline: 0,
  border: 0,
  margin: 0,
  // Remove the margin in Safari
  borderRadius: 0,
  padding: 0,
  // Remove the padding in Firefox
  cursor: "pointer",
  userSelect: "none",
  verticalAlign: "middle",
  MozAppearance: "none",
  // Reset
  WebkitAppearance: "none",
  // Reset
  textDecoration: "none",
  // So we take precedent over the style of a native <a /> element.
  color: "inherit",
  "&::-moz-focus-inner": {
    borderStyle: "none"
    // Remove Firefox dotted outline.
  },
  [`&.${Poe.disabled}`]: {
    pointerEvents: "none",
    // Disable link interactions
    cursor: "default"
  },
  "@media print": {
    colorAdjust: "exact"
  }
}), Boe = /* @__PURE__ */ _.forwardRef(function(e, t) {
  const n = po({
    props: e,
    name: "MuiButtonBase"
  }), {
    action: r,
    centerRipple: o = !1,
    children: a,
    className: l,
    component: u = "button",
    disabled: d = !1,
    disableRipple: f = !1,
    disableTouchRipple: p = !1,
    focusRipple: m = !1,
    focusVisibleClassName: g,
    LinkComponent: y = "a",
    onBlur: w,
    onClick: v,
    onContextMenu: x,
    onDragLeave: E,
    onFocus: N,
    onFocusVisible: C,
    onKeyDown: A,
    onKeyUp: R,
    onMouseDown: D,
    onMouseLeave: T,
    onMouseUp: V,
    onTouchEnd: F,
    onTouchMove: O,
    onTouchStart: B,
    tabIndex: U = 0,
    TouchRippleProps: G,
    touchRippleRef: z,
    type: $,
    ...L
  } = n, H = _.useRef(null), q = woe(), Y = Xb(q.ref, z), [M, X] = _.useState(!1);
  d && M && X(!1), _.useImperativeHandle(r, () => ({
    focusVisible: () => {
      X(!0), H.current.focus();
    }
  }), []);
  const Q = q.shouldMount && !f && !d;
  _.useEffect(() => {
    M && m && !f && q.pulsate();
  }, [f, m, M, q]);
  const P = zo(q, "start", D, p), te = zo(q, "stop", x, p), ie = zo(q, "stop", E, p), ae = zo(q, "stop", V, p), fe = zo(q, "stop", (je) => {
    M && je.preventDefault(), T && T(je);
  }, p), he = zo(q, "start", B, p), ye = zo(q, "stop", F, p), Ee = zo(q, "stop", O, p), we = zo(q, "stop", (je) => {
    z5(je.target) || X(!1), w && w(je);
  }, !1), xe = hp((je) => {
    H.current || (H.current = je.currentTarget), z5(je.target) && (X(!0), C && C(je)), N && N(je);
  }), Pe = () => {
    const je = H.current;
    return u && u !== "button" && !(je.tagName === "A" && je.href);
  }, Ve = hp((je) => {
    m && !je.repeat && M && je.key === " " && q.stop(je, () => {
      q.start(je);
    }), je.target === je.currentTarget && Pe() && je.key === " " && je.preventDefault(), A && A(je), je.target === je.currentTarget && Pe() && je.key === "Enter" && !d && (je.preventDefault(), v && v(je));
  }), Rt = hp((je) => {
    m && je.key === " " && M && !je.defaultPrevented && q.stop(je, () => {
      q.pulsate(je);
    }), R && R(je), v && je.target === je.currentTarget && Pe() && je.key === " " && !je.defaultPrevented && v(je);
  });
  let Pt = u;
  Pt === "button" && (L.href || L.to) && (Pt = y);
  const lt = {};
  Pt === "button" ? (lt.type = $ === void 0 ? "button" : $, lt.disabled = d) : (!L.href && !L.to && (lt.role = "button"), d && (lt["aria-disabled"] = d));
  const wr = Xb(t, H), en = {
    ...n,
    centerRipple: o,
    component: u,
    disabled: d,
    disableRipple: f,
    disableTouchRipple: p,
    focusRipple: m,
    tabIndex: U,
    focusVisible: M
  }, Bn = Loe(en);
  return /* @__PURE__ */ k.jsxs(Ioe, {
    as: Pt,
    className: Yt(Bn.root, l),
    ownerState: en,
    onBlur: we,
    onClick: v,
    onContextMenu: te,
    onFocus: xe,
    onKeyDown: Ve,
    onKeyUp: Rt,
    onMouseDown: P,
    onMouseLeave: fe,
    onMouseUp: ae,
    onDragLeave: ie,
    onTouchEnd: ye,
    onTouchMove: Ee,
    onTouchStart: he,
    ref: wr,
    tabIndex: d ? -1 : U,
    type: $,
    ...lt,
    ...L,
    children: [a, Q ? /* @__PURE__ */ k.jsx(Toe, {
      ref: Y,
      center: o,
      ...G
    }) : null]
  });
});
function zo(e, t, n, r = !1) {
  return hp((o) => (n && n(o), r || e[t](o), !0));
}
function Voe(e) {
  return co("MuiSvgIcon", e);
}
fo("MuiSvgIcon", ["root", "colorPrimary", "colorSecondary", "colorAction", "colorError", "colorDisabled", "fontSizeInherit", "fontSizeSmall", "fontSizeMedium", "fontSizeLarge"]);
const Hoe = (e) => {
  const {
    color: t,
    fontSize: n,
    classes: r
  } = e, o = {
    root: ["root", t !== "inherit" && `color${Sn(t)}`, `fontSize${Sn(n)}`]
  };
  return Jo(o, Voe, r);
}, Uoe = br("svg", {
  name: "MuiSvgIcon",
  slot: "Root",
  overridesResolver: (e, t) => {
    const {
      ownerState: n
    } = e;
    return [t.root, n.color !== "inherit" && t[`color${Sn(n.color)}`], t[`fontSize${Sn(n.fontSize)}`]];
  }
})(Es(({
  theme: e
}) => {
  var t, n, r, o, a, l, u, d, f, p, m, g, y, w;
  return {
    userSelect: "none",
    width: "1em",
    height: "1em",
    display: "inline-block",
    flexShrink: 0,
    transition: (o = (t = e.transitions) == null ? void 0 : t.create) == null ? void 0 : o.call(t, "fill", {
      duration: (r = (n = (e.vars ?? e).transitions) == null ? void 0 : n.duration) == null ? void 0 : r.shorter
    }),
    variants: [
      {
        props: (v) => !v.hasSvgAsChild,
        style: {
          // the <svg> will define the property that has `currentColor`
          // for example heroicons uses fill="none" and stroke="currentColor"
          fill: "currentColor"
        }
      },
      {
        props: {
          fontSize: "inherit"
        },
        style: {
          fontSize: "inherit"
        }
      },
      {
        props: {
          fontSize: "small"
        },
        style: {
          fontSize: ((l = (a = e.typography) == null ? void 0 : a.pxToRem) == null ? void 0 : l.call(a, 20)) || "1.25rem"
        }
      },
      {
        props: {
          fontSize: "medium"
        },
        style: {
          fontSize: ((d = (u = e.typography) == null ? void 0 : u.pxToRem) == null ? void 0 : d.call(u, 24)) || "1.5rem"
        }
      },
      {
        props: {
          fontSize: "large"
        },
        style: {
          fontSize: ((p = (f = e.typography) == null ? void 0 : f.pxToRem) == null ? void 0 : p.call(f, 35)) || "2.1875rem"
        }
      },
      // TODO v5 deprecate color prop, v6 remove for sx
      ...Object.entries((e.vars ?? e).palette).filter(([, v]) => v && v.main).map(([v]) => {
        var x, E;
        return {
          props: {
            color: v
          },
          style: {
            color: (E = (x = (e.vars ?? e).palette) == null ? void 0 : x[v]) == null ? void 0 : E.main
          }
        };
      }),
      {
        props: {
          color: "action"
        },
        style: {
          color: (g = (m = (e.vars ?? e).palette) == null ? void 0 : m.action) == null ? void 0 : g.active
        }
      },
      {
        props: {
          color: "disabled"
        },
        style: {
          color: (w = (y = (e.vars ?? e).palette) == null ? void 0 : y.action) == null ? void 0 : w.disabled
        }
      },
      {
        props: {
          color: "inherit"
        },
        style: {
          color: void 0
        }
      }
    ]
  };
})), Wb = /* @__PURE__ */ _.forwardRef(function(e, t) {
  const n = po({
    props: e,
    name: "MuiSvgIcon"
  }), {
    children: r,
    className: o,
    color: a = "inherit",
    component: l = "svg",
    fontSize: u = "medium",
    htmlColor: d,
    inheritViewBox: f = !1,
    titleAccess: p,
    viewBox: m = "0 0 24 24",
    ...g
  } = n, y = /* @__PURE__ */ _.isValidElement(r) && r.type === "svg", w = {
    ...n,
    color: a,
    component: l,
    fontSize: u,
    instanceFontSize: e.fontSize,
    inheritViewBox: f,
    viewBox: m,
    hasSvgAsChild: y
  }, v = {};
  f || (v.viewBox = m);
  const x = Hoe(w);
  return /* @__PURE__ */ k.jsxs(Uoe, {
    as: l,
    className: Yt(x.root, o),
    focusable: "false",
    color: d,
    "aria-hidden": p ? void 0 : !0,
    role: p ? "img" : void 0,
    ref: t,
    ...v,
    ...g,
    ...y && r.props,
    ownerState: w,
    children: [y ? r.props.children : r, p ? /* @__PURE__ */ k.jsx("title", {
      children: p
    }) : null]
  });
});
Wb.muiName = "SvgIcon";
function Foe(e, t) {
  function n(r, o) {
    return /* @__PURE__ */ k.jsx(Wb, {
      "data-testid": void 0,
      ref: o,
      ...r,
      children: e
    });
  }
  return n.muiName = Wb.muiName, /* @__PURE__ */ _.memo(/* @__PURE__ */ _.forwardRef(n));
}
const $oe = Foe(/* @__PURE__ */ k.jsx("path", {
  d: "M20 12l-1.41-1.41L13 16.17V4h-2v12.17l-5.58-5.59L4 12l8 8 8-8z"
}));
function Yoe(e) {
  return co("MuiTableSortLabel", e);
}
const Nv = fo("MuiTableSortLabel", ["root", "active", "icon", "iconDirectionDesc", "iconDirectionAsc", "directionDesc", "directionAsc"]);
function J5(e, t) {
  const {
    className: n,
    elementType: r,
    ownerState: o,
    externalForwardedProps: a,
    internalForwardedProps: l,
    shouldForwardComponentProp: u = !1,
    ...d
  } = t, {
    component: f,
    slots: p = {
      [e]: void 0
    },
    slotProps: m = {
      [e]: void 0
    },
    ...g
  } = a, y = p[e] || r, w = nre(m[e], o), {
    props: {
      component: v,
      ...x
    },
    internalRef: E
  } = tre({
    className: n,
    ...d,
    externalForwardedProps: e === "root" ? g : void 0,
    externalSlotProps: w
  }), N = Xb(E, w?.ref, t.ref), C = e === "root" ? v || f : v, A = Jne(y, {
    ...e === "root" && !f && !p[e] && l,
    ...e !== "root" && !p[e] && l,
    ...x,
    ...C && !u && {
      as: C
    },
    ...C && u && {
      component: C
    },
    ref: N
  }, o);
  return [y, A];
}
const qoe = (e) => {
  const {
    classes: t,
    direction: n,
    active: r
  } = e, o = {
    root: ["root", r && "active", `direction${Sn(n)}`],
    icon: ["icon", `iconDirection${Sn(n)}`]
  };
  return Jo(o, Yoe, t);
}, Xoe = br(Boe, {
  name: "MuiTableSortLabel",
  slot: "Root",
  overridesResolver: (e, t) => {
    const {
      ownerState: n
    } = e;
    return [t.root, n.active && t.active];
  }
})(Es(({
  theme: e
}) => ({
  cursor: "pointer",
  display: "inline-flex",
  justifyContent: "flex-start",
  flexDirection: "inherit",
  alignItems: "center",
  "&:focus": {
    color: (e.vars || e).palette.text.secondary
  },
  "&:hover": {
    color: (e.vars || e).palette.text.secondary,
    [`& .${Nv.icon}`]: {
      opacity: 0.5
    }
  },
  [`&.${Nv.active}`]: {
    color: (e.vars || e).palette.text.primary,
    [`& .${Nv.icon}`]: {
      opacity: 1,
      color: (e.vars || e).palette.text.secondary
    }
  }
}))), Goe = br("span", {
  name: "MuiTableSortLabel",
  slot: "Icon",
  overridesResolver: (e, t) => {
    const {
      ownerState: n
    } = e;
    return [t.icon, t[`iconDirection${Sn(n.direction)}`]];
  }
})(Es(({
  theme: e
}) => ({
  fontSize: 18,
  marginRight: 4,
  marginLeft: 4,
  opacity: 0,
  transition: e.transitions.create(["opacity", "transform"], {
    duration: e.transitions.duration.shorter
  }),
  userSelect: "none",
  variants: [{
    props: {
      direction: "desc"
    },
    style: {
      transform: "rotate(0deg)"
    }
  }, {
    props: {
      direction: "asc"
    },
    style: {
      transform: "rotate(180deg)"
    }
  }]
}))), Zoe = /* @__PURE__ */ _.forwardRef(function(e, t) {
  const n = po({
    props: e,
    name: "MuiTableSortLabel"
  }), {
    active: r = !1,
    children: o,
    className: a,
    direction: l = "asc",
    hideSortIcon: u = !1,
    IconComponent: d = $oe,
    slots: f = {},
    slotProps: p = {},
    ...m
  } = n, g = {
    ...n,
    active: r,
    direction: l,
    hideSortIcon: u,
    IconComponent: d
  }, y = qoe(g), w = {
    slots: f,
    slotProps: p
  }, [v, x] = J5("root", {
    elementType: Xoe,
    externalForwardedProps: w,
    ownerState: g,
    className: Yt(y.root, a),
    ref: t
  }), [E, N] = J5("icon", {
    elementType: Goe,
    externalForwardedProps: w,
    ownerState: g,
    className: y.icon
  });
  return /* @__PURE__ */ k.jsxs(v, {
    disableRipple: !0,
    component: "span",
    ...x,
    ...m,
    children: [o, u && !r ? null : /* @__PURE__ */ k.jsx(E, {
      as: d,
      ...N
    })]
  });
}), Woe = (e) => {
  const t = [];
  if (e === void 0)
    return {
      header: [],
      rows: []
    };
  e.data === void 0 && (e.data = []), e.columns === void 0 && (e.data.length === 0 ? e.columns = [] : e.columns = e.data[0].map((n, r) => `col${r}`)), e.index === void 0 && (e.index = e.data.map((n, r) => `row${r}`));
  for (let n = 0; n < e.index.length; n++) {
    const r = [e.index[n]];
    for (let o = 0; o < e.columns.length; o++)
      r.push(e.data[n][o]);
    t.push(r);
  }
  return {
    header: ["index", ...e.columns],
    rows: t
  };
}, Koe = ({ tabledata: e }) => {
  const t = _.useMemo(
    () => Woe(e),
    [e]
  ), [n, r] = _.useState("asc"), [o, a] = _.useState("index");
  let l = t.header.indexOf(o);
  l === -1 && (l = 0);
  const u = (m) => {
    r(o === m && n === "asc" ? "desc" : "asc"), a(m);
  }, d = (m, g) => {
    const y = m.map((w, v) => [
      w,
      v
    ]);
    return y.sort((w, v) => g(w[0], v[0])), y.map((w) => w[0]);
  }, f = (m, g) => m === "desc" ? (y, w) => w[l] < y[l] ? -1 : 1 : (y, w) => y[l] < w[l] ? -1 : 1, p = d(
    t.rows,
    f(n)
  );
  return /* @__PURE__ */ k.jsx(doe, { className: "tablecontainer", children: /* @__PURE__ */ k.jsxs(Qre, { size: "small", children: [
    /* @__PURE__ */ k.jsx(goe, { className: "tableHead", children: /* @__PURE__ */ k.jsx(K5, { className: "tableheadercolor", children: t.header.map((m) => /* @__PURE__ */ k.jsx(
      X5,
      {
        sortDirection: o === m ? n : !1,
        className: "tableheadercolor",
        children: /* @__PURE__ */ k.jsx(
          Zoe,
          {
            active: o === m,
            direction: o === m ? n : "asc",
            onClick: () => u(m),
            className: "tableheadercolor",
            sx: {
              "& .MuiTableSortLabel-icon": {
                color: "inherit !important"
              }
            },
            children: m
          }
        )
      },
      m
    )) }) }),
    /* @__PURE__ */ k.jsx(roe, { children: p.map((m, g) => /* @__PURE__ */ k.jsx(K5, { children: m.map((y, w) => /* @__PURE__ */ k.jsx(X5, { className: w == 0 ? "indexcol" : "datacol", children: y }, w)) }, e.index[g])) })
  ] }) });
};
var Ff = {};
/*!
 * content-type
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */
var eO;
function Qoe() {
  if (eO) return Ff;
  eO = 1;
  var e = /; *([!#$%&'*+.^_`|~0-9A-Za-z-]+) *= *("(?:[\u000b\u0020\u0021\u0023-\u005b\u005d-\u007e\u0080-\u00ff]|\\[\u000b\u0020-\u00ff])*"|[!#$%&'*+.^_`|~0-9A-Za-z-]+) */g, t = /^[\u000b\u0020-\u007e\u0080-\u00ff]+$/, n = /^[!#$%&'*+.^_`|~0-9A-Za-z-]+$/, r = /\\([\u000b\u0020-\u00ff])/g, o = /([\\"])/g, a = /^[!#$%&'*+.^_`|~0-9A-Za-z-]+\/[!#$%&'*+.^_`|~0-9A-Za-z-]+$/;
  Ff.format = l, Ff.parse = u;
  function l(m) {
    if (!m || typeof m != "object")
      throw new TypeError("argument obj is required");
    var g = m.parameters, y = m.type;
    if (!y || !a.test(y))
      throw new TypeError("invalid type");
    var w = y;
    if (g && typeof g == "object")
      for (var v, x = Object.keys(g).sort(), E = 0; E < x.length; E++) {
        if (v = x[E], !n.test(v))
          throw new TypeError("invalid parameter name");
        w += "; " + v + "=" + f(g[v]);
      }
    return w;
  }
  function u(m) {
    if (!m)
      throw new TypeError("argument string is required");
    var g = typeof m == "object" ? d(m) : m;
    if (typeof g != "string")
      throw new TypeError("argument string is required to be a string");
    var y = g.indexOf(";"), w = y !== -1 ? g.slice(0, y).trim() : g.trim();
    if (!a.test(w))
      throw new TypeError("invalid media type");
    var v = new p(w.toLowerCase());
    if (y !== -1) {
      var x, E, N;
      for (e.lastIndex = y; E = e.exec(g); ) {
        if (E.index !== y)
          throw new TypeError("invalid parameter format");
        y += E[0].length, x = E[1].toLowerCase(), N = E[2], N.charCodeAt(0) === 34 && (N = N.slice(1, -1), N.indexOf("\\") !== -1 && (N = N.replace(r, "$1"))), v.parameters[x] = N;
      }
      if (y !== g.length)
        throw new TypeError("invalid parameter format");
    }
    return v;
  }
  function d(m) {
    var g;
    if (typeof m.getHeader == "function" ? g = m.getHeader("content-type") : typeof m.headers == "object" && (g = m.headers && m.headers["content-type"]), typeof g != "string")
      throw new TypeError("content-type header is missing from object");
    return g;
  }
  function f(m) {
    var g = String(m);
    if (n.test(g))
      return g;
    if (g.length > 0 && !t.test(g))
      throw new TypeError("invalid parameter value");
    return '"' + g.replace(o, "\\$1") + '"';
  }
  function p(m) {
    this.parameters = /* @__PURE__ */ Object.create(null), this.type = m;
  }
  return Ff;
}
var Joe = Qoe(), Hl = /* @__PURE__ */ new Map(), Pj = function(e) {
  return e.cloneNode(!0);
}, tO = function() {
  return window.location.protocol === "file:";
}, Lj = function(e, t, n) {
  var r = new XMLHttpRequest();
  r.onreadystatechange = function() {
    try {
      if (!/\.svg/i.test(e) && r.readyState === 2) {
        var o = r.getResponseHeader("Content-Type");
        if (!o)
          throw new Error("Content type not found");
        var a = Joe.parse(o).type;
        if (!(a === "image/svg+xml" || a === "text/plain"))
          throw new Error("Invalid content type: ".concat(a));
      }
      if (r.readyState === 4) {
        if (r.status === 404 || r.responseXML === null)
          throw new Error(tO() ? "Note: SVG injection ajax calls do not work locally without adjusting security settings in your browser. Or consider using a local webserver." : "Unable to load SVG file: " + e);
        if (r.status === 200 || tO() && r.status === 0)
          n(null, r);
        else
          throw new Error("There was a problem injecting the SVG: " + r.status + " " + r.statusText);
      }
    } catch (l) {
      if (r.abort(), l instanceof Error)
        n(l, r);
      else
        throw l;
    }
  }, r.open("GET", e), r.withCredentials = t, r.overrideMimeType && r.overrideMimeType("text/xml"), r.send();
}, Li = {}, nO = function(e, t) {
  Li[e] = Li[e] || [], Li[e].push(t);
}, eie = function(e) {
  for (var t = function(o, a) {
    setTimeout(function() {
      if (Array.isArray(Li[e])) {
        var l = Hl.get(e), u = Li[e][o];
        l instanceof SVGSVGElement && u(null, Pj(l)), l instanceof Error && u(l), o === Li[e].length - 1 && delete Li[e];
      }
    }, 0);
  }, n = 0, r = Li[e].length; n < r; n++)
    t(n);
}, tie = function(e, t, n) {
  if (Hl.has(e)) {
    var r = Hl.get(e);
    if (r === void 0) {
      nO(e, n);
      return;
    }
    if (r instanceof SVGSVGElement) {
      n(null, Pj(r));
      return;
    }
  }
  Hl.set(e, void 0), nO(e, n), Lj(e, t, function(o, a) {
    var l;
    o ? Hl.set(e, o) : ((l = a.responseXML) === null || l === void 0 ? void 0 : l.documentElement) instanceof SVGSVGElement && Hl.set(e, a.responseXML.documentElement), eie(e);
  });
}, nie = function(e, t, n) {
  Lj(e, t, function(r, o) {
    var a;
    r ? n(r) : ((a = o.responseXML) === null || a === void 0 ? void 0 : a.documentElement) instanceof SVGSVGElement && n(null, o.responseXML.documentElement);
  });
}, rie = 0, oie = function() {
  return ++rie;
}, Xr = [], rO = {}, iie = "http://www.w3.org/2000/svg", Mv = "http://www.w3.org/1999/xlink", oO = function(e, t, n, r, o, a, l) {
  var u = e.getAttribute("data-src") || e.getAttribute("src");
  if (!u) {
    l(new Error("Invalid data-src or src attribute"));
    return;
  }
  if (Xr.indexOf(e) !== -1) {
    Xr.splice(Xr.indexOf(e), 1), e = null;
    return;
  }
  Xr.push(e), e.setAttribute("src", "");
  var d = r ? tie : nie;
  d(u, o, function(f, p) {
    if (!p) {
      Xr.splice(Xr.indexOf(e), 1), e = null, l(f);
      return;
    }
    var m = e.getAttribute("id");
    m && p.setAttribute("id", m);
    var g = e.getAttribute("title");
    g && p.setAttribute("title", g);
    var y = e.getAttribute("width");
    y && p.setAttribute("width", y);
    var w = e.getAttribute("height");
    w && p.setAttribute("height", w);
    var v = Array.from(new Set(rp(rp(rp([], (p.getAttribute("class") || "").split(" "), !0), ["injected-svg"], !1), (e.getAttribute("class") || "").split(" "), !0))).join(" ").trim();
    p.setAttribute("class", v);
    var x = e.getAttribute("style");
    x && p.setAttribute("style", x), p.setAttribute("data-src", u);
    var E = [].filter.call(e.attributes, function(H) {
      return /^data-\w[\w-]*$/.test(H.name);
    });
    if (Array.prototype.forEach.call(E, function(H) {
      H.name && H.value && p.setAttribute(H.name, H.value);
    }), n) {
      var N = {
        clipPath: ["clip-path"],
        "color-profile": ["color-profile"],
        cursor: ["cursor"],
        filter: ["filter"],
        linearGradient: ["fill", "stroke"],
        marker: ["marker", "marker-start", "marker-mid", "marker-end"],
        mask: ["mask"],
        path: [],
        pattern: ["fill", "stroke"],
        radialGradient: ["fill", "stroke"]
      }, C, A, R, D, T;
      Object.keys(N).forEach(function(H) {
        C = H, R = N[H], A = p.querySelectorAll(C + "[id]");
        for (var q = function(X, Q) {
          D = A[X].id, T = D + "-" + oie();
          var P;
          Array.prototype.forEach.call(R, function(we) {
            P = p.querySelectorAll("[" + we + '*="' + D + '"]');
            for (var xe = 0, Pe = P.length; xe < Pe; xe++) {
              var Ve = P[xe].getAttribute(we);
              Ve && !Ve.match(new RegExp('url\\("?#' + D + '"?\\)')) || P[xe].setAttribute(we, "url(#" + T + ")");
            }
          });
          for (var te = p.querySelectorAll("[*|href]"), ie = [], ae = 0, fe = te.length; ae < fe; ae++) {
            var he = te[ae].getAttributeNS(Mv, "href");
            he && he.toString() === "#" + A[X].id && ie.push(te[ae]);
          }
          for (var ye = 0, Ee = ie.length; ye < Ee; ye++)
            ie[ye].setAttributeNS(Mv, "href", "#" + T);
          A[X].id = T;
        }, Y = 0, M = A.length; Y < M; Y++)
          q(Y);
      });
    }
    p.removeAttribute("xmlns:a");
    for (var V = p.querySelectorAll("script"), F = [], O, B, U = 0, G = V.length; U < G; U++)
      B = V[U].getAttribute("type"), (!B || B === "application/ecmascript" || B === "application/javascript" || B === "text/javascript") && (O = V[U].innerText || V[U].textContent, O && F.push(O), p.removeChild(V[U]));
    if (F.length > 0 && (t === "always" || t === "once" && !rO[u])) {
      for (var z = 0, $ = F.length; z < $; z++)
        new Function(F[z])(window);
      rO[u] = !0;
    }
    var L = p.querySelectorAll("style");
    if (Array.prototype.forEach.call(L, function(H) {
      H.textContent += "";
    }), p.setAttribute("xmlns", iie), p.setAttribute("xmlns:xlink", Mv), a(p), !e.parentNode) {
      Xr.splice(Xr.indexOf(e), 1), e = null, l(new Error("Parent node is null"));
      return;
    }
    e.parentNode.replaceChild(p, e), Xr.splice(Xr.indexOf(e), 1), e = null, l(null, p);
  });
}, aie = function(e, t) {
  var n = t === void 0 ? {} : t, r = n.afterAll, o = r === void 0 ? function() {
  } : r, a = n.afterEach, l = a === void 0 ? function() {
  } : a, u = n.beforeEach, d = u === void 0 ? function() {
  } : u, f = n.cacheRequests, p = f === void 0 ? !0 : f, m = n.evalScripts, g = m === void 0 ? "never" : m, y = n.httpRequestWithCredentials, w = y === void 0 ? !1 : y, v = n.renumerateIRIElements, x = v === void 0 ? !0 : v;
  if (e && "length" in e)
    for (var E = 0, N = 0, C = e.length; N < C; N++)
      oO(e[N], g, x, p, w, d, function(A, R) {
        l(A, R), e && "length" in e && e.length === ++E && o(E);
      });
  else e ? oO(e, g, x, p, w, d, function(A, R) {
    l(A, R), o(1), e = null;
  }) : o(0);
}, lie = function(e) {
  var t = e?.ownerDocument || document;
  return t.defaultView || window;
}, sie = function(e, t) {
  for (var n in e)
    if (!(n in t))
      return !0;
  for (var r in t)
    if (e[r] !== t[r])
      return !0;
  return !1;
}, uie = ["afterInjection", "beforeInjection", "desc", "evalScripts", "fallback", "httpRequestWithCredentials", "loading", "renumerateIRIElements", "src", "title", "useRequestCache", "wrapper"], $f = "http://www.w3.org/2000/svg", iO = "http://www.w3.org/1999/xlink", Kx = /* @__PURE__ */ function(e) {
  function t() {
    for (var r, o = arguments.length, a = new Array(o), l = 0; l < o; l++)
      a[l] = arguments[l];
    return r = e.call.apply(e, [this].concat(a)) || this, r.initialState = {
      hasError: !1,
      isLoading: !0
    }, r.state = r.initialState, r._isMounted = !1, r.reactWrapper = void 0, r.nonReactWrapper = void 0, r.refCallback = function(u) {
      r.reactWrapper = u;
    }, r;
  }
  Tj(t, e);
  var n = t.prototype;
  return n.renderSVG = function() {
    var r = this;
    if (this.reactWrapper instanceof lie(this.reactWrapper).Node) {
      var o = this.props, a = o.desc, l = o.evalScripts, u = o.httpRequestWithCredentials, d = o.renumerateIRIElements, f = o.src, p = o.title, m = o.useRequestCache, g = this.props.onError, y = this.props.beforeInjection, w = this.props.afterInjection, v = this.props.wrapper, x, E;
      v === "svg" ? (x = document.createElementNS($f, v), x.setAttribute("xmlns", $f), x.setAttribute("xmlns:xlink", iO), E = document.createElementNS($f, v)) : (x = document.createElement(v), E = document.createElement(v)), x.appendChild(E), E.dataset.src = f, this.nonReactWrapper = this.reactWrapper.appendChild(x);
      var N = function(R) {
        if (r.removeSVG(), !r._isMounted) {
          g(R);
          return;
        }
        r.setState(function() {
          return {
            hasError: !0,
            isLoading: !1
          };
        }, function() {
          g(R);
        });
      }, C = function(R, D) {
        if (R) {
          N(R);
          return;
        }
        r._isMounted && r.setState(function() {
          return {
            isLoading: !1
          };
        }, function() {
          try {
            w(D);
          } catch (T) {
            N(T);
          }
        });
      }, A = function(R) {
        if (R.setAttribute("role", "img"), a) {
          var D = R.querySelector(":scope > desc");
          D && R.removeChild(D);
          var T = document.createElement("desc");
          T.innerHTML = a, R.prepend(T);
        }
        if (p) {
          var V = R.querySelector(":scope > title");
          V && R.removeChild(V);
          var F = document.createElement("title");
          F.innerHTML = p, R.prepend(F);
        }
        try {
          y(R);
        } catch (O) {
          N(O);
        }
      };
      aie(E, {
        afterEach: C,
        beforeEach: A,
        cacheRequests: m,
        evalScripts: l,
        httpRequestWithCredentials: u,
        renumerateIRIElements: d
      });
    }
  }, n.removeSVG = function() {
    var r;
    (r = this.nonReactWrapper) != null && r.parentNode && (this.nonReactWrapper.parentNode.removeChild(this.nonReactWrapper), this.nonReactWrapper = null);
  }, n.componentDidMount = function() {
    this._isMounted = !0, this.renderSVG();
  }, n.componentDidUpdate = function(r) {
    var o = this;
    sie(Ne({}, r), this.props) && this.setState(function() {
      return o.initialState;
    }, function() {
      o.removeSVG(), o.renderSVG();
    });
  }, n.componentWillUnmount = function() {
    this._isMounted = !1, this.removeSVG();
  }, n.render = function() {
    var r = this.props;
    r.afterInjection, r.beforeInjection, r.desc, r.evalScripts;
    var o = r.fallback;
    r.httpRequestWithCredentials;
    var a = r.loading;
    r.renumerateIRIElements, r.src, r.title, r.useRequestCache;
    var l = r.wrapper, u = Gx(r, uie), d = l;
    return /* @__PURE__ */ _.createElement(d, Ne({}, u, {
      ref: this.refCallback
    }, l === "svg" ? {
      xmlns: $f,
      xmlnsXlink: iO
    } : {}), this.state.isLoading && a && /* @__PURE__ */ _.createElement(a, null), this.state.hasError && o && /* @__PURE__ */ _.createElement(o, null));
  }, t;
}(_.Component);
Kx.defaultProps = {
  afterInjection: function() {
  },
  beforeInjection: function() {
  },
  desc: "",
  evalScripts: "never",
  fallback: null,
  httpRequestWithCredentials: !1,
  loading: null,
  onError: function() {
  },
  renumerateIRIElements: !0,
  title: "",
  useRequestCache: !0,
  wrapper: "div"
};
Kx.propTypes = {
  afterInjection: Ht.func,
  beforeInjection: Ht.func,
  desc: Ht.string,
  evalScripts: Ht.oneOf(["always", "once", "never"]),
  fallback: Ht.oneOfType([Ht.func, Ht.object, Ht.string]),
  httpRequestWithCredentials: Ht.bool,
  loading: Ht.oneOfType([Ht.func, Ht.object, Ht.string]),
  onError: Ht.func,
  renumerateIRIElements: Ht.bool,
  src: Ht.string.isRequired,
  title: Ht.string,
  useRequestCache: Ht.bool,
  wrapper: Ht.oneOf(["div", "span", "svg"])
};
const cie = ({ value: e }) => /* @__PURE__ */ k.jsx(
  Kx,
  {
    src: `data:image/svg+xml;base64,${btoa(e)}`,
    style: {
      maxWidth: "100%",
      maxHeight: "100%"
    },
    beforeInjection: (t) => {
      t.classList.add("svg-class-name"), t.setAttribute("style", "max-width: 100%; max-height: 100%;"), t.setAttribute("width", "100%"), t.setAttribute("height", "100%");
    }
  }
), Ij = ({
  value: e,
  preValue: t,
  onLoaded: n
}) => {
  const [r, o] = _.useState(t || e);
  if (_.useEffect(() => {
    if (e === t) return;
    const u = new Image();
    return u.onload = () => {
      n?.(), o(e);
    }, u.src = e, () => {
      u.onload = null;
    };
  }, [e, t, n]), r === void 0)
    return /* @__PURE__ */ k.jsx(k.Fragment, {});
  if (typeof r != "string")
    return console.error("ImageRenderer: value is not a string", r), /* @__PURE__ */ k.jsx(k.Fragment, {});
  const a = r.startsWith("data:") || r.startsWith("blob:");
  let l = r;
  return a || (l = "data:image/jpeg;base64," + r), /* @__PURE__ */ k.jsx("img", { src: l, style: { maxWidth: "100%", maxHeight: "100%" } });
}, Bj = ({
  value: e
}) => /* @__PURE__ */ k.jsx(cie, { value: e }), Vj = ({
  value: e
}) => {
  let t = "";
  try {
    t = JSON.stringify(e);
  } catch {
  }
  return /* @__PURE__ */ k.jsx("div", { children: /* @__PURE__ */ k.jsx("pre", { children: t }) });
}, Qx = ({
  value: e
}) => {
  if (typeof e != "string" || e.length % 4 !== 0)
    return /* @__PURE__ */ k.jsx("div", { children: e });
  const t = Math.round(3 * e.length / 4);
  return /* @__PURE__ */ k.jsx("div", { children: /* @__PURE__ */ k.jsxs("pre", { children: [
    "Bytes(",
    t,
    ")"
  ] }) });
}, Hj = ({
  value: e
}) => /* @__PURE__ */ k.jsx(
  Koe,
  {
    tabledata: e || {
      columns: [],
      index: [],
      data: []
    }
  }
), am = ({
  value: e
}) => /* @__PURE__ */ k.jsx(zee, { data: e }), Gp = am, die = {
  string: Vj,
  table: Hj,
  image: Ij,
  svg: Bj,
  dict: am,
  bytes: Qx
};
function Uj(e, [t, n]) {
  return Math.min(n, Math.max(t, e));
}
function fie(e) {
  const t = _.useRef({ value: e, previous: e });
  return _.useMemo(() => (t.current.value !== e && (t.current.previous = t.current.value, t.current.value = e), t.current.previous), [e]);
}
var Fj = ["PageUp", "PageDown"], $j = ["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight"], Yj = {
  "from-left": ["Home", "PageDown", "ArrowDown", "ArrowLeft"],
  "from-right": ["Home", "PageDown", "ArrowDown", "ArrowRight"],
  "from-bottom": ["Home", "PageDown", "ArrowDown", "ArrowLeft"],
  "from-top": ["Home", "PageDown", "ArrowUp", "ArrowLeft"]
}, Cs = "Slider", [Kb, pie, hie] = $w(Cs), [qj, nce] = Gi(Cs, [
  hie
]), [mie, lm] = qj(Cs), Xj = _.forwardRef(
  (e, t) => {
    const {
      name: n,
      min: r = 0,
      max: o = 100,
      step: a = 1,
      orientation: l = "horizontal",
      disabled: u = !1,
      minStepsBetweenThumbs: d = 0,
      defaultValue: f = [r],
      value: p,
      onValueChange: m = () => {
      },
      onValueCommit: g = () => {
      },
      inverted: y = !1,
      form: w,
      ...v
    } = e, x = _.useRef(/* @__PURE__ */ new Set()), E = _.useRef(0), N = l === "horizontal" ? gie : yie, [C = [], A] = ys({
      prop: p,
      defaultProp: f,
      onChange: (O) => {
        var B;
        (B = [...x.current][E.current]) == null || B.focus(), m(O);
      }
    }), R = _.useRef(C);
    function D(O) {
      const B = Sie(C, O);
      F(O, B);
    }
    function T(O) {
      F(O, E.current);
    }
    function V() {
      const O = R.current[E.current];
      C[E.current] !== O && g(C);
    }
    function F(O, B, { commit: U } = { commit: !1 }) {
      const G = Cie(a), z = Oie(Math.round((O - r) / a) * a + r, G), $ = Uj(z, [r, o]);
      A((L = []) => {
        const H = wie(L, $, B);
        if (Eie(H, d * a)) {
          E.current = H.indexOf($);
          const q = String(H) !== String(L);
          return q && U && g(H), q ? H : L;
        } else
          return L;
      });
    }
    return /* @__PURE__ */ k.jsx(
      mie,
      {
        scope: e.__scopeSlider,
        name: n,
        disabled: u,
        min: r,
        max: o,
        valueIndexToChangeRef: E,
        thumbs: x.current,
        values: C,
        orientation: l,
        form: w,
        children: /* @__PURE__ */ k.jsx(Kb.Provider, { scope: e.__scopeSlider, children: /* @__PURE__ */ k.jsx(Kb.Slot, { scope: e.__scopeSlider, children: /* @__PURE__ */ k.jsx(
          N,
          {
            "aria-disabled": u,
            "data-disabled": u ? "" : void 0,
            ...v,
            ref: t,
            onPointerDown: Te(v.onPointerDown, () => {
              u || (R.current = C);
            }),
            min: r,
            max: o,
            inverted: y,
            onSlideStart: u ? void 0 : D,
            onSlideMove: u ? void 0 : T,
            onSlideEnd: u ? void 0 : V,
            onHomeKeyDown: () => !u && F(r, 0, { commit: !0 }),
            onEndKeyDown: () => !u && F(o, C.length - 1, { commit: !0 }),
            onStepKeyDown: ({ event: O, direction: B }) => {
              if (!u) {
                const U = Fj.includes(O.key) || O.shiftKey && $j.includes(O.key) ? 10 : 1, G = E.current, z = C[G], $ = a * U * B;
                F(z + $, G, { commit: !0 });
              }
            }
          }
        ) }) })
      }
    );
  }
);
Xj.displayName = Cs;
var [Gj, Zj] = qj(Cs, {
  startEdge: "left",
  endEdge: "right",
  size: "width",
  direction: 1
}), gie = _.forwardRef(
  (e, t) => {
    const {
      min: n,
      max: r,
      dir: o,
      inverted: a,
      onSlideStart: l,
      onSlideMove: u,
      onSlideEnd: d,
      onStepKeyDown: f,
      ...p
    } = e, [m, g] = _.useState(null), y = kt(t, (C) => g(C)), w = _.useRef(void 0), v = Yw(o), x = v === "ltr", E = x && !a || !x && a;
    function N(C) {
      const A = w.current || m.getBoundingClientRect(), R = [0, A.width], D = Jx(R, E ? [n, r] : [r, n]);
      return w.current = A, D(C - A.left);
    }
    return /* @__PURE__ */ k.jsx(
      Gj,
      {
        scope: e.__scopeSlider,
        startEdge: E ? "left" : "right",
        endEdge: E ? "right" : "left",
        direction: E ? 1 : -1,
        size: "width",
        children: /* @__PURE__ */ k.jsx(
          Wj,
          {
            dir: v,
            "data-orientation": "horizontal",
            ...p,
            ref: y,
            style: {
              ...p.style,
              "--radix-slider-thumb-transform": "translateX(-50%)"
            },
            onSlideStart: (C) => {
              const A = N(C.clientX);
              l?.(A);
            },
            onSlideMove: (C) => {
              const A = N(C.clientX);
              u?.(A);
            },
            onSlideEnd: () => {
              w.current = void 0, d?.();
            },
            onStepKeyDown: (C) => {
              const A = Yj[E ? "from-left" : "from-right"].includes(C.key);
              f?.({ event: C, direction: A ? -1 : 1 });
            }
          }
        )
      }
    );
  }
), yie = _.forwardRef(
  (e, t) => {
    const {
      min: n,
      max: r,
      inverted: o,
      onSlideStart: a,
      onSlideMove: l,
      onSlideEnd: u,
      onStepKeyDown: d,
      ...f
    } = e, p = _.useRef(null), m = kt(t, p), g = _.useRef(void 0), y = !o;
    function w(v) {
      const x = g.current || p.current.getBoundingClientRect(), E = [0, x.height], N = Jx(E, y ? [r, n] : [n, r]);
      return g.current = x, N(v - x.top);
    }
    return /* @__PURE__ */ k.jsx(
      Gj,
      {
        scope: e.__scopeSlider,
        startEdge: y ? "bottom" : "top",
        endEdge: y ? "top" : "bottom",
        size: "height",
        direction: y ? 1 : -1,
        children: /* @__PURE__ */ k.jsx(
          Wj,
          {
            "data-orientation": "vertical",
            ...f,
            ref: m,
            style: {
              ...f.style,
              "--radix-slider-thumb-transform": "translateY(50%)"
            },
            onSlideStart: (v) => {
              const x = w(v.clientY);
              a?.(x);
            },
            onSlideMove: (v) => {
              const x = w(v.clientY);
              l?.(x);
            },
            onSlideEnd: () => {
              g.current = void 0, u?.();
            },
            onStepKeyDown: (v) => {
              const x = Yj[y ? "from-bottom" : "from-top"].includes(v.key);
              d?.({ event: v, direction: x ? -1 : 1 });
            }
          }
        )
      }
    );
  }
), Wj = _.forwardRef(
  (e, t) => {
    const {
      __scopeSlider: n,
      onSlideStart: r,
      onSlideMove: o,
      onSlideEnd: a,
      onHomeKeyDown: l,
      onEndKeyDown: u,
      onStepKeyDown: d,
      ...f
    } = e, p = lm(Cs, n);
    return /* @__PURE__ */ k.jsx(
      vt.span,
      {
        ...f,
        ref: t,
        onKeyDown: Te(e.onKeyDown, (m) => {
          m.key === "Home" ? (l(m), m.preventDefault()) : m.key === "End" ? (u(m), m.preventDefault()) : Fj.concat($j).includes(m.key) && (d(m), m.preventDefault());
        }),
        onPointerDown: Te(e.onPointerDown, (m) => {
          const g = m.target;
          g.setPointerCapture(m.pointerId), m.preventDefault(), p.thumbs.has(g) ? g.focus() : r(m);
        }),
        onPointerMove: Te(e.onPointerMove, (m) => {
          m.target.hasPointerCapture(m.pointerId) && o(m);
        }),
        onPointerUp: Te(e.onPointerUp, (m) => {
          const g = m.target;
          g.hasPointerCapture(m.pointerId) && (g.releasePointerCapture(m.pointerId), a(m));
        })
      }
    );
  }
), Kj = "SliderTrack", Qj = _.forwardRef(
  (e, t) => {
    const { __scopeSlider: n, ...r } = e, o = lm(Kj, n);
    return /* @__PURE__ */ k.jsx(
      vt.span,
      {
        "data-disabled": o.disabled ? "" : void 0,
        "data-orientation": o.orientation,
        ...r,
        ref: t
      }
    );
  }
);
Qj.displayName = Kj;
var Qb = "SliderRange", Jj = _.forwardRef(
  (e, t) => {
    const { __scopeSlider: n, ...r } = e, o = lm(Qb, n), a = Zj(Qb, n), l = _.useRef(null), u = kt(t, l), d = o.values.length, f = o.values.map(
      (g) => tD(g, o.min, o.max)
    ), p = d > 1 ? Math.min(...f) : 0, m = 100 - Math.max(...f);
    return /* @__PURE__ */ k.jsx(
      vt.span,
      {
        "data-orientation": o.orientation,
        "data-disabled": o.disabled ? "" : void 0,
        ...r,
        ref: u,
        style: {
          ...e.style,
          [a.startEdge]: p + "%",
          [a.endEdge]: m + "%"
        }
      }
    );
  }
);
Jj.displayName = Qb;
var Jb = "SliderThumb", eD = _.forwardRef(
  (e, t) => {
    const n = pie(e.__scopeSlider), [r, o] = _.useState(null), a = kt(t, (u) => o(u)), l = _.useMemo(
      () => r ? n().findIndex((u) => u.ref.current === r) : -1,
      [n, r]
    );
    return /* @__PURE__ */ k.jsx(vie, { ...e, ref: a, index: l });
  }
), vie = _.forwardRef(
  (e, t) => {
    const { __scopeSlider: n, index: r, name: o, ...a } = e, l = lm(Jb, n), u = Zj(Jb, n), [d, f] = _.useState(null), p = kt(t, (N) => f(N)), m = d ? l.form || !!d.closest("form") : !0, g = _M(d), y = l.values[r], w = y === void 0 ? 0 : tD(y, l.min, l.max), v = xie(r, l.values.length), x = g?.[u.size], E = x ? kie(x, w, u.direction) : 0;
    return _.useEffect(() => {
      if (d)
        return l.thumbs.add(d), () => {
          l.thumbs.delete(d);
        };
    }, [d, l.thumbs]), /* @__PURE__ */ k.jsxs(
      "span",
      {
        style: {
          transform: "var(--radix-slider-thumb-transform)",
          position: "absolute",
          [u.startEdge]: `calc(${w}% + ${E}px)`
        },
        children: [
          /* @__PURE__ */ k.jsx(Kb.ItemSlot, { scope: e.__scopeSlider, children: /* @__PURE__ */ k.jsx(
            vt.span,
            {
              role: "slider",
              "aria-label": e["aria-label"] || v,
              "aria-valuemin": l.min,
              "aria-valuenow": y,
              "aria-valuemax": l.max,
              "aria-orientation": l.orientation,
              "data-orientation": l.orientation,
              "data-disabled": l.disabled ? "" : void 0,
              tabIndex: l.disabled ? void 0 : 0,
              ...a,
              ref: p,
              style: y === void 0 ? { display: "none" } : e.style,
              onFocus: Te(e.onFocus, () => {
                l.valueIndexToChangeRef.current = r;
              })
            }
          ) }),
          m && /* @__PURE__ */ k.jsx(
            bie,
            {
              name: o ?? (l.name ? l.name + (l.values.length > 1 ? "[]" : "") : void 0),
              form: l.form,
              value: y
            },
            r
          )
        ]
      }
    );
  }
);
eD.displayName = Jb;
var bie = (e) => {
  const { value: t, ...n } = e, r = _.useRef(null), o = fie(t);
  return _.useEffect(() => {
    const a = r.current, l = window.HTMLInputElement.prototype, u = Object.getOwnPropertyDescriptor(l, "value").set;
    if (o !== t && u) {
      const d = new Event("input", { bubbles: !0 });
      u.call(a, t), a.dispatchEvent(d);
    }
  }, [o, t]), /* @__PURE__ */ k.jsx("input", { style: { display: "none" }, ...n, ref: r, defaultValue: t });
};
function wie(e = [], t, n) {
  const r = [...e];
  return r[n] = t, r.sort((o, a) => o - a);
}
function tD(e, t, n) {
  const r = 100 / (n - t) * (e - t);
  return Uj(r, [0, 100]);
}
function xie(e, t) {
  return t > 2 ? `Value ${e + 1} of ${t}` : t === 2 ? ["Minimum", "Maximum"][e] : void 0;
}
function Sie(e, t) {
  if (e.length === 1) return 0;
  const n = e.map((o) => Math.abs(o - t)), r = Math.min(...n);
  return n.indexOf(r);
}
function kie(e, t, n) {
  const r = e / 2, o = Jx([0, 50], [0, r]);
  return (r - o(t) * n) * n;
}
function _ie(e) {
  return e.slice(0, -1).map((t, n) => e[n + 1] - t);
}
function Eie(e, t) {
  if (t > 0) {
    const n = _ie(e);
    return Math.min(...n) >= t;
  }
  return !0;
}
function Jx(e, t) {
  return (n) => {
    if (e[0] === e[1] || t[0] === t[1]) return t[0];
    const r = (t[1] - t[0]) / (e[1] - e[0]);
    return t[0] + r * (n - e[0]);
  };
}
function Cie(e) {
  return (String(e).split(".")[1] || "").length;
}
function Oie(e, t) {
  const n = Math.pow(10, t);
  return Math.round(e * n) / n;
}
var Nie = Xj, Mie = Qj, Aie = Jj, Rie = eD;
const Nc = {
  aliceblue: [240, 248, 255],
  antiquewhite: [250, 235, 215],
  aqua: [0, 255, 255],
  aquamarine: [127, 255, 212],
  azure: [240, 255, 255],
  beige: [245, 245, 220],
  bisque: [255, 228, 196],
  black: [0, 0, 0],
  blanchedalmond: [255, 235, 205],
  blue: [0, 0, 255],
  blueviolet: [138, 43, 226],
  brown: [165, 42, 42],
  burlywood: [222, 184, 135],
  cadetblue: [95, 158, 160],
  chartreuse: [127, 255, 0],
  chocolate: [210, 105, 30],
  coral: [255, 127, 80],
  cornflowerblue: [100, 149, 237],
  cornsilk: [255, 248, 220],
  crimson: [220, 20, 60],
  cyan: [0, 255, 255],
  darkblue: [0, 0, 139],
  darkcyan: [0, 139, 139],
  darkgoldenrod: [184, 134, 11],
  darkgray: [169, 169, 169],
  darkgreen: [0, 100, 0],
  darkgrey: [169, 169, 169],
  darkkhaki: [189, 183, 107],
  darkmagenta: [139, 0, 139],
  darkolivegreen: [85, 107, 47],
  darkorange: [255, 140, 0],
  darkorchid: [153, 50, 204],
  darkred: [139, 0, 0],
  darksalmon: [233, 150, 122],
  darkseagreen: [143, 188, 143],
  darkslateblue: [72, 61, 139],
  darkslategray: [47, 79, 79],
  darkslategrey: [47, 79, 79],
  darkturquoise: [0, 206, 209],
  darkviolet: [148, 0, 211],
  deeppink: [255, 20, 147],
  deepskyblue: [0, 191, 255],
  dimgray: [105, 105, 105],
  dimgrey: [105, 105, 105],
  dodgerblue: [30, 144, 255],
  firebrick: [178, 34, 34],
  floralwhite: [255, 250, 240],
  forestgreen: [34, 139, 34],
  fuchsia: [255, 0, 255],
  gainsboro: [220, 220, 220],
  ghostwhite: [248, 248, 255],
  gold: [255, 215, 0],
  goldenrod: [218, 165, 32],
  gray: [128, 128, 128],
  green: [0, 128, 0],
  greenyellow: [173, 255, 47],
  grey: [128, 128, 128],
  honeydew: [240, 255, 240],
  hotpink: [255, 105, 180],
  indianred: [205, 92, 92],
  indigo: [75, 0, 130],
  ivory: [255, 255, 240],
  khaki: [240, 230, 140],
  lavender: [230, 230, 250],
  lavenderblush: [255, 240, 245],
  lawngreen: [124, 252, 0],
  lemonchiffon: [255, 250, 205],
  lightblue: [173, 216, 230],
  lightcoral: [240, 128, 128],
  lightcyan: [224, 255, 255],
  lightgoldenrodyellow: [250, 250, 210],
  lightgray: [211, 211, 211],
  lightgreen: [144, 238, 144],
  lightgrey: [211, 211, 211],
  lightpink: [255, 182, 193],
  lightsalmon: [255, 160, 122],
  lightseagreen: [32, 178, 170],
  lightskyblue: [135, 206, 250],
  lightslategray: [119, 136, 153],
  lightslategrey: [119, 136, 153],
  lightsteelblue: [176, 196, 222],
  lightyellow: [255, 255, 224],
  lime: [0, 255, 0],
  limegreen: [50, 205, 50],
  linen: [250, 240, 230],
  magenta: [255, 0, 255],
  maroon: [128, 0, 0],
  mediumaquamarine: [102, 205, 170],
  mediumblue: [0, 0, 205],
  mediumorchid: [186, 85, 211],
  mediumpurple: [147, 112, 219],
  mediumseagreen: [60, 179, 113],
  mediumslateblue: [123, 104, 238],
  mediumspringgreen: [0, 250, 154],
  mediumturquoise: [72, 209, 204],
  mediumvioletred: [199, 21, 133],
  midnightblue: [25, 25, 112],
  mintcream: [245, 255, 250],
  mistyrose: [255, 228, 225],
  moccasin: [255, 228, 181],
  navajowhite: [255, 222, 173],
  navy: [0, 0, 128],
  oldlace: [253, 245, 230],
  olive: [128, 128, 0],
  olivedrab: [107, 142, 35],
  orange: [255, 165, 0],
  orangered: [255, 69, 0],
  orchid: [218, 112, 214],
  palegoldenrod: [238, 232, 170],
  palegreen: [152, 251, 152],
  paleturquoise: [175, 238, 238],
  palevioletred: [219, 112, 147],
  papayawhip: [255, 239, 213],
  peachpuff: [255, 218, 185],
  peru: [205, 133, 63],
  pink: [255, 192, 203],
  plum: [221, 160, 221],
  powderblue: [176, 224, 230],
  purple: [128, 0, 128],
  rebeccapurple: [102, 51, 153],
  red: [255, 0, 0],
  rosybrown: [188, 143, 143],
  royalblue: [65, 105, 225],
  saddlebrown: [139, 69, 19],
  salmon: [250, 128, 114],
  sandybrown: [244, 164, 96],
  seagreen: [46, 139, 87],
  seashell: [255, 245, 238],
  sienna: [160, 82, 45],
  silver: [192, 192, 192],
  skyblue: [135, 206, 235],
  slateblue: [106, 90, 205],
  slategray: [112, 128, 144],
  slategrey: [112, 128, 144],
  snow: [255, 250, 250],
  springgreen: [0, 255, 127],
  steelblue: [70, 130, 180],
  tan: [210, 180, 140],
  teal: [0, 128, 128],
  thistle: [216, 191, 216],
  tomato: [255, 99, 71],
  turquoise: [64, 224, 208],
  violet: [238, 130, 238],
  wheat: [245, 222, 179],
  white: [255, 255, 255],
  whitesmoke: [245, 245, 245],
  yellow: [255, 255, 0],
  yellowgreen: [154, 205, 50]
}, nD = {};
for (const e of Object.keys(Nc))
  nD[Nc[e]] = e;
const ve = {
  rgb: { channels: 3, labels: "rgb" },
  hsl: { channels: 3, labels: "hsl" },
  hsv: { channels: 3, labels: "hsv" },
  hwb: { channels: 3, labels: "hwb" },
  cmyk: { channels: 4, labels: "cmyk" },
  xyz: { channels: 3, labels: "xyz" },
  lab: { channels: 3, labels: "lab" },
  lch: { channels: 3, labels: "lch" },
  hex: { channels: 1, labels: ["hex"] },
  keyword: { channels: 1, labels: ["keyword"] },
  ansi16: { channels: 1, labels: ["ansi16"] },
  ansi256: { channels: 1, labels: ["ansi256"] },
  hcg: { channels: 3, labels: ["h", "c", "g"] },
  apple: { channels: 3, labels: ["r16", "g16", "b16"] },
  gray: { channels: 1, labels: ["gray"] }
}, Ho = (6 / 29) ** 3;
for (const e of Object.keys(ve)) {
  if (!("channels" in ve[e]))
    throw new Error("missing channels property: " + e);
  if (!("labels" in ve[e]))
    throw new Error("missing channel labels property: " + e);
  if (ve[e].labels.length !== ve[e].channels)
    throw new Error("channel and label counts mismatch: " + e);
  const { channels: t, labels: n } = ve[e];
  delete ve[e].channels, delete ve[e].labels, Object.defineProperty(ve[e], "channels", { value: t }), Object.defineProperty(ve[e], "labels", { value: n });
}
ve.rgb.hsl = function(e) {
  const t = e[0] / 255, n = e[1] / 255, r = e[2] / 255, o = Math.min(t, n, r), a = Math.max(t, n, r), l = a - o;
  let u, d;
  switch (a) {
    case o: {
      u = 0;
      break;
    }
    case t: {
      u = (n - r) / l;
      break;
    }
    case n: {
      u = 2 + (r - t) / l;
      break;
    }
    case r: {
      u = 4 + (t - n) / l;
      break;
    }
  }
  u = Math.min(u * 60, 360), u < 0 && (u += 360);
  const f = (o + a) / 2;
  return a === o ? d = 0 : f <= 0.5 ? d = l / (a + o) : d = l / (2 - a - o), [u, d * 100, f * 100];
};
ve.rgb.hsv = function(e) {
  let t, n, r, o, a;
  const l = e[0] / 255, u = e[1] / 255, d = e[2] / 255, f = Math.max(l, u, d), p = f - Math.min(l, u, d), m = function(g) {
    return (f - g) / 6 / p + 1 / 2;
  };
  if (p === 0)
    o = 0, a = 0;
  else {
    switch (a = p / f, t = m(l), n = m(u), r = m(d), f) {
      case l: {
        o = r - n;
        break;
      }
      case u: {
        o = 1 / 3 + t - r;
        break;
      }
      case d: {
        o = 2 / 3 + n - t;
        break;
      }
    }
    o < 0 ? o += 1 : o > 1 && (o -= 1);
  }
  return [
    o * 360,
    a * 100,
    f * 100
  ];
};
ve.rgb.hwb = function(e) {
  const t = e[0], n = e[1];
  let r = e[2];
  const o = ve.rgb.hsl(e)[0], a = 1 / 255 * Math.min(t, Math.min(n, r));
  return r = 1 - 1 / 255 * Math.max(t, Math.max(n, r)), [o, a * 100, r * 100];
};
ve.rgb.cmyk = function(e) {
  const t = e[0] / 255, n = e[1] / 255, r = e[2] / 255, o = Math.min(1 - t, 1 - n, 1 - r), a = (1 - t - o) / (1 - o) || 0, l = (1 - n - o) / (1 - o) || 0, u = (1 - r - o) / (1 - o) || 0;
  return [a * 100, l * 100, u * 100, o * 100];
};
function jie(e, t) {
  return (e[0] - t[0]) ** 2 + (e[1] - t[1]) ** 2 + (e[2] - t[2]) ** 2;
}
ve.rgb.keyword = function(e) {
  const t = nD[e];
  if (t)
    return t;
  let n = Number.POSITIVE_INFINITY, r;
  for (const o of Object.keys(Nc)) {
    const a = Nc[o], l = jie(e, a);
    l < n && (n = l, r = o);
  }
  return r;
};
ve.keyword.rgb = function(e) {
  return Nc[e];
};
ve.rgb.xyz = function(e) {
  let t = e[0] / 255, n = e[1] / 255, r = e[2] / 255;
  t = t > 0.04045 ? ((t + 0.055) / 1.055) ** 2.4 : t / 12.92, n = n > 0.04045 ? ((n + 0.055) / 1.055) ** 2.4 : n / 12.92, r = r > 0.04045 ? ((r + 0.055) / 1.055) ** 2.4 : r / 12.92;
  const o = t * 0.4124564 + n * 0.3575761 + r * 0.1804375, a = t * 0.2126729 + n * 0.7151522 + r * 0.072175, l = t * 0.0193339 + n * 0.119192 + r * 0.9503041;
  return [o * 100, a * 100, l * 100];
};
ve.rgb.lab = function(e) {
  const t = ve.rgb.xyz(e);
  let n = t[0], r = t[1], o = t[2];
  n /= 95.047, r /= 100, o /= 108.883, n = n > Ho ? n ** (1 / 3) : 7.787 * n + 16 / 116, r = r > Ho ? r ** (1 / 3) : 7.787 * r + 16 / 116, o = o > Ho ? o ** (1 / 3) : 7.787 * o + 16 / 116;
  const a = 116 * r - 16, l = 500 * (n - r), u = 200 * (r - o);
  return [a, l, u];
};
ve.hsl.rgb = function(e) {
  const t = e[0] / 360, n = e[1] / 100, r = e[2] / 100;
  let o, a;
  if (n === 0)
    return a = r * 255, [a, a, a];
  const l = r < 0.5 ? r * (1 + n) : r + n - r * n, u = 2 * r - l, d = [0, 0, 0];
  for (let f = 0; f < 3; f++)
    o = t + 1 / 3 * -(f - 1), o < 0 && o++, o > 1 && o--, 6 * o < 1 ? a = u + (l - u) * 6 * o : 2 * o < 1 ? a = l : 3 * o < 2 ? a = u + (l - u) * (2 / 3 - o) * 6 : a = u, d[f] = a * 255;
  return d;
};
ve.hsl.hsv = function(e) {
  const t = e[0];
  let n = e[1] / 100, r = e[2] / 100, o = n;
  const a = Math.max(r, 0.01);
  r *= 2, n *= r <= 1 ? r : 2 - r, o *= a <= 1 ? a : 2 - a;
  const l = (r + n) / 2, u = r === 0 ? 2 * o / (a + o) : 2 * n / (r + n);
  return [t, u * 100, l * 100];
};
ve.hsv.rgb = function(e) {
  const t = e[0] / 60, n = e[1] / 100;
  let r = e[2] / 100;
  const o = Math.floor(t) % 6, a = t - Math.floor(t), l = 255 * r * (1 - n), u = 255 * r * (1 - n * a), d = 255 * r * (1 - n * (1 - a));
  switch (r *= 255, o) {
    case 0:
      return [r, d, l];
    case 1:
      return [u, r, l];
    case 2:
      return [l, r, d];
    case 3:
      return [l, u, r];
    case 4:
      return [d, l, r];
    case 5:
      return [r, l, u];
  }
};
ve.hsv.hsl = function(e) {
  const t = e[0], n = e[1] / 100, r = e[2] / 100, o = Math.max(r, 0.01);
  let a, l;
  l = (2 - n) * r;
  const u = (2 - n) * o;
  return a = n * o, a /= u <= 1 ? u : 2 - u, a = a || 0, l /= 2, [t, a * 100, l * 100];
};
ve.hwb.rgb = function(e) {
  const t = e[0] / 360;
  let n = e[1] / 100, r = e[2] / 100;
  const o = n + r;
  let a;
  o > 1 && (n /= o, r /= o);
  const l = Math.floor(6 * t), u = 1 - r;
  a = 6 * t - l, (l & 1) !== 0 && (a = 1 - a);
  const d = n + a * (u - n);
  let f, p, m;
  switch (l) {
    default:
    case 6:
    case 0: {
      f = u, p = d, m = n;
      break;
    }
    case 1: {
      f = d, p = u, m = n;
      break;
    }
    case 2: {
      f = n, p = u, m = d;
      break;
    }
    case 3: {
      f = n, p = d, m = u;
      break;
    }
    case 4: {
      f = d, p = n, m = u;
      break;
    }
    case 5: {
      f = u, p = n, m = d;
      break;
    }
  }
  return [f * 255, p * 255, m * 255];
};
ve.cmyk.rgb = function(e) {
  const t = e[0] / 100, n = e[1] / 100, r = e[2] / 100, o = e[3] / 100, a = 1 - Math.min(1, t * (1 - o) + o), l = 1 - Math.min(1, n * (1 - o) + o), u = 1 - Math.min(1, r * (1 - o) + o);
  return [a * 255, l * 255, u * 255];
};
ve.xyz.rgb = function(e) {
  const t = e[0] / 100, n = e[1] / 100, r = e[2] / 100;
  let o, a, l;
  return o = t * 3.2404542 + n * -1.5371385 + r * -0.4985314, a = t * -0.969266 + n * 1.8760108 + r * 0.041556, l = t * 0.0556434 + n * -0.2040259 + r * 1.0572252, o = o > 31308e-7 ? 1.055 * o ** (1 / 2.4) - 0.055 : o * 12.92, a = a > 31308e-7 ? 1.055 * a ** (1 / 2.4) - 0.055 : a * 12.92, l = l > 31308e-7 ? 1.055 * l ** (1 / 2.4) - 0.055 : l * 12.92, o = Math.min(Math.max(0, o), 1), a = Math.min(Math.max(0, a), 1), l = Math.min(Math.max(0, l), 1), [o * 255, a * 255, l * 255];
};
ve.xyz.lab = function(e) {
  let t = e[0], n = e[1], r = e[2];
  t /= 95.047, n /= 100, r /= 108.883, t = t > Ho ? t ** (1 / 3) : 7.787 * t + 16 / 116, n = n > Ho ? n ** (1 / 3) : 7.787 * n + 16 / 116, r = r > Ho ? r ** (1 / 3) : 7.787 * r + 16 / 116;
  const o = 116 * n - 16, a = 500 * (t - n), l = 200 * (n - r);
  return [o, a, l];
};
ve.lab.xyz = function(e) {
  const t = e[0], n = e[1], r = e[2];
  let o, a, l;
  a = (t + 16) / 116, o = n / 500 + a, l = a - r / 200;
  const u = a ** 3, d = o ** 3, f = l ** 3;
  return a = u > Ho ? u : (a - 16 / 116) / 7.787, o = d > Ho ? d : (o - 16 / 116) / 7.787, l = f > Ho ? f : (l - 16 / 116) / 7.787, o *= 95.047, a *= 100, l *= 108.883, [o, a, l];
};
ve.lab.lch = function(e) {
  const t = e[0], n = e[1], r = e[2];
  let o;
  o = Math.atan2(r, n) * 360 / 2 / Math.PI, o < 0 && (o += 360);
  const a = Math.sqrt(n * n + r * r);
  return [t, a, o];
};
ve.lch.lab = function(e) {
  const t = e[0], n = e[1], r = e[2] / 360 * 2 * Math.PI, o = n * Math.cos(r), a = n * Math.sin(r);
  return [t, o, a];
};
ve.rgb.ansi16 = function(e, t = null) {
  const [n, r, o] = e;
  let a = t === null ? ve.rgb.hsv(e)[2] : t;
  if (a = Math.round(a / 50), a === 0)
    return 30;
  let l = 30 + (Math.round(o / 255) << 2 | Math.round(r / 255) << 1 | Math.round(n / 255));
  return a === 2 && (l += 60), l;
};
ve.hsv.ansi16 = function(e) {
  return ve.rgb.ansi16(ve.hsv.rgb(e), e[2]);
};
ve.rgb.ansi256 = function(e) {
  const t = e[0], n = e[1], r = e[2];
  return t >> 4 === n >> 4 && n >> 4 === r >> 4 ? t < 8 ? 16 : t > 248 ? 231 : Math.round((t - 8) / 247 * 24) + 232 : 16 + 36 * Math.round(t / 255 * 5) + 6 * Math.round(n / 255 * 5) + Math.round(r / 255 * 5);
};
ve.ansi16.rgb = function(e) {
  e = e[0];
  let t = e % 10;
  if (t === 0 || t === 7)
    return e > 50 && (t += 3.5), t = t / 10.5 * 255, [t, t, t];
  const n = (Math.trunc(e > 50) + 1) * 0.5, r = (t & 1) * n * 255, o = (t >> 1 & 1) * n * 255, a = (t >> 2 & 1) * n * 255;
  return [r, o, a];
};
ve.ansi256.rgb = function(e) {
  if (e = e[0], e >= 232) {
    const a = (e - 232) * 10 + 8;
    return [a, a, a];
  }
  e -= 16;
  let t;
  const n = Math.floor(e / 36) / 5 * 255, r = Math.floor((t = e % 36) / 6) / 5 * 255, o = t % 6 / 5 * 255;
  return [n, r, o];
};
ve.rgb.hex = function(e) {
  const t = (((Math.round(e[0]) & 255) << 16) + ((Math.round(e[1]) & 255) << 8) + (Math.round(e[2]) & 255)).toString(16).toUpperCase();
  return "000000".slice(t.length) + t;
};
ve.hex.rgb = function(e) {
  const t = e.toString(16).match(/[a-f\d]{6}|[a-f\d]{3}/i);
  if (!t)
    return [0, 0, 0];
  let n = t[0];
  t[0].length === 3 && (n = [...n].map((u) => u + u).join(""));
  const r = Number.parseInt(n, 16), o = r >> 16 & 255, a = r >> 8 & 255, l = r & 255;
  return [o, a, l];
};
ve.rgb.hcg = function(e) {
  const t = e[0] / 255, n = e[1] / 255, r = e[2] / 255, o = Math.max(Math.max(t, n), r), a = Math.min(Math.min(t, n), r), l = o - a;
  let u;
  const d = l < 1 ? a / (1 - l) : 0;
  return l <= 0 ? u = 0 : o === t ? u = (n - r) / l % 6 : o === n ? u = 2 + (r - t) / l : u = 4 + (t - n) / l, u /= 6, u %= 1, [u * 360, l * 100, d * 100];
};
ve.hsl.hcg = function(e) {
  const t = e[1] / 100, n = e[2] / 100, r = n < 0.5 ? 2 * t * n : 2 * t * (1 - n);
  let o = 0;
  return r < 1 && (o = (n - 0.5 * r) / (1 - r)), [e[0], r * 100, o * 100];
};
ve.hsv.hcg = function(e) {
  const t = e[1] / 100, n = e[2] / 100, r = t * n;
  let o = 0;
  return r < 1 && (o = (n - r) / (1 - r)), [e[0], r * 100, o * 100];
};
ve.hcg.rgb = function(e) {
  const t = e[0] / 360, n = e[1] / 100, r = e[2] / 100;
  if (n === 0)
    return [r * 255, r * 255, r * 255];
  const o = [0, 0, 0], a = t % 1 * 6, l = a % 1, u = 1 - l;
  let d = 0;
  switch (Math.floor(a)) {
    case 0: {
      o[0] = 1, o[1] = l, o[2] = 0;
      break;
    }
    case 1: {
      o[0] = u, o[1] = 1, o[2] = 0;
      break;
    }
    case 2: {
      o[0] = 0, o[1] = 1, o[2] = l;
      break;
    }
    case 3: {
      o[0] = 0, o[1] = u, o[2] = 1;
      break;
    }
    case 4: {
      o[0] = l, o[1] = 0, o[2] = 1;
      break;
    }
    default:
      o[0] = 1, o[1] = 0, o[2] = u;
  }
  return d = (1 - n) * r, [
    (n * o[0] + d) * 255,
    (n * o[1] + d) * 255,
    (n * o[2] + d) * 255
  ];
};
ve.hcg.hsv = function(e) {
  const t = e[1] / 100, n = e[2] / 100, r = t + n * (1 - t);
  let o = 0;
  return r > 0 && (o = t / r), [e[0], o * 100, r * 100];
};
ve.hcg.hsl = function(e) {
  const t = e[1] / 100, n = e[2] / 100 * (1 - t) + 0.5 * t;
  let r = 0;
  return n > 0 && n < 0.5 ? r = t / (2 * n) : n >= 0.5 && n < 1 && (r = t / (2 * (1 - n))), [e[0], r * 100, n * 100];
};
ve.hcg.hwb = function(e) {
  const t = e[1] / 100, n = e[2] / 100, r = t + n * (1 - t);
  return [e[0], (r - t) * 100, (1 - r) * 100];
};
ve.hwb.hcg = function(e) {
  const t = e[1] / 100, n = 1 - e[2] / 100, r = n - t;
  let o = 0;
  return r < 1 && (o = (n - r) / (1 - r)), [e[0], r * 100, o * 100];
};
ve.apple.rgb = function(e) {
  return [e[0] / 65535 * 255, e[1] / 65535 * 255, e[2] / 65535 * 255];
};
ve.rgb.apple = function(e) {
  return [e[0] / 255 * 65535, e[1] / 255 * 65535, e[2] / 255 * 65535];
};
ve.gray.rgb = function(e) {
  return [e[0] / 100 * 255, e[0] / 100 * 255, e[0] / 100 * 255];
};
ve.gray.hsl = function(e) {
  return [0, 0, e[0]];
};
ve.gray.hsv = ve.gray.hsl;
ve.gray.hwb = function(e) {
  return [0, 100, e[0]];
};
ve.gray.cmyk = function(e) {
  return [0, 0, 0, e[0]];
};
ve.gray.lab = function(e) {
  return [e[0], 0, 0];
};
ve.gray.hex = function(e) {
  const t = Math.round(e[0] / 100 * 255) & 255, n = ((t << 16) + (t << 8) + t).toString(16).toUpperCase();
  return "000000".slice(n.length) + n;
};
ve.rgb.gray = function(e) {
  return [(e[0] + e[1] + e[2]) / 3 / 255 * 100];
};
function Die() {
  const e = {}, t = Object.keys(ve);
  for (let { length: n } = t, r = 0; r < n; r++)
    e[t[r]] = {
      // http://jsperf.com/1-vs-infinity
      // micro-opt, but this is simple.
      distance: -1,
      parent: null
    };
  return e;
}
function Tie(e) {
  const t = Die(), n = [e];
  for (t[e].distance = 0; n.length > 0; ) {
    const r = n.pop(), o = Object.keys(ve[r]);
    for (let { length: a } = o, l = 0; l < a; l++) {
      const u = o[l], d = t[u];
      d.distance === -1 && (d.distance = t[r].distance + 1, d.parent = r, n.unshift(u));
    }
  }
  return t;
}
function zie(e, t) {
  return function(n) {
    return t(e(n));
  };
}
function Pie(e, t) {
  const n = [t[e].parent, e];
  let r = ve[t[e].parent][e], o = t[e].parent;
  for (; t[o].parent; )
    n.unshift(t[o].parent), r = zie(ve[t[o].parent][o], r), o = t[o].parent;
  return r.conversion = n, r;
}
function Lie(e) {
  const t = Tie(e), n = {}, r = Object.keys(t);
  for (let { length: o } = r, a = 0; a < o; a++) {
    const l = r[a];
    t[l].parent !== null && (n[l] = Pie(l, t));
  }
  return n;
}
const ba = {}, Iie = Object.keys(ve);
function Bie(e) {
  const t = function(...n) {
    const r = n[0];
    return r == null ? r : (r.length > 1 && (n = r), e(n));
  };
  return "conversion" in e && (t.conversion = e.conversion), t;
}
function Vie(e) {
  const t = function(...n) {
    const r = n[0];
    if (r == null)
      return r;
    r.length > 1 && (n = r);
    const o = e(n);
    if (typeof o == "object")
      for (let { length: a } = o, l = 0; l < a; l++)
        o[l] = Math.round(o[l]);
    return o;
  };
  return "conversion" in e && (t.conversion = e.conversion), t;
}
for (const e of Iie) {
  ba[e] = {}, Object.defineProperty(ba[e], "channels", { value: ve[e].channels }), Object.defineProperty(ba[e], "labels", { value: ve[e].labels });
  const t = Lie(e), n = Object.keys(t);
  for (const r of n) {
    const o = t[r];
    ba[e][r] = Vie(o), ba[e][r].raw = Bie(o);
  }
}
const Hie = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: ba
}, Symbol.toStringTag, { value: "Module" })), pn = (e, t) => {
  const n = Array.isArray(t) ? t : [t];
  if (n[0] === void 0 || n[0] === null)
    return pn("rgb", [0, 0, 0]);
  const r = ba[e];
  if (!r)
    throw new Error(
      `Unsupported color type: ${e} allowed are ${Object.keys(Hie).join(
        ", "
      )}`
    );
  r[e] = () => n;
  const o = (l) => {
    const u = l(...n);
    return Array.isArray(u) ? u[0] != null : u;
  };
  if (!o(r.rgb) || !o(r.hsl))
    return pn("rgb", [0, 0, 0]);
  const a = {};
  return Object.keys(r).forEach((l) => {
    const u = r[l];
    typeof u == "function" && (a[l] = () => l === e ? n : u(...n));
  }), a;
}, Uie = ({
  onChange: e,
  colorconverter: t,
  allow_null: n = !1
}) => {
  if (t === null && !n)
    throw new Error("Color converter is null");
  const [r, o] = _.useState(t), [a, l] = _.useState([0, 0, 0]), [u, d] = _.useState([0, 0, 0]), [f, p] = _.useState([0, 0, 0]), [m, g] = _.useState("000");
  _.useEffect(() => {
    if (!r) {
      if (!n) throw new Error("Color converter is null");
      d([0, 0, 0]), l([0, 0, 0]), p([0, 0, 0]), g("");
      return;
    }
    l(r.hsl()), d(r.rgb()), p(r.hsv()), g(r.hex());
  }, [r]);
  const y = {
    backgroundColor: `hsl(${a[0]}, ${a[1]}%, ${a[2]}%)`,
    padding: "10px",
    margin: "10px 0"
  };
  return /* @__PURE__ */ k.jsxs("div", { style: { backgroundColor: "white" }, children: [
    /* @__PURE__ */ k.jsx("div", { style: y, children: "Color Preview" }),
    /* @__PURE__ */ k.jsxs("div", { className: "colorspace", children: [
      /* @__PURE__ */ k.jsx("div", { className: "colorspace_title", children: "RGB" }),
      /* @__PURE__ */ k.jsx("div", {}),
      /* @__PURE__ */ k.jsx("label", { children: "Red" }),
      /* @__PURE__ */ k.jsx(
        "input",
        {
          type: "range",
          min: "0",
          max: "255",
          value: u[0],
          onChange: (w) => {
            const v = [parseInt(w.target.value), u[1], u[2]], x = pn("rgb", v);
            o(x), e(x);
          },
          style: { background: "linear-gradient(to right, #000, #f00)" }
        }
      ),
      /* @__PURE__ */ k.jsx("label", { children: "Green" }),
      /* @__PURE__ */ k.jsx(
        "input",
        {
          type: "range",
          min: "0",
          max: "255",
          value: u[1],
          onChange: (w) => {
            const v = [u[0], parseInt(w.target.value), u[2]], x = pn("rgb", v);
            o(x), e(x);
          },
          style: { background: "linear-gradient(to right, #000, #0f0)" }
        }
      ),
      /* @__PURE__ */ k.jsx("label", { children: "Blue" }),
      /* @__PURE__ */ k.jsx(
        "input",
        {
          type: "range",
          min: "0",
          max: "255",
          value: u[2],
          onChange: (w) => {
            const v = [u[0], u[1], parseInt(w.target.value)], x = pn("rgb", v);
            o(x), e(x);
          },
          style: { background: "linear-gradient(to right, #000, #00f)" }
        }
      )
    ] }),
    /* @__PURE__ */ k.jsxs("div", { className: "colorspace", children: [
      /* @__PURE__ */ k.jsx("div", { className: "colorspace_title", children: "HSL" }),
      /* @__PURE__ */ k.jsx("div", {}),
      /* @__PURE__ */ k.jsx("label", { children: "Hue" }),
      /* @__PURE__ */ k.jsx(
        "input",
        {
          type: "range",
          min: "0",
          max: "360",
          value: a[0],
          onChange: (w) => {
            const v = [parseInt(w.target.value), a[1], a[2]], x = pn("hsl", v);
            o(x), e(x);
          },
          style: {
            background: "linear-gradient(to right, #f00, #ff0, #0f0, #0ff, #00f, #f0f, #f00)"
          }
        }
      ),
      /* @__PURE__ */ k.jsx("label", { children: "Saturation" }),
      /* @__PURE__ */ k.jsx(
        "input",
        {
          type: "range",
          min: "0",
          max: "100",
          value: a[1],
          onChange: (w) => {
            const v = [a[0], parseInt(w.target.value), a[2]], x = pn("hsl", v);
            o(x), e(x);
          },
          style: {
            background: `linear-gradient(to right, #fff, hsl(${a[0]}, 100%, 50%))`
          }
        }
      ),
      /* @__PURE__ */ k.jsx("label", { children: "Lightness" }),
      /* @__PURE__ */ k.jsx(
        "input",
        {
          type: "range",
          min: "0",
          max: "100",
          value: a[2],
          onChange: (w) => {
            const v = [a[0], a[1], parseInt(w.target.value)], x = pn("hsl", v);
            o(x), e(x);
          },
          style: {
            background: `linear-gradient(to right, #000, hsl(${a[0]}, 100%, 50%), #fff)`
          }
        }
      )
    ] }),
    /* @__PURE__ */ k.jsxs("div", { className: "colorspace", children: [
      /* @__PURE__ */ k.jsx("div", { className: "colorspace_title", children: "HSV" }),
      /* @__PURE__ */ k.jsx("div", {}),
      /* @__PURE__ */ k.jsx("label", { children: "Hue" }),
      /* @__PURE__ */ k.jsx(
        "input",
        {
          type: "range",
          min: "0",
          max: "360",
          value: f[0],
          onChange: (w) => {
            const v = [parseInt(w.target.value), f[1], f[2]], x = pn("hsv", v);
            o(x), e(x);
          },
          style: {
            background: "linear-gradient(to right, #f00, #ff0, #0f0, #0ff, #00f, #f0f, #f00)"
          }
        }
      ),
      /* @__PURE__ */ k.jsx("label", { children: "Saturation" }),
      /* @__PURE__ */ k.jsx(
        "input",
        {
          type: "range",
          min: "0",
          max: "100",
          value: f[1],
          onChange: (w) => {
            const v = [f[0], parseInt(w.target.value), f[2]], x = pn("hsv", v);
            o(x), e(x);
          },
          style: {
            background: `linear-gradient(to right, #fff, hsl(${a[0]}, 100%, 50%))`
          }
        }
      ),
      /* @__PURE__ */ k.jsx("label", { children: "Value" }),
      /* @__PURE__ */ k.jsx(
        "input",
        {
          type: "range",
          min: "0",
          max: "100",
          value: f[2],
          onChange: (w) => {
            const v = [f[0], f[1], parseInt(w.target.value)], x = pn("hsv", v);
            o(x), e(x);
          },
          style: {
            background: `linear-gradient(to right, #000, hsl(${a[0]}, 100%, 50%))`
          }
        }
      )
    ] }),
    /* @__PURE__ */ k.jsxs("div", { className: "colorspace", children: [
      /* @__PURE__ */ k.jsx("div", { className: "colorspace_title", children: "HEX" }),
      /* @__PURE__ */ k.jsx("div", {}),
      /* @__PURE__ */ k.jsx(
        "input",
        {
          type: "text",
          value: m,
          onChange: (w) => {
            const v = w.target.value === "" ? null : pn("hex", [w.target.value]);
            o(v), e(v);
          }
        }
      )
    ] })
  ] });
}, Fie = ({
  inicolordata: e,
  inicolorspace: t,
  allow_null: n = !1,
  delay: r = 1e3,
  onChange: o
}) => {
  const a = e !== void 0 ? e : [0, 0, 0], l = e === void 0 ? "rgb" : t || "hex", u = Array.isArray(a) ? a : [a], d = _.useMemo(() => {
    let x = pn(l, u);
    return x.rgb() === void 0 && (x = pn("rgb", [0, 0, 0])), x;
  }, [l, u]), [f, p] = _.useState(d);
  _.useEffect(() => {
    const x = e !== void 0 ? e : [0, 0, 0], E = e === void 0 ? "rgb" : t || "hex", N = Array.isArray(x) ? x : [x];
    let C = pn(E, N);
    C.rgb() === void 0 && (C = pn("rgb", [0, 0, 0])), p(C);
  }, [JSON.stringify(e), t]);
  const m = _.useContext(Ge), g = m.local_state(() => m.reactflowRef), y = _.useRef(null), w = _.useCallback(
    (x) => {
      if (x === null && !n)
        throw new Error("Color is null");
      x !== null && p(x), y.current && clearTimeout(y.current), o && (y.current = setTimeout(() => {
        o(x), y.current = null;
      }, r));
    },
    [n, o, r]
  );
  _.useEffect(() => () => {
    y.current && clearTimeout(y.current);
  }, []);
  const v = _.useMemo(
    () => ({
      background: "#" + f.hex(),
      borderRadius: "0.3rem",
      width: "2rem",
      height: "1rem"
    }),
    [f]
  );
  return /* @__PURE__ */ k.jsxs(GR, { children: [
    /* @__PURE__ */ k.jsx(ZR, { asChild: !0, children: /* @__PURE__ */ k.jsx("button", { style: v }) }),
    /* @__PURE__ */ k.jsx(WR, { container: g, children: /* @__PURE__ */ k.jsx(KR, { side: "left", className: "iotooltipcontent", children: /* @__PURE__ */ k.jsx(
      Uie,
      {
        onChange: w,
        colorconverter: f,
        allow_null: n
      }
    ) }) })
  ] });
};
function Ba(e) {
  "@babel/helpers - typeof";
  return Ba = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, Ba(e);
}
function $ie(e, t) {
  if (Ba(e) != "object" || !e) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t);
    if (Ba(r) != "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function rD(e) {
  var t = $ie(e, "string");
  return Ba(t) == "symbol" ? t : t + "";
}
function Zu(e, t, n) {
  return (t = rD(t)) in e ? Object.defineProperty(e, t, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = n, e;
}
function aO(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Ae(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? aO(Object(n), !0).forEach(function(r) {
      Zu(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : aO(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function Yie(e) {
  if (Array.isArray(e)) return e;
}
function qie(e, t) {
  var n = e == null ? null : typeof Symbol < "u" && e[Symbol.iterator] || e["@@iterator"];
  if (n != null) {
    var r, o, a, l, u = [], d = !0, f = !1;
    try {
      if (a = (n = n.call(e)).next, t === 0) {
        if (Object(n) !== n) return;
        d = !1;
      } else for (; !(d = (r = a.call(n)).done) && (u.push(r.value), u.length !== t); d = !0) ;
    } catch (p) {
      f = !0, o = p;
    } finally {
      try {
        if (!d && n.return != null && (l = n.return(), Object(l) !== l)) return;
      } finally {
        if (f) throw o;
      }
    }
    return u;
  }
}
function ew(e, t) {
  (t == null || t > e.length) && (t = e.length);
  for (var n = 0, r = Array(t); n < t; n++) r[n] = e[n];
  return r;
}
function oD(e, t) {
  if (e) {
    if (typeof e == "string") return ew(e, t);
    var n = {}.toString.call(e).slice(8, -1);
    return n === "Object" && e.constructor && (n = e.constructor.name), n === "Map" || n === "Set" ? Array.from(e) : n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n) ? ew(e, t) : void 0;
  }
}
function Xie() {
  throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function Uo(e, t) {
  return Yie(e) || qie(e, t) || oD(e, t) || Xie();
}
function ei(e, t) {
  if (e == null) return {};
  var n, r, o = Gx(e, t);
  if (Object.getOwnPropertySymbols) {
    var a = Object.getOwnPropertySymbols(e);
    for (r = 0; r < a.length; r++) n = a[r], t.indexOf(n) === -1 && {}.propertyIsEnumerable.call(e, n) && (o[n] = e[n]);
  }
  return o;
}
var Gie = ["defaultInputValue", "defaultMenuIsOpen", "defaultValue", "inputValue", "menuIsOpen", "onChange", "onInputChange", "onMenuClose", "onMenuOpen", "value"];
function Zie(e) {
  var t = e.defaultInputValue, n = t === void 0 ? "" : t, r = e.defaultMenuIsOpen, o = r === void 0 ? !1 : r, a = e.defaultValue, l = a === void 0 ? null : a, u = e.inputValue, d = e.menuIsOpen, f = e.onChange, p = e.onInputChange, m = e.onMenuClose, g = e.onMenuOpen, y = e.value, w = ei(e, Gie), v = _.useState(u !== void 0 ? u : n), x = Uo(v, 2), E = x[0], N = x[1], C = _.useState(d !== void 0 ? d : o), A = Uo(C, 2), R = A[0], D = A[1], T = _.useState(y !== void 0 ? y : l), V = Uo(T, 2), F = V[0], O = V[1], B = _.useCallback(function(q, Y) {
    typeof f == "function" && f(q, Y), O(q);
  }, [f]), U = _.useCallback(function(q, Y) {
    var M;
    typeof p == "function" && (M = p(q, Y)), N(M !== void 0 ? M : q);
  }, [p]), G = _.useCallback(function() {
    typeof g == "function" && g(), D(!0);
  }, [g]), z = _.useCallback(function() {
    typeof m == "function" && m(), D(!1);
  }, [m]), $ = u !== void 0 ? u : E, L = d !== void 0 ? d : R, H = y !== void 0 ? y : F;
  return Ae(Ae({}, w), {}, {
    inputValue: $,
    menuIsOpen: L,
    onChange: B,
    onInputChange: U,
    onMenuClose: z,
    onMenuOpen: G,
    value: H
  });
}
function Wie(e, t) {
  if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function");
}
function lO(e, t) {
  for (var n = 0; n < t.length; n++) {
    var r = t[n];
    r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, rD(r.key), r);
  }
}
function Kie(e, t, n) {
  return t && lO(e.prototype, t), n && lO(e, n), Object.defineProperty(e, "prototype", {
    writable: !1
  }), e;
}
function Qie(e, t) {
  if (typeof t != "function" && t !== null) throw new TypeError("Super expression must either be null or a function");
  e.prototype = Object.create(t && t.prototype, {
    constructor: {
      value: e,
      writable: !0,
      configurable: !0
    }
  }), Object.defineProperty(e, "prototype", {
    writable: !1
  }), t && Xp(e, t);
}
function Zp(e) {
  return Zp = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t) {
    return t.__proto__ || Object.getPrototypeOf(t);
  }, Zp(e);
}
function iD() {
  try {
    var e = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
  } catch {
  }
  return (iD = function() {
    return !!e;
  })();
}
function Jie(e, t) {
  if (t && (Ba(t) == "object" || typeof t == "function")) return t;
  if (t !== void 0) throw new TypeError("Derived constructors may only return object or undefined");
  return zj(e);
}
function eae(e) {
  var t = iD();
  return function() {
    var n, r = Zp(e);
    if (t) {
      var o = Zp(this).constructor;
      n = Reflect.construct(r, arguments, o);
    } else n = r.apply(this, arguments);
    return Jie(this, n);
  };
}
function tae(e) {
  if (Array.isArray(e)) return ew(e);
}
function nae(e) {
  if (typeof Symbol < "u" && e[Symbol.iterator] != null || e["@@iterator"] != null) return Array.from(e);
}
function rae() {
  throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function eS(e) {
  return tae(e) || nae(e) || oD(e) || rae();
}
function oae(e, t) {
  return t || (t = e.slice(0)), Object.freeze(Object.defineProperties(e, {
    raw: {
      value: Object.freeze(t)
    }
  }));
}
var tw = _.useLayoutEffect, iae = ["className", "clearValue", "cx", "getStyles", "getClassNames", "getValue", "hasValue", "isMulti", "isRtl", "options", "selectOption", "selectProps", "setValue", "theme"], Wp = function() {
};
function aae(e, t) {
  return t ? t[0] === "-" ? e + t : e + "__" + t : e;
}
function lae(e, t) {
  for (var n = arguments.length, r = new Array(n > 2 ? n - 2 : 0), o = 2; o < n; o++)
    r[o - 2] = arguments[o];
  var a = [].concat(r);
  if (t && e)
    for (var l in t)
      t.hasOwnProperty(l) && t[l] && a.push("".concat(aae(e, l)));
  return a.filter(function(u) {
    return u;
  }).map(function(u) {
    return String(u).trim();
  }).join(" ");
}
var sO = function(e) {
  return gae(e) ? e.filter(Boolean) : Ba(e) === "object" && e !== null ? [e] : [];
}, aD = function(e) {
  e.className, e.clearValue, e.cx, e.getStyles, e.getClassNames, e.getValue, e.hasValue, e.isMulti, e.isRtl, e.options, e.selectOption, e.selectProps, e.setValue, e.theme;
  var t = ei(e, iae);
  return Ae({}, t);
}, At = function(e, t, n) {
  var r = e.cx, o = e.getStyles, a = e.getClassNames, l = e.className;
  return {
    css: o(t, e),
    className: r(n ?? {}, a(t, e), l)
  };
};
function sm(e) {
  return [document.documentElement, document.body, window].indexOf(e) > -1;
}
function sae(e) {
  return sm(e) ? window.innerHeight : e.clientHeight;
}
function lD(e) {
  return sm(e) ? window.pageYOffset : e.scrollTop;
}
function Kp(e, t) {
  if (sm(e)) {
    window.scrollTo(0, t);
    return;
  }
  e.scrollTop = t;
}
function uae(e) {
  var t = getComputedStyle(e), n = t.position === "absolute", r = /(auto|scroll)/;
  if (t.position === "fixed") return document.documentElement;
  for (var o = e; o = o.parentElement; )
    if (t = getComputedStyle(o), !(n && t.position === "static") && r.test(t.overflow + t.overflowY + t.overflowX))
      return o;
  return document.documentElement;
}
function cae(e, t, n, r) {
  return n * ((e = e / r - 1) * e * e + 1) + t;
}
function Yf(e, t) {
  var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 200, r = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : Wp, o = lD(e), a = t - o, l = 10, u = 0;
  function d() {
    u += l;
    var f = cae(u, o, a, n);
    Kp(e, f), u < n ? window.requestAnimationFrame(d) : r(e);
  }
  d();
}
function uO(e, t) {
  var n = e.getBoundingClientRect(), r = t.getBoundingClientRect(), o = t.offsetHeight / 3;
  r.bottom + o > n.bottom ? Kp(e, Math.min(t.offsetTop + t.clientHeight - e.offsetHeight + o, e.scrollHeight)) : r.top - o < n.top && Kp(e, Math.max(t.offsetTop - o, 0));
}
function dae(e) {
  var t = e.getBoundingClientRect();
  return {
    bottom: t.bottom,
    height: t.height,
    left: t.left,
    right: t.right,
    top: t.top,
    width: t.width
  };
}
function cO() {
  try {
    return document.createEvent("TouchEvent"), !0;
  } catch {
    return !1;
  }
}
function fae() {
  try {
    return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
  } catch {
    return !1;
  }
}
var sD = !1, pae = {
  get passive() {
    return sD = !0;
  }
}, qf = typeof window < "u" ? window : {};
qf.addEventListener && qf.removeEventListener && (qf.addEventListener("p", Wp, pae), qf.removeEventListener("p", Wp, !1));
var hae = sD;
function mae(e) {
  return e != null;
}
function gae(e) {
  return Array.isArray(e);
}
function Xf(e, t, n) {
  return e ? t : n;
}
var yae = function(e) {
  for (var t = arguments.length, n = new Array(t > 1 ? t - 1 : 0), r = 1; r < t; r++)
    n[r - 1] = arguments[r];
  var o = Object.entries(e).filter(function(a) {
    var l = Uo(a, 1), u = l[0];
    return !n.includes(u);
  });
  return o.reduce(function(a, l) {
    var u = Uo(l, 2), d = u[0], f = u[1];
    return a[d] = f, a;
  }, {});
}, vae = ["children", "innerProps"], bae = ["children", "innerProps"];
function wae(e) {
  var t = e.maxHeight, n = e.menuEl, r = e.minHeight, o = e.placement, a = e.shouldScroll, l = e.isFixedPosition, u = e.controlHeight, d = uae(n), f = {
    placement: "bottom",
    maxHeight: t
  };
  if (!n || !n.offsetParent) return f;
  var p = d.getBoundingClientRect(), m = p.height, g = n.getBoundingClientRect(), y = g.bottom, w = g.height, v = g.top, x = n.offsetParent.getBoundingClientRect(), E = x.top, N = l ? window.innerHeight : sae(d), C = lD(d), A = parseInt(getComputedStyle(n).marginBottom, 10), R = parseInt(getComputedStyle(n).marginTop, 10), D = E - R, T = N - v, V = D + C, F = m - C - v, O = y - N + C + A, B = C + v - R, U = 160;
  switch (o) {
    case "auto":
    case "bottom":
      if (T >= w)
        return {
          placement: "bottom",
          maxHeight: t
        };
      if (F >= w && !l)
        return a && Yf(d, O, U), {
          placement: "bottom",
          maxHeight: t
        };
      if (!l && F >= r || l && T >= r) {
        a && Yf(d, O, U);
        var G = l ? T - A : F - A;
        return {
          placement: "bottom",
          maxHeight: G
        };
      }
      if (o === "auto" || l) {
        var z = t, $ = l ? D : V;
        return $ >= r && (z = Math.min($ - A - u, t)), {
          placement: "top",
          maxHeight: z
        };
      }
      if (o === "bottom")
        return a && Kp(d, O), {
          placement: "bottom",
          maxHeight: t
        };
      break;
    case "top":
      if (D >= w)
        return {
          placement: "top",
          maxHeight: t
        };
      if (V >= w && !l)
        return a && Yf(d, B, U), {
          placement: "top",
          maxHeight: t
        };
      if (!l && V >= r || l && D >= r) {
        var L = t;
        return (!l && V >= r || l && D >= r) && (L = l ? D - R : V - R), a && Yf(d, B, U), {
          placement: "top",
          maxHeight: L
        };
      }
      return {
        placement: "bottom",
        maxHeight: t
      };
    default:
      throw new Error('Invalid placement provided "'.concat(o, '".'));
  }
  return f;
}
function xae(e) {
  var t = {
    bottom: "top",
    top: "bottom"
  };
  return e ? t[e] : "bottom";
}
var uD = function(e) {
  return e === "auto" ? "bottom" : e;
}, Sae = function(e, t) {
  var n, r = e.placement, o = e.theme, a = o.borderRadius, l = o.spacing, u = o.colors;
  return Ae((n = {
    label: "menu"
  }, Zu(n, xae(r), "100%"), Zu(n, "position", "absolute"), Zu(n, "width", "100%"), Zu(n, "zIndex", 1), n), t ? {} : {
    backgroundColor: u.neutral0,
    borderRadius: a,
    boxShadow: "0 0 0 1px hsla(0, 0%, 0%, 0.1), 0 4px 11px hsla(0, 0%, 0%, 0.1)",
    marginBottom: l.menuGutter,
    marginTop: l.menuGutter
  });
}, cD = /* @__PURE__ */ _.createContext(null), kae = function(e) {
  var t = e.children, n = e.minMenuHeight, r = e.maxMenuHeight, o = e.menuPlacement, a = e.menuPosition, l = e.menuShouldScrollIntoView, u = e.theme, d = _.useContext(cD) || {}, f = d.setPortalPlacement, p = _.useRef(null), m = _.useState(r), g = Uo(m, 2), y = g[0], w = g[1], v = _.useState(null), x = Uo(v, 2), E = x[0], N = x[1], C = u.spacing.controlHeight;
  return tw(function() {
    var A = p.current;
    if (A) {
      var R = a === "fixed", D = l && !R, T = wae({
        maxHeight: r,
        menuEl: A,
        minHeight: n,
        placement: o,
        shouldScroll: D,
        isFixedPosition: R,
        controlHeight: C
      });
      w(T.maxHeight), N(T.placement), f?.(T.placement);
    }
  }, [r, o, a, l, n, f, C]), t({
    ref: p,
    placerProps: Ae(Ae({}, e), {}, {
      placement: E || uD(o),
      maxHeight: y
    })
  });
}, _ae = function(e) {
  var t = e.children, n = e.innerRef, r = e.innerProps;
  return Oe("div", Ne({}, At(e, "menu", {
    menu: !0
  }), {
    ref: n
  }, r), t);
}, Eae = _ae, Cae = function(e, t) {
  var n = e.maxHeight, r = e.theme.spacing.baseUnit;
  return Ae({
    maxHeight: n,
    overflowY: "auto",
    position: "relative",
    // required for offset[Height, Top] > keyboard scroll
    WebkitOverflowScrolling: "touch"
  }, t ? {} : {
    paddingBottom: r,
    paddingTop: r
  });
}, Oae = function(e) {
  var t = e.children, n = e.innerProps, r = e.innerRef, o = e.isMulti;
  return Oe("div", Ne({}, At(e, "menuList", {
    "menu-list": !0,
    "menu-list--is-multi": o
  }), {
    ref: r
  }, n), t);
}, dD = function(e, t) {
  var n = e.theme, r = n.spacing.baseUnit, o = n.colors;
  return Ae({
    textAlign: "center"
  }, t ? {} : {
    color: o.neutral40,
    padding: "".concat(r * 2, "px ").concat(r * 3, "px")
  });
}, Nae = dD, Mae = dD, Aae = function(e) {
  var t = e.children, n = t === void 0 ? "No options" : t, r = e.innerProps, o = ei(e, vae);
  return Oe("div", Ne({}, At(Ae(Ae({}, o), {}, {
    children: n,
    innerProps: r
  }), "noOptionsMessage", {
    "menu-notice": !0,
    "menu-notice--no-options": !0
  }), r), n);
}, Rae = function(e) {
  var t = e.children, n = t === void 0 ? "Loading..." : t, r = e.innerProps, o = ei(e, bae);
  return Oe("div", Ne({}, At(Ae(Ae({}, o), {}, {
    children: n,
    innerProps: r
  }), "loadingMessage", {
    "menu-notice": !0,
    "menu-notice--loading": !0
  }), r), n);
}, jae = function(e) {
  var t = e.rect, n = e.offset, r = e.position;
  return {
    left: t.left,
    position: r,
    top: n,
    width: t.width,
    zIndex: 1
  };
}, Dae = function(e) {
  var t = e.appendTo, n = e.children, r = e.controlElement, o = e.innerProps, a = e.menuPlacement, l = e.menuPosition, u = _.useRef(null), d = _.useRef(null), f = _.useState(uD(a)), p = Uo(f, 2), m = p[0], g = p[1], y = _.useMemo(function() {
    return {
      setPortalPlacement: g
    };
  }, []), w = _.useState(null), v = Uo(w, 2), x = v[0], E = v[1], N = _.useCallback(function() {
    if (r) {
      var D = dae(r), T = l === "fixed" ? 0 : window.pageYOffset, V = D[m] + T;
      (V !== x?.offset || D.left !== x?.rect.left || D.width !== x?.rect.width) && E({
        offset: V,
        rect: D
      });
    }
  }, [r, l, m, x?.offset, x?.rect.left, x?.rect.width]);
  tw(function() {
    N();
  }, [N]);
  var C = _.useCallback(function() {
    typeof d.current == "function" && (d.current(), d.current = null), r && u.current && (d.current = xM(r, u.current, N, {
      elementResize: "ResizeObserver" in window
    }));
  }, [r, N]);
  tw(function() {
    C();
  }, [C]);
  var A = _.useCallback(function(D) {
    u.current = D, C();
  }, [C]);
  if (!t && l !== "fixed" || !x) return null;
  var R = Oe("div", Ne({
    ref: A
  }, At(Ae(Ae({}, e), {}, {
    offset: x.offset,
    position: l,
    rect: x.rect
  }), "menuPortal", {
    "menu-portal": !0
  }), o), n);
  return Oe(cD.Provider, {
    value: y
  }, t ? /* @__PURE__ */ Mc.createPortal(R, t) : R);
}, Tae = function(e) {
  var t = e.isDisabled, n = e.isRtl;
  return {
    label: "container",
    direction: n ? "rtl" : void 0,
    pointerEvents: t ? "none" : void 0,
    // cancel mouse events when disabled
    position: "relative"
  };
}, zae = function(e) {
  var t = e.children, n = e.innerProps, r = e.isDisabled, o = e.isRtl;
  return Oe("div", Ne({}, At(e, "container", {
    "--is-disabled": r,
    "--is-rtl": o
  }), n), t);
}, Pae = function(e, t) {
  var n = e.theme.spacing, r = e.isMulti, o = e.hasValue, a = e.selectProps.controlShouldRenderValue;
  return Ae({
    alignItems: "center",
    display: r && o && a ? "flex" : "grid",
    flex: 1,
    flexWrap: "wrap",
    WebkitOverflowScrolling: "touch",
    position: "relative",
    overflow: "hidden"
  }, t ? {} : {
    padding: "".concat(n.baseUnit / 2, "px ").concat(n.baseUnit * 2, "px")
  });
}, Lae = function(e) {
  var t = e.children, n = e.innerProps, r = e.isMulti, o = e.hasValue;
  return Oe("div", Ne({}, At(e, "valueContainer", {
    "value-container": !0,
    "value-container--is-multi": r,
    "value-container--has-value": o
  }), n), t);
}, Iae = function() {
  return {
    alignItems: "center",
    alignSelf: "stretch",
    display: "flex",
    flexShrink: 0
  };
}, Bae = function(e) {
  var t = e.children, n = e.innerProps;
  return Oe("div", Ne({}, At(e, "indicatorsContainer", {
    indicators: !0
  }), n), t);
}, dO, Vae = ["size"], Hae = ["innerProps", "isRtl", "size"], Uae = {
  name: "8mmkcg",
  styles: "display:inline-block;fill:currentColor;line-height:1;stroke:currentColor;stroke-width:0"
}, fD = function(e) {
  var t = e.size, n = ei(e, Vae);
  return Oe("svg", Ne({
    height: t,
    width: t,
    viewBox: "0 0 20 20",
    "aria-hidden": "true",
    focusable: "false",
    css: Uae
  }, n));
}, tS = function(e) {
  return Oe(fD, Ne({
    size: 20
  }, e), Oe("path", {
    d: "M14.348 14.849c-0.469 0.469-1.229 0.469-1.697 0l-2.651-3.030-2.651 3.029c-0.469 0.469-1.229 0.469-1.697 0-0.469-0.469-0.469-1.229 0-1.697l2.758-3.15-2.759-3.152c-0.469-0.469-0.469-1.228 0-1.697s1.228-0.469 1.697 0l2.652 3.031 2.651-3.031c0.469-0.469 1.228-0.469 1.697 0s0.469 1.229 0 1.697l-2.758 3.152 2.758 3.15c0.469 0.469 0.469 1.229 0 1.698z"
  }));
}, pD = function(e) {
  return Oe(fD, Ne({
    size: 20
  }, e), Oe("path", {
    d: "M4.516 7.548c0.436-0.446 1.043-0.481 1.576 0l3.908 3.747 3.908-3.747c0.533-0.481 1.141-0.446 1.574 0 0.436 0.445 0.408 1.197 0 1.615-0.406 0.418-4.695 4.502-4.695 4.502-0.217 0.223-0.502 0.335-0.787 0.335s-0.57-0.112-0.789-0.335c0 0-4.287-4.084-4.695-4.502s-0.436-1.17 0-1.615z"
  }));
}, hD = function(e, t) {
  var n = e.isFocused, r = e.theme, o = r.spacing.baseUnit, a = r.colors;
  return Ae({
    label: "indicatorContainer",
    display: "flex",
    transition: "color 150ms"
  }, t ? {} : {
    color: n ? a.neutral60 : a.neutral20,
    padding: o * 2,
    ":hover": {
      color: n ? a.neutral80 : a.neutral40
    }
  });
}, Fae = hD, $ae = function(e) {
  var t = e.children, n = e.innerProps;
  return Oe("div", Ne({}, At(e, "dropdownIndicator", {
    indicator: !0,
    "dropdown-indicator": !0
  }), n), t || Oe(pD, null));
}, Yae = hD, qae = function(e) {
  var t = e.children, n = e.innerProps;
  return Oe("div", Ne({}, At(e, "clearIndicator", {
    indicator: !0,
    "clear-indicator": !0
  }), n), t || Oe(tS, null));
}, Xae = function(e, t) {
  var n = e.isDisabled, r = e.theme, o = r.spacing.baseUnit, a = r.colors;
  return Ae({
    label: "indicatorSeparator",
    alignSelf: "stretch",
    width: 1
  }, t ? {} : {
    backgroundColor: n ? a.neutral10 : a.neutral20,
    marginBottom: o * 2,
    marginTop: o * 2
  });
}, Gae = function(e) {
  var t = e.innerProps;
  return Oe("span", Ne({}, t, At(e, "indicatorSeparator", {
    "indicator-separator": !0
  })));
}, Zae = tm(dO || (dO = oae([`
  0%, 80%, 100% { opacity: 0; }
  40% { opacity: 1; }
`]))), Wae = function(e, t) {
  var n = e.isFocused, r = e.size, o = e.theme, a = o.colors, l = o.spacing.baseUnit;
  return Ae({
    label: "loadingIndicator",
    display: "flex",
    transition: "color 150ms",
    alignSelf: "center",
    fontSize: r,
    lineHeight: 1,
    marginRight: r,
    textAlign: "center",
    verticalAlign: "middle"
  }, t ? {} : {
    color: n ? a.neutral60 : a.neutral20,
    padding: l * 2
  });
}, Av = function(e) {
  var t = e.delay, n = e.offset;
  return Oe("span", {
    css: /* @__PURE__ */ $x({
      animation: "".concat(Zae, " 1s ease-in-out ").concat(t, "ms infinite;"),
      backgroundColor: "currentColor",
      borderRadius: "1em",
      display: "inline-block",
      marginLeft: n ? "1em" : void 0,
      height: "1em",
      verticalAlign: "top",
      width: "1em"
    }, "", "")
  });
}, Kae = function(e) {
  var t = e.innerProps, n = e.isRtl, r = e.size, o = r === void 0 ? 4 : r, a = ei(e, Hae);
  return Oe("div", Ne({}, At(Ae(Ae({}, a), {}, {
    innerProps: t,
    isRtl: n,
    size: o
  }), "loadingIndicator", {
    indicator: !0,
    "loading-indicator": !0
  }), t), Oe(Av, {
    delay: 0,
    offset: n
  }), Oe(Av, {
    delay: 160,
    offset: !0
  }), Oe(Av, {
    delay: 320,
    offset: !n
  }));
}, Qae = function(e, t) {
  var n = e.isDisabled, r = e.isFocused, o = e.theme, a = o.colors, l = o.borderRadius, u = o.spacing;
  return Ae({
    label: "control",
    alignItems: "center",
    cursor: "default",
    display: "flex",
    flexWrap: "wrap",
    justifyContent: "space-between",
    minHeight: u.controlHeight,
    outline: "0 !important",
    position: "relative",
    transition: "all 100ms"
  }, t ? {} : {
    backgroundColor: n ? a.neutral5 : a.neutral0,
    borderColor: n ? a.neutral10 : r ? a.primary : a.neutral20,
    borderRadius: l,
    borderStyle: "solid",
    borderWidth: 1,
    boxShadow: r ? "0 0 0 1px ".concat(a.primary) : void 0,
    "&:hover": {
      borderColor: r ? a.primary : a.neutral30
    }
  });
}, Jae = function(e) {
  var t = e.children, n = e.isDisabled, r = e.isFocused, o = e.innerRef, a = e.innerProps, l = e.menuIsOpen;
  return Oe("div", Ne({
    ref: o
  }, At(e, "control", {
    control: !0,
    "control--is-disabled": n,
    "control--is-focused": r,
    "control--menu-is-open": l
  }), a, {
    "aria-disabled": n || void 0
  }), t);
}, ele = Jae, tle = ["data"], nle = function(e, t) {
  var n = e.theme.spacing;
  return t ? {} : {
    paddingBottom: n.baseUnit * 2,
    paddingTop: n.baseUnit * 2
  };
}, rle = function(e) {
  var t = e.children, n = e.cx, r = e.getStyles, o = e.getClassNames, a = e.Heading, l = e.headingProps, u = e.innerProps, d = e.label, f = e.theme, p = e.selectProps;
  return Oe("div", Ne({}, At(e, "group", {
    group: !0
  }), u), Oe(a, Ne({}, l, {
    selectProps: p,
    theme: f,
    getStyles: r,
    getClassNames: o,
    cx: n
  }), d), Oe("div", null, t));
}, ole = function(e, t) {
  var n = e.theme, r = n.colors, o = n.spacing;
  return Ae({
    label: "group",
    cursor: "default",
    display: "block"
  }, t ? {} : {
    color: r.neutral40,
    fontSize: "75%",
    fontWeight: 500,
    marginBottom: "0.25em",
    paddingLeft: o.baseUnit * 3,
    paddingRight: o.baseUnit * 3,
    textTransform: "uppercase"
  });
}, ile = function(e) {
  var t = aD(e);
  t.data;
  var n = ei(t, tle);
  return Oe("div", Ne({}, At(e, "groupHeading", {
    "group-heading": !0
  }), n));
}, ale = rle, lle = ["innerRef", "isDisabled", "isHidden", "inputClassName"], sle = function(e, t) {
  var n = e.isDisabled, r = e.value, o = e.theme, a = o.spacing, l = o.colors;
  return Ae(Ae({
    visibility: n ? "hidden" : "visible",
    // force css to recompute when value change due to @emotion bug.
    // We can remove it whenever the bug is fixed.
    transform: r ? "translateZ(0)" : ""
  }, ule), t ? {} : {
    margin: a.baseUnit / 2,
    paddingBottom: a.baseUnit / 2,
    paddingTop: a.baseUnit / 2,
    color: l.neutral80
  });
}, mD = {
  gridArea: "1 / 2",
  font: "inherit",
  minWidth: "2px",
  border: 0,
  margin: 0,
  outline: 0,
  padding: 0
}, ule = {
  flex: "1 1 auto",
  display: "inline-grid",
  gridArea: "1 / 1 / 2 / 3",
  gridTemplateColumns: "0 min-content",
  "&:after": Ae({
    content: 'attr(data-value) " "',
    visibility: "hidden",
    whiteSpace: "pre"
  }, mD)
}, cle = function(e) {
  return Ae({
    label: "input",
    color: "inherit",
    background: 0,
    opacity: e ? 0 : 1,
    width: "100%"
  }, mD);
}, dle = function(e) {
  var t = e.cx, n = e.value, r = aD(e), o = r.innerRef, a = r.isDisabled, l = r.isHidden, u = r.inputClassName, d = ei(r, lle);
  return Oe("div", Ne({}, At(e, "input", {
    "input-container": !0
  }), {
    "data-value": n || ""
  }), Oe("input", Ne({
    className: t({
      input: !0
    }, u),
    ref: o,
    style: cle(l),
    disabled: a
  }, d)));
}, fle = dle, ple = function(e, t) {
  var n = e.theme, r = n.spacing, o = n.borderRadius, a = n.colors;
  return Ae({
    label: "multiValue",
    display: "flex",
    minWidth: 0
  }, t ? {} : {
    backgroundColor: a.neutral10,
    borderRadius: o / 2,
    margin: r.baseUnit / 2
  });
}, hle = function(e, t) {
  var n = e.theme, r = n.borderRadius, o = n.colors, a = e.cropWithEllipsis;
  return Ae({
    overflow: "hidden",
    textOverflow: a || a === void 0 ? "ellipsis" : void 0,
    whiteSpace: "nowrap"
  }, t ? {} : {
    borderRadius: r / 2,
    color: o.neutral80,
    fontSize: "85%",
    padding: 3,
    paddingLeft: 6
  });
}, mle = function(e, t) {
  var n = e.theme, r = n.spacing, o = n.borderRadius, a = n.colors, l = e.isFocused;
  return Ae({
    alignItems: "center",
    display: "flex"
  }, t ? {} : {
    borderRadius: o / 2,
    backgroundColor: l ? a.dangerLight : void 0,
    paddingLeft: r.baseUnit,
    paddingRight: r.baseUnit,
    ":hover": {
      backgroundColor: a.dangerLight,
      color: a.danger
    }
  });
}, gD = function(e) {
  var t = e.children, n = e.innerProps;
  return Oe("div", n, t);
}, gle = gD, yle = gD;
function vle(e) {
  var t = e.children, n = e.innerProps;
  return Oe("div", Ne({
    role: "button"
  }, n), t || Oe(tS, {
    size: 14
  }));
}
var ble = function(e) {
  var t = e.children, n = e.components, r = e.data, o = e.innerProps, a = e.isDisabled, l = e.removeProps, u = e.selectProps, d = n.Container, f = n.Label, p = n.Remove;
  return Oe(d, {
    data: r,
    innerProps: Ae(Ae({}, At(e, "multiValue", {
      "multi-value": !0,
      "multi-value--is-disabled": a
    })), o),
    selectProps: u
  }, Oe(f, {
    data: r,
    innerProps: Ae({}, At(e, "multiValueLabel", {
      "multi-value__label": !0
    })),
    selectProps: u
  }, t), Oe(p, {
    data: r,
    innerProps: Ae(Ae({}, At(e, "multiValueRemove", {
      "multi-value__remove": !0
    })), {}, {
      "aria-label": "Remove ".concat(t || "option")
    }, l),
    selectProps: u
  }));
}, wle = ble, xle = function(e, t) {
  var n = e.isDisabled, r = e.isFocused, o = e.isSelected, a = e.theme, l = a.spacing, u = a.colors;
  return Ae({
    label: "option",
    cursor: "default",
    display: "block",
    fontSize: "inherit",
    width: "100%",
    userSelect: "none",
    WebkitTapHighlightColor: "rgba(0, 0, 0, 0)"
  }, t ? {} : {
    backgroundColor: o ? u.primary : r ? u.primary25 : "transparent",
    color: n ? u.neutral20 : o ? u.neutral0 : "inherit",
    padding: "".concat(l.baseUnit * 2, "px ").concat(l.baseUnit * 3, "px"),
    // provide some affordance on touch devices
    ":active": {
      backgroundColor: n ? void 0 : o ? u.primary : u.primary50
    }
  });
}, Sle = function(e) {
  var t = e.children, n = e.isDisabled, r = e.isFocused, o = e.isSelected, a = e.innerRef, l = e.innerProps;
  return Oe("div", Ne({}, At(e, "option", {
    option: !0,
    "option--is-disabled": n,
    "option--is-focused": r,
    "option--is-selected": o
  }), {
    ref: a,
    "aria-disabled": n
  }, l), t);
}, kle = Sle, _le = function(e, t) {
  var n = e.theme, r = n.spacing, o = n.colors;
  return Ae({
    label: "placeholder",
    gridArea: "1 / 1 / 2 / 3"
  }, t ? {} : {
    color: o.neutral50,
    marginLeft: r.baseUnit / 2,
    marginRight: r.baseUnit / 2
  });
}, Ele = function(e) {
  var t = e.children, n = e.innerProps;
  return Oe("div", Ne({}, At(e, "placeholder", {
    placeholder: !0
  }), n), t);
}, Cle = Ele, Ole = function(e, t) {
  var n = e.isDisabled, r = e.theme, o = r.spacing, a = r.colors;
  return Ae({
    label: "singleValue",
    gridArea: "1 / 1 / 2 / 3",
    maxWidth: "100%",
    overflow: "hidden",
    textOverflow: "ellipsis",
    whiteSpace: "nowrap"
  }, t ? {} : {
    color: n ? a.neutral40 : a.neutral80,
    marginLeft: o.baseUnit / 2,
    marginRight: o.baseUnit / 2
  });
}, Nle = function(e) {
  var t = e.children, n = e.isDisabled, r = e.innerProps;
  return Oe("div", Ne({}, At(e, "singleValue", {
    "single-value": !0,
    "single-value--is-disabled": n
  }), r), t);
}, Mle = Nle, Ale = {
  ClearIndicator: qae,
  Control: ele,
  DropdownIndicator: $ae,
  DownChevron: pD,
  CrossIcon: tS,
  Group: ale,
  GroupHeading: ile,
  IndicatorsContainer: Bae,
  IndicatorSeparator: Gae,
  Input: fle,
  LoadingIndicator: Kae,
  Menu: Eae,
  MenuList: Oae,
  MenuPortal: Dae,
  LoadingMessage: Rae,
  NoOptionsMessage: Aae,
  MultiValue: wle,
  MultiValueContainer: gle,
  MultiValueLabel: yle,
  MultiValueRemove: vle,
  Option: kle,
  Placeholder: Cle,
  SelectContainer: zae,
  SingleValue: Mle,
  ValueContainer: Lae
}, Rle = function(e) {
  return Ae(Ae({}, Ale), e.components);
}, fO = Number.isNaN || function(e) {
  return typeof e == "number" && e !== e;
};
function jle(e, t) {
  return !!(e === t || fO(e) && fO(t));
}
function Dle(e, t) {
  if (e.length !== t.length)
    return !1;
  for (var n = 0; n < e.length; n++)
    if (!jle(e[n], t[n]))
      return !1;
  return !0;
}
function Tle(e, t) {
  t === void 0 && (t = Dle);
  var n = null;
  function r() {
    for (var o = [], a = 0; a < arguments.length; a++)
      o[a] = arguments[a];
    if (n && n.lastThis === this && t(o, n.lastArgs))
      return n.lastResult;
    var l = e.apply(this, o);
    return n = {
      lastResult: l,
      lastArgs: o,
      lastThis: this
    }, l;
  }
  return r.clear = function() {
    n = null;
  }, r;
}
var zle = {
  name: "7pg0cj-a11yText",
  styles: "label:a11yText;z-index:9999;border:0;clip:rect(1px, 1px, 1px, 1px);height:1px;width:1px;position:absolute;overflow:hidden;padding:0;white-space:nowrap"
}, Ple = function(e) {
  return Oe("span", Ne({
    css: zle
  }, e));
}, pO = Ple, Lle = {
  guidance: function(e) {
    var t = e.isSearchable, n = e.isMulti, r = e.tabSelectsValue, o = e.context, a = e.isInitialFocus;
    switch (o) {
      case "menu":
        return "Use Up and Down to choose options, press Enter to select the currently focused option, press Escape to exit the menu".concat(r ? ", press Tab to select the option and exit the menu" : "", ".");
      case "input":
        return a ? "".concat(e["aria-label"] || "Select", " is focused ").concat(t ? ",type to refine list" : "", ", press Down to open the menu, ").concat(n ? " press left to focus selected values" : "") : "";
      case "value":
        return "Use left and right to toggle between focused values, press Backspace to remove the currently focused value";
      default:
        return "";
    }
  },
  onChange: function(e) {
    var t = e.action, n = e.label, r = n === void 0 ? "" : n, o = e.labels, a = e.isDisabled;
    switch (t) {
      case "deselect-option":
      case "pop-value":
      case "remove-value":
        return "option ".concat(r, ", deselected.");
      case "clear":
        return "All selected options have been cleared.";
      case "initial-input-focus":
        return "option".concat(o.length > 1 ? "s" : "", " ").concat(o.join(","), ", selected.");
      case "select-option":
        return a ? "option ".concat(r, " is disabled. Select another option.") : "option ".concat(r, ", selected.");
      default:
        return "";
    }
  },
  onFocus: function(e) {
    var t = e.context, n = e.focused, r = e.options, o = e.label, a = o === void 0 ? "" : o, l = e.selectValue, u = e.isDisabled, d = e.isSelected, f = e.isAppleDevice, p = function(y, w) {
      return y && y.length ? "".concat(y.indexOf(w) + 1, " of ").concat(y.length) : "";
    };
    if (t === "value" && l)
      return "value ".concat(a, " focused, ").concat(p(l, n), ".");
    if (t === "menu" && f) {
      var m = u ? " disabled" : "", g = "".concat(d ? " selected" : "").concat(m);
      return "".concat(a).concat(g, ", ").concat(p(r, n), ".");
    }
    return "";
  },
  onFilter: function(e) {
    var t = e.inputValue, n = e.resultsMessage;
    return "".concat(n).concat(t ? " for search term " + t : "", ".");
  }
}, Ile = function(e) {
  var t = e.ariaSelection, n = e.focusedOption, r = e.focusedValue, o = e.focusableOptions, a = e.isFocused, l = e.selectValue, u = e.selectProps, d = e.id, f = e.isAppleDevice, p = u.ariaLiveMessages, m = u.getOptionLabel, g = u.inputValue, y = u.isMulti, w = u.isOptionDisabled, v = u.isSearchable, x = u.menuIsOpen, E = u.options, N = u.screenReaderStatus, C = u.tabSelectsValue, A = u.isLoading, R = u["aria-label"], D = u["aria-live"], T = _.useMemo(function() {
    return Ae(Ae({}, Lle), p || {});
  }, [p]), V = _.useMemo(function() {
    var z = "";
    if (t && T.onChange) {
      var $ = t.option, L = t.options, H = t.removedValue, q = t.removedValues, Y = t.value, M = function(ae) {
        return Array.isArray(ae) ? null : ae;
      }, X = H || $ || M(Y), Q = X ? m(X) : "", P = L || q || void 0, te = P ? P.map(m) : [], ie = Ae({
        // multiSelected items are usually items that have already been selected
        // or set by the user as a default value so we assume they are not disabled
        isDisabled: X && w(X, l),
        label: Q,
        labels: te
      }, t);
      z = T.onChange(ie);
    }
    return z;
  }, [t, T, w, l, m]), F = _.useMemo(function() {
    var z = "", $ = n || r, L = !!(n && l && l.includes(n));
    if ($ && T.onFocus) {
      var H = {
        focused: $,
        label: m($),
        isDisabled: w($, l),
        isSelected: L,
        options: o,
        context: $ === n ? "menu" : "value",
        selectValue: l,
        isAppleDevice: f
      };
      z = T.onFocus(H);
    }
    return z;
  }, [n, r, m, w, T, o, l, f]), O = _.useMemo(function() {
    var z = "";
    if (x && E.length && !A && T.onFilter) {
      var $ = N({
        count: o.length
      });
      z = T.onFilter({
        inputValue: g,
        resultsMessage: $
      });
    }
    return z;
  }, [o, g, x, T, E, N, A]), B = t?.action === "initial-input-focus", U = _.useMemo(function() {
    var z = "";
    if (T.guidance) {
      var $ = r ? "value" : x ? "menu" : "input";
      z = T.guidance({
        "aria-label": R,
        context: $,
        isDisabled: n && w(n, l),
        isMulti: y,
        isSearchable: v,
        tabSelectsValue: C,
        isInitialFocus: B
      });
    }
    return z;
  }, [R, n, r, y, w, v, x, T, l, C, B]), G = Oe(_.Fragment, null, Oe("span", {
    id: "aria-selection"
  }, V), Oe("span", {
    id: "aria-focused"
  }, F), Oe("span", {
    id: "aria-results"
  }, O), Oe("span", {
    id: "aria-guidance"
  }, U));
  return Oe(_.Fragment, null, Oe(pO, {
    id: d
  }, B && G), Oe(pO, {
    "aria-live": D,
    "aria-atomic": "false",
    "aria-relevant": "additions text",
    role: "log"
  }, a && !B && G));
}, Ble = Ile, nw = [{
  base: "A",
  letters: "A"
}, {
  base: "AA",
  letters: ""
}, {
  base: "AE",
  letters: ""
}, {
  base: "AO",
  letters: ""
}, {
  base: "AU",
  letters: ""
}, {
  base: "AV",
  letters: ""
}, {
  base: "AY",
  letters: ""
}, {
  base: "B",
  letters: "B"
}, {
  base: "C",
  letters: "C"
}, {
  base: "D",
  letters: "D"
}, {
  base: "DZ",
  letters: ""
}, {
  base: "Dz",
  letters: ""
}, {
  base: "E",
  letters: "E"
}, {
  base: "F",
  letters: "F"
}, {
  base: "G",
  letters: "G"
}, {
  base: "H",
  letters: "H"
}, {
  base: "I",
  letters: "I"
}, {
  base: "J",
  letters: "J"
}, {
  base: "K",
  letters: "K"
}, {
  base: "L",
  letters: "L"
}, {
  base: "LJ",
  letters: ""
}, {
  base: "Lj",
  letters: ""
}, {
  base: "M",
  letters: "M"
}, {
  base: "N",
  letters: "N"
}, {
  base: "NJ",
  letters: ""
}, {
  base: "Nj",
  letters: ""
}, {
  base: "O",
  letters: "O"
}, {
  base: "OI",
  letters: ""
}, {
  base: "OO",
  letters: ""
}, {
  base: "OU",
  letters: ""
}, {
  base: "P",
  letters: "P"
}, {
  base: "Q",
  letters: "Q"
}, {
  base: "R",
  letters: "R"
}, {
  base: "S",
  letters: "S"
}, {
  base: "T",
  letters: "T"
}, {
  base: "TZ",
  letters: ""
}, {
  base: "U",
  letters: "U"
}, {
  base: "V",
  letters: "V"
}, {
  base: "VY",
  letters: ""
}, {
  base: "W",
  letters: "W"
}, {
  base: "X",
  letters: "X"
}, {
  base: "Y",
  letters: "Y"
}, {
  base: "Z",
  letters: "Z"
}, {
  base: "a",
  letters: "a"
}, {
  base: "aa",
  letters: ""
}, {
  base: "ae",
  letters: ""
}, {
  base: "ao",
  letters: ""
}, {
  base: "au",
  letters: ""
}, {
  base: "av",
  letters: ""
}, {
  base: "ay",
  letters: ""
}, {
  base: "b",
  letters: "b"
}, {
  base: "c",
  letters: "c"
}, {
  base: "d",
  letters: "d"
}, {
  base: "dz",
  letters: ""
}, {
  base: "e",
  letters: "e"
}, {
  base: "f",
  letters: "f"
}, {
  base: "g",
  letters: "g"
}, {
  base: "h",
  letters: "h"
}, {
  base: "hv",
  letters: ""
}, {
  base: "i",
  letters: "i"
}, {
  base: "j",
  letters: "j"
}, {
  base: "k",
  letters: "k"
}, {
  base: "l",
  letters: "l"
}, {
  base: "lj",
  letters: ""
}, {
  base: "m",
  letters: "m"
}, {
  base: "n",
  letters: "n"
}, {
  base: "nj",
  letters: ""
}, {
  base: "o",
  letters: "o"
}, {
  base: "oi",
  letters: ""
}, {
  base: "ou",
  letters: ""
}, {
  base: "oo",
  letters: ""
}, {
  base: "p",
  letters: "p"
}, {
  base: "q",
  letters: "q"
}, {
  base: "r",
  letters: "r"
}, {
  base: "s",
  letters: "s"
}, {
  base: "t",
  letters: "t"
}, {
  base: "tz",
  letters: ""
}, {
  base: "u",
  letters: "u"
}, {
  base: "v",
  letters: "v"
}, {
  base: "vy",
  letters: ""
}, {
  base: "w",
  letters: "w"
}, {
  base: "x",
  letters: "x"
}, {
  base: "y",
  letters: "y"
}, {
  base: "z",
  letters: "z"
}], Vle = new RegExp("[" + nw.map(function(e) {
  return e.letters;
}).join("") + "]", "g"), yD = {};
for (var Rv = 0; Rv < nw.length; Rv++)
  for (var jv = nw[Rv], Dv = 0; Dv < jv.letters.length; Dv++)
    yD[jv.letters[Dv]] = jv.base;
var vD = function(e) {
  return e.replace(Vle, function(t) {
    return yD[t];
  });
}, Hle = Tle(vD), hO = function(e) {
  return e.replace(/^\s+|\s+$/g, "");
}, Ule = function(e) {
  return "".concat(e.label, " ").concat(e.value);
}, Fle = function(e) {
  return function(t, n) {
    if (t.data.__isNew__) return !0;
    var r = Ae({
      ignoreCase: !0,
      ignoreAccents: !0,
      stringify: Ule,
      trim: !0,
      matchFrom: "any"
    }, e), o = r.ignoreCase, a = r.ignoreAccents, l = r.stringify, u = r.trim, d = r.matchFrom, f = u ? hO(n) : n, p = u ? hO(l(t)) : l(t);
    return o && (f = f.toLowerCase(), p = p.toLowerCase()), a && (f = Hle(f), p = vD(p)), d === "start" ? p.substr(0, f.length) === f : p.indexOf(f) > -1;
  };
}, $le = ["innerRef"];
function Yle(e) {
  var t = e.innerRef, n = ei(e, $le), r = yae(n, "onExited", "in", "enter", "exit", "appear");
  return Oe("input", Ne({
    ref: t
  }, r, {
    css: /* @__PURE__ */ $x({
      label: "dummyInput",
      // get rid of any default styles
      background: 0,
      border: 0,
      // important! this hides the flashing cursor
      caretColor: "transparent",
      fontSize: "inherit",
      gridArea: "1 / 1 / 2 / 3",
      outline: 0,
      padding: 0,
      // important! without `width` browsers won't allow focus
      width: 1,
      // remove cursor on desktop
      color: "transparent",
      // remove cursor on mobile whilst maintaining "scroll into view" behaviour
      left: -100,
      opacity: 0,
      position: "relative",
      transform: "scale(.01)"
    }, "", "")
  }));
}
var qle = function(e) {
  e.cancelable && e.preventDefault(), e.stopPropagation();
};
function Xle(e) {
  var t = e.isEnabled, n = e.onBottomArrive, r = e.onBottomLeave, o = e.onTopArrive, a = e.onTopLeave, l = _.useRef(!1), u = _.useRef(!1), d = _.useRef(0), f = _.useRef(null), p = _.useCallback(function(x, E) {
    if (f.current !== null) {
      var N = f.current, C = N.scrollTop, A = N.scrollHeight, R = N.clientHeight, D = f.current, T = E > 0, V = A - R - C, F = !1;
      V > E && l.current && (r && r(x), l.current = !1), T && u.current && (a && a(x), u.current = !1), T && E > V ? (n && !l.current && n(x), D.scrollTop = A, F = !0, l.current = !0) : !T && -E > C && (o && !u.current && o(x), D.scrollTop = 0, F = !0, u.current = !0), F && qle(x);
    }
  }, [n, r, o, a]), m = _.useCallback(function(x) {
    p(x, x.deltaY);
  }, [p]), g = _.useCallback(function(x) {
    d.current = x.changedTouches[0].clientY;
  }, []), y = _.useCallback(function(x) {
    var E = d.current - x.changedTouches[0].clientY;
    p(x, E);
  }, [p]), w = _.useCallback(function(x) {
    if (x) {
      var E = hae ? {
        passive: !1
      } : !1;
      x.addEventListener("wheel", m, E), x.addEventListener("touchstart", g, E), x.addEventListener("touchmove", y, E);
    }
  }, [y, g, m]), v = _.useCallback(function(x) {
    x && (x.removeEventListener("wheel", m, !1), x.removeEventListener("touchstart", g, !1), x.removeEventListener("touchmove", y, !1));
  }, [y, g, m]);
  return _.useEffect(function() {
    if (t) {
      var x = f.current;
      return w(x), function() {
        v(x);
      };
    }
  }, [t, w, v]), function(x) {
    f.current = x;
  };
}
var mO = ["boxSizing", "height", "overflow", "paddingRight", "position"], gO = {
  boxSizing: "border-box",
  // account for possible declaration `width: 100%;` on body
  overflow: "hidden",
  position: "relative",
  height: "100%"
};
function yO(e) {
  e.cancelable && e.preventDefault();
}
function vO(e) {
  e.stopPropagation();
}
function bO() {
  var e = this.scrollTop, t = this.scrollHeight, n = e + this.offsetHeight;
  e === 0 ? this.scrollTop = 1 : n === t && (this.scrollTop = e - 1);
}
function wO() {
  return "ontouchstart" in window || navigator.maxTouchPoints;
}
var xO = !!(typeof window < "u" && window.document && window.document.createElement), Uu = 0, Bl = {
  capture: !1,
  passive: !1
};
function Gle(e) {
  var t = e.isEnabled, n = e.accountForScrollbars, r = n === void 0 ? !0 : n, o = _.useRef({}), a = _.useRef(null), l = _.useCallback(function(d) {
    if (xO) {
      var f = document.body, p = f && f.style;
      if (r && mO.forEach(function(w) {
        var v = p && p[w];
        o.current[w] = v;
      }), r && Uu < 1) {
        var m = parseInt(o.current.paddingRight, 10) || 0, g = document.body ? document.body.clientWidth : 0, y = window.innerWidth - g + m || 0;
        Object.keys(gO).forEach(function(w) {
          var v = gO[w];
          p && (p[w] = v);
        }), p && (p.paddingRight = "".concat(y, "px"));
      }
      f && wO() && (f.addEventListener("touchmove", yO, Bl), d && (d.addEventListener("touchstart", bO, Bl), d.addEventListener("touchmove", vO, Bl))), Uu += 1;
    }
  }, [r]), u = _.useCallback(function(d) {
    if (xO) {
      var f = document.body, p = f && f.style;
      Uu = Math.max(Uu - 1, 0), r && Uu < 1 && mO.forEach(function(m) {
        var g = o.current[m];
        p && (p[m] = g);
      }), f && wO() && (f.removeEventListener("touchmove", yO, Bl), d && (d.removeEventListener("touchstart", bO, Bl), d.removeEventListener("touchmove", vO, Bl)));
    }
  }, [r]);
  return _.useEffect(function() {
    if (t) {
      var d = a.current;
      return l(d), function() {
        u(d);
      };
    }
  }, [t, l, u]), function(d) {
    a.current = d;
  };
}
var Zle = function(e) {
  var t = e.target;
  return t.ownerDocument.activeElement && t.ownerDocument.activeElement.blur();
}, Wle = {
  name: "1kfdb0e",
  styles: "position:fixed;left:0;bottom:0;right:0;top:0"
};
function Kle(e) {
  var t = e.children, n = e.lockEnabled, r = e.captureEnabled, o = r === void 0 ? !0 : r, a = e.onBottomArrive, l = e.onBottomLeave, u = e.onTopArrive, d = e.onTopLeave, f = Xle({
    isEnabled: o,
    onBottomArrive: a,
    onBottomLeave: l,
    onTopArrive: u,
    onTopLeave: d
  }), p = Gle({
    isEnabled: n
  }), m = function(g) {
    f(g), p(g);
  };
  return Oe(_.Fragment, null, n && Oe("div", {
    onClick: Zle,
    css: Wle
  }), t(m));
}
var Qle = {
  name: "1a0ro4n-requiredInput",
  styles: "label:requiredInput;opacity:0;pointer-events:none;position:absolute;bottom:0;left:0;right:0;width:100%"
}, Jle = function(e) {
  var t = e.name, n = e.onFocus;
  return Oe("input", {
    required: !0,
    name: t,
    tabIndex: -1,
    "aria-hidden": "true",
    onFocus: n,
    css: Qle,
    value: "",
    onChange: function() {
    }
  });
}, ese = Jle;
function nS(e) {
  var t;
  return typeof window < "u" && window.navigator != null ? e.test(((t = window.navigator.userAgentData) === null || t === void 0 ? void 0 : t.platform) || window.navigator.platform) : !1;
}
function tse() {
  return nS(/^iPhone/i);
}
function bD() {
  return nS(/^Mac/i);
}
function nse() {
  return nS(/^iPad/i) || // iPadOS 13 lies and says it's a Mac, but we can distinguish by detecting touch support.
  bD() && navigator.maxTouchPoints > 1;
}
function rse() {
  return tse() || nse();
}
function ose() {
  return bD() || rse();
}
var ise = function(e) {
  return e.label;
}, ase = function(e) {
  return e.label;
}, lse = function(e) {
  return e.value;
}, sse = function(e) {
  return !!e.isDisabled;
}, use = {
  clearIndicator: Yae,
  container: Tae,
  control: Qae,
  dropdownIndicator: Fae,
  group: nle,
  groupHeading: ole,
  indicatorsContainer: Iae,
  indicatorSeparator: Xae,
  input: sle,
  loadingIndicator: Wae,
  loadingMessage: Mae,
  menu: Sae,
  menuList: Cae,
  menuPortal: jae,
  multiValue: ple,
  multiValueLabel: hle,
  multiValueRemove: mle,
  noOptionsMessage: Nae,
  option: xle,
  placeholder: _le,
  singleValue: Ole,
  valueContainer: Pae
}, cse = {
  primary: "#2684FF",
  primary75: "#4C9AFF",
  primary50: "#B2D4FF",
  primary25: "#DEEBFF",
  danger: "#DE350B",
  dangerLight: "#FFBDAD",
  neutral0: "hsl(0, 0%, 100%)",
  neutral5: "hsl(0, 0%, 95%)",
  neutral10: "hsl(0, 0%, 90%)",
  neutral20: "hsl(0, 0%, 80%)",
  neutral30: "hsl(0, 0%, 70%)",
  neutral40: "hsl(0, 0%, 60%)",
  neutral50: "hsl(0, 0%, 50%)",
  neutral60: "hsl(0, 0%, 40%)",
  neutral70: "hsl(0, 0%, 30%)",
  neutral80: "hsl(0, 0%, 20%)",
  neutral90: "hsl(0, 0%, 10%)"
}, dse = 4, wD = 4, fse = 38, pse = wD * 2, hse = {
  baseUnit: wD,
  controlHeight: fse,
  menuGutter: pse
}, Tv = {
  borderRadius: dse,
  colors: cse,
  spacing: hse
}, mse = {
  "aria-live": "polite",
  backspaceRemovesValue: !0,
  blurInputOnSelect: cO(),
  captureMenuScroll: !cO(),
  classNames: {},
  closeMenuOnSelect: !0,
  closeMenuOnScroll: !1,
  components: {},
  controlShouldRenderValue: !0,
  escapeClearsValue: !1,
  filterOption: Fle(),
  formatGroupLabel: ise,
  getOptionLabel: ase,
  getOptionValue: lse,
  isDisabled: !1,
  isLoading: !1,
  isMulti: !1,
  isRtl: !1,
  isSearchable: !0,
  isOptionDisabled: sse,
  loadingMessage: function() {
    return "Loading...";
  },
  maxMenuHeight: 300,
  minMenuHeight: 140,
  menuIsOpen: !1,
  menuPlacement: "bottom",
  menuPosition: "absolute",
  menuShouldBlockScroll: !1,
  menuShouldScrollIntoView: !fae(),
  noOptionsMessage: function() {
    return "No options";
  },
  openMenuOnFocus: !1,
  openMenuOnClick: !0,
  options: [],
  pageSize: 5,
  placeholder: "Select...",
  screenReaderStatus: function(e) {
    var t = e.count;
    return "".concat(t, " result").concat(t !== 1 ? "s" : "", " available");
  },
  styles: {},
  tabIndex: 0,
  tabSelectsValue: !0,
  unstyled: !1
};
function SO(e, t, n, r) {
  var o = kD(e, t, n), a = _D(e, t, n), l = SD(e, t), u = Qp(e, t);
  return {
    type: "option",
    data: t,
    isDisabled: o,
    isSelected: a,
    label: l,
    value: u,
    index: r
  };
}
function mp(e, t) {
  return e.options.map(function(n, r) {
    if ("options" in n) {
      var o = n.options.map(function(l, u) {
        return SO(e, l, t, u);
      }).filter(function(l) {
        return _O(e, l);
      });
      return o.length > 0 ? {
        type: "group",
        data: n,
        options: o,
        index: r
      } : void 0;
    }
    var a = SO(e, n, t, r);
    return _O(e, a) ? a : void 0;
  }).filter(mae);
}
function xD(e) {
  return e.reduce(function(t, n) {
    return n.type === "group" ? t.push.apply(t, eS(n.options.map(function(r) {
      return r.data;
    }))) : t.push(n.data), t;
  }, []);
}
function kO(e, t) {
  return e.reduce(function(n, r) {
    return r.type === "group" ? n.push.apply(n, eS(r.options.map(function(o) {
      return {
        data: o.data,
        id: "".concat(t, "-").concat(r.index, "-").concat(o.index)
      };
    }))) : n.push({
      data: r.data,
      id: "".concat(t, "-").concat(r.index)
    }), n;
  }, []);
}
function gse(e, t) {
  return xD(mp(e, t));
}
function _O(e, t) {
  var n = e.inputValue, r = n === void 0 ? "" : n, o = t.data, a = t.isSelected, l = t.label, u = t.value;
  return (!CD(e) || !a) && ED(e, {
    label: l,
    value: u,
    data: o
  }, r);
}
function yse(e, t) {
  var n = e.focusedValue, r = e.selectValue, o = r.indexOf(n);
  if (o > -1) {
    var a = t.indexOf(n);
    if (a > -1)
      return n;
    if (o < t.length)
      return t[o];
  }
  return null;
}
function vse(e, t) {
  var n = e.focusedOption;
  return n && t.indexOf(n) > -1 ? n : t[0];
}
var zv = function(e, t) {
  var n, r = (n = e.find(function(o) {
    return o.data === t;
  })) === null || n === void 0 ? void 0 : n.id;
  return r || null;
}, SD = function(e, t) {
  return e.getOptionLabel(t);
}, Qp = function(e, t) {
  return e.getOptionValue(t);
};
function kD(e, t, n) {
  return typeof e.isOptionDisabled == "function" ? e.isOptionDisabled(t, n) : !1;
}
function _D(e, t, n) {
  if (n.indexOf(t) > -1) return !0;
  if (typeof e.isOptionSelected == "function")
    return e.isOptionSelected(t, n);
  var r = Qp(e, t);
  return n.some(function(o) {
    return Qp(e, o) === r;
  });
}
function ED(e, t, n) {
  return e.filterOption ? e.filterOption(t, n) : !0;
}
var CD = function(e) {
  var t = e.hideSelectedOptions, n = e.isMulti;
  return t === void 0 ? n : t;
}, bse = 1, OD = /* @__PURE__ */ function(e) {
  Qie(n, e);
  var t = eae(n);
  function n(r) {
    var o;
    if (Wie(this, n), o = t.call(this, r), o.state = {
      ariaSelection: null,
      focusedOption: null,
      focusedOptionId: null,
      focusableOptionsWithIds: [],
      focusedValue: null,
      inputIsHidden: !1,
      isFocused: !1,
      selectValue: [],
      clearFocusValueOnUpdate: !1,
      prevWasFocused: !1,
      inputIsHiddenAfterUpdate: void 0,
      prevProps: void 0,
      instancePrefix: ""
    }, o.blockOptionHover = !1, o.isComposing = !1, o.commonProps = void 0, o.initialTouchX = 0, o.initialTouchY = 0, o.openAfterFocus = !1, o.scrollToFocusedOptionOnUpdate = !1, o.userIsDragging = void 0, o.isAppleDevice = ose(), o.controlRef = null, o.getControlRef = function(d) {
      o.controlRef = d;
    }, o.focusedOptionRef = null, o.getFocusedOptionRef = function(d) {
      o.focusedOptionRef = d;
    }, o.menuListRef = null, o.getMenuListRef = function(d) {
      o.menuListRef = d;
    }, o.inputRef = null, o.getInputRef = function(d) {
      o.inputRef = d;
    }, o.focus = o.focusInput, o.blur = o.blurInput, o.onChange = function(d, f) {
      var p = o.props, m = p.onChange, g = p.name;
      f.name = g, o.ariaOnChange(d, f), m(d, f);
    }, o.setValue = function(d, f, p) {
      var m = o.props, g = m.closeMenuOnSelect, y = m.isMulti, w = m.inputValue;
      o.onInputChange("", {
        action: "set-value",
        prevInputValue: w
      }), g && (o.setState({
        inputIsHiddenAfterUpdate: !y
      }), o.onMenuClose()), o.setState({
        clearFocusValueOnUpdate: !0
      }), o.onChange(d, {
        action: f,
        option: p
      });
    }, o.selectOption = function(d) {
      var f = o.props, p = f.blurInputOnSelect, m = f.isMulti, g = f.name, y = o.state.selectValue, w = m && o.isOptionSelected(d, y), v = o.isOptionDisabled(d, y);
      if (w) {
        var x = o.getOptionValue(d);
        o.setValue(y.filter(function(E) {
          return o.getOptionValue(E) !== x;
        }), "deselect-option", d);
      } else if (!v)
        m ? o.setValue([].concat(eS(y), [d]), "select-option", d) : o.setValue(d, "select-option");
      else {
        o.ariaOnChange(d, {
          action: "select-option",
          option: d,
          name: g
        });
        return;
      }
      p && o.blurInput();
    }, o.removeValue = function(d) {
      var f = o.props.isMulti, p = o.state.selectValue, m = o.getOptionValue(d), g = p.filter(function(w) {
        return o.getOptionValue(w) !== m;
      }), y = Xf(f, g, g[0] || null);
      o.onChange(y, {
        action: "remove-value",
        removedValue: d
      }), o.focusInput();
    }, o.clearValue = function() {
      var d = o.state.selectValue;
      o.onChange(Xf(o.props.isMulti, [], null), {
        action: "clear",
        removedValues: d
      });
    }, o.popValue = function() {
      var d = o.props.isMulti, f = o.state.selectValue, p = f[f.length - 1], m = f.slice(0, f.length - 1), g = Xf(d, m, m[0] || null);
      p && o.onChange(g, {
        action: "pop-value",
        removedValue: p
      });
    }, o.getFocusedOptionId = function(d) {
      return zv(o.state.focusableOptionsWithIds, d);
    }, o.getFocusableOptionsWithIds = function() {
      return kO(mp(o.props, o.state.selectValue), o.getElementId("option"));
    }, o.getValue = function() {
      return o.state.selectValue;
    }, o.cx = function() {
      for (var d = arguments.length, f = new Array(d), p = 0; p < d; p++)
        f[p] = arguments[p];
      return lae.apply(void 0, [o.props.classNamePrefix].concat(f));
    }, o.getOptionLabel = function(d) {
      return SD(o.props, d);
    }, o.getOptionValue = function(d) {
      return Qp(o.props, d);
    }, o.getStyles = function(d, f) {
      var p = o.props.unstyled, m = use[d](f, p);
      m.boxSizing = "border-box";
      var g = o.props.styles[d];
      return g ? g(m, f) : m;
    }, o.getClassNames = function(d, f) {
      var p, m;
      return (p = (m = o.props.classNames)[d]) === null || p === void 0 ? void 0 : p.call(m, f);
    }, o.getElementId = function(d) {
      return "".concat(o.state.instancePrefix, "-").concat(d);
    }, o.getComponents = function() {
      return Rle(o.props);
    }, o.buildCategorizedOptions = function() {
      return mp(o.props, o.state.selectValue);
    }, o.getCategorizedOptions = function() {
      return o.props.menuIsOpen ? o.buildCategorizedOptions() : [];
    }, o.buildFocusableOptions = function() {
      return xD(o.buildCategorizedOptions());
    }, o.getFocusableOptions = function() {
      return o.props.menuIsOpen ? o.buildFocusableOptions() : [];
    }, o.ariaOnChange = function(d, f) {
      o.setState({
        ariaSelection: Ae({
          value: d
        }, f)
      });
    }, o.onMenuMouseDown = function(d) {
      d.button === 0 && (d.stopPropagation(), d.preventDefault(), o.focusInput());
    }, o.onMenuMouseMove = function(d) {
      o.blockOptionHover = !1;
    }, o.onControlMouseDown = function(d) {
      if (!d.defaultPrevented) {
        var f = o.props.openMenuOnClick;
        o.state.isFocused ? o.props.menuIsOpen ? d.target.tagName !== "INPUT" && d.target.tagName !== "TEXTAREA" && o.onMenuClose() : f && o.openMenu("first") : (f && (o.openAfterFocus = !0), o.focusInput()), d.target.tagName !== "INPUT" && d.target.tagName !== "TEXTAREA" && d.preventDefault();
      }
    }, o.onDropdownIndicatorMouseDown = function(d) {
      if (!(d && d.type === "mousedown" && d.button !== 0) && !o.props.isDisabled) {
        var f = o.props, p = f.isMulti, m = f.menuIsOpen;
        o.focusInput(), m ? (o.setState({
          inputIsHiddenAfterUpdate: !p
        }), o.onMenuClose()) : o.openMenu("first"), d.preventDefault();
      }
    }, o.onClearIndicatorMouseDown = function(d) {
      d && d.type === "mousedown" && d.button !== 0 || (o.clearValue(), d.preventDefault(), o.openAfterFocus = !1, d.type === "touchend" ? o.focusInput() : setTimeout(function() {
        return o.focusInput();
      }));
    }, o.onScroll = function(d) {
      typeof o.props.closeMenuOnScroll == "boolean" ? d.target instanceof HTMLElement && sm(d.target) && o.props.onMenuClose() : typeof o.props.closeMenuOnScroll == "function" && o.props.closeMenuOnScroll(d) && o.props.onMenuClose();
    }, o.onCompositionStart = function() {
      o.isComposing = !0;
    }, o.onCompositionEnd = function() {
      o.isComposing = !1;
    }, o.onTouchStart = function(d) {
      var f = d.touches, p = f && f.item(0);
      p && (o.initialTouchX = p.clientX, o.initialTouchY = p.clientY, o.userIsDragging = !1);
    }, o.onTouchMove = function(d) {
      var f = d.touches, p = f && f.item(0);
      if (p) {
        var m = Math.abs(p.clientX - o.initialTouchX), g = Math.abs(p.clientY - o.initialTouchY), y = 5;
        o.userIsDragging = m > y || g > y;
      }
    }, o.onTouchEnd = function(d) {
      o.userIsDragging || (o.controlRef && !o.controlRef.contains(d.target) && o.menuListRef && !o.menuListRef.contains(d.target) && o.blurInput(), o.initialTouchX = 0, o.initialTouchY = 0);
    }, o.onControlTouchEnd = function(d) {
      o.userIsDragging || o.onControlMouseDown(d);
    }, o.onClearIndicatorTouchEnd = function(d) {
      o.userIsDragging || o.onClearIndicatorMouseDown(d);
    }, o.onDropdownIndicatorTouchEnd = function(d) {
      o.userIsDragging || o.onDropdownIndicatorMouseDown(d);
    }, o.handleInputChange = function(d) {
      var f = o.props.inputValue, p = d.currentTarget.value;
      o.setState({
        inputIsHiddenAfterUpdate: !1
      }), o.onInputChange(p, {
        action: "input-change",
        prevInputValue: f
      }), o.props.menuIsOpen || o.onMenuOpen();
    }, o.onInputFocus = function(d) {
      o.props.onFocus && o.props.onFocus(d), o.setState({
        inputIsHiddenAfterUpdate: !1,
        isFocused: !0
      }), (o.openAfterFocus || o.props.openMenuOnFocus) && o.openMenu("first"), o.openAfterFocus = !1;
    }, o.onInputBlur = function(d) {
      var f = o.props.inputValue;
      if (o.menuListRef && o.menuListRef.contains(document.activeElement)) {
        o.inputRef.focus();
        return;
      }
      o.props.onBlur && o.props.onBlur(d), o.onInputChange("", {
        action: "input-blur",
        prevInputValue: f
      }), o.onMenuClose(), o.setState({
        focusedValue: null,
        isFocused: !1
      });
    }, o.onOptionHover = function(d) {
      if (!(o.blockOptionHover || o.state.focusedOption === d)) {
        var f = o.getFocusableOptions(), p = f.indexOf(d);
        o.setState({
          focusedOption: d,
          focusedOptionId: p > -1 ? o.getFocusedOptionId(d) : null
        });
      }
    }, o.shouldHideSelectedOptions = function() {
      return CD(o.props);
    }, o.onValueInputFocus = function(d) {
      d.preventDefault(), d.stopPropagation(), o.focus();
    }, o.onKeyDown = function(d) {
      var f = o.props, p = f.isMulti, m = f.backspaceRemovesValue, g = f.escapeClearsValue, y = f.inputValue, w = f.isClearable, v = f.isDisabled, x = f.menuIsOpen, E = f.onKeyDown, N = f.tabSelectsValue, C = f.openMenuOnFocus, A = o.state, R = A.focusedOption, D = A.focusedValue, T = A.selectValue;
      if (!v && !(typeof E == "function" && (E(d), d.defaultPrevented))) {
        switch (o.blockOptionHover = !0, d.key) {
          case "ArrowLeft":
            if (!p || y) return;
            o.focusValue("previous");
            break;
          case "ArrowRight":
            if (!p || y) return;
            o.focusValue("next");
            break;
          case "Delete":
          case "Backspace":
            if (y) return;
            if (D)
              o.removeValue(D);
            else {
              if (!m) return;
              p ? o.popValue() : w && o.clearValue();
            }
            break;
          case "Tab":
            if (o.isComposing || d.shiftKey || !x || !N || !R || // don't capture the event if the menu opens on focus and the focused
            // option is already selected; it breaks the flow of navigation
            C && o.isOptionSelected(R, T))
              return;
            o.selectOption(R);
            break;
          case "Enter":
            if (d.keyCode === 229)
              break;
            if (x) {
              if (!R || o.isComposing) return;
              o.selectOption(R);
              break;
            }
            return;
          case "Escape":
            x ? (o.setState({
              inputIsHiddenAfterUpdate: !1
            }), o.onInputChange("", {
              action: "menu-close",
              prevInputValue: y
            }), o.onMenuClose()) : w && g && o.clearValue();
            break;
          case " ":
            if (y)
              return;
            if (!x) {
              o.openMenu("first");
              break;
            }
            if (!R) return;
            o.selectOption(R);
            break;
          case "ArrowUp":
            x ? o.focusOption("up") : o.openMenu("last");
            break;
          case "ArrowDown":
            x ? o.focusOption("down") : o.openMenu("first");
            break;
          case "PageUp":
            if (!x) return;
            o.focusOption("pageup");
            break;
          case "PageDown":
            if (!x) return;
            o.focusOption("pagedown");
            break;
          case "Home":
            if (!x) return;
            o.focusOption("first");
            break;
          case "End":
            if (!x) return;
            o.focusOption("last");
            break;
          default:
            return;
        }
        d.preventDefault();
      }
    }, o.state.instancePrefix = "react-select-" + (o.props.instanceId || ++bse), o.state.selectValue = sO(r.value), r.menuIsOpen && o.state.selectValue.length) {
      var a = o.getFocusableOptionsWithIds(), l = o.buildFocusableOptions(), u = l.indexOf(o.state.selectValue[0]);
      o.state.focusableOptionsWithIds = a, o.state.focusedOption = l[u], o.state.focusedOptionId = zv(a, l[u]);
    }
    return o;
  }
  return Kie(n, [{
    key: "componentDidMount",
    value: function() {
      this.startListeningComposition(), this.startListeningToTouch(), this.props.closeMenuOnScroll && document && document.addEventListener && document.addEventListener("scroll", this.onScroll, !0), this.props.autoFocus && this.focusInput(), this.props.menuIsOpen && this.state.focusedOption && this.menuListRef && this.focusedOptionRef && uO(this.menuListRef, this.focusedOptionRef);
    }
  }, {
    key: "componentDidUpdate",
    value: function(r) {
      var o = this.props, a = o.isDisabled, l = o.menuIsOpen, u = this.state.isFocused;
      (u && !a && r.isDisabled || // ensure focus is on the Input when the menu opens
      u && l && !r.menuIsOpen) && this.focusInput(), u && a && !r.isDisabled ? this.setState({
        isFocused: !1
      }, this.onMenuClose) : !u && !a && r.isDisabled && this.inputRef === document.activeElement && this.setState({
        isFocused: !0
      }), this.menuListRef && this.focusedOptionRef && this.scrollToFocusedOptionOnUpdate && (uO(this.menuListRef, this.focusedOptionRef), this.scrollToFocusedOptionOnUpdate = !1);
    }
  }, {
    key: "componentWillUnmount",
    value: function() {
      this.stopListeningComposition(), this.stopListeningToTouch(), document.removeEventListener("scroll", this.onScroll, !0);
    }
    // ==============================
    // Consumer Handlers
    // ==============================
  }, {
    key: "onMenuOpen",
    value: function() {
      this.props.onMenuOpen();
    }
  }, {
    key: "onMenuClose",
    value: function() {
      this.onInputChange("", {
        action: "menu-close",
        prevInputValue: this.props.inputValue
      }), this.props.onMenuClose();
    }
  }, {
    key: "onInputChange",
    value: function(r, o) {
      this.props.onInputChange(r, o);
    }
    // ==============================
    // Methods
    // ==============================
  }, {
    key: "focusInput",
    value: function() {
      this.inputRef && this.inputRef.focus();
    }
  }, {
    key: "blurInput",
    value: function() {
      this.inputRef && this.inputRef.blur();
    }
    // aliased for consumers
  }, {
    key: "openMenu",
    value: function(r) {
      var o = this, a = this.state, l = a.selectValue, u = a.isFocused, d = this.buildFocusableOptions(), f = r === "first" ? 0 : d.length - 1;
      if (!this.props.isMulti) {
        var p = d.indexOf(l[0]);
        p > -1 && (f = p);
      }
      this.scrollToFocusedOptionOnUpdate = !(u && this.menuListRef), this.setState({
        inputIsHiddenAfterUpdate: !1,
        focusedValue: null,
        focusedOption: d[f],
        focusedOptionId: this.getFocusedOptionId(d[f])
      }, function() {
        return o.onMenuOpen();
      });
    }
  }, {
    key: "focusValue",
    value: function(r) {
      var o = this.state, a = o.selectValue, l = o.focusedValue;
      if (this.props.isMulti) {
        this.setState({
          focusedOption: null
        });
        var u = a.indexOf(l);
        l || (u = -1);
        var d = a.length - 1, f = -1;
        if (a.length) {
          switch (r) {
            case "previous":
              u === 0 ? f = 0 : u === -1 ? f = d : f = u - 1;
              break;
            case "next":
              u > -1 && u < d && (f = u + 1);
              break;
          }
          this.setState({
            inputIsHidden: f !== -1,
            focusedValue: a[f]
          });
        }
      }
    }
  }, {
    key: "focusOption",
    value: function() {
      var r = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "first", o = this.props.pageSize, a = this.state.focusedOption, l = this.getFocusableOptions();
      if (l.length) {
        var u = 0, d = l.indexOf(a);
        a || (d = -1), r === "up" ? u = d > 0 ? d - 1 : l.length - 1 : r === "down" ? u = (d + 1) % l.length : r === "pageup" ? (u = d - o, u < 0 && (u = 0)) : r === "pagedown" ? (u = d + o, u > l.length - 1 && (u = l.length - 1)) : r === "last" && (u = l.length - 1), this.scrollToFocusedOptionOnUpdate = !0, this.setState({
          focusedOption: l[u],
          focusedValue: null,
          focusedOptionId: this.getFocusedOptionId(l[u])
        });
      }
    }
  }, {
    key: "getTheme",
    value: (
      // ==============================
      // Getters
      // ==============================
      function() {
        return this.props.theme ? typeof this.props.theme == "function" ? this.props.theme(Tv) : Ae(Ae({}, Tv), this.props.theme) : Tv;
      }
    )
  }, {
    key: "getCommonProps",
    value: function() {
      var r = this.clearValue, o = this.cx, a = this.getStyles, l = this.getClassNames, u = this.getValue, d = this.selectOption, f = this.setValue, p = this.props, m = p.isMulti, g = p.isRtl, y = p.options, w = this.hasValue();
      return {
        clearValue: r,
        cx: o,
        getStyles: a,
        getClassNames: l,
        getValue: u,
        hasValue: w,
        isMulti: m,
        isRtl: g,
        options: y,
        selectOption: d,
        selectProps: p,
        setValue: f,
        theme: this.getTheme()
      };
    }
  }, {
    key: "hasValue",
    value: function() {
      var r = this.state.selectValue;
      return r.length > 0;
    }
  }, {
    key: "hasOptions",
    value: function() {
      return !!this.getFocusableOptions().length;
    }
  }, {
    key: "isClearable",
    value: function() {
      var r = this.props, o = r.isClearable, a = r.isMulti;
      return o === void 0 ? a : o;
    }
  }, {
    key: "isOptionDisabled",
    value: function(r, o) {
      return kD(this.props, r, o);
    }
  }, {
    key: "isOptionSelected",
    value: function(r, o) {
      return _D(this.props, r, o);
    }
  }, {
    key: "filterOption",
    value: function(r, o) {
      return ED(this.props, r, o);
    }
  }, {
    key: "formatOptionLabel",
    value: function(r, o) {
      if (typeof this.props.formatOptionLabel == "function") {
        var a = this.props.inputValue, l = this.state.selectValue;
        return this.props.formatOptionLabel(r, {
          context: o,
          inputValue: a,
          selectValue: l
        });
      } else
        return this.getOptionLabel(r);
    }
  }, {
    key: "formatGroupLabel",
    value: function(r) {
      return this.props.formatGroupLabel(r);
    }
    // ==============================
    // Mouse Handlers
    // ==============================
  }, {
    key: "startListeningComposition",
    value: (
      // ==============================
      // Composition Handlers
      // ==============================
      function() {
        document && document.addEventListener && (document.addEventListener("compositionstart", this.onCompositionStart, !1), document.addEventListener("compositionend", this.onCompositionEnd, !1));
      }
    )
  }, {
    key: "stopListeningComposition",
    value: function() {
      document && document.removeEventListener && (document.removeEventListener("compositionstart", this.onCompositionStart), document.removeEventListener("compositionend", this.onCompositionEnd));
    }
  }, {
    key: "startListeningToTouch",
    value: (
      // ==============================
      // Touch Handlers
      // ==============================
      function() {
        document && document.addEventListener && (document.addEventListener("touchstart", this.onTouchStart, !1), document.addEventListener("touchmove", this.onTouchMove, !1), document.addEventListener("touchend", this.onTouchEnd, !1));
      }
    )
  }, {
    key: "stopListeningToTouch",
    value: function() {
      document && document.removeEventListener && (document.removeEventListener("touchstart", this.onTouchStart), document.removeEventListener("touchmove", this.onTouchMove), document.removeEventListener("touchend", this.onTouchEnd));
    }
  }, {
    key: "renderInput",
    value: (
      // ==============================
      // Renderers
      // ==============================
      function() {
        var r = this.props, o = r.isDisabled, a = r.isSearchable, l = r.inputId, u = r.inputValue, d = r.tabIndex, f = r.form, p = r.menuIsOpen, m = r.required, g = this.getComponents(), y = g.Input, w = this.state, v = w.inputIsHidden, x = w.ariaSelection, E = this.commonProps, N = l || this.getElementId("input"), C = Ae(Ae(Ae({
          "aria-autocomplete": "list",
          "aria-expanded": p,
          "aria-haspopup": !0,
          "aria-errormessage": this.props["aria-errormessage"],
          "aria-invalid": this.props["aria-invalid"],
          "aria-label": this.props["aria-label"],
          "aria-labelledby": this.props["aria-labelledby"],
          "aria-required": m,
          role: "combobox",
          "aria-activedescendant": this.isAppleDevice ? void 0 : this.state.focusedOptionId || ""
        }, p && {
          "aria-controls": this.getElementId("listbox")
        }), !a && {
          "aria-readonly": !0
        }), this.hasValue() ? x?.action === "initial-input-focus" && {
          "aria-describedby": this.getElementId("live-region")
        } : {
          "aria-describedby": this.getElementId("placeholder")
        });
        return a ? /* @__PURE__ */ _.createElement(y, Ne({}, E, {
          autoCapitalize: "none",
          autoComplete: "off",
          autoCorrect: "off",
          id: N,
          innerRef: this.getInputRef,
          isDisabled: o,
          isHidden: v,
          onBlur: this.onInputBlur,
          onChange: this.handleInputChange,
          onFocus: this.onInputFocus,
          spellCheck: "false",
          tabIndex: d,
          form: f,
          type: "text",
          value: u
        }, C)) : /* @__PURE__ */ _.createElement(Yle, Ne({
          id: N,
          innerRef: this.getInputRef,
          onBlur: this.onInputBlur,
          onChange: Wp,
          onFocus: this.onInputFocus,
          disabled: o,
          tabIndex: d,
          inputMode: "none",
          form: f,
          value: ""
        }, C));
      }
    )
  }, {
    key: "renderPlaceholderOrValue",
    value: function() {
      var r = this, o = this.getComponents(), a = o.MultiValue, l = o.MultiValueContainer, u = o.MultiValueLabel, d = o.MultiValueRemove, f = o.SingleValue, p = o.Placeholder, m = this.commonProps, g = this.props, y = g.controlShouldRenderValue, w = g.isDisabled, v = g.isMulti, x = g.inputValue, E = g.placeholder, N = this.state, C = N.selectValue, A = N.focusedValue, R = N.isFocused;
      if (!this.hasValue() || !y)
        return x ? null : /* @__PURE__ */ _.createElement(p, Ne({}, m, {
          key: "placeholder",
          isDisabled: w,
          isFocused: R,
          innerProps: {
            id: this.getElementId("placeholder")
          }
        }), E);
      if (v)
        return C.map(function(T, V) {
          var F = T === A, O = "".concat(r.getOptionLabel(T), "-").concat(r.getOptionValue(T));
          return /* @__PURE__ */ _.createElement(a, Ne({}, m, {
            components: {
              Container: l,
              Label: u,
              Remove: d
            },
            isFocused: F,
            isDisabled: w,
            key: O,
            index: V,
            removeProps: {
              onClick: function() {
                return r.removeValue(T);
              },
              onTouchEnd: function() {
                return r.removeValue(T);
              },
              onMouseDown: function(B) {
                B.preventDefault();
              }
            },
            data: T
          }), r.formatOptionLabel(T, "value"));
        });
      if (x)
        return null;
      var D = C[0];
      return /* @__PURE__ */ _.createElement(f, Ne({}, m, {
        data: D,
        isDisabled: w
      }), this.formatOptionLabel(D, "value"));
    }
  }, {
    key: "renderClearIndicator",
    value: function() {
      var r = this.getComponents(), o = r.ClearIndicator, a = this.commonProps, l = this.props, u = l.isDisabled, d = l.isLoading, f = this.state.isFocused;
      if (!this.isClearable() || !o || u || !this.hasValue() || d)
        return null;
      var p = {
        onMouseDown: this.onClearIndicatorMouseDown,
        onTouchEnd: this.onClearIndicatorTouchEnd,
        "aria-hidden": "true"
      };
      return /* @__PURE__ */ _.createElement(o, Ne({}, a, {
        innerProps: p,
        isFocused: f
      }));
    }
  }, {
    key: "renderLoadingIndicator",
    value: function() {
      var r = this.getComponents(), o = r.LoadingIndicator, a = this.commonProps, l = this.props, u = l.isDisabled, d = l.isLoading, f = this.state.isFocused;
      if (!o || !d) return null;
      var p = {
        "aria-hidden": "true"
      };
      return /* @__PURE__ */ _.createElement(o, Ne({}, a, {
        innerProps: p,
        isDisabled: u,
        isFocused: f
      }));
    }
  }, {
    key: "renderIndicatorSeparator",
    value: function() {
      var r = this.getComponents(), o = r.DropdownIndicator, a = r.IndicatorSeparator;
      if (!o || !a) return null;
      var l = this.commonProps, u = this.props.isDisabled, d = this.state.isFocused;
      return /* @__PURE__ */ _.createElement(a, Ne({}, l, {
        isDisabled: u,
        isFocused: d
      }));
    }
  }, {
    key: "renderDropdownIndicator",
    value: function() {
      var r = this.getComponents(), o = r.DropdownIndicator;
      if (!o) return null;
      var a = this.commonProps, l = this.props.isDisabled, u = this.state.isFocused, d = {
        onMouseDown: this.onDropdownIndicatorMouseDown,
        onTouchEnd: this.onDropdownIndicatorTouchEnd,
        "aria-hidden": "true"
      };
      return /* @__PURE__ */ _.createElement(o, Ne({}, a, {
        innerProps: d,
        isDisabled: l,
        isFocused: u
      }));
    }
  }, {
    key: "renderMenu",
    value: function() {
      var r = this, o = this.getComponents(), a = o.Group, l = o.GroupHeading, u = o.Menu, d = o.MenuList, f = o.MenuPortal, p = o.LoadingMessage, m = o.NoOptionsMessage, g = o.Option, y = this.commonProps, w = this.state.focusedOption, v = this.props, x = v.captureMenuScroll, E = v.inputValue, N = v.isLoading, C = v.loadingMessage, A = v.minMenuHeight, R = v.maxMenuHeight, D = v.menuIsOpen, T = v.menuPlacement, V = v.menuPosition, F = v.menuPortalTarget, O = v.menuShouldBlockScroll, B = v.menuShouldScrollIntoView, U = v.noOptionsMessage, G = v.onMenuScrollToTop, z = v.onMenuScrollToBottom;
      if (!D) return null;
      var $ = function(X, Q) {
        var P = X.type, te = X.data, ie = X.isDisabled, ae = X.isSelected, fe = X.label, he = X.value, ye = w === te, Ee = ie ? void 0 : function() {
          return r.onOptionHover(te);
        }, we = ie ? void 0 : function() {
          return r.selectOption(te);
        }, xe = "".concat(r.getElementId("option"), "-").concat(Q), Pe = {
          id: xe,
          onClick: we,
          onMouseMove: Ee,
          onMouseOver: Ee,
          tabIndex: -1,
          role: "option",
          "aria-selected": r.isAppleDevice ? void 0 : ae
          // is not supported on Apple devices
        };
        return /* @__PURE__ */ _.createElement(g, Ne({}, y, {
          innerProps: Pe,
          data: te,
          isDisabled: ie,
          isSelected: ae,
          key: xe,
          label: fe,
          type: P,
          value: he,
          isFocused: ye,
          innerRef: ye ? r.getFocusedOptionRef : void 0
        }), r.formatOptionLabel(X.data, "menu"));
      }, L;
      if (this.hasOptions())
        L = this.getCategorizedOptions().map(function(X) {
          if (X.type === "group") {
            var Q = X.data, P = X.options, te = X.index, ie = "".concat(r.getElementId("group"), "-").concat(te), ae = "".concat(ie, "-heading");
            return /* @__PURE__ */ _.createElement(a, Ne({}, y, {
              key: ie,
              data: Q,
              options: P,
              Heading: l,
              headingProps: {
                id: ae,
                data: X.data
              },
              label: r.formatGroupLabel(X.data)
            }), X.options.map(function(fe) {
              return $(fe, "".concat(te, "-").concat(fe.index));
            }));
          } else if (X.type === "option")
            return $(X, "".concat(X.index));
        });
      else if (N) {
        var H = C({
          inputValue: E
        });
        if (H === null) return null;
        L = /* @__PURE__ */ _.createElement(p, y, H);
      } else {
        var q = U({
          inputValue: E
        });
        if (q === null) return null;
        L = /* @__PURE__ */ _.createElement(m, y, q);
      }
      var Y = {
        minMenuHeight: A,
        maxMenuHeight: R,
        menuPlacement: T,
        menuPosition: V,
        menuShouldScrollIntoView: B
      }, M = /* @__PURE__ */ _.createElement(kae, Ne({}, y, Y), function(X) {
        var Q = X.ref, P = X.placerProps, te = P.placement, ie = P.maxHeight;
        return /* @__PURE__ */ _.createElement(u, Ne({}, y, Y, {
          innerRef: Q,
          innerProps: {
            onMouseDown: r.onMenuMouseDown,
            onMouseMove: r.onMenuMouseMove
          },
          isLoading: N,
          placement: te
        }), /* @__PURE__ */ _.createElement(Kle, {
          captureEnabled: x,
          onTopArrive: G,
          onBottomArrive: z,
          lockEnabled: O
        }, function(ae) {
          return /* @__PURE__ */ _.createElement(d, Ne({}, y, {
            innerRef: function(fe) {
              r.getMenuListRef(fe), ae(fe);
            },
            innerProps: {
              role: "listbox",
              "aria-multiselectable": y.isMulti,
              id: r.getElementId("listbox")
            },
            isLoading: N,
            maxHeight: ie,
            focusedOption: w
          }), L);
        }));
      });
      return F || V === "fixed" ? /* @__PURE__ */ _.createElement(f, Ne({}, y, {
        appendTo: F,
        controlElement: this.controlRef,
        menuPlacement: T,
        menuPosition: V
      }), M) : M;
    }
  }, {
    key: "renderFormField",
    value: function() {
      var r = this, o = this.props, a = o.delimiter, l = o.isDisabled, u = o.isMulti, d = o.name, f = o.required, p = this.state.selectValue;
      if (f && !this.hasValue() && !l)
        return /* @__PURE__ */ _.createElement(ese, {
          name: d,
          onFocus: this.onValueInputFocus
        });
      if (!(!d || l))
        if (u)
          if (a) {
            var m = p.map(function(w) {
              return r.getOptionValue(w);
            }).join(a);
            return /* @__PURE__ */ _.createElement("input", {
              name: d,
              type: "hidden",
              value: m
            });
          } else {
            var g = p.length > 0 ? p.map(function(w, v) {
              return /* @__PURE__ */ _.createElement("input", {
                key: "i-".concat(v),
                name: d,
                type: "hidden",
                value: r.getOptionValue(w)
              });
            }) : /* @__PURE__ */ _.createElement("input", {
              name: d,
              type: "hidden",
              value: ""
            });
            return /* @__PURE__ */ _.createElement("div", null, g);
          }
        else {
          var y = p[0] ? this.getOptionValue(p[0]) : "";
          return /* @__PURE__ */ _.createElement("input", {
            name: d,
            type: "hidden",
            value: y
          });
        }
    }
  }, {
    key: "renderLiveRegion",
    value: function() {
      var r = this.commonProps, o = this.state, a = o.ariaSelection, l = o.focusedOption, u = o.focusedValue, d = o.isFocused, f = o.selectValue, p = this.getFocusableOptions();
      return /* @__PURE__ */ _.createElement(Ble, Ne({}, r, {
        id: this.getElementId("live-region"),
        ariaSelection: a,
        focusedOption: l,
        focusedValue: u,
        isFocused: d,
        selectValue: f,
        focusableOptions: p,
        isAppleDevice: this.isAppleDevice
      }));
    }
  }, {
    key: "render",
    value: function() {
      var r = this.getComponents(), o = r.Control, a = r.IndicatorsContainer, l = r.SelectContainer, u = r.ValueContainer, d = this.props, f = d.className, p = d.id, m = d.isDisabled, g = d.menuIsOpen, y = this.state.isFocused, w = this.commonProps = this.getCommonProps();
      return /* @__PURE__ */ _.createElement(l, Ne({}, w, {
        className: f,
        innerProps: {
          id: p,
          onKeyDown: this.onKeyDown
        },
        isDisabled: m,
        isFocused: y
      }), this.renderLiveRegion(), /* @__PURE__ */ _.createElement(o, Ne({}, w, {
        innerRef: this.getControlRef,
        innerProps: {
          onMouseDown: this.onControlMouseDown,
          onTouchEnd: this.onControlTouchEnd
        },
        isDisabled: m,
        isFocused: y,
        menuIsOpen: g
      }), /* @__PURE__ */ _.createElement(u, Ne({}, w, {
        isDisabled: m
      }), this.renderPlaceholderOrValue(), this.renderInput()), /* @__PURE__ */ _.createElement(a, Ne({}, w, {
        isDisabled: m
      }), this.renderClearIndicator(), this.renderLoadingIndicator(), this.renderIndicatorSeparator(), this.renderDropdownIndicator())), this.renderMenu(), this.renderFormField());
    }
  }], [{
    key: "getDerivedStateFromProps",
    value: function(r, o) {
      var a = o.prevProps, l = o.clearFocusValueOnUpdate, u = o.inputIsHiddenAfterUpdate, d = o.ariaSelection, f = o.isFocused, p = o.prevWasFocused, m = o.instancePrefix, g = r.options, y = r.value, w = r.menuIsOpen, v = r.inputValue, x = r.isMulti, E = sO(y), N = {};
      if (a && (y !== a.value || g !== a.options || w !== a.menuIsOpen || v !== a.inputValue)) {
        var C = w ? gse(r, E) : [], A = w ? kO(mp(r, E), "".concat(m, "-option")) : [], R = l ? yse(o, E) : null, D = vse(o, C), T = zv(A, D);
        N = {
          selectValue: E,
          focusedOption: D,
          focusedOptionId: T,
          focusableOptionsWithIds: A,
          focusedValue: R,
          clearFocusValueOnUpdate: !1
        };
      }
      var V = u != null && r !== a ? {
        inputIsHidden: u,
        inputIsHiddenAfterUpdate: void 0
      } : {}, F = d, O = f && p;
      return f && !O && (F = {
        value: Xf(x, E, E[0] || null),
        options: E,
        action: "initial-input-focus"
      }, O = !p), d?.action === "initial-input-focus" && (F = null), Ae(Ae(Ae({}, N), V), {}, {
        prevProps: r,
        ariaSelection: F,
        prevWasFocused: O
      });
    }
  }]), n;
}(_.Component);
OD.defaultProps = mse;
var wse = /* @__PURE__ */ _.forwardRef(function(e, t) {
  var n = Zie(e);
  return /* @__PURE__ */ _.createElement(OD, Ne({
    ref: t
  }, n));
}), xse = wse;
const Sse = ({
  options: e,
  items_per_page: t,
  className: n,
  defaultValue: r,
  onChange: o
}) => {
  const [a, l] = _.useState(""), [u, d] = _.useState(0), f = (y) => {
    l(y.toLowerCase()), d(0);
  }, p = e.filter((y) => y.label.toLowerCase().includes(a) || y.value.toLowerCase().includes(a));
  var m;
  t !== void 0 ? m = p.slice(
    u * t,
    (u + 1) * t
  ) : m = p;
  const g = {
    control: (y) => ({
      ...y,
      minHeight: void 0
    })
  };
  return /* @__PURE__ */ k.jsx(
    xse,
    {
      options: m,
      onInputChange: f,
      onChange: o,
      inputValue: a,
      isSearchable: !0,
      placeholder: "Select an option...",
      className: n,
      unstyled: !0,
      styles: g,
      classNamePrefix: "styled-select",
      defaultValue: r,
      value: r
    }
  );
};
function kse(e) {
  return e === 0 ? 0 : Math.abs(e) < 1e-12 ? e : Number(e.toPrecision(12));
}
const ND = ({
  iostore: e,
  inputconverter: t,
  parser: n = (r) => parseFloat(r)
}) => {
  var r, o, a, l, u, d, f, p, m, g, y, w, v, x;
  const E = _.useContext(Ge), { preview: N } = e.valuestore(), C = e.use(), [A, R] = _.useState(
    t[1](N?.value)
  );
  _.useEffect(() => {
    R(t[1](N?.value));
  }, [N]);
  const D = (B) => {
    var U, G, z;
    B = n(
      parseFloat(B.toString()).toString()
      // parse float first for e notation
    ), isNaN(B) ? (B = "<NoValue>", R("")) : (((U = C.value_options) == null ? void 0 : U.min) !== void 0 && B < C.value_options.min && (B = C.value_options.min), ((G = C.value_options) == null ? void 0 : G.max) !== void 0 && B > C.value_options.max && (B = C.value_options.max), B = kse(B), R(B.toString()));
    try {
      B = t[0](B);
    } catch {
    }
    (z = E.worker) == null || z.set_io_value({
      nid: C.node,
      ioid: C.id,
      value: B,
      set_default: C.render_options.set_default
    });
  }, T = (B) => {
    D(B.target.value);
  };
  let V = C.connected ? t[1](N?.value) : A;
  V === void 0 && (V = (r = C.value_options) == null ? void 0 : r.min), V === void 0 && (V = (o = C.value_options) == null ? void 0 : o.max), V === void 0 && (V = ""), V === null && (V = "");
  let F = null, O = 1;
  return ((a = C.value_options) == null ? void 0 : a.step) !== void 0 ? O = C.value_options.step : ((l = C.value_options) == null ? void 0 : l.max) !== void 0 && ((u = C.value_options) == null ? void 0 : u.min) !== void 0 && (O = (((d = C.value_options) == null ? void 0 : d.max) - ((f = C.value_options) == null ? void 0 : f.min)) / 1e3), ((p = C.value_options) == null ? void 0 : p.max) !== void 0 && ((m = C.value_options) == null ? void 0 : m.min) !== void 0 && !C.connected && (F = /* @__PURE__ */ k.jsx("div", { style: { minWidth: "6.25rem" }, className: "SliderContainer", children: /* @__PURE__ */ k.jsxs(
    Nie,
    {
      className: "SliderRoot",
      value: [V === void 0 ? (g = C.value_options) == null ? void 0 : g.min : V],
      min: (y = C.value_options) == null ? void 0 : y.min,
      max: (w = C.value_options) == null ? void 0 : w.max,
      step: O,
      disabled: C.connected,
      onValueCommit: (B) => {
        isNaN(B[0]) || D(B[0]);
      },
      onValueChange: (B) => {
        isNaN(B[0]) || R(B[0].toString());
      },
      onKeyDown: (B) => {
        ["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight"].includes(
          B.key
        ) && B.stopPropagation();
      },
      children: [
        /* @__PURE__ */ k.jsx(Mie, { className: "SliderTrack", children: /* @__PURE__ */ k.jsx(Aie, { className: "SliderRange" }) }),
        /* @__PURE__ */ k.jsx(Rie, { className: "SliderThumb" })
      ]
    }
  ) })), /* @__PURE__ */ k.jsxs(k.Fragment, { children: [
    F,
    /* @__PURE__ */ k.jsx(
      "input",
      {
        type: "text",
        className: "nodedatainput styledinput numberinput",
        value: V,
        onChange: (B) => R(B.target.value),
        onBlur: T,
        step: O,
        onKeyDown: (B) => {
          if (!(B.ctrlKey || B.metaKey)) {
            if (B.key === "ArrowUp") {
              B.shiftKey && (O *= 10);
              let U = (parseFloat(V) || 0) + O;
              D(U);
              return;
            }
            if (B.key === "ArrowDown") {
              B.shiftKey && (O *= 10);
              let U = (parseFloat(V) || 0) - O;
              D(U);
              return;
            }
            !/^[0-9.eE+-]$/.test(B.key) && !["Backspace", "ArrowLeft", "ArrowRight", "Delete", "Tab"].includes(
              B.key
            ) && B.preventDefault();
          }
        },
        disabled: C.connected,
        min: (v = C.value_options) == null ? void 0 : v.min,
        max: (x = C.value_options) == null ? void 0 : x.max
      }
    )
  ] });
}, _se = ({
  iostore: e,
  inputconverter: t
}) => ND({ iostore: e, inputconverter: t, parser: parseFloat }), Ese = ({
  iostore: e,
  inputconverter: t
}) => ND({ iostore: e, inputconverter: t, parser: parseInt }), Cse = ({
  iostore: e,
  inputconverter: t
}) => {
  const n = _.useContext(Ge), { preview: r } = e.valuestore(), o = e.use(), a = r?.value === void 0, l = _.useRef(null);
  _.useEffect(() => {
    l.current && (l.current.indeterminate = a);
  }, [l, a]);
  const u = (d) => {
    var f;
    let p = d.target.checked;
    try {
      p = t[0](d.target.checked);
    } catch {
    }
    (f = n.worker) == null || f.set_io_value({
      nid: o.node,
      ioid: o.id,
      value: p,
      set_default: o.render_options.set_default
    });
  };
  return /* @__PURE__ */ k.jsx(
    "input",
    {
      ref: l,
      type: "checkbox",
      className: "styledcheckbox booleaninput",
      checked: !!t[1](r?.value),
      onChange: u,
      disabled: o.connected
    }
  );
}, EO = ({
  iostore: e,
  inputconverter: t
}) => {
  const n = _.useContext(Ge), { preview: r, full: o } = e.valuestore(), a = e.use(), l = o === void 0 ? r?.value : o?.value, [u, d] = _.useState(t[1](l));
  _.useEffect(() => {
    d(t[1](l));
  }, [l]);
  const f = (m) => {
    var g;
    let y = m.target.value;
    y || (y = "<NoValue>");
    try {
      y = t[0](y);
    } catch {
    }
    (g = n.worker) == null || g.set_io_value({
      nid: a.node,
      ioid: a.id,
      value: y,
      set_default: a.render_options.set_default
    });
  };
  let p = a.connected ? t[1](l) : u;
  return p == null && (p = ""), /* @__PURE__ */ k.jsx(
    "input",
    {
      className: "nodedatainput styledinput stringinput",
      value: p,
      onChange: (m) => d(m.target.value),
      onBlur: f,
      disabled: a.connected
    }
  );
}, Ose = ({ iostore: e }) => {
  var t;
  const n = _.useContext(Ge), r = e.use(), { preview: o, full: a } = e.valuestore(), l = a === void 0 ? o?.value : a.value, u = ((t = r.value_options) == null ? void 0 : t.colorspace) || "hex", d = (p) => {
    var m;
    let g = "<NoValue>";
    p && (p[u] ? g = p[u]() : g = p.hex()), p === null && (g = null);
    try {
      g = g;
    } catch {
    }
    (m = n.worker) == null || m.set_io_value({
      nid: r.node,
      ioid: r.id,
      value: g,
      set_default: r.render_options.set_default
    });
  };
  let f = !1;
  return typeof r.type != "string" && "anyOf" in r.type && r.type.anyOf !== void 0 && (f = r.type.anyOf.some((p) => p === "None")), /* @__PURE__ */ k.jsx(
    Fie,
    {
      onChange: d,
      inicolordata: l,
      allow_null: f,
      inicolorspace: u
    }
  );
}, Nse = (e) => e, Mse = (e) => parseFloat(e), Ase = (e) => !!e, Rse = (e) => e === "null" ? null : e, jse = (e) => e === "nuinputconvertermber" ? Mse : e === "boolean" ? Ase : e === "undefined" ? Rse : Nse, Jp = ({
  iostore: e,
  inputconverter: t,
  parser: n
}) => {
  var r;
  const o = e.use(), { preview: a, full: l } = e.valuestore(), u = l === void 0 ? a?.value : l.value;
  let d = ((r = o.value_options) == null ? void 0 : r.options) || [];
  Array.isArray(d) && (d = {
    type: "enum",
    values: d,
    keys: d.map((x) => x === null ? "None" : x.toString()),
    nullable: !1
  }), d.type !== "enum" && (d = {
    type: "enum",
    values: Object.values(d),
    keys: Object.keys(d),
    nullable: !1
  }), d = d, d.nullable && !d.values.includes(null) && !d.keys.includes("None") && (d.values.unshift(null), d.keys.unshift("None"));
  const f = [];
  for (let x = 0; x < d.values.length; x++) {
    const E = d.values[x] === null || d.values[x] === void 0 ? "undefined" : typeof d.values[x];
    let N = d.values[x];
    N === null && (N = "null"), N === void 0 && (N = "undefined"), f.push([d.keys[x], N.toString(), E]);
  }
  const p = _.useContext(Ge), m = ({
    value: x,
    // label
    datatype: E
  }) => {
    var N;
    let C = (n || jse(E))(x);
    try {
      C = t[0](x);
    } catch {
    }
    (N = p.worker) == null || N.set_io_value({
      nid: o.node,
      ioid: o.id,
      value: C,
      set_default: o.render_options.set_default
    });
  };
  let g = u;
  g === null && (g = "null"), g === void 0 && (g = "undefined");
  const y = f.find((x) => x[1] === g.toString());
  let w;
  y !== void 0 && (w = {
    value: y[1],
    label: y[0],
    datatype: y[2]
  });
  const v = f.map(
    (x) => ({
      value: x[1],
      label: x[0],
      datatype: x[2]
    })
  );
  return (
    // <Suspense fallback={<select disabled={true}></select>}>
    /* @__PURE__ */ k.jsx(
      Sse,
      {
        className: "nodedatainput styleddropdown",
        options: v,
        defaultValue: w,
        onChange: (x) => {
          if (x === null) {
            m({
              value: "<NoValue>",
              datatype: "string"
            });
            return;
          }
          m(x);
        }
      }
    )
  );
}, Dse = (e, t = void 0) => ({ iostore: n }) => {
  const { full: r, preview: o } = n.valuestore(), a = r === void 0 ? o : r, l = a?.value || t;
  return /* @__PURE__ */ k.jsx(e, { iostore: n, value: l });
}, Tse = {
  float: _se,
  int: Ese,
  bool: Cse,
  string: EO,
  str: EO,
  color: Ose,
  select: Jp,
  enum: Jp,
  bytes: Dse(Qx, "")
}, zse = ({
  iostore: e,
  typestring: t
}) => {
  const { InLineRenderer: n } = _.useContext(ti), { preview: r, full: o } = e.valuestore();
  if (t && n[t])
    return /* @__PURE__ */ k.jsx("div", { children: n[t]({ iostore: e }) });
  let a = (JSON.stringify(o || r) || "").replace(/\\n/g, `
`);
  return a.length > 63 && (a = a.slice(0, 60) + "..."), /* @__PURE__ */ k.jsx("div", { children: a });
}, Pse = {}, Or = (e, t = void 0) => ({ iostore: n }) => {
  const { full: r, preview: o } = n.valuestore(), a = r === void 0 ? o : r, l = a?.value || t;
  return /* @__PURE__ */ k.jsx(e, { iostore: n, value: l });
}, Lse = {
  string: Or(Vj),
  table: Or(Hj),
  image: Or(Ij),
  svg: Or(Bj, ""),
  dict: Or(am, "{}"),
  bytes: Or(Qx, "")
}, Ise = {}, MD = (e) => ({
  iostore: t,
  value: n,
  preValue: r,
  onLoaded: o
}) => /* @__PURE__ */ k.jsx(
  e,
  {
    iostore: t,
    value: n,
    preValue: r,
    onLoaded: o
  }
), CO = MD(am), Bse = {
  // image: Base64FullImageOutput,
}, Vse = {}, Hse = {}, Use = {}, Er = {
  Inputrenderer: Tse,
  Outputrenderer: Pse,
  HandlePreviewRenderer: Ise,
  DataOverlayRenderer: Bse,
  DataPreviewViewRenderer: Lse,
  DataViewRenderer: die,
  InLineRenderer: yee,
  NodeContextExtenders: Use,
  NodeRenderer: Vse,
  NodeHooks: Hse
}, Fse = (e, t) => {
  const n = t.options || {}, r = n.overwrite === void 0 ? !0 : n.overwrite;
  switch (t.type) {
    case "EXTEND_INPUT_RENDER":
      return !r && e.Inputrenderer[t.payload.type] ? e : {
        ...e,
        Inputrenderer: {
          ...e.Inputrenderer,
          [t.payload.type]: t.payload.component
        }
      };
    case "EXTEND_OUTPUT_RENDER":
      return !r && e.Outputrenderer[t.payload.type] ? e : {
        ...e,
        Outputrenderer: {
          ...e.Outputrenderer,
          [t.payload.type]: t.payload.component
        }
      };
    case "EXTEND_HANDLE_PREVIEW_RENDER":
      return !r && e.HandlePreviewRenderer[t.payload.type] ? e : {
        ...e,
        HandlePreviewRenderer: {
          ...e.HandlePreviewRenderer,
          [t.payload.type]: t.payload.component
        }
      };
    case "EXTEND_DATA_OVERLAY_RENDER":
      return !r && e.DataOverlayRenderer[t.payload.type] ? e : {
        ...e,
        DataOverlayRenderer: {
          ...e.DataOverlayRenderer,
          [t.payload.type]: t.payload.component
        }
      };
    case "EXTEND_DATA_PREVIEW_RENDER":
      return !r && e.DataPreviewViewRenderer[t.payload.type] ? e : {
        ...e,
        DataPreviewViewRenderer: {
          ...e.DataPreviewViewRenderer,
          [t.payload.type]: t.payload.component
        }
      };
    case "EXTEND_DATA_VIEW_RENDER":
      return !r && e.DataViewRenderer[t.payload.type] ? e : {
        ...e,
        DataViewRenderer: {
          ...e.DataViewRenderer,
          [t.payload.type]: t.payload.component
        }
      };
    case "EXTEND_NODE_CONTEXT_EXTENDER":
      return !r && e.NodeContextExtenders[t.payload.type] ? e : {
        ...e,
        NodeContextExtenders: {
          ...e.NodeContextExtenders,
          [t.payload.type]: t.payload.component
        }
      };
    case "EXTEND_NODE_RENDERER":
      return !r && e.NodeRenderer[t.payload.type] ? e : {
        ...e,
        NodeRenderer: {
          ...e.NodeRenderer,
          [t.payload.type]: t.payload.component
        }
      };
    case "EXTEND_NODE_HOOKS":
      return !r && e.NodeHooks[t.payload.type] ? e : {
        ...e,
        NodeHooks: {
          ...e.NodeHooks,
          [t.payload.type]: t.payload.component
        }
      };
    case "EXTEND_FROM_PLUGIN":
      let o = !1;
      const a = [
        [t.payload.plugin.input_renderers || {}, e.Inputrenderer],
        [t.payload.plugin.output_renderers || {}, e.Outputrenderer],
        [
          t.payload.plugin.handle_preview_renderers || {},
          e.HandlePreviewRenderer
        ],
        [
          t.payload.plugin.data_overlay_renderers || {},
          e.DataOverlayRenderer
        ],
        [
          t.payload.plugin.data_preview_renderers || {},
          e.DataPreviewViewRenderer
        ],
        [
          t.payload.plugin.data_view_renderers || {},
          e.DataViewRenderer
        ],
        [
          t.payload.plugin.node_context_extenders || {},
          e.NodeContextExtenders
        ],
        [t.payload.plugin.node_renderers || {}, e.NodeRenderer],
        [t.payload.plugin.node_hooks || {}, e.NodeHooks]
      ];
      for (const [l, u] of a) {
        if (Object.keys(l).length > 0) {
          if (r)
            o = !0;
          else
            for (const d in l)
              if (!u[d]) {
                o = !0;
                break;
              }
        }
        if (o) break;
      }
      if (!o)
        return e;
      for (const [l, u] of a)
        for (const d in l)
          (r || !u[d]) && (u[d] = l[d]);
      return { ...e };
    default:
      return e;
  }
}, $se = ({
  children: e,
  plugins: t,
  fnrf_zst: n
}) => {
  const [r, o] = _.useReducer(
    Fse,
    Er
  ), a = (v, x, E) => {
    o({
      type: "EXTEND_INPUT_RENDER",
      payload: { type: v, component: x },
      options: E
    });
  }, l = (v, x, E) => {
    o({
      type: "EXTEND_OUTPUT_RENDER",
      payload: { type: v, component: x },
      options: E
    });
  }, u = (v, x, E) => {
    o({
      type: "EXTEND_HANDLE_PREVIEW_RENDER",
      payload: { type: v, component: x },
      options: E
    });
  }, d = (v, x, E) => {
    o({
      type: "EXTEND_DATA_OVERLAY_RENDER",
      payload: { type: v, component: x },
      options: E
    });
  }, f = (v, x, E) => {
    o({
      type: "EXTEND_DATA_PREVIEW_RENDER",
      payload: { type: v, component: x },
      options: E
    });
  }, p = (v, x, E) => {
    o({
      type: "EXTEND_DATA_VIEW_RENDER",
      payload: { type: v, component: x },
      options: E
    });
  }, m = (v, x, E) => {
    o({
      type: "EXTEND_NODE_CONTEXT_EXTENDER",
      payload: { type: v, component: x },
      options: E
    });
  }, g = (v, x, E) => {
    o({
      type: "EXTEND_NODE_RENDERER",
      payload: { type: v, component: x },
      options: E
    });
  }, y = (v, x, E) => {
    o({
      type: "EXTEND_NODE_HOOKS",
      payload: { type: v, component: x },
      options: E
    });
  }, w = (v, x) => {
    o({
      type: "EXTEND_FROM_PLUGIN",
      payload: { plugin: v },
      options: x
    });
  };
  return _.useEffect(() => {
    for (const v in t) {
      const x = t[v];
      if (!x) continue;
      const E = x.renderpluginfactory;
      E && w(E({ React: jO, fnrf_zst: n, NodeContext: TD }));
    }
  }, [t]), /* @__PURE__ */ k.jsx(
    ti.Provider,
    {
      value: {
        Inputrenderer: r.Inputrenderer,
        Outputrenderer: r.Outputrenderer,
        HandlePreviewRenderer: r.HandlePreviewRenderer,
        DataOverlayRenderer: r.DataOverlayRenderer,
        DataPreviewViewRenderer: r.DataPreviewViewRenderer,
        DataViewRenderer: r.DataViewRenderer,
        InLineRenderer: r.InLineRenderer,
        NodeContextExtenders: r.NodeContextExtenders,
        NodeRenderer: r.NodeRenderer,
        NodeHooks: r.NodeHooks,
        extendInputRenderMapping: a,
        extendOutputRenderMapping: l,
        extendHandlePreviewRenderMapping: u,
        extendDataOverlayRenderMapping: d,
        extendDataPreviewRenderMapping: f,
        extendDataViewRenderMapping: p,
        extendNodeContextExtender: m,
        extendNodeRenderer: g,
        extendNodeHooks: y,
        extendFromPlugin: w
      },
      children: e
    }
  );
}, ti = _.createContext({
  Inputrenderer: Er.Inputrenderer,
  Outputrenderer: Er.Outputrenderer,
  HandlePreviewRenderer: Er.HandlePreviewRenderer,
  DataOverlayRenderer: Er.DataOverlayRenderer,
  DataPreviewViewRenderer: Er.DataPreviewViewRenderer,
  DataViewRenderer: Er.DataViewRenderer,
  InLineRenderer: Er.InLineRenderer,
  NodeContextExtenders: Er.NodeContextExtenders,
  NodeRenderer: Er.NodeRenderer,
  NodeHooks: Er.NodeHooks,
  extendInputRenderMapping: (e, t, n) => {
  },
  extendOutputRenderMapping: (e, t, n) => {
  },
  extendHandlePreviewRenderMapping: (e, t, n) => {
  },
  extendDataOverlayRenderMapping: (e, t, n) => {
  },
  extendDataPreviewRenderMapping: (e, t, n) => {
  },
  extendDataViewRenderMapping: (e, t, n) => {
  },
  extendNodeContextExtender: (e, t, n) => {
  },
  extendNodeRenderer: (e, t, n) => {
  },
  extendNodeHooks: (e, t, n) => {
  },
  extendFromPlugin: (e, t) => {
  }
}), AD = (e) => {
  const t = _.useContext(Ge), { DataOverlayRenderer: n, DataViewRenderer: r } = _.useContext(ti);
  if (e === void 0) return;
  const o = t.render_options(), [a] = Fa(e.type, o.typemap || {});
  return a ? n[a] ? n[a] : r[a] ? MD(r[a]) : CO : CO;
}, Yse = (e) => {
  const t = _.useContext(Ge).render_options(), { HandlePreviewRenderer: n, DataPreviewViewRenderer: r } = _.useContext(ti), o = AD(e);
  let a;
  if (e) {
    const [l] = Fa(e.type, t.typemap || {});
    l ? n[l] ? a = n[l] : r[l] ? a = r[l] : a = Or(Gp) : a = Or(Gp);
  }
  return [a, o];
}, RD = ({
  iostore: e,
  Component: t
}) => {
  const [n, r] = _.useState(void 0), [o, a] = _.useState(void 0), { full: l } = e.valuestore();
  _.useEffect(() => {
    l === void 0 ? e.getState().try_get_full_value() : a(l.value);
  }, [l]);
  const u = () => {
    o !== void 0 && r(o);
  };
  return /* @__PURE__ */ k.jsx(
    t,
    {
      iostore: e,
      value: o,
      preValue: n,
      onLoaded: u
    }
  );
}, jD = ({
  iostore: e,
  Component: t
}) => /* @__PURE__ */ k.jsx(t, { iostore: e }), Fa = (e, t) => {
  if (typeof e == "string")
    return e in t ? [t[e], e] : [e, e];
  if ("allOf" in e && e.allOf !== void 0)
    return [void 0, void 0];
  if ("anyOf" in e && e.anyOf !== void 0) {
    const n = e.anyOf.map((r) => Fa(r, t));
    for (const r of n)
      switch (r[0]) {
        case "bool":
          return ["bool", r[1]];
        case "enum":
          return ["enum", r[1]];
        case "float":
          return ["float", r[1]];
        case "int":
          return ["int", r[1]];
        case "string":
          return ["string", r[1]];
        case "str":
          return ["string", r[1]];
      }
    return [void 0, void 0];
  }
  return !("type" in e) || e.type === void 0 ? [void 0, void 0] : e.type === "enum" ? ["enum", "enum"] : [void 0, void 0];
}, rw = ({
  iostore: e,
  typestring: t,
  preview: n,
  ...r
}) => {
  const [o, a] = _.useState(!1), [l, u] = _.useState(!1), d = _.useContext(Ge), f = e.use(), [p, m] = Yse(f), g = d.local_state(() => d.reactflowRef);
  return (
    // <Tooltip.Provider>
    /* @__PURE__ */ k.jsxs(GR, { open: o || l, onOpenChange: u, children: [
      /* @__PURE__ */ k.jsx(ZR, { asChild: !0, children: /* @__PURE__ */ k.jsx(pc, { id: f.id, "data-type": t, ...r }) }),
      /* @__PURE__ */ k.jsx(WR, { container: g, children: /* @__PURE__ */ k.jsxs(KR, { className: "iotooltipcontent", sideOffset: 5, children: [
        /* @__PURE__ */ k.jsxs("div", { className: "iotooltip_container", children: [
          /* @__PURE__ */ k.jsxs("div", { className: "iotooltip_header", children: [
            o ? /* @__PURE__ */ k.jsx(T$, { onClick: () => a(!1) }) : /* @__PURE__ */ k.jsx(D$, { onClick: () => a(!0) }),
            m && /* @__PURE__ */ k.jsx(
              bs,
              {
                title: f.full_id,
                trigger: /* @__PURE__ */ k.jsx(cM, {}),
                onOpenChange: (y) => {
                  y && f.try_get_full_value && f.try_get_full_value(), a(y);
                },
                children: /* @__PURE__ */ k.jsx(
                  RD,
                  {
                    Component: m,
                    iostore: e
                  }
                )
              }
            )
          ] }),
          p ? /* @__PURE__ */ k.jsx(jD, { Component: p, iostore: e }) : `no preview available for "${t}"`
        ] }),
        /* @__PURE__ */ k.jsx(mee, { className: "iotooltipcontentarrow" })
      ] }) })
    ] })
  );
}, eh = {
  "": [(e) => e, (e) => e],
  str_to_json: [
    (e) => JSON.parse(e),
    (e) => typeof e == "string" ? e : JSON.stringify(e)
  ],
  str_to_list: [
    (e) => {
      try {
        const t = JSON.parse(e);
        return Array.isArray(t) ? t : [t];
      } catch {
        try {
          return JSON.parse("[" + e + "]");
        } catch {
        }
      }
      throw new Error("Invalid list");
    },
    (e) => JSON.stringify(e)
  ]
}, qse = ({ iostore: e }) => {
  var t, n;
  const r = _.useContext(Ge).render_options(), o = e.use(), [a, l] = Fa(
    o.render_options.type,
    r.typemap || {}
  ), { Inputrenderer: u } = _.useContext(ti), d = a ? (t = o.value_options) != null && t.options ? Jp : u[a] : void 0, f = eh[(l && ((n = r.inputconverter) == null ? void 0 : n[l])) ?? ""] || eh[""];
  return o.hidden ? null : /* @__PURE__ */ k.jsxs("div", { className: "nodeinput", "data-type": a, children: [
    /* @__PURE__ */ k.jsx(
      rw,
      {
        iostore: e,
        typestring: a,
        position: Ce.Left,
        type: "target"
      }
    ),
    d && /* @__PURE__ */ k.jsx("div", { className: "iovaluefield nodrag", "data-type": a, children: /* @__PURE__ */ k.jsx(d, { iostore: e, inputconverter: f }) }),
    /* @__PURE__ */ k.jsx("div", { className: "ioname", children: o.name }),
    /* @__PURE__ */ k.jsx(
      rw,
      {
        iostore: e,
        typestring: a,
        position: Ce.Right,
        type: "source"
      }
    )
  ] });
}, Xse = ({ iostore: e }) => {
  const t = _.useContext(Ge).render_options(), n = e.use(), [r] = Fa(n.type, t.typemap || {}), { Outputrenderer: o } = _.useContext(ti), a = r ? o[r] : void 0;
  return n.hidden ? null : /* @__PURE__ */ k.jsxs("div", { className: "nodeoutput", "data-type": r, children: [
    /* @__PURE__ */ k.jsx(
      rw,
      {
        iostore: e,
        typestring: r,
        position: Ce.Right,
        type: "source"
      }
    ),
    /* @__PURE__ */ k.jsx("div", { className: "ioname", children: n.name }),
    a ? /* @__PURE__ */ k.jsx("div", { className: "iovaluefield nodrag", children: /* @__PURE__ */ k.jsx(a, { iostore: e }) }) : /* @__PURE__ */ k.jsx("div", { className: "iovaluefield", children: /* @__PURE__ */ k.jsx(zse, { iostore: e, typestring: r }) })
  ] });
}, Gse = (e) => {
  const t = _.useContext(Ge), n = AD(e), { DataPreviewViewRenderer: r, DataViewRenderer: o } = _.useContext(ti), a = t.render_options();
  if (e === void 0) return [void 0, n];
  const [l] = Fa(e.type, a.typemap || {});
  return l ? r[l] ? [r[l], n] : o[l] ? [
    Or(o[l]),
    n
  ] : [
    Or(Gp),
    n
  ] : [
    Or(Gp),
    n
  ];
};
function Zse(e, t, n = {}) {
  const {
    maxFontSize: r = 100,
    // default maximum font size
    minFontSize: o = 6,
    // default minimum font size
    decrementFactor: a = 0.9
    // font size decrement step
  } = n;
  if (!e || !t)
    return;
  if (a >= 1 || a <= 0)
    throw new Error("decrementFactor must be between 0 and 1");
  const l = e.getBoundingClientRect(), u = l.width, d = l.height;
  let f = r;
  t.style.whiteSpace = "nowrap", t.style.display = "inline-block", t.style.fontSize = f + "px";
  let p = t.getBoundingClientRect();
  for (; (p.width > u || p.height > d) && f > o; )
    f *= a, t.style.fontSize = f + "px", p = t.getBoundingClientRect();
}
function Wse(e = {
  n: 0,
  elapsed: 0,
  ascii: !1,
  unit: "it",
  unit_scale: !1,
  unit_divisor: 1e3
}) {
  let t = e.total ?? null;
  const {
    n,
    unit_scale: r,
    elapsed: o,
    // ascii,
    unit: a,
    unit_divisor: l,
    // ncols = undefined,
    prefix: u = "",
    rate: d = void 0,
    // bar_format = undefined,
    postfix: f = null,
    initial: p = 0
    // colour = undefined,
  } = e;
  t !== null && n >= t + 0.5 && (t = null);
  let m = n, g = t, y = d;
  r && r !== !0 && r !== 1 && (t !== null && (g = t * r), m = n * r, d !== void 0 && (y = d * r));
  const w = OO(o);
  y === void 0 && o > 0 && (y = (m - p) / o);
  const v = y ? 1 / y : void 0, [x, E] = y ? Gf(y, l) : [void 0, ""], [N, C] = v ? Gf(v, 1e3) : [void 0, ""], A = (x || "?") + `${E}${a}/s`, R = N ? `${N}${C}s/` + a : "?", D = v && v > 1 ? R : A, T = r ? Gf(m, l).join("") : m.toString(), V = r && g !== null ? Gf(g, l).join("") : g?.toString() ?? "?", F = y && g !== null ? (g - m) / y : 0, O = y ? OO(F) : "?", B = u ? `${u}: ` : "";
  if (t !== null) {
    const U = m / t * 100, G = ` ${T}/${V} [${w} < ${O}, ${D}${f ?? ""}]`;
    return `${B}${U.toFixed(0)}%${G}`;
  }
  return `${B}${T}${a} [${w}, ${D}${f ?? ""}]`;
}
function OO(e) {
  const t = Math.floor(e / 60), n = Math.floor(e % 60);
  return `${t}:${n.toString().padStart(2, "0")}`;
}
function Gf(e, t) {
  const n = ["", "K", "M", "G", "T"];
  let r = 0;
  for (; e >= t && r < n.length - 1; )
    e /= t, r++;
  return [e.toFixed(2), n[r]];
}
const Kse = ({ state: e, className: t = "reacttqdm", ...n }) => {
  const r = _.useRef(null), o = _.useRef(null);
  _.useEffect(() => {
    const l = () => {
      !r.current || !o.current || Zse(r.current, o.current, {
        maxFontSize: 12,
        decrementFactor: 0.9
      });
    };
    return l(), window.addEventListener("resize", l), () => {
      window.removeEventListener("resize", l);
    };
  }, [e]);
  const a = e.total ? e.n / e.total * 100 : 0;
  return /* @__PURE__ */ k.jsx("div", { ref: r, className: t, ...n, children: /* @__PURE__ */ k.jsxs(
    "div",
    {
      style: {
        position: "relative",
        display: "flex",
        flexDirection: "column",
        justifyContent: "center",
        alignItems: "center"
      },
      children: [
        /* @__PURE__ */ k.jsx(
          "div",
          {
            className: t + "-bar",
            style: {
              position: "absolute",
              width: "100%",
              height: "100%",
              // Adjust height if needed
              overflow: "hidden"
            },
            children: /* @__PURE__ */ k.jsx(
              "div",
              {
                className: t + "-progress",
                style: {
                  width: `${a}%`,
                  height: "100%"
                }
              }
            )
          }
        ),
        /* @__PURE__ */ k.jsx("div", { className: t + "-text", ref: o, children: Wse(e) })
      ]
    }
  ) });
}, Qse = _.memo(({ node_data: e }) => {
  const t = _.useContext(Ge), n = () => {
    t.on_node_action({
      type: "trigger",
      from_remote: !1,
      id: e.id
    });
  };
  return /* @__PURE__ */ k.jsxs(
    "div",
    {
      className: "nodeheader",
      title: e.description || e.node_name,
      children: [
        /* @__PURE__ */ k.jsxs("div", { className: "nodeheader_element", children: [
          /* @__PURE__ */ k.jsx(
            P$,
            {
              fontSize: "inherit",
              className: "triggerbutton",
              onClick: n
            }
          ),
          /* @__PURE__ */ k.jsx(
            z$,
            {
              fontSize: "inherit",
              onClick: async () => {
                var r;
                console.log(
                  "nodestatus",
                  await ((r = t.worker) == null ? void 0 : r.get_node_status(e.id))
                );
              }
            }
          )
        ] }),
        /* @__PURE__ */ k.jsx("div", { className: "nodeheader_element nodeheader_title", children: /* @__PURE__ */ k.jsx("div", { className: "nodeheader_title_text", children: e.node_name }) }),
        /* @__PURE__ */ k.jsx("div", { className: "nodeheader_element", children: /* @__PURE__ */ k.jsx(Hc, { fontSize: "inherit" }) })
      ]
    }
  );
}), Jse = ({
  iostore: e,
  node_data: t
}) => {
  var n, r;
  const o = e.use(), [a, l] = Gse(o);
  return /* @__PURE__ */ k.jsx(
    "div",
    {
      className: "nodrag nodedatabody",
      "data-src": ((r = (n = t.render_options) == null ? void 0 : n.data) == null ? void 0 : r.src) || "",
      children: a && o && /* @__PURE__ */ k.jsx(
        bs,
        {
          title: o.full_id,
          trigger: /* @__PURE__ */ k.jsx("div", { className: "nodedatabutton", children: /* @__PURE__ */ k.jsx(jD, { Component: a, iostore: e }) }),
          onOpenChange: (u) => {
            u && o != null && o.try_get_full_value && o?.try_get_full_value();
          },
          children: l && /* @__PURE__ */ k.jsx(RD, { Component: l, iostore: e })
        }
      )
    }
  );
}, eue = _.memo(({ node_data: e }) => {
  var t, n, r, o;
  const a = (n = (t = e.render_options) == null ? void 0 : t.data) != null && n.src ? e.io[(o = (r = e.render_options) == null ? void 0 : r.data) == null ? void 0 : o.src] : void 0;
  return /* @__PURE__ */ k.jsxs("div", { className: "nodebody", children: [
    e.outputs.map((l) => /* @__PURE__ */ k.jsx(Xse, { iostore: e.io[l] }, l)),
    a && /* @__PURE__ */ k.jsx(Jse, { node_data: e, iostore: a }),
    e.inputs.map((l) => /* @__PURE__ */ k.jsx(qse, { iostore: e.io[l] }, l))
  ] });
}), DD = _.memo(({ node_data: e }) => {
  const [t, n] = _.useState(e.name);
  _.useEffect(() => {
    n(e.name);
  }, [e]);
  const r = _.useContext(Ge), o = (l) => {
    n(l.target.value);
  }, a = (l) => {
    const u = l.target.value;
    r.on_node_action({
      type: "update",
      from_remote: !1,
      id: e.id,
      node: { name: u }
    });
  };
  return /* @__PURE__ */ k.jsx(
    "input",
    {
      className: "nodename_input",
      value: t,
      onChange: o,
      onBlur: a
    }
  );
}), tue = ({ node_data: e }) => {
  if (!e.progress) return null;
  const t = e.progress();
  return /* @__PURE__ */ k.jsx(
    Kse,
    {
      state: t,
      className: "nodeprogress"
    }
  );
}, nue = _.memo(
  ({ node_data: e }) => /* @__PURE__ */ k.jsxs("div", { className: "nodefooter", children: [
    e.error && /* @__PURE__ */ k.jsx("div", { className: "nodeerror", children: e.error }),
    /* @__PURE__ */ k.jsx(tue, { node_data: e })
  ] })
), rue = (e) => {
  const t = _.useContext(Ge), [n, r] = _.useState(!1), o = e.in_trigger(), a = _.useContext(ti), l = a.NodeContextExtenders[e.node_id], u = _.useMemo(
    () => l?.({ node_data: e }) || {},
    [l, e]
  ), d = _.useMemo(
    () => ({ ...u, node_data: e }),
    [u, e]
  ), f = a.NodeHooks[e.node_id];
  for (const p of f || [])
    p({ nodecontext: d });
  return _.useEffect(() => {
    var p;
    (p = t.worker) == null || p.call_hooks("node_mounted", e.id);
  }, [t.worker, e.id]), _.useEffect(() => {
    let p;
    return o && !n ? r(!0) : n && (p = setTimeout(() => r(!1), 200)), () => clearTimeout(p);
  }, [o, n]), { visualTrigger: n, nodecontext: d };
}, TD = _.createContext(null), oue = ({ data: e }) => {
  const t = e.nodestore.use(), n = t.properties["frontend:collapsed"] || !1, { visualTrigger: r, nodecontext: o } = rue(t);
  return /* @__PURE__ */ k.jsx(TD.Provider, { value: o, children: /* @__PURE__ */ k.jsxs(
    "div",
    {
      className: "innernode" + (r ? " intrigger" : "") + (t.error ? " error" : ""),
      children: [
        /* @__PURE__ */ k.jsx(Qse, { node_data: t }),
        /* @__PURE__ */ k.jsx(DD, { node_data: t }),
        n ? null : /* @__PURE__ */ k.jsx(eue, { node_data: t }),
        /* @__PURE__ */ k.jsx(nue, { node_data: t })
      ]
    }
  ) });
}, iue = ({ iostore: e }) => {
  var t, n;
  const r = _.useContext(Ge).render_options(), o = e.use(), [a, l] = Fa(
    o.render_options.type,
    r.typemap || {}
  ), { Inputrenderer: u } = _.useContext(ti), d = a ? (t = o.value_options) != null && t.options ? Jp : u[a] : void 0, f = eh[(l && ((n = r.inputconverter) == null ? void 0 : n[l])) ?? ""] || eh[""];
  return /* @__PURE__ */ k.jsxs("div", { className: "nodesettings_component", children: [
    /* @__PURE__ */ k.jsx("div", { children: o.name }),
    d && /* @__PURE__ */ k.jsx(d, { iostore: e, inputconverter: f }),
    /* @__PURE__ */ k.jsx("div", { children: /* @__PURE__ */ k.jsxs("label", { children: [
      "hidden:",
      /* @__PURE__ */ k.jsx(
        "input",
        {
          className: "styledcheckbox",
          type: "checkbox",
          disabled: o.connected,
          onChange: (p) => {
            var m;
            (m = o.set_hidden) == null || m.call(o, p.target.checked);
          },
          checked: o.hidden
        }
      )
    ] }) })
  ] });
}, aue = ({ iostore: e }) => {
  const t = e.use();
  return /* @__PURE__ */ k.jsxs("div", { className: "nodesettings_component", children: [
    /* @__PURE__ */ k.jsx("div", { children: t.name }),
    /* @__PURE__ */ k.jsx("div", { children: /* @__PURE__ */ k.jsxs("label", { children: [
      "hidden:",
      /* @__PURE__ */ k.jsx(
        "input",
        {
          className: "styledcheckbox",
          type: "checkbox",
          disabled: t.connected,
          onChange: (n) => {
            var r;
            (r = t.set_hidden) == null || r.call(t, n.target.checked);
          },
          checked: t.hidden
        }
      )
    ] }) })
  ] });
}, lue = ({
  nodestore: e
}) => {
  const t = e.use();
  return /* @__PURE__ */ k.jsxs("div", { className: "nodesettings_content", children: [
    /* @__PURE__ */ k.jsx("div", { className: "nodesettings_section", children: /* @__PURE__ */ k.jsxs("div", { className: "nodesettings_component", children: [
      /* @__PURE__ */ k.jsx("div", { children: "Name" }),
      /* @__PURE__ */ k.jsx("div", { children: /* @__PURE__ */ k.jsx(DD, { node_data: t }) })
    ] }) }),
    /* @__PURE__ */ k.jsxs("div", { className: "nodesettings_section", children: [
      /* @__PURE__ */ k.jsx("div", { children: "Inputs" }),
      t.inputs.map((n) => /* @__PURE__ */ k.jsx(iue, { iostore: t.io[n] }, n))
    ] }),
    /* @__PURE__ */ k.jsxs("div", { className: "nodesettings_section", children: [
      /* @__PURE__ */ k.jsx("div", { children: "Outputs" }),
      t.outputs.map((n) => /* @__PURE__ */ k.jsx(aue, { iostore: t.io[n] }, n))
    ] })
  ] });
}, sue = () => {
  const e = _.useContext(Ge), t = e.local_state((r) => r.selected_nodes);
  if (t.length === 0)
    return /* @__PURE__ */ k.jsx("div", { children: "Node Settings" });
  if (t.length > 1)
    return /* @__PURE__ */ k.jsx("div", { children: "Multiple Nodes Selected" });
  const n = e.nodespace.get_node(t[0]);
  return n ? /* @__PURE__ */ k.jsx(lue, { nodestore: n }) : /* @__PURE__ */ k.jsx("div", { children: "Node not found" });
}, uue = () => {
  const e = _.useContext(Ge), t = e.local_settings(
    (o) => o.view_settings.expand_node_props
  ), n = e.local_settings(
    (o) => o.update_view_settings
  ), r = (o) => {
    n({ expand_node_props: o });
  };
  return /* @__PURE__ */ k.jsx(
    MA,
    {
      direction: "left",
      expanded: t === void 0 ? !1 : t,
      containerClassName: "pos-right pos-top bg1 h-12",
      className: "nodesettings_content",
      onExpandChange: r,
      children: /* @__PURE__ */ k.jsx(sue, {})
    }
  );
}, cue = ({
  id: e,
  sourceX: t,
  sourceY: n,
  targetX: r,
  targetY: o,
  sourcePosition: a,
  targetPosition: l,
  data: u,
  ...d
}) => {
  const [f] = gw({
    sourceX: t,
    sourceY: n,
    sourcePosition: a,
    targetX: r,
    targetY: o,
    targetPosition: l
  });
  return /* @__PURE__ */ k.jsx(k.Fragment, { children: /* @__PURE__ */ k.jsx(Pc, { id: e, path: f, ...d }) });
}, due = (e) => ({
  nodes: e.nodes,
  edges: e.edges,
  onNodesChange: e.onNodesChange,
  onEdgesChange: e.onEdgesChange,
  onConnect: e.onConnect
}), fue = { default: oue }, pue = {
  default: cue
}, hue = () => {
  const e = zc(), t = _.useContext(Ge);
  return t.rf_instance = e, /* @__PURE__ */ k.jsx(k.Fragment, {});
}, mue = () => {
  const e = _.useContext(Ge), t = ls("Delete"), n = G1(), r = q1();
  if (t) {
    for (const o of n)
      if (o.selected) {
        if (!e.worker) return /* @__PURE__ */ k.jsx(k.Fragment, {});
        if (!o.source || !o.target) return /* @__PURE__ */ k.jsx(k.Fragment, {});
        if (!o.sourceHandle || !o.targetHandle) return /* @__PURE__ */ k.jsx(k.Fragment, {});
        e.worker.remove_edge({
          src_nid: o.source,
          src_ioid: o.sourceHandle,
          trg_nid: o.target,
          trg_ioid: o.targetHandle
        });
      }
    for (const o of r)
      if (o.selected) {
        if (!e.worker) return /* @__PURE__ */ k.jsx(k.Fragment, {});
        e.worker.remove_node(o.id);
      }
  }
  return /* @__PURE__ */ k.jsx(k.Fragment, {});
}, gue = ({
  id: e,
  top: t,
  left: n,
  right: r,
  bottom: o,
  ...a
}) => {
  const { getNode: l, setNodes: u, addNodes: d, setEdges: f } = zc(), p = _.useContext(Ge), m = _.useCallback(() => {
    const v = l(e);
    if (!v) return;
    const x = {
      x: v.position.x + 50,
      y: v.position.y + 50
    };
    d({ ...v, id: `${v.id}-copy`, position: x });
  }, [e, l, d]), g = _.useCallback(() => {
    p.on_node_action({ type: "delete", id: e, from_remote: !1 });
  }, [e, u, f]), y = p.nodespace.get_node(e, !1);
  if (!y) return /* @__PURE__ */ k.jsx(k.Fragment, { children: " " });
  const w = y.use();
  return /* @__PURE__ */ k.jsxs(
    "div",
    {
      style: { top: t, left: n, right: r, bottom: o },
      className: "context-menu",
      ...a,
      children: [
        /* @__PURE__ */ k.jsx("p", { style: { fontWeight: "bold" }, children: /* @__PURE__ */ k.jsx("small", { children: w.name }) }),
        /* @__PURE__ */ k.jsx("button", { onClick: m, children: "duplicate" }),
        /* @__PURE__ */ k.jsx("button", { onClick: g, children: "delete" })
      ]
    }
  );
}, yue = (e) => {
  const t = _.useContext(Ge), n = _.useRef(null);
  _.useEffect(() => {
    t.reactflowRef = n.current;
  }, [n]);
  const [r, o] = _.useState(null), a = ({
    nodes: g,
    edges: y
  }) => {
    const w = t.local_state.getState();
    t.local_state.setState({
      ...w,
      selected_nodes: g.map((v) => v.id),
      selected_edges: y.map((v) => v.id)
    });
  }, l = _.useCallback(() => o(null), [o]), { nodes: u, edges: d, onNodesChange: f, onEdgesChange: p, onConnect: m } = t.useReactFlowStore(iee(due));
  return /* @__PURE__ */ k.jsx("div", { className: "reactflowlayer", children: /* @__PURE__ */ k.jsxs(
    $1,
    {
      nodes: u,
      edges: d,
      onNodesChange: f,
      onEdgesChange: p,
      onConnect: m,
      nodeTypes: fue,
      edgeTypes: pue,
      minZoom: e.minZoom,
      maxZoom: e.maxZoom,
      fitView: !0,
      onSelectionChange: a,
      ref: n,
      onPaneClick: l,
      panOnDrag: !e.static,
      children: [
        /* @__PURE__ */ k.jsx(hue, {}),
        /* @__PURE__ */ k.jsx(mue, {}),
        /* @__PURE__ */ k.jsx(
          J1,
          {
            color: "#888",
            gap: 16,
            size: 1
          }
        ),
        e.minimap && /* @__PURE__ */ k.jsx(
          vI,
          {
            nodeStrokeWidth: 3,
            pannable: !e.static,
            zoomable: !e.static,
            zoomStep: 3
          }
        ),
        r && /* @__PURE__ */ k.jsx(gue, { onClick: l, ...r })
      ]
    }
  ) });
}, um = _.createContext(
  void 0
), Ea = _.forwardRef((e, t) => {
  const { asChild: n, children: r, className: o, style: a, ...l } = e, [u, d] = _.useState(!1), f = _.useRef(null), [p, m] = _.useState(null), [g, y] = _.useState({}), w = e.htime || 300, v = e.vtime || 300, x = e.hdelay || 0, E = e.vdelay || 200;
  _.useImperativeHandle(t, () => f.current, []);
  const N = async () => {
    if (!f.current) return;
    f.current.style.transition = "none", f.current.style.position = "", f.current.style.top = "", f.current.style.left = "", f.current.style.width = "", f.current.style.height = "";
    const T = f.current.getBoundingClientRect();
    m([T.left, T.top, T.width, T.height]), f.current.style.transition = "none", y({
      position: "absolute",
      top: `${T.top}px`,
      left: `${T.left}px`,
      width: `${T.width}px`,
      height: `${T.height}px`
    }), y((U) => ({
      ...U,
      transitionProperty: "width, left, height, top",
      transitionDuration: `${w}ms, ${w}ms, ${v}ms, ${v}ms`
    })), d(!0);
    const V = new Promise((U) => {
      setTimeout(() => {
        y((G) => ({
          ...G,
          left: "0px",
          width: "100vw"
        })), U();
      }, x);
    }), F = new Promise((U) => {
      setTimeout(() => {
        y((G) => ({
          ...G,
          top: "0px",
          height: "100vh"
        })), U();
      }, E);
    }), O = Math.max(w + x, v + E), B = new Promise((U) => {
      setTimeout(() => {
        U();
      }, O);
    });
    await Promise.all([V, F, B]);
  }, C = async () => {
    if (!f.current || !p) return;
    const T = {
      transitionProperty: "width, left, height, top",
      transitionDuration: `${w}ms, ${w}ms, ${v}ms, ${v}ms`
    };
    y((L) => ({
      ...L,
      ...T
    }));
    const [V, F, O, B] = p, U = new Promise((L) => {
      setTimeout(() => {
        y((H) => ({
          ...H,
          left: `${V}px`,
          width: `${O}px`
        })), L();
      }, E);
    }), G = new Promise((L) => {
      setTimeout(() => {
        y((H) => ({
          ...H,
          top: `${F}px`,
          height: `${B}px`
        })), L();
      }, x);
    }), z = Math.max(w + x, v + E), $ = new Promise((L) => {
      setTimeout(() => {
        L();
      }, z);
    });
    await Promise.all([U, G, $]), f.current.style.transition = "", y({}), d(!1);
  }, A = async () => {
    f.current && (u ? await C() : await N());
  };
  let R;
  if (n && _.isValidElement(r)) {
    const T = r, V = [
      T.props.className,
      o,
      "smooth-expand",
      u ? "smooth-expand-expanded" : ""
    ].filter(Boolean).join(" "), F = {
      ...T.props.style,
      ...a,
      ...g
    };
    R = _.cloneElement(T, {
      ref: f,
      className: V,
      style: F,
      ...l
    });
  } else
    R = /* @__PURE__ */ k.jsx(
      "div",
      {
        ref: f,
        ...l,
        className: `smooth-expand ${u ? "smooth-expand-expanded" : ""} ${o || ""}`,
        style: { ...a, ...g },
        children: r
      }
    );
  const D = /* @__PURE__ */ k.jsx(um.Provider, { value: { isExpanded: u, toggleExpand: A }, children: R });
  return u ? Mc.createPortal(D, document.body) : D;
});
Ea.Trigger = function({
  children: e
}) {
  const t = _.useContext(um);
  if (!t)
    throw new Error(
      "SmoothExpandComponent.Trigger must be used within a SmoothExpandComponent"
    );
  return /* @__PURE__ */ k.jsx("div", { style: { cursor: "pointer" }, onClick: t.toggleExpand, children: e });
};
Ea.Expanded = function({
  children: e
}) {
  const t = _.useContext(um);
  if (!t)
    throw new Error(
      "SmoothExpandComponent.Expanded must be used within a SmoothExpandComponent"
    );
  return t.isExpanded ? /* @__PURE__ */ k.jsx(k.Fragment, { children: e }) : null;
};
Ea.Collapsed = function({
  children: e
}) {
  const t = _.useContext(um);
  if (!t)
    throw new Error(
      "SmoothExpandComponent.Collapsed must be used within a SmoothExpandComponent"
    );
  return t.isExpanded ? null : /* @__PURE__ */ k.jsx(k.Fragment, { children: e });
};
const cm = _.createContext(void 0), Ii = _.forwardRef((e, t) => {
  const { asChild: n, children: r, className: o, style: a, ...l } = e, u = _.useRef(null);
  _.useImperativeHandle(
    t,
    () => u.current,
    []
  );
  const [d, f] = _.useState(!1), p = _.useCallback(async () => {
    try {
      const g = u.current;
      if (!g) return;
      if (!d)
        g.requestFullscreen ? await g.requestFullscreen() : g.mozRequestFullScreen ? await g.mozRequestFullScreen() : g.webkitRequestFullscreen ? await g.webkitRequestFullscreen() : g.msRequestFullscreen && await g.msRequestFullscreen(), f(!0);
      else {
        const y = document;
        y.exitFullscreen ? await y.exitFullscreen() : y.mozCancelFullScreen ? await y.mozCancelFullScreen() : y.webkitExitFullscreen ? await y.webkitExitFullscreen() : y.msExitFullscreen && await y.msExitFullscreen(), f(!1);
      }
    } catch (g) {
      console.error("Error toggling fullscreen", g);
    }
  }, [d]);
  _.useEffect(() => {
    const g = () => {
      const y = document.fullscreenElement;
      f(!!y);
    };
    return document.addEventListener("fullscreenchange", g), document.addEventListener("webkitfullscreenchange", g), document.addEventListener("mozfullscreenchange", g), document.addEventListener("MSFullscreenChange", g), () => {
      document.removeEventListener("fullscreenchange", g), document.removeEventListener(
        "webkitfullscreenchange",
        g
      ), document.removeEventListener(
        "mozfullscreenchange",
        g
      ), document.removeEventListener(
        "MSFullscreenChange",
        g
      );
    };
  }, []);
  let m;
  if (n && _.isValidElement(r)) {
    const g = r, y = [g.props.className, o].filter(Boolean).join(" "), w = { ...g.props.style, ...a };
    m = _.cloneElement(g, {
      ref: u,
      className: y,
      style: w,
      ...l
    });
  } else
    m = /* @__PURE__ */ k.jsx("div", { ref: u, ...l, className: o, style: a, children: r });
  return /* @__PURE__ */ k.jsx(cm.Provider, { value: { isFullScreen: d, toggleFullscreen: p }, children: m });
});
Ii.Trigger = function({
  children: e
}) {
  const t = _.useContext(cm);
  if (!t)
    throw new Error(
      "FullScreenComponent.Trigger must be used within a FullScreenComponent"
    );
  return /* @__PURE__ */ k.jsx("div", { style: { cursor: "pointer" }, onClick: t.toggleFullscreen, children: e });
};
Ii.InFullScreen = function({
  children: e
}) {
  const t = _.useContext(cm);
  if (!t)
    throw new Error(
      "FullScreenComponent.Expanded must be used within a FullScreenComponent"
    );
  return t.isFullScreen ? /* @__PURE__ */ k.jsx(k.Fragment, { children: e }) : null;
};
Ii.OutFullScreen = function({
  children: e
}) {
  const t = _.useContext(cm);
  if (!t)
    throw new Error(
      "FullScreenComponent.Collapsed must be used within a FullScreenComponent"
    );
  return t.isFullScreen ? null : /* @__PURE__ */ k.jsx(k.Fragment, { children: e });
};
const vue = ({
  fnrf_zst: e,
  header: t,
  flow: n,
  library: r
}) => {
  const [o, a] = _.useState(
    e.options.worker
  ), l = _.useRef(null);
  e.workermanager && (e.workermanager.on_setWorker = a), e.set_worker(o), _.useEffect(() => {
    e.auto_progress();
  }, []), _.useEffect(() => {
    e.local_state.setState({ funcnodescontainerRef: l.current });
  }, [l]);
  const u = e.plugins();
  return /* @__PURE__ */ k.jsx($se, { plugins: u, fnrf_zst: e, children: /* @__PURE__ */ k.jsx(Ge.Provider, { value: e, children: /* @__PURE__ */ k.jsx(Ea, { asChild: !0, children: /* @__PURE__ */ k.jsx(Ii, { asChild: !0, children: /* @__PURE__ */ k.jsx(
    pX,
    {
      style: {
        height: "100%",
        width: "100%",
        display: "flex",
        flexDirection: "column",
        flex: 1
      },
      children: /* @__PURE__ */ k.jsxs(
        "div",
        {
          ref: l,
          className: "funcnodesreactflowcontainer funcnodescontainer",
          children: [
            t.show && /* @__PURE__ */ k.jsx(SX, { ...t }),
            /* @__PURE__ */ k.jsxs("div", { className: "funcnodesreactflowbody", children: [
              /* @__PURE__ */ k.jsx(yue, { ...n }),
              o && r.show && /* @__PURE__ */ k.jsx(nee, {}),
              o && n.showNodeSettings && /* @__PURE__ */ k.jsx(uue, {})
            ] }),
            /* @__PURE__ */ k.jsxs("div", { className: "funcnodesflaotingmenu", children: [
              /* @__PURE__ */ k.jsx(Ii.OutFullScreen, { children: n.allowExpand && /* @__PURE__ */ k.jsxs(Ea.Trigger, { children: [
                /* @__PURE__ */ k.jsx(Ea.Expanded, { children: /* @__PURE__ */ k.jsx(
                  R$,
                  {
                    size: "xl",
                    style: { padding: "4px" }
                  }
                ) }),
                /* @__PURE__ */ k.jsx(Ea.Collapsed, { children: /* @__PURE__ */ k.jsx(
                  j$,
                  {
                    size: "xl",
                    style: { padding: "4px" }
                  }
                ) })
              ] }) }),
              n.allowFullScreen && /* @__PURE__ */ k.jsxs(Ii.Trigger, { children: [
                /* @__PURE__ */ k.jsx(Ii.OutFullScreen, { children: /* @__PURE__ */ k.jsx(cM, { size: "xl", style: { padding: "4px" } }) }),
                /* @__PURE__ */ k.jsx(Ii.InFullScreen, { children: /* @__PURE__ */ k.jsx(
                  A$,
                  {
                    size: "xl",
                    style: { padding: "4px" }
                  }
                ) })
              ] })
            ] })
          ]
        }
      )
    }
  ) }) }) }) });
}, ow = {};
window.fnrf_zst === void 0 && (window.fnrf_zst = ow);
const bue = {
  show: !0
}, wue = {
  show: !0,
  showmenu: !0
}, xue = {
  minimap: !0,
  static: !1,
  minZoom: 0.1,
  maxZoom: 5,
  allowFullScreen: !0,
  allowExpand: !0,
  showNodeSettings: !0
}, zD = {
  id: "",
  // required
  debug: !1,
  useWorkerManager: !0,
  show_library: !0,
  header: wue,
  flow: xue,
  library: bue
}, Ge = _.createContext(
  _4(zD)
), Sue = (e) => {
  let t = nh(e, {
    ...zD,
    id: Z4()
  }).new_obj;
  if (!t.useWorkerManager && t.worker === void 0)
    return /* @__PURE__ */ k.jsx("div", { children: "Error: If you don't use a worker manager, you must provide a default worker." });
  if (e.useWorkerManager && e.workermanager_url === void 0)
    return /* @__PURE__ */ k.jsx("div", { children: "Error: If you use a worker manager, you must provide a worker manager url." });
  let n = ow[t.id];
  n === void 0 && (n = _4(t), ow[t.id] = n), n.options.debug = t.debug;
  const [r, o] = _.useState(t);
  return _.useEffect(() => {
    const a = [];
    if (r.worker === void 0 && r.worker_url !== void 0) {
      r.useWorkerManager = !1;
      const l = new K4({
        url: r.worker_url,
        uuid: r.id,
        on_sync_complete: r.on_sync_complete
      });
      r.worker = l, a.push(() => {
        l.disconnect();
      });
    }
    if (r.fnw_url !== void 0) {
      if (r.worker === void 0)
        throw new Error("defining fnw_url requires a worker to be defined");
      const l = vV(r.fnw_url), u = r.worker.on_sync_complete, d = async (f) => {
        const p = await l;
        f.on_sync_complete = u, await f.update_from_export(p);
      };
      r.worker.on_sync_complete = d;
    }
    if (r.worker !== void 0 && r.worker.set_zustand(n), t.useWorkerManager) {
      const l = new cV(
        t.workermanager_url,
        n
      );
      n.workermanager = l, a.push(() => {
        l.remove();
      });
    }
    return o({ ...r }), r.on_ready && typeof r.on_ready == "function" && r.on_ready({ fnrf_zst: n }), () => {
      for (const l of a)
        l();
    };
  }, []), /* @__PURE__ */ k.jsx(
    vue,
    {
      fnrf_zst: n,
      header: r.header,
      library: r.library,
      flow: r.flow
    }
  );
}, kue = (e) => (new k4("FuncNodes", e.debug ? "debug" : "info").debug("Initalizing FuncNodes with props:", e), /* @__PURE__ */ k.jsx("div", { className: "FuncnodesApp", children: /* @__PURE__ */ k.jsx(Sue, { ...e }) })), an = [];
for (let e = 0; e < 256; ++e)
  an.push((e + 256).toString(16).slice(1));
function _ue(e, t = 0) {
  return (an[e[t + 0]] + an[e[t + 1]] + an[e[t + 2]] + an[e[t + 3]] + "-" + an[e[t + 4]] + an[e[t + 5]] + "-" + an[e[t + 6]] + an[e[t + 7]] + "-" + an[e[t + 8]] + an[e[t + 9]] + "-" + an[e[t + 10]] + an[e[t + 11]] + an[e[t + 12]] + an[e[t + 13]] + an[e[t + 14]] + an[e[t + 15]]).toLowerCase();
}
let Pv;
const Eue = new Uint8Array(16);
function Cue() {
  if (!Pv) {
    if (typeof crypto > "u" || !crypto.getRandomValues)
      throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
    Pv = crypto.getRandomValues.bind(crypto);
  }
  return Pv(Eue);
}
const Oue = typeof crypto < "u" && crypto.randomUUID && crypto.randomUUID.bind(crypto), NO = { randomUUID: Oue };
function Nue(e, t, n) {
  if (NO.randomUUID && !e)
    return NO.randomUUID();
  e = e || {};
  const r = e.random ?? e.rng?.() ?? Cue();
  if (r.length < 16)
    throw new Error("Random bytes length must be >= 16");
  return r[6] = r[6] & 15 | 64, r[8] = r[8] & 63 | 128, _ue(r);
}
const PD = '(function(){"use strict";const d="https://cdn.jsdelivr.net/pyodide/v0.27.2/full/pyodide.mjs",e=self;e.workerState={pyodide:null,pyodide_url:d,packages:[],state:{msg:"loading",loaded:!1,progress:0},micropip:null,worker:{},pyodideReady:!1,pyodideReadyPromise:null,debug:!1,interruptBuffer:null,receivepy:(r,t)=>{},receivepy_bytes:(r,t)=>{},handel_register:{},post_pyodide_ready:void 0},e.reset=async()=>{for(const r in e.list_workers())try{const t=await e.get_worker(r);t.worker&&t.worker.stop(),t.reject_promise?.("Worker reset")}catch{}e.workerState.pyodide&&e.interrupt(),e.workerState.pyodide=null,e.workerState.micropip=null,e.workerState.worker={},e.workerState.pyodideReady=!1;try{e.workerState.interruptBuffer=new Uint8Array(new SharedArrayBuffer(1)),e.workerState.interruptBuffer[0]=0}catch{}},e.initializePyodide=async()=>{if(!e.workerState.pyodide){console.log("initializePyodide with: Debug:",e.workerState.debug,"Pyodide URL:",e.workerState.pyodide_url,"Packages:",e.workerState.packages),console.debug("Loading Pyodide..."),e.workerState.state.msg="Loading Pyodide...",e.workerState.state.progress=0,await e.reset(),console.debug("Loading Pyodide module..."),e.workerState.state.msg="Loading Pyodide module...",e.workerState.state.progress=.1;const r=await import(e.workerState.pyodide_url);console.debug("Loading Pyodide instance..."),e.workerState.state.msg="Loading Pyodide instance...",e.workerState.state.progress=.2;const t=r.loadPyodide,o=e.workerState.pyodide_url.split("/").slice(0,-1).join("/");console.log(o),e.workerState.pyodide=await t({packages:["micropip"],indexURL:o}),e.workerState.interruptBuffer&&e.workerState.pyodide.setInterruptBuffer(e.workerState.interruptBuffer)}e.workerState.micropip||(console.debug("Importing micropip..."),e.workerState.state.msg="Importing micropip...",e.workerState.state.progress=.3,e.workerState.micropip=e.workerState.pyodide.pyimport("micropip")),console.debug("Pyodide ready. Installing funcnodes...");for(const r of e.workerState.packages)console.log("Installing package:",r),e.workerState.state.msg=`Installing package: ${r}`,await e.workerState.micropip.install(r);return e.workerState.state.msg="Installing funcnodes",e.workerState.state.progress=.8,await e.workerState.micropip.install("funcnodes"),e.workerState.state.msg="Installing funcnodes-worker",await e.workerState.micropip.install("funcnodes-worker"),e.workerState.state.msg="Installing funcnodes-pyodide",await e.workerState.micropip.install("funcnodes-pyodide"),e.workerState.state.msg="Installing funcnodes-react-flow",await e.workerState.micropip.install("funcnodes-react-flow"),e.workerState.state.msg="Importing funcnodes",console.debug("Importing funcnodes..."),await e.workerState.pyodide.runPythonAsync("import funcnodes_pyodide"),console.debug("Running post_pyodide_ready..."),await e.workerState.post_pyodide_ready?.(e.workerState),console.debug("Pyodide ready"),e.workerState.state.msg="ready",e.workerState.state.progress=.1,e.workerState.pyodideReady=!0,{pyodide:e.workerState.pyodide,micropip:e.workerState.micropip}},e.interrupt=()=>{e.workerState.interruptBuffer&&(e.workerState.interruptBuffer[0]=1)},e.list_workers=()=>Object.keys(e.workerState.worker),e.get_worker=async r=>{if(!r)throw new Error("Worker id is required");if(!e.workerState.worker[r])throw new Error(`Worker with id ${r} not found`);return await e.workerState.worker[r].make_promise,e.workerState.worker[r]},e.has_worker=r=>{if(!r)throw new Error("Worker id is required");return!!e.workerState.worker[r]},e.get_or_create_worker=async r=>{if(!r)throw new Error("Worker id is required");return e.workerState.worker[r]||(console.log("Creating worker with id",r),await e.initializeFuncNodesWorker(r)),e.get_worker(r)},e.initializeFuncNodesWorker=async r=>{try{if(!e.workerState.pyodideReadyPromise)throw new Error("Pyodide newer initialized");const{pyodide:t}=await e.workerState.pyodideReadyPromise;if(!e.has_worker(r)){e.workerState.worker[r]={worker:null,make_promise:void 0};const o=new Promise(async(i,a)=>{e.workerState.worker[r].reject_promise=a,console.debug(`Creating worker (${r})...`);const s=await t.runPythonAsync(`funcnodes_pyodide.new_worker(debug=${e.workerState.debug?1:0}, uuid="${r}")`);if(console.debug("Worker created:",s),typeof s.set_receiver=="function")s.set_receiver(self);else throw new Error("Worker does not expose a \'set_receiver\' method.");e.workerState.worker[r].worker=s,console.debug("Worker ready"),i(s)});e.workerState.worker[r].make_promise=o}return e.get_worker(r)}catch(t){throw console.error("Error during worker initialization:",t),t}},e.receivepy=(r,t)=>{try{let o={};if(typeof r=="string"?o.msg=r:o=r,o.msg===void 0)return;typeof o.msg!="string"&&(o.msg=JSON.stringify(o.msg)),t!==void 0&&(typeof t=="string"?o.worker_id||(o.worker_id=t):o={...t,...o});const i=o.worker_id;if(!i)throw new Error(`Worker id not provided in receivepy(${JSON.stringify(o)})`);if(!e.workerState.worker[i])throw new Error(`Worker with id ${i} not found in receivepy(${JSON.stringify(o)})`);e.workerState.receivepy(r,i)}catch(o){console.error("Error during receivepy:",o);return}},e.receivepy_bytes=(r,t)=>{r=r.toJs();try{let o={};if(r instanceof Uint8Array?o.msg=r:o=r,o.msg===void 0)return;t!==void 0&&(typeof t=="string"?o.worker_id||(o.worker_id=t):o={...t,...o});const i=o.worker_id;if(!i)throw new Error("Worker id not provided in receivepy_bytes");if(!e.workerState.worker[i])throw new Error(`Worker with id ${i} not found in receivepy_bytes`);e.workerState.receivepy_bytes(r,i)}catch(o){console.error("Error during receivepy_bytes:",o);return}},e.startInitialization=({debug:r=!1,receivepy:t,receivepy_bytes:o,pyodide_url:i,post_pyodide_ready:a,packages:s})=>(e.workerState.debug=r,e.workerState.pyodide_url=i||d,e.workerState.packages=s,e.workerState.receivepy=t,e.workerState.receivepy_bytes=o,e.workerState.pyodideReadyPromise=null,e.workerState.post_pyodide_ready=a,e.workerState),e.register_cmd_message=(r,t)=>{if(e.workerState.handel_register[r])throw new Error(`Command ${r} already registered`);e.workerState.handel_register[r]=t},e.register_cmd_message("ping",async r=>"pong"),e.register_cmd_message("init",async r=>{if(e.workerState.pyodideReadyPromise)throw new Error("Pyodide is already initialized");r.data&&(r.data.pyodide_url&&(e.workerState.pyodide_url=r.data.pyodide_url),r.data.packages&&(e.workerState.packages=r.data.packages),r.data.debug&&(e.workerState.debug=r.data.debug)),e.workerState.pyodideReadyPromise=e.initializePyodide()}),e.register_cmd_message("_eval",async r=>{try{const t=await e.workerState.pyodide?.runPythonAsync(r.msg||"print(\'No code provided\')");return console.log("Eval result:",t),t}catch(t){console.error("Error during _eval:",t)}}),e.register_cmd_message("state",async r=>({state:{...e.workerState.state,loaded:e.workerState.pyodideReady}})),e.register_cmd_message("worker:state",async r=>({state:{loaded:!!(await e.get_or_create_worker(r.worker_id)).worker}})),e.register_cmd_message("worker:stop",async r=>{if(!e.has_worker(r.worker_id))return;const t=await e.get_or_create_worker(r.worker_id);return t.worker&&(t.worker.stop(),t.worker=null,t.reject_promise?.("Worker stopped")),delete e.workerState.worker[r.worker_id],{state:{loaded:!1}}}),e.register_cmd_message("worker:send",async r=>{const t=await e.get_or_create_worker(r.worker_id);if(!t.worker)throw new Error("Worker is not initialized");if(typeof t.worker.receivejs!="function")throw new Error(`Worker does not support receivejs: ${typeof t.worker.receivejs}`);t.worker.receivejs(r.msg)}),e.handleMessage=async r=>{const t={original:r};r.id&&(t.id=r.id),r.toJs===void 0&&(r.toJs=!0);try{if(r.cmd){const o=r;if(e.workerState.handel_register[o.cmd])t.result=await e.workerState.handel_register[o.cmd](o);else throw new Error("Unknown command: "+o.cmd)}else throw new Error("Unknown message format: "+JSON.stringify(r))}catch(o){t.error=o.message}return t},e.read_url_params=()=>{const r=new URLSearchParams(self.location.search),t=r.get("debug")?.toLowerCase()==="true",o=r.get("pyodide_url")||void 0,i=r.get("packages")?.split(",")||[];return{debug:t,pyodide_url:o,packages:i}};const n=e;n.general_initalization=r=>{const t=n.read_url_params();n.startInitialization({...r,...t})};const w=n,c=n;c.init_dedicated_worker=r=>{const t=e;t.onmessage=async i=>{const a=i.data,s=await t.handleMessage(a);t.postMessage(s)};const o={...r,receivepy:(i,a)=>{t.postMessage({cmd:"receive",msg:i,worker_id:a})},receivepy_bytes(i,a){t.postMessage({cmd:"receive_bytes",msg:i,worker_id:a})}};t.general_initalization(o)},w.init_shared_worker=r=>{const t=e;t.connectedPorts=[],t.onconnect=i=>{const a=i.ports[0];t.connectedPorts.push(a),a.start(),console.debug("Port connected in shared worker"),a.onmessage=async s=>{const k=s.data,p=await t.handleMessage(k);a.postMessage(p)}};const o={...r,receivepy:(i,a)=>{t.connectedPorts.forEach(s=>{s.postMessage({cmd:"receive",msg:i,worker_id:a})})},receivepy_bytes(i,a){t.connectedPorts.forEach(s=>{s.postMessage({cmd:"receive_bytes",msg:i,worker_id:a})})}};t.general_initalization(o)},(r=>{n.init_dedicated_worker(r)})({})})();\n', MO = typeof self < "u" && self.Blob && new Blob([PD], { type: "text/javascript;charset=utf-8" });
function Mue(e) {
  let t;
  try {
    if (t = MO && (self.URL || self.webkitURL).createObjectURL(MO), !t) throw "";
    const n = new Worker(t, {
      name: e?.name
    });
    return n.addEventListener("error", () => {
      (self.URL || self.webkitURL).revokeObjectURL(t);
    }), n;
  } catch {
    return new Worker(
      "data:text/javascript;charset=utf-8," + encodeURIComponent(PD),
      {
        name: e?.name
      }
    );
  } finally {
    t && (self.URL || self.webkitURL).revokeObjectURL(t);
  }
}
const Aue = '(function(){"use strict";const d="https://cdn.jsdelivr.net/pyodide/v0.27.2/full/pyodide.mjs",e=self;e.workerState={pyodide:null,pyodide_url:d,packages:[],state:{msg:"loading",loaded:!1,progress:0},micropip:null,worker:{},pyodideReady:!1,pyodideReadyPromise:null,debug:!1,interruptBuffer:null,receivepy:(r,t)=>{},receivepy_bytes:(r,t)=>{},handel_register:{},post_pyodide_ready:void 0},e.reset=async()=>{for(const r in e.list_workers())try{const t=await e.get_worker(r);t.worker&&t.worker.stop(),t.reject_promise?.("Worker reset")}catch{}e.workerState.pyodide&&e.interrupt(),e.workerState.pyodide=null,e.workerState.micropip=null,e.workerState.worker={},e.workerState.pyodideReady=!1;try{e.workerState.interruptBuffer=new Uint8Array(new SharedArrayBuffer(1)),e.workerState.interruptBuffer[0]=0}catch{}},e.initializePyodide=async()=>{if(!e.workerState.pyodide){console.log("initializePyodide with: Debug:",e.workerState.debug,"Pyodide URL:",e.workerState.pyodide_url,"Packages:",e.workerState.packages),console.debug("Loading Pyodide..."),e.workerState.state.msg="Loading Pyodide...",e.workerState.state.progress=0,await e.reset(),console.debug("Loading Pyodide module..."),e.workerState.state.msg="Loading Pyodide module...",e.workerState.state.progress=.1;const r=await import(e.workerState.pyodide_url);console.debug("Loading Pyodide instance..."),e.workerState.state.msg="Loading Pyodide instance...",e.workerState.state.progress=.2;const t=r.loadPyodide,o=e.workerState.pyodide_url.split("/").slice(0,-1).join("/");console.log(o),e.workerState.pyodide=await t({packages:["micropip"],indexURL:o}),e.workerState.interruptBuffer&&e.workerState.pyodide.setInterruptBuffer(e.workerState.interruptBuffer)}e.workerState.micropip||(console.debug("Importing micropip..."),e.workerState.state.msg="Importing micropip...",e.workerState.state.progress=.3,e.workerState.micropip=e.workerState.pyodide.pyimport("micropip")),console.debug("Pyodide ready. Installing funcnodes...");for(const r of e.workerState.packages)console.log("Installing package:",r),e.workerState.state.msg=`Installing package: ${r}`,await e.workerState.micropip.install(r);return e.workerState.state.msg="Installing funcnodes",e.workerState.state.progress=.8,await e.workerState.micropip.install("funcnodes"),e.workerState.state.msg="Installing funcnodes-worker",await e.workerState.micropip.install("funcnodes-worker"),e.workerState.state.msg="Installing funcnodes-pyodide",await e.workerState.micropip.install("funcnodes-pyodide"),e.workerState.state.msg="Installing funcnodes-react-flow",await e.workerState.micropip.install("funcnodes-react-flow"),e.workerState.state.msg="Importing funcnodes",console.debug("Importing funcnodes..."),await e.workerState.pyodide.runPythonAsync("import funcnodes_pyodide"),console.debug("Running post_pyodide_ready..."),await e.workerState.post_pyodide_ready?.(e.workerState),console.debug("Pyodide ready"),e.workerState.state.msg="ready",e.workerState.state.progress=.1,e.workerState.pyodideReady=!0,{pyodide:e.workerState.pyodide,micropip:e.workerState.micropip}},e.interrupt=()=>{e.workerState.interruptBuffer&&(e.workerState.interruptBuffer[0]=1)},e.list_workers=()=>Object.keys(e.workerState.worker),e.get_worker=async r=>{if(!r)throw new Error("Worker id is required");if(!e.workerState.worker[r])throw new Error(`Worker with id ${r} not found`);return await e.workerState.worker[r].make_promise,e.workerState.worker[r]},e.has_worker=r=>{if(!r)throw new Error("Worker id is required");return!!e.workerState.worker[r]},e.get_or_create_worker=async r=>{if(!r)throw new Error("Worker id is required");return e.workerState.worker[r]||(console.log("Creating worker with id",r),await e.initializeFuncNodesWorker(r)),e.get_worker(r)},e.initializeFuncNodesWorker=async r=>{try{if(!e.workerState.pyodideReadyPromise)throw new Error("Pyodide newer initialized");const{pyodide:t}=await e.workerState.pyodideReadyPromise;if(!e.has_worker(r)){e.workerState.worker[r]={worker:null,make_promise:void 0};const o=new Promise(async(i,a)=>{e.workerState.worker[r].reject_promise=a,console.debug(`Creating worker (${r})...`);const s=await t.runPythonAsync(`funcnodes_pyodide.new_worker(debug=${e.workerState.debug?1:0}, uuid="${r}")`);if(console.debug("Worker created:",s),typeof s.set_receiver=="function")s.set_receiver(self);else throw new Error("Worker does not expose a \'set_receiver\' method.");e.workerState.worker[r].worker=s,console.debug("Worker ready"),i(s)});e.workerState.worker[r].make_promise=o}return e.get_worker(r)}catch(t){throw console.error("Error during worker initialization:",t),t}},e.receivepy=(r,t)=>{try{let o={};if(typeof r=="string"?o.msg=r:o=r,o.msg===void 0)return;typeof o.msg!="string"&&(o.msg=JSON.stringify(o.msg)),t!==void 0&&(typeof t=="string"?o.worker_id||(o.worker_id=t):o={...t,...o});const i=o.worker_id;if(!i)throw new Error(`Worker id not provided in receivepy(${JSON.stringify(o)})`);if(!e.workerState.worker[i])throw new Error(`Worker with id ${i} not found in receivepy(${JSON.stringify(o)})`);e.workerState.receivepy(r,i)}catch(o){console.error("Error during receivepy:",o);return}},e.receivepy_bytes=(r,t)=>{r=r.toJs();try{let o={};if(r instanceof Uint8Array?o.msg=r:o=r,o.msg===void 0)return;t!==void 0&&(typeof t=="string"?o.worker_id||(o.worker_id=t):o={...t,...o});const i=o.worker_id;if(!i)throw new Error("Worker id not provided in receivepy_bytes");if(!e.workerState.worker[i])throw new Error(`Worker with id ${i} not found in receivepy_bytes`);e.workerState.receivepy_bytes(r,i)}catch(o){console.error("Error during receivepy_bytes:",o);return}},e.startInitialization=({debug:r=!1,receivepy:t,receivepy_bytes:o,pyodide_url:i,post_pyodide_ready:a,packages:s})=>(e.workerState.debug=r,e.workerState.pyodide_url=i||d,e.workerState.packages=s,e.workerState.receivepy=t,e.workerState.receivepy_bytes=o,e.workerState.pyodideReadyPromise=null,e.workerState.post_pyodide_ready=a,e.workerState),e.register_cmd_message=(r,t)=>{if(e.workerState.handel_register[r])throw new Error(`Command ${r} already registered`);e.workerState.handel_register[r]=t},e.register_cmd_message("ping",async r=>"pong"),e.register_cmd_message("init",async r=>{if(e.workerState.pyodideReadyPromise)throw new Error("Pyodide is already initialized");r.data&&(r.data.pyodide_url&&(e.workerState.pyodide_url=r.data.pyodide_url),r.data.packages&&(e.workerState.packages=r.data.packages),r.data.debug&&(e.workerState.debug=r.data.debug)),e.workerState.pyodideReadyPromise=e.initializePyodide()}),e.register_cmd_message("_eval",async r=>{try{const t=await e.workerState.pyodide?.runPythonAsync(r.msg||"print(\'No code provided\')");return console.log("Eval result:",t),t}catch(t){console.error("Error during _eval:",t)}}),e.register_cmd_message("state",async r=>({state:{...e.workerState.state,loaded:e.workerState.pyodideReady}})),e.register_cmd_message("worker:state",async r=>({state:{loaded:!!(await e.get_or_create_worker(r.worker_id)).worker}})),e.register_cmd_message("worker:stop",async r=>{if(!e.has_worker(r.worker_id))return;const t=await e.get_or_create_worker(r.worker_id);return t.worker&&(t.worker.stop(),t.worker=null,t.reject_promise?.("Worker stopped")),delete e.workerState.worker[r.worker_id],{state:{loaded:!1}}}),e.register_cmd_message("worker:send",async r=>{const t=await e.get_or_create_worker(r.worker_id);if(!t.worker)throw new Error("Worker is not initialized");if(typeof t.worker.receivejs!="function")throw new Error(`Worker does not support receivejs: ${typeof t.worker.receivejs}`);t.worker.receivejs(r.msg)}),e.handleMessage=async r=>{const t={original:r};r.id&&(t.id=r.id),r.toJs===void 0&&(r.toJs=!0);try{if(r.cmd){const o=r;if(e.workerState.handel_register[o.cmd])t.result=await e.workerState.handel_register[o.cmd](o);else throw new Error("Unknown command: "+o.cmd)}else throw new Error("Unknown message format: "+JSON.stringify(r))}catch(o){t.error=o.message}return t},e.read_url_params=()=>{const r=new URLSearchParams(self.location.search),t=r.get("debug")?.toLowerCase()==="true",o=r.get("pyodide_url")||void 0,i=r.get("packages")?.split(",")||[];return{debug:t,pyodide_url:o,packages:i}};const n=e;n.general_initalization=r=>{const t=n.read_url_params();n.startInitialization({...r,...t})};const w=n,c=n;c.init_dedicated_worker=r=>{const t=e;t.onmessage=async i=>{const a=i.data,s=await t.handleMessage(a);t.postMessage(s)};const o={...r,receivepy:(i,a)=>{t.postMessage({cmd:"receive",msg:i,worker_id:a})},receivepy_bytes(i,a){t.postMessage({cmd:"receive_bytes",msg:i,worker_id:a})}};t.general_initalization(o)},w.init_shared_worker=r=>{const t=e;t.connectedPorts=[],t.onconnect=i=>{const a=i.ports[0];t.connectedPorts.push(a),a.start(),console.debug("Port connected in shared worker"),a.onmessage=async s=>{const k=s.data,p=await t.handleMessage(k);a.postMessage(p)}};const o={...r,receivepy:(i,a)=>{t.connectedPorts.forEach(s=>{s.postMessage({cmd:"receive",msg:i,worker_id:a})})},receivepy_bytes(i,a){t.connectedPorts.forEach(s=>{s.postMessage({cmd:"receive_bytes",msg:i,worker_id:a})})}};t.general_initalization(o)},(r=>{n.init_shared_worker(r)})({})})();\n';
function Rue(e) {
  return new SharedWorker(
    "data:text/javascript;charset=utf-8," + encodeURIComponent(Aue),
    {
      name: e?.name
    }
  );
}
const jue = (e) => (e.worker || (e.worker_classes || (e.worker_classes = {
  Shared: Rue,
  Dedicated: Mue
}), e.shared_worker ? e.worker_url === void 0 ? e.worker = new e.worker_classes.Shared({
  name: e.uuid
}) : e.worker = new SharedWorker(e.worker_url, {
  name: e.uuid,
  type: "module"
}) : e.worker_url === void 0 ? e.worker = new e.worker_classes.Dedicated({
  name: e.uuid
}) : e.worker = new Worker(e.worker_url, {
  name: e.uuid,
  type: "module"
})), e.worker);
class LD extends W4 {
  constructor(t) {
    const n = {
      uuid: Nue(),
      ...t
    };
    if (super(n), this._message_hooks = [], this._worker = jue(n), this._worker instanceof SharedWorker)
      n.shared_worker = !0, this._port = this._worker.port, this._port.start(), this._port.addEventListener("message", this.onmessage.bind(this));
    else if (this._worker instanceof Worker)
      n.shared_worker = !1, this._worker.addEventListener("message", this.onmessage.bind(this));
    else
      throw new Error("worker must be an instance of Worker or SharedWorker");
    this.postMessage({
      cmd: "init",
      data: {
        debug: n.debug,
        pyodide_url: n.pyodide_url,
        packages: n.packages
      }
    });
    const r = setInterval(() => {
      this.postMessage({ cmd: "state" });
    }, 400);
    this._workerstate = { loaded: !1, msg: "loading", progress: 0 }, this.initPromise = new Promise(async (o) => {
      for (; !this._workerstate.loaded; )
        await new Promise((a) => setTimeout(a, 100));
      clearInterval(r), this.is_open = !0, this._zustand?.auto_progress(), o();
    }), this.initPromise.then(() => {
      this.stepwise_fullsync();
    });
  }
  async send(t) {
    await this.initPromise, this.postMessage({
      cmd: "worker:send",
      msg: JSON.stringify(t),
      worker_id: this.uuid
    });
  }
  postMessage(t) {
    t.worker_id = this.uuid, this._port ? this._port.postMessage(t) : this._worker.postMessage(t);
  }
  registerMessageHook(t) {
    return this._message_hooks.push(t), () => {
      this._message_hooks = this._message_hooks.filter((n) => n !== t);
    };
  }
  onmessage(t) {
    for (const n of this._message_hooks)
      n(t.data);
    if (t.data.result)
      t.data.result.state && (this._workerstate = {
        ...this._workerstate,
        ...t.data.result.state
      }, t.data.result.state.msg && t.data.result.state.msg !== "ready" && this._zustand?.set_progress({
        message: this._workerstate.msg,
        status: "info",
        progress: this._workerstate.progress,
        blocking: !0
      }));
    else if (t.data.cmd) {
      if (t.data.cmd === "receive") {
        if (t.data.worker_id === void 0)
          throw new Error("worker_id is undefined");
        t.data.worker_id === this.uuid && this.receive(JSON.parse(t.data.msg));
      } else if (t.data.cmd === "receive_bytes") {
        if (t.data.worker_id === void 0)
          throw new Error("worker_id is undefined");
        t.data.worker_id === this.uuid && this.onbytes(t.data.msg);
      }
    }
  }
  async upload_file({
    files: t,
    onProgressCallback: n,
    root: r
  }) {
    const o = [], a = t.length;
    let l = 0;
    if (t.length === 0)
      return "";
    for (let f = 0; f < t.length; f++) {
      const p = t[f], m = new FileReader(), g = new Promise((y, w) => {
        m.onload = async (v) => {
          try {
            const x = v.target.result?.replace(/^data:.+;base64,/, ""), E = p.webkitRelativePath || p.name, N = r ? `${r}/${E}` : E, C = await this._send_cmd({
              cmd: "upload",
              kwargs: { data: x, filename: N },
              wait_for_response: !0
            });
            l++, n && n(l, a), y(C);
          } catch (x) {
            w(x);
          }
        }, m.readAsDataURL(p);
      });
      o.push(g);
    }
    const u = await Promise.all(o);
    return u.reduce((f, p) => {
      const m = p.split("/"), g = f.split("/"), y = [];
      for (let w = 0; w < m.length && m[w] === g[w]; w++)
        y.push(m[w]);
      return y.join("/");
    }, u[0]);
  }
  get ready() {
    return this._workerstate.loaded;
  }
}
const Due = (e, t) => {
  t === void 0 && (t = {});
  const { element: n, eleid: r } = typeof e == "string" ? {
    element: document.getElementById(e),
    eleid: e
  } : { element: e, eleid: e.id }, o = /* @__PURE__ */ Y6.jsx(kue, { ...t, id: t.id || r }), a = Q6.createRoot(n);
  return a.render(o), {
    root: a,
    content: o
  };
}, Tue = (e, t) => {
  if (t.shared_worker ? t.shared_worker = !0 : t.shared_worker = !1, !t.uuid) {
    const r = typeof e == "string" ? e : e.id;
    r !== void 0 && (t.uuid = r);
  }
  const n = new LD(t);
  window.FuncNodes(e, {
    useWorkerManager: !1,
    worker: n
  });
};
window.FuncNodes = Due;
window.FuncNodes.FuncnodesPyodideWorker = LD;
window.FuncNodes.FuncnodesPyodide = Tue;
