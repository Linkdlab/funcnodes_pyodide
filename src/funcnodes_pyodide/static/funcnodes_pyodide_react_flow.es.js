var XK = Object.defineProperty;
var YK = (e, t, n) => t in e ? XK(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : e[t] = n;
var JK = (e, t) => () => (t || e((t = { exports: {} }).exports, t), t.exports);
var Gn = (e, t, n) => YK(e, typeof t != "symbol" ? t + "" : t, n);
var Fze = JK((so, lo) => {
  var pp = window;
  function QK(e, t) {
    for (var n = 0; n < t.length; n++) {
      const r = t[n];
      if (typeof r != "string" && !Array.isArray(r)) {
        for (const o in r)
          if (o !== "default" && !(o in e)) {
            const a = Object.getOwnPropertyDescriptor(r, o);
            a && Object.defineProperty(e, o, a.get ? a : {
              enumerable: !0,
              get: () => r[o]
            });
          }
      }
    }
    return Object.freeze(Object.defineProperty(e, Symbol.toStringTag, { value: "Module" }));
  }
  (function() {
    const t = document.createElement("link").relList;
    if (t && t.supports && t.supports("modulepreload")) return;
    for (const o of document.querySelectorAll('link[rel="modulepreload"]')) r(o);
    new MutationObserver((o) => {
      for (const a of o)
        if (a.type === "childList")
          for (const i of a.addedNodes) i.tagName === "LINK" && i.rel === "modulepreload" && r(i);
    }).observe(document, {
      childList: !0,
      subtree: !0
    });
    function n(o) {
      const a = {};
      return o.integrity && (a.integrity = o.integrity), o.referrerPolicy && (a.referrerPolicy = o.referrerPolicy), o.crossOrigin === "use-credentials" ? a.credentials = "include" : o.crossOrigin === "anonymous" ? a.credentials = "omit" : a.credentials = "same-origin", a;
    }
    function r(o) {
      if (o.ep) return;
      o.ep = !0;
      const a = n(o);
      fetch(o.href, a);
    }
  })();
  function XF(e) {
    return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
  }
  var e_ = { exports: {} }, ot = {};
  var n5;
  function ZK() {
    if (n5) return ot;
    n5 = 1;
    var e = /* @__PURE__ */ Symbol.for("react.transitional.element"), t = /* @__PURE__ */ Symbol.for("react.portal"), n = /* @__PURE__ */ Symbol.for("react.fragment"), r = /* @__PURE__ */ Symbol.for("react.strict_mode"), o = /* @__PURE__ */ Symbol.for("react.profiler"), a = /* @__PURE__ */ Symbol.for("react.consumer"), i = /* @__PURE__ */ Symbol.for("react.context"), s = /* @__PURE__ */ Symbol.for("react.forward_ref"), u = /* @__PURE__ */ Symbol.for("react.suspense"), c = /* @__PURE__ */ Symbol.for("react.memo"), f = /* @__PURE__ */ Symbol.for("react.lazy"), p = /* @__PURE__ */ Symbol.for("react.activity"), g = Symbol.iterator;
    function h(L) {
      return L === null || typeof L != "object" ? null : (L = g && L[g] || L["@@iterator"], typeof L == "function" ? L : null);
    }
    var y = {
      isMounted: function() {
        return !1;
      },
      enqueueForceUpdate: function() {
      },
      enqueueReplaceState: function() {
      },
      enqueueSetState: function() {
      }
    }, b = Object.assign, v = {};
    function w(L, K, T) {
      this.props = L, this.context = K, this.refs = v, this.updater = T || y;
    }
    w.prototype.isReactComponent = {}, w.prototype.setState = function(L, K) {
      if (typeof L != "object" && typeof L != "function" && L != null)
        throw Error(
          "takes an object of state variables to update or a function which returns an object of state variables."
        );
      this.updater.enqueueSetState(this, L, K, "setState");
    }, w.prototype.forceUpdate = function(L) {
      this.updater.enqueueForceUpdate(this, L, "forceUpdate");
    };
    function _() {
    }
    _.prototype = w.prototype;
    function k(L, K, T) {
      this.props = L, this.context = K, this.refs = v, this.updater = T || y;
    }
    var E = k.prototype = new _();
    E.constructor = k, b(E, w.prototype), E.isPureReactComponent = !0;
    var P = Array.isArray;
    function O() {
    }
    var M = { H: null, A: null, T: null, S: null }, I = Object.prototype.hasOwnProperty;
    function A(L, K, T) {
      var V = T.ref;
      return {
        $$typeof: e,
        type: L,
        key: K,
        ref: V !== void 0 ? V : null,
        props: T
      };
    }
    function D(L, K) {
      return A(L.type, K, L.props);
    }
    function F(L) {
      return typeof L == "object" && L !== null && L.$$typeof === e;
    }
    function j(L) {
      var K = { "=": "=0", ":": "=2" };
      return "$" + L.replace(/[=:]/g, function(T) {
        return K[T];
      });
    }
    var U = /\/+/g;
    function $(L, K) {
      return typeof L == "object" && L !== null && L.key != null ? j("" + L.key) : K.toString(36);
    }
    function q(L) {
      switch (L.status) {
        case "fulfilled":
          return L.value;
        case "rejected":
          throw L.reason;
        default:
          switch (typeof L.status == "string" ? L.then(O, O) : (L.status = "pending", L.then(
            function(K) {
              L.status === "pending" && (L.status = "fulfilled", L.value = K);
            },
            function(K) {
              L.status === "pending" && (L.status = "rejected", L.reason = K);
            }
          )), L.status) {
            case "fulfilled":
              return L.value;
            case "rejected":
              throw L.reason;
          }
      }
      throw L;
    }
    function B(L, K, T, V, X) {
      var Q = typeof L;
      (Q === "undefined" || Q === "boolean") && (L = null);
      var ne = !1;
      if (L === null) ne = !0;
      else
        switch (Q) {
          case "bigint":
          case "string":
          case "number":
            ne = !0;
            break;
          case "object":
            switch (L.$$typeof) {
              case e:
              case t:
                ne = !0;
                break;
              case f:
                return ne = L._init, B(
                  ne(L._payload),
                  K,
                  T,
                  V,
                  X
                );
            }
        }
      if (ne)
        return X = X(L), ne = V === "" ? "." + $(L, 0) : V, P(X) ? (T = "", ne != null && (T = ne.replace(U, "$&/") + "/"), B(X, K, T, "", function(ce) {
          return ce;
        })) : X != null && (F(X) && (X = D(
          X,
          T + (X.key == null || L && L.key === X.key ? "" : ("" + X.key).replace(
            U,
            "$&/"
          ) + "/") + ne
        )), K.push(X)), 1;
      ne = 0;
      var te = V === "" ? "." : V + ":";
      if (P(L))
        for (var ae = 0; ae < L.length; ae++)
          V = L[ae], Q = te + $(V, ae), ne += B(
            V,
            K,
            T,
            Q,
            X
          );
      else if (ae = h(L), typeof ae == "function")
        for (L = ae.call(L), ae = 0; !(V = L.next()).done; )
          V = V.value, Q = te + $(V, ae++), ne += B(
            V,
            K,
            T,
            Q,
            X
          );
      else if (Q === "object") {
        if (typeof L.then == "function")
          return B(
            q(L),
            K,
            T,
            V,
            X
          );
        throw K = String(L), Error(
          "Objects are not valid as a React child (found: " + (K === "[object Object]" ? "object with keys {" + Object.keys(L).join(", ") + "}" : K) + "). If you meant to render a collection of children, use an array instead."
        );
      }
      return ne;
    }
    function G(L, K, T) {
      if (L == null) return L;
      var V = [], X = 0;
      return B(L, V, "", "", function(Q) {
        return K.call(T, Q, X++);
      }), V;
    }
    function W(L) {
      if (L._status === -1) {
        var K = L._result;
        K = K(), K.then(
          function(T) {
            (L._status === 0 || L._status === -1) && (L._status = 1, L._result = T);
          },
          function(T) {
            (L._status === 0 || L._status === -1) && (L._status = 2, L._result = T);
          }
        ), L._status === -1 && (L._status = 0, L._result = K);
      }
      if (L._status === 1) return L._result.default;
      throw L._result;
    }
    var Y = typeof reportError == "function" ? reportError : function(L) {
      if (typeof window == "object" && typeof window.ErrorEvent == "function") {
        var K = new window.ErrorEvent("error", {
          bubbles: !0,
          cancelable: !0,
          message: typeof L == "object" && L !== null && typeof L.message == "string" ? String(L.message) : String(L),
          error: L
        });
        if (!window.dispatchEvent(K)) return;
      } else if (typeof process == "object" && typeof process.emit == "function") {
        process.emit("uncaughtException", L);
        return;
      }
      console.error(L);
    }, z = {
      map: G,
      forEach: function(L, K, T) {
        G(
          L,
          function() {
            K.apply(this, arguments);
          },
          T
        );
      },
      count: function(L) {
        var K = 0;
        return G(L, function() {
          K++;
        }), K;
      },
      toArray: function(L) {
        return G(L, function(K) {
          return K;
        }) || [];
      },
      only: function(L) {
        if (!F(L))
          throw Error(
            "React.Children.only expected to receive a single React element child."
          );
        return L;
      }
    };
    return ot.Activity = p, ot.Children = z, ot.Component = w, ot.Fragment = n, ot.Profiler = o, ot.PureComponent = k, ot.StrictMode = r, ot.Suspense = u, ot.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = M, ot.__COMPILER_RUNTIME = {
      __proto__: null,
      c: function(L) {
        return M.H.useMemoCache(L);
      }
    }, ot.cache = function(L) {
      return function() {
        return L.apply(null, arguments);
      };
    }, ot.cacheSignal = function() {
      return null;
    }, ot.cloneElement = function(L, K, T) {
      if (L == null)
        throw Error(
          "The argument must be a React element, but you passed " + L + "."
        );
      var V = b({}, L.props), X = L.key;
      if (K != null)
        for (Q in K.key !== void 0 && (X = "" + K.key), K)
          !I.call(K, Q) || Q === "key" || Q === "__self" || Q === "__source" || Q === "ref" && K.ref === void 0 || (V[Q] = K[Q]);
      var Q = arguments.length - 2;
      if (Q === 1) V.children = T;
      else if (1 < Q) {
        for (var ne = Array(Q), te = 0; te < Q; te++)
          ne[te] = arguments[te + 2];
        V.children = ne;
      }
      return A(L.type, X, V);
    }, ot.createContext = function(L) {
      return L = {
        $$typeof: i,
        _currentValue: L,
        _currentValue2: L,
        _threadCount: 0,
        Provider: null,
        Consumer: null
      }, L.Provider = L, L.Consumer = {
        $$typeof: a,
        _context: L
      }, L;
    }, ot.createElement = function(L, K, T) {
      var V, X = {}, Q = null;
      if (K != null)
        for (V in K.key !== void 0 && (Q = "" + K.key), K)
          I.call(K, V) && V !== "key" && V !== "__self" && V !== "__source" && (X[V] = K[V]);
      var ne = arguments.length - 2;
      if (ne === 1) X.children = T;
      else if (1 < ne) {
        for (var te = Array(ne), ae = 0; ae < ne; ae++)
          te[ae] = arguments[ae + 2];
        X.children = te;
      }
      if (L && L.defaultProps)
        for (V in ne = L.defaultProps, ne)
          X[V] === void 0 && (X[V] = ne[V]);
      return A(L, Q, X);
    }, ot.createRef = function() {
      return { current: null };
    }, ot.forwardRef = function(L) {
      return { $$typeof: s, render: L };
    }, ot.isValidElement = F, ot.lazy = function(L) {
      return {
        $$typeof: f,
        _payload: { _status: -1, _result: L },
        _init: W
      };
    }, ot.memo = function(L, K) {
      return {
        $$typeof: c,
        type: L,
        compare: K === void 0 ? null : K
      };
    }, ot.startTransition = function(L) {
      var K = M.T, T = {};
      M.T = T;
      try {
        var V = L(), X = M.S;
        X !== null && X(T, V), typeof V == "object" && V !== null && typeof V.then == "function" && V.then(O, Y);
      } catch (Q) {
        Y(Q);
      } finally {
        K !== null && T.types !== null && (K.types = T.types), M.T = K;
      }
    }, ot.unstable_useCacheRefresh = function() {
      return M.H.useCacheRefresh();
    }, ot.use = function(L) {
      return M.H.use(L);
    }, ot.useActionState = function(L, K, T) {
      return M.H.useActionState(L, K, T);
    }, ot.useCallback = function(L, K) {
      return M.H.useCallback(L, K);
    }, ot.useContext = function(L) {
      return M.H.useContext(L);
    }, ot.useDebugValue = function() {
    }, ot.useDeferredValue = function(L, K) {
      return M.H.useDeferredValue(L, K);
    }, ot.useEffect = function(L, K) {
      return M.H.useEffect(L, K);
    }, ot.useEffectEvent = function(L) {
      return M.H.useEffectEvent(L);
    }, ot.useId = function() {
      return M.H.useId();
    }, ot.useImperativeHandle = function(L, K, T) {
      return M.H.useImperativeHandle(L, K, T);
    }, ot.useInsertionEffect = function(L, K) {
      return M.H.useInsertionEffect(L, K);
    }, ot.useLayoutEffect = function(L, K) {
      return M.H.useLayoutEffect(L, K);
    }, ot.useMemo = function(L, K) {
      return M.H.useMemo(L, K);
    }, ot.useOptimistic = function(L, K) {
      return M.H.useOptimistic(L, K);
    }, ot.useReducer = function(L, K, T) {
      return M.H.useReducer(L, K, T);
    }, ot.useRef = function(L) {
      return M.H.useRef(L);
    }, ot.useState = function(L) {
      return M.H.useState(L);
    }, ot.useSyncExternalStore = function(L, K, T) {
      return M.H.useSyncExternalStore(
        L,
        K,
        T
      );
    }, ot.useTransition = function() {
      return M.H.useTransition();
    }, ot.version = "19.2.3", ot;
  }
  var r5;
  function YF() {
    return r5 || (r5 = 1, e_.exports = ZK()), e_.exports;
  }
  var C = YF();
  const gn = /* @__PURE__ */ XF(C), Rm = /* @__PURE__ */ QK({
    __proto__: null,
    default: gn
  }, [C]);
  var t_ = { exports: {} }, mr = {};
  var o5;
  function eG() {
    if (o5) return mr;
    o5 = 1;
    var e = YF();
    function t(u) {
      var c = "https://react.dev/errors/" + u;
      if (1 < arguments.length) {
        c += "?args[]=" + encodeURIComponent(arguments[1]);
        for (var f = 2; f < arguments.length; f++)
          c += "&args[]=" + encodeURIComponent(arguments[f]);
      }
      return "Minified React error #" + u + "; visit " + c + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
    }
    function n() {
    }
    var r = {
      d: {
        f: n,
        r: function() {
          throw Error(t(522));
        },
        D: n,
        C: n,
        L: n,
        m: n,
        X: n,
        S: n,
        M: n
      },
      p: 0,
      findDOMNode: null
    }, o = /* @__PURE__ */ Symbol.for("react.portal");
    function a(u, c, f) {
      var p = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null;
      return {
        $$typeof: o,
        key: p == null ? null : "" + p,
        children: u,
        containerInfo: c,
        implementation: f
      };
    }
    var i = e.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE;
    function s(u, c) {
      if (u === "font") return "";
      if (typeof c == "string")
        return c === "use-credentials" ? c : "";
    }
    return mr.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = r, mr.createPortal = function(u, c) {
      var f = 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : null;
      if (!c || c.nodeType !== 1 && c.nodeType !== 9 && c.nodeType !== 11)
        throw Error(t(299));
      return a(u, c, null, f);
    }, mr.flushSync = function(u) {
      var c = i.T, f = r.p;
      try {
        if (i.T = null, r.p = 2, u) return u();
      } finally {
        i.T = c, r.p = f, r.d.f();
      }
    }, mr.preconnect = function(u, c) {
      typeof u == "string" && (c ? (c = c.crossOrigin, c = typeof c == "string" ? c === "use-credentials" ? c : "" : void 0) : c = null, r.d.C(u, c));
    }, mr.prefetchDNS = function(u) {
      typeof u == "string" && r.d.D(u);
    }, mr.preinit = function(u, c) {
      if (typeof u == "string" && c && typeof c.as == "string") {
        var f = c.as, p = s(f, c.crossOrigin), g = typeof c.integrity == "string" ? c.integrity : void 0, h = typeof c.fetchPriority == "string" ? c.fetchPriority : void 0;
        f === "style" ? r.d.S(
          u,
          typeof c.precedence == "string" ? c.precedence : void 0,
          {
            crossOrigin: p,
            integrity: g,
            fetchPriority: h
          }
        ) : f === "script" && r.d.X(u, {
          crossOrigin: p,
          integrity: g,
          fetchPriority: h,
          nonce: typeof c.nonce == "string" ? c.nonce : void 0
        });
      }
    }, mr.preinitModule = function(u, c) {
      if (typeof u == "string")
        if (typeof c == "object" && c !== null) {
          if (c.as == null || c.as === "script") {
            var f = s(
              c.as,
              c.crossOrigin
            );
            r.d.M(u, {
              crossOrigin: f,
              integrity: typeof c.integrity == "string" ? c.integrity : void 0,
              nonce: typeof c.nonce == "string" ? c.nonce : void 0
            });
          }
        } else c == null && r.d.M(u);
    }, mr.preload = function(u, c) {
      if (typeof u == "string" && typeof c == "object" && c !== null && typeof c.as == "string") {
        var f = c.as, p = s(f, c.crossOrigin);
        r.d.L(u, f, {
          crossOrigin: p,
          integrity: typeof c.integrity == "string" ? c.integrity : void 0,
          nonce: typeof c.nonce == "string" ? c.nonce : void 0,
          type: typeof c.type == "string" ? c.type : void 0,
          fetchPriority: typeof c.fetchPriority == "string" ? c.fetchPriority : void 0,
          referrerPolicy: typeof c.referrerPolicy == "string" ? c.referrerPolicy : void 0,
          imageSrcSet: typeof c.imageSrcSet == "string" ? c.imageSrcSet : void 0,
          imageSizes: typeof c.imageSizes == "string" ? c.imageSizes : void 0,
          media: typeof c.media == "string" ? c.media : void 0
        });
      }
    }, mr.preloadModule = function(u, c) {
      if (typeof u == "string")
        if (c) {
          var f = s(c.as, c.crossOrigin);
          r.d.m(u, {
            as: typeof c.as == "string" && c.as !== "script" ? c.as : void 0,
            crossOrigin: f,
            integrity: typeof c.integrity == "string" ? c.integrity : void 0
          });
        } else r.d.m(u);
    }, mr.requestFormReset = function(u) {
      r.d.r(u);
    }, mr.unstable_batchedUpdates = function(u, c) {
      return u(c);
    }, mr.useFormState = function(u, c, f) {
      return i.H.useFormState(u, c, f);
    }, mr.useFormStatus = function() {
      return i.H.useHostTransitionStatus();
    }, mr.version = "19.2.3", mr;
  }
  var a5;
  function tG() {
    if (a5) return t_.exports;
    a5 = 1;
    function e() {
      if (!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != "function"))
        try {
          __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(e);
        } catch (t) {
          console.error(t);
        }
    }
    return e(), t_.exports = eG(), t_.exports;
  }
  var xu = tG();
  const Hc = /* @__PURE__ */ XF(xu), nG = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    get ArrayBufferDataStructure() {
      return v8;
    },
    get CTypeStructure() {
      return y8;
    },
    get DataPreviewViewRendererToHandlePreviewRenderer() {
      return D7;
    },
    get DataStructure() {
      return Ia;
    },
    get DataViewRendererToDataPreviewViewRenderer() {
      return zr;
    },
    get DataViewRendererToInputRenderer() {
      return L7;
    },
    get DataViewRendererToOverlayRenderer() {
      return ox;
    },
    get FuncNodes() {
      return BW;
    },
    get FuncNodesRenderer() {
      return Vx;
    },
    get FuncNodesWorker() {
      return oP;
    },
    get JSONStructure() {
      return Gs;
    },
    get LATEST_VERSION() {
      return zW;
    },
    get TextStructure() {
      return b8;
    },
    get deep_merge() {
      return tl;
    },
    get deep_update() {
      return WE;
    },
    get object_factory_maker() {
      return Yb;
    },
    get useFuncNodesContext() {
      return Vt;
    },
    get useIOGetFullValue() {
      return ih;
    },
    get useIOStore() {
      return Sn;
    },
    get useIOValueStore() {
      return Ybe;
    },
    get useNodeStore() {
      return go;
    },
    get useSetIOValue() {
      return _u;
    },
    get useSetIOValueOptions() {
      return Xbe;
    },
    get useWorkerApi() {
      return Nr;
    }
  }, Symbol.toStringTag, { value: "Module" }));
  function Qi(e) {
    return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
  }
  var i5 = { exports: {} }, Hf = {}, s5;
  function rG() {
    if (s5) return Hf;
    s5 = 1;
    var e = /* @__PURE__ */ Symbol.for("react.transitional.element"), t = /* @__PURE__ */ Symbol.for("react.fragment");
    function n(r, o, a) {
      var i = null;
      if (a !== void 0 && (i = "" + a), o.key !== void 0 && (i = "" + o.key), "key" in o) {
        a = {};
        for (var s in o)
          s !== "key" && (a[s] = o[s]);
      } else a = o;
      return o = a.ref, {
        $$typeof: e,
        type: r,
        key: i,
        ref: o !== void 0 ? o : null,
        props: a
      };
    }
    return Hf.Fragment = t, Hf.jsx = n, Hf.jsxs = n, Hf;
  }
  var l5;
  function oG() {
    return l5 || (l5 = 1, i5.exports = rG()), i5.exports;
  }
  var S = oG(), n_ = { exports: {} }, Wf = {}, u5 = { exports: {} }, c5 = {}, d5;
  function aG() {
    return d5 || (d5 = 1, (function(e) {
      function t(B, G) {
        var W = B.length;
        B.push(G);
        e: for (; 0 < W; ) {
          var Y = W - 1 >>> 1, z = B[Y];
          if (0 < o(z, G))
            B[Y] = G, B[W] = z, W = Y;
          else break e;
        }
      }
      function n(B) {
        return B.length === 0 ? null : B[0];
      }
      function r(B) {
        if (B.length === 0) return null;
        var G = B[0], W = B.pop();
        if (W !== G) {
          B[0] = W;
          e: for (var Y = 0, z = B.length, L = z >>> 1; Y < L; ) {
            var K = 2 * (Y + 1) - 1, T = B[K], V = K + 1, X = B[V];
            if (0 > o(T, W))
              V < z && 0 > o(X, T) ? (B[Y] = X, B[V] = W, Y = V) : (B[Y] = T, B[K] = W, Y = K);
            else if (V < z && 0 > o(X, W))
              B[Y] = X, B[V] = W, Y = V;
            else break e;
          }
        }
        return G;
      }
      function o(B, G) {
        var W = B.sortIndex - G.sortIndex;
        return W !== 0 ? W : B.id - G.id;
      }
      if (e.unstable_now = void 0, typeof performance == "object" && typeof performance.now == "function") {
        var a = performance;
        e.unstable_now = function() {
          return a.now();
        };
      } else {
        var i = Date, s = i.now();
        e.unstable_now = function() {
          return i.now() - s;
        };
      }
      var u = [], c = [], f = 1, p = null, g = 3, h = !1, y = !1, b = !1, v = !1, w = typeof setTimeout == "function" ? setTimeout : null, _ = typeof clearTimeout == "function" ? clearTimeout : null, k = typeof setImmediate < "u" ? setImmediate : null;
      function E(B) {
        for (var G = n(c); G !== null; ) {
          if (G.callback === null) r(c);
          else if (G.startTime <= B)
            r(c), G.sortIndex = G.expirationTime, t(u, G);
          else break;
          G = n(c);
        }
      }
      function P(B) {
        if (b = !1, E(B), !y)
          if (n(u) !== null)
            y = !0, O || (O = !0, j());
          else {
            var G = n(c);
            G !== null && q(P, G.startTime - B);
          }
      }
      var O = !1, M = -1, I = 5, A = -1;
      function D() {
        return v ? !0 : !(e.unstable_now() - A < I);
      }
      function F() {
        if (v = !1, O) {
          var B = e.unstable_now();
          A = B;
          var G = !0;
          try {
            e: {
              y = !1, b && (b = !1, _(M), M = -1), h = !0;
              var W = g;
              try {
                t: {
                  for (E(B), p = n(u); p !== null && !(p.expirationTime > B && D()); ) {
                    var Y = p.callback;
                    if (typeof Y == "function") {
                      p.callback = null, g = p.priorityLevel;
                      var z = Y(
                        p.expirationTime <= B
                      );
                      if (B = e.unstable_now(), typeof z == "function") {
                        p.callback = z, E(B), G = !0;
                        break t;
                      }
                      p === n(u) && r(u), E(B);
                    } else r(u);
                    p = n(u);
                  }
                  if (p !== null) G = !0;
                  else {
                    var L = n(c);
                    L !== null && q(
                      P,
                      L.startTime - B
                    ), G = !1;
                  }
                }
                break e;
              } finally {
                p = null, g = W, h = !1;
              }
              G = void 0;
            }
          } finally {
            G ? j() : O = !1;
          }
        }
      }
      var j;
      if (typeof k == "function")
        j = function() {
          k(F);
        };
      else if (typeof MessageChannel < "u") {
        var U = new MessageChannel(), $ = U.port2;
        U.port1.onmessage = F, j = function() {
          $.postMessage(null);
        };
      } else
        j = function() {
          w(F, 0);
        };
      function q(B, G) {
        M = w(function() {
          B(e.unstable_now());
        }, G);
      }
      e.unstable_IdlePriority = 5, e.unstable_ImmediatePriority = 1, e.unstable_LowPriority = 4, e.unstable_NormalPriority = 3, e.unstable_Profiling = null, e.unstable_UserBlockingPriority = 2, e.unstable_cancelCallback = function(B) {
        B.callback = null;
      }, e.unstable_forceFrameRate = function(B) {
        0 > B || 125 < B ? console.error(
          "forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"
        ) : I = 0 < B ? Math.floor(1e3 / B) : 5;
      }, e.unstable_getCurrentPriorityLevel = function() {
        return g;
      }, e.unstable_next = function(B) {
        switch (g) {
          case 1:
          case 2:
          case 3:
            var G = 3;
            break;
          default:
            G = g;
        }
        var W = g;
        g = G;
        try {
          return B();
        } finally {
          g = W;
        }
      }, e.unstable_requestPaint = function() {
        v = !0;
      }, e.unstable_runWithPriority = function(B, G) {
        switch (B) {
          case 1:
          case 2:
          case 3:
          case 4:
          case 5:
            break;
          default:
            B = 3;
        }
        var W = g;
        g = B;
        try {
          return G();
        } finally {
          g = W;
        }
      }, e.unstable_scheduleCallback = function(B, G, W) {
        var Y = e.unstable_now();
        switch (typeof W == "object" && W !== null ? (W = W.delay, W = typeof W == "number" && 0 < W ? Y + W : Y) : W = Y, B) {
          case 1:
            var z = -1;
            break;
          case 2:
            z = 250;
            break;
          case 5:
            z = 1073741823;
            break;
          case 4:
            z = 1e4;
            break;
          default:
            z = 5e3;
        }
        return z = W + z, B = {
          id: f++,
          callback: G,
          priorityLevel: B,
          startTime: W,
          expirationTime: z,
          sortIndex: -1
        }, W > Y ? (B.sortIndex = W, t(c, B), n(u) === null && B === n(c) && (b ? (_(M), M = -1) : b = !0, q(P, W - Y))) : (B.sortIndex = z, t(u, B), y || h || (y = !0, O || (O = !0, j()))), B;
      }, e.unstable_shouldYield = D, e.unstable_wrapCallback = function(B) {
        var G = g;
        return function() {
          var W = g;
          g = G;
          try {
            return B.apply(this, arguments);
          } finally {
            g = W;
          }
        };
      };
    })(c5)), c5;
  }
  var f5;
  function iG() {
    return f5 || (f5 = 1, u5.exports = aG()), u5.exports;
  }
  var p5;
  function sG() {
    if (p5) return Wf;
    p5 = 1;
    var e = iG(), t = gn, n = Hc;
    function r(l) {
      var d = "https://react.dev/errors/" + l;
      if (1 < arguments.length) {
        d += "?args[]=" + encodeURIComponent(arguments[1]);
        for (var m = 2; m < arguments.length; m++)
          d += "&args[]=" + encodeURIComponent(arguments[m]);
      }
      return "Minified React error #" + l + "; visit " + d + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
    }
    function o(l) {
      return !(!l || l.nodeType !== 1 && l.nodeType !== 9 && l.nodeType !== 11);
    }
    function a(l) {
      var d = l, m = l;
      if (l.alternate) for (; d.return; ) d = d.return;
      else {
        l = d;
        do
          d = l, (d.flags & 4098) !== 0 && (m = d.return), l = d.return;
        while (l);
      }
      return d.tag === 3 ? m : null;
    }
    function i(l) {
      if (l.tag === 13) {
        var d = l.memoizedState;
        if (d === null && (l = l.alternate, l !== null && (d = l.memoizedState)), d !== null) return d.dehydrated;
      }
      return null;
    }
    function s(l) {
      if (l.tag === 31) {
        var d = l.memoizedState;
        if (d === null && (l = l.alternate, l !== null && (d = l.memoizedState)), d !== null) return d.dehydrated;
      }
      return null;
    }
    function u(l) {
      if (a(l) !== l)
        throw Error(r(188));
    }
    function c(l) {
      var d = l.alternate;
      if (!d) {
        if (d = a(l), d === null) throw Error(r(188));
        return d !== l ? null : l;
      }
      for (var m = l, x = d; ; ) {
        var N = m.return;
        if (N === null) break;
        var R = N.alternate;
        if (R === null) {
          if (x = N.return, x !== null) {
            m = x;
            continue;
          }
          break;
        }
        if (N.child === R.child) {
          for (R = N.child; R; ) {
            if (R === m) return u(N), l;
            if (R === x) return u(N), d;
            R = R.sibling;
          }
          throw Error(r(188));
        }
        if (m.return !== x.return) m = N, x = R;
        else {
          for (var H = !1, J = N.child; J; ) {
            if (J === m) {
              H = !0, m = N, x = R;
              break;
            }
            if (J === x) {
              H = !0, x = N, m = R;
              break;
            }
            J = J.sibling;
          }
          if (!H) {
            for (J = R.child; J; ) {
              if (J === m) {
                H = !0, m = R, x = N;
                break;
              }
              if (J === x) {
                H = !0, x = R, m = N;
                break;
              }
              J = J.sibling;
            }
            if (!H) throw Error(r(189));
          }
        }
        if (m.alternate !== x) throw Error(r(190));
      }
      if (m.tag !== 3) throw Error(r(188));
      return m.stateNode.current === m ? l : d;
    }
    function f(l) {
      var d = l.tag;
      if (d === 5 || d === 26 || d === 27 || d === 6) return l;
      for (l = l.child; l !== null; ) {
        if (d = f(l), d !== null) return d;
        l = l.sibling;
      }
      return null;
    }
    var p = Object.assign, g = /* @__PURE__ */ Symbol.for("react.element"), h = /* @__PURE__ */ Symbol.for("react.transitional.element"), y = /* @__PURE__ */ Symbol.for("react.portal"), b = /* @__PURE__ */ Symbol.for("react.fragment"), v = /* @__PURE__ */ Symbol.for("react.strict_mode"), w = /* @__PURE__ */ Symbol.for("react.profiler"), _ = /* @__PURE__ */ Symbol.for("react.consumer"), k = /* @__PURE__ */ Symbol.for("react.context"), E = /* @__PURE__ */ Symbol.for("react.forward_ref"), P = /* @__PURE__ */ Symbol.for("react.suspense"), O = /* @__PURE__ */ Symbol.for("react.suspense_list"), M = /* @__PURE__ */ Symbol.for("react.memo"), I = /* @__PURE__ */ Symbol.for("react.lazy"), A = /* @__PURE__ */ Symbol.for("react.activity"), D = /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel"), F = Symbol.iterator;
    function j(l) {
      return l === null || typeof l != "object" ? null : (l = F && l[F] || l["@@iterator"], typeof l == "function" ? l : null);
    }
    var U = /* @__PURE__ */ Symbol.for("react.client.reference");
    function $(l) {
      if (l == null) return null;
      if (typeof l == "function")
        return l.$$typeof === U ? null : l.displayName || l.name || null;
      if (typeof l == "string") return l;
      switch (l) {
        case b:
          return "Fragment";
        case w:
          return "Profiler";
        case v:
          return "StrictMode";
        case P:
          return "Suspense";
        case O:
          return "SuspenseList";
        case A:
          return "Activity";
      }
      if (typeof l == "object")
        switch (l.$$typeof) {
          case y:
            return "Portal";
          case k:
            return l.displayName || "Context";
          case _:
            return (l._context.displayName || "Context") + ".Consumer";
          case E:
            var d = l.render;
            return l = l.displayName, l || (l = d.displayName || d.name || "", l = l !== "" ? "ForwardRef(" + l + ")" : "ForwardRef"), l;
          case M:
            return d = l.displayName || null, d !== null ? d : $(l.type) || "Memo";
          case I:
            d = l._payload, l = l._init;
            try {
              return $(l(d));
            } catch {
            }
        }
      return null;
    }
    var q = Array.isArray, B = t.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, G = n.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, W = {
      pending: !1,
      data: null,
      method: null,
      action: null
    }, Y = [], z = -1;
    function L(l) {
      return { current: l };
    }
    function K(l) {
      0 > z || (l.current = Y[z], Y[z] = null, z--);
    }
    function T(l, d) {
      z++, Y[z] = l.current, l.current = d;
    }
    var V = L(null), X = L(null), Q = L(null), ne = L(null);
    function te(l, d) {
      switch (T(Q, d), T(X, l), T(V, null), d.nodeType) {
        case 9:
        case 11:
          l = (l = d.documentElement) && (l = l.namespaceURI) ? Ej(l) : 0;
          break;
        default:
          if (l = d.tagName, d = d.namespaceURI)
            d = Ej(d), l = Cj(d, l);
          else
            switch (l) {
              case "svg":
                l = 1;
                break;
              case "math":
                l = 2;
                break;
              default:
                l = 0;
            }
      }
      K(V), T(V, l);
    }
    function ae() {
      K(V), K(X), K(Q);
    }
    function ce(l) {
      l.memoizedState !== null && T(ne, l);
      var d = V.current, m = Cj(d, l.type);
      d !== m && (T(X, l), T(V, m));
    }
    function Z(l) {
      X.current === l && (K(V), K(X)), ne.current === l && (K(ne), zf._currentValue = W);
    }
    var ee, oe;
    function le(l) {
      if (ee === void 0)
        try {
          throw Error();
        } catch (m) {
          var d = m.stack.trim().match(/\n( *(at )?)/);
          ee = d && d[1] || "", oe = -1 < m.stack.indexOf(`
    at`) ? " (<anonymous>)" : -1 < m.stack.indexOf("@") ? "@unknown:0:0" : "";
        }
      return `
` + ee + l + oe;
    }
    var be = !1;
    function ke(l, d) {
      if (!l || be) return "";
      be = !0;
      var m = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      try {
        var x = {
          DetermineComponentFrameRoot: function() {
            try {
              if (d) {
                var xe = function() {
                  throw Error();
                };
                if (Object.defineProperty(xe.prototype, "props", {
                  set: function() {
                    throw Error();
                  }
                }), typeof Reflect == "object" && Reflect.construct) {
                  try {
                    Reflect.construct(xe, []);
                  } catch (ge) {
                    var pe = ge;
                  }
                  Reflect.construct(l, [], xe);
                } else {
                  try {
                    xe.call();
                  } catch (ge) {
                    pe = ge;
                  }
                  l.call(xe.prototype);
                }
              } else {
                try {
                  throw Error();
                } catch (ge) {
                  pe = ge;
                }
                (xe = l()) && typeof xe.catch == "function" && xe.catch(function() {
                });
              }
            } catch (ge) {
              if (ge && pe && typeof ge.stack == "string")
                return [ge.stack, pe.stack];
            }
            return [null, null];
          }
        };
        x.DetermineComponentFrameRoot.displayName = "DetermineComponentFrameRoot";
        var N = Object.getOwnPropertyDescriptor(
          x.DetermineComponentFrameRoot,
          "name"
        );
        N && N.configurable && Object.defineProperty(
          x.DetermineComponentFrameRoot,
          "name",
          { value: "DetermineComponentFrameRoot" }
        );
        var R = x.DetermineComponentFrameRoot(), H = R[0], J = R[1];
        if (H && J) {
          var re = H.split(`
`), fe = J.split(`
`);
          for (N = x = 0; x < re.length && !re[x].includes("DetermineComponentFrameRoot"); )
            x++;
          for (; N < fe.length && !fe[N].includes(
            "DetermineComponentFrameRoot"
          ); )
            N++;
          if (x === re.length || N === fe.length)
            for (x = re.length - 1, N = fe.length - 1; 1 <= x && 0 <= N && re[x] !== fe[N]; )
              N--;
          for (; 1 <= x && 0 <= N; x--, N--)
            if (re[x] !== fe[N]) {
              if (x !== 1 || N !== 1)
                do
                  if (x--, N--, 0 > N || re[x] !== fe[N]) {
                    var ve = `
` + re[x].replace(" at new ", " at ");
                    return l.displayName && ve.includes("<anonymous>") && (ve = ve.replace("<anonymous>", l.displayName)), ve;
                  }
                while (1 <= x && 0 <= N);
              break;
            }
        }
      } finally {
        be = !1, Error.prepareStackTrace = m;
      }
      return (m = l ? l.displayName || l.name : "") ? le(m) : "";
    }
    function De(l, d) {
      switch (l.tag) {
        case 26:
        case 27:
        case 5:
          return le(l.type);
        case 16:
          return le("Lazy");
        case 13:
          return l.child !== d && d !== null ? le("Suspense Fallback") : le("Suspense");
        case 19:
          return le("SuspenseList");
        case 0:
        case 15:
          return ke(l.type, !1);
        case 11:
          return ke(l.type.render, !1);
        case 1:
          return ke(l.type, !0);
        case 31:
          return le("Activity");
        default:
          return "";
      }
    }
    function ze(l) {
      try {
        var d = "", m = null;
        do
          d += De(l, m), m = l, l = l.return;
        while (l);
        return d;
      } catch (x) {
        return `
Error generating stack: ` + x.message + `
` + x.stack;
      }
    }
    var Ue = Object.prototype.hasOwnProperty, He = e.unstable_scheduleCallback, Pe = e.unstable_cancelCallback, It = e.unstable_shouldYield, Xe = e.unstable_requestPaint, Ee = e.unstable_now, _e = e.unstable_getCurrentPriorityLevel, ie = e.unstable_ImmediatePriority, me = e.unstable_UserBlockingPriority, Se = e.unstable_NormalPriority, je = e.unstable_LowPriority, Ae = e.unstable_IdlePriority, vt = e.log, yt = e.unstable_setDisableYieldValue, At = null, qt = null;
    function Mn(l) {
      if (typeof vt == "function" && yt(l), qt && typeof qt.setStrictMode == "function")
        try {
          qt.setStrictMode(At, l);
        } catch {
        }
    }
    var Re = Math.clz32 ? Math.clz32 : Rr, bt = Math.log, Ct = Math.LN2;
    function Rr(l) {
      return l >>>= 0, l === 0 ? 32 : 31 - (bt(l) / Ct | 0) | 0;
    }
    var Fo = 256, on = 262144, bn = 4194304;
    function Kr(l) {
      var d = l & 42;
      if (d !== 0) return d;
      switch (l & -l) {
        case 1:
          return 1;
        case 2:
          return 2;
        case 4:
          return 4;
        case 8:
          return 8;
        case 16:
          return 16;
        case 32:
          return 32;
        case 64:
          return 64;
        case 128:
          return 128;
        case 256:
        case 512:
        case 1024:
        case 2048:
        case 4096:
        case 8192:
        case 16384:
        case 32768:
        case 65536:
        case 131072:
          return l & 261888;
        case 262144:
        case 524288:
        case 1048576:
        case 2097152:
          return l & 3932160;
        case 4194304:
        case 8388608:
        case 16777216:
        case 33554432:
          return l & 62914560;
        case 67108864:
          return 67108864;
        case 134217728:
          return 134217728;
        case 268435456:
          return 268435456;
        case 536870912:
          return 536870912;
        case 1073741824:
          return 0;
        default:
          return l;
      }
    }
    function To(l, d, m) {
      var x = l.pendingLanes;
      if (x === 0) return 0;
      var N = 0, R = l.suspendedLanes, H = l.pingedLanes;
      l = l.warmLanes;
      var J = x & 134217727;
      return J !== 0 ? (x = J & ~R, x !== 0 ? N = Kr(x) : (H &= J, H !== 0 ? N = Kr(H) : m || (m = J & ~l, m !== 0 && (N = Kr(m))))) : (J = x & ~R, J !== 0 ? N = Kr(J) : H !== 0 ? N = Kr(H) : m || (m = x & ~l, m !== 0 && (N = Kr(m)))), N === 0 ? 0 : d !== 0 && d !== N && (d & R) === 0 && (R = N & -N, m = d & -d, R >= m || R === 32 && (m & 4194048) !== 0) ? d : N;
    }
    function tr(l, d) {
      return (l.pendingLanes & ~(l.suspendedLanes & ~l.pingedLanes) & d) === 0;
    }
    function Ux(l, d) {
      switch (l) {
        case 1:
        case 2:
        case 4:
        case 8:
        case 64:
          return d + 250;
        case 16:
        case 32:
        case 128:
        case 256:
        case 512:
        case 1024:
        case 2048:
        case 4096:
        case 8192:
        case 16384:
        case 32768:
        case 65536:
        case 131072:
        case 262144:
        case 524288:
        case 1048576:
        case 2097152:
          return d + 5e3;
        case 4194304:
        case 8388608:
        case 16777216:
        case 33554432:
          return -1;
        case 67108864:
        case 134217728:
        case 268435456:
        case 536870912:
        case 1073741824:
          return -1;
        default:
          return -1;
      }
    }
    function Eh() {
      var l = bn;
      return bn <<= 1, (bn & 62914560) === 0 && (bn = 4194304), l;
    }
    function Yd(l) {
      for (var d = [], m = 0; 31 > m; m++) d.push(l);
      return d;
    }
    function bl(l, d) {
      l.pendingLanes |= d, d !== 268435456 && (l.suspendedLanes = 0, l.pingedLanes = 0, l.warmLanes = 0);
    }
    function Hx(l, d, m, x, N, R) {
      var H = l.pendingLanes;
      l.pendingLanes = m, l.suspendedLanes = 0, l.pingedLanes = 0, l.warmLanes = 0, l.expiredLanes &= m, l.entangledLanes &= m, l.errorRecoveryDisabledLanes &= m, l.shellSuspendCounter = 0;
      var J = l.entanglements, re = l.expirationTimes, fe = l.hiddenUpdates;
      for (m = H & ~m; 0 < m; ) {
        var ve = 31 - Re(m), xe = 1 << ve;
        J[ve] = 0, re[ve] = -1;
        var pe = fe[ve];
        if (pe !== null)
          for (fe[ve] = null, ve = 0; ve < pe.length; ve++) {
            var ge = pe[ve];
            ge !== null && (ge.lane &= -536870913);
          }
        m &= ~xe;
      }
      x !== 0 && Ch(l, x, 0), R !== 0 && N === 0 && l.tag !== 0 && (l.suspendedLanes |= R & ~(H & ~d));
    }
    function Ch(l, d, m) {
      l.pendingLanes |= d, l.suspendedLanes &= ~d;
      var x = 31 - Re(d);
      l.entangledLanes |= d, l.entanglements[x] = l.entanglements[x] | 1073741824 | m & 261930;
    }
    function Ph(l, d) {
      var m = l.entangledLanes |= d;
      for (l = l.entanglements; m; ) {
        var x = 31 - Re(m), N = 1 << x;
        N & d | l[x] & d && (l[x] |= d), m &= ~N;
      }
    }
    function Oh(l, d) {
      var m = d & -d;
      return m = (m & 42) !== 0 ? 1 : Jd(m), (m & (l.suspendedLanes | d)) !== 0 ? 0 : m;
    }
    function Jd(l) {
      switch (l) {
        case 2:
          l = 1;
          break;
        case 8:
          l = 4;
          break;
        case 32:
          l = 16;
          break;
        case 256:
        case 512:
        case 1024:
        case 2048:
        case 4096:
        case 8192:
        case 16384:
        case 32768:
        case 65536:
        case 131072:
        case 262144:
        case 524288:
        case 1048576:
        case 2097152:
        case 4194304:
        case 8388608:
        case 16777216:
        case 33554432:
          l = 128;
          break;
        case 268435456:
          l = 134217728;
          break;
        default:
          l = 0;
      }
      return l;
    }
    function Qd(l) {
      return l &= -l, 2 < l ? 8 < l ? (l & 134217727) !== 0 ? 32 : 268435456 : 8 : 2;
    }
    function Nh() {
      var l = G.p;
      return l !== 0 ? l : (l = window.event, l === void 0 ? 32 : Xj(l.type));
    }
    function Mh(l, d) {
      var m = G.p;
      try {
        return G.p = l, d();
      } finally {
        G.p = m;
      }
    }
    var da = Math.random().toString(36).slice(2), qn = "__reactFiber$" + da, pr = "__reactProps$" + da, oi = "__reactContainer$" + da, Du = "__reactEvents$" + da, Rh = "__reactListeners$" + da, Wx = "__reactHandles$" + da, jh = "__reactResources$" + da, wl = "__reactMarker$" + da;
    function Zd(l) {
      delete l[qn], delete l[pr], delete l[Du], delete l[Rh], delete l[Wx];
    }
    function ls(l) {
      var d = l[qn];
      if (d) return d;
      for (var m = l.parentNode; m; ) {
        if (d = m[oi] || m[qn]) {
          if (m = d.alternate, d.child !== null || m !== null && m.child !== null)
            for (l = Ij(l); l !== null; ) {
              if (m = l[qn]) return m;
              l = Ij(l);
            }
          return d;
        }
        l = m, m = l.parentNode;
      }
      return null;
    }
    function us(l) {
      if (l = l[qn] || l[oi]) {
        var d = l.tag;
        if (d === 5 || d === 6 || d === 13 || d === 31 || d === 26 || d === 27 || d === 3)
          return l;
      }
      return null;
    }
    function cs(l) {
      var d = l.tag;
      if (d === 5 || d === 26 || d === 27 || d === 6) return l.stateNode;
      throw Error(r(33));
    }
    function ds(l) {
      var d = l[jh];
      return d || (d = l[jh] = { hoistableStyles: /* @__PURE__ */ new Map(), hoistableScripts: /* @__PURE__ */ new Map() }), d;
    }
    function $n(l) {
      l[wl] = !0;
    }
    var Ih = /* @__PURE__ */ new Set(), Ah = {};
    function ai(l, d) {
      fs(l, d), fs(l + "Capture", d);
    }
    function fs(l, d) {
      for (Ah[l] = d, l = 0; l < d.length; l++)
        Ih.add(d[l]);
    }
    var qx = RegExp(
      "^[:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD][:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"
    ), ef = {}, $h = {};
    function Kx(l) {
      return Ue.call($h, l) ? !0 : Ue.call(ef, l) ? !1 : qx.test(l) ? $h[l] = !0 : (ef[l] = !0, !1);
    }
    function Lu(l, d, m) {
      if (Kx(d))
        if (m === null) l.removeAttribute(d);
        else {
          switch (typeof m) {
            case "undefined":
            case "function":
            case "symbol":
              l.removeAttribute(d);
              return;
            case "boolean":
              var x = d.toLowerCase().slice(0, 5);
              if (x !== "data-" && x !== "aria-") {
                l.removeAttribute(d);
                return;
              }
          }
          l.setAttribute(d, "" + m);
        }
    }
    function Fu(l, d, m) {
      if (m === null) l.removeAttribute(d);
      else {
        switch (typeof m) {
          case "undefined":
          case "function":
          case "symbol":
          case "boolean":
            l.removeAttribute(d);
            return;
        }
        l.setAttribute(d, "" + m);
      }
    }
    function zo(l, d, m, x) {
      if (x === null) l.removeAttribute(m);
      else {
        switch (typeof x) {
          case "undefined":
          case "function":
          case "symbol":
          case "boolean":
            l.removeAttribute(m);
            return;
        }
        l.setAttributeNS(d, m, "" + x);
      }
    }
    function jr(l) {
      switch (typeof l) {
        case "bigint":
        case "boolean":
        case "number":
        case "string":
        case "undefined":
          return l;
        case "object":
          return l;
        default:
          return "";
      }
    }
    function Dh(l) {
      var d = l.type;
      return (l = l.nodeName) && l.toLowerCase() === "input" && (d === "checkbox" || d === "radio");
    }
    function Gx(l, d, m) {
      var x = Object.getOwnPropertyDescriptor(
        l.constructor.prototype,
        d
      );
      if (!l.hasOwnProperty(d) && typeof x < "u" && typeof x.get == "function" && typeof x.set == "function") {
        var N = x.get, R = x.set;
        return Object.defineProperty(l, d, {
          configurable: !0,
          get: function() {
            return N.call(this);
          },
          set: function(H) {
            m = "" + H, R.call(this, H);
          }
        }), Object.defineProperty(l, d, {
          enumerable: x.enumerable
        }), {
          getValue: function() {
            return m;
          },
          setValue: function(H) {
            m = "" + H;
          },
          stopTracking: function() {
            l._valueTracker = null, delete l[d];
          }
        };
      }
    }
    function Tu(l) {
      if (!l._valueTracker) {
        var d = Dh(l) ? "checked" : "value";
        l._valueTracker = Gx(
          l,
          d,
          "" + l[d]
        );
      }
    }
    function Lh(l) {
      if (!l) return !1;
      var d = l._valueTracker;
      if (!d) return !0;
      var m = d.getValue(), x = "";
      return l && (x = Dh(l) ? l.checked ? "true" : "false" : l.value), l = x, l !== m ? (d.setValue(l), !0) : !1;
    }
    function xl(l) {
      if (l = l || (typeof document < "u" ? document : void 0), typeof l > "u") return null;
      try {
        return l.activeElement || l.body;
      } catch {
        return l.body;
      }
    }
    var Xx = /[\n"\\]/g;
    function Gr(l) {
      return l.replace(
        Xx,
        function(d) {
          return "\\" + d.charCodeAt(0).toString(16) + " ";
        }
      );
    }
    function kl(l, d, m, x, N, R, H, J) {
      l.name = "", H != null && typeof H != "function" && typeof H != "symbol" && typeof H != "boolean" ? l.type = H : l.removeAttribute("type"), d != null ? H === "number" ? (d === 0 && l.value === "" || l.value != d) && (l.value = "" + jr(d)) : l.value !== "" + jr(d) && (l.value = "" + jr(d)) : H !== "submit" && H !== "reset" || l.removeAttribute("value"), d != null ? tf(l, H, jr(d)) : m != null ? tf(l, H, jr(m)) : x != null && l.removeAttribute("value"), N == null && R != null && (l.defaultChecked = !!R), N != null && (l.checked = N && typeof N != "function" && typeof N != "symbol"), J != null && typeof J != "function" && typeof J != "symbol" && typeof J != "boolean" ? l.name = "" + jr(J) : l.removeAttribute("name");
    }
    function Fh(l, d, m, x, N, R, H, J) {
      if (R != null && typeof R != "function" && typeof R != "symbol" && typeof R != "boolean" && (l.type = R), d != null || m != null) {
        if (!(R !== "submit" && R !== "reset" || d != null)) {
          Tu(l);
          return;
        }
        m = m != null ? "" + jr(m) : "", d = d != null ? "" + jr(d) : m, J || d === l.value || (l.value = d), l.defaultValue = d;
      }
      x = x ?? N, x = typeof x != "function" && typeof x != "symbol" && !!x, l.checked = J ? l.checked : !!x, l.defaultChecked = !!x, H != null && typeof H != "function" && typeof H != "symbol" && typeof H != "boolean" && (l.name = H), Tu(l);
    }
    function tf(l, d, m) {
      d === "number" && xl(l.ownerDocument) === l || l.defaultValue === "" + m || (l.defaultValue = "" + m);
    }
    function ii(l, d, m, x) {
      if (l = l.options, d) {
        d = {};
        for (var N = 0; N < m.length; N++)
          d["$" + m[N]] = !0;
        for (m = 0; m < l.length; m++)
          N = d.hasOwnProperty("$" + l[m].value), l[m].selected !== N && (l[m].selected = N), N && x && (l[m].defaultSelected = !0);
      } else {
        for (m = "" + jr(m), d = null, N = 0; N < l.length; N++) {
          if (l[N].value === m) {
            l[N].selected = !0, x && (l[N].defaultSelected = !0);
            return;
          }
          d !== null || l[N].disabled || (d = l[N]);
        }
        d !== null && (d.selected = !0);
      }
    }
    function wN(l, d, m) {
      if (d != null && (d = "" + jr(d), d !== l.value && (l.value = d), m == null)) {
        l.defaultValue !== d && (l.defaultValue = d);
        return;
      }
      l.defaultValue = m != null ? "" + jr(m) : "";
    }
    function xN(l, d, m, x) {
      if (d == null) {
        if (x != null) {
          if (m != null) throw Error(r(92));
          if (q(x)) {
            if (1 < x.length) throw Error(r(93));
            x = x[0];
          }
          m = x;
        }
        m == null && (m = ""), d = m;
      }
      m = jr(d), l.defaultValue = m, x = l.textContent, x === m && x !== "" && x !== null && (l.value = x), Tu(l);
    }
    function zu(l, d) {
      if (d) {
        var m = l.firstChild;
        if (m && m === l.lastChild && m.nodeType === 3) {
          m.nodeValue = d;
          return;
        }
      }
      l.textContent = d;
    }
    var HW = new Set(
      "animationIterationCount aspectRatio borderImageOutset borderImageSlice borderImageWidth boxFlex boxFlexGroup boxOrdinalGroup columnCount columns flex flexGrow flexPositive flexShrink flexNegative flexOrder gridArea gridRow gridRowEnd gridRowSpan gridRowStart gridColumn gridColumnEnd gridColumnSpan gridColumnStart fontWeight lineClamp lineHeight opacity order orphans scale tabSize widows zIndex zoom fillOpacity floodOpacity stopOpacity strokeDasharray strokeDashoffset strokeMiterlimit strokeOpacity strokeWidth MozAnimationIterationCount MozBoxFlex MozBoxFlexGroup MozLineClamp msAnimationIterationCount msFlex msZoom msFlexGrow msFlexNegative msFlexOrder msFlexPositive msFlexShrink msGridColumn msGridColumnSpan msGridRow msGridRowSpan WebkitAnimationIterationCount WebkitBoxFlex WebKitBoxFlexGroup WebkitBoxOrdinalGroup WebkitColumnCount WebkitColumns WebkitFlex WebkitFlexGrow WebkitFlexPositive WebkitFlexShrink WebkitLineClamp".split(
        " "
      )
    );
    function kN(l, d, m) {
      var x = d.indexOf("--") === 0;
      m == null || typeof m == "boolean" || m === "" ? x ? l.setProperty(d, "") : d === "float" ? l.cssFloat = "" : l[d] = "" : x ? l.setProperty(d, m) : typeof m != "number" || m === 0 || HW.has(d) ? d === "float" ? l.cssFloat = m : l[d] = ("" + m).trim() : l[d] = m + "px";
    }
    function SN(l, d, m) {
      if (d != null && typeof d != "object")
        throw Error(r(62));
      if (l = l.style, m != null) {
        for (var x in m)
          !m.hasOwnProperty(x) || d != null && d.hasOwnProperty(x) || (x.indexOf("--") === 0 ? l.setProperty(x, "") : x === "float" ? l.cssFloat = "" : l[x] = "");
        for (var N in d)
          x = d[N], d.hasOwnProperty(N) && m[N] !== x && kN(l, N, x);
      } else
        for (var R in d)
          d.hasOwnProperty(R) && kN(l, R, d[R]);
    }
    function Yx(l) {
      if (l.indexOf("-") === -1) return !1;
      switch (l) {
        case "annotation-xml":
        case "color-profile":
        case "font-face":
        case "font-face-src":
        case "font-face-uri":
        case "font-face-format":
        case "font-face-name":
        case "missing-glyph":
          return !1;
        default:
          return !0;
      }
    }
    var WW = /* @__PURE__ */ new Map([
      ["acceptCharset", "accept-charset"],
      ["htmlFor", "for"],
      ["httpEquiv", "http-equiv"],
      ["crossOrigin", "crossorigin"],
      ["accentHeight", "accent-height"],
      ["alignmentBaseline", "alignment-baseline"],
      ["arabicForm", "arabic-form"],
      ["baselineShift", "baseline-shift"],
      ["capHeight", "cap-height"],
      ["clipPath", "clip-path"],
      ["clipRule", "clip-rule"],
      ["colorInterpolation", "color-interpolation"],
      ["colorInterpolationFilters", "color-interpolation-filters"],
      ["colorProfile", "color-profile"],
      ["colorRendering", "color-rendering"],
      ["dominantBaseline", "dominant-baseline"],
      ["enableBackground", "enable-background"],
      ["fillOpacity", "fill-opacity"],
      ["fillRule", "fill-rule"],
      ["floodColor", "flood-color"],
      ["floodOpacity", "flood-opacity"],
      ["fontFamily", "font-family"],
      ["fontSize", "font-size"],
      ["fontSizeAdjust", "font-size-adjust"],
      ["fontStretch", "font-stretch"],
      ["fontStyle", "font-style"],
      ["fontVariant", "font-variant"],
      ["fontWeight", "font-weight"],
      ["glyphName", "glyph-name"],
      ["glyphOrientationHorizontal", "glyph-orientation-horizontal"],
      ["glyphOrientationVertical", "glyph-orientation-vertical"],
      ["horizAdvX", "horiz-adv-x"],
      ["horizOriginX", "horiz-origin-x"],
      ["imageRendering", "image-rendering"],
      ["letterSpacing", "letter-spacing"],
      ["lightingColor", "lighting-color"],
      ["markerEnd", "marker-end"],
      ["markerMid", "marker-mid"],
      ["markerStart", "marker-start"],
      ["overlinePosition", "overline-position"],
      ["overlineThickness", "overline-thickness"],
      ["paintOrder", "paint-order"],
      ["panose-1", "panose-1"],
      ["pointerEvents", "pointer-events"],
      ["renderingIntent", "rendering-intent"],
      ["shapeRendering", "shape-rendering"],
      ["stopColor", "stop-color"],
      ["stopOpacity", "stop-opacity"],
      ["strikethroughPosition", "strikethrough-position"],
      ["strikethroughThickness", "strikethrough-thickness"],
      ["strokeDasharray", "stroke-dasharray"],
      ["strokeDashoffset", "stroke-dashoffset"],
      ["strokeLinecap", "stroke-linecap"],
      ["strokeLinejoin", "stroke-linejoin"],
      ["strokeMiterlimit", "stroke-miterlimit"],
      ["strokeOpacity", "stroke-opacity"],
      ["strokeWidth", "stroke-width"],
      ["textAnchor", "text-anchor"],
      ["textDecoration", "text-decoration"],
      ["textRendering", "text-rendering"],
      ["transformOrigin", "transform-origin"],
      ["underlinePosition", "underline-position"],
      ["underlineThickness", "underline-thickness"],
      ["unicodeBidi", "unicode-bidi"],
      ["unicodeRange", "unicode-range"],
      ["unitsPerEm", "units-per-em"],
      ["vAlphabetic", "v-alphabetic"],
      ["vHanging", "v-hanging"],
      ["vIdeographic", "v-ideographic"],
      ["vMathematical", "v-mathematical"],
      ["vectorEffect", "vector-effect"],
      ["vertAdvY", "vert-adv-y"],
      ["vertOriginX", "vert-origin-x"],
      ["vertOriginY", "vert-origin-y"],
      ["wordSpacing", "word-spacing"],
      ["writingMode", "writing-mode"],
      ["xmlnsXlink", "xmlns:xlink"],
      ["xHeight", "x-height"]
    ]), qW = /^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*:/i;
    function Th(l) {
      return qW.test("" + l) ? "javascript:throw new Error('React has blocked a javascript: URL as a security precaution.')" : l;
    }
    function si() {
    }
    var Jx = null;
    function Qx(l) {
      return l = l.target || l.srcElement || window, l.correspondingUseElement && (l = l.correspondingUseElement), l.nodeType === 3 ? l.parentNode : l;
    }
    var Bu = null, Vu = null;
    function _N(l) {
      var d = us(l);
      if (d && (l = d.stateNode)) {
        var m = l[pr] || null;
        e: switch (l = d.stateNode, d.type) {
          case "input":
            if (kl(
              l,
              m.value,
              m.defaultValue,
              m.defaultValue,
              m.checked,
              m.defaultChecked,
              m.type,
              m.name
            ), d = m.name, m.type === "radio" && d != null) {
              for (m = l; m.parentNode; ) m = m.parentNode;
              for (m = m.querySelectorAll(
                'input[name="' + Gr(
                  "" + d
                ) + '"][type="radio"]'
              ), d = 0; d < m.length; d++) {
                var x = m[d];
                if (x !== l && x.form === l.form) {
                  var N = x[pr] || null;
                  if (!N) throw Error(r(90));
                  kl(
                    x,
                    N.value,
                    N.defaultValue,
                    N.defaultValue,
                    N.checked,
                    N.defaultChecked,
                    N.type,
                    N.name
                  );
                }
              }
              for (d = 0; d < m.length; d++)
                x = m[d], x.form === l.form && Lh(x);
            }
            break e;
          case "textarea":
            wN(l, m.value, m.defaultValue);
            break e;
          case "select":
            d = m.value, d != null && ii(l, !!m.multiple, d, !1);
        }
      }
    }
    var Zx = !1;
    function EN(l, d, m) {
      if (Zx) return l(d, m);
      Zx = !0;
      try {
        var x = l(d);
        return x;
      } finally {
        if (Zx = !1, (Bu !== null || Vu !== null) && (Cg(), Bu && (d = Bu, l = Vu, Vu = Bu = null, _N(d), l)))
          for (d = 0; d < l.length; d++) _N(l[d]);
      }
    }
    function nf(l, d) {
      var m = l.stateNode;
      if (m === null) return null;
      var x = m[pr] || null;
      if (x === null) return null;
      m = x[d];
      e: switch (d) {
        case "onClick":
        case "onClickCapture":
        case "onDoubleClick":
        case "onDoubleClickCapture":
        case "onMouseDown":
        case "onMouseDownCapture":
        case "onMouseMove":
        case "onMouseMoveCapture":
        case "onMouseUp":
        case "onMouseUpCapture":
        case "onMouseEnter":
          (x = !x.disabled) || (l = l.type, x = !(l === "button" || l === "input" || l === "select" || l === "textarea")), l = !x;
          break e;
        default:
          l = !1;
      }
      if (l) return null;
      if (m && typeof m != "function")
        throw Error(
          r(231, d, typeof m)
        );
      return m;
    }
    var li = !(typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u"), ek = !1;
    if (li)
      try {
        var rf = {};
        Object.defineProperty(rf, "passive", {
          get: function() {
            ek = !0;
          }
        }), window.addEventListener("test", rf, rf), window.removeEventListener("test", rf, rf);
      } catch {
        ek = !1;
      }
    var ps = null, tk = null, zh = null;
    function CN() {
      if (zh) return zh;
      var l, d = tk, m = d.length, x, N = "value" in ps ? ps.value : ps.textContent, R = N.length;
      for (l = 0; l < m && d[l] === N[l]; l++) ;
      var H = m - l;
      for (x = 1; x <= H && d[m - x] === N[R - x]; x++) ;
      return zh = N.slice(l, 1 < x ? 1 - x : void 0);
    }
    function Bh(l) {
      var d = l.keyCode;
      return "charCode" in l ? (l = l.charCode, l === 0 && d === 13 && (l = 13)) : l = d, l === 10 && (l = 13), 32 <= l || l === 13 ? l : 0;
    }
    function Vh() {
      return !0;
    }
    function PN() {
      return !1;
    }
    function Ir(l) {
      function d(m, x, N, R, H) {
        this._reactName = m, this._targetInst = N, this.type = x, this.nativeEvent = R, this.target = H, this.currentTarget = null;
        for (var J in l)
          l.hasOwnProperty(J) && (m = l[J], this[J] = m ? m(R) : R[J]);
        return this.isDefaultPrevented = (R.defaultPrevented != null ? R.defaultPrevented : R.returnValue === !1) ? Vh : PN, this.isPropagationStopped = PN, this;
      }
      return p(d.prototype, {
        preventDefault: function() {
          this.defaultPrevented = !0;
          var m = this.nativeEvent;
          m && (m.preventDefault ? m.preventDefault() : typeof m.returnValue != "unknown" && (m.returnValue = !1), this.isDefaultPrevented = Vh);
        },
        stopPropagation: function() {
          var m = this.nativeEvent;
          m && (m.stopPropagation ? m.stopPropagation() : typeof m.cancelBubble != "unknown" && (m.cancelBubble = !0), this.isPropagationStopped = Vh);
        },
        persist: function() {
        },
        isPersistent: Vh
      }), d;
    }
    var Sl = {
      eventPhase: 0,
      bubbles: 0,
      cancelable: 0,
      timeStamp: function(l) {
        return l.timeStamp || Date.now();
      },
      defaultPrevented: 0,
      isTrusted: 0
    }, Uh = Ir(Sl), of = p({}, Sl, { view: 0, detail: 0 }), KW = Ir(of), nk, rk, af, Hh = p({}, of, {
      screenX: 0,
      screenY: 0,
      clientX: 0,
      clientY: 0,
      pageX: 0,
      pageY: 0,
      ctrlKey: 0,
      shiftKey: 0,
      altKey: 0,
      metaKey: 0,
      getModifierState: ak,
      button: 0,
      buttons: 0,
      relatedTarget: function(l) {
        return l.relatedTarget === void 0 ? l.fromElement === l.srcElement ? l.toElement : l.fromElement : l.relatedTarget;
      },
      movementX: function(l) {
        return "movementX" in l ? l.movementX : (l !== af && (af && l.type === "mousemove" ? (nk = l.screenX - af.screenX, rk = l.screenY - af.screenY) : rk = nk = 0, af = l), nk);
      },
      movementY: function(l) {
        return "movementY" in l ? l.movementY : rk;
      }
    }), ON = Ir(Hh), GW = p({}, Hh, { dataTransfer: 0 }), XW = Ir(GW), YW = p({}, of, { relatedTarget: 0 }), ok = Ir(YW), JW = p({}, Sl, {
      animationName: 0,
      elapsedTime: 0,
      pseudoElement: 0
    }), QW = Ir(JW), ZW = p({}, Sl, {
      clipboardData: function(l) {
        return "clipboardData" in l ? l.clipboardData : window.clipboardData;
      }
    }), eq = Ir(ZW), tq = p({}, Sl, { data: 0 }), NN = Ir(tq), nq = {
      Esc: "Escape",
      Spacebar: " ",
      Left: "ArrowLeft",
      Up: "ArrowUp",
      Right: "ArrowRight",
      Down: "ArrowDown",
      Del: "Delete",
      Win: "OS",
      Menu: "ContextMenu",
      Apps: "ContextMenu",
      Scroll: "ScrollLock",
      MozPrintableKey: "Unidentified"
    }, rq = {
      8: "Backspace",
      9: "Tab",
      12: "Clear",
      13: "Enter",
      16: "Shift",
      17: "Control",
      18: "Alt",
      19: "Pause",
      20: "CapsLock",
      27: "Escape",
      32: " ",
      33: "PageUp",
      34: "PageDown",
      35: "End",
      36: "Home",
      37: "ArrowLeft",
      38: "ArrowUp",
      39: "ArrowRight",
      40: "ArrowDown",
      45: "Insert",
      46: "Delete",
      112: "F1",
      113: "F2",
      114: "F3",
      115: "F4",
      116: "F5",
      117: "F6",
      118: "F7",
      119: "F8",
      120: "F9",
      121: "F10",
      122: "F11",
      123: "F12",
      144: "NumLock",
      145: "ScrollLock",
      224: "Meta"
    }, oq = {
      Alt: "altKey",
      Control: "ctrlKey",
      Meta: "metaKey",
      Shift: "shiftKey"
    };
    function aq(l) {
      var d = this.nativeEvent;
      return d.getModifierState ? d.getModifierState(l) : (l = oq[l]) ? !!d[l] : !1;
    }
    function ak() {
      return aq;
    }
    var iq = p({}, of, {
      key: function(l) {
        if (l.key) {
          var d = nq[l.key] || l.key;
          if (d !== "Unidentified") return d;
        }
        return l.type === "keypress" ? (l = Bh(l), l === 13 ? "Enter" : String.fromCharCode(l)) : l.type === "keydown" || l.type === "keyup" ? rq[l.keyCode] || "Unidentified" : "";
      },
      code: 0,
      location: 0,
      ctrlKey: 0,
      shiftKey: 0,
      altKey: 0,
      metaKey: 0,
      repeat: 0,
      locale: 0,
      getModifierState: ak,
      charCode: function(l) {
        return l.type === "keypress" ? Bh(l) : 0;
      },
      keyCode: function(l) {
        return l.type === "keydown" || l.type === "keyup" ? l.keyCode : 0;
      },
      which: function(l) {
        return l.type === "keypress" ? Bh(l) : l.type === "keydown" || l.type === "keyup" ? l.keyCode : 0;
      }
    }), sq = Ir(iq), lq = p({}, Hh, {
      pointerId: 0,
      width: 0,
      height: 0,
      pressure: 0,
      tangentialPressure: 0,
      tiltX: 0,
      tiltY: 0,
      twist: 0,
      pointerType: 0,
      isPrimary: 0
    }), MN = Ir(lq), uq = p({}, of, {
      touches: 0,
      targetTouches: 0,
      changedTouches: 0,
      altKey: 0,
      metaKey: 0,
      ctrlKey: 0,
      shiftKey: 0,
      getModifierState: ak
    }), cq = Ir(uq), dq = p({}, Sl, {
      propertyName: 0,
      elapsedTime: 0,
      pseudoElement: 0
    }), fq = Ir(dq), pq = p({}, Hh, {
      deltaX: function(l) {
        return "deltaX" in l ? l.deltaX : "wheelDeltaX" in l ? -l.wheelDeltaX : 0;
      },
      deltaY: function(l) {
        return "deltaY" in l ? l.deltaY : "wheelDeltaY" in l ? -l.wheelDeltaY : "wheelDelta" in l ? -l.wheelDelta : 0;
      },
      deltaZ: 0,
      deltaMode: 0
    }), mq = Ir(pq), hq = p({}, Sl, {
      newState: 0,
      oldState: 0
    }), gq = Ir(hq), vq = [9, 13, 27, 32], ik = li && "CompositionEvent" in window, sf = null;
    li && "documentMode" in document && (sf = document.documentMode);
    var yq = li && "TextEvent" in window && !sf, RN = li && (!ik || sf && 8 < sf && 11 >= sf), jN = " ", IN = !1;
    function AN(l, d) {
      switch (l) {
        case "keyup":
          return vq.indexOf(d.keyCode) !== -1;
        case "keydown":
          return d.keyCode !== 229;
        case "keypress":
        case "mousedown":
        case "focusout":
          return !0;
        default:
          return !1;
      }
    }
    function $N(l) {
      return l = l.detail, typeof l == "object" && "data" in l ? l.data : null;
    }
    var Uu = !1;
    function bq(l, d) {
      switch (l) {
        case "compositionend":
          return $N(d);
        case "keypress":
          return d.which !== 32 ? null : (IN = !0, jN);
        case "textInput":
          return l = d.data, l === jN && IN ? null : l;
        default:
          return null;
      }
    }
    function wq(l, d) {
      if (Uu)
        return l === "compositionend" || !ik && AN(l, d) ? (l = CN(), zh = tk = ps = null, Uu = !1, l) : null;
      switch (l) {
        case "paste":
          return null;
        case "keypress":
          if (!(d.ctrlKey || d.altKey || d.metaKey) || d.ctrlKey && d.altKey) {
            if (d.char && 1 < d.char.length)
              return d.char;
            if (d.which) return String.fromCharCode(d.which);
          }
          return null;
        case "compositionend":
          return RN && d.locale !== "ko" ? null : d.data;
        default:
          return null;
      }
    }
    var xq = {
      color: !0,
      date: !0,
      datetime: !0,
      "datetime-local": !0,
      email: !0,
      month: !0,
      number: !0,
      password: !0,
      range: !0,
      search: !0,
      tel: !0,
      text: !0,
      time: !0,
      url: !0,
      week: !0
    };
    function DN(l) {
      var d = l && l.nodeName && l.nodeName.toLowerCase();
      return d === "input" ? !!xq[l.type] : d === "textarea";
    }
    function LN(l, d, m, x) {
      Bu ? Vu ? Vu.push(x) : Vu = [x] : Bu = x, d = Ig(d, "onChange"), 0 < d.length && (m = new Uh(
        "onChange",
        "change",
        null,
        m,
        x
      ), l.push({ event: m, listeners: d }));
    }
    var lf = null, uf = null;
    function kq(l) {
      bj(l, 0);
    }
    function Wh(l) {
      var d = cs(l);
      if (Lh(d)) return l;
    }
    function FN(l, d) {
      if (l === "change") return d;
    }
    var TN = !1;
    if (li) {
      var sk;
      if (li) {
        var lk = "oninput" in document;
        if (!lk) {
          var zN = document.createElement("div");
          zN.setAttribute("oninput", "return;"), lk = typeof zN.oninput == "function";
        }
        sk = lk;
      } else sk = !1;
      TN = sk && (!document.documentMode || 9 < document.documentMode);
    }
    function BN() {
      lf && (lf.detachEvent("onpropertychange", VN), uf = lf = null);
    }
    function VN(l) {
      if (l.propertyName === "value" && Wh(uf)) {
        var d = [];
        LN(
          d,
          uf,
          l,
          Qx(l)
        ), EN(kq, d);
      }
    }
    function Sq(l, d, m) {
      l === "focusin" ? (BN(), lf = d, uf = m, lf.attachEvent("onpropertychange", VN)) : l === "focusout" && BN();
    }
    function _q(l) {
      if (l === "selectionchange" || l === "keyup" || l === "keydown")
        return Wh(uf);
    }
    function Eq(l, d) {
      if (l === "click") return Wh(d);
    }
    function Cq(l, d) {
      if (l === "input" || l === "change")
        return Wh(d);
    }
    function Pq(l, d) {
      return l === d && (l !== 0 || 1 / l === 1 / d) || l !== l && d !== d;
    }
    var Xr = typeof Object.is == "function" ? Object.is : Pq;
    function cf(l, d) {
      if (Xr(l, d)) return !0;
      if (typeof l != "object" || l === null || typeof d != "object" || d === null)
        return !1;
      var m = Object.keys(l), x = Object.keys(d);
      if (m.length !== x.length) return !1;
      for (x = 0; x < m.length; x++) {
        var N = m[x];
        if (!Ue.call(d, N) || !Xr(l[N], d[N]))
          return !1;
      }
      return !0;
    }
    function UN(l) {
      for (; l && l.firstChild; ) l = l.firstChild;
      return l;
    }
    function HN(l, d) {
      var m = UN(l);
      l = 0;
      for (var x; m; ) {
        if (m.nodeType === 3) {
          if (x = l + m.textContent.length, l <= d && x >= d)
            return { node: m, offset: d - l };
          l = x;
        }
        e: {
          for (; m; ) {
            if (m.nextSibling) {
              m = m.nextSibling;
              break e;
            }
            m = m.parentNode;
          }
          m = void 0;
        }
        m = UN(m);
      }
    }
    function WN(l, d) {
      return l && d ? l === d ? !0 : l && l.nodeType === 3 ? !1 : d && d.nodeType === 3 ? WN(l, d.parentNode) : "contains" in l ? l.contains(d) : l.compareDocumentPosition ? !!(l.compareDocumentPosition(d) & 16) : !1 : !1;
    }
    function qN(l) {
      l = l != null && l.ownerDocument != null && l.ownerDocument.defaultView != null ? l.ownerDocument.defaultView : window;
      for (var d = xl(l.document); d instanceof l.HTMLIFrameElement; ) {
        try {
          var m = typeof d.contentWindow.location.href == "string";
        } catch {
          m = !1;
        }
        if (m) l = d.contentWindow;
        else break;
        d = xl(l.document);
      }
      return d;
    }
    function uk(l) {
      var d = l && l.nodeName && l.nodeName.toLowerCase();
      return d && (d === "input" && (l.type === "text" || l.type === "search" || l.type === "tel" || l.type === "url" || l.type === "password") || d === "textarea" || l.contentEditable === "true");
    }
    var Oq = li && "documentMode" in document && 11 >= document.documentMode, Hu = null, ck = null, df = null, dk = !1;
    function KN(l, d, m) {
      var x = m.window === m ? m.document : m.nodeType === 9 ? m : m.ownerDocument;
      dk || Hu == null || Hu !== xl(x) || (x = Hu, "selectionStart" in x && uk(x) ? x = { start: x.selectionStart, end: x.selectionEnd } : (x = (x.ownerDocument && x.ownerDocument.defaultView || window).getSelection(), x = {
        anchorNode: x.anchorNode,
        anchorOffset: x.anchorOffset,
        focusNode: x.focusNode,
        focusOffset: x.focusOffset
      }), df && cf(df, x) || (df = x, x = Ig(ck, "onSelect"), 0 < x.length && (d = new Uh(
        "onSelect",
        "select",
        null,
        d,
        m
      ), l.push({ event: d, listeners: x }), d.target = Hu)));
    }
    function _l(l, d) {
      var m = {};
      return m[l.toLowerCase()] = d.toLowerCase(), m["Webkit" + l] = "webkit" + d, m["Moz" + l] = "moz" + d, m;
    }
    var Wu = {
      animationend: _l("Animation", "AnimationEnd"),
      animationiteration: _l("Animation", "AnimationIteration"),
      animationstart: _l("Animation", "AnimationStart"),
      transitionrun: _l("Transition", "TransitionRun"),
      transitionstart: _l("Transition", "TransitionStart"),
      transitioncancel: _l("Transition", "TransitionCancel"),
      transitionend: _l("Transition", "TransitionEnd")
    }, fk = {}, GN = {};
    li && (GN = document.createElement("div").style, "AnimationEvent" in window || (delete Wu.animationend.animation, delete Wu.animationiteration.animation, delete Wu.animationstart.animation), "TransitionEvent" in window || delete Wu.transitionend.transition);
    function El(l) {
      if (fk[l]) return fk[l];
      if (!Wu[l]) return l;
      var d = Wu[l], m;
      for (m in d)
        if (d.hasOwnProperty(m) && m in GN)
          return fk[l] = d[m];
      return l;
    }
    var XN = El("animationend"), YN = El("animationiteration"), JN = El("animationstart"), Nq = El("transitionrun"), Mq = El("transitionstart"), Rq = El("transitioncancel"), QN = El("transitionend"), ZN = /* @__PURE__ */ new Map(), pk = "abort auxClick beforeToggle cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(
      " "
    );
    pk.push("scrollEnd");
    function Bo(l, d) {
      ZN.set(l, d), ai(d, [l]);
    }
    var qh = typeof reportError == "function" ? reportError : function(l) {
      if (typeof window == "object" && typeof window.ErrorEvent == "function") {
        var d = new window.ErrorEvent("error", {
          bubbles: !0,
          cancelable: !0,
          message: typeof l == "object" && l !== null && typeof l.message == "string" ? String(l.message) : String(l),
          error: l
        });
        if (!window.dispatchEvent(d)) return;
      } else if (typeof process == "object" && typeof process.emit == "function") {
        process.emit("uncaughtException", l);
        return;
      }
      console.error(l);
    }, yo = [], qu = 0, mk = 0;
    function Kh() {
      for (var l = qu, d = mk = qu = 0; d < l; ) {
        var m = yo[d];
        yo[d++] = null;
        var x = yo[d];
        yo[d++] = null;
        var N = yo[d];
        yo[d++] = null;
        var R = yo[d];
        if (yo[d++] = null, x !== null && N !== null) {
          var H = x.pending;
          H === null ? N.next = N : (N.next = H.next, H.next = N), x.pending = N;
        }
        R !== 0 && eM(m, N, R);
      }
    }
    function Gh(l, d, m, x) {
      yo[qu++] = l, yo[qu++] = d, yo[qu++] = m, yo[qu++] = x, mk |= x, l.lanes |= x, l = l.alternate, l !== null && (l.lanes |= x);
    }
    function hk(l, d, m, x) {
      return Gh(l, d, m, x), Xh(l);
    }
    function Cl(l, d) {
      return Gh(l, null, null, d), Xh(l);
    }
    function eM(l, d, m) {
      l.lanes |= m;
      var x = l.alternate;
      x !== null && (x.lanes |= m);
      for (var N = !1, R = l.return; R !== null; )
        R.childLanes |= m, x = R.alternate, x !== null && (x.childLanes |= m), R.tag === 22 && (l = R.stateNode, l === null || l._visibility & 1 || (N = !0)), l = R, R = R.return;
      return l.tag === 3 ? (R = l.stateNode, N && d !== null && (N = 31 - Re(m), l = R.hiddenUpdates, x = l[N], x === null ? l[N] = [d] : x.push(d), d.lane = m | 536870912), R) : null;
    }
    function Xh(l) {
      if (50 < If)
        throw If = 0, _S = null, Error(r(185));
      for (var d = l.return; d !== null; )
        l = d, d = l.return;
      return l.tag === 3 ? l.stateNode : null;
    }
    var Ku = {};
    function jq(l, d, m, x) {
      this.tag = l, this.key = m, this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null, this.index = 0, this.refCleanup = this.ref = null, this.pendingProps = d, this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null, this.mode = x, this.subtreeFlags = this.flags = 0, this.deletions = null, this.childLanes = this.lanes = 0, this.alternate = null;
    }
    function Yr(l, d, m, x) {
      return new jq(l, d, m, x);
    }
    function gk(l) {
      return l = l.prototype, !(!l || !l.isReactComponent);
    }
    function ui(l, d) {
      var m = l.alternate;
      return m === null ? (m = Yr(
        l.tag,
        d,
        l.key,
        l.mode
      ), m.elementType = l.elementType, m.type = l.type, m.stateNode = l.stateNode, m.alternate = l, l.alternate = m) : (m.pendingProps = d, m.type = l.type, m.flags = 0, m.subtreeFlags = 0, m.deletions = null), m.flags = l.flags & 65011712, m.childLanes = l.childLanes, m.lanes = l.lanes, m.child = l.child, m.memoizedProps = l.memoizedProps, m.memoizedState = l.memoizedState, m.updateQueue = l.updateQueue, d = l.dependencies, m.dependencies = d === null ? null : { lanes: d.lanes, firstContext: d.firstContext }, m.sibling = l.sibling, m.index = l.index, m.ref = l.ref, m.refCleanup = l.refCleanup, m;
    }
    function tM(l, d) {
      l.flags &= 65011714;
      var m = l.alternate;
      return m === null ? (l.childLanes = 0, l.lanes = d, l.child = null, l.subtreeFlags = 0, l.memoizedProps = null, l.memoizedState = null, l.updateQueue = null, l.dependencies = null, l.stateNode = null) : (l.childLanes = m.childLanes, l.lanes = m.lanes, l.child = m.child, l.subtreeFlags = 0, l.deletions = null, l.memoizedProps = m.memoizedProps, l.memoizedState = m.memoizedState, l.updateQueue = m.updateQueue, l.type = m.type, d = m.dependencies, l.dependencies = d === null ? null : {
        lanes: d.lanes,
        firstContext: d.firstContext
      }), l;
    }
    function Yh(l, d, m, x, N, R) {
      var H = 0;
      if (x = l, typeof l == "function") gk(l) && (H = 1);
      else if (typeof l == "string")
        H = LK(
          l,
          m,
          V.current
        ) ? 26 : l === "html" || l === "head" || l === "body" ? 27 : 5;
      else
        e: switch (l) {
          case A:
            return l = Yr(31, m, d, N), l.elementType = A, l.lanes = R, l;
          case b:
            return Pl(m.children, N, R, d);
          case v:
            H = 8, N |= 24;
            break;
          case w:
            return l = Yr(12, m, d, N | 2), l.elementType = w, l.lanes = R, l;
          case P:
            return l = Yr(13, m, d, N), l.elementType = P, l.lanes = R, l;
          case O:
            return l = Yr(19, m, d, N), l.elementType = O, l.lanes = R, l;
          default:
            if (typeof l == "object" && l !== null)
              switch (l.$$typeof) {
                case k:
                  H = 10;
                  break e;
                case _:
                  H = 9;
                  break e;
                case E:
                  H = 11;
                  break e;
                case M:
                  H = 14;
                  break e;
                case I:
                  H = 16, x = null;
                  break e;
              }
            H = 29, m = Error(
              r(130, l === null ? "null" : typeof l, "")
            ), x = null;
        }
      return d = Yr(H, m, d, N), d.elementType = l, d.type = x, d.lanes = R, d;
    }
    function Pl(l, d, m, x) {
      return l = Yr(7, l, x, d), l.lanes = m, l;
    }
    function vk(l, d, m) {
      return l = Yr(6, l, null, d), l.lanes = m, l;
    }
    function nM(l) {
      var d = Yr(18, null, null, 0);
      return d.stateNode = l, d;
    }
    function yk(l, d, m) {
      return d = Yr(
        4,
        l.children !== null ? l.children : [],
        l.key,
        d
      ), d.lanes = m, d.stateNode = {
        containerInfo: l.containerInfo,
        pendingChildren: null,
        implementation: l.implementation
      }, d;
    }
    var rM = /* @__PURE__ */ new WeakMap();
    function bo(l, d) {
      if (typeof l == "object" && l !== null) {
        var m = rM.get(l);
        return m !== void 0 ? m : (d = {
          value: l,
          source: d,
          stack: ze(d)
        }, rM.set(l, d), d);
      }
      return {
        value: l,
        source: d,
        stack: ze(d)
      };
    }
    var Gu = [], Xu = 0, Jh = null, ff = 0, wo = [], xo = 0, ms = null, fa = 1, pa = "";
    function ci(l, d) {
      Gu[Xu++] = ff, Gu[Xu++] = Jh, Jh = l, ff = d;
    }
    function oM(l, d, m) {
      wo[xo++] = fa, wo[xo++] = pa, wo[xo++] = ms, ms = l;
      var x = fa;
      l = pa;
      var N = 32 - Re(x) - 1;
      x &= ~(1 << N), m += 1;
      var R = 32 - Re(d) + N;
      if (30 < R) {
        var H = N - N % 5;
        R = (x & (1 << H) - 1).toString(32), x >>= H, N -= H, fa = 1 << 32 - Re(d) + N | m << N | x, pa = R + l;
      } else
        fa = 1 << R | m << N | x, pa = l;
    }
    function bk(l) {
      l.return !== null && (ci(l, 1), oM(l, 1, 0));
    }
    function wk(l) {
      for (; l === Jh; )
        Jh = Gu[--Xu], Gu[Xu] = null, ff = Gu[--Xu], Gu[Xu] = null;
      for (; l === ms; )
        ms = wo[--xo], wo[xo] = null, pa = wo[--xo], wo[xo] = null, fa = wo[--xo], wo[xo] = null;
    }
    function aM(l, d) {
      wo[xo++] = fa, wo[xo++] = pa, wo[xo++] = ms, fa = d.id, pa = d.overflow, ms = l;
    }
    var nr = null, pn = null, Pt = !1, hs = null, ko = !1, xk = Error(r(519));
    function gs(l) {
      var d = Error(
        r(
          418,
          1 < arguments.length && arguments[1] !== void 0 && arguments[1] ? "text" : "HTML",
          ""
        )
      );
      throw pf(bo(d, l)), xk;
    }
    function iM(l) {
      var d = l.stateNode, m = l.type, x = l.memoizedProps;
      switch (d[qn] = l, d[pr] = x, m) {
        case "dialog":
          xt("cancel", d), xt("close", d);
          break;
        case "iframe":
        case "object":
        case "embed":
          xt("load", d);
          break;
        case "video":
        case "audio":
          for (m = 0; m < $f.length; m++)
            xt($f[m], d);
          break;
        case "source":
          xt("error", d);
          break;
        case "img":
        case "image":
        case "link":
          xt("error", d), xt("load", d);
          break;
        case "details":
          xt("toggle", d);
          break;
        case "input":
          xt("invalid", d), Fh(
            d,
            x.value,
            x.defaultValue,
            x.checked,
            x.defaultChecked,
            x.type,
            x.name,
            !0
          );
          break;
        case "select":
          xt("invalid", d);
          break;
        case "textarea":
          xt("invalid", d), xN(d, x.value, x.defaultValue, x.children);
      }
      m = x.children, typeof m != "string" && typeof m != "number" && typeof m != "bigint" || d.textContent === "" + m || x.suppressHydrationWarning === !0 || Sj(d.textContent, m) ? (x.popover != null && (xt("beforetoggle", d), xt("toggle", d)), x.onScroll != null && xt("scroll", d), x.onScrollEnd != null && xt("scrollend", d), x.onClick != null && (d.onclick = si), d = !0) : d = !1, d || gs(l, !0);
    }
    function sM(l) {
      for (nr = l.return; nr; )
        switch (nr.tag) {
          case 5:
          case 31:
          case 13:
            ko = !1;
            return;
          case 27:
          case 3:
            ko = !0;
            return;
          default:
            nr = nr.return;
        }
    }
    function Yu(l) {
      if (l !== nr) return !1;
      if (!Pt) return sM(l), Pt = !0, !1;
      var d = l.tag, m;
      if ((m = d !== 3 && d !== 27) && ((m = d === 5) && (m = l.type, m = !(m !== "form" && m !== "button") || TS(l.type, l.memoizedProps)), m = !m), m && pn && gs(l), sM(l), d === 13) {
        if (l = l.memoizedState, l = l !== null ? l.dehydrated : null, !l) throw Error(r(317));
        pn = jj(l);
      } else if (d === 31) {
        if (l = l.memoizedState, l = l !== null ? l.dehydrated : null, !l) throw Error(r(317));
        pn = jj(l);
      } else
        d === 27 ? (d = pn, Ms(l.type) ? (l = HS, HS = null, pn = l) : pn = d) : pn = nr ? So(l.stateNode.nextSibling) : null;
      return !0;
    }
    function Ol() {
      pn = nr = null, Pt = !1;
    }
    function kk() {
      var l = hs;
      return l !== null && (Lr === null ? Lr = l : Lr.push.apply(
        Lr,
        l
      ), hs = null), l;
    }
    function pf(l) {
      hs === null ? hs = [l] : hs.push(l);
    }
    var Sk = L(null), Nl = null, di = null;
    function vs(l, d, m) {
      T(Sk, d._currentValue), d._currentValue = m;
    }
    function fi(l) {
      l._currentValue = Sk.current, K(Sk);
    }
    function _k(l, d, m) {
      for (; l !== null; ) {
        var x = l.alternate;
        if ((l.childLanes & d) !== d ? (l.childLanes |= d, x !== null && (x.childLanes |= d)) : x !== null && (x.childLanes & d) !== d && (x.childLanes |= d), l === m) break;
        l = l.return;
      }
    }
    function Ek(l, d, m, x) {
      var N = l.child;
      for (N !== null && (N.return = l); N !== null; ) {
        var R = N.dependencies;
        if (R !== null) {
          var H = N.child;
          R = R.firstContext;
          e: for (; R !== null; ) {
            var J = R;
            R = N;
            for (var re = 0; re < d.length; re++)
              if (J.context === d[re]) {
                R.lanes |= m, J = R.alternate, J !== null && (J.lanes |= m), _k(
                  R.return,
                  m,
                  l
                ), x || (H = null);
                break e;
              }
            R = J.next;
          }
        } else if (N.tag === 18) {
          if (H = N.return, H === null) throw Error(r(341));
          H.lanes |= m, R = H.alternate, R !== null && (R.lanes |= m), _k(H, m, l), H = null;
        } else H = N.child;
        if (H !== null) H.return = N;
        else
          for (H = N; H !== null; ) {
            if (H === l) {
              H = null;
              break;
            }
            if (N = H.sibling, N !== null) {
              N.return = H.return, H = N;
              break;
            }
            H = H.return;
          }
        N = H;
      }
    }
    function Ju(l, d, m, x) {
      l = null;
      for (var N = d, R = !1; N !== null; ) {
        if (!R) {
          if ((N.flags & 524288) !== 0) R = !0;
          else if ((N.flags & 262144) !== 0) break;
        }
        if (N.tag === 10) {
          var H = N.alternate;
          if (H === null) throw Error(r(387));
          if (H = H.memoizedProps, H !== null) {
            var J = N.type;
            Xr(N.pendingProps.value, H.value) || (l !== null ? l.push(J) : l = [J]);
          }
        } else if (N === ne.current) {
          if (H = N.alternate, H === null) throw Error(r(387));
          H.memoizedState.memoizedState !== N.memoizedState.memoizedState && (l !== null ? l.push(zf) : l = [zf]);
        }
        N = N.return;
      }
      l !== null && Ek(
        d,
        l,
        m,
        x
      ), d.flags |= 262144;
    }
    function Qh(l) {
      for (l = l.firstContext; l !== null; ) {
        if (!Xr(
          l.context._currentValue,
          l.memoizedValue
        ))
          return !0;
        l = l.next;
      }
      return !1;
    }
    function Ml(l) {
      Nl = l, di = null, l = l.dependencies, l !== null && (l.firstContext = null);
    }
    function rr(l) {
      return lM(Nl, l);
    }
    function Zh(l, d) {
      return Nl === null && Ml(l), lM(l, d);
    }
    function lM(l, d) {
      var m = d._currentValue;
      if (d = { context: d, memoizedValue: m, next: null }, di === null) {
        if (l === null) throw Error(r(308));
        di = d, l.dependencies = { lanes: 0, firstContext: d }, l.flags |= 524288;
      } else di = di.next = d;
      return m;
    }
    var Iq = typeof AbortController < "u" ? AbortController : function() {
      var l = [], d = this.signal = {
        aborted: !1,
        addEventListener: function(m, x) {
          l.push(x);
        }
      };
      this.abort = function() {
        d.aborted = !0, l.forEach(function(m) {
          return m();
        });
      };
    }, Aq = e.unstable_scheduleCallback, $q = e.unstable_NormalPriority, Dn = {
      $$typeof: k,
      Consumer: null,
      Provider: null,
      _currentValue: null,
      _currentValue2: null,
      _threadCount: 0
    };
    function Ck() {
      return {
        controller: new Iq(),
        data: /* @__PURE__ */ new Map(),
        refCount: 0
      };
    }
    function mf(l) {
      l.refCount--, l.refCount === 0 && Aq($q, function() {
        l.controller.abort();
      });
    }
    var hf = null, Pk = 0, Qu = 0, Zu = null;
    function Dq(l, d) {
      if (hf === null) {
        var m = hf = [];
        Pk = 0, Qu = MS(), Zu = {
          status: "pending",
          value: void 0,
          then: function(x) {
            m.push(x);
          }
        };
      }
      return Pk++, d.then(uM, uM), d;
    }
    function uM() {
      if (--Pk === 0 && hf !== null) {
        Zu !== null && (Zu.status = "fulfilled");
        var l = hf;
        hf = null, Qu = 0, Zu = null;
        for (var d = 0; d < l.length; d++) (0, l[d])();
      }
    }
    function Lq(l, d) {
      var m = [], x = {
        status: "pending",
        value: null,
        reason: null,
        then: function(N) {
          m.push(N);
        }
      };
      return l.then(
        function() {
          x.status = "fulfilled", x.value = d;
          for (var N = 0; N < m.length; N++) (0, m[N])(d);
        },
        function(N) {
          for (x.status = "rejected", x.reason = N, N = 0; N < m.length; N++)
            (0, m[N])(void 0);
        }
      ), x;
    }
    var cM = B.S;
    B.S = function(l, d) {
      KR = Ee(), typeof d == "object" && d !== null && typeof d.then == "function" && Dq(l, d), cM !== null && cM(l, d);
    };
    var Rl = L(null);
    function Ok() {
      var l = Rl.current;
      return l !== null ? l : an.pooledCache;
    }
    function eg(l, d) {
      d === null ? T(Rl, Rl.current) : T(Rl, d.pool);
    }
    function dM() {
      var l = Ok();
      return l === null ? null : { parent: Dn._currentValue, pool: l };
    }
    var ec = Error(r(460)), Nk = Error(r(474)), tg = Error(r(542)), ng = { then: function() {
    } };
    function fM(l) {
      return l = l.status, l === "fulfilled" || l === "rejected";
    }
    function pM(l, d, m) {
      switch (m = l[m], m === void 0 ? l.push(d) : m !== d && (d.then(si, si), d = m), d.status) {
        case "fulfilled":
          return d.value;
        case "rejected":
          throw l = d.reason, hM(l), l;
        default:
          if (typeof d.status == "string") d.then(si, si);
          else {
            if (l = an, l !== null && 100 < l.shellSuspendCounter)
              throw Error(r(482));
            l = d, l.status = "pending", l.then(
              function(x) {
                if (d.status === "pending") {
                  var N = d;
                  N.status = "fulfilled", N.value = x;
                }
              },
              function(x) {
                if (d.status === "pending") {
                  var N = d;
                  N.status = "rejected", N.reason = x;
                }
              }
            );
          }
          switch (d.status) {
            case "fulfilled":
              return d.value;
            case "rejected":
              throw l = d.reason, hM(l), l;
          }
          throw Il = d, ec;
      }
    }
    function jl(l) {
      try {
        var d = l._init;
        return d(l._payload);
      } catch (m) {
        throw m !== null && typeof m == "object" && typeof m.then == "function" ? (Il = m, ec) : m;
      }
    }
    var Il = null;
    function mM() {
      if (Il === null) throw Error(r(459));
      var l = Il;
      return Il = null, l;
    }
    function hM(l) {
      if (l === ec || l === tg)
        throw Error(r(483));
    }
    var tc = null, gf = 0;
    function rg(l) {
      var d = gf;
      return gf += 1, tc === null && (tc = []), pM(tc, l, d);
    }
    function vf(l, d) {
      d = d.props.ref, l.ref = d !== void 0 ? d : null;
    }
    function og(l, d) {
      throw d.$$typeof === g ? Error(r(525)) : (l = Object.prototype.toString.call(d), Error(
        r(
          31,
          l === "[object Object]" ? "object with keys {" + Object.keys(d).join(", ") + "}" : l
        )
      ));
    }
    function gM(l) {
      function d(ue, se) {
        if (l) {
          var de = ue.deletions;
          de === null ? (ue.deletions = [se], ue.flags |= 16) : de.push(se);
        }
      }
      function m(ue, se) {
        if (!l) return null;
        for (; se !== null; )
          d(ue, se), se = se.sibling;
        return null;
      }
      function x(ue) {
        for (var se = /* @__PURE__ */ new Map(); ue !== null; )
          ue.key !== null ? se.set(ue.key, ue) : se.set(ue.index, ue), ue = ue.sibling;
        return se;
      }
      function N(ue, se) {
        return ue = ui(ue, se), ue.index = 0, ue.sibling = null, ue;
      }
      function R(ue, se, de) {
        return ue.index = de, l ? (de = ue.alternate, de !== null ? (de = de.index, de < se ? (ue.flags |= 67108866, se) : de) : (ue.flags |= 67108866, se)) : (ue.flags |= 1048576, se);
      }
      function H(ue) {
        return l && ue.alternate === null && (ue.flags |= 67108866), ue;
      }
      function J(ue, se, de, we) {
        return se === null || se.tag !== 6 ? (se = vk(de, ue.mode, we), se.return = ue, se) : (se = N(se, de), se.return = ue, se);
      }
      function re(ue, se, de, we) {
        var We = de.type;
        return We === b ? ve(
          ue,
          se,
          de.props.children,
          we,
          de.key
        ) : se !== null && (se.elementType === We || typeof We == "object" && We !== null && We.$$typeof === I && jl(We) === se.type) ? (se = N(se, de.props), vf(se, de), se.return = ue, se) : (se = Yh(
          de.type,
          de.key,
          de.props,
          null,
          ue.mode,
          we
        ), vf(se, de), se.return = ue, se);
      }
      function fe(ue, se, de, we) {
        return se === null || se.tag !== 4 || se.stateNode.containerInfo !== de.containerInfo || se.stateNode.implementation !== de.implementation ? (se = yk(de, ue.mode, we), se.return = ue, se) : (se = N(se, de.children || []), se.return = ue, se);
      }
      function ve(ue, se, de, we, We) {
        return se === null || se.tag !== 7 ? (se = Pl(
          de,
          ue.mode,
          we,
          We
        ), se.return = ue, se) : (se = N(se, de), se.return = ue, se);
      }
      function xe(ue, se, de) {
        if (typeof se == "string" && se !== "" || typeof se == "number" || typeof se == "bigint")
          return se = vk(
            "" + se,
            ue.mode,
            de
          ), se.return = ue, se;
        if (typeof se == "object" && se !== null) {
          switch (se.$$typeof) {
            case h:
              return de = Yh(
                se.type,
                se.key,
                se.props,
                null,
                ue.mode,
                de
              ), vf(de, se), de.return = ue, de;
            case y:
              return se = yk(
                se,
                ue.mode,
                de
              ), se.return = ue, se;
            case I:
              return se = jl(se), xe(ue, se, de);
          }
          if (q(se) || j(se))
            return se = Pl(
              se,
              ue.mode,
              de,
              null
            ), se.return = ue, se;
          if (typeof se.then == "function")
            return xe(ue, rg(se), de);
          if (se.$$typeof === k)
            return xe(
              ue,
              Zh(ue, se),
              de
            );
          og(ue, se);
        }
        return null;
      }
      function pe(ue, se, de, we) {
        var We = se !== null ? se.key : null;
        if (typeof de == "string" && de !== "" || typeof de == "number" || typeof de == "bigint")
          return We !== null ? null : J(ue, se, "" + de, we);
        if (typeof de == "object" && de !== null) {
          switch (de.$$typeof) {
            case h:
              return de.key === We ? re(ue, se, de, we) : null;
            case y:
              return de.key === We ? fe(ue, se, de, we) : null;
            case I:
              return de = jl(de), pe(ue, se, de, we);
          }
          if (q(de) || j(de))
            return We !== null ? null : ve(ue, se, de, we, null);
          if (typeof de.then == "function")
            return pe(
              ue,
              se,
              rg(de),
              we
            );
          if (de.$$typeof === k)
            return pe(
              ue,
              se,
              Zh(ue, de),
              we
            );
          og(ue, de);
        }
        return null;
      }
      function ge(ue, se, de, we, We) {
        if (typeof we == "string" && we !== "" || typeof we == "number" || typeof we == "bigint")
          return ue = ue.get(de) || null, J(se, ue, "" + we, We);
        if (typeof we == "object" && we !== null) {
          switch (we.$$typeof) {
            case h:
              return ue = ue.get(
                we.key === null ? de : we.key
              ) || null, re(se, ue, we, We);
            case y:
              return ue = ue.get(
                we.key === null ? de : we.key
              ) || null, fe(se, ue, we, We);
            case I:
              return we = jl(we), ge(
                ue,
                se,
                de,
                we,
                We
              );
          }
          if (q(we) || j(we))
            return ue = ue.get(de) || null, ve(se, ue, we, We, null);
          if (typeof we.then == "function")
            return ge(
              ue,
              se,
              de,
              rg(we),
              We
            );
          if (we.$$typeof === k)
            return ge(
              ue,
              se,
              de,
              Zh(se, we),
              We
            );
          og(se, we);
        }
        return null;
      }
      function Fe(ue, se, de, we) {
        for (var We = null, $t = null, Be = se, ut = se = 0, _t = null; Be !== null && ut < de.length; ut++) {
          Be.index > ut ? (_t = Be, Be = null) : _t = Be.sibling;
          var Dt = pe(
            ue,
            Be,
            de[ut],
            we
          );
          if (Dt === null) {
            Be === null && (Be = _t);
            break;
          }
          l && Be && Dt.alternate === null && d(ue, Be), se = R(Dt, se, ut), $t === null ? We = Dt : $t.sibling = Dt, $t = Dt, Be = _t;
        }
        if (ut === de.length)
          return m(ue, Be), Pt && ci(ue, ut), We;
        if (Be === null) {
          for (; ut < de.length; ut++)
            Be = xe(ue, de[ut], we), Be !== null && (se = R(
              Be,
              se,
              ut
            ), $t === null ? We = Be : $t.sibling = Be, $t = Be);
          return Pt && ci(ue, ut), We;
        }
        for (Be = x(Be); ut < de.length; ut++)
          _t = ge(
            Be,
            ue,
            ut,
            de[ut],
            we
          ), _t !== null && (l && _t.alternate !== null && Be.delete(
            _t.key === null ? ut : _t.key
          ), se = R(
            _t,
            se,
            ut
          ), $t === null ? We = _t : $t.sibling = _t, $t = _t);
        return l && Be.forEach(function($s) {
          return d(ue, $s);
        }), Pt && ci(ue, ut), We;
      }
      function Ze(ue, se, de, we) {
        if (de == null) throw Error(r(151));
        for (var We = null, $t = null, Be = se, ut = se = 0, _t = null, Dt = de.next(); Be !== null && !Dt.done; ut++, Dt = de.next()) {
          Be.index > ut ? (_t = Be, Be = null) : _t = Be.sibling;
          var $s = pe(ue, Be, Dt.value, we);
          if ($s === null) {
            Be === null && (Be = _t);
            break;
          }
          l && Be && $s.alternate === null && d(ue, Be), se = R($s, se, ut), $t === null ? We = $s : $t.sibling = $s, $t = $s, Be = _t;
        }
        if (Dt.done)
          return m(ue, Be), Pt && ci(ue, ut), We;
        if (Be === null) {
          for (; !Dt.done; ut++, Dt = de.next())
            Dt = xe(ue, Dt.value, we), Dt !== null && (se = R(Dt, se, ut), $t === null ? We = Dt : $t.sibling = Dt, $t = Dt);
          return Pt && ci(ue, ut), We;
        }
        for (Be = x(Be); !Dt.done; ut++, Dt = de.next())
          Dt = ge(Be, ue, ut, Dt.value, we), Dt !== null && (l && Dt.alternate !== null && Be.delete(Dt.key === null ? ut : Dt.key), se = R(Dt, se, ut), $t === null ? We = Dt : $t.sibling = Dt, $t = Dt);
        return l && Be.forEach(function(GK) {
          return d(ue, GK);
        }), Pt && ci(ue, ut), We;
      }
      function tn(ue, se, de, we) {
        if (typeof de == "object" && de !== null && de.type === b && de.key === null && (de = de.props.children), typeof de == "object" && de !== null) {
          switch (de.$$typeof) {
            case h:
              e: {
                for (var We = de.key; se !== null; ) {
                  if (se.key === We) {
                    if (We = de.type, We === b) {
                      if (se.tag === 7) {
                        m(
                          ue,
                          se.sibling
                        ), we = N(
                          se,
                          de.props.children
                        ), we.return = ue, ue = we;
                        break e;
                      }
                    } else if (se.elementType === We || typeof We == "object" && We !== null && We.$$typeof === I && jl(We) === se.type) {
                      m(
                        ue,
                        se.sibling
                      ), we = N(se, de.props), vf(we, de), we.return = ue, ue = we;
                      break e;
                    }
                    m(ue, se);
                    break;
                  } else d(ue, se);
                  se = se.sibling;
                }
                de.type === b ? (we = Pl(
                  de.props.children,
                  ue.mode,
                  we,
                  de.key
                ), we.return = ue, ue = we) : (we = Yh(
                  de.type,
                  de.key,
                  de.props,
                  null,
                  ue.mode,
                  we
                ), vf(we, de), we.return = ue, ue = we);
              }
              return H(ue);
            case y:
              e: {
                for (We = de.key; se !== null; ) {
                  if (se.key === We)
                    if (se.tag === 4 && se.stateNode.containerInfo === de.containerInfo && se.stateNode.implementation === de.implementation) {
                      m(
                        ue,
                        se.sibling
                      ), we = N(se, de.children || []), we.return = ue, ue = we;
                      break e;
                    } else {
                      m(ue, se);
                      break;
                    }
                  else d(ue, se);
                  se = se.sibling;
                }
                we = yk(de, ue.mode, we), we.return = ue, ue = we;
              }
              return H(ue);
            case I:
              return de = jl(de), tn(
                ue,
                se,
                de,
                we
              );
          }
          if (q(de))
            return Fe(
              ue,
              se,
              de,
              we
            );
          if (j(de)) {
            if (We = j(de), typeof We != "function") throw Error(r(150));
            return de = We.call(de), Ze(
              ue,
              se,
              de,
              we
            );
          }
          if (typeof de.then == "function")
            return tn(
              ue,
              se,
              rg(de),
              we
            );
          if (de.$$typeof === k)
            return tn(
              ue,
              se,
              Zh(ue, de),
              we
            );
          og(ue, de);
        }
        return typeof de == "string" && de !== "" || typeof de == "number" || typeof de == "bigint" ? (de = "" + de, se !== null && se.tag === 6 ? (m(ue, se.sibling), we = N(se, de), we.return = ue, ue = we) : (m(ue, se), we = vk(de, ue.mode, we), we.return = ue, ue = we), H(ue)) : m(ue, se);
      }
      return function(ue, se, de, we) {
        try {
          gf = 0;
          var We = tn(
            ue,
            se,
            de,
            we
          );
          return tc = null, We;
        } catch (Be) {
          if (Be === ec || Be === tg) throw Be;
          var $t = Yr(29, Be, null, ue.mode);
          return $t.lanes = we, $t.return = ue, $t;
        }
      };
    }
    var Al = gM(!0), vM = gM(!1), ys = !1;
    function Mk(l) {
      l.updateQueue = {
        baseState: l.memoizedState,
        firstBaseUpdate: null,
        lastBaseUpdate: null,
        shared: { pending: null, lanes: 0, hiddenCallbacks: null },
        callbacks: null
      };
    }
    function Rk(l, d) {
      l = l.updateQueue, d.updateQueue === l && (d.updateQueue = {
        baseState: l.baseState,
        firstBaseUpdate: l.firstBaseUpdate,
        lastBaseUpdate: l.lastBaseUpdate,
        shared: l.shared,
        callbacks: null
      });
    }
    function bs(l) {
      return { lane: l, tag: 0, payload: null, callback: null, next: null };
    }
    function ws(l, d, m) {
      var x = l.updateQueue;
      if (x === null) return null;
      if (x = x.shared, (Tt & 2) !== 0) {
        var N = x.pending;
        return N === null ? d.next = d : (d.next = N.next, N.next = d), x.pending = d, d = Xh(l), eM(l, null, m), d;
      }
      return Gh(l, x, d, m), Xh(l);
    }
    function yf(l, d, m) {
      if (d = d.updateQueue, d !== null && (d = d.shared, (m & 4194048) !== 0)) {
        var x = d.lanes;
        x &= l.pendingLanes, m |= x, d.lanes = m, Ph(l, m);
      }
    }
    function jk(l, d) {
      var m = l.updateQueue, x = l.alternate;
      if (x !== null && (x = x.updateQueue, m === x)) {
        var N = null, R = null;
        if (m = m.firstBaseUpdate, m !== null) {
          do {
            var H = {
              lane: m.lane,
              tag: m.tag,
              payload: m.payload,
              callback: null,
              next: null
            };
            R === null ? N = R = H : R = R.next = H, m = m.next;
          } while (m !== null);
          R === null ? N = R = d : R = R.next = d;
        } else N = R = d;
        m = {
          baseState: x.baseState,
          firstBaseUpdate: N,
          lastBaseUpdate: R,
          shared: x.shared,
          callbacks: x.callbacks
        }, l.updateQueue = m;
        return;
      }
      l = m.lastBaseUpdate, l === null ? m.firstBaseUpdate = d : l.next = d, m.lastBaseUpdate = d;
    }
    var Ik = !1;
    function bf() {
      if (Ik) {
        var l = Zu;
        if (l !== null) throw l;
      }
    }
    function wf(l, d, m, x) {
      Ik = !1;
      var N = l.updateQueue;
      ys = !1;
      var R = N.firstBaseUpdate, H = N.lastBaseUpdate, J = N.shared.pending;
      if (J !== null) {
        N.shared.pending = null;
        var re = J, fe = re.next;
        re.next = null, H === null ? R = fe : H.next = fe, H = re;
        var ve = l.alternate;
        ve !== null && (ve = ve.updateQueue, J = ve.lastBaseUpdate, J !== H && (J === null ? ve.firstBaseUpdate = fe : J.next = fe, ve.lastBaseUpdate = re));
      }
      if (R !== null) {
        var xe = N.baseState;
        H = 0, ve = fe = re = null, J = R;
        do {
          var pe = J.lane & -536870913, ge = pe !== J.lane;
          if (ge ? (St & pe) === pe : (x & pe) === pe) {
            pe !== 0 && pe === Qu && (Ik = !0), ve !== null && (ve = ve.next = {
              lane: 0,
              tag: J.tag,
              payload: J.payload,
              callback: null,
              next: null
            });
            e: {
              var Fe = l, Ze = J;
              pe = d;
              var tn = m;
              switch (Ze.tag) {
                case 1:
                  if (Fe = Ze.payload, typeof Fe == "function") {
                    xe = Fe.call(tn, xe, pe);
                    break e;
                  }
                  xe = Fe;
                  break e;
                case 3:
                  Fe.flags = Fe.flags & -65537 | 128;
                case 0:
                  if (Fe = Ze.payload, pe = typeof Fe == "function" ? Fe.call(tn, xe, pe) : Fe, pe == null) break e;
                  xe = p({}, xe, pe);
                  break e;
                case 2:
                  ys = !0;
              }
            }
            pe = J.callback, pe !== null && (l.flags |= 64, ge && (l.flags |= 8192), ge = N.callbacks, ge === null ? N.callbacks = [pe] : ge.push(pe));
          } else
            ge = {
              lane: pe,
              tag: J.tag,
              payload: J.payload,
              callback: J.callback,
              next: null
            }, ve === null ? (fe = ve = ge, re = xe) : ve = ve.next = ge, H |= pe;
          if (J = J.next, J === null) {
            if (J = N.shared.pending, J === null)
              break;
            ge = J, J = ge.next, ge.next = null, N.lastBaseUpdate = ge, N.shared.pending = null;
          }
        } while (!0);
        ve === null && (re = xe), N.baseState = re, N.firstBaseUpdate = fe, N.lastBaseUpdate = ve, R === null && (N.shared.lanes = 0), Es |= H, l.lanes = H, l.memoizedState = xe;
      }
    }
    function yM(l, d) {
      if (typeof l != "function")
        throw Error(r(191, l));
      l.call(d);
    }
    function bM(l, d) {
      var m = l.callbacks;
      if (m !== null)
        for (l.callbacks = null, l = 0; l < m.length; l++)
          yM(m[l], d);
    }
    var nc = L(null), ag = L(0);
    function wM(l, d) {
      l = xi, T(ag, l), T(nc, d), xi = l | d.baseLanes;
    }
    function Ak() {
      T(ag, xi), T(nc, nc.current);
    }
    function $k() {
      xi = ag.current, K(nc), K(ag);
    }
    var Jr = L(null), Vo = null;
    function xs(l) {
      var d = l.alternate;
      T(Rn, Rn.current & 1), T(Jr, l), Vo === null && (d === null || nc.current !== null || d.memoizedState !== null) && (Vo = l);
    }
    function Dk(l) {
      T(Rn, Rn.current), T(Jr, l), Vo === null && (Vo = l);
    }
    function xM(l) {
      l.tag === 22 ? (T(Rn, Rn.current), T(Jr, l), Vo === null && (Vo = l)) : ks();
    }
    function ks() {
      T(Rn, Rn.current), T(Jr, Jr.current);
    }
    function Qr(l) {
      K(Jr), Vo === l && (Vo = null), K(Rn);
    }
    var Rn = L(0);
    function ig(l) {
      for (var d = l; d !== null; ) {
        if (d.tag === 13) {
          var m = d.memoizedState;
          if (m !== null && (m = m.dehydrated, m === null || VS(m) || US(m)))
            return d;
        } else if (d.tag === 19 && (d.memoizedProps.revealOrder === "forwards" || d.memoizedProps.revealOrder === "backwards" || d.memoizedProps.revealOrder === "unstable_legacy-backwards" || d.memoizedProps.revealOrder === "together")) {
          if ((d.flags & 128) !== 0) return d;
        } else if (d.child !== null) {
          d.child.return = d, d = d.child;
          continue;
        }
        if (d === l) break;
        for (; d.sibling === null; ) {
          if (d.return === null || d.return === l) return null;
          d = d.return;
        }
        d.sibling.return = d.return, d = d.sibling;
      }
      return null;
    }
    var pi = 0, it = null, Zt = null, Ln = null, sg = !1, rc = !1, $l = !1, lg = 0, xf = 0, oc = null, Fq = 0;
    function En() {
      throw Error(r(321));
    }
    function Lk(l, d) {
      if (d === null) return !1;
      for (var m = 0; m < d.length && m < l.length; m++)
        if (!Xr(l[m], d[m])) return !1;
      return !0;
    }
    function Fk(l, d, m, x, N, R) {
      return pi = R, it = d, d.memoizedState = null, d.updateQueue = null, d.lanes = 0, B.H = l === null || l.memoizedState === null ? oR : Zk, $l = !1, R = m(x, N), $l = !1, rc && (R = SM(
        d,
        m,
        x,
        N
      )), kM(l), R;
    }
    function kM(l) {
      B.H = _f;
      var d = Zt !== null && Zt.next !== null;
      if (pi = 0, Ln = Zt = it = null, sg = !1, xf = 0, oc = null, d) throw Error(r(300));
      l === null || Fn || (l = l.dependencies, l !== null && Qh(l) && (Fn = !0));
    }
    function SM(l, d, m, x) {
      it = l;
      var N = 0;
      do {
        if (rc && (oc = null), xf = 0, rc = !1, 25 <= N) throw Error(r(301));
        if (N += 1, Ln = Zt = null, l.updateQueue != null) {
          var R = l.updateQueue;
          R.lastEffect = null, R.events = null, R.stores = null, R.memoCache != null && (R.memoCache.index = 0);
        }
        B.H = aR, R = d(m, x);
      } while (rc);
      return R;
    }
    function Tq() {
      var l = B.H, d = l.useState()[0];
      return d = typeof d.then == "function" ? kf(d) : d, l = l.useState()[0], (Zt !== null ? Zt.memoizedState : null) !== l && (it.flags |= 1024), d;
    }
    function Tk() {
      var l = lg !== 0;
      return lg = 0, l;
    }
    function zk(l, d, m) {
      d.updateQueue = l.updateQueue, d.flags &= -2053, l.lanes &= ~m;
    }
    function Bk(l) {
      if (sg) {
        for (l = l.memoizedState; l !== null; ) {
          var d = l.queue;
          d !== null && (d.pending = null), l = l.next;
        }
        sg = !1;
      }
      pi = 0, Ln = Zt = it = null, rc = !1, xf = lg = 0, oc = null;
    }
    function _r() {
      var l = {
        memoizedState: null,
        baseState: null,
        baseQueue: null,
        queue: null,
        next: null
      };
      return Ln === null ? it.memoizedState = Ln = l : Ln = Ln.next = l, Ln;
    }
    function jn() {
      if (Zt === null) {
        var l = it.alternate;
        l = l !== null ? l.memoizedState : null;
      } else l = Zt.next;
      var d = Ln === null ? it.memoizedState : Ln.next;
      if (d !== null)
        Ln = d, Zt = l;
      else {
        if (l === null)
          throw it.alternate === null ? Error(r(467)) : Error(r(310));
        Zt = l, l = {
          memoizedState: Zt.memoizedState,
          baseState: Zt.baseState,
          baseQueue: Zt.baseQueue,
          queue: Zt.queue,
          next: null
        }, Ln === null ? it.memoizedState = Ln = l : Ln = Ln.next = l;
      }
      return Ln;
    }
    function ug() {
      return { lastEffect: null, events: null, stores: null, memoCache: null };
    }
    function kf(l) {
      var d = xf;
      return xf += 1, oc === null && (oc = []), l = pM(oc, l, d), d = it, (Ln === null ? d.memoizedState : Ln.next) === null && (d = d.alternate, B.H = d === null || d.memoizedState === null ? oR : Zk), l;
    }
    function cg(l) {
      if (l !== null && typeof l == "object") {
        if (typeof l.then == "function") return kf(l);
        if (l.$$typeof === k) return rr(l);
      }
      throw Error(r(438, String(l)));
    }
    function Vk(l) {
      var d = null, m = it.updateQueue;
      if (m !== null && (d = m.memoCache), d == null) {
        var x = it.alternate;
        x !== null && (x = x.updateQueue, x !== null && (x = x.memoCache, x != null && (d = {
          data: x.data.map(function(N) {
            return N.slice();
          }),
          index: 0
        })));
      }
      if (d == null && (d = { data: [], index: 0 }), m === null && (m = ug(), it.updateQueue = m), m.memoCache = d, m = d.data[d.index], m === void 0)
        for (m = d.data[d.index] = Array(l), x = 0; x < l; x++)
          m[x] = D;
      return d.index++, m;
    }
    function mi(l, d) {
      return typeof d == "function" ? d(l) : d;
    }
    function dg(l) {
      var d = jn();
      return Uk(d, Zt, l);
    }
    function Uk(l, d, m) {
      var x = l.queue;
      if (x === null) throw Error(r(311));
      x.lastRenderedReducer = m;
      var N = l.baseQueue, R = x.pending;
      if (R !== null) {
        if (N !== null) {
          var H = N.next;
          N.next = R.next, R.next = H;
        }
        d.baseQueue = N = R, x.pending = null;
      }
      if (R = l.baseState, N === null) l.memoizedState = R;
      else {
        d = N.next;
        var J = H = null, re = null, fe = d, ve = !1;
        do {
          var xe = fe.lane & -536870913;
          if (xe !== fe.lane ? (St & xe) === xe : (pi & xe) === xe) {
            var pe = fe.revertLane;
            if (pe === 0)
              re !== null && (re = re.next = {
                lane: 0,
                revertLane: 0,
                gesture: null,
                action: fe.action,
                hasEagerState: fe.hasEagerState,
                eagerState: fe.eagerState,
                next: null
              }), xe === Qu && (ve = !0);
            else if ((pi & pe) === pe) {
              fe = fe.next, pe === Qu && (ve = !0);
              continue;
            } else
              xe = {
                lane: 0,
                revertLane: fe.revertLane,
                gesture: null,
                action: fe.action,
                hasEagerState: fe.hasEagerState,
                eagerState: fe.eagerState,
                next: null
              }, re === null ? (J = re = xe, H = R) : re = re.next = xe, it.lanes |= pe, Es |= pe;
            xe = fe.action, $l && m(R, xe), R = fe.hasEagerState ? fe.eagerState : m(R, xe);
          } else
            pe = {
              lane: xe,
              revertLane: fe.revertLane,
              gesture: fe.gesture,
              action: fe.action,
              hasEagerState: fe.hasEagerState,
              eagerState: fe.eagerState,
              next: null
            }, re === null ? (J = re = pe, H = R) : re = re.next = pe, it.lanes |= xe, Es |= xe;
          fe = fe.next;
        } while (fe !== null && fe !== d);
        if (re === null ? H = R : re.next = J, !Xr(R, l.memoizedState) && (Fn = !0, ve && (m = Zu, m !== null)))
          throw m;
        l.memoizedState = R, l.baseState = H, l.baseQueue = re, x.lastRenderedState = R;
      }
      return N === null && (x.lanes = 0), [l.memoizedState, x.dispatch];
    }
    function Hk(l) {
      var d = jn(), m = d.queue;
      if (m === null) throw Error(r(311));
      m.lastRenderedReducer = l;
      var x = m.dispatch, N = m.pending, R = d.memoizedState;
      if (N !== null) {
        m.pending = null;
        var H = N = N.next;
        do
          R = l(R, H.action), H = H.next;
        while (H !== N);
        Xr(R, d.memoizedState) || (Fn = !0), d.memoizedState = R, d.baseQueue === null && (d.baseState = R), m.lastRenderedState = R;
      }
      return [R, x];
    }
    function _M(l, d, m) {
      var x = it, N = jn(), R = Pt;
      if (R) {
        if (m === void 0) throw Error(r(407));
        m = m();
      } else m = d();
      var H = !Xr(
        (Zt || N).memoizedState,
        m
      );
      if (H && (N.memoizedState = m, Fn = !0), N = N.queue, Kk(PM.bind(null, x, N, l), [
        l
      ]), N.getSnapshot !== d || H || Ln !== null && Ln.memoizedState.tag & 1) {
        if (x.flags |= 2048, ac(
          9,
          { destroy: void 0 },
          CM.bind(
            null,
            x,
            N,
            m,
            d
          ),
          null
        ), an === null) throw Error(r(349));
        R || (pi & 127) !== 0 || EM(x, d, m);
      }
      return m;
    }
    function EM(l, d, m) {
      l.flags |= 16384, l = { getSnapshot: d, value: m }, d = it.updateQueue, d === null ? (d = ug(), it.updateQueue = d, d.stores = [l]) : (m = d.stores, m === null ? d.stores = [l] : m.push(l));
    }
    function CM(l, d, m, x) {
      d.value = m, d.getSnapshot = x, OM(d) && NM(l);
    }
    function PM(l, d, m) {
      return m(function() {
        OM(d) && NM(l);
      });
    }
    function OM(l) {
      var d = l.getSnapshot;
      l = l.value;
      try {
        var m = d();
        return !Xr(l, m);
      } catch {
        return !0;
      }
    }
    function NM(l) {
      var d = Cl(l, 2);
      d !== null && Fr(d, l, 2);
    }
    function Wk(l) {
      var d = _r();
      if (typeof l == "function") {
        var m = l;
        if (l = m(), $l) {
          Mn(!0);
          try {
            m();
          } finally {
            Mn(!1);
          }
        }
      }
      return d.memoizedState = d.baseState = l, d.queue = {
        pending: null,
        lanes: 0,
        dispatch: null,
        lastRenderedReducer: mi,
        lastRenderedState: l
      }, d;
    }
    function MM(l, d, m, x) {
      return l.baseState = m, Uk(
        l,
        Zt,
        typeof x == "function" ? x : mi
      );
    }
    function zq(l, d, m, x, N) {
      if (mg(l)) throw Error(r(485));
      if (l = d.action, l !== null) {
        var R = {
          payload: N,
          action: l,
          next: null,
          isTransition: !0,
          status: "pending",
          value: null,
          reason: null,
          listeners: [],
          then: function(H) {
            R.listeners.push(H);
          }
        };
        B.T !== null ? m(!0) : R.isTransition = !1, x(R), m = d.pending, m === null ? (R.next = d.pending = R, RM(d, R)) : (R.next = m.next, d.pending = m.next = R);
      }
    }
    function RM(l, d) {
      var m = d.action, x = d.payload, N = l.state;
      if (d.isTransition) {
        var R = B.T, H = {};
        B.T = H;
        try {
          var J = m(N, x), re = B.S;
          re !== null && re(H, J), jM(l, d, J);
        } catch (fe) {
          qk(l, d, fe);
        } finally {
          R !== null && H.types !== null && (R.types = H.types), B.T = R;
        }
      } else
        try {
          R = m(N, x), jM(l, d, R);
        } catch (fe) {
          qk(l, d, fe);
        }
    }
    function jM(l, d, m) {
      m !== null && typeof m == "object" && typeof m.then == "function" ? m.then(
        function(x) {
          IM(l, d, x);
        },
        function(x) {
          return qk(l, d, x);
        }
      ) : IM(l, d, m);
    }
    function IM(l, d, m) {
      d.status = "fulfilled", d.value = m, AM(d), l.state = m, d = l.pending, d !== null && (m = d.next, m === d ? l.pending = null : (m = m.next, d.next = m, RM(l, m)));
    }
    function qk(l, d, m) {
      var x = l.pending;
      if (l.pending = null, x !== null) {
        x = x.next;
        do
          d.status = "rejected", d.reason = m, AM(d), d = d.next;
        while (d !== x);
      }
      l.action = null;
    }
    function AM(l) {
      l = l.listeners;
      for (var d = 0; d < l.length; d++) (0, l[d])();
    }
    function $M(l, d) {
      return d;
    }
    function DM(l, d) {
      if (Pt) {
        var m = an.formState;
        if (m !== null) {
          e: {
            var x = it;
            if (Pt) {
              if (pn) {
                t: {
                  for (var N = pn, R = ko; N.nodeType !== 8; ) {
                    if (!R) {
                      N = null;
                      break t;
                    }
                    if (N = So(
                      N.nextSibling
                    ), N === null) {
                      N = null;
                      break t;
                    }
                  }
                  R = N.data, N = R === "F!" || R === "F" ? N : null;
                }
                if (N) {
                  pn = So(
                    N.nextSibling
                  ), x = N.data === "F!";
                  break e;
                }
              }
              gs(x);
            }
            x = !1;
          }
          x && (d = m[0]);
        }
      }
      return m = _r(), m.memoizedState = m.baseState = d, x = {
        pending: null,
        lanes: 0,
        dispatch: null,
        lastRenderedReducer: $M,
        lastRenderedState: d
      }, m.queue = x, m = tR.bind(
        null,
        it,
        x
      ), x.dispatch = m, x = Wk(!1), R = Qk.bind(
        null,
        it,
        !1,
        x.queue
      ), x = _r(), N = {
        state: d,
        dispatch: null,
        action: l,
        pending: null
      }, x.queue = N, m = zq.bind(
        null,
        it,
        N,
        R,
        m
      ), N.dispatch = m, x.memoizedState = l, [d, m, !1];
    }
    function LM(l) {
      var d = jn();
      return FM(d, Zt, l);
    }
    function FM(l, d, m) {
      if (d = Uk(
        l,
        d,
        $M
      )[0], l = dg(mi)[0], typeof d == "object" && d !== null && typeof d.then == "function")
        try {
          var x = kf(d);
        } catch (H) {
          throw H === ec ? tg : H;
        }
      else x = d;
      d = jn();
      var N = d.queue, R = N.dispatch;
      return m !== d.memoizedState && (it.flags |= 2048, ac(
        9,
        { destroy: void 0 },
        Bq.bind(null, N, m),
        null
      )), [x, R, l];
    }
    function Bq(l, d) {
      l.action = d;
    }
    function TM(l) {
      var d = jn(), m = Zt;
      if (m !== null)
        return FM(d, m, l);
      jn(), d = d.memoizedState, m = jn();
      var x = m.queue.dispatch;
      return m.memoizedState = l, [d, x, !1];
    }
    function ac(l, d, m, x) {
      return l = { tag: l, create: m, deps: x, inst: d, next: null }, d = it.updateQueue, d === null && (d = ug(), it.updateQueue = d), m = d.lastEffect, m === null ? d.lastEffect = l.next = l : (x = m.next, m.next = l, l.next = x, d.lastEffect = l), l;
    }
    function zM() {
      return jn().memoizedState;
    }
    function fg(l, d, m, x) {
      var N = _r();
      it.flags |= l, N.memoizedState = ac(
        1 | d,
        { destroy: void 0 },
        m,
        x === void 0 ? null : x
      );
    }
    function pg(l, d, m, x) {
      var N = jn();
      x = x === void 0 ? null : x;
      var R = N.memoizedState.inst;
      Zt !== null && x !== null && Lk(x, Zt.memoizedState.deps) ? N.memoizedState = ac(d, R, m, x) : (it.flags |= l, N.memoizedState = ac(
        1 | d,
        R,
        m,
        x
      ));
    }
    function BM(l, d) {
      fg(8390656, 8, l, d);
    }
    function Kk(l, d) {
      pg(2048, 8, l, d);
    }
    function Vq(l) {
      it.flags |= 4;
      var d = it.updateQueue;
      if (d === null)
        d = ug(), it.updateQueue = d, d.events = [l];
      else {
        var m = d.events;
        m === null ? d.events = [l] : m.push(l);
      }
    }
    function VM(l) {
      var d = jn().memoizedState;
      return Vq({ ref: d, nextImpl: l }), function() {
        if ((Tt & 2) !== 0) throw Error(r(440));
        return d.impl.apply(void 0, arguments);
      };
    }
    function UM(l, d) {
      return pg(4, 2, l, d);
    }
    function HM(l, d) {
      return pg(4, 4, l, d);
    }
    function WM(l, d) {
      if (typeof d == "function") {
        l = l();
        var m = d(l);
        return function() {
          typeof m == "function" ? m() : d(null);
        };
      }
      if (d != null)
        return l = l(), d.current = l, function() {
          d.current = null;
        };
    }
    function qM(l, d, m) {
      m = m != null ? m.concat([l]) : null, pg(4, 4, WM.bind(null, d, l), m);
    }
    function Gk() {
    }
    function KM(l, d) {
      var m = jn();
      d = d === void 0 ? null : d;
      var x = m.memoizedState;
      return d !== null && Lk(d, x[1]) ? x[0] : (m.memoizedState = [l, d], l);
    }
    function GM(l, d) {
      var m = jn();
      d = d === void 0 ? null : d;
      var x = m.memoizedState;
      if (d !== null && Lk(d, x[1]))
        return x[0];
      if (x = l(), $l) {
        Mn(!0);
        try {
          l();
        } finally {
          Mn(!1);
        }
      }
      return m.memoizedState = [x, d], x;
    }
    function Xk(l, d, m) {
      return m === void 0 || (pi & 1073741824) !== 0 && (St & 261930) === 0 ? l.memoizedState = d : (l.memoizedState = m, l = XR(), it.lanes |= l, Es |= l, m);
    }
    function XM(l, d, m, x) {
      return Xr(m, d) ? m : nc.current !== null ? (l = Xk(l, m, x), Xr(l, d) || (Fn = !0), l) : (pi & 42) === 0 || (pi & 1073741824) !== 0 && (St & 261930) === 0 ? (Fn = !0, l.memoizedState = m) : (l = XR(), it.lanes |= l, Es |= l, d);
    }
    function YM(l, d, m, x, N) {
      var R = G.p;
      G.p = R !== 0 && 8 > R ? R : 8;
      var H = B.T, J = {};
      B.T = J, Qk(l, !1, d, m);
      try {
        var re = N(), fe = B.S;
        if (fe !== null && fe(J, re), re !== null && typeof re == "object" && typeof re.then == "function") {
          var ve = Lq(
            re,
            x
          );
          Sf(
            l,
            d,
            ve,
            to(l)
          );
        } else
          Sf(
            l,
            d,
            x,
            to(l)
          );
      } catch (xe) {
        Sf(
          l,
          d,
          { then: function() {
          }, status: "rejected", reason: xe },
          to()
        );
      } finally {
        G.p = R, H !== null && J.types !== null && (H.types = J.types), B.T = H;
      }
    }
    function Uq() {
    }
    function Yk(l, d, m, x) {
      if (l.tag !== 5) throw Error(r(476));
      var N = JM(l).queue;
      YM(
        l,
        N,
        d,
        W,
        m === null ? Uq : function() {
          return QM(l), m(x);
        }
      );
    }
    function JM(l) {
      var d = l.memoizedState;
      if (d !== null) return d;
      d = {
        memoizedState: W,
        baseState: W,
        baseQueue: null,
        queue: {
          pending: null,
          lanes: 0,
          dispatch: null,
          lastRenderedReducer: mi,
          lastRenderedState: W
        },
        next: null
      };
      var m = {};
      return d.next = {
        memoizedState: m,
        baseState: m,
        baseQueue: null,
        queue: {
          pending: null,
          lanes: 0,
          dispatch: null,
          lastRenderedReducer: mi,
          lastRenderedState: m
        },
        next: null
      }, l.memoizedState = d, l = l.alternate, l !== null && (l.memoizedState = d), d;
    }
    function QM(l) {
      var d = JM(l);
      d.next === null && (d = l.alternate.memoizedState), Sf(
        l,
        d.next.queue,
        {},
        to()
      );
    }
    function Jk() {
      return rr(zf);
    }
    function ZM() {
      return jn().memoizedState;
    }
    function eR() {
      return jn().memoizedState;
    }
    function Hq(l) {
      for (var d = l.return; d !== null; ) {
        switch (d.tag) {
          case 24:
          case 3:
            var m = to();
            l = bs(m);
            var x = ws(d, l, m);
            x !== null && (Fr(x, d, m), yf(x, d, m)), d = { cache: Ck() }, l.payload = d;
            return;
        }
        d = d.return;
      }
    }
    function Wq(l, d, m) {
      var x = to();
      m = {
        lane: x,
        revertLane: 0,
        gesture: null,
        action: m,
        hasEagerState: !1,
        eagerState: null,
        next: null
      }, mg(l) ? nR(d, m) : (m = hk(l, d, m, x), m !== null && (Fr(m, l, x), rR(m, d, x)));
    }
    function tR(l, d, m) {
      var x = to();
      Sf(l, d, m, x);
    }
    function Sf(l, d, m, x) {
      var N = {
        lane: x,
        revertLane: 0,
        gesture: null,
        action: m,
        hasEagerState: !1,
        eagerState: null,
        next: null
      };
      if (mg(l)) nR(d, N);
      else {
        var R = l.alternate;
        if (l.lanes === 0 && (R === null || R.lanes === 0) && (R = d.lastRenderedReducer, R !== null))
          try {
            var H = d.lastRenderedState, J = R(H, m);
            if (N.hasEagerState = !0, N.eagerState = J, Xr(J, H))
              return Gh(l, d, N, 0), an === null && Kh(), !1;
          } catch {
          }
        if (m = hk(l, d, N, x), m !== null)
          return Fr(m, l, x), rR(m, d, x), !0;
      }
      return !1;
    }
    function Qk(l, d, m, x) {
      if (x = {
        lane: 2,
        revertLane: MS(),
        gesture: null,
        action: x,
        hasEagerState: !1,
        eagerState: null,
        next: null
      }, mg(l)) {
        if (d) throw Error(r(479));
      } else
        d = hk(
          l,
          m,
          x,
          2
        ), d !== null && Fr(d, l, 2);
    }
    function mg(l) {
      var d = l.alternate;
      return l === it || d !== null && d === it;
    }
    function nR(l, d) {
      rc = sg = !0;
      var m = l.pending;
      m === null ? d.next = d : (d.next = m.next, m.next = d), l.pending = d;
    }
    function rR(l, d, m) {
      if ((m & 4194048) !== 0) {
        var x = d.lanes;
        x &= l.pendingLanes, m |= x, d.lanes = m, Ph(l, m);
      }
    }
    var _f = {
      readContext: rr,
      use: cg,
      useCallback: En,
      useContext: En,
      useEffect: En,
      useImperativeHandle: En,
      useLayoutEffect: En,
      useInsertionEffect: En,
      useMemo: En,
      useReducer: En,
      useRef: En,
      useState: En,
      useDebugValue: En,
      useDeferredValue: En,
      useTransition: En,
      useSyncExternalStore: En,
      useId: En,
      useHostTransitionStatus: En,
      useFormState: En,
      useActionState: En,
      useOptimistic: En,
      useMemoCache: En,
      useCacheRefresh: En
    };
    _f.useEffectEvent = En;
    var oR = {
      readContext: rr,
      use: cg,
      useCallback: function(l, d) {
        return _r().memoizedState = [
          l,
          d === void 0 ? null : d
        ], l;
      },
      useContext: rr,
      useEffect: BM,
      useImperativeHandle: function(l, d, m) {
        m = m != null ? m.concat([l]) : null, fg(
          4194308,
          4,
          WM.bind(null, d, l),
          m
        );
      },
      useLayoutEffect: function(l, d) {
        return fg(4194308, 4, l, d);
      },
      useInsertionEffect: function(l, d) {
        fg(4, 2, l, d);
      },
      useMemo: function(l, d) {
        var m = _r();
        d = d === void 0 ? null : d;
        var x = l();
        if ($l) {
          Mn(!0);
          try {
            l();
          } finally {
            Mn(!1);
          }
        }
        return m.memoizedState = [x, d], x;
      },
      useReducer: function(l, d, m) {
        var x = _r();
        if (m !== void 0) {
          var N = m(d);
          if ($l) {
            Mn(!0);
            try {
              m(d);
            } finally {
              Mn(!1);
            }
          }
        } else N = d;
        return x.memoizedState = x.baseState = N, l = {
          pending: null,
          lanes: 0,
          dispatch: null,
          lastRenderedReducer: l,
          lastRenderedState: N
        }, x.queue = l, l = l.dispatch = Wq.bind(
          null,
          it,
          l
        ), [x.memoizedState, l];
      },
      useRef: function(l) {
        var d = _r();
        return l = { current: l }, d.memoizedState = l;
      },
      useState: function(l) {
        l = Wk(l);
        var d = l.queue, m = tR.bind(null, it, d);
        return d.dispatch = m, [l.memoizedState, m];
      },
      useDebugValue: Gk,
      useDeferredValue: function(l, d) {
        var m = _r();
        return Xk(m, l, d);
      },
      useTransition: function() {
        var l = Wk(!1);
        return l = YM.bind(
          null,
          it,
          l.queue,
          !0,
          !1
        ), _r().memoizedState = l, [!1, l];
      },
      useSyncExternalStore: function(l, d, m) {
        var x = it, N = _r();
        if (Pt) {
          if (m === void 0)
            throw Error(r(407));
          m = m();
        } else {
          if (m = d(), an === null)
            throw Error(r(349));
          (St & 127) !== 0 || EM(x, d, m);
        }
        N.memoizedState = m;
        var R = { value: m, getSnapshot: d };
        return N.queue = R, BM(PM.bind(null, x, R, l), [
          l
        ]), x.flags |= 2048, ac(
          9,
          { destroy: void 0 },
          CM.bind(
            null,
            x,
            R,
            m,
            d
          ),
          null
        ), m;
      },
      useId: function() {
        var l = _r(), d = an.identifierPrefix;
        if (Pt) {
          var m = pa, x = fa;
          m = (x & ~(1 << 32 - Re(x) - 1)).toString(32) + m, d = "_" + d + "R_" + m, m = lg++, 0 < m && (d += "H" + m.toString(32)), d += "_";
        } else
          m = Fq++, d = "_" + d + "r_" + m.toString(32) + "_";
        return l.memoizedState = d;
      },
      useHostTransitionStatus: Jk,
      useFormState: DM,
      useActionState: DM,
      useOptimistic: function(l) {
        var d = _r();
        d.memoizedState = d.baseState = l;
        var m = {
          pending: null,
          lanes: 0,
          dispatch: null,
          lastRenderedReducer: null,
          lastRenderedState: null
        };
        return d.queue = m, d = Qk.bind(
          null,
          it,
          !0,
          m
        ), m.dispatch = d, [l, d];
      },
      useMemoCache: Vk,
      useCacheRefresh: function() {
        return _r().memoizedState = Hq.bind(
          null,
          it
        );
      },
      useEffectEvent: function(l) {
        var d = _r(), m = { impl: l };
        return d.memoizedState = m, function() {
          if ((Tt & 2) !== 0)
            throw Error(r(440));
          return m.impl.apply(void 0, arguments);
        };
      }
    }, Zk = {
      readContext: rr,
      use: cg,
      useCallback: KM,
      useContext: rr,
      useEffect: Kk,
      useImperativeHandle: qM,
      useInsertionEffect: UM,
      useLayoutEffect: HM,
      useMemo: GM,
      useReducer: dg,
      useRef: zM,
      useState: function() {
        return dg(mi);
      },
      useDebugValue: Gk,
      useDeferredValue: function(l, d) {
        var m = jn();
        return XM(
          m,
          Zt.memoizedState,
          l,
          d
        );
      },
      useTransition: function() {
        var l = dg(mi)[0], d = jn().memoizedState;
        return [
          typeof l == "boolean" ? l : kf(l),
          d
        ];
      },
      useSyncExternalStore: _M,
      useId: ZM,
      useHostTransitionStatus: Jk,
      useFormState: LM,
      useActionState: LM,
      useOptimistic: function(l, d) {
        var m = jn();
        return MM(m, Zt, l, d);
      },
      useMemoCache: Vk,
      useCacheRefresh: eR
    };
    Zk.useEffectEvent = VM;
    var aR = {
      readContext: rr,
      use: cg,
      useCallback: KM,
      useContext: rr,
      useEffect: Kk,
      useImperativeHandle: qM,
      useInsertionEffect: UM,
      useLayoutEffect: HM,
      useMemo: GM,
      useReducer: Hk,
      useRef: zM,
      useState: function() {
        return Hk(mi);
      },
      useDebugValue: Gk,
      useDeferredValue: function(l, d) {
        var m = jn();
        return Zt === null ? Xk(m, l, d) : XM(
          m,
          Zt.memoizedState,
          l,
          d
        );
      },
      useTransition: function() {
        var l = Hk(mi)[0], d = jn().memoizedState;
        return [
          typeof l == "boolean" ? l : kf(l),
          d
        ];
      },
      useSyncExternalStore: _M,
      useId: ZM,
      useHostTransitionStatus: Jk,
      useFormState: TM,
      useActionState: TM,
      useOptimistic: function(l, d) {
        var m = jn();
        return Zt !== null ? MM(m, Zt, l, d) : (m.baseState = l, [l, m.queue.dispatch]);
      },
      useMemoCache: Vk,
      useCacheRefresh: eR
    };
    aR.useEffectEvent = VM;
    function eS(l, d, m, x) {
      d = l.memoizedState, m = m(x, d), m = m == null ? d : p({}, d, m), l.memoizedState = m, l.lanes === 0 && (l.updateQueue.baseState = m);
    }
    var tS = {
      enqueueSetState: function(l, d, m) {
        l = l._reactInternals;
        var x = to(), N = bs(x);
        N.payload = d, m != null && (N.callback = m), d = ws(l, N, x), d !== null && (Fr(d, l, x), yf(d, l, x));
      },
      enqueueReplaceState: function(l, d, m) {
        l = l._reactInternals;
        var x = to(), N = bs(x);
        N.tag = 1, N.payload = d, m != null && (N.callback = m), d = ws(l, N, x), d !== null && (Fr(d, l, x), yf(d, l, x));
      },
      enqueueForceUpdate: function(l, d) {
        l = l._reactInternals;
        var m = to(), x = bs(m);
        x.tag = 2, d != null && (x.callback = d), d = ws(l, x, m), d !== null && (Fr(d, l, m), yf(d, l, m));
      }
    };
    function iR(l, d, m, x, N, R, H) {
      return l = l.stateNode, typeof l.shouldComponentUpdate == "function" ? l.shouldComponentUpdate(x, R, H) : d.prototype && d.prototype.isPureReactComponent ? !cf(m, x) || !cf(N, R) : !0;
    }
    function sR(l, d, m, x) {
      l = d.state, typeof d.componentWillReceiveProps == "function" && d.componentWillReceiveProps(m, x), typeof d.UNSAFE_componentWillReceiveProps == "function" && d.UNSAFE_componentWillReceiveProps(m, x), d.state !== l && tS.enqueueReplaceState(d, d.state, null);
    }
    function Dl(l, d) {
      var m = d;
      if ("ref" in d) {
        m = {};
        for (var x in d)
          x !== "ref" && (m[x] = d[x]);
      }
      if (l = l.defaultProps) {
        m === d && (m = p({}, m));
        for (var N in l)
          m[N] === void 0 && (m[N] = l[N]);
      }
      return m;
    }
    function lR(l) {
      qh(l);
    }
    function uR(l) {
      console.error(l);
    }
    function cR(l) {
      qh(l);
    }
    function hg(l, d) {
      try {
        var m = l.onUncaughtError;
        m(d.value, { componentStack: d.stack });
      } catch (x) {
        setTimeout(function() {
          throw x;
        });
      }
    }
    function dR(l, d, m) {
      try {
        var x = l.onCaughtError;
        x(m.value, {
          componentStack: m.stack,
          errorBoundary: d.tag === 1 ? d.stateNode : null
        });
      } catch (N) {
        setTimeout(function() {
          throw N;
        });
      }
    }
    function nS(l, d, m) {
      return m = bs(m), m.tag = 3, m.payload = { element: null }, m.callback = function() {
        hg(l, d);
      }, m;
    }
    function fR(l) {
      return l = bs(l), l.tag = 3, l;
    }
    function pR(l, d, m, x) {
      var N = m.type.getDerivedStateFromError;
      if (typeof N == "function") {
        var R = x.value;
        l.payload = function() {
          return N(R);
        }, l.callback = function() {
          dR(d, m, x);
        };
      }
      var H = m.stateNode;
      H !== null && typeof H.componentDidCatch == "function" && (l.callback = function() {
        dR(d, m, x), typeof N != "function" && (Cs === null ? Cs = /* @__PURE__ */ new Set([this]) : Cs.add(this));
        var J = x.stack;
        this.componentDidCatch(x.value, {
          componentStack: J !== null ? J : ""
        });
      });
    }
    function qq(l, d, m, x, N) {
      if (m.flags |= 32768, x !== null && typeof x == "object" && typeof x.then == "function") {
        if (d = m.alternate, d !== null && Ju(
          d,
          m,
          N,
          !0
        ), m = Jr.current, m !== null) {
          switch (m.tag) {
            case 31:
            case 13:
              return Vo === null ? Pg() : m.alternate === null && Cn === 0 && (Cn = 3), m.flags &= -257, m.flags |= 65536, m.lanes = N, x === ng ? m.flags |= 16384 : (d = m.updateQueue, d === null ? m.updateQueue = /* @__PURE__ */ new Set([x]) : d.add(x), PS(l, x, N)), !1;
            case 22:
              return m.flags |= 65536, x === ng ? m.flags |= 16384 : (d = m.updateQueue, d === null ? (d = {
                transitions: null,
                markerInstances: null,
                retryQueue: /* @__PURE__ */ new Set([x])
              }, m.updateQueue = d) : (m = d.retryQueue, m === null ? d.retryQueue = /* @__PURE__ */ new Set([x]) : m.add(x)), PS(l, x, N)), !1;
          }
          throw Error(r(435, m.tag));
        }
        return PS(l, x, N), Pg(), !1;
      }
      if (Pt)
        return d = Jr.current, d !== null ? ((d.flags & 65536) === 0 && (d.flags |= 256), d.flags |= 65536, d.lanes = N, x !== xk && (l = Error(r(422), { cause: x }), pf(bo(l, m)))) : (x !== xk && (d = Error(r(423), {
          cause: x
        }), pf(
          bo(d, m)
        )), l = l.current.alternate, l.flags |= 65536, N &= -N, l.lanes |= N, x = bo(x, m), N = nS(
          l.stateNode,
          x,
          N
        ), jk(l, N), Cn !== 4 && (Cn = 2)), !1;
      var R = Error(r(520), { cause: x });
      if (R = bo(R, m), jf === null ? jf = [R] : jf.push(R), Cn !== 4 && (Cn = 2), d === null) return !0;
      x = bo(x, m), m = d;
      do {
        switch (m.tag) {
          case 3:
            return m.flags |= 65536, l = N & -N, m.lanes |= l, l = nS(m.stateNode, x, l), jk(m, l), !1;
          case 1:
            if (d = m.type, R = m.stateNode, (m.flags & 128) === 0 && (typeof d.getDerivedStateFromError == "function" || R !== null && typeof R.componentDidCatch == "function" && (Cs === null || !Cs.has(R))))
              return m.flags |= 65536, N &= -N, m.lanes |= N, N = fR(N), pR(
                N,
                l,
                m,
                x
              ), jk(m, N), !1;
        }
        m = m.return;
      } while (m !== null);
      return !1;
    }
    var rS = Error(r(461)), Fn = !1;
    function or(l, d, m, x) {
      d.child = l === null ? vM(d, null, m, x) : Al(
        d,
        l.child,
        m,
        x
      );
    }
    function mR(l, d, m, x, N) {
      m = m.render;
      var R = d.ref;
      if ("ref" in x) {
        var H = {};
        for (var J in x)
          J !== "ref" && (H[J] = x[J]);
      } else H = x;
      return Ml(d), x = Fk(
        l,
        d,
        m,
        H,
        R,
        N
      ), J = Tk(), l !== null && !Fn ? (zk(l, d, N), hi(l, d, N)) : (Pt && J && bk(d), d.flags |= 1, or(l, d, x, N), d.child);
    }
    function hR(l, d, m, x, N) {
      if (l === null) {
        var R = m.type;
        return typeof R == "function" && !gk(R) && R.defaultProps === void 0 && m.compare === null ? (d.tag = 15, d.type = R, gR(
          l,
          d,
          R,
          x,
          N
        )) : (l = Yh(
          m.type,
          null,
          x,
          d,
          d.mode,
          N
        ), l.ref = d.ref, l.return = d, d.child = l);
      }
      if (R = l.child, !dS(l, N)) {
        var H = R.memoizedProps;
        if (m = m.compare, m = m !== null ? m : cf, m(H, x) && l.ref === d.ref)
          return hi(l, d, N);
      }
      return d.flags |= 1, l = ui(R, x), l.ref = d.ref, l.return = d, d.child = l;
    }
    function gR(l, d, m, x, N) {
      if (l !== null) {
        var R = l.memoizedProps;
        if (cf(R, x) && l.ref === d.ref)
          if (Fn = !1, d.pendingProps = x = R, dS(l, N))
            (l.flags & 131072) !== 0 && (Fn = !0);
          else
            return d.lanes = l.lanes, hi(l, d, N);
      }
      return oS(
        l,
        d,
        m,
        x,
        N
      );
    }
    function vR(l, d, m, x) {
      var N = x.children, R = l !== null ? l.memoizedState : null;
      if (l === null && d.stateNode === null && (d.stateNode = {
        _visibility: 1,
        _pendingMarkers: null,
        _retryCache: null,
        _transitions: null
      }), x.mode === "hidden") {
        if ((d.flags & 128) !== 0) {
          if (R = R !== null ? R.baseLanes | m : m, l !== null) {
            for (x = d.child = l.child, N = 0; x !== null; )
              N = N | x.lanes | x.childLanes, x = x.sibling;
            x = N & ~R;
          } else x = 0, d.child = null;
          return yR(
            l,
            d,
            R,
            m,
            x
          );
        }
        if ((m & 536870912) !== 0)
          d.memoizedState = { baseLanes: 0, cachePool: null }, l !== null && eg(
            d,
            R !== null ? R.cachePool : null
          ), R !== null ? wM(d, R) : Ak(), xM(d);
        else
          return x = d.lanes = 536870912, yR(
            l,
            d,
            R !== null ? R.baseLanes | m : m,
            m,
            x
          );
      } else
        R !== null ? (eg(d, R.cachePool), wM(d, R), ks(), d.memoizedState = null) : (l !== null && eg(d, null), Ak(), ks());
      return or(l, d, N, m), d.child;
    }
    function Ef(l, d) {
      return l !== null && l.tag === 22 || d.stateNode !== null || (d.stateNode = {
        _visibility: 1,
        _pendingMarkers: null,
        _retryCache: null,
        _transitions: null
      }), d.sibling;
    }
    function yR(l, d, m, x, N) {
      var R = Ok();
      return R = R === null ? null : { parent: Dn._currentValue, pool: R }, d.memoizedState = {
        baseLanes: m,
        cachePool: R
      }, l !== null && eg(d, null), Ak(), xM(d), l !== null && Ju(l, d, x, !0), d.childLanes = N, null;
    }
    function gg(l, d) {
      return d = yg(
        { mode: d.mode, children: d.children },
        l.mode
      ), d.ref = l.ref, l.child = d, d.return = l, d;
    }
    function bR(l, d, m) {
      return Al(d, l.child, null, m), l = gg(d, d.pendingProps), l.flags |= 2, Qr(d), d.memoizedState = null, l;
    }
    function Kq(l, d, m) {
      var x = d.pendingProps, N = (d.flags & 128) !== 0;
      if (d.flags &= -129, l === null) {
        if (Pt) {
          if (x.mode === "hidden")
            return l = gg(d, x), d.lanes = 536870912, Ef(null, l);
          if (Dk(d), (l = pn) ? (l = Rj(
            l,
            ko
          ), l = l !== null && l.data === "&" ? l : null, l !== null && (d.memoizedState = {
            dehydrated: l,
            treeContext: ms !== null ? { id: fa, overflow: pa } : null,
            retryLane: 536870912,
            hydrationErrors: null
          }, m = nM(l), m.return = d, d.child = m, nr = d, pn = null)) : l = null, l === null) throw gs(d);
          return d.lanes = 536870912, null;
        }
        return gg(d, x);
      }
      var R = l.memoizedState;
      if (R !== null) {
        var H = R.dehydrated;
        if (Dk(d), N)
          if (d.flags & 256)
            d.flags &= -257, d = bR(
              l,
              d,
              m
            );
          else if (d.memoizedState !== null)
            d.child = l.child, d.flags |= 128, d = null;
          else throw Error(r(558));
        else if (Fn || Ju(l, d, m, !1), N = (m & l.childLanes) !== 0, Fn || N) {
          if (x = an, x !== null && (H = Oh(x, m), H !== 0 && H !== R.retryLane))
            throw R.retryLane = H, Cl(l, H), Fr(x, l, H), rS;
          Pg(), d = bR(
            l,
            d,
            m
          );
        } else
          l = R.treeContext, pn = So(H.nextSibling), nr = d, Pt = !0, hs = null, ko = !1, l !== null && aM(d, l), d = gg(d, x), d.flags |= 4096;
        return d;
      }
      return l = ui(l.child, {
        mode: x.mode,
        children: x.children
      }), l.ref = d.ref, d.child = l, l.return = d, l;
    }
    function vg(l, d) {
      var m = d.ref;
      if (m === null)
        l !== null && l.ref !== null && (d.flags |= 4194816);
      else {
        if (typeof m != "function" && typeof m != "object")
          throw Error(r(284));
        (l === null || l.ref !== m) && (d.flags |= 4194816);
      }
    }
    function oS(l, d, m, x, N) {
      return Ml(d), m = Fk(
        l,
        d,
        m,
        x,
        void 0,
        N
      ), x = Tk(), l !== null && !Fn ? (zk(l, d, N), hi(l, d, N)) : (Pt && x && bk(d), d.flags |= 1, or(l, d, m, N), d.child);
    }
    function wR(l, d, m, x, N, R) {
      return Ml(d), d.updateQueue = null, m = SM(
        d,
        x,
        m,
        N
      ), kM(l), x = Tk(), l !== null && !Fn ? (zk(l, d, R), hi(l, d, R)) : (Pt && x && bk(d), d.flags |= 1, or(l, d, m, R), d.child);
    }
    function xR(l, d, m, x, N) {
      if (Ml(d), d.stateNode === null) {
        var R = Ku, H = m.contextType;
        typeof H == "object" && H !== null && (R = rr(H)), R = new m(x, R), d.memoizedState = R.state !== null && R.state !== void 0 ? R.state : null, R.updater = tS, d.stateNode = R, R._reactInternals = d, R = d.stateNode, R.props = x, R.state = d.memoizedState, R.refs = {}, Mk(d), H = m.contextType, R.context = typeof H == "object" && H !== null ? rr(H) : Ku, R.state = d.memoizedState, H = m.getDerivedStateFromProps, typeof H == "function" && (eS(
          d,
          m,
          H,
          x
        ), R.state = d.memoizedState), typeof m.getDerivedStateFromProps == "function" || typeof R.getSnapshotBeforeUpdate == "function" || typeof R.UNSAFE_componentWillMount != "function" && typeof R.componentWillMount != "function" || (H = R.state, typeof R.componentWillMount == "function" && R.componentWillMount(), typeof R.UNSAFE_componentWillMount == "function" && R.UNSAFE_componentWillMount(), H !== R.state && tS.enqueueReplaceState(R, R.state, null), wf(d, x, R, N), bf(), R.state = d.memoizedState), typeof R.componentDidMount == "function" && (d.flags |= 4194308), x = !0;
      } else if (l === null) {
        R = d.stateNode;
        var J = d.memoizedProps, re = Dl(m, J);
        R.props = re;
        var fe = R.context, ve = m.contextType;
        H = Ku, typeof ve == "object" && ve !== null && (H = rr(ve));
        var xe = m.getDerivedStateFromProps;
        ve = typeof xe == "function" || typeof R.getSnapshotBeforeUpdate == "function", J = d.pendingProps !== J, ve || typeof R.UNSAFE_componentWillReceiveProps != "function" && typeof R.componentWillReceiveProps != "function" || (J || fe !== H) && sR(
          d,
          R,
          x,
          H
        ), ys = !1;
        var pe = d.memoizedState;
        R.state = pe, wf(d, x, R, N), bf(), fe = d.memoizedState, J || pe !== fe || ys ? (typeof xe == "function" && (eS(
          d,
          m,
          xe,
          x
        ), fe = d.memoizedState), (re = ys || iR(
          d,
          m,
          re,
          x,
          pe,
          fe,
          H
        )) ? (ve || typeof R.UNSAFE_componentWillMount != "function" && typeof R.componentWillMount != "function" || (typeof R.componentWillMount == "function" && R.componentWillMount(), typeof R.UNSAFE_componentWillMount == "function" && R.UNSAFE_componentWillMount()), typeof R.componentDidMount == "function" && (d.flags |= 4194308)) : (typeof R.componentDidMount == "function" && (d.flags |= 4194308), d.memoizedProps = x, d.memoizedState = fe), R.props = x, R.state = fe, R.context = H, x = re) : (typeof R.componentDidMount == "function" && (d.flags |= 4194308), x = !1);
      } else {
        R = d.stateNode, Rk(l, d), H = d.memoizedProps, ve = Dl(m, H), R.props = ve, xe = d.pendingProps, pe = R.context, fe = m.contextType, re = Ku, typeof fe == "object" && fe !== null && (re = rr(fe)), J = m.getDerivedStateFromProps, (fe = typeof J == "function" || typeof R.getSnapshotBeforeUpdate == "function") || typeof R.UNSAFE_componentWillReceiveProps != "function" && typeof R.componentWillReceiveProps != "function" || (H !== xe || pe !== re) && sR(
          d,
          R,
          x,
          re
        ), ys = !1, pe = d.memoizedState, R.state = pe, wf(d, x, R, N), bf();
        var ge = d.memoizedState;
        H !== xe || pe !== ge || ys || l !== null && l.dependencies !== null && Qh(l.dependencies) ? (typeof J == "function" && (eS(
          d,
          m,
          J,
          x
        ), ge = d.memoizedState), (ve = ys || iR(
          d,
          m,
          ve,
          x,
          pe,
          ge,
          re
        ) || l !== null && l.dependencies !== null && Qh(l.dependencies)) ? (fe || typeof R.UNSAFE_componentWillUpdate != "function" && typeof R.componentWillUpdate != "function" || (typeof R.componentWillUpdate == "function" && R.componentWillUpdate(x, ge, re), typeof R.UNSAFE_componentWillUpdate == "function" && R.UNSAFE_componentWillUpdate(
          x,
          ge,
          re
        )), typeof R.componentDidUpdate == "function" && (d.flags |= 4), typeof R.getSnapshotBeforeUpdate == "function" && (d.flags |= 1024)) : (typeof R.componentDidUpdate != "function" || H === l.memoizedProps && pe === l.memoizedState || (d.flags |= 4), typeof R.getSnapshotBeforeUpdate != "function" || H === l.memoizedProps && pe === l.memoizedState || (d.flags |= 1024), d.memoizedProps = x, d.memoizedState = ge), R.props = x, R.state = ge, R.context = re, x = ve) : (typeof R.componentDidUpdate != "function" || H === l.memoizedProps && pe === l.memoizedState || (d.flags |= 4), typeof R.getSnapshotBeforeUpdate != "function" || H === l.memoizedProps && pe === l.memoizedState || (d.flags |= 1024), x = !1);
      }
      return R = x, vg(l, d), x = (d.flags & 128) !== 0, R || x ? (R = d.stateNode, m = x && typeof m.getDerivedStateFromError != "function" ? null : R.render(), d.flags |= 1, l !== null && x ? (d.child = Al(
        d,
        l.child,
        null,
        N
      ), d.child = Al(
        d,
        null,
        m,
        N
      )) : or(l, d, m, N), d.memoizedState = R.state, l = d.child) : l = hi(
        l,
        d,
        N
      ), l;
    }
    function kR(l, d, m, x) {
      return Ol(), d.flags |= 256, or(l, d, m, x), d.child;
    }
    var aS = {
      dehydrated: null,
      treeContext: null,
      retryLane: 0,
      hydrationErrors: null
    };
    function iS(l) {
      return { baseLanes: l, cachePool: dM() };
    }
    function sS(l, d, m) {
      return l = l !== null ? l.childLanes & ~m : 0, d && (l |= eo), l;
    }
    function SR(l, d, m) {
      var x = d.pendingProps, N = !1, R = (d.flags & 128) !== 0, H;
      if ((H = R) || (H = l !== null && l.memoizedState === null ? !1 : (Rn.current & 2) !== 0), H && (N = !0, d.flags &= -129), H = (d.flags & 32) !== 0, d.flags &= -33, l === null) {
        if (Pt) {
          if (N ? xs(d) : ks(), (l = pn) ? (l = Rj(
            l,
            ko
          ), l = l !== null && l.data !== "&" ? l : null, l !== null && (d.memoizedState = {
            dehydrated: l,
            treeContext: ms !== null ? { id: fa, overflow: pa } : null,
            retryLane: 536870912,
            hydrationErrors: null
          }, m = nM(l), m.return = d, d.child = m, nr = d, pn = null)) : l = null, l === null) throw gs(d);
          return US(l) ? d.lanes = 32 : d.lanes = 536870912, null;
        }
        var J = x.children;
        return x = x.fallback, N ? (ks(), N = d.mode, J = yg(
          { mode: "hidden", children: J },
          N
        ), x = Pl(
          x,
          N,
          m,
          null
        ), J.return = d, x.return = d, J.sibling = x, d.child = J, x = d.child, x.memoizedState = iS(m), x.childLanes = sS(
          l,
          H,
          m
        ), d.memoizedState = aS, Ef(null, x)) : (xs(d), lS(d, J));
      }
      var re = l.memoizedState;
      if (re !== null && (J = re.dehydrated, J !== null)) {
        if (R)
          d.flags & 256 ? (xs(d), d.flags &= -257, d = uS(
            l,
            d,
            m
          )) : d.memoizedState !== null ? (ks(), d.child = l.child, d.flags |= 128, d = null) : (ks(), J = x.fallback, N = d.mode, x = yg(
            { mode: "visible", children: x.children },
            N
          ), J = Pl(
            J,
            N,
            m,
            null
          ), J.flags |= 2, x.return = d, J.return = d, x.sibling = J, d.child = x, Al(
            d,
            l.child,
            null,
            m
          ), x = d.child, x.memoizedState = iS(m), x.childLanes = sS(
            l,
            H,
            m
          ), d.memoizedState = aS, d = Ef(null, x));
        else if (xs(d), US(J)) {
          if (H = J.nextSibling && J.nextSibling.dataset, H) var fe = H.dgst;
          H = fe, x = Error(r(419)), x.stack = "", x.digest = H, pf({ value: x, source: null, stack: null }), d = uS(
            l,
            d,
            m
          );
        } else if (Fn || Ju(l, d, m, !1), H = (m & l.childLanes) !== 0, Fn || H) {
          if (H = an, H !== null && (x = Oh(H, m), x !== 0 && x !== re.retryLane))
            throw re.retryLane = x, Cl(l, x), Fr(H, l, x), rS;
          VS(J) || Pg(), d = uS(
            l,
            d,
            m
          );
        } else
          VS(J) ? (d.flags |= 192, d.child = l.child, d = null) : (l = re.treeContext, pn = So(
            J.nextSibling
          ), nr = d, Pt = !0, hs = null, ko = !1, l !== null && aM(d, l), d = lS(
            d,
            x.children
          ), d.flags |= 4096);
        return d;
      }
      return N ? (ks(), J = x.fallback, N = d.mode, re = l.child, fe = re.sibling, x = ui(re, {
        mode: "hidden",
        children: x.children
      }), x.subtreeFlags = re.subtreeFlags & 65011712, fe !== null ? J = ui(
        fe,
        J
      ) : (J = Pl(
        J,
        N,
        m,
        null
      ), J.flags |= 2), J.return = d, x.return = d, x.sibling = J, d.child = x, Ef(null, x), x = d.child, J = l.child.memoizedState, J === null ? J = iS(m) : (N = J.cachePool, N !== null ? (re = Dn._currentValue, N = N.parent !== re ? { parent: re, pool: re } : N) : N = dM(), J = {
        baseLanes: J.baseLanes | m,
        cachePool: N
      }), x.memoizedState = J, x.childLanes = sS(
        l,
        H,
        m
      ), d.memoizedState = aS, Ef(l.child, x)) : (xs(d), m = l.child, l = m.sibling, m = ui(m, {
        mode: "visible",
        children: x.children
      }), m.return = d, m.sibling = null, l !== null && (H = d.deletions, H === null ? (d.deletions = [l], d.flags |= 16) : H.push(l)), d.child = m, d.memoizedState = null, m);
    }
    function lS(l, d) {
      return d = yg(
        { mode: "visible", children: d },
        l.mode
      ), d.return = l, l.child = d;
    }
    function yg(l, d) {
      return l = Yr(22, l, null, d), l.lanes = 0, l;
    }
    function uS(l, d, m) {
      return Al(d, l.child, null, m), l = lS(
        d,
        d.pendingProps.children
      ), l.flags |= 2, d.memoizedState = null, l;
    }
    function _R(l, d, m) {
      l.lanes |= d;
      var x = l.alternate;
      x !== null && (x.lanes |= d), _k(l.return, d, m);
    }
    function cS(l, d, m, x, N, R) {
      var H = l.memoizedState;
      H === null ? l.memoizedState = {
        isBackwards: d,
        rendering: null,
        renderingStartTime: 0,
        last: x,
        tail: m,
        tailMode: N,
        treeForkCount: R
      } : (H.isBackwards = d, H.rendering = null, H.renderingStartTime = 0, H.last = x, H.tail = m, H.tailMode = N, H.treeForkCount = R);
    }
    function ER(l, d, m) {
      var x = d.pendingProps, N = x.revealOrder, R = x.tail;
      x = x.children;
      var H = Rn.current, J = (H & 2) !== 0;
      if (J ? (H = H & 1 | 2, d.flags |= 128) : H &= 1, T(Rn, H), or(l, d, x, m), x = Pt ? ff : 0, !J && l !== null && (l.flags & 128) !== 0)
        e: for (l = d.child; l !== null; ) {
          if (l.tag === 13)
            l.memoizedState !== null && _R(l, m, d);
          else if (l.tag === 19)
            _R(l, m, d);
          else if (l.child !== null) {
            l.child.return = l, l = l.child;
            continue;
          }
          if (l === d) break e;
          for (; l.sibling === null; ) {
            if (l.return === null || l.return === d)
              break e;
            l = l.return;
          }
          l.sibling.return = l.return, l = l.sibling;
        }
      switch (N) {
        case "forwards":
          for (m = d.child, N = null; m !== null; )
            l = m.alternate, l !== null && ig(l) === null && (N = m), m = m.sibling;
          m = N, m === null ? (N = d.child, d.child = null) : (N = m.sibling, m.sibling = null), cS(
            d,
            !1,
            N,
            m,
            R,
            x
          );
          break;
        case "backwards":
        case "unstable_legacy-backwards":
          for (m = null, N = d.child, d.child = null; N !== null; ) {
            if (l = N.alternate, l !== null && ig(l) === null) {
              d.child = N;
              break;
            }
            l = N.sibling, N.sibling = m, m = N, N = l;
          }
          cS(
            d,
            !0,
            m,
            null,
            R,
            x
          );
          break;
        case "together":
          cS(
            d,
            !1,
            null,
            null,
            void 0,
            x
          );
          break;
        default:
          d.memoizedState = null;
      }
      return d.child;
    }
    function hi(l, d, m) {
      if (l !== null && (d.dependencies = l.dependencies), Es |= d.lanes, (m & d.childLanes) === 0)
        if (l !== null) {
          if (Ju(
            l,
            d,
            m,
            !1
          ), (m & d.childLanes) === 0)
            return null;
        } else return null;
      if (l !== null && d.child !== l.child)
        throw Error(r(153));
      if (d.child !== null) {
        for (l = d.child, m = ui(l, l.pendingProps), d.child = m, m.return = d; l.sibling !== null; )
          l = l.sibling, m = m.sibling = ui(l, l.pendingProps), m.return = d;
        m.sibling = null;
      }
      return d.child;
    }
    function dS(l, d) {
      return (l.lanes & d) !== 0 ? !0 : (l = l.dependencies, !!(l !== null && Qh(l)));
    }
    function Gq(l, d, m) {
      switch (d.tag) {
        case 3:
          te(d, d.stateNode.containerInfo), vs(d, Dn, l.memoizedState.cache), Ol();
          break;
        case 27:
        case 5:
          ce(d);
          break;
        case 4:
          te(d, d.stateNode.containerInfo);
          break;
        case 10:
          vs(
            d,
            d.type,
            d.memoizedProps.value
          );
          break;
        case 31:
          if (d.memoizedState !== null)
            return d.flags |= 128, Dk(d), null;
          break;
        case 13:
          var x = d.memoizedState;
          if (x !== null)
            return x.dehydrated !== null ? (xs(d), d.flags |= 128, null) : (m & d.child.childLanes) !== 0 ? SR(l, d, m) : (xs(d), l = hi(
              l,
              d,
              m
            ), l !== null ? l.sibling : null);
          xs(d);
          break;
        case 19:
          var N = (l.flags & 128) !== 0;
          if (x = (m & d.childLanes) !== 0, x || (Ju(
            l,
            d,
            m,
            !1
          ), x = (m & d.childLanes) !== 0), N) {
            if (x)
              return ER(
                l,
                d,
                m
              );
            d.flags |= 128;
          }
          if (N = d.memoizedState, N !== null && (N.rendering = null, N.tail = null, N.lastEffect = null), T(Rn, Rn.current), x) break;
          return null;
        case 22:
          return d.lanes = 0, vR(
            l,
            d,
            m,
            d.pendingProps
          );
        case 24:
          vs(d, Dn, l.memoizedState.cache);
      }
      return hi(l, d, m);
    }
    function CR(l, d, m) {
      if (l !== null)
        if (l.memoizedProps !== d.pendingProps)
          Fn = !0;
        else {
          if (!dS(l, m) && (d.flags & 128) === 0)
            return Fn = !1, Gq(
              l,
              d,
              m
            );
          Fn = (l.flags & 131072) !== 0;
        }
      else
        Fn = !1, Pt && (d.flags & 1048576) !== 0 && oM(d, ff, d.index);
      switch (d.lanes = 0, d.tag) {
        case 16:
          e: {
            var x = d.pendingProps;
            if (l = jl(d.elementType), d.type = l, typeof l == "function")
              gk(l) ? (x = Dl(l, x), d.tag = 1, d = xR(
                null,
                d,
                l,
                x,
                m
              )) : (d.tag = 0, d = oS(
                null,
                d,
                l,
                x,
                m
              ));
            else {
              if (l != null) {
                var N = l.$$typeof;
                if (N === E) {
                  d.tag = 11, d = mR(
                    null,
                    d,
                    l,
                    x,
                    m
                  );
                  break e;
                } else if (N === M) {
                  d.tag = 14, d = hR(
                    null,
                    d,
                    l,
                    x,
                    m
                  );
                  break e;
                }
              }
              throw d = $(l) || l, Error(r(306, d, ""));
            }
          }
          return d;
        case 0:
          return oS(
            l,
            d,
            d.type,
            d.pendingProps,
            m
          );
        case 1:
          return x = d.type, N = Dl(
            x,
            d.pendingProps
          ), xR(
            l,
            d,
            x,
            N,
            m
          );
        case 3:
          e: {
            if (te(
              d,
              d.stateNode.containerInfo
            ), l === null) throw Error(r(387));
            x = d.pendingProps;
            var R = d.memoizedState;
            N = R.element, Rk(l, d), wf(d, x, null, m);
            var H = d.memoizedState;
            if (x = H.cache, vs(d, Dn, x), x !== R.cache && Ek(
              d,
              [Dn],
              m,
              !0
            ), bf(), x = H.element, R.isDehydrated)
              if (R = {
                element: x,
                isDehydrated: !1,
                cache: H.cache
              }, d.updateQueue.baseState = R, d.memoizedState = R, d.flags & 256) {
                d = kR(
                  l,
                  d,
                  x,
                  m
                );
                break e;
              } else if (x !== N) {
                N = bo(
                  Error(r(424)),
                  d
                ), pf(N), d = kR(
                  l,
                  d,
                  x,
                  m
                );
                break e;
              } else
                for (l = d.stateNode.containerInfo, l.nodeType === 9 ? l = l.body : l = l.nodeName === "HTML" ? l.ownerDocument.body : l, pn = So(l.firstChild), nr = d, Pt = !0, hs = null, ko = !0, m = vM(
                  d,
                  null,
                  x,
                  m
                ), d.child = m; m; )
                  m.flags = m.flags & -3 | 4096, m = m.sibling;
            else {
              if (Ol(), x === N) {
                d = hi(
                  l,
                  d,
                  m
                );
                break e;
              }
              or(l, d, x, m);
            }
            d = d.child;
          }
          return d;
        case 26:
          return vg(l, d), l === null ? (m = Lj(
            d.type,
            null,
            d.pendingProps,
            null
          )) ? d.memoizedState = m : Pt || (m = d.type, l = d.pendingProps, x = Ag(
            Q.current
          ).createElement(m), x[qn] = d, x[pr] = l, ar(x, m, l), $n(x), d.stateNode = x) : d.memoizedState = Lj(
            d.type,
            l.memoizedProps,
            d.pendingProps,
            l.memoizedState
          ), null;
        case 27:
          return ce(d), l === null && Pt && (x = d.stateNode = Aj(
            d.type,
            d.pendingProps,
            Q.current
          ), nr = d, ko = !0, N = pn, Ms(d.type) ? (HS = N, pn = So(x.firstChild)) : pn = N), or(
            l,
            d,
            d.pendingProps.children,
            m
          ), vg(l, d), l === null && (d.flags |= 4194304), d.child;
        case 5:
          return l === null && Pt && ((N = x = pn) && (x = _K(
            x,
            d.type,
            d.pendingProps,
            ko
          ), x !== null ? (d.stateNode = x, nr = d, pn = So(x.firstChild), ko = !1, N = !0) : N = !1), N || gs(d)), ce(d), N = d.type, R = d.pendingProps, H = l !== null ? l.memoizedProps : null, x = R.children, TS(N, R) ? x = null : H !== null && TS(N, H) && (d.flags |= 32), d.memoizedState !== null && (N = Fk(
            l,
            d,
            Tq,
            null,
            null,
            m
          ), zf._currentValue = N), vg(l, d), or(l, d, x, m), d.child;
        case 6:
          return l === null && Pt && ((l = m = pn) && (m = EK(
            m,
            d.pendingProps,
            ko
          ), m !== null ? (d.stateNode = m, nr = d, pn = null, l = !0) : l = !1), l || gs(d)), null;
        case 13:
          return SR(l, d, m);
        case 4:
          return te(
            d,
            d.stateNode.containerInfo
          ), x = d.pendingProps, l === null ? d.child = Al(
            d,
            null,
            x,
            m
          ) : or(l, d, x, m), d.child;
        case 11:
          return mR(
            l,
            d,
            d.type,
            d.pendingProps,
            m
          );
        case 7:
          return or(
            l,
            d,
            d.pendingProps,
            m
          ), d.child;
        case 8:
          return or(
            l,
            d,
            d.pendingProps.children,
            m
          ), d.child;
        case 12:
          return or(
            l,
            d,
            d.pendingProps.children,
            m
          ), d.child;
        case 10:
          return x = d.pendingProps, vs(d, d.type, x.value), or(l, d, x.children, m), d.child;
        case 9:
          return N = d.type._context, x = d.pendingProps.children, Ml(d), N = rr(N), x = x(N), d.flags |= 1, or(l, d, x, m), d.child;
        case 14:
          return hR(
            l,
            d,
            d.type,
            d.pendingProps,
            m
          );
        case 15:
          return gR(
            l,
            d,
            d.type,
            d.pendingProps,
            m
          );
        case 19:
          return ER(l, d, m);
        case 31:
          return Kq(l, d, m);
        case 22:
          return vR(
            l,
            d,
            m,
            d.pendingProps
          );
        case 24:
          return Ml(d), x = rr(Dn), l === null ? (N = Ok(), N === null && (N = an, R = Ck(), N.pooledCache = R, R.refCount++, R !== null && (N.pooledCacheLanes |= m), N = R), d.memoizedState = { parent: x, cache: N }, Mk(d), vs(d, Dn, N)) : ((l.lanes & m) !== 0 && (Rk(l, d), wf(d, null, null, m), bf()), N = l.memoizedState, R = d.memoizedState, N.parent !== x ? (N = { parent: x, cache: x }, d.memoizedState = N, d.lanes === 0 && (d.memoizedState = d.updateQueue.baseState = N), vs(d, Dn, x)) : (x = R.cache, vs(d, Dn, x), x !== N.cache && Ek(
            d,
            [Dn],
            m,
            !0
          ))), or(
            l,
            d,
            d.pendingProps.children,
            m
          ), d.child;
        case 29:
          throw d.pendingProps;
      }
      throw Error(r(156, d.tag));
    }
    function gi(l) {
      l.flags |= 4;
    }
    function fS(l, d, m, x, N) {
      if ((d = (l.mode & 32) !== 0) && (d = !1), d) {
        if (l.flags |= 16777216, (N & 335544128) === N)
          if (l.stateNode.complete) l.flags |= 8192;
          else if (ZR()) l.flags |= 8192;
          else
            throw Il = ng, Nk;
      } else l.flags &= -16777217;
    }
    function PR(l, d) {
      if (d.type !== "stylesheet" || (d.state.loading & 4) !== 0)
        l.flags &= -16777217;
      else if (l.flags |= 16777216, !Vj(d))
        if (ZR()) l.flags |= 8192;
        else
          throw Il = ng, Nk;
    }
    function bg(l, d) {
      d !== null && (l.flags |= 4), l.flags & 16384 && (d = l.tag !== 22 ? Eh() : 536870912, l.lanes |= d, uc |= d);
    }
    function Cf(l, d) {
      if (!Pt)
        switch (l.tailMode) {
          case "hidden":
            d = l.tail;
            for (var m = null; d !== null; )
              d.alternate !== null && (m = d), d = d.sibling;
            m === null ? l.tail = null : m.sibling = null;
            break;
          case "collapsed":
            m = l.tail;
            for (var x = null; m !== null; )
              m.alternate !== null && (x = m), m = m.sibling;
            x === null ? d || l.tail === null ? l.tail = null : l.tail.sibling = null : x.sibling = null;
        }
    }
    function mn(l) {
      var d = l.alternate !== null && l.alternate.child === l.child, m = 0, x = 0;
      if (d)
        for (var N = l.child; N !== null; )
          m |= N.lanes | N.childLanes, x |= N.subtreeFlags & 65011712, x |= N.flags & 65011712, N.return = l, N = N.sibling;
      else
        for (N = l.child; N !== null; )
          m |= N.lanes | N.childLanes, x |= N.subtreeFlags, x |= N.flags, N.return = l, N = N.sibling;
      return l.subtreeFlags |= x, l.childLanes = m, d;
    }
    function Xq(l, d, m) {
      var x = d.pendingProps;
      switch (wk(d), d.tag) {
        case 16:
        case 15:
        case 0:
        case 11:
        case 7:
        case 8:
        case 12:
        case 9:
        case 14:
          return mn(d), null;
        case 1:
          return mn(d), null;
        case 3:
          return m = d.stateNode, x = null, l !== null && (x = l.memoizedState.cache), d.memoizedState.cache !== x && (d.flags |= 2048), fi(Dn), ae(), m.pendingContext && (m.context = m.pendingContext, m.pendingContext = null), (l === null || l.child === null) && (Yu(d) ? gi(d) : l === null || l.memoizedState.isDehydrated && (d.flags & 256) === 0 || (d.flags |= 1024, kk())), mn(d), null;
        case 26:
          var N = d.type, R = d.memoizedState;
          return l === null ? (gi(d), R !== null ? (mn(d), PR(d, R)) : (mn(d), fS(
            d,
            N,
            null,
            x,
            m
          ))) : R ? R !== l.memoizedState ? (gi(d), mn(d), PR(d, R)) : (mn(d), d.flags &= -16777217) : (l = l.memoizedProps, l !== x && gi(d), mn(d), fS(
            d,
            N,
            l,
            x,
            m
          )), null;
        case 27:
          if (Z(d), m = Q.current, N = d.type, l !== null && d.stateNode != null)
            l.memoizedProps !== x && gi(d);
          else {
            if (!x) {
              if (d.stateNode === null)
                throw Error(r(166));
              return mn(d), null;
            }
            l = V.current, Yu(d) ? iM(d) : (l = Aj(N, x, m), d.stateNode = l, gi(d));
          }
          return mn(d), null;
        case 5:
          if (Z(d), N = d.type, l !== null && d.stateNode != null)
            l.memoizedProps !== x && gi(d);
          else {
            if (!x) {
              if (d.stateNode === null)
                throw Error(r(166));
              return mn(d), null;
            }
            if (R = V.current, Yu(d))
              iM(d);
            else {
              var H = Ag(
                Q.current
              );
              switch (R) {
                case 1:
                  R = H.createElementNS(
                    "http://www.w3.org/2000/svg",
                    N
                  );
                  break;
                case 2:
                  R = H.createElementNS(
                    "http://www.w3.org/1998/Math/MathML",
                    N
                  );
                  break;
                default:
                  switch (N) {
                    case "svg":
                      R = H.createElementNS(
                        "http://www.w3.org/2000/svg",
                        N
                      );
                      break;
                    case "math":
                      R = H.createElementNS(
                        "http://www.w3.org/1998/Math/MathML",
                        N
                      );
                      break;
                    case "script":
                      R = H.createElement("div"), R.innerHTML = "<script><\/script>", R = R.removeChild(
                        R.firstChild
                      );
                      break;
                    case "select":
                      R = typeof x.is == "string" ? H.createElement("select", {
                        is: x.is
                      }) : H.createElement("select"), x.multiple ? R.multiple = !0 : x.size && (R.size = x.size);
                      break;
                    default:
                      R = typeof x.is == "string" ? H.createElement(N, { is: x.is }) : H.createElement(N);
                  }
              }
              R[qn] = d, R[pr] = x;
              e: for (H = d.child; H !== null; ) {
                if (H.tag === 5 || H.tag === 6)
                  R.appendChild(H.stateNode);
                else if (H.tag !== 4 && H.tag !== 27 && H.child !== null) {
                  H.child.return = H, H = H.child;
                  continue;
                }
                if (H === d) break e;
                for (; H.sibling === null; ) {
                  if (H.return === null || H.return === d)
                    break e;
                  H = H.return;
                }
                H.sibling.return = H.return, H = H.sibling;
              }
              d.stateNode = R;
              e: switch (ar(R, N, x), N) {
                case "button":
                case "input":
                case "select":
                case "textarea":
                  x = !!x.autoFocus;
                  break e;
                case "img":
                  x = !0;
                  break e;
                default:
                  x = !1;
              }
              x && gi(d);
            }
          }
          return mn(d), fS(
            d,
            d.type,
            l === null ? null : l.memoizedProps,
            d.pendingProps,
            m
          ), null;
        case 6:
          if (l && d.stateNode != null)
            l.memoizedProps !== x && gi(d);
          else {
            if (typeof x != "string" && d.stateNode === null)
              throw Error(r(166));
            if (l = Q.current, Yu(d)) {
              if (l = d.stateNode, m = d.memoizedProps, x = null, N = nr, N !== null)
                switch (N.tag) {
                  case 27:
                  case 5:
                    x = N.memoizedProps;
                }
              l[qn] = d, l = !!(l.nodeValue === m || x !== null && x.suppressHydrationWarning === !0 || Sj(l.nodeValue, m)), l || gs(d, !0);
            } else
              l = Ag(l).createTextNode(
                x
              ), l[qn] = d, d.stateNode = l;
          }
          return mn(d), null;
        case 31:
          if (m = d.memoizedState, l === null || l.memoizedState !== null) {
            if (x = Yu(d), m !== null) {
              if (l === null) {
                if (!x) throw Error(r(318));
                if (l = d.memoizedState, l = l !== null ? l.dehydrated : null, !l) throw Error(r(557));
                l[qn] = d;
              } else
                Ol(), (d.flags & 128) === 0 && (d.memoizedState = null), d.flags |= 4;
              mn(d), l = !1;
            } else
              m = kk(), l !== null && l.memoizedState !== null && (l.memoizedState.hydrationErrors = m), l = !0;
            if (!l)
              return d.flags & 256 ? (Qr(d), d) : (Qr(d), null);
            if ((d.flags & 128) !== 0)
              throw Error(r(558));
          }
          return mn(d), null;
        case 13:
          if (x = d.memoizedState, l === null || l.memoizedState !== null && l.memoizedState.dehydrated !== null) {
            if (N = Yu(d), x !== null && x.dehydrated !== null) {
              if (l === null) {
                if (!N) throw Error(r(318));
                if (N = d.memoizedState, N = N !== null ? N.dehydrated : null, !N) throw Error(r(317));
                N[qn] = d;
              } else
                Ol(), (d.flags & 128) === 0 && (d.memoizedState = null), d.flags |= 4;
              mn(d), N = !1;
            } else
              N = kk(), l !== null && l.memoizedState !== null && (l.memoizedState.hydrationErrors = N), N = !0;
            if (!N)
              return d.flags & 256 ? (Qr(d), d) : (Qr(d), null);
          }
          return Qr(d), (d.flags & 128) !== 0 ? (d.lanes = m, d) : (m = x !== null, l = l !== null && l.memoizedState !== null, m && (x = d.child, N = null, x.alternate !== null && x.alternate.memoizedState !== null && x.alternate.memoizedState.cachePool !== null && (N = x.alternate.memoizedState.cachePool.pool), R = null, x.memoizedState !== null && x.memoizedState.cachePool !== null && (R = x.memoizedState.cachePool.pool), R !== N && (x.flags |= 2048)), m !== l && m && (d.child.flags |= 8192), bg(d, d.updateQueue), mn(d), null);
        case 4:
          return ae(), l === null && AS(d.stateNode.containerInfo), mn(d), null;
        case 10:
          return fi(d.type), mn(d), null;
        case 19:
          if (K(Rn), x = d.memoizedState, x === null) return mn(d), null;
          if (N = (d.flags & 128) !== 0, R = x.rendering, R === null)
            if (N) Cf(x, !1);
            else {
              if (Cn !== 0 || l !== null && (l.flags & 128) !== 0)
                for (l = d.child; l !== null; ) {
                  if (R = ig(l), R !== null) {
                    for (d.flags |= 128, Cf(x, !1), l = R.updateQueue, d.updateQueue = l, bg(d, l), d.subtreeFlags = 0, l = m, m = d.child; m !== null; )
                      tM(m, l), m = m.sibling;
                    return T(
                      Rn,
                      Rn.current & 1 | 2
                    ), Pt && ci(d, x.treeForkCount), d.child;
                  }
                  l = l.sibling;
                }
              x.tail !== null && Ee() > _g && (d.flags |= 128, N = !0, Cf(x, !1), d.lanes = 4194304);
            }
          else {
            if (!N)
              if (l = ig(R), l !== null) {
                if (d.flags |= 128, N = !0, l = l.updateQueue, d.updateQueue = l, bg(d, l), Cf(x, !0), x.tail === null && x.tailMode === "hidden" && !R.alternate && !Pt)
                  return mn(d), null;
              } else
                2 * Ee() - x.renderingStartTime > _g && m !== 536870912 && (d.flags |= 128, N = !0, Cf(x, !1), d.lanes = 4194304);
            x.isBackwards ? (R.sibling = d.child, d.child = R) : (l = x.last, l !== null ? l.sibling = R : d.child = R, x.last = R);
          }
          return x.tail !== null ? (l = x.tail, x.rendering = l, x.tail = l.sibling, x.renderingStartTime = Ee(), l.sibling = null, m = Rn.current, T(
            Rn,
            N ? m & 1 | 2 : m & 1
          ), Pt && ci(d, x.treeForkCount), l) : (mn(d), null);
        case 22:
        case 23:
          return Qr(d), $k(), x = d.memoizedState !== null, l !== null ? l.memoizedState !== null !== x && (d.flags |= 8192) : x && (d.flags |= 8192), x ? (m & 536870912) !== 0 && (d.flags & 128) === 0 && (mn(d), d.subtreeFlags & 6 && (d.flags |= 8192)) : mn(d), m = d.updateQueue, m !== null && bg(d, m.retryQueue), m = null, l !== null && l.memoizedState !== null && l.memoizedState.cachePool !== null && (m = l.memoizedState.cachePool.pool), x = null, d.memoizedState !== null && d.memoizedState.cachePool !== null && (x = d.memoizedState.cachePool.pool), x !== m && (d.flags |= 2048), l !== null && K(Rl), null;
        case 24:
          return m = null, l !== null && (m = l.memoizedState.cache), d.memoizedState.cache !== m && (d.flags |= 2048), fi(Dn), mn(d), null;
        case 25:
          return null;
        case 30:
          return null;
      }
      throw Error(r(156, d.tag));
    }
    function Yq(l, d) {
      switch (wk(d), d.tag) {
        case 1:
          return l = d.flags, l & 65536 ? (d.flags = l & -65537 | 128, d) : null;
        case 3:
          return fi(Dn), ae(), l = d.flags, (l & 65536) !== 0 && (l & 128) === 0 ? (d.flags = l & -65537 | 128, d) : null;
        case 26:
        case 27:
        case 5:
          return Z(d), null;
        case 31:
          if (d.memoizedState !== null) {
            if (Qr(d), d.alternate === null)
              throw Error(r(340));
            Ol();
          }
          return l = d.flags, l & 65536 ? (d.flags = l & -65537 | 128, d) : null;
        case 13:
          if (Qr(d), l = d.memoizedState, l !== null && l.dehydrated !== null) {
            if (d.alternate === null)
              throw Error(r(340));
            Ol();
          }
          return l = d.flags, l & 65536 ? (d.flags = l & -65537 | 128, d) : null;
        case 19:
          return K(Rn), null;
        case 4:
          return ae(), null;
        case 10:
          return fi(d.type), null;
        case 22:
        case 23:
          return Qr(d), $k(), l !== null && K(Rl), l = d.flags, l & 65536 ? (d.flags = l & -65537 | 128, d) : null;
        case 24:
          return fi(Dn), null;
        case 25:
          return null;
        default:
          return null;
      }
    }
    function OR(l, d) {
      switch (wk(d), d.tag) {
        case 3:
          fi(Dn), ae();
          break;
        case 26:
        case 27:
        case 5:
          Z(d);
          break;
        case 4:
          ae();
          break;
        case 31:
          d.memoizedState !== null && Qr(d);
          break;
        case 13:
          Qr(d);
          break;
        case 19:
          K(Rn);
          break;
        case 10:
          fi(d.type);
          break;
        case 22:
        case 23:
          Qr(d), $k(), l !== null && K(Rl);
          break;
        case 24:
          fi(Dn);
      }
    }
    function Pf(l, d) {
      try {
        var m = d.updateQueue, x = m !== null ? m.lastEffect : null;
        if (x !== null) {
          var N = x.next;
          m = N;
          do {
            if ((m.tag & l) === l) {
              x = void 0;
              var R = m.create, H = m.inst;
              x = R(), H.destroy = x;
            }
            m = m.next;
          } while (m !== N);
        }
      } catch (J) {
        Gt(d, d.return, J);
      }
    }
    function Ss(l, d, m) {
      try {
        var x = d.updateQueue, N = x !== null ? x.lastEffect : null;
        if (N !== null) {
          var R = N.next;
          x = R;
          do {
            if ((x.tag & l) === l) {
              var H = x.inst, J = H.destroy;
              if (J !== void 0) {
                H.destroy = void 0, N = d;
                var re = m, fe = J;
                try {
                  fe();
                } catch (ve) {
                  Gt(
                    N,
                    re,
                    ve
                  );
                }
              }
            }
            x = x.next;
          } while (x !== R);
        }
      } catch (ve) {
        Gt(d, d.return, ve);
      }
    }
    function NR(l) {
      var d = l.updateQueue;
      if (d !== null) {
        var m = l.stateNode;
        try {
          bM(d, m);
        } catch (x) {
          Gt(l, l.return, x);
        }
      }
    }
    function MR(l, d, m) {
      m.props = Dl(
        l.type,
        l.memoizedProps
      ), m.state = l.memoizedState;
      try {
        m.componentWillUnmount();
      } catch (x) {
        Gt(l, d, x);
      }
    }
    function Of(l, d) {
      try {
        var m = l.ref;
        if (m !== null) {
          switch (l.tag) {
            case 26:
            case 27:
            case 5:
              var x = l.stateNode;
              break;
            case 30:
              x = l.stateNode;
              break;
            default:
              x = l.stateNode;
          }
          typeof m == "function" ? l.refCleanup = m(x) : m.current = x;
        }
      } catch (N) {
        Gt(l, d, N);
      }
    }
    function ma(l, d) {
      var m = l.ref, x = l.refCleanup;
      if (m !== null)
        if (typeof x == "function")
          try {
            x();
          } catch (N) {
            Gt(l, d, N);
          } finally {
            l.refCleanup = null, l = l.alternate, l != null && (l.refCleanup = null);
          }
        else if (typeof m == "function")
          try {
            m(null);
          } catch (N) {
            Gt(l, d, N);
          }
        else m.current = null;
    }
    function RR(l) {
      var d = l.type, m = l.memoizedProps, x = l.stateNode;
      try {
        e: switch (d) {
          case "button":
          case "input":
          case "select":
          case "textarea":
            m.autoFocus && x.focus();
            break e;
          case "img":
            m.src ? x.src = m.src : m.srcSet && (x.srcset = m.srcSet);
        }
      } catch (N) {
        Gt(l, l.return, N);
      }
    }
    function pS(l, d, m) {
      try {
        var x = l.stateNode;
        yK(x, l.type, m, d), x[pr] = d;
      } catch (N) {
        Gt(l, l.return, N);
      }
    }
    function jR(l) {
      return l.tag === 5 || l.tag === 3 || l.tag === 26 || l.tag === 27 && Ms(l.type) || l.tag === 4;
    }
    function mS(l) {
      e: for (; ; ) {
        for (; l.sibling === null; ) {
          if (l.return === null || jR(l.return)) return null;
          l = l.return;
        }
        for (l.sibling.return = l.return, l = l.sibling; l.tag !== 5 && l.tag !== 6 && l.tag !== 18; ) {
          if (l.tag === 27 && Ms(l.type) || l.flags & 2 || l.child === null || l.tag === 4) continue e;
          l.child.return = l, l = l.child;
        }
        if (!(l.flags & 2)) return l.stateNode;
      }
    }
    function hS(l, d, m) {
      var x = l.tag;
      if (x === 5 || x === 6)
        l = l.stateNode, d ? (m.nodeType === 9 ? m.body : m.nodeName === "HTML" ? m.ownerDocument.body : m).insertBefore(l, d) : (d = m.nodeType === 9 ? m.body : m.nodeName === "HTML" ? m.ownerDocument.body : m, d.appendChild(l), m = m._reactRootContainer, m != null || d.onclick !== null || (d.onclick = si));
      else if (x !== 4 && (x === 27 && Ms(l.type) && (m = l.stateNode, d = null), l = l.child, l !== null))
        for (hS(l, d, m), l = l.sibling; l !== null; )
          hS(l, d, m), l = l.sibling;
    }
    function wg(l, d, m) {
      var x = l.tag;
      if (x === 5 || x === 6)
        l = l.stateNode, d ? m.insertBefore(l, d) : m.appendChild(l);
      else if (x !== 4 && (x === 27 && Ms(l.type) && (m = l.stateNode), l = l.child, l !== null))
        for (wg(l, d, m), l = l.sibling; l !== null; )
          wg(l, d, m), l = l.sibling;
    }
    function IR(l) {
      var d = l.stateNode, m = l.memoizedProps;
      try {
        for (var x = l.type, N = d.attributes; N.length; )
          d.removeAttributeNode(N[0]);
        ar(d, x, m), d[qn] = l, d[pr] = m;
      } catch (R) {
        Gt(l, l.return, R);
      }
    }
    var vi = !1, Tn = !1, gS = !1, AR = typeof WeakSet == "function" ? WeakSet : Set, Jn = null;
    function Jq(l, d) {
      if (l = l.containerInfo, LS = Bg, l = qN(l), uk(l)) {
        if ("selectionStart" in l)
          var m = {
            start: l.selectionStart,
            end: l.selectionEnd
          };
        else
          e: {
            m = (m = l.ownerDocument) && m.defaultView || window;
            var x = m.getSelection && m.getSelection();
            if (x && x.rangeCount !== 0) {
              m = x.anchorNode;
              var N = x.anchorOffset, R = x.focusNode;
              x = x.focusOffset;
              try {
                m.nodeType, R.nodeType;
              } catch {
                m = null;
                break e;
              }
              var H = 0, J = -1, re = -1, fe = 0, ve = 0, xe = l, pe = null;
              t: for (; ; ) {
                for (var ge; xe !== m || N !== 0 && xe.nodeType !== 3 || (J = H + N), xe !== R || x !== 0 && xe.nodeType !== 3 || (re = H + x), xe.nodeType === 3 && (H += xe.nodeValue.length), (ge = xe.firstChild) !== null; )
                  pe = xe, xe = ge;
                for (; ; ) {
                  if (xe === l) break t;
                  if (pe === m && ++fe === N && (J = H), pe === R && ++ve === x && (re = H), (ge = xe.nextSibling) !== null) break;
                  xe = pe, pe = xe.parentNode;
                }
                xe = ge;
              }
              m = J === -1 || re === -1 ? null : { start: J, end: re };
            } else m = null;
          }
        m = m || { start: 0, end: 0 };
      } else m = null;
      for (FS = { focusedElem: l, selectionRange: m }, Bg = !1, Jn = d; Jn !== null; )
        if (d = Jn, l = d.child, (d.subtreeFlags & 1028) !== 0 && l !== null)
          l.return = d, Jn = l;
        else
          for (; Jn !== null; ) {
            switch (d = Jn, R = d.alternate, l = d.flags, d.tag) {
              case 0:
                if ((l & 4) !== 0 && (l = d.updateQueue, l = l !== null ? l.events : null, l !== null))
                  for (m = 0; m < l.length; m++)
                    N = l[m], N.ref.impl = N.nextImpl;
                break;
              case 11:
              case 15:
                break;
              case 1:
                if ((l & 1024) !== 0 && R !== null) {
                  l = void 0, m = d, N = R.memoizedProps, R = R.memoizedState, x = m.stateNode;
                  try {
                    var Fe = Dl(
                      m.type,
                      N
                    );
                    l = x.getSnapshotBeforeUpdate(
                      Fe,
                      R
                    ), x.__reactInternalSnapshotBeforeUpdate = l;
                  } catch (Ze) {
                    Gt(
                      m,
                      m.return,
                      Ze
                    );
                  }
                }
                break;
              case 3:
                if ((l & 1024) !== 0) {
                  if (l = d.stateNode.containerInfo, m = l.nodeType, m === 9)
                    BS(l);
                  else if (m === 1)
                    switch (l.nodeName) {
                      case "HEAD":
                      case "HTML":
                      case "BODY":
                        BS(l);
                        break;
                      default:
                        l.textContent = "";
                    }
                }
                break;
              case 5:
              case 26:
              case 27:
              case 6:
              case 4:
              case 17:
                break;
              default:
                if ((l & 1024) !== 0) throw Error(r(163));
            }
            if (l = d.sibling, l !== null) {
              l.return = d.return, Jn = l;
              break;
            }
            Jn = d.return;
          }
    }
    function $R(l, d, m) {
      var x = m.flags;
      switch (m.tag) {
        case 0:
        case 11:
        case 15:
          bi(l, m), x & 4 && Pf(5, m);
          break;
        case 1:
          if (bi(l, m), x & 4)
            if (l = m.stateNode, d === null)
              try {
                l.componentDidMount();
              } catch (H) {
                Gt(m, m.return, H);
              }
            else {
              var N = Dl(
                m.type,
                d.memoizedProps
              );
              d = d.memoizedState;
              try {
                l.componentDidUpdate(
                  N,
                  d,
                  l.__reactInternalSnapshotBeforeUpdate
                );
              } catch (H) {
                Gt(
                  m,
                  m.return,
                  H
                );
              }
            }
          x & 64 && NR(m), x & 512 && Of(m, m.return);
          break;
        case 3:
          if (bi(l, m), x & 64 && (l = m.updateQueue, l !== null)) {
            if (d = null, m.child !== null)
              switch (m.child.tag) {
                case 27:
                case 5:
                  d = m.child.stateNode;
                  break;
                case 1:
                  d = m.child.stateNode;
              }
            try {
              bM(l, d);
            } catch (H) {
              Gt(m, m.return, H);
            }
          }
          break;
        case 27:
          d === null && x & 4 && IR(m);
        case 26:
        case 5:
          bi(l, m), d === null && x & 4 && RR(m), x & 512 && Of(m, m.return);
          break;
        case 12:
          bi(l, m);
          break;
        case 31:
          bi(l, m), x & 4 && FR(l, m);
          break;
        case 13:
          bi(l, m), x & 4 && TR(l, m), x & 64 && (l = m.memoizedState, l !== null && (l = l.dehydrated, l !== null && (m = iK.bind(
            null,
            m
          ), CK(l, m))));
          break;
        case 22:
          if (x = m.memoizedState !== null || vi, !x) {
            d = d !== null && d.memoizedState !== null || Tn, N = vi;
            var R = Tn;
            vi = x, (Tn = d) && !R ? wi(
              l,
              m,
              (m.subtreeFlags & 8772) !== 0
            ) : bi(l, m), vi = N, Tn = R;
          }
          break;
        case 30:
          break;
        default:
          bi(l, m);
      }
    }
    function DR(l) {
      var d = l.alternate;
      d !== null && (l.alternate = null, DR(d)), l.child = null, l.deletions = null, l.sibling = null, l.tag === 5 && (d = l.stateNode, d !== null && Zd(d)), l.stateNode = null, l.return = null, l.dependencies = null, l.memoizedProps = null, l.memoizedState = null, l.pendingProps = null, l.stateNode = null, l.updateQueue = null;
    }
    var wn = null, Ar = !1;
    function yi(l, d, m) {
      for (m = m.child; m !== null; )
        LR(l, d, m), m = m.sibling;
    }
    function LR(l, d, m) {
      if (qt && typeof qt.onCommitFiberUnmount == "function")
        try {
          qt.onCommitFiberUnmount(At, m);
        } catch {
        }
      switch (m.tag) {
        case 26:
          Tn || ma(m, d), yi(
            l,
            d,
            m
          ), m.memoizedState ? m.memoizedState.count-- : m.stateNode && (m = m.stateNode, m.parentNode.removeChild(m));
          break;
        case 27:
          Tn || ma(m, d);
          var x = wn, N = Ar;
          Ms(m.type) && (wn = m.stateNode, Ar = !1), yi(
            l,
            d,
            m
          ), Lf(m.stateNode), wn = x, Ar = N;
          break;
        case 5:
          Tn || ma(m, d);
        case 6:
          if (x = wn, N = Ar, wn = null, yi(
            l,
            d,
            m
          ), wn = x, Ar = N, wn !== null)
            if (Ar)
              try {
                (wn.nodeType === 9 ? wn.body : wn.nodeName === "HTML" ? wn.ownerDocument.body : wn).removeChild(m.stateNode);
              } catch (R) {
                Gt(
                  m,
                  d,
                  R
                );
              }
            else
              try {
                wn.removeChild(m.stateNode);
              } catch (R) {
                Gt(
                  m,
                  d,
                  R
                );
              }
          break;
        case 18:
          wn !== null && (Ar ? (l = wn, Nj(
            l.nodeType === 9 ? l.body : l.nodeName === "HTML" ? l.ownerDocument.body : l,
            m.stateNode
          ), vc(l)) : Nj(wn, m.stateNode));
          break;
        case 4:
          x = wn, N = Ar, wn = m.stateNode.containerInfo, Ar = !0, yi(
            l,
            d,
            m
          ), wn = x, Ar = N;
          break;
        case 0:
        case 11:
        case 14:
        case 15:
          Ss(2, m, d), Tn || Ss(4, m, d), yi(
            l,
            d,
            m
          );
          break;
        case 1:
          Tn || (ma(m, d), x = m.stateNode, typeof x.componentWillUnmount == "function" && MR(
            m,
            d,
            x
          )), yi(
            l,
            d,
            m
          );
          break;
        case 21:
          yi(
            l,
            d,
            m
          );
          break;
        case 22:
          Tn = (x = Tn) || m.memoizedState !== null, yi(
            l,
            d,
            m
          ), Tn = x;
          break;
        default:
          yi(
            l,
            d,
            m
          );
      }
    }
    function FR(l, d) {
      if (d.memoizedState === null && (l = d.alternate, l !== null && (l = l.memoizedState, l !== null))) {
        l = l.dehydrated;
        try {
          vc(l);
        } catch (m) {
          Gt(d, d.return, m);
        }
      }
    }
    function TR(l, d) {
      if (d.memoizedState === null && (l = d.alternate, l !== null && (l = l.memoizedState, l !== null && (l = l.dehydrated, l !== null))))
        try {
          vc(l);
        } catch (m) {
          Gt(d, d.return, m);
        }
    }
    function Qq(l) {
      switch (l.tag) {
        case 31:
        case 13:
        case 19:
          var d = l.stateNode;
          return d === null && (d = l.stateNode = new AR()), d;
        case 22:
          return l = l.stateNode, d = l._retryCache, d === null && (d = l._retryCache = new AR()), d;
        default:
          throw Error(r(435, l.tag));
      }
    }
    function xg(l, d) {
      var m = Qq(l);
      d.forEach(function(x) {
        if (!m.has(x)) {
          m.add(x);
          var N = sK.bind(null, l, x);
          x.then(N, N);
        }
      });
    }
    function $r(l, d) {
      var m = d.deletions;
      if (m !== null)
        for (var x = 0; x < m.length; x++) {
          var N = m[x], R = l, H = d, J = H;
          e: for (; J !== null; ) {
            switch (J.tag) {
              case 27:
                if (Ms(J.type)) {
                  wn = J.stateNode, Ar = !1;
                  break e;
                }
                break;
              case 5:
                wn = J.stateNode, Ar = !1;
                break e;
              case 3:
              case 4:
                wn = J.stateNode.containerInfo, Ar = !0;
                break e;
            }
            J = J.return;
          }
          if (wn === null) throw Error(r(160));
          LR(R, H, N), wn = null, Ar = !1, R = N.alternate, R !== null && (R.return = null), N.return = null;
        }
      if (d.subtreeFlags & 13886)
        for (d = d.child; d !== null; )
          zR(d, l), d = d.sibling;
    }
    var Uo = null;
    function zR(l, d) {
      var m = l.alternate, x = l.flags;
      switch (l.tag) {
        case 0:
        case 11:
        case 14:
        case 15:
          $r(d, l), Dr(l), x & 4 && (Ss(3, l, l.return), Pf(3, l), Ss(5, l, l.return));
          break;
        case 1:
          $r(d, l), Dr(l), x & 512 && (Tn || m === null || ma(m, m.return)), x & 64 && vi && (l = l.updateQueue, l !== null && (x = l.callbacks, x !== null && (m = l.shared.hiddenCallbacks, l.shared.hiddenCallbacks = m === null ? x : m.concat(x))));
          break;
        case 26:
          var N = Uo;
          if ($r(d, l), Dr(l), x & 512 && (Tn || m === null || ma(m, m.return)), x & 4) {
            var R = m !== null ? m.memoizedState : null;
            if (x = l.memoizedState, m === null)
              if (x === null)
                if (l.stateNode === null) {
                  e: {
                    x = l.type, m = l.memoizedProps, N = N.ownerDocument || N;
                    t: switch (x) {
                      case "title":
                        R = N.getElementsByTagName("title")[0], (!R || R[wl] || R[qn] || R.namespaceURI === "http://www.w3.org/2000/svg" || R.hasAttribute("itemprop")) && (R = N.createElement(x), N.head.insertBefore(
                          R,
                          N.querySelector("head > title")
                        )), ar(R, x, m), R[qn] = l, $n(R), x = R;
                        break e;
                      case "link":
                        var H = zj(
                          "link",
                          "href",
                          N
                        ).get(x + (m.href || ""));
                        if (H) {
                          for (var J = 0; J < H.length; J++)
                            if (R = H[J], R.getAttribute("href") === (m.href == null || m.href === "" ? null : m.href) && R.getAttribute("rel") === (m.rel == null ? null : m.rel) && R.getAttribute("title") === (m.title == null ? null : m.title) && R.getAttribute("crossorigin") === (m.crossOrigin == null ? null : m.crossOrigin)) {
                              H.splice(J, 1);
                              break t;
                            }
                        }
                        R = N.createElement(x), ar(R, x, m), N.head.appendChild(R);
                        break;
                      case "meta":
                        if (H = zj(
                          "meta",
                          "content",
                          N
                        ).get(x + (m.content || ""))) {
                          for (J = 0; J < H.length; J++)
                            if (R = H[J], R.getAttribute("content") === (m.content == null ? null : "" + m.content) && R.getAttribute("name") === (m.name == null ? null : m.name) && R.getAttribute("property") === (m.property == null ? null : m.property) && R.getAttribute("http-equiv") === (m.httpEquiv == null ? null : m.httpEquiv) && R.getAttribute("charset") === (m.charSet == null ? null : m.charSet)) {
                              H.splice(J, 1);
                              break t;
                            }
                        }
                        R = N.createElement(x), ar(R, x, m), N.head.appendChild(R);
                        break;
                      default:
                        throw Error(r(468, x));
                    }
                    R[qn] = l, $n(R), x = R;
                  }
                  l.stateNode = x;
                } else
                  Bj(
                    N,
                    l.type,
                    l.stateNode
                  );
              else
                l.stateNode = Tj(
                  N,
                  x,
                  l.memoizedProps
                );
            else
              R !== x ? (R === null ? m.stateNode !== null && (m = m.stateNode, m.parentNode.removeChild(m)) : R.count--, x === null ? Bj(
                N,
                l.type,
                l.stateNode
              ) : Tj(
                N,
                x,
                l.memoizedProps
              )) : x === null && l.stateNode !== null && pS(
                l,
                l.memoizedProps,
                m.memoizedProps
              );
          }
          break;
        case 27:
          $r(d, l), Dr(l), x & 512 && (Tn || m === null || ma(m, m.return)), m !== null && x & 4 && pS(
            l,
            l.memoizedProps,
            m.memoizedProps
          );
          break;
        case 5:
          if ($r(d, l), Dr(l), x & 512 && (Tn || m === null || ma(m, m.return)), l.flags & 32) {
            N = l.stateNode;
            try {
              zu(N, "");
            } catch (Fe) {
              Gt(l, l.return, Fe);
            }
          }
          x & 4 && l.stateNode != null && (N = l.memoizedProps, pS(
            l,
            N,
            m !== null ? m.memoizedProps : N
          )), x & 1024 && (gS = !0);
          break;
        case 6:
          if ($r(d, l), Dr(l), x & 4) {
            if (l.stateNode === null)
              throw Error(r(162));
            x = l.memoizedProps, m = l.stateNode;
            try {
              m.nodeValue = x;
            } catch (Fe) {
              Gt(l, l.return, Fe);
            }
          }
          break;
        case 3:
          if (Lg = null, N = Uo, Uo = $g(d.containerInfo), $r(d, l), Uo = N, Dr(l), x & 4 && m !== null && m.memoizedState.isDehydrated)
            try {
              vc(d.containerInfo);
            } catch (Fe) {
              Gt(l, l.return, Fe);
            }
          gS && (gS = !1, BR(l));
          break;
        case 4:
          x = Uo, Uo = $g(
            l.stateNode.containerInfo
          ), $r(d, l), Dr(l), Uo = x;
          break;
        case 12:
          $r(d, l), Dr(l);
          break;
        case 31:
          $r(d, l), Dr(l), x & 4 && (x = l.updateQueue, x !== null && (l.updateQueue = null, xg(l, x)));
          break;
        case 13:
          $r(d, l), Dr(l), l.child.flags & 8192 && l.memoizedState !== null != (m !== null && m.memoizedState !== null) && (Sg = Ee()), x & 4 && (x = l.updateQueue, x !== null && (l.updateQueue = null, xg(l, x)));
          break;
        case 22:
          N = l.memoizedState !== null;
          var re = m !== null && m.memoizedState !== null, fe = vi, ve = Tn;
          if (vi = fe || N, Tn = ve || re, $r(d, l), Tn = ve, vi = fe, Dr(l), x & 8192)
            e: for (d = l.stateNode, d._visibility = N ? d._visibility & -2 : d._visibility | 1, N && (m === null || re || vi || Tn || Ll(l)), m = null, d = l; ; ) {
              if (d.tag === 5 || d.tag === 26) {
                if (m === null) {
                  re = m = d;
                  try {
                    if (R = re.stateNode, N)
                      H = R.style, typeof H.setProperty == "function" ? H.setProperty("display", "none", "important") : H.display = "none";
                    else {
                      J = re.stateNode;
                      var xe = re.memoizedProps.style, pe = xe != null && xe.hasOwnProperty("display") ? xe.display : null;
                      J.style.display = pe == null || typeof pe == "boolean" ? "" : ("" + pe).trim();
                    }
                  } catch (Fe) {
                    Gt(re, re.return, Fe);
                  }
                }
              } else if (d.tag === 6) {
                if (m === null) {
                  re = d;
                  try {
                    re.stateNode.nodeValue = N ? "" : re.memoizedProps;
                  } catch (Fe) {
                    Gt(re, re.return, Fe);
                  }
                }
              } else if (d.tag === 18) {
                if (m === null) {
                  re = d;
                  try {
                    var ge = re.stateNode;
                    N ? Mj(ge, !0) : Mj(re.stateNode, !1);
                  } catch (Fe) {
                    Gt(re, re.return, Fe);
                  }
                }
              } else if ((d.tag !== 22 && d.tag !== 23 || d.memoizedState === null || d === l) && d.child !== null) {
                d.child.return = d, d = d.child;
                continue;
              }
              if (d === l) break e;
              for (; d.sibling === null; ) {
                if (d.return === null || d.return === l) break e;
                m === d && (m = null), d = d.return;
              }
              m === d && (m = null), d.sibling.return = d.return, d = d.sibling;
            }
          x & 4 && (x = l.updateQueue, x !== null && (m = x.retryQueue, m !== null && (x.retryQueue = null, xg(l, m))));
          break;
        case 19:
          $r(d, l), Dr(l), x & 4 && (x = l.updateQueue, x !== null && (l.updateQueue = null, xg(l, x)));
          break;
        case 30:
          break;
        case 21:
          break;
        default:
          $r(d, l), Dr(l);
      }
    }
    function Dr(l) {
      var d = l.flags;
      if (d & 2) {
        try {
          for (var m, x = l.return; x !== null; ) {
            if (jR(x)) {
              m = x;
              break;
            }
            x = x.return;
          }
          if (m == null) throw Error(r(160));
          switch (m.tag) {
            case 27:
              var N = m.stateNode, R = mS(l);
              wg(l, R, N);
              break;
            case 5:
              var H = m.stateNode;
              m.flags & 32 && (zu(H, ""), m.flags &= -33);
              var J = mS(l);
              wg(l, J, H);
              break;
            case 3:
            case 4:
              var re = m.stateNode.containerInfo, fe = mS(l);
              hS(
                l,
                fe,
                re
              );
              break;
            default:
              throw Error(r(161));
          }
        } catch (ve) {
          Gt(l, l.return, ve);
        }
        l.flags &= -3;
      }
      d & 4096 && (l.flags &= -4097);
    }
    function BR(l) {
      if (l.subtreeFlags & 1024)
        for (l = l.child; l !== null; ) {
          var d = l;
          BR(d), d.tag === 5 && d.flags & 1024 && d.stateNode.reset(), l = l.sibling;
        }
    }
    function bi(l, d) {
      if (d.subtreeFlags & 8772)
        for (d = d.child; d !== null; )
          $R(l, d.alternate, d), d = d.sibling;
    }
    function Ll(l) {
      for (l = l.child; l !== null; ) {
        var d = l;
        switch (d.tag) {
          case 0:
          case 11:
          case 14:
          case 15:
            Ss(4, d, d.return), Ll(d);
            break;
          case 1:
            ma(d, d.return);
            var m = d.stateNode;
            typeof m.componentWillUnmount == "function" && MR(
              d,
              d.return,
              m
            ), Ll(d);
            break;
          case 27:
            Lf(d.stateNode);
          case 26:
          case 5:
            ma(d, d.return), Ll(d);
            break;
          case 22:
            d.memoizedState === null && Ll(d);
            break;
          case 30:
            Ll(d);
            break;
          default:
            Ll(d);
        }
        l = l.sibling;
      }
    }
    function wi(l, d, m) {
      for (m = m && (d.subtreeFlags & 8772) !== 0, d = d.child; d !== null; ) {
        var x = d.alternate, N = l, R = d, H = R.flags;
        switch (R.tag) {
          case 0:
          case 11:
          case 15:
            wi(
              N,
              R,
              m
            ), Pf(4, R);
            break;
          case 1:
            if (wi(
              N,
              R,
              m
            ), x = R, N = x.stateNode, typeof N.componentDidMount == "function")
              try {
                N.componentDidMount();
              } catch (fe) {
                Gt(x, x.return, fe);
              }
            if (x = R, N = x.updateQueue, N !== null) {
              var J = x.stateNode;
              try {
                var re = N.shared.hiddenCallbacks;
                if (re !== null)
                  for (N.shared.hiddenCallbacks = null, N = 0; N < re.length; N++)
                    yM(re[N], J);
              } catch (fe) {
                Gt(x, x.return, fe);
              }
            }
            m && H & 64 && NR(R), Of(R, R.return);
            break;
          case 27:
            IR(R);
          case 26:
          case 5:
            wi(
              N,
              R,
              m
            ), m && x === null && H & 4 && RR(R), Of(R, R.return);
            break;
          case 12:
            wi(
              N,
              R,
              m
            );
            break;
          case 31:
            wi(
              N,
              R,
              m
            ), m && H & 4 && FR(N, R);
            break;
          case 13:
            wi(
              N,
              R,
              m
            ), m && H & 4 && TR(N, R);
            break;
          case 22:
            R.memoizedState === null && wi(
              N,
              R,
              m
            ), Of(R, R.return);
            break;
          case 30:
            break;
          default:
            wi(
              N,
              R,
              m
            );
        }
        d = d.sibling;
      }
    }
    function vS(l, d) {
      var m = null;
      l !== null && l.memoizedState !== null && l.memoizedState.cachePool !== null && (m = l.memoizedState.cachePool.pool), l = null, d.memoizedState !== null && d.memoizedState.cachePool !== null && (l = d.memoizedState.cachePool.pool), l !== m && (l != null && l.refCount++, m != null && mf(m));
    }
    function yS(l, d) {
      l = null, d.alternate !== null && (l = d.alternate.memoizedState.cache), d = d.memoizedState.cache, d !== l && (d.refCount++, l != null && mf(l));
    }
    function Ho(l, d, m, x) {
      if (d.subtreeFlags & 10256)
        for (d = d.child; d !== null; )
          VR(
            l,
            d,
            m,
            x
          ), d = d.sibling;
    }
    function VR(l, d, m, x) {
      var N = d.flags;
      switch (d.tag) {
        case 0:
        case 11:
        case 15:
          Ho(
            l,
            d,
            m,
            x
          ), N & 2048 && Pf(9, d);
          break;
        case 1:
          Ho(
            l,
            d,
            m,
            x
          );
          break;
        case 3:
          Ho(
            l,
            d,
            m,
            x
          ), N & 2048 && (l = null, d.alternate !== null && (l = d.alternate.memoizedState.cache), d = d.memoizedState.cache, d !== l && (d.refCount++, l != null && mf(l)));
          break;
        case 12:
          if (N & 2048) {
            Ho(
              l,
              d,
              m,
              x
            ), l = d.stateNode;
            try {
              var R = d.memoizedProps, H = R.id, J = R.onPostCommit;
              typeof J == "function" && J(
                H,
                d.alternate === null ? "mount" : "update",
                l.passiveEffectDuration,
                -0
              );
            } catch (re) {
              Gt(d, d.return, re);
            }
          } else
            Ho(
              l,
              d,
              m,
              x
            );
          break;
        case 31:
          Ho(
            l,
            d,
            m,
            x
          );
          break;
        case 13:
          Ho(
            l,
            d,
            m,
            x
          );
          break;
        case 23:
          break;
        case 22:
          R = d.stateNode, H = d.alternate, d.memoizedState !== null ? R._visibility & 2 ? Ho(
            l,
            d,
            m,
            x
          ) : Nf(l, d) : R._visibility & 2 ? Ho(
            l,
            d,
            m,
            x
          ) : (R._visibility |= 2, ic(
            l,
            d,
            m,
            x,
            (d.subtreeFlags & 10256) !== 0 || !1
          )), N & 2048 && vS(H, d);
          break;
        case 24:
          Ho(
            l,
            d,
            m,
            x
          ), N & 2048 && yS(d.alternate, d);
          break;
        default:
          Ho(
            l,
            d,
            m,
            x
          );
      }
    }
    function ic(l, d, m, x, N) {
      for (N = N && ((d.subtreeFlags & 10256) !== 0 || !1), d = d.child; d !== null; ) {
        var R = l, H = d, J = m, re = x, fe = H.flags;
        switch (H.tag) {
          case 0:
          case 11:
          case 15:
            ic(
              R,
              H,
              J,
              re,
              N
            ), Pf(8, H);
            break;
          case 23:
            break;
          case 22:
            var ve = H.stateNode;
            H.memoizedState !== null ? ve._visibility & 2 ? ic(
              R,
              H,
              J,
              re,
              N
            ) : Nf(
              R,
              H
            ) : (ve._visibility |= 2, ic(
              R,
              H,
              J,
              re,
              N
            )), N && fe & 2048 && vS(
              H.alternate,
              H
            );
            break;
          case 24:
            ic(
              R,
              H,
              J,
              re,
              N
            ), N && fe & 2048 && yS(H.alternate, H);
            break;
          default:
            ic(
              R,
              H,
              J,
              re,
              N
            );
        }
        d = d.sibling;
      }
    }
    function Nf(l, d) {
      if (d.subtreeFlags & 10256)
        for (d = d.child; d !== null; ) {
          var m = l, x = d, N = x.flags;
          switch (x.tag) {
            case 22:
              Nf(m, x), N & 2048 && vS(
                x.alternate,
                x
              );
              break;
            case 24:
              Nf(m, x), N & 2048 && yS(x.alternate, x);
              break;
            default:
              Nf(m, x);
          }
          d = d.sibling;
        }
    }
    var Mf = 8192;
    function sc(l, d, m) {
      if (l.subtreeFlags & Mf)
        for (l = l.child; l !== null; )
          UR(
            l,
            d,
            m
          ), l = l.sibling;
    }
    function UR(l, d, m) {
      switch (l.tag) {
        case 26:
          sc(
            l,
            d,
            m
          ), l.flags & Mf && l.memoizedState !== null && FK(
            m,
            Uo,
            l.memoizedState,
            l.memoizedProps
          );
          break;
        case 5:
          sc(
            l,
            d,
            m
          );
          break;
        case 3:
        case 4:
          var x = Uo;
          Uo = $g(l.stateNode.containerInfo), sc(
            l,
            d,
            m
          ), Uo = x;
          break;
        case 22:
          l.memoizedState === null && (x = l.alternate, x !== null && x.memoizedState !== null ? (x = Mf, Mf = 16777216, sc(
            l,
            d,
            m
          ), Mf = x) : sc(
            l,
            d,
            m
          ));
          break;
        default:
          sc(
            l,
            d,
            m
          );
      }
    }
    function HR(l) {
      var d = l.alternate;
      if (d !== null && (l = d.child, l !== null)) {
        d.child = null;
        do
          d = l.sibling, l.sibling = null, l = d;
        while (l !== null);
      }
    }
    function Rf(l) {
      var d = l.deletions;
      if ((l.flags & 16) !== 0) {
        if (d !== null)
          for (var m = 0; m < d.length; m++) {
            var x = d[m];
            Jn = x, qR(
              x,
              l
            );
          }
        HR(l);
      }
      if (l.subtreeFlags & 10256)
        for (l = l.child; l !== null; )
          WR(l), l = l.sibling;
    }
    function WR(l) {
      switch (l.tag) {
        case 0:
        case 11:
        case 15:
          Rf(l), l.flags & 2048 && Ss(9, l, l.return);
          break;
        case 3:
          Rf(l);
          break;
        case 12:
          Rf(l);
          break;
        case 22:
          var d = l.stateNode;
          l.memoizedState !== null && d._visibility & 2 && (l.return === null || l.return.tag !== 13) ? (d._visibility &= -3, kg(l)) : Rf(l);
          break;
        default:
          Rf(l);
      }
    }
    function kg(l) {
      var d = l.deletions;
      if ((l.flags & 16) !== 0) {
        if (d !== null)
          for (var m = 0; m < d.length; m++) {
            var x = d[m];
            Jn = x, qR(
              x,
              l
            );
          }
        HR(l);
      }
      for (l = l.child; l !== null; ) {
        switch (d = l, d.tag) {
          case 0:
          case 11:
          case 15:
            Ss(8, d, d.return), kg(d);
            break;
          case 22:
            m = d.stateNode, m._visibility & 2 && (m._visibility &= -3, kg(d));
            break;
          default:
            kg(d);
        }
        l = l.sibling;
      }
    }
    function qR(l, d) {
      for (; Jn !== null; ) {
        var m = Jn;
        switch (m.tag) {
          case 0:
          case 11:
          case 15:
            Ss(8, m, d);
            break;
          case 23:
          case 22:
            if (m.memoizedState !== null && m.memoizedState.cachePool !== null) {
              var x = m.memoizedState.cachePool.pool;
              x != null && x.refCount++;
            }
            break;
          case 24:
            mf(m.memoizedState.cache);
        }
        if (x = m.child, x !== null) x.return = m, Jn = x;
        else
          e: for (m = l; Jn !== null; ) {
            x = Jn;
            var N = x.sibling, R = x.return;
            if (DR(x), x === m) {
              Jn = null;
              break e;
            }
            if (N !== null) {
              N.return = R, Jn = N;
              break e;
            }
            Jn = R;
          }
      }
    }
    var Zq = {
      getCacheForType: function(l) {
        var d = rr(Dn), m = d.data.get(l);
        return m === void 0 && (m = l(), d.data.set(l, m)), m;
      },
      cacheSignal: function() {
        return rr(Dn).controller.signal;
      }
    }, eK = typeof WeakMap == "function" ? WeakMap : Map, Tt = 0, an = null, wt = null, St = 0, Kt = 0, Zr = null, _s = !1, lc = !1, bS = !1, xi = 0, Cn = 0, Es = 0, Fl = 0, wS = 0, eo = 0, uc = 0, jf = null, Lr = null, xS = !1, Sg = 0, KR = 0, _g = 1 / 0, Eg = null, Cs = null, Kn = 0, Ps = null, cc = null, ki = 0, kS = 0, SS = null, GR = null, If = 0, _S = null;
    function to() {
      return (Tt & 2) !== 0 && St !== 0 ? St & -St : B.T !== null ? MS() : Nh();
    }
    function XR() {
      if (eo === 0)
        if ((St & 536870912) === 0 || Pt) {
          var l = on;
          on <<= 1, (on & 3932160) === 0 && (on = 262144), eo = l;
        } else eo = 536870912;
      return l = Jr.current, l !== null && (l.flags |= 32), eo;
    }
    function Fr(l, d, m) {
      (l === an && (Kt === 2 || Kt === 9) || l.cancelPendingCommit !== null) && (dc(l, 0), Os(
        l,
        St,
        eo,
        !1
      )), bl(l, m), ((Tt & 2) === 0 || l !== an) && (l === an && ((Tt & 2) === 0 && (Fl |= m), Cn === 4 && Os(
        l,
        St,
        eo,
        !1
      )), ha(l));
    }
    function YR(l, d, m) {
      if ((Tt & 6) !== 0) throw Error(r(327));
      var x = !m && (d & 127) === 0 && (d & l.expiredLanes) === 0 || tr(l, d), N = x ? rK(l, d) : CS(l, d, !0), R = x;
      do {
        if (N === 0) {
          lc && !x && Os(l, d, 0, !1);
          break;
        } else {
          if (m = l.current.alternate, R && !tK(m)) {
            N = CS(l, d, !1), R = !1;
            continue;
          }
          if (N === 2) {
            if (R = d, l.errorRecoveryDisabledLanes & R)
              var H = 0;
            else
              H = l.pendingLanes & -536870913, H = H !== 0 ? H : H & 536870912 ? 536870912 : 0;
            if (H !== 0) {
              d = H;
              e: {
                var J = l;
                N = jf;
                var re = J.current.memoizedState.isDehydrated;
                if (re && (dc(J, H).flags |= 256), H = CS(
                  J,
                  H,
                  !1
                ), H !== 2) {
                  if (bS && !re) {
                    J.errorRecoveryDisabledLanes |= R, Fl |= R, N = 4;
                    break e;
                  }
                  R = Lr, Lr = N, R !== null && (Lr === null ? Lr = R : Lr.push.apply(
                    Lr,
                    R
                  ));
                }
                N = H;
              }
              if (R = !1, N !== 2) continue;
            }
          }
          if (N === 1) {
            dc(l, 0), Os(l, d, 0, !0);
            break;
          }
          e: {
            switch (x = l, R = N, R) {
              case 0:
              case 1:
                throw Error(r(345));
              case 4:
                if ((d & 4194048) !== d) break;
              case 6:
                Os(
                  x,
                  d,
                  eo,
                  !_s
                );
                break e;
              case 2:
                Lr = null;
                break;
              case 3:
              case 5:
                break;
              default:
                throw Error(r(329));
            }
            if ((d & 62914560) === d && (N = Sg + 300 - Ee(), 10 < N)) {
              if (Os(
                x,
                d,
                eo,
                !_s
              ), To(x, 0, !0) !== 0) break e;
              ki = d, x.timeoutHandle = Pj(
                JR.bind(
                  null,
                  x,
                  m,
                  Lr,
                  Eg,
                  xS,
                  d,
                  eo,
                  Fl,
                  uc,
                  _s,
                  R,
                  "Throttled",
                  -0,
                  0
                ),
                N
              );
              break e;
            }
            JR(
              x,
              m,
              Lr,
              Eg,
              xS,
              d,
              eo,
              Fl,
              uc,
              _s,
              R,
              null,
              -0,
              0
            );
          }
        }
        break;
      } while (!0);
      ha(l);
    }
    function JR(l, d, m, x, N, R, H, J, re, fe, ve, xe, pe, ge) {
      if (l.timeoutHandle = -1, xe = d.subtreeFlags, xe & 8192 || (xe & 16785408) === 16785408) {
        xe = {
          stylesheets: null,
          count: 0,
          imgCount: 0,
          imgBytes: 0,
          suspenseyImages: [],
          waitingForImages: !0,
          waitingForViewTransition: !1,
          unsuspend: si
        }, UR(
          d,
          R,
          xe
        );
        var Fe = (R & 62914560) === R ? Sg - Ee() : (R & 4194048) === R ? KR - Ee() : 0;
        if (Fe = TK(
          xe,
          Fe
        ), Fe !== null) {
          ki = R, l.cancelPendingCommit = Fe(
            aj.bind(
              null,
              l,
              d,
              R,
              m,
              x,
              N,
              H,
              J,
              re,
              ve,
              xe,
              null,
              pe,
              ge
            )
          ), Os(l, R, H, !fe);
          return;
        }
      }
      aj(
        l,
        d,
        R,
        m,
        x,
        N,
        H,
        J,
        re
      );
    }
    function tK(l) {
      for (var d = l; ; ) {
        var m = d.tag;
        if ((m === 0 || m === 11 || m === 15) && d.flags & 16384 && (m = d.updateQueue, m !== null && (m = m.stores, m !== null)))
          for (var x = 0; x < m.length; x++) {
            var N = m[x], R = N.getSnapshot;
            N = N.value;
            try {
              if (!Xr(R(), N)) return !1;
            } catch {
              return !1;
            }
          }
        if (m = d.child, d.subtreeFlags & 16384 && m !== null)
          m.return = d, d = m;
        else {
          if (d === l) break;
          for (; d.sibling === null; ) {
            if (d.return === null || d.return === l) return !0;
            d = d.return;
          }
          d.sibling.return = d.return, d = d.sibling;
        }
      }
      return !0;
    }
    function Os(l, d, m, x) {
      d &= ~wS, d &= ~Fl, l.suspendedLanes |= d, l.pingedLanes &= ~d, x && (l.warmLanes |= d), x = l.expirationTimes;
      for (var N = d; 0 < N; ) {
        var R = 31 - Re(N), H = 1 << R;
        x[R] = -1, N &= ~H;
      }
      m !== 0 && Ch(l, m, d);
    }
    function Cg() {
      return (Tt & 6) === 0 ? (Af(0), !1) : !0;
    }
    function ES() {
      if (wt !== null) {
        if (Kt === 0)
          var l = wt.return;
        else
          l = wt, di = Nl = null, Bk(l), tc = null, gf = 0, l = wt;
        for (; l !== null; )
          OR(l.alternate, l), l = l.return;
        wt = null;
      }
    }
    function dc(l, d) {
      var m = l.timeoutHandle;
      m !== -1 && (l.timeoutHandle = -1, xK(m)), m = l.cancelPendingCommit, m !== null && (l.cancelPendingCommit = null, m()), ki = 0, ES(), an = l, wt = m = ui(l.current, null), St = d, Kt = 0, Zr = null, _s = !1, lc = tr(l, d), bS = !1, uc = eo = wS = Fl = Es = Cn = 0, Lr = jf = null, xS = !1, (d & 8) !== 0 && (d |= d & 32);
      var x = l.entangledLanes;
      if (x !== 0)
        for (l = l.entanglements, x &= d; 0 < x; ) {
          var N = 31 - Re(x), R = 1 << N;
          d |= l[N], x &= ~R;
        }
      return xi = d, Kh(), m;
    }
    function QR(l, d) {
      it = null, B.H = _f, d === ec || d === tg ? (d = mM(), Kt = 3) : d === Nk ? (d = mM(), Kt = 4) : Kt = d === rS ? 8 : d !== null && typeof d == "object" && typeof d.then == "function" ? 6 : 1, Zr = d, wt === null && (Cn = 1, hg(
        l,
        bo(d, l.current)
      ));
    }
    function ZR() {
      var l = Jr.current;
      return l === null ? !0 : (St & 4194048) === St ? Vo === null : (St & 62914560) === St || (St & 536870912) !== 0 ? l === Vo : !1;
    }
    function ej() {
      var l = B.H;
      return B.H = _f, l === null ? _f : l;
    }
    function tj() {
      var l = B.A;
      return B.A = Zq, l;
    }
    function Pg() {
      Cn = 4, _s || (St & 4194048) !== St && Jr.current !== null || (lc = !0), (Es & 134217727) === 0 && (Fl & 134217727) === 0 || an === null || Os(
        an,
        St,
        eo,
        !1
      );
    }
    function CS(l, d, m) {
      var x = Tt;
      Tt |= 2;
      var N = ej(), R = tj();
      (an !== l || St !== d) && (Eg = null, dc(l, d)), d = !1;
      var H = Cn;
      e: do
        try {
          if (Kt !== 0 && wt !== null) {
            var J = wt, re = Zr;
            switch (Kt) {
              case 8:
                ES(), H = 6;
                break e;
              case 3:
              case 2:
              case 9:
              case 6:
                Jr.current === null && (d = !0);
                var fe = Kt;
                if (Kt = 0, Zr = null, fc(l, J, re, fe), m && lc) {
                  H = 0;
                  break e;
                }
                break;
              default:
                fe = Kt, Kt = 0, Zr = null, fc(l, J, re, fe);
            }
          }
          nK(), H = Cn;
          break;
        } catch (ve) {
          QR(l, ve);
        }
      while (!0);
      return d && l.shellSuspendCounter++, di = Nl = null, Tt = x, B.H = N, B.A = R, wt === null && (an = null, St = 0, Kh()), H;
    }
    function nK() {
      for (; wt !== null; ) nj(wt);
    }
    function rK(l, d) {
      var m = Tt;
      Tt |= 2;
      var x = ej(), N = tj();
      an !== l || St !== d ? (Eg = null, _g = Ee() + 500, dc(l, d)) : lc = tr(
        l,
        d
      );
      e: do
        try {
          if (Kt !== 0 && wt !== null) {
            d = wt;
            var R = Zr;
            t: switch (Kt) {
              case 1:
                Kt = 0, Zr = null, fc(l, d, R, 1);
                break;
              case 2:
              case 9:
                if (fM(R)) {
                  Kt = 0, Zr = null, rj(d);
                  break;
                }
                d = function() {
                  Kt !== 2 && Kt !== 9 || an !== l || (Kt = 7), ha(l);
                }, R.then(d, d);
                break e;
              case 3:
                Kt = 7;
                break e;
              case 4:
                Kt = 5;
                break e;
              case 7:
                fM(R) ? (Kt = 0, Zr = null, rj(d)) : (Kt = 0, Zr = null, fc(l, d, R, 7));
                break;
              case 5:
                var H = null;
                switch (wt.tag) {
                  case 26:
                    H = wt.memoizedState;
                  case 5:
                  case 27:
                    var J = wt;
                    if (H ? Vj(H) : J.stateNode.complete) {
                      Kt = 0, Zr = null;
                      var re = J.sibling;
                      if (re !== null) wt = re;
                      else {
                        var fe = J.return;
                        fe !== null ? (wt = fe, Og(fe)) : wt = null;
                      }
                      break t;
                    }
                }
                Kt = 0, Zr = null, fc(l, d, R, 5);
                break;
              case 6:
                Kt = 0, Zr = null, fc(l, d, R, 6);
                break;
              case 8:
                ES(), Cn = 6;
                break e;
              default:
                throw Error(r(462));
            }
          }
          oK();
          break;
        } catch (ve) {
          QR(l, ve);
        }
      while (!0);
      return di = Nl = null, B.H = x, B.A = N, Tt = m, wt !== null ? 0 : (an = null, St = 0, Kh(), Cn);
    }
    function oK() {
      for (; wt !== null && !It(); )
        nj(wt);
    }
    function nj(l) {
      var d = CR(l.alternate, l, xi);
      l.memoizedProps = l.pendingProps, d === null ? Og(l) : wt = d;
    }
    function rj(l) {
      var d = l, m = d.alternate;
      switch (d.tag) {
        case 15:
        case 0:
          d = wR(
            m,
            d,
            d.pendingProps,
            d.type,
            void 0,
            St
          );
          break;
        case 11:
          d = wR(
            m,
            d,
            d.pendingProps,
            d.type.render,
            d.ref,
            St
          );
          break;
        case 5:
          Bk(d);
        default:
          OR(m, d), d = wt = tM(d, xi), d = CR(m, d, xi);
      }
      l.memoizedProps = l.pendingProps, d === null ? Og(l) : wt = d;
    }
    function fc(l, d, m, x) {
      di = Nl = null, Bk(d), tc = null, gf = 0;
      var N = d.return;
      try {
        if (qq(
          l,
          N,
          d,
          m,
          St
        )) {
          Cn = 1, hg(
            l,
            bo(m, l.current)
          ), wt = null;
          return;
        }
      } catch (R) {
        if (N !== null) throw wt = N, R;
        Cn = 1, hg(
          l,
          bo(m, l.current)
        ), wt = null;
        return;
      }
      d.flags & 32768 ? (Pt || x === 1 ? l = !0 : lc || (St & 536870912) !== 0 ? l = !1 : (_s = l = !0, (x === 2 || x === 9 || x === 3 || x === 6) && (x = Jr.current, x !== null && x.tag === 13 && (x.flags |= 16384))), oj(d, l)) : Og(d);
    }
    function Og(l) {
      var d = l;
      do {
        if ((d.flags & 32768) !== 0) {
          oj(
            d,
            _s
          );
          return;
        }
        l = d.return;
        var m = Xq(
          d.alternate,
          d,
          xi
        );
        if (m !== null) {
          wt = m;
          return;
        }
        if (d = d.sibling, d !== null) {
          wt = d;
          return;
        }
        wt = d = l;
      } while (d !== null);
      Cn === 0 && (Cn = 5);
    }
    function oj(l, d) {
      do {
        var m = Yq(l.alternate, l);
        if (m !== null) {
          m.flags &= 32767, wt = m;
          return;
        }
        if (m = l.return, m !== null && (m.flags |= 32768, m.subtreeFlags = 0, m.deletions = null), !d && (l = l.sibling, l !== null)) {
          wt = l;
          return;
        }
        wt = l = m;
      } while (l !== null);
      Cn = 6, wt = null;
    }
    function aj(l, d, m, x, N, R, H, J, re) {
      l.cancelPendingCommit = null;
      do
        Ng();
      while (Kn !== 0);
      if ((Tt & 6) !== 0) throw Error(r(327));
      if (d !== null) {
        if (d === l.current) throw Error(r(177));
        if (R = d.lanes | d.childLanes, R |= mk, Hx(
          l,
          m,
          R,
          H,
          J,
          re
        ), l === an && (wt = an = null, St = 0), cc = d, Ps = l, ki = m, kS = R, SS = N, GR = x, (d.subtreeFlags & 10256) !== 0 || (d.flags & 10256) !== 0 ? (l.callbackNode = null, l.callbackPriority = 0, lK(Se, function() {
          return cj(), null;
        })) : (l.callbackNode = null, l.callbackPriority = 0), x = (d.flags & 13878) !== 0, (d.subtreeFlags & 13878) !== 0 || x) {
          x = B.T, B.T = null, N = G.p, G.p = 2, H = Tt, Tt |= 4;
          try {
            Jq(l, d, m);
          } finally {
            Tt = H, G.p = N, B.T = x;
          }
        }
        Kn = 1, ij(), sj(), lj();
      }
    }
    function ij() {
      if (Kn === 1) {
        Kn = 0;
        var l = Ps, d = cc, m = (d.flags & 13878) !== 0;
        if ((d.subtreeFlags & 13878) !== 0 || m) {
          m = B.T, B.T = null;
          var x = G.p;
          G.p = 2;
          var N = Tt;
          Tt |= 4;
          try {
            zR(d, l);
            var R = FS, H = qN(l.containerInfo), J = R.focusedElem, re = R.selectionRange;
            if (H !== J && J && J.ownerDocument && WN(
              J.ownerDocument.documentElement,
              J
            )) {
              if (re !== null && uk(J)) {
                var fe = re.start, ve = re.end;
                if (ve === void 0 && (ve = fe), "selectionStart" in J)
                  J.selectionStart = fe, J.selectionEnd = Math.min(
                    ve,
                    J.value.length
                  );
                else {
                  var xe = J.ownerDocument || document, pe = xe && xe.defaultView || window;
                  if (pe.getSelection) {
                    var ge = pe.getSelection(), Fe = J.textContent.length, Ze = Math.min(re.start, Fe), tn = re.end === void 0 ? Ze : Math.min(re.end, Fe);
                    !ge.extend && Ze > tn && (H = tn, tn = Ze, Ze = H);
                    var ue = HN(
                      J,
                      Ze
                    ), se = HN(
                      J,
                      tn
                    );
                    if (ue && se && (ge.rangeCount !== 1 || ge.anchorNode !== ue.node || ge.anchorOffset !== ue.offset || ge.focusNode !== se.node || ge.focusOffset !== se.offset)) {
                      var de = xe.createRange();
                      de.setStart(ue.node, ue.offset), ge.removeAllRanges(), Ze > tn ? (ge.addRange(de), ge.extend(se.node, se.offset)) : (de.setEnd(se.node, se.offset), ge.addRange(de));
                    }
                  }
                }
              }
              for (xe = [], ge = J; ge = ge.parentNode; )
                ge.nodeType === 1 && xe.push({
                  element: ge,
                  left: ge.scrollLeft,
                  top: ge.scrollTop
                });
              for (typeof J.focus == "function" && J.focus(), J = 0; J < xe.length; J++) {
                var we = xe[J];
                we.element.scrollLeft = we.left, we.element.scrollTop = we.top;
              }
            }
            Bg = !!LS, FS = LS = null;
          } finally {
            Tt = N, G.p = x, B.T = m;
          }
        }
        l.current = d, Kn = 2;
      }
    }
    function sj() {
      if (Kn === 2) {
        Kn = 0;
        var l = Ps, d = cc, m = (d.flags & 8772) !== 0;
        if ((d.subtreeFlags & 8772) !== 0 || m) {
          m = B.T, B.T = null;
          var x = G.p;
          G.p = 2;
          var N = Tt;
          Tt |= 4;
          try {
            $R(l, d.alternate, d);
          } finally {
            Tt = N, G.p = x, B.T = m;
          }
        }
        Kn = 3;
      }
    }
    function lj() {
      if (Kn === 4 || Kn === 3) {
        Kn = 0, Xe();
        var l = Ps, d = cc, m = ki, x = GR;
        (d.subtreeFlags & 10256) !== 0 || (d.flags & 10256) !== 0 ? Kn = 5 : (Kn = 0, cc = Ps = null, uj(l, l.pendingLanes));
        var N = l.pendingLanes;
        if (N === 0 && (Cs = null), Qd(m), d = d.stateNode, qt && typeof qt.onCommitFiberRoot == "function")
          try {
            qt.onCommitFiberRoot(
              At,
              d,
              void 0,
              (d.current.flags & 128) === 128
            );
          } catch {
          }
        if (x !== null) {
          d = B.T, N = G.p, G.p = 2, B.T = null;
          try {
            for (var R = l.onRecoverableError, H = 0; H < x.length; H++) {
              var J = x[H];
              R(J.value, {
                componentStack: J.stack
              });
            }
          } finally {
            B.T = d, G.p = N;
          }
        }
        (ki & 3) !== 0 && Ng(), ha(l), N = l.pendingLanes, (m & 261930) !== 0 && (N & 42) !== 0 ? l === _S ? If++ : (If = 0, _S = l) : If = 0, Af(0);
      }
    }
    function uj(l, d) {
      (l.pooledCacheLanes &= d) === 0 && (d = l.pooledCache, d != null && (l.pooledCache = null, mf(d)));
    }
    function Ng() {
      return ij(), sj(), lj(), cj();
    }
    function cj() {
      if (Kn !== 5) return !1;
      var l = Ps, d = kS;
      kS = 0;
      var m = Qd(ki), x = B.T, N = G.p;
      try {
        G.p = 32 > m ? 32 : m, B.T = null, m = SS, SS = null;
        var R = Ps, H = ki;
        if (Kn = 0, cc = Ps = null, ki = 0, (Tt & 6) !== 0) throw Error(r(331));
        var J = Tt;
        if (Tt |= 4, WR(R.current), VR(
          R,
          R.current,
          H,
          m
        ), Tt = J, Af(0, !1), qt && typeof qt.onPostCommitFiberRoot == "function")
          try {
            qt.onPostCommitFiberRoot(At, R);
          } catch {
          }
        return !0;
      } finally {
        G.p = N, B.T = x, uj(l, d);
      }
    }
    function dj(l, d, m) {
      d = bo(m, d), d = nS(l.stateNode, d, 2), l = ws(l, d, 2), l !== null && (bl(l, 2), ha(l));
    }
    function Gt(l, d, m) {
      if (l.tag === 3)
        dj(l, l, m);
      else
        for (; d !== null; ) {
          if (d.tag === 3) {
            dj(
              d,
              l,
              m
            );
            break;
          } else if (d.tag === 1) {
            var x = d.stateNode;
            if (typeof d.type.getDerivedStateFromError == "function" || typeof x.componentDidCatch == "function" && (Cs === null || !Cs.has(x))) {
              l = bo(m, l), m = fR(2), x = ws(d, m, 2), x !== null && (pR(
                m,
                x,
                d,
                l
              ), bl(x, 2), ha(x));
              break;
            }
          }
          d = d.return;
        }
    }
    function PS(l, d, m) {
      var x = l.pingCache;
      if (x === null) {
        x = l.pingCache = new eK();
        var N = /* @__PURE__ */ new Set();
        x.set(d, N);
      } else
        N = x.get(d), N === void 0 && (N = /* @__PURE__ */ new Set(), x.set(d, N));
      N.has(m) || (bS = !0, N.add(m), l = aK.bind(null, l, d, m), d.then(l, l));
    }
    function aK(l, d, m) {
      var x = l.pingCache;
      x !== null && x.delete(d), l.pingedLanes |= l.suspendedLanes & m, l.warmLanes &= ~m, an === l && (St & m) === m && (Cn === 4 || Cn === 3 && (St & 62914560) === St && 300 > Ee() - Sg ? (Tt & 2) === 0 && dc(l, 0) : wS |= m, uc === St && (uc = 0)), ha(l);
    }
    function fj(l, d) {
      d === 0 && (d = Eh()), l = Cl(l, d), l !== null && (bl(l, d), ha(l));
    }
    function iK(l) {
      var d = l.memoizedState, m = 0;
      d !== null && (m = d.retryLane), fj(l, m);
    }
    function sK(l, d) {
      var m = 0;
      switch (l.tag) {
        case 31:
        case 13:
          var x = l.stateNode, N = l.memoizedState;
          N !== null && (m = N.retryLane);
          break;
        case 19:
          x = l.stateNode;
          break;
        case 22:
          x = l.stateNode._retryCache;
          break;
        default:
          throw Error(r(314));
      }
      x !== null && x.delete(d), fj(l, m);
    }
    function lK(l, d) {
      return He(l, d);
    }
    var Mg = null, pc = null, OS = !1, Rg = !1, NS = !1, Ns = 0;
    function ha(l) {
      l !== pc && l.next === null && (pc === null ? Mg = pc = l : pc = pc.next = l), Rg = !0, OS || (OS = !0, cK());
    }
    function Af(l, d) {
      if (!NS && Rg) {
        NS = !0;
        do
          for (var m = !1, x = Mg; x !== null; ) {
            if (l !== 0) {
              var N = x.pendingLanes;
              if (N === 0) var R = 0;
              else {
                var H = x.suspendedLanes, J = x.pingedLanes;
                R = (1 << 31 - Re(42 | l) + 1) - 1, R &= N & ~(H & ~J), R = R & 201326741 ? R & 201326741 | 1 : R ? R | 2 : 0;
              }
              R !== 0 && (m = !0, gj(x, R));
            } else
              R = St, R = To(
                x,
                x === an ? R : 0,
                x.cancelPendingCommit !== null || x.timeoutHandle !== -1
              ), (R & 3) === 0 || tr(x, R) || (m = !0, gj(x, R));
            x = x.next;
          }
        while (m);
        NS = !1;
      }
    }
    function uK() {
      pj();
    }
    function pj() {
      Rg = OS = !1;
      var l = 0;
      Ns !== 0 && wK() && (l = Ns);
      for (var d = Ee(), m = null, x = Mg; x !== null; ) {
        var N = x.next, R = mj(x, d);
        R === 0 ? (x.next = null, m === null ? Mg = N : m.next = N, N === null && (pc = m)) : (m = x, (l !== 0 || (R & 3) !== 0) && (Rg = !0)), x = N;
      }
      Kn !== 0 && Kn !== 5 || Af(l), Ns !== 0 && (Ns = 0);
    }
    function mj(l, d) {
      for (var m = l.suspendedLanes, x = l.pingedLanes, N = l.expirationTimes, R = l.pendingLanes & -62914561; 0 < R; ) {
        var H = 31 - Re(R), J = 1 << H, re = N[H];
        re === -1 ? ((J & m) === 0 || (J & x) !== 0) && (N[H] = Ux(J, d)) : re <= d && (l.expiredLanes |= J), R &= ~J;
      }
      if (d = an, m = St, m = To(
        l,
        l === d ? m : 0,
        l.cancelPendingCommit !== null || l.timeoutHandle !== -1
      ), x = l.callbackNode, m === 0 || l === d && (Kt === 2 || Kt === 9) || l.cancelPendingCommit !== null)
        return x !== null && x !== null && Pe(x), l.callbackNode = null, l.callbackPriority = 0;
      if ((m & 3) === 0 || tr(l, m)) {
        if (d = m & -m, d === l.callbackPriority) return d;
        switch (x !== null && Pe(x), Qd(m)) {
          case 2:
          case 8:
            m = me;
            break;
          case 32:
            m = Se;
            break;
          case 268435456:
            m = Ae;
            break;
          default:
            m = Se;
        }
        return x = hj.bind(null, l), m = He(m, x), l.callbackPriority = d, l.callbackNode = m, d;
      }
      return x !== null && x !== null && Pe(x), l.callbackPriority = 2, l.callbackNode = null, 2;
    }
    function hj(l, d) {
      if (Kn !== 0 && Kn !== 5)
        return l.callbackNode = null, l.callbackPriority = 0, null;
      var m = l.callbackNode;
      if (Ng() && l.callbackNode !== m)
        return null;
      var x = St;
      return x = To(
        l,
        l === an ? x : 0,
        l.cancelPendingCommit !== null || l.timeoutHandle !== -1
      ), x === 0 ? null : (YR(l, x, d), mj(l, Ee()), l.callbackNode != null && l.callbackNode === m ? hj.bind(null, l) : null);
    }
    function gj(l, d) {
      if (Ng()) return null;
      YR(l, d, !0);
    }
    function cK() {
      kK(function() {
        (Tt & 6) !== 0 ? He(
          ie,
          uK
        ) : pj();
      });
    }
    function MS() {
      if (Ns === 0) {
        var l = Qu;
        l === 0 && (l = Fo, Fo <<= 1, (Fo & 261888) === 0 && (Fo = 256)), Ns = l;
      }
      return Ns;
    }
    function vj(l) {
      return l == null || typeof l == "symbol" || typeof l == "boolean" ? null : typeof l == "function" ? l : Th("" + l);
    }
    function yj(l, d) {
      var m = d.ownerDocument.createElement("input");
      return m.name = d.name, m.value = d.value, l.id && m.setAttribute("form", l.id), d.parentNode.insertBefore(m, d), l = new FormData(l), m.parentNode.removeChild(m), l;
    }
    function dK(l, d, m, x, N) {
      if (d === "submit" && m && m.stateNode === N) {
        var R = vj(
          (N[pr] || null).action
        ), H = x.submitter;
        H && (d = (d = H[pr] || null) ? vj(d.formAction) : H.getAttribute("formAction"), d !== null && (R = d, H = null));
        var J = new Uh(
          "action",
          "action",
          null,
          x,
          N
        );
        l.push({
          event: J,
          listeners: [
            {
              instance: null,
              listener: function() {
                if (x.defaultPrevented) {
                  if (Ns !== 0) {
                    var re = H ? yj(N, H) : new FormData(N);
                    Yk(
                      m,
                      {
                        pending: !0,
                        data: re,
                        method: N.method,
                        action: R
                      },
                      null,
                      re
                    );
                  }
                } else
                  typeof R == "function" && (J.preventDefault(), re = H ? yj(N, H) : new FormData(N), Yk(
                    m,
                    {
                      pending: !0,
                      data: re,
                      method: N.method,
                      action: R
                    },
                    R,
                    re
                  ));
              },
              currentTarget: N
            }
          ]
        });
      }
    }
    for (var RS = 0; RS < pk.length; RS++) {
      var jS = pk[RS], fK = jS.toLowerCase(), pK = jS[0].toUpperCase() + jS.slice(1);
      Bo(
        fK,
        "on" + pK
      );
    }
    Bo(XN, "onAnimationEnd"), Bo(YN, "onAnimationIteration"), Bo(JN, "onAnimationStart"), Bo("dblclick", "onDoubleClick"), Bo("focusin", "onFocus"), Bo("focusout", "onBlur"), Bo(Nq, "onTransitionRun"), Bo(Mq, "onTransitionStart"), Bo(Rq, "onTransitionCancel"), Bo(QN, "onTransitionEnd"), fs("onMouseEnter", ["mouseout", "mouseover"]), fs("onMouseLeave", ["mouseout", "mouseover"]), fs("onPointerEnter", ["pointerout", "pointerover"]), fs("onPointerLeave", ["pointerout", "pointerover"]), ai(
      "onChange",
      "change click focusin focusout input keydown keyup selectionchange".split(" ")
    ), ai(
      "onSelect",
      "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(
        " "
      )
    ), ai("onBeforeInput", [
      "compositionend",
      "keypress",
      "textInput",
      "paste"
    ]), ai(
      "onCompositionEnd",
      "compositionend focusout keydown keypress keyup mousedown".split(" ")
    ), ai(
      "onCompositionStart",
      "compositionstart focusout keydown keypress keyup mousedown".split(" ")
    ), ai(
      "onCompositionUpdate",
      "compositionupdate focusout keydown keypress keyup mousedown".split(" ")
    );
    var $f = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(
      " "
    ), mK = new Set(
      "beforetoggle cancel close invalid load scroll scrollend toggle".split(" ").concat($f)
    );
    function bj(l, d) {
      d = (d & 4) !== 0;
      for (var m = 0; m < l.length; m++) {
        var x = l[m], N = x.event;
        x = x.listeners;
        e: {
          var R = void 0;
          if (d)
            for (var H = x.length - 1; 0 <= H; H--) {
              var J = x[H], re = J.instance, fe = J.currentTarget;
              if (J = J.listener, re !== R && N.isPropagationStopped())
                break e;
              R = J, N.currentTarget = fe;
              try {
                R(N);
              } catch (ve) {
                qh(ve);
              }
              N.currentTarget = null, R = re;
            }
          else
            for (H = 0; H < x.length; H++) {
              if (J = x[H], re = J.instance, fe = J.currentTarget, J = J.listener, re !== R && N.isPropagationStopped())
                break e;
              R = J, N.currentTarget = fe;
              try {
                R(N);
              } catch (ve) {
                qh(ve);
              }
              N.currentTarget = null, R = re;
            }
        }
      }
    }
    function xt(l, d) {
      var m = d[Du];
      m === void 0 && (m = d[Du] = /* @__PURE__ */ new Set());
      var x = l + "__bubble";
      m.has(x) || (wj(d, l, 2, !1), m.add(x));
    }
    function IS(l, d, m) {
      var x = 0;
      d && (x |= 4), wj(
        m,
        l,
        x,
        d
      );
    }
    var jg = "_reactListening" + Math.random().toString(36).slice(2);
    function AS(l) {
      if (!l[jg]) {
        l[jg] = !0, Ih.forEach(function(m) {
          m !== "selectionchange" && (mK.has(m) || IS(m, !1, l), IS(m, !0, l));
        });
        var d = l.nodeType === 9 ? l : l.ownerDocument;
        d === null || d[jg] || (d[jg] = !0, IS("selectionchange", !1, d));
      }
    }
    function wj(l, d, m, x) {
      switch (Xj(d)) {
        case 2:
          var N = VK;
          break;
        case 8:
          N = UK;
          break;
        default:
          N = XS;
      }
      m = N.bind(
        null,
        d,
        m,
        l
      ), N = void 0, !ek || d !== "touchstart" && d !== "touchmove" && d !== "wheel" || (N = !0), x ? N !== void 0 ? l.addEventListener(d, m, {
        capture: !0,
        passive: N
      }) : l.addEventListener(d, m, !0) : N !== void 0 ? l.addEventListener(d, m, {
        passive: N
      }) : l.addEventListener(d, m, !1);
    }
    function $S(l, d, m, x, N) {
      var R = x;
      if ((d & 1) === 0 && (d & 2) === 0 && x !== null)
        e: for (; ; ) {
          if (x === null) return;
          var H = x.tag;
          if (H === 3 || H === 4) {
            var J = x.stateNode.containerInfo;
            if (J === N) break;
            if (H === 4)
              for (H = x.return; H !== null; ) {
                var re = H.tag;
                if ((re === 3 || re === 4) && H.stateNode.containerInfo === N)
                  return;
                H = H.return;
              }
            for (; J !== null; ) {
              if (H = ls(J), H === null) return;
              if (re = H.tag, re === 5 || re === 6 || re === 26 || re === 27) {
                x = R = H;
                continue e;
              }
              J = J.parentNode;
            }
          }
          x = x.return;
        }
      EN(function() {
        var fe = R, ve = Qx(m), xe = [];
        e: {
          var pe = ZN.get(l);
          if (pe !== void 0) {
            var ge = Uh, Fe = l;
            switch (l) {
              case "keypress":
                if (Bh(m) === 0) break e;
              case "keydown":
              case "keyup":
                ge = sq;
                break;
              case "focusin":
                Fe = "focus", ge = ok;
                break;
              case "focusout":
                Fe = "blur", ge = ok;
                break;
              case "beforeblur":
              case "afterblur":
                ge = ok;
                break;
              case "click":
                if (m.button === 2) break e;
              case "auxclick":
              case "dblclick":
              case "mousedown":
              case "mousemove":
              case "mouseup":
              case "mouseout":
              case "mouseover":
              case "contextmenu":
                ge = ON;
                break;
              case "drag":
              case "dragend":
              case "dragenter":
              case "dragexit":
              case "dragleave":
              case "dragover":
              case "dragstart":
              case "drop":
                ge = XW;
                break;
              case "touchcancel":
              case "touchend":
              case "touchmove":
              case "touchstart":
                ge = cq;
                break;
              case XN:
              case YN:
              case JN:
                ge = QW;
                break;
              case QN:
                ge = fq;
                break;
              case "scroll":
              case "scrollend":
                ge = KW;
                break;
              case "wheel":
                ge = mq;
                break;
              case "copy":
              case "cut":
              case "paste":
                ge = eq;
                break;
              case "gotpointercapture":
              case "lostpointercapture":
              case "pointercancel":
              case "pointerdown":
              case "pointermove":
              case "pointerout":
              case "pointerover":
              case "pointerup":
                ge = MN;
                break;
              case "toggle":
              case "beforetoggle":
                ge = gq;
            }
            var Ze = (d & 4) !== 0, tn = !Ze && (l === "scroll" || l === "scrollend"), ue = Ze ? pe !== null ? pe + "Capture" : null : pe;
            Ze = [];
            for (var se = fe, de; se !== null; ) {
              var we = se;
              if (de = we.stateNode, we = we.tag, we !== 5 && we !== 26 && we !== 27 || de === null || ue === null || (we = nf(se, ue), we != null && Ze.push(
                Df(se, we, de)
              )), tn) break;
              se = se.return;
            }
            0 < Ze.length && (pe = new ge(
              pe,
              Fe,
              null,
              m,
              ve
            ), xe.push({ event: pe, listeners: Ze }));
          }
        }
        if ((d & 7) === 0) {
          e: {
            if (pe = l === "mouseover" || l === "pointerover", ge = l === "mouseout" || l === "pointerout", pe && m !== Jx && (Fe = m.relatedTarget || m.fromElement) && (ls(Fe) || Fe[oi]))
              break e;
            if ((ge || pe) && (pe = ve.window === ve ? ve : (pe = ve.ownerDocument) ? pe.defaultView || pe.parentWindow : window, ge ? (Fe = m.relatedTarget || m.toElement, ge = fe, Fe = Fe ? ls(Fe) : null, Fe !== null && (tn = a(Fe), Ze = Fe.tag, Fe !== tn || Ze !== 5 && Ze !== 27 && Ze !== 6) && (Fe = null)) : (ge = null, Fe = fe), ge !== Fe)) {
              if (Ze = ON, we = "onMouseLeave", ue = "onMouseEnter", se = "mouse", (l === "pointerout" || l === "pointerover") && (Ze = MN, we = "onPointerLeave", ue = "onPointerEnter", se = "pointer"), tn = ge == null ? pe : cs(ge), de = Fe == null ? pe : cs(Fe), pe = new Ze(
                we,
                se + "leave",
                ge,
                m,
                ve
              ), pe.target = tn, pe.relatedTarget = de, we = null, ls(ve) === fe && (Ze = new Ze(
                ue,
                se + "enter",
                Fe,
                m,
                ve
              ), Ze.target = de, Ze.relatedTarget = tn, we = Ze), tn = we, ge && Fe)
                t: {
                  for (Ze = hK, ue = ge, se = Fe, de = 0, we = ue; we; we = Ze(we))
                    de++;
                  we = 0;
                  for (var We = se; We; We = Ze(We))
                    we++;
                  for (; 0 < de - we; )
                    ue = Ze(ue), de--;
                  for (; 0 < we - de; )
                    se = Ze(se), we--;
                  for (; de--; ) {
                    if (ue === se || se !== null && ue === se.alternate) {
                      Ze = ue;
                      break t;
                    }
                    ue = Ze(ue), se = Ze(se);
                  }
                  Ze = null;
                }
              else Ze = null;
              ge !== null && xj(
                xe,
                pe,
                ge,
                Ze,
                !1
              ), Fe !== null && tn !== null && xj(
                xe,
                tn,
                Fe,
                Ze,
                !0
              );
            }
          }
          e: {
            if (pe = fe ? cs(fe) : window, ge = pe.nodeName && pe.nodeName.toLowerCase(), ge === "select" || ge === "input" && pe.type === "file")
              var $t = FN;
            else if (DN(pe))
              if (TN)
                $t = Cq;
              else {
                $t = _q;
                var Be = Sq;
              }
            else
              ge = pe.nodeName, !ge || ge.toLowerCase() !== "input" || pe.type !== "checkbox" && pe.type !== "radio" ? fe && Yx(fe.elementType) && ($t = FN) : $t = Eq;
            if ($t && ($t = $t(l, fe))) {
              LN(
                xe,
                $t,
                m,
                ve
              );
              break e;
            }
            Be && Be(l, pe, fe), l === "focusout" && fe && pe.type === "number" && fe.memoizedProps.value != null && tf(pe, "number", pe.value);
          }
          switch (Be = fe ? cs(fe) : window, l) {
            case "focusin":
              (DN(Be) || Be.contentEditable === "true") && (Hu = Be, ck = fe, df = null);
              break;
            case "focusout":
              df = ck = Hu = null;
              break;
            case "mousedown":
              dk = !0;
              break;
            case "contextmenu":
            case "mouseup":
            case "dragend":
              dk = !1, KN(xe, m, ve);
              break;
            case "selectionchange":
              if (Oq) break;
            case "keydown":
            case "keyup":
              KN(xe, m, ve);
          }
          var ut;
          if (ik)
            e: {
              switch (l) {
                case "compositionstart":
                  var _t = "onCompositionStart";
                  break e;
                case "compositionend":
                  _t = "onCompositionEnd";
                  break e;
                case "compositionupdate":
                  _t = "onCompositionUpdate";
                  break e;
              }
              _t = void 0;
            }
          else
            Uu ? AN(l, m) && (_t = "onCompositionEnd") : l === "keydown" && m.keyCode === 229 && (_t = "onCompositionStart");
          _t && (RN && m.locale !== "ko" && (Uu || _t !== "onCompositionStart" ? _t === "onCompositionEnd" && Uu && (ut = CN()) : (ps = ve, tk = "value" in ps ? ps.value : ps.textContent, Uu = !0)), Be = Ig(fe, _t), 0 < Be.length && (_t = new NN(
            _t,
            l,
            null,
            m,
            ve
          ), xe.push({ event: _t, listeners: Be }), ut ? _t.data = ut : (ut = $N(m), ut !== null && (_t.data = ut)))), (ut = yq ? bq(l, m) : wq(l, m)) && (_t = Ig(fe, "onBeforeInput"), 0 < _t.length && (Be = new NN(
            "onBeforeInput",
            "beforeinput",
            null,
            m,
            ve
          ), xe.push({
            event: Be,
            listeners: _t
          }), Be.data = ut)), dK(
            xe,
            l,
            fe,
            m,
            ve
          );
        }
        bj(xe, d);
      });
    }
    function Df(l, d, m) {
      return {
        instance: l,
        listener: d,
        currentTarget: m
      };
    }
    function Ig(l, d) {
      for (var m = d + "Capture", x = []; l !== null; ) {
        var N = l, R = N.stateNode;
        if (N = N.tag, N !== 5 && N !== 26 && N !== 27 || R === null || (N = nf(l, m), N != null && x.unshift(
          Df(l, N, R)
        ), N = nf(l, d), N != null && x.push(
          Df(l, N, R)
        )), l.tag === 3) return x;
        l = l.return;
      }
      return [];
    }
    function hK(l) {
      if (l === null) return null;
      do
        l = l.return;
      while (l && l.tag !== 5 && l.tag !== 27);
      return l || null;
    }
    function xj(l, d, m, x, N) {
      for (var R = d._reactName, H = []; m !== null && m !== x; ) {
        var J = m, re = J.alternate, fe = J.stateNode;
        if (J = J.tag, re !== null && re === x) break;
        J !== 5 && J !== 26 && J !== 27 || fe === null || (re = fe, N ? (fe = nf(m, R), fe != null && H.unshift(
          Df(m, fe, re)
        )) : N || (fe = nf(m, R), fe != null && H.push(
          Df(m, fe, re)
        ))), m = m.return;
      }
      H.length !== 0 && l.push({ event: d, listeners: H });
    }
    var gK = /\r\n?/g, vK = /\u0000|\uFFFD/g;
    function kj(l) {
      return (typeof l == "string" ? l : "" + l).replace(gK, `
`).replace(vK, "");
    }
    function Sj(l, d) {
      return d = kj(d), kj(l) === d;
    }
    function en(l, d, m, x, N, R) {
      switch (m) {
        case "children":
          typeof x == "string" ? d === "body" || d === "textarea" && x === "" || zu(l, x) : (typeof x == "number" || typeof x == "bigint") && d !== "body" && zu(l, "" + x);
          break;
        case "className":
          Fu(l, "class", x);
          break;
        case "tabIndex":
          Fu(l, "tabindex", x);
          break;
        case "dir":
        case "role":
        case "viewBox":
        case "width":
        case "height":
          Fu(l, m, x);
          break;
        case "style":
          SN(l, x, R);
          break;
        case "data":
          if (d !== "object") {
            Fu(l, "data", x);
            break;
          }
        case "src":
        case "href":
          if (x === "" && (d !== "a" || m !== "href")) {
            l.removeAttribute(m);
            break;
          }
          if (x == null || typeof x == "function" || typeof x == "symbol" || typeof x == "boolean") {
            l.removeAttribute(m);
            break;
          }
          x = Th("" + x), l.setAttribute(m, x);
          break;
        case "action":
        case "formAction":
          if (typeof x == "function") {
            l.setAttribute(
              m,
              "javascript:throw new Error('A React form was unexpectedly submitted. If you called form.submit() manually, consider using form.requestSubmit() instead. If you\\'re trying to use event.stopPropagation() in a submit event handler, consider also calling event.preventDefault().')"
            );
            break;
          } else
            typeof R == "function" && (m === "formAction" ? (d !== "input" && en(l, d, "name", N.name, N, null), en(
              l,
              d,
              "formEncType",
              N.formEncType,
              N,
              null
            ), en(
              l,
              d,
              "formMethod",
              N.formMethod,
              N,
              null
            ), en(
              l,
              d,
              "formTarget",
              N.formTarget,
              N,
              null
            )) : (en(l, d, "encType", N.encType, N, null), en(l, d, "method", N.method, N, null), en(l, d, "target", N.target, N, null)));
          if (x == null || typeof x == "symbol" || typeof x == "boolean") {
            l.removeAttribute(m);
            break;
          }
          x = Th("" + x), l.setAttribute(m, x);
          break;
        case "onClick":
          x != null && (l.onclick = si);
          break;
        case "onScroll":
          x != null && xt("scroll", l);
          break;
        case "onScrollEnd":
          x != null && xt("scrollend", l);
          break;
        case "dangerouslySetInnerHTML":
          if (x != null) {
            if (typeof x != "object" || !("__html" in x))
              throw Error(r(61));
            if (m = x.__html, m != null) {
              if (N.children != null) throw Error(r(60));
              l.innerHTML = m;
            }
          }
          break;
        case "multiple":
          l.multiple = x && typeof x != "function" && typeof x != "symbol";
          break;
        case "muted":
          l.muted = x && typeof x != "function" && typeof x != "symbol";
          break;
        case "suppressContentEditableWarning":
        case "suppressHydrationWarning":
        case "defaultValue":
        case "defaultChecked":
        case "innerHTML":
        case "ref":
          break;
        case "autoFocus":
          break;
        case "xlinkHref":
          if (x == null || typeof x == "function" || typeof x == "boolean" || typeof x == "symbol") {
            l.removeAttribute("xlink:href");
            break;
          }
          m = Th("" + x), l.setAttributeNS(
            "http://www.w3.org/1999/xlink",
            "xlink:href",
            m
          );
          break;
        case "contentEditable":
        case "spellCheck":
        case "draggable":
        case "value":
        case "autoReverse":
        case "externalResourcesRequired":
        case "focusable":
        case "preserveAlpha":
          x != null && typeof x != "function" && typeof x != "symbol" ? l.setAttribute(m, "" + x) : l.removeAttribute(m);
          break;
        case "inert":
        case "allowFullScreen":
        case "async":
        case "autoPlay":
        case "controls":
        case "default":
        case "defer":
        case "disabled":
        case "disablePictureInPicture":
        case "disableRemotePlayback":
        case "formNoValidate":
        case "hidden":
        case "loop":
        case "noModule":
        case "noValidate":
        case "open":
        case "playsInline":
        case "readOnly":
        case "required":
        case "reversed":
        case "scoped":
        case "seamless":
        case "itemScope":
          x && typeof x != "function" && typeof x != "symbol" ? l.setAttribute(m, "") : l.removeAttribute(m);
          break;
        case "capture":
        case "download":
          x === !0 ? l.setAttribute(m, "") : x !== !1 && x != null && typeof x != "function" && typeof x != "symbol" ? l.setAttribute(m, x) : l.removeAttribute(m);
          break;
        case "cols":
        case "rows":
        case "size":
        case "span":
          x != null && typeof x != "function" && typeof x != "symbol" && !isNaN(x) && 1 <= x ? l.setAttribute(m, x) : l.removeAttribute(m);
          break;
        case "rowSpan":
        case "start":
          x == null || typeof x == "function" || typeof x == "symbol" || isNaN(x) ? l.removeAttribute(m) : l.setAttribute(m, x);
          break;
        case "popover":
          xt("beforetoggle", l), xt("toggle", l), Lu(l, "popover", x);
          break;
        case "xlinkActuate":
          zo(
            l,
            "http://www.w3.org/1999/xlink",
            "xlink:actuate",
            x
          );
          break;
        case "xlinkArcrole":
          zo(
            l,
            "http://www.w3.org/1999/xlink",
            "xlink:arcrole",
            x
          );
          break;
        case "xlinkRole":
          zo(
            l,
            "http://www.w3.org/1999/xlink",
            "xlink:role",
            x
          );
          break;
        case "xlinkShow":
          zo(
            l,
            "http://www.w3.org/1999/xlink",
            "xlink:show",
            x
          );
          break;
        case "xlinkTitle":
          zo(
            l,
            "http://www.w3.org/1999/xlink",
            "xlink:title",
            x
          );
          break;
        case "xlinkType":
          zo(
            l,
            "http://www.w3.org/1999/xlink",
            "xlink:type",
            x
          );
          break;
        case "xmlBase":
          zo(
            l,
            "http://www.w3.org/XML/1998/namespace",
            "xml:base",
            x
          );
          break;
        case "xmlLang":
          zo(
            l,
            "http://www.w3.org/XML/1998/namespace",
            "xml:lang",
            x
          );
          break;
        case "xmlSpace":
          zo(
            l,
            "http://www.w3.org/XML/1998/namespace",
            "xml:space",
            x
          );
          break;
        case "is":
          Lu(l, "is", x);
          break;
        case "innerText":
        case "textContent":
          break;
        default:
          (!(2 < m.length) || m[0] !== "o" && m[0] !== "O" || m[1] !== "n" && m[1] !== "N") && (m = WW.get(m) || m, Lu(l, m, x));
      }
    }
    function DS(l, d, m, x, N, R) {
      switch (m) {
        case "style":
          SN(l, x, R);
          break;
        case "dangerouslySetInnerHTML":
          if (x != null) {
            if (typeof x != "object" || !("__html" in x))
              throw Error(r(61));
            if (m = x.__html, m != null) {
              if (N.children != null) throw Error(r(60));
              l.innerHTML = m;
            }
          }
          break;
        case "children":
          typeof x == "string" ? zu(l, x) : (typeof x == "number" || typeof x == "bigint") && zu(l, "" + x);
          break;
        case "onScroll":
          x != null && xt("scroll", l);
          break;
        case "onScrollEnd":
          x != null && xt("scrollend", l);
          break;
        case "onClick":
          x != null && (l.onclick = si);
          break;
        case "suppressContentEditableWarning":
        case "suppressHydrationWarning":
        case "innerHTML":
        case "ref":
          break;
        case "innerText":
        case "textContent":
          break;
        default:
          if (!Ah.hasOwnProperty(m))
            e: {
              if (m[0] === "o" && m[1] === "n" && (N = m.endsWith("Capture"), d = m.slice(2, N ? m.length - 7 : void 0), R = l[pr] || null, R = R != null ? R[m] : null, typeof R == "function" && l.removeEventListener(d, R, N), typeof x == "function")) {
                typeof R != "function" && R !== null && (m in l ? l[m] = null : l.hasAttribute(m) && l.removeAttribute(m)), l.addEventListener(d, x, N);
                break e;
              }
              m in l ? l[m] = x : x === !0 ? l.setAttribute(m, "") : Lu(l, m, x);
            }
      }
    }
    function ar(l, d, m) {
      switch (d) {
        case "div":
        case "span":
        case "svg":
        case "path":
        case "a":
        case "g":
        case "p":
        case "li":
          break;
        case "img":
          xt("error", l), xt("load", l);
          var x = !1, N = !1, R;
          for (R in m)
            if (m.hasOwnProperty(R)) {
              var H = m[R];
              if (H != null)
                switch (R) {
                  case "src":
                    x = !0;
                    break;
                  case "srcSet":
                    N = !0;
                    break;
                  case "children":
                  case "dangerouslySetInnerHTML":
                    throw Error(r(137, d));
                  default:
                    en(l, d, R, H, m, null);
                }
            }
          N && en(l, d, "srcSet", m.srcSet, m, null), x && en(l, d, "src", m.src, m, null);
          return;
        case "input":
          xt("invalid", l);
          var J = R = H = N = null, re = null, fe = null;
          for (x in m)
            if (m.hasOwnProperty(x)) {
              var ve = m[x];
              if (ve != null)
                switch (x) {
                  case "name":
                    N = ve;
                    break;
                  case "type":
                    H = ve;
                    break;
                  case "checked":
                    re = ve;
                    break;
                  case "defaultChecked":
                    fe = ve;
                    break;
                  case "value":
                    R = ve;
                    break;
                  case "defaultValue":
                    J = ve;
                    break;
                  case "children":
                  case "dangerouslySetInnerHTML":
                    if (ve != null)
                      throw Error(r(137, d));
                    break;
                  default:
                    en(l, d, x, ve, m, null);
                }
            }
          Fh(
            l,
            R,
            J,
            re,
            fe,
            H,
            N,
            !1
          );
          return;
        case "select":
          xt("invalid", l), x = H = R = null;
          for (N in m)
            if (m.hasOwnProperty(N) && (J = m[N], J != null))
              switch (N) {
                case "value":
                  R = J;
                  break;
                case "defaultValue":
                  H = J;
                  break;
                case "multiple":
                  x = J;
                default:
                  en(l, d, N, J, m, null);
              }
          d = R, m = H, l.multiple = !!x, d != null ? ii(l, !!x, d, !1) : m != null && ii(l, !!x, m, !0);
          return;
        case "textarea":
          xt("invalid", l), R = N = x = null;
          for (H in m)
            if (m.hasOwnProperty(H) && (J = m[H], J != null))
              switch (H) {
                case "value":
                  x = J;
                  break;
                case "defaultValue":
                  N = J;
                  break;
                case "children":
                  R = J;
                  break;
                case "dangerouslySetInnerHTML":
                  if (J != null) throw Error(r(91));
                  break;
                default:
                  en(l, d, H, J, m, null);
              }
          xN(l, x, N, R);
          return;
        case "option":
          for (re in m)
            m.hasOwnProperty(re) && (x = m[re], x != null) && (re === "selected" ? l.selected = x && typeof x != "function" && typeof x != "symbol" : en(l, d, re, x, m, null));
          return;
        case "dialog":
          xt("beforetoggle", l), xt("toggle", l), xt("cancel", l), xt("close", l);
          break;
        case "iframe":
        case "object":
          xt("load", l);
          break;
        case "video":
        case "audio":
          for (x = 0; x < $f.length; x++)
            xt($f[x], l);
          break;
        case "image":
          xt("error", l), xt("load", l);
          break;
        case "details":
          xt("toggle", l);
          break;
        case "embed":
        case "source":
        case "link":
          xt("error", l), xt("load", l);
        case "area":
        case "base":
        case "br":
        case "col":
        case "hr":
        case "keygen":
        case "meta":
        case "param":
        case "track":
        case "wbr":
        case "menuitem":
          for (fe in m)
            if (m.hasOwnProperty(fe) && (x = m[fe], x != null))
              switch (fe) {
                case "children":
                case "dangerouslySetInnerHTML":
                  throw Error(r(137, d));
                default:
                  en(l, d, fe, x, m, null);
              }
          return;
        default:
          if (Yx(d)) {
            for (ve in m)
              m.hasOwnProperty(ve) && (x = m[ve], x !== void 0 && DS(
                l,
                d,
                ve,
                x,
                m,
                void 0
              ));
            return;
          }
      }
      for (J in m)
        m.hasOwnProperty(J) && (x = m[J], x != null && en(l, d, J, x, m, null));
    }
    function yK(l, d, m, x) {
      switch (d) {
        case "div":
        case "span":
        case "svg":
        case "path":
        case "a":
        case "g":
        case "p":
        case "li":
          break;
        case "input":
          var N = null, R = null, H = null, J = null, re = null, fe = null, ve = null;
          for (ge in m) {
            var xe = m[ge];
            if (m.hasOwnProperty(ge) && xe != null)
              switch (ge) {
                case "checked":
                  break;
                case "value":
                  break;
                case "defaultValue":
                  re = xe;
                default:
                  x.hasOwnProperty(ge) || en(l, d, ge, null, x, xe);
              }
          }
          for (var pe in x) {
            var ge = x[pe];
            if (xe = m[pe], x.hasOwnProperty(pe) && (ge != null || xe != null))
              switch (pe) {
                case "type":
                  R = ge;
                  break;
                case "name":
                  N = ge;
                  break;
                case "checked":
                  fe = ge;
                  break;
                case "defaultChecked":
                  ve = ge;
                  break;
                case "value":
                  H = ge;
                  break;
                case "defaultValue":
                  J = ge;
                  break;
                case "children":
                case "dangerouslySetInnerHTML":
                  if (ge != null)
                    throw Error(r(137, d));
                  break;
                default:
                  ge !== xe && en(
                    l,
                    d,
                    pe,
                    ge,
                    x,
                    xe
                  );
              }
          }
          kl(
            l,
            H,
            J,
            re,
            fe,
            ve,
            R,
            N
          );
          return;
        case "select":
          ge = H = J = pe = null;
          for (R in m)
            if (re = m[R], m.hasOwnProperty(R) && re != null)
              switch (R) {
                case "value":
                  break;
                case "multiple":
                  ge = re;
                default:
                  x.hasOwnProperty(R) || en(
                    l,
                    d,
                    R,
                    null,
                    x,
                    re
                  );
              }
          for (N in x)
            if (R = x[N], re = m[N], x.hasOwnProperty(N) && (R != null || re != null))
              switch (N) {
                case "value":
                  pe = R;
                  break;
                case "defaultValue":
                  J = R;
                  break;
                case "multiple":
                  H = R;
                default:
                  R !== re && en(
                    l,
                    d,
                    N,
                    R,
                    x,
                    re
                  );
              }
          d = J, m = H, x = ge, pe != null ? ii(l, !!m, pe, !1) : !!x != !!m && (d != null ? ii(l, !!m, d, !0) : ii(l, !!m, m ? [] : "", !1));
          return;
        case "textarea":
          ge = pe = null;
          for (J in m)
            if (N = m[J], m.hasOwnProperty(J) && N != null && !x.hasOwnProperty(J))
              switch (J) {
                case "value":
                  break;
                case "children":
                  break;
                default:
                  en(l, d, J, null, x, N);
              }
          for (H in x)
            if (N = x[H], R = m[H], x.hasOwnProperty(H) && (N != null || R != null))
              switch (H) {
                case "value":
                  pe = N;
                  break;
                case "defaultValue":
                  ge = N;
                  break;
                case "children":
                  break;
                case "dangerouslySetInnerHTML":
                  if (N != null) throw Error(r(91));
                  break;
                default:
                  N !== R && en(l, d, H, N, x, R);
              }
          wN(l, pe, ge);
          return;
        case "option":
          for (var Fe in m)
            pe = m[Fe], m.hasOwnProperty(Fe) && pe != null && !x.hasOwnProperty(Fe) && (Fe === "selected" ? l.selected = !1 : en(
              l,
              d,
              Fe,
              null,
              x,
              pe
            ));
          for (re in x)
            pe = x[re], ge = m[re], x.hasOwnProperty(re) && pe !== ge && (pe != null || ge != null) && (re === "selected" ? l.selected = pe && typeof pe != "function" && typeof pe != "symbol" : en(
              l,
              d,
              re,
              pe,
              x,
              ge
            ));
          return;
        case "img":
        case "link":
        case "area":
        case "base":
        case "br":
        case "col":
        case "embed":
        case "hr":
        case "keygen":
        case "meta":
        case "param":
        case "source":
        case "track":
        case "wbr":
        case "menuitem":
          for (var Ze in m)
            pe = m[Ze], m.hasOwnProperty(Ze) && pe != null && !x.hasOwnProperty(Ze) && en(l, d, Ze, null, x, pe);
          for (fe in x)
            if (pe = x[fe], ge = m[fe], x.hasOwnProperty(fe) && pe !== ge && (pe != null || ge != null))
              switch (fe) {
                case "children":
                case "dangerouslySetInnerHTML":
                  if (pe != null)
                    throw Error(r(137, d));
                  break;
                default:
                  en(
                    l,
                    d,
                    fe,
                    pe,
                    x,
                    ge
                  );
              }
          return;
        default:
          if (Yx(d)) {
            for (var tn in m)
              pe = m[tn], m.hasOwnProperty(tn) && pe !== void 0 && !x.hasOwnProperty(tn) && DS(
                l,
                d,
                tn,
                void 0,
                x,
                pe
              );
            for (ve in x)
              pe = x[ve], ge = m[ve], !x.hasOwnProperty(ve) || pe === ge || pe === void 0 && ge === void 0 || DS(
                l,
                d,
                ve,
                pe,
                x,
                ge
              );
            return;
          }
      }
      for (var ue in m)
        pe = m[ue], m.hasOwnProperty(ue) && pe != null && !x.hasOwnProperty(ue) && en(l, d, ue, null, x, pe);
      for (xe in x)
        pe = x[xe], ge = m[xe], !x.hasOwnProperty(xe) || pe === ge || pe == null && ge == null || en(l, d, xe, pe, x, ge);
    }
    function _j(l) {
      switch (l) {
        case "css":
        case "script":
        case "font":
        case "img":
        case "image":
        case "input":
        case "link":
          return !0;
        default:
          return !1;
      }
    }
    function bK() {
      if (typeof performance.getEntriesByType == "function") {
        for (var l = 0, d = 0, m = performance.getEntriesByType("resource"), x = 0; x < m.length; x++) {
          var N = m[x], R = N.transferSize, H = N.initiatorType, J = N.duration;
          if (R && J && _j(H)) {
            for (H = 0, J = N.responseEnd, x += 1; x < m.length; x++) {
              var re = m[x], fe = re.startTime;
              if (fe > J) break;
              var ve = re.transferSize, xe = re.initiatorType;
              ve && _j(xe) && (re = re.responseEnd, H += ve * (re < J ? 1 : (J - fe) / (re - fe)));
            }
            if (--x, d += 8 * (R + H) / (N.duration / 1e3), l++, 10 < l) break;
          }
        }
        if (0 < l) return d / l / 1e6;
      }
      return navigator.connection && (l = navigator.connection.downlink, typeof l == "number") ? l : 5;
    }
    var LS = null, FS = null;
    function Ag(l) {
      return l.nodeType === 9 ? l : l.ownerDocument;
    }
    function Ej(l) {
      switch (l) {
        case "http://www.w3.org/2000/svg":
          return 1;
        case "http://www.w3.org/1998/Math/MathML":
          return 2;
        default:
          return 0;
      }
    }
    function Cj(l, d) {
      if (l === 0)
        switch (d) {
          case "svg":
            return 1;
          case "math":
            return 2;
          default:
            return 0;
        }
      return l === 1 && d === "foreignObject" ? 0 : l;
    }
    function TS(l, d) {
      return l === "textarea" || l === "noscript" || typeof d.children == "string" || typeof d.children == "number" || typeof d.children == "bigint" || typeof d.dangerouslySetInnerHTML == "object" && d.dangerouslySetInnerHTML !== null && d.dangerouslySetInnerHTML.__html != null;
    }
    var zS = null;
    function wK() {
      var l = window.event;
      return l && l.type === "popstate" ? l === zS ? !1 : (zS = l, !0) : (zS = null, !1);
    }
    var Pj = typeof setTimeout == "function" ? setTimeout : void 0, xK = typeof clearTimeout == "function" ? clearTimeout : void 0, Oj = typeof Promise == "function" ? Promise : void 0, kK = typeof queueMicrotask == "function" ? queueMicrotask : typeof Oj < "u" ? function(l) {
      return Oj.resolve(null).then(l).catch(SK);
    } : Pj;
    function SK(l) {
      setTimeout(function() {
        throw l;
      });
    }
    function Ms(l) {
      return l === "head";
    }
    function Nj(l, d) {
      var m = d, x = 0;
      do {
        var N = m.nextSibling;
        if (l.removeChild(m), N && N.nodeType === 8)
          if (m = N.data, m === "/$" || m === "/&") {
            if (x === 0) {
              l.removeChild(N), vc(d);
              return;
            }
            x--;
          } else if (m === "$" || m === "$?" || m === "$~" || m === "$!" || m === "&")
            x++;
          else if (m === "html")
            Lf(l.ownerDocument.documentElement);
          else if (m === "head") {
            m = l.ownerDocument.head, Lf(m);
            for (var R = m.firstChild; R; ) {
              var H = R.nextSibling, J = R.nodeName;
              R[wl] || J === "SCRIPT" || J === "STYLE" || J === "LINK" && R.rel.toLowerCase() === "stylesheet" || m.removeChild(R), R = H;
            }
          } else
            m === "body" && Lf(l.ownerDocument.body);
        m = N;
      } while (m);
      vc(d);
    }
    function Mj(l, d) {
      var m = l;
      l = 0;
      do {
        var x = m.nextSibling;
        if (m.nodeType === 1 ? d ? (m._stashedDisplay = m.style.display, m.style.display = "none") : (m.style.display = m._stashedDisplay || "", m.getAttribute("style") === "" && m.removeAttribute("style")) : m.nodeType === 3 && (d ? (m._stashedText = m.nodeValue, m.nodeValue = "") : m.nodeValue = m._stashedText || ""), x && x.nodeType === 8)
          if (m = x.data, m === "/$") {
            if (l === 0) break;
            l--;
          } else
            m !== "$" && m !== "$?" && m !== "$~" && m !== "$!" || l++;
        m = x;
      } while (m);
    }
    function BS(l) {
      var d = l.firstChild;
      for (d && d.nodeType === 10 && (d = d.nextSibling); d; ) {
        var m = d;
        switch (d = d.nextSibling, m.nodeName) {
          case "HTML":
          case "HEAD":
          case "BODY":
            BS(m), Zd(m);
            continue;
          case "SCRIPT":
          case "STYLE":
            continue;
          case "LINK":
            if (m.rel.toLowerCase() === "stylesheet") continue;
        }
        l.removeChild(m);
      }
    }
    function _K(l, d, m, x) {
      for (; l.nodeType === 1; ) {
        var N = m;
        if (l.nodeName.toLowerCase() !== d.toLowerCase()) {
          if (!x && (l.nodeName !== "INPUT" || l.type !== "hidden"))
            break;
        } else if (x) {
          if (!l[wl])
            switch (d) {
              case "meta":
                if (!l.hasAttribute("itemprop")) break;
                return l;
              case "link":
                if (R = l.getAttribute("rel"), R === "stylesheet" && l.hasAttribute("data-precedence") || R !== N.rel || l.getAttribute("href") !== (N.href == null || N.href === "" ? null : N.href) || l.getAttribute("crossorigin") !== (N.crossOrigin == null ? null : N.crossOrigin) || l.getAttribute("title") !== (N.title == null ? null : N.title))
                  break;
                return l;
              case "style":
                if (l.hasAttribute("data-precedence")) break;
                return l;
              case "script":
                if (R = l.getAttribute("src"), (R !== (N.src == null ? null : N.src) || l.getAttribute("type") !== (N.type == null ? null : N.type) || l.getAttribute("crossorigin") !== (N.crossOrigin == null ? null : N.crossOrigin)) && R && l.hasAttribute("async") && !l.hasAttribute("itemprop"))
                  break;
                return l;
              default:
                return l;
            }
        } else if (d === "input" && l.type === "hidden") {
          var R = N.name == null ? null : "" + N.name;
          if (N.type === "hidden" && l.getAttribute("name") === R)
            return l;
        } else return l;
        if (l = So(l.nextSibling), l === null) break;
      }
      return null;
    }
    function EK(l, d, m) {
      if (d === "") return null;
      for (; l.nodeType !== 3; )
        if ((l.nodeType !== 1 || l.nodeName !== "INPUT" || l.type !== "hidden") && !m || (l = So(l.nextSibling), l === null)) return null;
      return l;
    }
    function Rj(l, d) {
      for (; l.nodeType !== 8; )
        if ((l.nodeType !== 1 || l.nodeName !== "INPUT" || l.type !== "hidden") && !d || (l = So(l.nextSibling), l === null)) return null;
      return l;
    }
    function VS(l) {
      return l.data === "$?" || l.data === "$~";
    }
    function US(l) {
      return l.data === "$!" || l.data === "$?" && l.ownerDocument.readyState !== "loading";
    }
    function CK(l, d) {
      var m = l.ownerDocument;
      if (l.data === "$~") l._reactRetry = d;
      else if (l.data !== "$?" || m.readyState !== "loading")
        d();
      else {
        var x = function() {
          d(), m.removeEventListener("DOMContentLoaded", x);
        };
        m.addEventListener("DOMContentLoaded", x), l._reactRetry = x;
      }
    }
    function So(l) {
      for (; l != null; l = l.nextSibling) {
        var d = l.nodeType;
        if (d === 1 || d === 3) break;
        if (d === 8) {
          if (d = l.data, d === "$" || d === "$!" || d === "$?" || d === "$~" || d === "&" || d === "F!" || d === "F")
            break;
          if (d === "/$" || d === "/&") return null;
        }
      }
      return l;
    }
    var HS = null;
    function jj(l) {
      l = l.nextSibling;
      for (var d = 0; l; ) {
        if (l.nodeType === 8) {
          var m = l.data;
          if (m === "/$" || m === "/&") {
            if (d === 0)
              return So(l.nextSibling);
            d--;
          } else
            m !== "$" && m !== "$!" && m !== "$?" && m !== "$~" && m !== "&" || d++;
        }
        l = l.nextSibling;
      }
      return null;
    }
    function Ij(l) {
      l = l.previousSibling;
      for (var d = 0; l; ) {
        if (l.nodeType === 8) {
          var m = l.data;
          if (m === "$" || m === "$!" || m === "$?" || m === "$~" || m === "&") {
            if (d === 0) return l;
            d--;
          } else m !== "/$" && m !== "/&" || d++;
        }
        l = l.previousSibling;
      }
      return null;
    }
    function Aj(l, d, m) {
      switch (d = Ag(m), l) {
        case "html":
          if (l = d.documentElement, !l) throw Error(r(452));
          return l;
        case "head":
          if (l = d.head, !l) throw Error(r(453));
          return l;
        case "body":
          if (l = d.body, !l) throw Error(r(454));
          return l;
        default:
          throw Error(r(451));
      }
    }
    function Lf(l) {
      for (var d = l.attributes; d.length; )
        l.removeAttributeNode(d[0]);
      Zd(l);
    }
    var _o = /* @__PURE__ */ new Map(), $j = /* @__PURE__ */ new Set();
    function $g(l) {
      return typeof l.getRootNode == "function" ? l.getRootNode() : l.nodeType === 9 ? l : l.ownerDocument;
    }
    var Si = G.d;
    G.d = {
      f: PK,
      r: OK,
      D: NK,
      C: MK,
      L: RK,
      m: jK,
      X: AK,
      S: IK,
      M: $K
    };
    function PK() {
      var l = Si.f(), d = Cg();
      return l || d;
    }
    function OK(l) {
      var d = us(l);
      d !== null && d.tag === 5 && d.type === "form" ? QM(d) : Si.r(l);
    }
    var mc = typeof document > "u" ? null : document;
    function Dj(l, d, m) {
      var x = mc;
      if (x && typeof d == "string" && d) {
        var N = Gr(d);
        N = 'link[rel="' + l + '"][href="' + N + '"]', typeof m == "string" && (N += '[crossorigin="' + m + '"]'), $j.has(N) || ($j.add(N), l = { rel: l, crossOrigin: m, href: d }, x.querySelector(N) === null && (d = x.createElement("link"), ar(d, "link", l), $n(d), x.head.appendChild(d)));
      }
    }
    function NK(l) {
      Si.D(l), Dj("dns-prefetch", l, null);
    }
    function MK(l, d) {
      Si.C(l, d), Dj("preconnect", l, d);
    }
    function RK(l, d, m) {
      Si.L(l, d, m);
      var x = mc;
      if (x && l && d) {
        var N = 'link[rel="preload"][as="' + Gr(d) + '"]';
        d === "image" && m && m.imageSrcSet ? (N += '[imagesrcset="' + Gr(
          m.imageSrcSet
        ) + '"]', typeof m.imageSizes == "string" && (N += '[imagesizes="' + Gr(
          m.imageSizes
        ) + '"]')) : N += '[href="' + Gr(l) + '"]';
        var R = N;
        switch (d) {
          case "style":
            R = hc(l);
            break;
          case "script":
            R = gc(l);
        }
        _o.has(R) || (l = p(
          {
            rel: "preload",
            href: d === "image" && m && m.imageSrcSet ? void 0 : l,
            as: d
          },
          m
        ), _o.set(R, l), x.querySelector(N) !== null || d === "style" && x.querySelector(Ff(R)) || d === "script" && x.querySelector(Tf(R)) || (d = x.createElement("link"), ar(d, "link", l), $n(d), x.head.appendChild(d)));
      }
    }
    function jK(l, d) {
      Si.m(l, d);
      var m = mc;
      if (m && l) {
        var x = d && typeof d.as == "string" ? d.as : "script", N = 'link[rel="modulepreload"][as="' + Gr(x) + '"][href="' + Gr(l) + '"]', R = N;
        switch (x) {
          case "audioworklet":
          case "paintworklet":
          case "serviceworker":
          case "sharedworker":
          case "worker":
          case "script":
            R = gc(l);
        }
        if (!_o.has(R) && (l = p({ rel: "modulepreload", href: l }, d), _o.set(R, l), m.querySelector(N) === null)) {
          switch (x) {
            case "audioworklet":
            case "paintworklet":
            case "serviceworker":
            case "sharedworker":
            case "worker":
            case "script":
              if (m.querySelector(Tf(R)))
                return;
          }
          x = m.createElement("link"), ar(x, "link", l), $n(x), m.head.appendChild(x);
        }
      }
    }
    function IK(l, d, m) {
      Si.S(l, d, m);
      var x = mc;
      if (x && l) {
        var N = ds(x).hoistableStyles, R = hc(l);
        d = d || "default";
        var H = N.get(R);
        if (!H) {
          var J = { loading: 0, preload: null };
          if (H = x.querySelector(
            Ff(R)
          ))
            J.loading = 5;
          else {
            l = p(
              { rel: "stylesheet", href: l, "data-precedence": d },
              m
            ), (m = _o.get(R)) && WS(l, m);
            var re = H = x.createElement("link");
            $n(re), ar(re, "link", l), re._p = new Promise(function(fe, ve) {
              re.onload = fe, re.onerror = ve;
            }), re.addEventListener("load", function() {
              J.loading |= 1;
            }), re.addEventListener("error", function() {
              J.loading |= 2;
            }), J.loading |= 4, Dg(H, d, x);
          }
          H = {
            type: "stylesheet",
            instance: H,
            count: 1,
            state: J
          }, N.set(R, H);
        }
      }
    }
    function AK(l, d) {
      Si.X(l, d);
      var m = mc;
      if (m && l) {
        var x = ds(m).hoistableScripts, N = gc(l), R = x.get(N);
        R || (R = m.querySelector(Tf(N)), R || (l = p({ src: l, async: !0 }, d), (d = _o.get(N)) && qS(l, d), R = m.createElement("script"), $n(R), ar(R, "link", l), m.head.appendChild(R)), R = {
          type: "script",
          instance: R,
          count: 1,
          state: null
        }, x.set(N, R));
      }
    }
    function $K(l, d) {
      Si.M(l, d);
      var m = mc;
      if (m && l) {
        var x = ds(m).hoistableScripts, N = gc(l), R = x.get(N);
        R || (R = m.querySelector(Tf(N)), R || (l = p({ src: l, async: !0, type: "module" }, d), (d = _o.get(N)) && qS(l, d), R = m.createElement("script"), $n(R), ar(R, "link", l), m.head.appendChild(R)), R = {
          type: "script",
          instance: R,
          count: 1,
          state: null
        }, x.set(N, R));
      }
    }
    function Lj(l, d, m, x) {
      var N = (N = Q.current) ? $g(N) : null;
      if (!N) throw Error(r(446));
      switch (l) {
        case "meta":
        case "title":
          return null;
        case "style":
          return typeof m.precedence == "string" && typeof m.href == "string" ? (d = hc(m.href), m = ds(
            N
          ).hoistableStyles, x = m.get(d), x || (x = {
            type: "style",
            instance: null,
            count: 0,
            state: null
          }, m.set(d, x)), x) : { type: "void", instance: null, count: 0, state: null };
        case "link":
          if (m.rel === "stylesheet" && typeof m.href == "string" && typeof m.precedence == "string") {
            l = hc(m.href);
            var R = ds(
              N
            ).hoistableStyles, H = R.get(l);
            if (H || (N = N.ownerDocument || N, H = {
              type: "stylesheet",
              instance: null,
              count: 0,
              state: { loading: 0, preload: null }
            }, R.set(l, H), (R = N.querySelector(
              Ff(l)
            )) && !R._p && (H.instance = R, H.state.loading = 5), _o.has(l) || (m = {
              rel: "preload",
              as: "style",
              href: m.href,
              crossOrigin: m.crossOrigin,
              integrity: m.integrity,
              media: m.media,
              hrefLang: m.hrefLang,
              referrerPolicy: m.referrerPolicy
            }, _o.set(l, m), R || DK(
              N,
              l,
              m,
              H.state
            ))), d && x === null)
              throw Error(r(528, ""));
            return H;
          }
          if (d && x !== null)
            throw Error(r(529, ""));
          return null;
        case "script":
          return d = m.async, m = m.src, typeof m == "string" && d && typeof d != "function" && typeof d != "symbol" ? (d = gc(m), m = ds(
            N
          ).hoistableScripts, x = m.get(d), x || (x = {
            type: "script",
            instance: null,
            count: 0,
            state: null
          }, m.set(d, x)), x) : { type: "void", instance: null, count: 0, state: null };
        default:
          throw Error(r(444, l));
      }
    }
    function hc(l) {
      return 'href="' + Gr(l) + '"';
    }
    function Ff(l) {
      return 'link[rel="stylesheet"][' + l + "]";
    }
    function Fj(l) {
      return p({}, l, {
        "data-precedence": l.precedence,
        precedence: null
      });
    }
    function DK(l, d, m, x) {
      l.querySelector('link[rel="preload"][as="style"][' + d + "]") ? x.loading = 1 : (d = l.createElement("link"), x.preload = d, d.addEventListener("load", function() {
        return x.loading |= 1;
      }), d.addEventListener("error", function() {
        return x.loading |= 2;
      }), ar(d, "link", m), $n(d), l.head.appendChild(d));
    }
    function gc(l) {
      return '[src="' + Gr(l) + '"]';
    }
    function Tf(l) {
      return "script[async]" + l;
    }
    function Tj(l, d, m) {
      if (d.count++, d.instance === null)
        switch (d.type) {
          case "style":
            var x = l.querySelector(
              'style[data-href~="' + Gr(m.href) + '"]'
            );
            if (x)
              return d.instance = x, $n(x), x;
            var N = p({}, m, {
              "data-href": m.href,
              "data-precedence": m.precedence,
              href: null,
              precedence: null
            });
            return x = (l.ownerDocument || l).createElement(
              "style"
            ), $n(x), ar(x, "style", N), Dg(x, m.precedence, l), d.instance = x;
          case "stylesheet":
            N = hc(m.href);
            var R = l.querySelector(
              Ff(N)
            );
            if (R)
              return d.state.loading |= 4, d.instance = R, $n(R), R;
            x = Fj(m), (N = _o.get(N)) && WS(x, N), R = (l.ownerDocument || l).createElement("link"), $n(R);
            var H = R;
            return H._p = new Promise(function(J, re) {
              H.onload = J, H.onerror = re;
            }), ar(R, "link", x), d.state.loading |= 4, Dg(R, m.precedence, l), d.instance = R;
          case "script":
            return R = gc(m.src), (N = l.querySelector(
              Tf(R)
            )) ? (d.instance = N, $n(N), N) : (x = m, (N = _o.get(R)) && (x = p({}, m), qS(x, N)), l = l.ownerDocument || l, N = l.createElement("script"), $n(N), ar(N, "link", x), l.head.appendChild(N), d.instance = N);
          case "void":
            return null;
          default:
            throw Error(r(443, d.type));
        }
      else
        d.type === "stylesheet" && (d.state.loading & 4) === 0 && (x = d.instance, d.state.loading |= 4, Dg(x, m.precedence, l));
      return d.instance;
    }
    function Dg(l, d, m) {
      for (var x = m.querySelectorAll(
        'link[rel="stylesheet"][data-precedence],style[data-precedence]'
      ), N = x.length ? x[x.length - 1] : null, R = N, H = 0; H < x.length; H++) {
        var J = x[H];
        if (J.dataset.precedence === d) R = J;
        else if (R !== N) break;
      }
      R ? R.parentNode.insertBefore(l, R.nextSibling) : (d = m.nodeType === 9 ? m.head : m, d.insertBefore(l, d.firstChild));
    }
    function WS(l, d) {
      l.crossOrigin == null && (l.crossOrigin = d.crossOrigin), l.referrerPolicy == null && (l.referrerPolicy = d.referrerPolicy), l.title == null && (l.title = d.title);
    }
    function qS(l, d) {
      l.crossOrigin == null && (l.crossOrigin = d.crossOrigin), l.referrerPolicy == null && (l.referrerPolicy = d.referrerPolicy), l.integrity == null && (l.integrity = d.integrity);
    }
    var Lg = null;
    function zj(l, d, m) {
      if (Lg === null) {
        var x = /* @__PURE__ */ new Map(), N = Lg = /* @__PURE__ */ new Map();
        N.set(m, x);
      } else
        N = Lg, x = N.get(m), x || (x = /* @__PURE__ */ new Map(), N.set(m, x));
      if (x.has(l)) return x;
      for (x.set(l, null), m = m.getElementsByTagName(l), N = 0; N < m.length; N++) {
        var R = m[N];
        if (!(R[wl] || R[qn] || l === "link" && R.getAttribute("rel") === "stylesheet") && R.namespaceURI !== "http://www.w3.org/2000/svg") {
          var H = R.getAttribute(d) || "";
          H = l + H;
          var J = x.get(H);
          J ? J.push(R) : x.set(H, [R]);
        }
      }
      return x;
    }
    function Bj(l, d, m) {
      l = l.ownerDocument || l, l.head.insertBefore(
        m,
        d === "title" ? l.querySelector("head > title") : null
      );
    }
    function LK(l, d, m) {
      if (m === 1 || d.itemProp != null) return !1;
      switch (l) {
        case "meta":
        case "title":
          return !0;
        case "style":
          if (typeof d.precedence != "string" || typeof d.href != "string" || d.href === "")
            break;
          return !0;
        case "link":
          if (typeof d.rel != "string" || typeof d.href != "string" || d.href === "" || d.onLoad || d.onError)
            break;
          return d.rel === "stylesheet" ? (l = d.disabled, typeof d.precedence == "string" && l == null) : !0;
        case "script":
          if (d.async && typeof d.async != "function" && typeof d.async != "symbol" && !d.onLoad && !d.onError && d.src && typeof d.src == "string")
            return !0;
      }
      return !1;
    }
    function Vj(l) {
      return !(l.type === "stylesheet" && (l.state.loading & 3) === 0);
    }
    function FK(l, d, m, x) {
      if (m.type === "stylesheet" && (typeof x.media != "string" || matchMedia(x.media).matches !== !1) && (m.state.loading & 4) === 0) {
        if (m.instance === null) {
          var N = hc(x.href), R = d.querySelector(
            Ff(N)
          );
          if (R) {
            d = R._p, d !== null && typeof d == "object" && typeof d.then == "function" && (l.count++, l = Fg.bind(l), d.then(l, l)), m.state.loading |= 4, m.instance = R, $n(R);
            return;
          }
          R = d.ownerDocument || d, x = Fj(x), (N = _o.get(N)) && WS(x, N), R = R.createElement("link"), $n(R);
          var H = R;
          H._p = new Promise(function(J, re) {
            H.onload = J, H.onerror = re;
          }), ar(R, "link", x), m.instance = R;
        }
        l.stylesheets === null && (l.stylesheets = /* @__PURE__ */ new Map()), l.stylesheets.set(m, d), (d = m.state.preload) && (m.state.loading & 3) === 0 && (l.count++, m = Fg.bind(l), d.addEventListener("load", m), d.addEventListener("error", m));
      }
    }
    var KS = 0;
    function TK(l, d) {
      return l.stylesheets && l.count === 0 && zg(l, l.stylesheets), 0 < l.count || 0 < l.imgCount ? function(m) {
        var x = setTimeout(function() {
          if (l.stylesheets && zg(l, l.stylesheets), l.unsuspend) {
            var R = l.unsuspend;
            l.unsuspend = null, R();
          }
        }, 6e4 + d);
        0 < l.imgBytes && KS === 0 && (KS = 62500 * bK());
        var N = setTimeout(
          function() {
            if (l.waitingForImages = !1, l.count === 0 && (l.stylesheets && zg(l, l.stylesheets), l.unsuspend)) {
              var R = l.unsuspend;
              l.unsuspend = null, R();
            }
          },
          (l.imgBytes > KS ? 50 : 800) + d
        );
        return l.unsuspend = m, function() {
          l.unsuspend = null, clearTimeout(x), clearTimeout(N);
        };
      } : null;
    }
    function Fg() {
      if (this.count--, this.count === 0 && (this.imgCount === 0 || !this.waitingForImages)) {
        if (this.stylesheets) zg(this, this.stylesheets);
        else if (this.unsuspend) {
          var l = this.unsuspend;
          this.unsuspend = null, l();
        }
      }
    }
    var Tg = null;
    function zg(l, d) {
      l.stylesheets = null, l.unsuspend !== null && (l.count++, Tg = /* @__PURE__ */ new Map(), d.forEach(zK, l), Tg = null, Fg.call(l));
    }
    function zK(l, d) {
      if (!(d.state.loading & 4)) {
        var m = Tg.get(l);
        if (m) var x = m.get(null);
        else {
          m = /* @__PURE__ */ new Map(), Tg.set(l, m);
          for (var N = l.querySelectorAll(
            "link[data-precedence],style[data-precedence]"
          ), R = 0; R < N.length; R++) {
            var H = N[R];
            (H.nodeName === "LINK" || H.getAttribute("media") !== "not all") && (m.set(H.dataset.precedence, H), x = H);
          }
          x && m.set(null, x);
        }
        N = d.instance, H = N.getAttribute("data-precedence"), R = m.get(H) || x, R === x && m.set(null, N), m.set(H, N), this.count++, x = Fg.bind(this), N.addEventListener("load", x), N.addEventListener("error", x), R ? R.parentNode.insertBefore(N, R.nextSibling) : (l = l.nodeType === 9 ? l.head : l, l.insertBefore(N, l.firstChild)), d.state.loading |= 4;
      }
    }
    var zf = {
      $$typeof: k,
      Provider: null,
      Consumer: null,
      _currentValue: W,
      _currentValue2: W,
      _threadCount: 0
    };
    function BK(l, d, m, x, N, R, H, J, re) {
      this.tag = 1, this.containerInfo = l, this.pingCache = this.current = this.pendingChildren = null, this.timeoutHandle = -1, this.callbackNode = this.next = this.pendingContext = this.context = this.cancelPendingCommit = null, this.callbackPriority = 0, this.expirationTimes = Yd(-1), this.entangledLanes = this.shellSuspendCounter = this.errorRecoveryDisabledLanes = this.expiredLanes = this.warmLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0, this.entanglements = Yd(0), this.hiddenUpdates = Yd(null), this.identifierPrefix = x, this.onUncaughtError = N, this.onCaughtError = R, this.onRecoverableError = H, this.pooledCache = null, this.pooledCacheLanes = 0, this.formState = re, this.incompleteTransitions = /* @__PURE__ */ new Map();
    }
    function Uj(l, d, m, x, N, R, H, J, re, fe, ve, xe) {
      return l = new BK(
        l,
        d,
        m,
        H,
        re,
        fe,
        ve,
        xe,
        J
      ), d = 1, R === !0 && (d |= 24), R = Yr(3, null, null, d), l.current = R, R.stateNode = l, d = Ck(), d.refCount++, l.pooledCache = d, d.refCount++, R.memoizedState = {
        element: x,
        isDehydrated: m,
        cache: d
      }, Mk(R), l;
    }
    function Hj(l) {
      return l ? (l = Ku, l) : Ku;
    }
    function Wj(l, d, m, x, N, R) {
      N = Hj(N), x.context === null ? x.context = N : x.pendingContext = N, x = bs(d), x.payload = { element: m }, R = R === void 0 ? null : R, R !== null && (x.callback = R), m = ws(l, x, d), m !== null && (Fr(m, l, d), yf(m, l, d));
    }
    function qj(l, d) {
      if (l = l.memoizedState, l !== null && l.dehydrated !== null) {
        var m = l.retryLane;
        l.retryLane = m !== 0 && m < d ? m : d;
      }
    }
    function GS(l, d) {
      qj(l, d), (l = l.alternate) && qj(l, d);
    }
    function Kj(l) {
      if (l.tag === 13 || l.tag === 31) {
        var d = Cl(l, 67108864);
        d !== null && Fr(d, l, 67108864), GS(l, 67108864);
      }
    }
    function Gj(l) {
      if (l.tag === 13 || l.tag === 31) {
        var d = to();
        d = Jd(d);
        var m = Cl(l, d);
        m !== null && Fr(m, l, d), GS(l, d);
      }
    }
    var Bg = !0;
    function VK(l, d, m, x) {
      var N = B.T;
      B.T = null;
      var R = G.p;
      try {
        G.p = 2, XS(l, d, m, x);
      } finally {
        G.p = R, B.T = N;
      }
    }
    function UK(l, d, m, x) {
      var N = B.T;
      B.T = null;
      var R = G.p;
      try {
        G.p = 8, XS(l, d, m, x);
      } finally {
        G.p = R, B.T = N;
      }
    }
    function XS(l, d, m, x) {
      if (Bg) {
        var N = YS(x);
        if (N === null)
          $S(
            l,
            d,
            x,
            Vg,
            m
          ), Yj(l, x);
        else if (WK(
          N,
          l,
          d,
          m,
          x
        ))
          x.stopPropagation();
        else if (Yj(l, x), d & 4 && -1 < HK.indexOf(l)) {
          for (; N !== null; ) {
            var R = us(N);
            if (R !== null)
              switch (R.tag) {
                case 3:
                  if (R = R.stateNode, R.current.memoizedState.isDehydrated) {
                    var H = Kr(R.pendingLanes);
                    if (H !== 0) {
                      var J = R;
                      for (J.pendingLanes |= 2, J.entangledLanes |= 2; H; ) {
                        var re = 1 << 31 - Re(H);
                        J.entanglements[1] |= re, H &= ~re;
                      }
                      ha(R), (Tt & 6) === 0 && (_g = Ee() + 500, Af(0));
                    }
                  }
                  break;
                case 31:
                case 13:
                  J = Cl(R, 2), J !== null && Fr(J, R, 2), Cg(), GS(R, 2);
              }
            if (R = YS(x), R === null && $S(
              l,
              d,
              x,
              Vg,
              m
            ), R === N) break;
            N = R;
          }
          N !== null && x.stopPropagation();
        } else
          $S(
            l,
            d,
            x,
            null,
            m
          );
      }
    }
    function YS(l) {
      return l = Qx(l), JS(l);
    }
    var Vg = null;
    function JS(l) {
      if (Vg = null, l = ls(l), l !== null) {
        var d = a(l);
        if (d === null) l = null;
        else {
          var m = d.tag;
          if (m === 13) {
            if (l = i(d), l !== null) return l;
            l = null;
          } else if (m === 31) {
            if (l = s(d), l !== null) return l;
            l = null;
          } else if (m === 3) {
            if (d.stateNode.current.memoizedState.isDehydrated)
              return d.tag === 3 ? d.stateNode.containerInfo : null;
            l = null;
          } else d !== l && (l = null);
        }
      }
      return Vg = l, null;
    }
    function Xj(l) {
      switch (l) {
        case "beforetoggle":
        case "cancel":
        case "click":
        case "close":
        case "contextmenu":
        case "copy":
        case "cut":
        case "auxclick":
        case "dblclick":
        case "dragend":
        case "dragstart":
        case "drop":
        case "focusin":
        case "focusout":
        case "input":
        case "invalid":
        case "keydown":
        case "keypress":
        case "keyup":
        case "mousedown":
        case "mouseup":
        case "paste":
        case "pause":
        case "play":
        case "pointercancel":
        case "pointerdown":
        case "pointerup":
        case "ratechange":
        case "reset":
        case "resize":
        case "seeked":
        case "submit":
        case "toggle":
        case "touchcancel":
        case "touchend":
        case "touchstart":
        case "volumechange":
        case "change":
        case "selectionchange":
        case "textInput":
        case "compositionstart":
        case "compositionend":
        case "compositionupdate":
        case "beforeblur":
        case "afterblur":
        case "beforeinput":
        case "blur":
        case "fullscreenchange":
        case "focus":
        case "hashchange":
        case "popstate":
        case "select":
        case "selectstart":
          return 2;
        case "drag":
        case "dragenter":
        case "dragexit":
        case "dragleave":
        case "dragover":
        case "mousemove":
        case "mouseout":
        case "mouseover":
        case "pointermove":
        case "pointerout":
        case "pointerover":
        case "scroll":
        case "touchmove":
        case "wheel":
        case "mouseenter":
        case "mouseleave":
        case "pointerenter":
        case "pointerleave":
          return 8;
        case "message":
          switch (_e()) {
            case ie:
              return 2;
            case me:
              return 8;
            case Se:
            case je:
              return 32;
            case Ae:
              return 268435456;
            default:
              return 32;
          }
        default:
          return 32;
      }
    }
    var QS = !1, Rs = null, js = null, Is = null, Bf = /* @__PURE__ */ new Map(), Vf = /* @__PURE__ */ new Map(), As = [], HK = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset".split(
      " "
    );
    function Yj(l, d) {
      switch (l) {
        case "focusin":
        case "focusout":
          Rs = null;
          break;
        case "dragenter":
        case "dragleave":
          js = null;
          break;
        case "mouseover":
        case "mouseout":
          Is = null;
          break;
        case "pointerover":
        case "pointerout":
          Bf.delete(d.pointerId);
          break;
        case "gotpointercapture":
        case "lostpointercapture":
          Vf.delete(d.pointerId);
      }
    }
    function Uf(l, d, m, x, N, R) {
      return l === null || l.nativeEvent !== R ? (l = {
        blockedOn: d,
        domEventName: m,
        eventSystemFlags: x,
        nativeEvent: R,
        targetContainers: [N]
      }, d !== null && (d = us(d), d !== null && Kj(d)), l) : (l.eventSystemFlags |= x, d = l.targetContainers, N !== null && d.indexOf(N) === -1 && d.push(N), l);
    }
    function WK(l, d, m, x, N) {
      switch (d) {
        case "focusin":
          return Rs = Uf(
            Rs,
            l,
            d,
            m,
            x,
            N
          ), !0;
        case "dragenter":
          return js = Uf(
            js,
            l,
            d,
            m,
            x,
            N
          ), !0;
        case "mouseover":
          return Is = Uf(
            Is,
            l,
            d,
            m,
            x,
            N
          ), !0;
        case "pointerover":
          var R = N.pointerId;
          return Bf.set(
            R,
            Uf(
              Bf.get(R) || null,
              l,
              d,
              m,
              x,
              N
            )
          ), !0;
        case "gotpointercapture":
          return R = N.pointerId, Vf.set(
            R,
            Uf(
              Vf.get(R) || null,
              l,
              d,
              m,
              x,
              N
            )
          ), !0;
      }
      return !1;
    }
    function Jj(l) {
      var d = ls(l.target);
      if (d !== null) {
        var m = a(d);
        if (m !== null) {
          if (d = m.tag, d === 13) {
            if (d = i(m), d !== null) {
              l.blockedOn = d, Mh(l.priority, function() {
                Gj(m);
              });
              return;
            }
          } else if (d === 31) {
            if (d = s(m), d !== null) {
              l.blockedOn = d, Mh(l.priority, function() {
                Gj(m);
              });
              return;
            }
          } else if (d === 3 && m.stateNode.current.memoizedState.isDehydrated) {
            l.blockedOn = m.tag === 3 ? m.stateNode.containerInfo : null;
            return;
          }
        }
      }
      l.blockedOn = null;
    }
    function Ug(l) {
      if (l.blockedOn !== null) return !1;
      for (var d = l.targetContainers; 0 < d.length; ) {
        var m = YS(l.nativeEvent);
        if (m === null) {
          m = l.nativeEvent;
          var x = new m.constructor(
            m.type,
            m
          );
          Jx = x, m.target.dispatchEvent(x), Jx = null;
        } else
          return d = us(m), d !== null && Kj(d), l.blockedOn = m, !1;
        d.shift();
      }
      return !0;
    }
    function Qj(l, d, m) {
      Ug(l) && m.delete(d);
    }
    function qK() {
      QS = !1, Rs !== null && Ug(Rs) && (Rs = null), js !== null && Ug(js) && (js = null), Is !== null && Ug(Is) && (Is = null), Bf.forEach(Qj), Vf.forEach(Qj);
    }
    function Hg(l, d) {
      l.blockedOn === d && (l.blockedOn = null, QS || (QS = !0, e.unstable_scheduleCallback(
        e.unstable_NormalPriority,
        qK
      )));
    }
    var Wg = null;
    function Zj(l) {
      Wg !== l && (Wg = l, e.unstable_scheduleCallback(
        e.unstable_NormalPriority,
        function() {
          Wg === l && (Wg = null);
          for (var d = 0; d < l.length; d += 3) {
            var m = l[d], x = l[d + 1], N = l[d + 2];
            if (typeof x != "function") {
              if (JS(x || m) === null)
                continue;
              break;
            }
            var R = us(m);
            R !== null && (l.splice(d, 3), d -= 3, Yk(
              R,
              {
                pending: !0,
                data: N,
                method: m.method,
                action: x
              },
              x,
              N
            ));
          }
        }
      ));
    }
    function vc(l) {
      function d(re) {
        return Hg(re, l);
      }
      Rs !== null && Hg(Rs, l), js !== null && Hg(js, l), Is !== null && Hg(Is, l), Bf.forEach(d), Vf.forEach(d);
      for (var m = 0; m < As.length; m++) {
        var x = As[m];
        x.blockedOn === l && (x.blockedOn = null);
      }
      for (; 0 < As.length && (m = As[0], m.blockedOn === null); )
        Jj(m), m.blockedOn === null && As.shift();
      if (m = (l.ownerDocument || l).$$reactFormReplay, m != null)
        for (x = 0; x < m.length; x += 3) {
          var N = m[x], R = m[x + 1], H = N[pr] || null;
          if (typeof R == "function")
            H || Zj(m);
          else if (H) {
            var J = null;
            if (R && R.hasAttribute("formAction")) {
              if (N = R, H = R[pr] || null)
                J = H.formAction;
              else if (JS(N) !== null) continue;
            } else J = H.action;
            typeof J == "function" ? m[x + 1] = J : (m.splice(x, 3), x -= 3), Zj(m);
          }
        }
    }
    function e5() {
      function l(R) {
        R.canIntercept && R.info === "react-transition" && R.intercept({
          handler: function() {
            return new Promise(function(H) {
              return N = H;
            });
          },
          focusReset: "manual",
          scroll: "manual"
        });
      }
      function d() {
        N !== null && (N(), N = null), x || setTimeout(m, 20);
      }
      function m() {
        if (!x && !navigation.transition) {
          var R = navigation.currentEntry;
          R && R.url != null && navigation.navigate(R.url, {
            state: R.getState(),
            info: "react-transition",
            history: "replace"
          });
        }
      }
      if (typeof navigation == "object") {
        var x = !1, N = null;
        return navigation.addEventListener("navigate", l), navigation.addEventListener("navigatesuccess", d), navigation.addEventListener("navigateerror", d), setTimeout(m, 100), function() {
          x = !0, navigation.removeEventListener("navigate", l), navigation.removeEventListener("navigatesuccess", d), navigation.removeEventListener("navigateerror", d), N !== null && (N(), N = null);
        };
      }
    }
    function ZS(l) {
      this._internalRoot = l;
    }
    qg.prototype.render = ZS.prototype.render = function(l) {
      var d = this._internalRoot;
      if (d === null) throw Error(r(409));
      var m = d.current, x = to();
      Wj(m, x, l, d, null, null);
    }, qg.prototype.unmount = ZS.prototype.unmount = function() {
      var l = this._internalRoot;
      if (l !== null) {
        this._internalRoot = null;
        var d = l.containerInfo;
        Wj(l.current, 2, null, l, null, null), Cg(), d[oi] = null;
      }
    };
    function qg(l) {
      this._internalRoot = l;
    }
    qg.prototype.unstable_scheduleHydration = function(l) {
      if (l) {
        var d = Nh();
        l = { blockedOn: null, target: l, priority: d };
        for (var m = 0; m < As.length && d !== 0 && d < As[m].priority; m++) ;
        As.splice(m, 0, l), m === 0 && Jj(l);
      }
    };
    var t5 = t.version;
    if (t5 !== "19.2.3")
      throw Error(
        r(
          527,
          t5,
          "19.2.3"
        )
      );
    G.findDOMNode = function(l) {
      var d = l._reactInternals;
      if (d === void 0)
        throw typeof l.render == "function" ? Error(r(188)) : (l = Object.keys(l).join(","), Error(r(268, l)));
      return l = c(d), l = l !== null ? f(l) : null, l = l === null ? null : l.stateNode, l;
    };
    var KK = {
      bundleType: 0,
      version: "19.2.3",
      rendererPackageName: "react-dom",
      currentDispatcherRef: B,
      reconcilerVersion: "19.2.3"
    };
    if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u") {
      var Kg = __REACT_DEVTOOLS_GLOBAL_HOOK__;
      if (!Kg.isDisabled && Kg.supportsFiber)
        try {
          At = Kg.inject(
            KK
          ), qt = Kg;
        } catch {
        }
    }
    return Wf.createRoot = function(l, d) {
      if (!o(l)) throw Error(r(299));
      var m = !1, x = "", N = lR, R = uR, H = cR;
      return d != null && (d.unstable_strictMode === !0 && (m = !0), d.identifierPrefix !== void 0 && (x = d.identifierPrefix), d.onUncaughtError !== void 0 && (N = d.onUncaughtError), d.onCaughtError !== void 0 && (R = d.onCaughtError), d.onRecoverableError !== void 0 && (H = d.onRecoverableError)), d = Uj(
        l,
        1,
        !1,
        null,
        null,
        m,
        x,
        null,
        N,
        R,
        H,
        e5
      ), l[oi] = d.current, AS(l), new ZS(d);
    }, Wf.hydrateRoot = function(l, d, m) {
      if (!o(l)) throw Error(r(299));
      var x = !1, N = "", R = lR, H = uR, J = cR, re = null;
      return m != null && (m.unstable_strictMode === !0 && (x = !0), m.identifierPrefix !== void 0 && (N = m.identifierPrefix), m.onUncaughtError !== void 0 && (R = m.onUncaughtError), m.onCaughtError !== void 0 && (H = m.onCaughtError), m.onRecoverableError !== void 0 && (J = m.onRecoverableError), m.formState !== void 0 && (re = m.formState)), d = Uj(
        l,
        1,
        !0,
        d,
        m ?? null,
        x,
        N,
        re,
        R,
        H,
        J,
        e5
      ), d.context = Hj(null), m = d.current, x = to(), x = Jd(x), N = bs(x), N.callback = null, ws(m, N, x), m = x, d.current.lanes = m, bl(d, m), ha(d), l[oi] = d.current, AS(l), new qg(d);
    }, Wf.version = "19.2.3", Wf;
  }
  var m5;
  function lG() {
    if (m5) return n_.exports;
    m5 = 1;
    function e() {
      if (!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != "function"))
        try {
          __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(e);
        } catch (t) {
          console.error(t);
        }
    }
    return e(), n_.exports = sG(), n_.exports;
  }
  var uG = lG();
  const Xn = {
    /** Debug level - most verbose, for development debugging */
    DEBUG: 0,
    /** Info level - general information about application flow */
    INFO: 10,
    /** Warning level - concerning but non-critical issues */
    WARN: 20,
    /** Error level - critical problems requiring attention */
    ERROR: 30
  }, JF = Xn.DEBUG, QF = Xn.INFO, cG = Xn.WARN, dG = Xn.ERROR, h5 = (e) => typeof e == "string" ? e : e === Xn.DEBUG ? "DEBUG" : e === Xn.INFO ? "INFO" : e === Xn.WARN ? "WARN" : e === Xn.ERROR ? "ERROR" : "UNKNOWN";
  function fG() {
    const e = [];
    return function(t, n) {
      if (typeof n != "object" || n === null)
        return n;
      for (; e.length > 0 && e.at(-1) !== this; )
        e.pop();
      return e.includes(n) ? "[Circular]" : (e.push(n), n);
    };
  }
  const g5 = (e) => {
    if (typeof e == "number") return e;
    const t = e.toLowerCase();
    if (t === "debug") return Xn.DEBUG;
    if (t === "info") return Xn.INFO;
    if (t === "warn" || t === "warning") return Xn.WARN;
    if (t === "error") return Xn.ERROR;
    throw new Error(`Unknown log level: ${e}`);
  };
  class VE {
    /**
     * Create a new BaseLogger instance.
     *
     * @param {string} name - The name/identifier for this logger
     * @param {number | string} [level=LEVELS.INFO] - Initial log level
     * @param {boolean} [with_timestamp=true] - Whether to include timestamps
     * @example
     * ```typescript
     * const logger = new MyLogger("DatabaseService", "DEBUG", true);
     * ```
     */
    constructor(t, n = Xn.INFO, r = !0) {
      this.name = t, this.level = g5(n), this._level_name = h5(this.level), this.with_timestamp = r;
    }
    /**
     * Set the logging level for this logger instance.
     *
     * @param {number | string} level - The new log level (numeric or string)
     * @example
     * ```typescript
     * logger.set_level(DEBUG); // Enable debug logging
     * logger.set_level("debug"); // Same as above using string
     * ```
     */
    set_level(t) {
      typeof t == "string" && (t = g5(t)), this.level = t, this._level_name = h5(this.level);
    }
    /**
     * Get the string representation of the current log level.
     *
     * @returns {string} The current log level as a string
     * @example
     * ```typescript
     * logger.level_name // "INFO"
     * ```
     */
    get level_name() {
      return this._level_name;
    }
    /**
     * Format a log message with level, timestamp, and arguments.
     *
     * @param {string} levelstring - The log level string (DEBUG, INFO, etc.)
     * @param {string} message - The primary log message
     * @param {...any[]} args - Additional arguments to include
     * @returns {string} The formatted log message
     * @example
     * ```typescript
     * // Returns: "12/25/2023, 10:30:15 AM [MyApp] INFO: User logged in {userId: 123}"
     * logger.format_message("INFO", "User logged in", {userId: 123});
     * ```
     */
    format_message(t, n, ...r) {
      return `${this.with_timestamp ? (/* @__PURE__ */ new Date()).toLocaleString() : ""} [${this.name}] ${t}: ${n} ${r.map((o) => JSON.stringify(o, fG())).join(" ")}`.trim();
    }
    /**
     * Log a debug message if the current level allows it.
     *
     * @param {string} message - The primary log message
     * @param {...any[]} args - Additional context arguments
     */
    debug(t, ...n) {
      this.level <= Xn.DEBUG && this.out_debug(this.format_message("DEBUG", t, ...n));
    }
    /**
     * Log an info message if the current level allows it.
     *
     * @param {string} message - The primary log message
     * @param {...any[]} args - Additional context arguments
     */
    info(t, ...n) {
      this.level <= Xn.INFO && this.out_info(this.format_message("INFO", t, ...n));
    }
    /**
     * Log a warning message if the current level allows it.
     *
     * @param {string} message - The primary log message
     * @param {...any[]} args - Additional context arguments
     */
    warn(t, ...n) {
      this.level <= Xn.WARN && this.out_warn(this.format_message("WARN", t, ...n));
    }
    /**
     * Log an error message if the current level allows it.
     *
     * @param {string} message - The primary log message
     * @param {Error} [error] - Optional Error object for stack trace handling
     */
    error(t, n) {
      this.level <= Xn.ERROR && this.out_error(this.format_message("ERROR", t), n);
    }
  }
  class UE extends VE {
    /**
     * Create a new ConsoleLogger instance.
     *
     * @param {string} name - The name/identifier for this logger
     * @param {number | string} [level=LEVELS.INFO] - Initial log level
     * @example
     * ```typescript
     * const logger = new ConsoleLogger("API", "WARN");
     * ```
     */
    constructor(t, n = Xn.INFO) {
      super(t, n);
    }
    /**
     * Output debug message to console.debug.
     *
     * @protected
     * @param {string} formatted_message - The formatted message to output
     */
    out_debug(t) {
      console.debug(t);
    }
    /**
     * Output info message to console.info.
     *
     * @protected
     * @param {string} formatted_message - The formatted message to output
     */
    out_info(t) {
      console.info(t);
    }
    /**
     * Output warning message to console.warn.
     *
     * @protected
     * @param {string} formatted_message - The formatted message to output
     */
    out_warn(t) {
      console.warn(t);
    }
    /**
     * Output error message to console.error.
     *
     * @protected
     * @param {string} formatted_message - The formatted message to output
     * @param {Error | undefined} error - Optional Error object for stack trace handling
     */
    out_error(t, n) {
      console.error(t), n && console.error(n);
    }
  }
  function r_(e) {
    return e.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#039;");
  }
  class pG extends VE {
    /**
     * Create a new DivLogger instance.
     *
     * @param {HTMLDivElement} div - The HTML div element to append log messages to
     * @param {string} name - The name/identifier for this logger
     * @param {number | string} [level=LEVELS.INFO] - Initial log level
     * @example
     * ```typescript
     * const logContainer = document.createElement('div');
     * const logger = new DivLogger(logContainer, "WebWorker", "DEBUG");
     * ```
     */
    constructor(t, n, r = Xn.INFO) {
      super(n, r), this._div = t;
    }
    /**
     * Format a log message with HTML escaping for safe DOM insertion.
     *
     * Overrides the base implementation to automatically escape HTML content,
     * preventing XSS vulnerabilities when displaying logs in web interfaces.
     *
     * @param {string} levelstring - The log level string (DEBUG, INFO, etc.)
     * @param {string} message - The primary log message
     * @param {...any[]} args - Additional arguments to include
     * @returns {string} The formatted and HTML-escaped log message
     * @example
     * ```typescript
     * // Input: "User input: <script>alert('xss')<\/script>"
     * // Output: "12/25/2023, 10:30:15 AM [UI] INFO: User input: &lt;script&gt;alert('xss')&lt;/script&gt;"
     * ```
     */
    format_message(t, n, ...r) {
      return r_(super.format_message(t, n, ...r));
    }
    /**
     * Output debug message as HTML div with 'debug' class.
     *
     * @protected
     * @param {string} formatted_message - The pre-formatted and HTML-escaped message to output
     */
    out_debug(t) {
      this._div.innerHTML += `<div class="debug">${t}</div>`;
    }
    /**
     * Output info message as HTML div with 'info' class.
     *
     * @protected
     * @param {string} formatted_message - The pre-formatted and HTML-escaped message to output
     */
    out_info(t) {
      this._div.innerHTML += `<div class="info">${t}</div>`;
    }
    /**
     * Output warning message as HTML div with 'warn' class.
     *
     * @protected
     * @param {string} formatted_message - The pre-formatted and HTML-escaped message to output
     */
    out_warn(t) {
      this._div.innerHTML += `<div class="warn">${t}</div>`;
    }
    /**
     * Output error message as HTML div with 'error' class.
     *
     * @protected
     * @param {string} formatted_message - The pre-formatted and HTML-escaped message to output
     * @param {Error | undefined} error - Optional Error object for stack trace handling
     */
    out_error(t, n) {
      let r = t;
      if (n) {
        const o = n.stack ? r_(n.stack) : r_(n.message);
        r += `<br><pre>${o}</pre>`;
      }
      this._div.innerHTML += `<div class="error">${r}</div>`;
    }
  }
  function mG(e) {
    const t = window.atob(e), n = t.length, r = new Uint8Array(n);
    for (let o = 0; o < n; o++)
      r[o] = t.charCodeAt(o);
    return r;
  }
  function hG(e, t) {
    return new Blob([e], { type: t });
  }
  function gG(e, t) {
    return hG(mG(e), t);
  }
  function vG(e, t, n) {
    const r = gG(e, n), o = URL.createObjectURL(r), a = document.createElement("a");
    a.href = o, a.download = t, a.click(), URL.revokeObjectURL(o), a.remove();
  }
  function yG(e, t = !0) {
    return new Promise((n, r) => {
      const o = new FileReader();
      o.onload = () => {
        const a = o.result;
        n(t ? a.split(",")[1] : a);
      }, o.onerror = () => r(o.error), o.readAsDataURL(e);
    });
  }
  function bG(e) {
    return new Promise((t, n) => {
      const r = document.createElement("input");
      r.type = "file", r.accept = e, r.onchange = () => {
        const o = r.files?.[0];
        o ? t(o) : n(new Error("No file selected"));
      }, r.oncancel = () => {
        n(new Error("File selection cancelled"));
      }, r.click();
    });
  }
  function wG(e) {
    return bG(e).then(yG);
  }
  async function xG(e, t = !0) {
    try {
      const n = await fetch(e);
      if (!n.ok)
        throw new Error(
          `Failed to fetch from URL: ${n.status} ${n.statusText}`
        );
      const r = await n.blob();
      return await new Promise((o, a) => {
        const i = new FileReader();
        i.onload = () => {
          const s = i.result;
          typeof s != "string" && (a("Failed to convert URL to Base64: No result from FileReader"), a(i.error)), o(t ? s.split(",")[1] : s);
        }, i.onerror = () => a(i.error), i.readAsDataURL(r);
      });
    } catch (n) {
      throw console.error("Error converting URL to Base64:", n), n;
    }
  }
  function qs(e) {
    if (Object.prototype.toString.call(e) !== "[object Object]")
      return !1;
    const t = Object.getPrototypeOf(e);
    return t === null || t === Object.prototype;
  }
  function HE(e, t, n = /* @__PURE__ */ new WeakMap()) {
    if (e === t) return !0;
    if (typeof e != "object" || e === null || typeof t != "object" || t === null)
      return !1;
    if (n.has(e))
      return n.get(e) === t;
    if (n.set(e, t), e.constructor !== t.constructor) return !1;
    if (e.constructor === Object || e.constructor === Array) {
      const r = Object.keys(e), o = Object.keys(t);
      if (r.length !== o.length) return !1;
      for (const a of r)
        if (!o.includes(a) || !HE(e[a], t[a], n)) return !1;
    }
    return e instanceof Date && t instanceof Date ? e.getTime() === t.getTime() : !0;
  }
  const tl = (e, t) => {
    let n = !1;
    if (!qs(e))
      throw new Error("Target must be a plain object not" + typeof e);
    if (!qs(t))
      throw new Error("Source must be a plain object not" + typeof t);
    const r = { ...e };
    return Object.keys(t).forEach((o) => {
      const a = t[o], i = e[o];
      if (qs(a) && qs(i)) {
        const { new_obj: s, change: u } = tl(
          i,
          a
        );
        u && (n = !0, r[o] = s);
      } else HE(i, a) || (n = !0, r[o] = a);
    }), { new_obj: r, change: n };
  }, WE = (e, t) => {
    let n = !1;
    if (!qs(e))
      throw new Error("Target must be a plain object");
    if (!qs(t))
      throw new Error("Source must be a plain object");
    const r = { ...e };
    return Object.keys(t).forEach((o) => {
      const a = t[o], i = e[o];
      if (!(i === void 0 && a === void 0)) {
        if (i === void 0) {
          n = !0, r[o] = a;
          return;
        }
        if (qs(a) && qs(i)) {
          const { new_obj: s, change: u } = WE(
            i,
            a
          );
          u && (n = !0, r[o] = s);
        }
      }
    }), { new_obj: r, change: n };
  }, Yb = (e, t = void 0) => {
    const n = JSON.stringify(e);
    return (r) => {
      let o = JSON.parse(n);
      return t !== void 0 && (o = t(o)), r === void 0 ? o : WE(r, o).new_obj;
    };
  }, Co = (e, t) => t === void 0 ? [e, !1] : [t, e !== t];
  function ZF(e, t) {
    throw new Error("Unhandled case: " + e + " with: " + JSON.stringify(t));
  }
  const Wc = (e, t) => {
    if (t === void 0) return [e, !1];
    if (e === void 0) return [t, t !== void 0];
    const { new_obj: n, change: r } = tl(e, t);
    return [n, r];
  }, kG = ({ error: e }) => /* @__PURE__ */ S.jsxs("div", { className: "error-div", children: [
    /* @__PURE__ */ S.jsx("h1", { children: "Error" }),
    /* @__PURE__ */ S.jsx("p", { children: e.message })
  ] }), Jb = C.createContext(
    void 0
  ), Ks = C.forwardRef((e, t) => {
    const {
      asChild: n = !1,
      children: r,
      className: o,
      style: a,
      htime: i = 300,
      vtime: s = 300,
      hdelay: u = 0,
      vdelay: c = 200,
      zIndex: f = 9999,
      ...p
    } = e, [g, h] = C.useState(!1), [y, b] = C.useState({}), v = C.useRef(null), w = C.useRef(null);
    C.useImperativeHandle(t, () => v.current, []);
    const _ = C.useMemo(
      () => ({
        horizontal: i,
        vertical: s,
        horizontalDelay: u,
        verticalDelay: c
      }),
      [i, s, u, c]
    ), k = C.useCallback(
      () => Math.max(
        _.horizontal + _.horizontalDelay,
        _.vertical + _.verticalDelay
      ),
      [_]
    ), E = C.useCallback(async () => {
      if (v.current)
        try {
          const F = v.current.getBoundingClientRect();
          w.current = F, b({
            position: "fixed",
            top: `${F.top}px`,
            left: `${F.left}px`,
            width: `${F.width}px`,
            height: `${F.height}px`,
            zIndex: f,
            transition: "none"
          }), h(!0), v.current.offsetHeight, b((j) => ({
            ...j,
            transition: [
              `width ${_.horizontal}ms ease-in-out ${_.horizontalDelay}ms`,
              `left ${_.horizontal}ms ease-in-out ${_.horizontalDelay}ms`,
              `height ${_.vertical}ms ease-in-out ${_.verticalDelay}ms`,
              `top ${_.vertical}ms ease-in-out ${_.verticalDelay}ms`
            ].join(", ")
          })), requestAnimationFrame(() => {
            b((j) => ({
              ...j,
              top: "0",
              left: "0",
              width: "100vw",
              height: "100vh"
            }));
          }), await new Promise((j) => setTimeout(j, k()));
        } catch (F) {
          console.warn("Error during expand animation:", F), h(!0);
        }
    }, [_, f, k]), P = C.useCallback(async () => {
      if (!v.current || !w.current) return;
      const F = w.current;
      b((j) => ({
        ...j,
        transition: [
          `width ${_.horizontal}ms ease-in-out ${_.verticalDelay}ms`,
          `left ${_.horizontal}ms ease-in-out ${_.verticalDelay}ms`,
          `height ${_.vertical}ms ease-in-out ${_.horizontalDelay}ms`,
          `top ${_.vertical}ms ease-in-out ${_.horizontalDelay}ms`
        ].join(", ")
      })), requestAnimationFrame(() => {
        b((j) => ({
          ...j,
          top: `${F.top}px`,
          left: `${F.left}px`,
          width: `${F.width}px`,
          height: `${F.height}px`
        }));
      }), await new Promise((j) => setTimeout(j, k())), b({}), h(!1), w.current = null;
    }, [_, k]), O = C.useCallback(async () => {
      g ? await P() : await E();
    }, [g, E, P]), M = C.useMemo(
      () => ({ isExpanded: g, toggleExpand: O }),
      [g, O]
    ), I = C.useMemo(
      () => ({ ...a, ...y }),
      [a, y]
    );
    let A;
    if (n && C.isValidElement(r)) {
      const F = r;
      A = C.cloneElement(F, {
        ref: v,
        className: [F.props.className, o].filter(Boolean).join(" "),
        style: { ...F.props.style, ...I },
        ...p
      });
    } else
      A = /* @__PURE__ */ S.jsx("div", { ref: v, className: o, style: I, ...p, children: r });
    const D = /* @__PURE__ */ S.jsx(Jb.Provider, { value: M, children: A });
    return g ? xu.createPortal(D, document.body) : D;
  });
  Ks.displayName = "SmoothExpand";
  Ks.Trigger = function({
    children: e,
    className: t
  }) {
    const n = C.useContext(Jb);
    if (!n)
      throw new Error(
        "SmoothExpand.Trigger must be used within a SmoothExpand component"
      );
    return /* @__PURE__ */ S.jsx(
      "div",
      {
        className: t,
        style: { cursor: "pointer" },
        onClick: n.toggleExpand,
        role: "button",
        tabIndex: 0,
        onKeyDown: (r) => {
          (r.key === "Enter" || r.key === " ") && (r.preventDefault(), n.toggleExpand());
        },
        children: e
      }
    );
  };
  Ks.Expanded = function({
    children: e
  }) {
    const t = C.useContext(Jb);
    if (!t)
      throw new Error(
        "SmoothExpand.Expanded must be used within a SmoothExpand component"
      );
    return t.isExpanded ? /* @__PURE__ */ S.jsx(S.Fragment, { children: e }) : null;
  };
  Ks.Collapsed = function({
    children: e
  }) {
    const t = C.useContext(Jb);
    if (!t)
      throw new Error(
        "SmoothExpand.Collapsed must be used within a SmoothExpand component"
      );
    return t.isExpanded ? null : /* @__PURE__ */ S.jsx(S.Fragment, { children: e });
  };
  const Qb = C.createContext(
    void 0
  ), Ai = C.forwardRef((e, t) => {
    const { asChild: n = !1, children: r, className: o, style: a, ...i } = e, [s, u] = C.useState(!1), c = C.useRef(null);
    C.useImperativeHandle(t, () => c.current, []);
    const f = C.useCallback(async (v) => {
      const w = v;
      if (v.requestFullscreen)
        await v.requestFullscreen();
      else if (w.mozRequestFullScreen)
        await w.mozRequestFullScreen();
      else if (w.webkitRequestFullscreen)
        await w.webkitRequestFullscreen();
      else if (w.msRequestFullscreen)
        await w.msRequestFullscreen();
      else
        throw new Error("Fullscreen API is not supported in this browser");
    }, []), p = C.useCallback(async () => {
      const v = document;
      if (document.exitFullscreen)
        await document.exitFullscreen();
      else if (v.mozCancelFullScreen)
        await v.mozCancelFullScreen();
      else if (v.webkitExitFullscreen)
        await v.webkitExitFullscreen();
      else if (v.msExitFullscreen)
        await v.msExitFullscreen();
      else
        throw new Error("Exit fullscreen API is not supported in this browser");
    }, []), g = C.useCallback(async () => {
      try {
        const v = c.current;
        if (!v) {
          console.warn("FullScreen: No element reference available");
          return;
        }
        s ? await p() : await f(v);
      } catch (v) {
        console.error("FullScreen: Error toggling fullscreen mode", v);
      }
    }, [s, f, p]), h = C.useCallback(() => {
      const v = !!(document.fullscreenElement || document.webkitFullscreenElement || document.mozFullScreenElement || document.msFullscreenElement);
      u(v);
    }, []);
    C.useEffect(() => {
      const v = [
        "fullscreenchange",
        "webkitfullscreenchange",
        "mozfullscreenchange",
        "MSFullscreenChange"
      ];
      return v.forEach((w) => {
        document.addEventListener(w, h);
      }), () => {
        v.forEach((w) => {
          document.removeEventListener(w, h);
        });
      };
    }, [h]);
    const y = C.useMemo(
      () => ({ isFullScreen: s, toggleFullscreen: g }),
      [s, g]
    );
    let b;
    if (n && C.isValidElement(r)) {
      const v = r;
      b = C.cloneElement(v, {
        ref: c,
        className: [v.props.className, o].filter(Boolean).join(" "),
        style: { ...v.props.style, ...a },
        ...i
      });
    } else
      b = /* @__PURE__ */ S.jsx("div", { ref: c, className: o, style: a, ...i, children: r });
    return /* @__PURE__ */ S.jsx(Qb.Provider, { value: y, children: b });
  });
  Ai.displayName = "FullScreen";
  Ai.Trigger = function({
    children: e,
    className: t
  }) {
    const n = C.useContext(Qb);
    if (!n)
      throw new Error(
        "FullScreen.Trigger must be used within a FullScreen component"
      );
    return /* @__PURE__ */ S.jsx(
      "div",
      {
        className: t,
        style: { cursor: "pointer" },
        onClick: n.toggleFullscreen,
        role: "button",
        tabIndex: 0,
        onKeyDown: (r) => {
          (r.key === "Enter" || r.key === " ") && (r.preventDefault(), n.toggleFullscreen());
        },
        children: e
      }
    );
  };
  Ai.InFullScreen = function({
    children: e
  }) {
    const t = C.useContext(Qb);
    if (!t)
      throw new Error(
        "FullScreen.InFullScreen must be used within a FullScreen component"
      );
    return t.isFullScreen ? /* @__PURE__ */ S.jsx(S.Fragment, { children: e }) : null;
  };
  Ai.OutFullScreen = function({
    children: e
  }) {
    const t = C.useContext(Qb);
    if (!t)
      throw new Error(
        "FullScreen.OutFullScreen must be used within a FullScreen component"
      );
    return t.isFullScreen ? null : /* @__PURE__ */ S.jsx(S.Fragment, { children: e });
  };
  var o_ = { exports: {} }, v5 = { exports: {} }, Ut = {}, y5;
  function SG() {
    if (y5) return Ut;
    y5 = 1;
    var e = typeof Symbol == "function" && Symbol.for, t = e ? /* @__PURE__ */ Symbol.for("react.element") : 60103, n = e ? /* @__PURE__ */ Symbol.for("react.portal") : 60106, r = e ? /* @__PURE__ */ Symbol.for("react.fragment") : 60107, o = e ? /* @__PURE__ */ Symbol.for("react.strict_mode") : 60108, a = e ? /* @__PURE__ */ Symbol.for("react.profiler") : 60114, i = e ? /* @__PURE__ */ Symbol.for("react.provider") : 60109, s = e ? /* @__PURE__ */ Symbol.for("react.context") : 60110, u = e ? /* @__PURE__ */ Symbol.for("react.async_mode") : 60111, c = e ? /* @__PURE__ */ Symbol.for("react.concurrent_mode") : 60111, f = e ? /* @__PURE__ */ Symbol.for("react.forward_ref") : 60112, p = e ? /* @__PURE__ */ Symbol.for("react.suspense") : 60113, g = e ? /* @__PURE__ */ Symbol.for("react.suspense_list") : 60120, h = e ? /* @__PURE__ */ Symbol.for("react.memo") : 60115, y = e ? /* @__PURE__ */ Symbol.for("react.lazy") : 60116, b = e ? /* @__PURE__ */ Symbol.for("react.block") : 60121, v = e ? /* @__PURE__ */ Symbol.for("react.fundamental") : 60117, w = e ? /* @__PURE__ */ Symbol.for("react.responder") : 60118, _ = e ? /* @__PURE__ */ Symbol.for("react.scope") : 60119;
    function k(P) {
      if (typeof P == "object" && P !== null) {
        var O = P.$$typeof;
        switch (O) {
          case t:
            switch (P = P.type, P) {
              case u:
              case c:
              case r:
              case a:
              case o:
              case p:
                return P;
              default:
                switch (P = P && P.$$typeof, P) {
                  case s:
                  case f:
                  case y:
                  case h:
                  case i:
                    return P;
                  default:
                    return O;
                }
            }
          case n:
            return O;
        }
      }
    }
    function E(P) {
      return k(P) === c;
    }
    return Ut.AsyncMode = u, Ut.ConcurrentMode = c, Ut.ContextConsumer = s, Ut.ContextProvider = i, Ut.Element = t, Ut.ForwardRef = f, Ut.Fragment = r, Ut.Lazy = y, Ut.Memo = h, Ut.Portal = n, Ut.Profiler = a, Ut.StrictMode = o, Ut.Suspense = p, Ut.isAsyncMode = function(P) {
      return E(P) || k(P) === u;
    }, Ut.isConcurrentMode = E, Ut.isContextConsumer = function(P) {
      return k(P) === s;
    }, Ut.isContextProvider = function(P) {
      return k(P) === i;
    }, Ut.isElement = function(P) {
      return typeof P == "object" && P !== null && P.$$typeof === t;
    }, Ut.isForwardRef = function(P) {
      return k(P) === f;
    }, Ut.isFragment = function(P) {
      return k(P) === r;
    }, Ut.isLazy = function(P) {
      return k(P) === y;
    }, Ut.isMemo = function(P) {
      return k(P) === h;
    }, Ut.isPortal = function(P) {
      return k(P) === n;
    }, Ut.isProfiler = function(P) {
      return k(P) === a;
    }, Ut.isStrictMode = function(P) {
      return k(P) === o;
    }, Ut.isSuspense = function(P) {
      return k(P) === p;
    }, Ut.isValidElementType = function(P) {
      return typeof P == "string" || typeof P == "function" || P === r || P === c || P === a || P === o || P === p || P === g || typeof P == "object" && P !== null && (P.$$typeof === y || P.$$typeof === h || P.$$typeof === i || P.$$typeof === s || P.$$typeof === f || P.$$typeof === v || P.$$typeof === w || P.$$typeof === _ || P.$$typeof === b);
    }, Ut.typeOf = k, Ut;
  }
  var b5;
  function _G() {
    return b5 || (b5 = 1, v5.exports = SG()), v5.exports;
  }
  var a_, w5;
  function EG() {
    if (w5) return a_;
    w5 = 1;
    var e = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
    return a_ = e, a_;
  }
  var i_, x5;
  function CG() {
    if (x5) return i_;
    x5 = 1;
    var e = /* @__PURE__ */ EG();
    function t() {
    }
    function n() {
    }
    return n.resetWarningCache = t, i_ = function() {
      function r(i, s, u, c, f, p) {
        if (p !== e) {
          var g = new Error(
            "Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types"
          );
          throw g.name = "Invariant Violation", g;
        }
      }
      r.isRequired = r;
      function o() {
        return r;
      }
      var a = {
        array: r,
        bigint: r,
        bool: r,
        func: r,
        number: r,
        object: r,
        string: r,
        symbol: r,
        any: r,
        arrayOf: o,
        element: r,
        elementType: r,
        instanceOf: o,
        node: r,
        objectOf: o,
        oneOf: o,
        oneOfType: o,
        shape: o,
        exact: o,
        checkPropTypes: n,
        resetWarningCache: t
      };
      return a.PropTypes = a, a;
    }, i_;
  }
  var k5;
  function PG() {
    return k5 || (k5 = 1, o_.exports = /* @__PURE__ */ CG()()), o_.exports;
  }
  var Bn = /* @__PURE__ */ PG();
  const Jc = /* @__PURE__ */ Qi(Bn);
  function eT(e) {
    var t, n, r = "";
    if (typeof e == "string" || typeof e == "number") r += e;
    else if (typeof e == "object") if (Array.isArray(e)) {
      var o = e.length;
      for (t = 0; t < o; t++) e[t] && (n = eT(e[t])) && (r && (r += " "), r += n);
    } else for (n in e) e[n] && (r && (r += " "), r += n);
    return r;
  }
  function Le() {
    for (var e, t, n = 0, r = "", o = arguments.length; n < o; n++) (e = arguments[n]) && (t = eT(e)) && (r && (r += " "), r += t);
    return r;
  }
  function nt(e, t, n = void 0) {
    const r = {};
    for (const o in e) {
      const a = e[o];
      let i = "", s = !0;
      for (let u = 0; u < a.length; u += 1) {
        const c = a[u];
        c && (i += (s === !0 ? "" : " ") + t(c), s = !1, n && n[c] && (i += " " + n[c]));
      }
      r[o] = i;
    }
    return r;
  }
  const tT = /* @__PURE__ */ C.createContext();
  function Vi(e, ...t) {
    const n = new URL(`https://mui.com/production-error/?code=${e}`);
    return t.forEach((r) => n.searchParams.append("args[]", r)), `Minified MUI error #${e}; visit ${n} for the full message.`;
  }
  function $e(e) {
    if (typeof e != "string")
      throw new Error(Vi(7));
    return e.charAt(0).toUpperCase() + e.slice(1);
  }
  var S5 = { exports: {} }, nn = {}, _5;
  function OG() {
    if (_5) return nn;
    _5 = 1;
    var e = /* @__PURE__ */ Symbol.for("react.transitional.element"), t = /* @__PURE__ */ Symbol.for("react.portal"), n = /* @__PURE__ */ Symbol.for("react.fragment"), r = /* @__PURE__ */ Symbol.for("react.strict_mode"), o = /* @__PURE__ */ Symbol.for("react.profiler"), a = /* @__PURE__ */ Symbol.for("react.consumer"), i = /* @__PURE__ */ Symbol.for("react.context"), s = /* @__PURE__ */ Symbol.for("react.forward_ref"), u = /* @__PURE__ */ Symbol.for("react.suspense"), c = /* @__PURE__ */ Symbol.for("react.suspense_list"), f = /* @__PURE__ */ Symbol.for("react.memo"), p = /* @__PURE__ */ Symbol.for("react.lazy"), g = /* @__PURE__ */ Symbol.for("react.view_transition"), h = /* @__PURE__ */ Symbol.for("react.client.reference");
    function y(b) {
      if (typeof b == "object" && b !== null) {
        var v = b.$$typeof;
        switch (v) {
          case e:
            switch (b = b.type, b) {
              case n:
              case o:
              case r:
              case u:
              case c:
              case g:
                return b;
              default:
                switch (b = b && b.$$typeof, b) {
                  case i:
                  case s:
                  case p:
                  case f:
                    return b;
                  case a:
                    return b;
                  default:
                    return v;
                }
            }
          case t:
            return v;
        }
      }
    }
    return nn.ContextConsumer = a, nn.ContextProvider = i, nn.Element = e, nn.ForwardRef = s, nn.Fragment = n, nn.Lazy = p, nn.Memo = f, nn.Portal = t, nn.Profiler = o, nn.StrictMode = r, nn.Suspense = u, nn.SuspenseList = c, nn.isContextConsumer = function(b) {
      return y(b) === a;
    }, nn.isContextProvider = function(b) {
      return y(b) === i;
    }, nn.isElement = function(b) {
      return typeof b == "object" && b !== null && b.$$typeof === e;
    }, nn.isForwardRef = function(b) {
      return y(b) === s;
    }, nn.isFragment = function(b) {
      return y(b) === n;
    }, nn.isLazy = function(b) {
      return y(b) === p;
    }, nn.isMemo = function(b) {
      return y(b) === f;
    }, nn.isPortal = function(b) {
      return y(b) === t;
    }, nn.isProfiler = function(b) {
      return y(b) === o;
    }, nn.isStrictMode = function(b) {
      return y(b) === r;
    }, nn.isSuspense = function(b) {
      return y(b) === u;
    }, nn.isSuspenseList = function(b) {
      return y(b) === c;
    }, nn.isValidElementType = function(b) {
      return typeof b == "string" || typeof b == "function" || b === n || b === o || b === r || b === u || b === c || typeof b == "object" && b !== null && (b.$$typeof === p || b.$$typeof === f || b.$$typeof === i || b.$$typeof === a || b.$$typeof === s || b.$$typeof === h || b.getModuleId !== void 0);
    }, nn.typeOf = y, nn;
  }
  var E5;
  function NG() {
    return E5 || (E5 = 1, S5.exports = /* @__PURE__ */ OG()), S5.exports;
  }
  var nT = /* @__PURE__ */ NG();
  function Na(e) {
    if (typeof e != "object" || e === null)
      return !1;
    const t = Object.getPrototypeOf(e);
    return (t === null || t === Object.prototype || Object.getPrototypeOf(t) === null) && !(Symbol.toStringTag in e) && !(Symbol.iterator in e);
  }
  function rT(e) {
    if (/* @__PURE__ */ C.isValidElement(e) || nT.isValidElementType(e) || !Na(e))
      return e;
    const t = {};
    return Object.keys(e).forEach((n) => {
      t[n] = rT(e[n]);
    }), t;
  }
  function wr(e, t, n = {
    clone: !0
  }) {
    const r = n.clone ? {
      ...e
    } : e;
    return Na(e) && Na(t) && Object.keys(t).forEach((o) => {
      /* @__PURE__ */ C.isValidElement(t[o]) || nT.isValidElementType(t[o]) ? r[o] = t[o] : Na(t[o]) && // Avoid prototype pollution
      Object.prototype.hasOwnProperty.call(e, o) && Na(e[o]) ? r[o] = wr(e[o], t[o], n) : n.clone ? r[o] = Na(t[o]) ? rT(t[o]) : t[o] : r[o] = t[o];
    }), r;
  }
  function Pp(e, t) {
    return t ? wr(e, t, {
      clone: !1
      // No need to clone deep, it's way faster.
    }) : e;
  }
  function C5(e, t) {
    if (!e.containerQueries)
      return t;
    const n = Object.keys(t).filter((r) => r.startsWith("@container")).sort((r, o) => {
      const a = /min-width:\s*([0-9.]+)/;
      return +(r.match(a)?.[1] || 0) - +(o.match(a)?.[1] || 0);
    });
    return n.length ? n.reduce((r, o) => {
      const a = t[o];
      return delete r[o], r[o] = a, r;
    }, {
      ...t
    }) : t;
  }
  function MG(e, t) {
    return t === "@" || t.startsWith("@") && (e.some((n) => t.startsWith(`@${n}`)) || !!t.match(/^@\d/));
  }
  function RG(e, t) {
    const n = t.match(/^@([^/]+)?\/?(.+)?$/);
    if (!n)
      return null;
    const [, r, o] = n, a = Number.isNaN(+r) ? r || 0 : +r;
    return e.containerQueries(o).up(a);
  }
  function jG(e) {
    const t = (a, i) => a.replace("@media", i ? `@container ${i}` : "@container");
    function n(a, i) {
      a.up = (...s) => t(e.breakpoints.up(...s), i), a.down = (...s) => t(e.breakpoints.down(...s), i), a.between = (...s) => t(e.breakpoints.between(...s), i), a.only = (...s) => t(e.breakpoints.only(...s), i), a.not = (...s) => {
        const u = t(e.breakpoints.not(...s), i);
        return u.includes("not all and") ? u.replace("not all and ", "").replace("min-width:", "width<").replace("max-width:", "width>").replace("and", "or") : u;
      };
    }
    const r = {}, o = (a) => (n(r, a), r);
    return n(o), {
      ...e,
      containerQueries: o
    };
  }
  const Zb = {
    xs: 0,
    // phone
    sm: 600,
    // tablet
    md: 900,
    // small laptop
    lg: 1200,
    // desktop
    xl: 1536
    // large screen
  }, P5 = {
    // Sorted ASC by size. That's important.
    // It can't be configured as it's used statically for propTypes.
    keys: ["xs", "sm", "md", "lg", "xl"],
    up: (e) => `@media (min-width:${Zb[e]}px)`
  }, IG = {
    containerQueries: (e) => ({
      up: (t) => {
        let n = typeof t == "number" ? t : Zb[t] || t;
        return typeof n == "number" && (n = `${n}px`), e ? `@container ${e} (min-width:${n})` : `@container (min-width:${n})`;
      }
    })
  };
  function Ui(e, t, n) {
    const r = e.theme || {};
    if (Array.isArray(t)) {
      const o = r.breakpoints || P5;
      return t.reduce((a, i, s) => (a[o.up(o.keys[s])] = n(t[s]), a), {});
    }
    if (typeof t == "object") {
      const o = r.breakpoints || P5;
      return Object.keys(t).reduce((a, i) => {
        if (MG(o.keys, i)) {
          const s = RG(r.containerQueries ? r : IG, i);
          s && (a[s] = n(t[i], i));
        } else if (Object.keys(o.values || Zb).includes(i)) {
          const s = o.up(i);
          a[s] = n(t[i], i);
        } else {
          const s = i;
          a[s] = t[s];
        }
        return a;
      }, {});
    }
    return n(t);
  }
  function AG(e = {}) {
    return e.keys?.reduce((t, n) => {
      const r = e.up(n);
      return t[r] = {}, t;
    }, {}) || {};
  }
  function O5(e, t) {
    return e.reduce((n, r) => {
      const o = n[r];
      return (!o || Object.keys(o).length === 0) && delete n[r], n;
    }, t);
  }
  function ew(e, t, n = !0) {
    if (!t || typeof t != "string")
      return null;
    if (e && e.vars && n) {
      const r = `vars.${t}`.split(".").reduce((o, a) => o && o[a] ? o[a] : null, e);
      if (r != null)
        return r;
    }
    return t.split(".").reduce((r, o) => r && r[o] != null ? r[o] : null, e);
  }
  function Yy(e, t, n, r = n) {
    let o;
    return typeof e == "function" ? o = e(n) : Array.isArray(e) ? o = e[n] || r : o = ew(e, n) || r, t && (o = t(o, r, e)), o;
  }
  function An(e) {
    const {
      prop: t,
      cssProperty: n = e.prop,
      themeKey: r,
      transform: o
    } = e, a = (i) => {
      if (i[t] == null)
        return null;
      const s = i[t], u = i.theme, c = ew(u, r) || {};
      return Ui(i, s, (f) => {
        let p = Yy(c, o, f);
        return f === p && typeof f == "string" && (p = Yy(c, o, `${t}${f === "default" ? "" : $e(f)}`, f)), n === !1 ? p : {
          [n]: p
        };
      });
    };
    return a.propTypes = {}, a.filterProps = [t], a;
  }
  function $G(e) {
    const t = {};
    return (n) => (t[n] === void 0 && (t[n] = e(n)), t[n]);
  }
  const DG = {
    m: "margin",
    p: "padding"
  }, LG = {
    t: "Top",
    r: "Right",
    b: "Bottom",
    l: "Left",
    x: ["Left", "Right"],
    y: ["Top", "Bottom"]
  }, N5 = {
    marginX: "mx",
    marginY: "my",
    paddingX: "px",
    paddingY: "py"
  }, FG = $G((e) => {
    if (e.length > 2)
      if (N5[e])
        e = N5[e];
      else
        return [e];
    const [t, n] = e.split(""), r = DG[t], o = LG[n] || "";
    return Array.isArray(o) ? o.map((a) => r + a) : [r + o];
  }), qE = ["m", "mt", "mr", "mb", "ml", "mx", "my", "margin", "marginTop", "marginRight", "marginBottom", "marginLeft", "marginX", "marginY", "marginInline", "marginInlineStart", "marginInlineEnd", "marginBlock", "marginBlockStart", "marginBlockEnd"], KE = ["p", "pt", "pr", "pb", "pl", "px", "py", "padding", "paddingTop", "paddingRight", "paddingBottom", "paddingLeft", "paddingX", "paddingY", "paddingInline", "paddingInlineStart", "paddingInlineEnd", "paddingBlock", "paddingBlockStart", "paddingBlockEnd"];
  [...qE, ...KE];
  function jm(e, t, n, r) {
    const o = ew(e, t, !0) ?? n;
    return typeof o == "number" || typeof o == "string" ? (a) => typeof a == "string" ? a : typeof o == "string" ? o.startsWith("var(") && a === 0 ? 0 : o.startsWith("var(") && a === 1 ? o : `calc(${a} * ${o})` : o * a : Array.isArray(o) ? (a) => {
      if (typeof a == "string")
        return a;
      const i = Math.abs(a), s = o[i];
      return a >= 0 ? s : typeof s == "number" ? -s : typeof s == "string" && s.startsWith("var(") ? `calc(-1 * ${s})` : `-${s}`;
    } : typeof o == "function" ? o : (() => {
    });
  }
  function GE(e) {
    return jm(e, "spacing", 8);
  }
  function Im(e, t) {
    return typeof t == "string" || t == null ? t : e(t);
  }
  function TG(e, t) {
    return (n) => e.reduce((r, o) => (r[o] = Im(t, n), r), {});
  }
  function zG(e, t, n, r) {
    if (!t.includes(n))
      return null;
    const o = FG(n), a = TG(o, r), i = e[n];
    return Ui(e, i, a);
  }
  function oT(e, t) {
    const n = GE(e.theme);
    return Object.keys(e).map((r) => zG(e, t, r, n)).reduce(Pp, {});
  }
  function Pn(e) {
    return oT(e, qE);
  }
  Pn.propTypes = {};
  Pn.filterProps = qE;
  function On(e) {
    return oT(e, KE);
  }
  On.propTypes = {};
  On.filterProps = KE;
  function tw(...e) {
    const t = e.reduce((r, o) => (o.filterProps.forEach((a) => {
      r[a] = o;
    }), r), {}), n = (r) => Object.keys(r).reduce((o, a) => t[a] ? Pp(o, t[a](r)) : o, {});
    return n.propTypes = {}, n.filterProps = e.reduce((r, o) => r.concat(o.filterProps), []), n;
  }
  function Po(e) {
    return typeof e != "number" ? e : `${e}px solid`;
  }
  function Lo(e, t) {
    return An({
      prop: e,
      themeKey: "borders",
      transform: t
    });
  }
  const BG = Lo("border", Po), VG = Lo("borderTop", Po), UG = Lo("borderRight", Po), HG = Lo("borderBottom", Po), WG = Lo("borderLeft", Po), qG = Lo("borderColor"), KG = Lo("borderTopColor"), GG = Lo("borderRightColor"), XG = Lo("borderBottomColor"), YG = Lo("borderLeftColor"), JG = Lo("outline", Po), QG = Lo("outlineColor"), nw = (e) => {
    if (e.borderRadius !== void 0 && e.borderRadius !== null) {
      const t = jm(e.theme, "shape.borderRadius", 4), n = (r) => ({
        borderRadius: Im(t, r)
      });
      return Ui(e, e.borderRadius, n);
    }
    return null;
  };
  nw.propTypes = {};
  nw.filterProps = ["borderRadius"];
  tw(BG, VG, UG, HG, WG, qG, KG, GG, XG, YG, nw, JG, QG);
  const rw = (e) => {
    if (e.gap !== void 0 && e.gap !== null) {
      const t = jm(e.theme, "spacing", 8), n = (r) => ({
        gap: Im(t, r)
      });
      return Ui(e, e.gap, n);
    }
    return null;
  };
  rw.propTypes = {};
  rw.filterProps = ["gap"];
  const ow = (e) => {
    if (e.columnGap !== void 0 && e.columnGap !== null) {
      const t = jm(e.theme, "spacing", 8), n = (r) => ({
        columnGap: Im(t, r)
      });
      return Ui(e, e.columnGap, n);
    }
    return null;
  };
  ow.propTypes = {};
  ow.filterProps = ["columnGap"];
  const aw = (e) => {
    if (e.rowGap !== void 0 && e.rowGap !== null) {
      const t = jm(e.theme, "spacing", 8), n = (r) => ({
        rowGap: Im(t, r)
      });
      return Ui(e, e.rowGap, n);
    }
    return null;
  };
  aw.propTypes = {};
  aw.filterProps = ["rowGap"];
  const ZG = An({
    prop: "gridColumn"
  }), eX = An({
    prop: "gridRow"
  }), tX = An({
    prop: "gridAutoFlow"
  }), nX = An({
    prop: "gridAutoColumns"
  }), rX = An({
    prop: "gridAutoRows"
  }), oX = An({
    prop: "gridTemplateColumns"
  }), aX = An({
    prop: "gridTemplateRows"
  }), iX = An({
    prop: "gridTemplateAreas"
  }), sX = An({
    prop: "gridArea"
  });
  tw(rw, ow, aw, ZG, eX, tX, nX, rX, oX, aX, iX, sX);
  function Qc(e, t) {
    return t === "grey" ? t : e;
  }
  const lX = An({
    prop: "color",
    themeKey: "palette",
    transform: Qc
  }), uX = An({
    prop: "bgcolor",
    cssProperty: "backgroundColor",
    themeKey: "palette",
    transform: Qc
  }), cX = An({
    prop: "backgroundColor",
    themeKey: "palette",
    transform: Qc
  });
  tw(lX, uX, cX);
  function ao(e) {
    return e <= 1 && e !== 0 ? `${e * 100}%` : e;
  }
  const dX = An({
    prop: "width",
    transform: ao
  }), XE = (e) => {
    if (e.maxWidth !== void 0 && e.maxWidth !== null) {
      const t = (n) => {
        const r = e.theme?.breakpoints?.values?.[n] || Zb[n];
        return r ? e.theme?.breakpoints?.unit !== "px" ? {
          maxWidth: `${r}${e.theme.breakpoints.unit}`
        } : {
          maxWidth: r
        } : {
          maxWidth: ao(n)
        };
      };
      return Ui(e, e.maxWidth, t);
    }
    return null;
  };
  XE.filterProps = ["maxWidth"];
  const fX = An({
    prop: "minWidth",
    transform: ao
  }), pX = An({
    prop: "height",
    transform: ao
  }), mX = An({
    prop: "maxHeight",
    transform: ao
  }), hX = An({
    prop: "minHeight",
    transform: ao
  });
  An({
    prop: "size",
    cssProperty: "width",
    transform: ao
  });
  An({
    prop: "size",
    cssProperty: "height",
    transform: ao
  });
  const gX = An({
    prop: "boxSizing"
  });
  tw(dX, XE, fX, pX, mX, hX, gX);
  const Am = {
    // borders
    border: {
      themeKey: "borders",
      transform: Po
    },
    borderTop: {
      themeKey: "borders",
      transform: Po
    },
    borderRight: {
      themeKey: "borders",
      transform: Po
    },
    borderBottom: {
      themeKey: "borders",
      transform: Po
    },
    borderLeft: {
      themeKey: "borders",
      transform: Po
    },
    borderColor: {
      themeKey: "palette"
    },
    borderTopColor: {
      themeKey: "palette"
    },
    borderRightColor: {
      themeKey: "palette"
    },
    borderBottomColor: {
      themeKey: "palette"
    },
    borderLeftColor: {
      themeKey: "palette"
    },
    outline: {
      themeKey: "borders",
      transform: Po
    },
    outlineColor: {
      themeKey: "palette"
    },
    borderRadius: {
      themeKey: "shape.borderRadius",
      style: nw
    },
    // palette
    color: {
      themeKey: "palette",
      transform: Qc
    },
    bgcolor: {
      themeKey: "palette",
      cssProperty: "backgroundColor",
      transform: Qc
    },
    backgroundColor: {
      themeKey: "palette",
      transform: Qc
    },
    // spacing
    p: {
      style: On
    },
    pt: {
      style: On
    },
    pr: {
      style: On
    },
    pb: {
      style: On
    },
    pl: {
      style: On
    },
    px: {
      style: On
    },
    py: {
      style: On
    },
    padding: {
      style: On
    },
    paddingTop: {
      style: On
    },
    paddingRight: {
      style: On
    },
    paddingBottom: {
      style: On
    },
    paddingLeft: {
      style: On
    },
    paddingX: {
      style: On
    },
    paddingY: {
      style: On
    },
    paddingInline: {
      style: On
    },
    paddingInlineStart: {
      style: On
    },
    paddingInlineEnd: {
      style: On
    },
    paddingBlock: {
      style: On
    },
    paddingBlockStart: {
      style: On
    },
    paddingBlockEnd: {
      style: On
    },
    m: {
      style: Pn
    },
    mt: {
      style: Pn
    },
    mr: {
      style: Pn
    },
    mb: {
      style: Pn
    },
    ml: {
      style: Pn
    },
    mx: {
      style: Pn
    },
    my: {
      style: Pn
    },
    margin: {
      style: Pn
    },
    marginTop: {
      style: Pn
    },
    marginRight: {
      style: Pn
    },
    marginBottom: {
      style: Pn
    },
    marginLeft: {
      style: Pn
    },
    marginX: {
      style: Pn
    },
    marginY: {
      style: Pn
    },
    marginInline: {
      style: Pn
    },
    marginInlineStart: {
      style: Pn
    },
    marginInlineEnd: {
      style: Pn
    },
    marginBlock: {
      style: Pn
    },
    marginBlockStart: {
      style: Pn
    },
    marginBlockEnd: {
      style: Pn
    },
    // display
    displayPrint: {
      cssProperty: !1,
      transform: (e) => ({
        "@media print": {
          display: e
        }
      })
    },
    display: {},
    overflow: {},
    textOverflow: {},
    visibility: {},
    whiteSpace: {},
    // flexbox
    flexBasis: {},
    flexDirection: {},
    flexWrap: {},
    justifyContent: {},
    alignItems: {},
    alignContent: {},
    order: {},
    flex: {},
    flexGrow: {},
    flexShrink: {},
    alignSelf: {},
    justifyItems: {},
    justifySelf: {},
    // grid
    gap: {
      style: rw
    },
    rowGap: {
      style: aw
    },
    columnGap: {
      style: ow
    },
    gridColumn: {},
    gridRow: {},
    gridAutoFlow: {},
    gridAutoColumns: {},
    gridAutoRows: {},
    gridTemplateColumns: {},
    gridTemplateRows: {},
    gridTemplateAreas: {},
    gridArea: {},
    // positions
    position: {},
    zIndex: {
      themeKey: "zIndex"
    },
    top: {},
    right: {},
    bottom: {},
    left: {},
    // shadows
    boxShadow: {
      themeKey: "shadows"
    },
    // sizing
    width: {
      transform: ao
    },
    maxWidth: {
      style: XE
    },
    minWidth: {
      transform: ao
    },
    height: {
      transform: ao
    },
    maxHeight: {
      transform: ao
    },
    minHeight: {
      transform: ao
    },
    boxSizing: {},
    // typography
    font: {
      themeKey: "font"
    },
    fontFamily: {
      themeKey: "typography"
    },
    fontSize: {
      themeKey: "typography"
    },
    fontStyle: {
      themeKey: "typography"
    },
    fontWeight: {
      themeKey: "typography"
    },
    letterSpacing: {},
    textTransform: {},
    lineHeight: {},
    textAlign: {},
    typography: {
      cssProperty: !1,
      themeKey: "typography"
    }
  };
  function vX(...e) {
    const t = e.reduce((r, o) => r.concat(Object.keys(o)), []), n = new Set(t);
    return e.every((r) => n.size === Object.keys(r).length);
  }
  function yX(e, t) {
    return typeof e == "function" ? e(t) : e;
  }
  function bX() {
    function e(n, r, o, a) {
      const i = {
        [n]: r,
        theme: o
      }, s = a[n];
      if (!s)
        return {
          [n]: r
        };
      const {
        cssProperty: u = n,
        themeKey: c,
        transform: f,
        style: p
      } = s;
      if (r == null)
        return null;
      if (c === "typography" && r === "inherit")
        return {
          [n]: r
        };
      const g = ew(o, c) || {};
      return p ? p(i) : Ui(i, r, (h) => {
        let y = Yy(g, f, h);
        return h === y && typeof h == "string" && (y = Yy(g, f, `${n}${h === "default" ? "" : $e(h)}`, h)), u === !1 ? y : {
          [u]: y
        };
      });
    }
    function t(n) {
      const {
        sx: r,
        theme: o = {},
        nested: a
      } = n || {};
      if (!r)
        return null;
      const i = o.unstable_sxConfig ?? Am;
      function s(u) {
        let c = u;
        if (typeof u == "function")
          c = u(o);
        else if (typeof u != "object")
          return u;
        if (!c)
          return null;
        const f = AG(o.breakpoints), p = Object.keys(f);
        let g = f;
        return Object.keys(c).forEach((h) => {
          const y = yX(c[h], o);
          if (y != null)
            if (typeof y == "object")
              if (i[h])
                g = Pp(g, e(h, y, o, i));
              else {
                const b = Ui({
                  theme: o
                }, y, (v) => ({
                  [h]: v
                }));
                vX(b, y) ? g[h] = t({
                  sx: y,
                  theme: o,
                  nested: !0
                }) : g = Pp(g, b);
              }
            else
              g = Pp(g, e(h, y, o, i));
        }), !a && o.modularCssLayers ? {
          "@layer sx": C5(o, O5(p, g))
        } : C5(o, O5(p, g));
      }
      return Array.isArray(r) ? r.map(s) : s(r);
    }
    return t;
  }
  const nl = bX();
  nl.filterProps = ["sx"];
  const wX = (e) => {
    const t = {
      systemProps: {},
      otherProps: {}
    }, n = e?.theme?.unstable_sxConfig ?? Am;
    return Object.keys(e).forEach((r) => {
      n[r] ? t.systemProps[r] = e[r] : t.otherProps[r] = e[r];
    }), t;
  };
  function YE(e) {
    const {
      sx: t,
      ...n
    } = e, {
      systemProps: r,
      otherProps: o
    } = wX(n);
    let a;
    return Array.isArray(t) ? a = [r, ...t] : typeof t == "function" ? a = (...i) => {
      const s = t(...i);
      return Na(s) ? {
        ...r,
        ...s
      } : r;
    } : a = {
      ...r,
      ...t
    }, {
      ...o,
      sx: a
    };
  }
  function Ge() {
    return Ge = Object.assign ? Object.assign.bind() : function(e) {
      for (var t = 1; t < arguments.length; t++) {
        var n = arguments[t];
        for (var r in n) ({}).hasOwnProperty.call(n, r) && (e[r] = n[r]);
      }
      return e;
    }, Ge.apply(null, arguments);
  }
  function xX(e) {
    if (e.sheet)
      return e.sheet;
    for (var t = 0; t < document.styleSheets.length; t++)
      if (document.styleSheets[t].ownerNode === e)
        return document.styleSheets[t];
  }
  function kX(e) {
    var t = document.createElement("style");
    return t.setAttribute("data-emotion", e.key), e.nonce !== void 0 && t.setAttribute("nonce", e.nonce), t.appendChild(document.createTextNode("")), t.setAttribute("data-s", ""), t;
  }
  var SX = /* @__PURE__ */ (function() {
    function e(n) {
      var r = this;
      this._insertTag = function(o) {
        var a;
        r.tags.length === 0 ? r.insertionPoint ? a = r.insertionPoint.nextSibling : r.prepend ? a = r.container.firstChild : a = r.before : a = r.tags[r.tags.length - 1].nextSibling, r.container.insertBefore(o, a), r.tags.push(o);
      }, this.isSpeedy = n.speedy === void 0 ? !0 : n.speedy, this.tags = [], this.ctr = 0, this.nonce = n.nonce, this.key = n.key, this.container = n.container, this.prepend = n.prepend, this.insertionPoint = n.insertionPoint, this.before = null;
    }
    var t = e.prototype;
    return t.hydrate = function(n) {
      n.forEach(this._insertTag);
    }, t.insert = function(n) {
      this.ctr % (this.isSpeedy ? 65e3 : 1) === 0 && this._insertTag(kX(this));
      var r = this.tags[this.tags.length - 1];
      if (this.isSpeedy) {
        var o = xX(r);
        try {
          o.insertRule(n, o.cssRules.length);
        } catch {
        }
      } else
        r.appendChild(document.createTextNode(n));
      this.ctr++;
    }, t.flush = function() {
      this.tags.forEach(function(n) {
        var r;
        return (r = n.parentNode) == null ? void 0 : r.removeChild(n);
      }), this.tags = [], this.ctr = 0;
    }, e;
  })(), hr = "-ms-", Jy = "-moz-", zt = "-webkit-", aT = "comm", JE = "rule", QE = "decl", _X = "@import", iT = "@keyframes", EX = "@layer", CX = Math.abs, iw = String.fromCharCode, PX = Object.assign;
  function OX(e, t) {
    return ur(e, 0) ^ 45 ? (((t << 2 ^ ur(e, 0)) << 2 ^ ur(e, 1)) << 2 ^ ur(e, 2)) << 2 ^ ur(e, 3) : 0;
  }
  function sT(e) {
    return e.trim();
  }
  function NX(e, t) {
    return (e = t.exec(e)) ? e[0] : e;
  }
  function Bt(e, t, n) {
    return e.replace(t, n);
  }
  function Z0(e, t) {
    return e.indexOf(t);
  }
  function ur(e, t) {
    return e.charCodeAt(t) | 0;
  }
  function Kp(e, t, n) {
    return e.slice(t, n);
  }
  function Ea(e) {
    return e.length;
  }
  function ZE(e) {
    return e.length;
  }
  function Gg(e, t) {
    return t.push(e), e;
  }
  function MX(e, t) {
    return e.map(t).join("");
  }
  var sw = 1, dd = 1, lT = 0, Hr = 0, Un = 0, Id = "";
  function lw(e, t, n, r, o, a, i) {
    return { value: e, root: t, parent: n, type: r, props: o, children: a, line: sw, column: dd, length: i, return: "" };
  }
  function qf(e, t) {
    return PX(lw("", null, null, "", null, null, 0), e, { length: -e.length }, t);
  }
  function RX() {
    return Un;
  }
  function jX() {
    return Un = Hr > 0 ? ur(Id, --Hr) : 0, dd--, Un === 10 && (dd = 1, sw--), Un;
  }
  function uo() {
    return Un = Hr < lT ? ur(Id, Hr++) : 0, dd++, Un === 10 && (dd = 1, sw++), Un;
  }
  function Ta() {
    return ur(Id, Hr);
  }
  function ky() {
    return Hr;
  }
  function $m(e, t) {
    return Kp(Id, e, t);
  }
  function Gp(e) {
    switch (e) {
      // \0 \t \n \r \s whitespace token
      case 0:
      case 9:
      case 10:
      case 13:
      case 32:
        return 5;
      // ! + , / > @ ~ isolate token
      case 33:
      case 43:
      case 44:
      case 47:
      case 62:
      case 64:
      case 126:
      // ; { } breakpoint token
      case 59:
      case 123:
      case 125:
        return 4;
      // : accompanied token
      case 58:
        return 3;
      // " ' ( [ opening delimit token
      case 34:
      case 39:
      case 40:
      case 91:
        return 2;
      // ) ] closing delimit token
      case 41:
      case 93:
        return 1;
    }
    return 0;
  }
  function uT(e) {
    return sw = dd = 1, lT = Ea(Id = e), Hr = 0, [];
  }
  function cT(e) {
    return Id = "", e;
  }
  function Sy(e) {
    return sT($m(Hr - 1, e2(e === 91 ? e + 2 : e === 40 ? e + 1 : e)));
  }
  function IX(e) {
    for (; (Un = Ta()) && Un < 33; )
      uo();
    return Gp(e) > 2 || Gp(Un) > 3 ? "" : " ";
  }
  function AX(e, t) {
    for (; --t && uo() && !(Un < 48 || Un > 102 || Un > 57 && Un < 65 || Un > 70 && Un < 97); )
      ;
    return $m(e, ky() + (t < 6 && Ta() == 32 && uo() == 32));
  }
  function e2(e) {
    for (; uo(); )
      switch (Un) {
        // ] ) " '
        case e:
          return Hr;
        // " '
        case 34:
        case 39:
          e !== 34 && e !== 39 && e2(Un);
          break;
        // (
        case 40:
          e === 41 && e2(e);
          break;
        // \
        case 92:
          uo();
          break;
      }
    return Hr;
  }
  function $X(e, t) {
    for (; uo() && e + Un !== 57 && !(e + Un === 84 && Ta() === 47); )
      ;
    return "/*" + $m(t, Hr - 1) + "*" + iw(e === 47 ? e : uo());
  }
  function DX(e) {
    for (; !Gp(Ta()); )
      uo();
    return $m(e, Hr);
  }
  function LX(e) {
    return cT(_y("", null, null, null, [""], e = uT(e), 0, [0], e));
  }
  function _y(e, t, n, r, o, a, i, s, u) {
    for (var c = 0, f = 0, p = i, g = 0, h = 0, y = 0, b = 1, v = 1, w = 1, _ = 0, k = "", E = o, P = a, O = r, M = k; v; )
      switch (y = _, _ = uo()) {
        // (
        case 40:
          if (y != 108 && ur(M, p - 1) == 58) {
            Z0(M += Bt(Sy(_), "&", "&\f"), "&\f") != -1 && (w = -1);
            break;
          }
        // " ' [
        case 34:
        case 39:
        case 91:
          M += Sy(_);
          break;
        // \t \n \r \s
        case 9:
        case 10:
        case 13:
        case 32:
          M += IX(y);
          break;
        // \
        case 92:
          M += AX(ky() - 1, 7);
          continue;
        // /
        case 47:
          switch (Ta()) {
            case 42:
            case 47:
              Gg(FX($X(uo(), ky()), t, n), u);
              break;
            default:
              M += "/";
          }
          break;
        // {
        case 123 * b:
          s[c++] = Ea(M) * w;
        // } ; \0
        case 125 * b:
        case 59:
        case 0:
          switch (_) {
            // \0 }
            case 0:
            case 125:
              v = 0;
            // ;
            case 59 + f:
              w == -1 && (M = Bt(M, /\f/g, "")), h > 0 && Ea(M) - p && Gg(h > 32 ? R5(M + ";", r, n, p - 1) : R5(Bt(M, " ", "") + ";", r, n, p - 2), u);
              break;
            // @ ;
            case 59:
              M += ";";
            // { rule/at-rule
            default:
              if (Gg(O = M5(M, t, n, c, f, o, s, k, E = [], P = [], p), a), _ === 123)
                if (f === 0)
                  _y(M, t, O, O, E, a, p, s, P);
                else
                  switch (g === 99 && ur(M, 3) === 110 ? 100 : g) {
                    // d l m s
                    case 100:
                    case 108:
                    case 109:
                    case 115:
                      _y(e, O, O, r && Gg(M5(e, O, O, 0, 0, o, s, k, o, E = [], p), P), o, P, p, s, r ? E : P);
                      break;
                    default:
                      _y(M, O, O, O, [""], P, 0, s, P);
                  }
          }
          c = f = h = 0, b = w = 1, k = M = "", p = i;
          break;
        // :
        case 58:
          p = 1 + Ea(M), h = y;
        default:
          if (b < 1) {
            if (_ == 123)
              --b;
            else if (_ == 125 && b++ == 0 && jX() == 125)
              continue;
          }
          switch (M += iw(_), _ * b) {
            // &
            case 38:
              w = f > 0 ? 1 : (M += "\f", -1);
              break;
            // ,
            case 44:
              s[c++] = (Ea(M) - 1) * w, w = 1;
              break;
            // @
            case 64:
              Ta() === 45 && (M += Sy(uo())), g = Ta(), f = p = Ea(k = M += DX(ky())), _++;
              break;
            // -
            case 45:
              y === 45 && Ea(M) == 2 && (b = 0);
          }
      }
    return a;
  }
  function M5(e, t, n, r, o, a, i, s, u, c, f) {
    for (var p = o - 1, g = o === 0 ? a : [""], h = ZE(g), y = 0, b = 0, v = 0; y < r; ++y)
      for (var w = 0, _ = Kp(e, p + 1, p = CX(b = i[y])), k = e; w < h; ++w)
        (k = sT(b > 0 ? g[w] + " " + _ : Bt(_, /&\f/g, g[w]))) && (u[v++] = k);
    return lw(e, t, n, o === 0 ? JE : s, u, c, f);
  }
  function FX(e, t, n) {
    return lw(e, t, n, aT, iw(RX()), Kp(e, 2, -2), 0);
  }
  function R5(e, t, n, r) {
    return lw(e, t, n, QE, Kp(e, 0, r), Kp(e, r + 1, -1), r);
  }
  function Zc(e, t) {
    for (var n = "", r = ZE(e), o = 0; o < r; o++)
      n += t(e[o], o, e, t) || "";
    return n;
  }
  function TX(e, t, n, r) {
    switch (e.type) {
      case EX:
        if (e.children.length) break;
      case _X:
      case QE:
        return e.return = e.return || e.value;
      case aT:
        return "";
      case iT:
        return e.return = e.value + "{" + Zc(e.children, r) + "}";
      case JE:
        e.value = e.props.join(",");
    }
    return Ea(n = Zc(e.children, r)) ? e.return = e.value + "{" + n + "}" : "";
  }
  function zX(e) {
    var t = ZE(e);
    return function(n, r, o, a) {
      for (var i = "", s = 0; s < t; s++)
        i += e[s](n, r, o, a) || "";
      return i;
    };
  }
  function BX(e) {
    return function(t) {
      t.root || (t = t.return) && e(t);
    };
  }
  function dT(e) {
    var t = /* @__PURE__ */ Object.create(null);
    return function(n) {
      return t[n] === void 0 && (t[n] = e(n)), t[n];
    };
  }
  var VX = function(e, t, n) {
    for (var r = 0, o = 0; r = o, o = Ta(), r === 38 && o === 12 && (t[n] = 1), !Gp(o); )
      uo();
    return $m(e, Hr);
  }, UX = function(e, t) {
    var n = -1, r = 44;
    do
      switch (Gp(r)) {
        case 0:
          r === 38 && Ta() === 12 && (t[n] = 1), e[n] += VX(Hr - 1, t, n);
          break;
        case 2:
          e[n] += Sy(r);
          break;
        case 4:
          if (r === 44) {
            e[++n] = Ta() === 58 ? "&\f" : "", t[n] = e[n].length;
            break;
          }
        // fallthrough
        default:
          e[n] += iw(r);
      }
    while (r = uo());
    return e;
  }, HX = function(e, t) {
    return cT(UX(uT(e), t));
  }, j5 = /* @__PURE__ */ new WeakMap(), WX = function(e) {
    if (!(e.type !== "rule" || !e.parent || // positive .length indicates that this rule contains pseudo
    // negative .length indicates that this rule has been already prefixed
    e.length < 1)) {
      for (var t = e.value, n = e.parent, r = e.column === n.column && e.line === n.line; n.type !== "rule"; )
        if (n = n.parent, !n) return;
      if (!(e.props.length === 1 && t.charCodeAt(0) !== 58 && !j5.get(n)) && !r) {
        j5.set(e, !0);
        for (var o = [], a = HX(t, o), i = n.props, s = 0, u = 0; s < a.length; s++)
          for (var c = 0; c < i.length; c++, u++)
            e.props[u] = o[s] ? a[s].replace(/&\f/g, i[c]) : i[c] + " " + a[s];
      }
    }
  }, qX = function(e) {
    if (e.type === "decl") {
      var t = e.value;
      t.charCodeAt(0) === 108 && // charcode for b
      t.charCodeAt(2) === 98 && (e.return = "", e.value = "");
    }
  };
  function fT(e, t) {
    switch (OX(e, t)) {
      // color-adjust
      case 5103:
        return zt + "print-" + e + e;
      // animation, animation-(delay|direction|duration|fill-mode|iteration-count|name|play-state|timing-function)
      case 5737:
      case 4201:
      case 3177:
      case 3433:
      case 1641:
      case 4457:
      case 2921:
      // text-decoration, filter, clip-path, backface-visibility, column, box-decoration-break
      case 5572:
      case 6356:
      case 5844:
      case 3191:
      case 6645:
      case 3005:
      // mask, mask-image, mask-(mode|clip|size), mask-(repeat|origin), mask-position, mask-composite,
      case 6391:
      case 5879:
      case 5623:
      case 6135:
      case 4599:
      case 4855:
      // background-clip, columns, column-(count|fill|gap|rule|rule-color|rule-style|rule-width|span|width)
      case 4215:
      case 6389:
      case 5109:
      case 5365:
      case 5621:
      case 3829:
        return zt + e + e;
      // appearance, user-select, transform, hyphens, text-size-adjust
      case 5349:
      case 4246:
      case 4810:
      case 6968:
      case 2756:
        return zt + e + Jy + e + hr + e + e;
      // flex, flex-direction
      case 6828:
      case 4268:
        return zt + e + hr + e + e;
      // order
      case 6165:
        return zt + e + hr + "flex-" + e + e;
      // align-items
      case 5187:
        return zt + e + Bt(e, /(\w+).+(:[^]+)/, zt + "box-$1$2" + hr + "flex-$1$2") + e;
      // align-self
      case 5443:
        return zt + e + hr + "flex-item-" + Bt(e, /flex-|-self/, "") + e;
      // align-content
      case 4675:
        return zt + e + hr + "flex-line-pack" + Bt(e, /align-content|flex-|-self/, "") + e;
      // flex-shrink
      case 5548:
        return zt + e + hr + Bt(e, "shrink", "negative") + e;
      // flex-basis
      case 5292:
        return zt + e + hr + Bt(e, "basis", "preferred-size") + e;
      // flex-grow
      case 6060:
        return zt + "box-" + Bt(e, "-grow", "") + zt + e + hr + Bt(e, "grow", "positive") + e;
      // transition
      case 4554:
        return zt + Bt(e, /([^-])(transform)/g, "$1" + zt + "$2") + e;
      // cursor
      case 6187:
        return Bt(Bt(Bt(e, /(zoom-|grab)/, zt + "$1"), /(image-set)/, zt + "$1"), e, "") + e;
      // background, background-image
      case 5495:
      case 3959:
        return Bt(e, /(image-set\([^]*)/, zt + "$1$`$1");
      // justify-content
      case 4968:
        return Bt(Bt(e, /(.+:)(flex-)?(.*)/, zt + "box-pack:$3" + hr + "flex-pack:$3"), /s.+-b[^;]+/, "justify") + zt + e + e;
      // (margin|padding)-inline-(start|end)
      case 4095:
      case 3583:
      case 4068:
      case 2532:
        return Bt(e, /(.+)-inline(.+)/, zt + "$1$2") + e;
      // (min|max)?(width|height|inline-size|block-size)
      case 8116:
      case 7059:
      case 5753:
      case 5535:
      case 5445:
      case 5701:
      case 4933:
      case 4677:
      case 5533:
      case 5789:
      case 5021:
      case 4765:
        if (Ea(e) - 1 - t > 6) switch (ur(e, t + 1)) {
          // (m)ax-content, (m)in-content
          case 109:
            if (ur(e, t + 4) !== 45) break;
          // (f)ill-available, (f)it-content
          case 102:
            return Bt(e, /(.+:)(.+)-([^]+)/, "$1" + zt + "$2-$3$1" + Jy + (ur(e, t + 3) == 108 ? "$3" : "$2-$3")) + e;
          // (s)tretch
          case 115:
            return ~Z0(e, "stretch") ? fT(Bt(e, "stretch", "fill-available"), t) + e : e;
        }
        break;
      // position: sticky
      case 4949:
        if (ur(e, t + 1) !== 115) break;
      // display: (flex|inline-flex)
      case 6444:
        switch (ur(e, Ea(e) - 3 - (~Z0(e, "!important") && 10))) {
          // stic(k)y
          case 107:
            return Bt(e, ":", ":" + zt) + e;
          // (inline-)?fl(e)x
          case 101:
            return Bt(e, /(.+:)([^;!]+)(;|!.+)?/, "$1" + zt + (ur(e, 14) === 45 ? "inline-" : "") + "box$3$1" + zt + "$2$3$1" + hr + "$2box$3") + e;
        }
        break;
      // writing-mode
      case 5936:
        switch (ur(e, t + 11)) {
          // vertical-l(r)
          case 114:
            return zt + e + hr + Bt(e, /[svh]\w+-[tblr]{2}/, "tb") + e;
          // vertical-r(l)
          case 108:
            return zt + e + hr + Bt(e, /[svh]\w+-[tblr]{2}/, "tb-rl") + e;
          // horizontal(-)tb
          case 45:
            return zt + e + hr + Bt(e, /[svh]\w+-[tblr]{2}/, "lr") + e;
        }
        return zt + e + hr + e + e;
    }
    return e;
  }
  var KX = function(e, t, n, r) {
    if (e.length > -1 && !e.return) switch (e.type) {
      case QE:
        e.return = fT(e.value, e.length);
        break;
      case iT:
        return Zc([qf(e, {
          value: Bt(e.value, "@", "@" + zt)
        })], r);
      case JE:
        if (e.length) return MX(e.props, function(o) {
          switch (NX(o, /(::plac\w+|:read-\w+)/)) {
            // :read-(only|write)
            case ":read-only":
            case ":read-write":
              return Zc([qf(e, {
                props: [Bt(o, /:(read-\w+)/, ":" + Jy + "$1")]
              })], r);
            // :placeholder
            case "::placeholder":
              return Zc([qf(e, {
                props: [Bt(o, /:(plac\w+)/, ":" + zt + "input-$1")]
              }), qf(e, {
                props: [Bt(o, /:(plac\w+)/, ":" + Jy + "$1")]
              }), qf(e, {
                props: [Bt(o, /:(plac\w+)/, hr + "input-$1")]
              })], r);
          }
          return "";
        });
    }
  }, GX = [KX], XX = function(e) {
    var t = e.key;
    if (t === "css") {
      var n = document.querySelectorAll("style[data-emotion]:not([data-s])");
      Array.prototype.forEach.call(n, function(y) {
        var b = y.getAttribute("data-emotion");
        b.indexOf(" ") !== -1 && (document.head.appendChild(y), y.setAttribute("data-s", ""));
      });
    }
    var r = e.stylisPlugins || GX, o = {}, a, i = [];
    a = e.container || document.head, Array.prototype.forEach.call(
      // this means we will ignore elements which don't have a space in them which
      // means that the style elements we're looking at are only Emotion 11 server-rendered style elements
      document.querySelectorAll('style[data-emotion^="' + t + ' "]'),
      function(y) {
        for (var b = y.getAttribute("data-emotion").split(" "), v = 1; v < b.length; v++)
          o[b[v]] = !0;
        i.push(y);
      }
    );
    var s, u = [WX, qX];
    {
      var c, f = [TX, BX(function(y) {
        c.insert(y);
      })], p = zX(u.concat(r, f)), g = function(y) {
        return Zc(LX(y), p);
      };
      s = function(y, b, v, w) {
        c = v, g(y ? y + "{" + b.styles + "}" : b.styles), w && (h.inserted[b.name] = !0);
      };
    }
    var h = {
      key: t,
      sheet: new SX({
        key: t,
        container: a,
        nonce: e.nonce,
        speedy: e.speedy,
        prepend: e.prepend,
        insertionPoint: e.insertionPoint
      }),
      nonce: e.nonce,
      inserted: o,
      registered: {},
      insert: s
    };
    return h.sheet.hydrate(i), h;
  }, s_, I5;
  function YX() {
    if (I5) return s_;
    I5 = 1;
    var e = _G(), t = {
      childContextTypes: !0,
      contextType: !0,
      contextTypes: !0,
      defaultProps: !0,
      displayName: !0,
      getDefaultProps: !0,
      getDerivedStateFromError: !0,
      getDerivedStateFromProps: !0,
      mixins: !0,
      propTypes: !0,
      type: !0
    }, n = {
      name: !0,
      length: !0,
      prototype: !0,
      caller: !0,
      callee: !0,
      arguments: !0,
      arity: !0
    }, r = {
      $$typeof: !0,
      render: !0,
      defaultProps: !0,
      displayName: !0,
      propTypes: !0
    }, o = {
      $$typeof: !0,
      compare: !0,
      defaultProps: !0,
      displayName: !0,
      propTypes: !0,
      type: !0
    }, a = {};
    a[e.ForwardRef] = r, a[e.Memo] = o;
    function i(y) {
      return e.isMemo(y) ? o : a[y.$$typeof] || t;
    }
    var s = Object.defineProperty, u = Object.getOwnPropertyNames, c = Object.getOwnPropertySymbols, f = Object.getOwnPropertyDescriptor, p = Object.getPrototypeOf, g = Object.prototype;
    function h(y, b, v) {
      if (typeof b != "string") {
        if (g) {
          var w = p(b);
          w && w !== g && h(y, w, v);
        }
        var _ = u(b);
        c && (_ = _.concat(c(b)));
        for (var k = i(y), E = i(b), P = 0; P < _.length; ++P) {
          var O = _[P];
          if (!n[O] && !(v && v[O]) && !(E && E[O]) && !(k && k[O])) {
            var M = f(b, O);
            try {
              s(y, O, M);
            } catch {
            }
          }
        }
      }
      return y;
    }
    return s_ = h, s_;
  }
  YX();
  var JX = !0;
  function pT(e, t, n) {
    var r = "";
    return n.split(" ").forEach(function(o) {
      e[o] !== void 0 ? t.push(e[o] + ";") : o && (r += o + " ");
    }), r;
  }
  var eC = function(e, t, n) {
    var r = e.key + "-" + t.name;
    (n === !1 || // we need to always store it if we're in compat mode and
    // in node since emotion-server relies on whether a style is in
    // the registered cache to know whether a style is global or not
    // also, note that this check will be dead code eliminated in the browser
    JX === !1) && e.registered[r] === void 0 && (e.registered[r] = t.styles);
  }, tC = function(e, t, n) {
    eC(e, t, n);
    var r = e.key + "-" + t.name;
    if (e.inserted[t.name] === void 0) {
      var o = t;
      do
        e.insert(t === o ? "." + r : "", o, e.sheet, !0), o = o.next;
      while (o !== void 0);
    }
  };
  function QX(e) {
    for (var t = 0, n, r = 0, o = e.length; o >= 4; ++r, o -= 4)
      n = e.charCodeAt(r) & 255 | (e.charCodeAt(++r) & 255) << 8 | (e.charCodeAt(++r) & 255) << 16 | (e.charCodeAt(++r) & 255) << 24, n = /* Math.imul(k, m): */
      (n & 65535) * 1540483477 + ((n >>> 16) * 59797 << 16), n ^= /* k >>> r: */
      n >>> 24, t = /* Math.imul(k, m): */
      (n & 65535) * 1540483477 + ((n >>> 16) * 59797 << 16) ^ /* Math.imul(h, m): */
      (t & 65535) * 1540483477 + ((t >>> 16) * 59797 << 16);
    switch (o) {
      case 3:
        t ^= (e.charCodeAt(r + 2) & 255) << 16;
      case 2:
        t ^= (e.charCodeAt(r + 1) & 255) << 8;
      case 1:
        t ^= e.charCodeAt(r) & 255, t = /* Math.imul(h, m): */
        (t & 65535) * 1540483477 + ((t >>> 16) * 59797 << 16);
    }
    return t ^= t >>> 13, t = /* Math.imul(h, m): */
    (t & 65535) * 1540483477 + ((t >>> 16) * 59797 << 16), ((t ^ t >>> 15) >>> 0).toString(36);
  }
  var ZX = {
    animationIterationCount: 1,
    aspectRatio: 1,
    borderImageOutset: 1,
    borderImageSlice: 1,
    borderImageWidth: 1,
    boxFlex: 1,
    boxFlexGroup: 1,
    boxOrdinalGroup: 1,
    columnCount: 1,
    columns: 1,
    flex: 1,
    flexGrow: 1,
    flexPositive: 1,
    flexShrink: 1,
    flexNegative: 1,
    flexOrder: 1,
    gridRow: 1,
    gridRowEnd: 1,
    gridRowSpan: 1,
    gridRowStart: 1,
    gridColumn: 1,
    gridColumnEnd: 1,
    gridColumnSpan: 1,
    gridColumnStart: 1,
    msGridRow: 1,
    msGridRowSpan: 1,
    msGridColumn: 1,
    msGridColumnSpan: 1,
    fontWeight: 1,
    lineHeight: 1,
    opacity: 1,
    order: 1,
    orphans: 1,
    scale: 1,
    tabSize: 1,
    widows: 1,
    zIndex: 1,
    zoom: 1,
    WebkitLineClamp: 1,
    // SVG-related properties
    fillOpacity: 1,
    floodOpacity: 1,
    stopOpacity: 1,
    strokeDasharray: 1,
    strokeDashoffset: 1,
    strokeMiterlimit: 1,
    strokeOpacity: 1,
    strokeWidth: 1
  }, eY = /[A-Z]|^ms/g, tY = /_EMO_([^_]+?)_([^]*?)_EMO_/g, mT = function(e) {
    return e.charCodeAt(1) === 45;
  }, A5 = function(e) {
    return e != null && typeof e != "boolean";
  }, l_ = /* @__PURE__ */ dT(function(e) {
    return mT(e) ? e : e.replace(eY, "-$&").toLowerCase();
  }), $5 = function(e, t) {
    switch (e) {
      case "animation":
      case "animationName":
        if (typeof t == "string")
          return t.replace(tY, function(n, r, o) {
            return Ca = {
              name: r,
              styles: o,
              next: Ca
            }, r;
          });
    }
    return ZX[e] !== 1 && !mT(e) && typeof t == "number" && t !== 0 ? t + "px" : t;
  };
  function Xp(e, t, n) {
    if (n == null)
      return "";
    var r = n;
    if (r.__emotion_styles !== void 0)
      return r;
    switch (typeof n) {
      case "boolean":
        return "";
      case "object": {
        var o = n;
        if (o.anim === 1)
          return Ca = {
            name: o.name,
            styles: o.styles,
            next: Ca
          }, o.name;
        var a = n;
        if (a.styles !== void 0) {
          var i = a.next;
          if (i !== void 0)
            for (; i !== void 0; )
              Ca = {
                name: i.name,
                styles: i.styles,
                next: Ca
              }, i = i.next;
          var s = a.styles + ";";
          return s;
        }
        return nY(e, t, n);
      }
      case "function": {
        if (e !== void 0) {
          var u = Ca, c = n(e);
          return Ca = u, Xp(e, t, c);
        }
        break;
      }
    }
    var f = n;
    if (t == null)
      return f;
    var p = t[f];
    return p !== void 0 ? p : f;
  }
  function nY(e, t, n) {
    var r = "";
    if (Array.isArray(n))
      for (var o = 0; o < n.length; o++)
        r += Xp(e, t, n[o]) + ";";
    else
      for (var a in n) {
        var i = n[a];
        if (typeof i != "object") {
          var s = i;
          t != null && t[s] !== void 0 ? r += a + "{" + t[s] + "}" : A5(s) && (r += l_(a) + ":" + $5(a, s) + ";");
        } else if (Array.isArray(i) && typeof i[0] == "string" && (t == null || t[i[0]] === void 0))
          for (var u = 0; u < i.length; u++)
            A5(i[u]) && (r += l_(a) + ":" + $5(a, i[u]) + ";");
        else {
          var c = Xp(e, t, i);
          switch (a) {
            case "animation":
            case "animationName": {
              r += l_(a) + ":" + c + ";";
              break;
            }
            default:
              r += a + "{" + c + "}";
          }
        }
      }
    return r;
  }
  var D5 = /label:\s*([^\s;{]+)\s*(;|$)/g, Ca;
  function Dm(e, t, n) {
    if (e.length === 1 && typeof e[0] == "object" && e[0] !== null && e[0].styles !== void 0)
      return e[0];
    var r = !0, o = "";
    Ca = void 0;
    var a = e[0];
    if (a == null || a.raw === void 0)
      r = !1, o += Xp(n, t, a);
    else {
      var i = a;
      o += i[0];
    }
    for (var s = 1; s < e.length; s++)
      if (o += Xp(n, t, e[s]), r) {
        var u = a;
        o += u[s];
      }
    D5.lastIndex = 0;
    for (var c = "", f; (f = D5.exec(o)) !== null; )
      c += "-" + f[1];
    var p = QX(o) + c;
    return {
      name: p,
      styles: o,
      next: Ca
    };
  }
  var rY = function(e) {
    return e();
  }, hT = C.useInsertionEffect ? C.useInsertionEffect : !1, gT = hT || rY, L5 = hT || C.useLayoutEffect, vT = /* @__PURE__ */ C.createContext(
    // we're doing this to avoid preconstruct's dead code elimination in this one case
    // because this module is primarily intended for the browser and node
    // but it's also required in react native and similar environments sometimes
    // and we could have a special build just for that
    // but this is much easier and the native packages
    // might use a different theme context in the future anyway
    typeof HTMLElement < "u" ? /* @__PURE__ */ XX({
      key: "css"
    }) : null
  );
  vT.Provider;
  var nC = function(e) {
    return /* @__PURE__ */ C.forwardRef(function(t, n) {
      var r = C.useContext(vT);
      return e(t, r, n);
    });
  }, Lm = /* @__PURE__ */ C.createContext({}), rC = {}.hasOwnProperty, t2 = "__EMOTION_TYPE_PLEASE_DO_NOT_USE__", oY = function(e, t) {
    var n = {};
    for (var r in t)
      rC.call(t, r) && (n[r] = t[r]);
    return n[t2] = e, n;
  }, aY = function(e) {
    var t = e.cache, n = e.serialized, r = e.isStringTag;
    return eC(t, n, r), gT(function() {
      return tC(t, n, r);
    }), null;
  }, iY = /* @__PURE__ */ nC(function(e, t, n) {
    var r = e.css;
    typeof r == "string" && t.registered[r] !== void 0 && (r = t.registered[r]);
    var o = e[t2], a = [r], i = "";
    typeof e.className == "string" ? i = pT(t.registered, a, e.className) : e.className != null && (i = e.className + " ");
    var s = Dm(a, void 0, C.useContext(Lm));
    i += t.key + "-" + s.name;
    var u = {};
    for (var c in e)
      rC.call(e, c) && c !== "css" && c !== t2 && (u[c] = e[c]);
    return u.className = i, n && (u.ref = n), /* @__PURE__ */ C.createElement(C.Fragment, null, /* @__PURE__ */ C.createElement(aY, {
      cache: t,
      serialized: s,
      isStringTag: typeof o == "string"
    }), /* @__PURE__ */ C.createElement(o, u));
  }), sY = iY, qe = function(e, t) {
    var n = arguments;
    if (t == null || !rC.call(t, "css"))
      return C.createElement.apply(void 0, n);
    var r = n.length, o = new Array(r);
    o[0] = sY, o[1] = oY(e, t);
    for (var a = 2; a < r; a++)
      o[a] = n[a];
    return C.createElement.apply(null, o);
  };
  (function(e) {
    var t;
    t || (t = e.JSX || (e.JSX = {}));
  })(qe || (qe = {}));
  var lY = /* @__PURE__ */ nC(function(e, t) {
    var n = e.styles, r = Dm([n], void 0, C.useContext(Lm)), o = C.useRef();
    return L5(function() {
      var a = t.key + "-global", i = new t.sheet.constructor({
        key: a,
        nonce: t.sheet.nonce,
        container: t.sheet.container,
        speedy: t.sheet.isSpeedy
      }), s = !1, u = document.querySelector('style[data-emotion="' + a + " " + r.name + '"]');
      return t.sheet.tags.length && (i.before = t.sheet.tags[0]), u !== null && (s = !0, u.setAttribute("data-emotion", a), i.hydrate([u])), o.current = [i, s], function() {
        i.flush();
      };
    }, [t]), L5(function() {
      var a = o.current, i = a[0], s = a[1];
      if (s) {
        a[1] = !1;
        return;
      }
      if (r.next !== void 0 && tC(t, r.next, !0), i.tags.length) {
        var u = i.tags[i.tags.length - 1].nextElementSibling;
        i.before = u, i.flush();
      }
      t.insert("", r, i, !1);
    }, [t, r.name]), null;
  });
  function Fm() {
    for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)
      t[n] = arguments[n];
    return Dm(t);
  }
  function Ad() {
    var e = Fm.apply(void 0, arguments), t = "animation-" + e.name;
    return {
      name: t,
      styles: "@keyframes " + t + "{" + e.styles + "}",
      anim: 1,
      toString: function() {
        return "_EMO_" + this.name + "_" + this.styles + "_EMO_";
      }
    };
  }
  var uY = /^((children|dangerouslySetInnerHTML|key|ref|autoFocus|defaultValue|defaultChecked|innerHTML|suppressContentEditableWarning|suppressHydrationWarning|valueLink|abbr|accept|acceptCharset|accessKey|action|allow|allowUserMedia|allowPaymentRequest|allowFullScreen|allowTransparency|alt|async|autoComplete|autoPlay|capture|cellPadding|cellSpacing|challenge|charSet|checked|cite|classID|className|cols|colSpan|content|contentEditable|contextMenu|controls|controlsList|coords|crossOrigin|data|dateTime|decoding|default|defer|dir|disabled|disablePictureInPicture|disableRemotePlayback|download|draggable|encType|enterKeyHint|fetchpriority|fetchPriority|form|formAction|formEncType|formMethod|formNoValidate|formTarget|frameBorder|headers|height|hidden|high|href|hrefLang|htmlFor|httpEquiv|id|inputMode|integrity|is|keyParams|keyType|kind|label|lang|list|loading|loop|low|marginHeight|marginWidth|max|maxLength|media|mediaGroup|method|min|minLength|multiple|muted|name|nonce|noValidate|open|optimum|pattern|placeholder|playsInline|poster|preload|profile|radioGroup|readOnly|referrerPolicy|rel|required|reversed|role|rows|rowSpan|sandbox|scope|scoped|scrolling|seamless|selected|shape|size|sizes|slot|span|spellCheck|src|srcDoc|srcLang|srcSet|start|step|style|summary|tabIndex|target|title|translate|type|useMap|value|width|wmode|wrap|about|datatype|inlist|prefix|property|resource|typeof|vocab|autoCapitalize|autoCorrect|autoSave|color|incremental|fallback|inert|itemProp|itemScope|itemType|itemID|itemRef|on|option|results|security|unselectable|accentHeight|accumulate|additive|alignmentBaseline|allowReorder|alphabetic|amplitude|arabicForm|ascent|attributeName|attributeType|autoReverse|azimuth|baseFrequency|baselineShift|baseProfile|bbox|begin|bias|by|calcMode|capHeight|clip|clipPathUnits|clipPath|clipRule|colorInterpolation|colorInterpolationFilters|colorProfile|colorRendering|contentScriptType|contentStyleType|cursor|cx|cy|d|decelerate|descent|diffuseConstant|direction|display|divisor|dominantBaseline|dur|dx|dy|edgeMode|elevation|enableBackground|end|exponent|externalResourcesRequired|fill|fillOpacity|fillRule|filter|filterRes|filterUnits|floodColor|floodOpacity|focusable|fontFamily|fontSize|fontSizeAdjust|fontStretch|fontStyle|fontVariant|fontWeight|format|from|fr|fx|fy|g1|g2|glyphName|glyphOrientationHorizontal|glyphOrientationVertical|glyphRef|gradientTransform|gradientUnits|hanging|horizAdvX|horizOriginX|ideographic|imageRendering|in|in2|intercept|k|k1|k2|k3|k4|kernelMatrix|kernelUnitLength|kerning|keyPoints|keySplines|keyTimes|lengthAdjust|letterSpacing|lightingColor|limitingConeAngle|local|markerEnd|markerMid|markerStart|markerHeight|markerUnits|markerWidth|mask|maskContentUnits|maskUnits|mathematical|mode|numOctaves|offset|opacity|operator|order|orient|orientation|origin|overflow|overlinePosition|overlineThickness|panose1|paintOrder|pathLength|patternContentUnits|patternTransform|patternUnits|pointerEvents|points|pointsAtX|pointsAtY|pointsAtZ|preserveAlpha|preserveAspectRatio|primitiveUnits|r|radius|refX|refY|renderingIntent|repeatCount|repeatDur|requiredExtensions|requiredFeatures|restart|result|rotate|rx|ry|scale|seed|shapeRendering|slope|spacing|specularConstant|specularExponent|speed|spreadMethod|startOffset|stdDeviation|stemh|stemv|stitchTiles|stopColor|stopOpacity|strikethroughPosition|strikethroughThickness|string|stroke|strokeDasharray|strokeDashoffset|strokeLinecap|strokeLinejoin|strokeMiterlimit|strokeOpacity|strokeWidth|surfaceScale|systemLanguage|tableValues|targetX|targetY|textAnchor|textDecoration|textRendering|textLength|to|transform|u1|u2|underlinePosition|underlineThickness|unicode|unicodeBidi|unicodeRange|unitsPerEm|vAlphabetic|vHanging|vIdeographic|vMathematical|values|vectorEffect|version|vertAdvY|vertOriginX|vertOriginY|viewBox|viewTarget|visibility|widths|wordSpacing|writingMode|x|xHeight|x1|x2|xChannelSelector|xlinkActuate|xlinkArcrole|xlinkHref|xlinkRole|xlinkShow|xlinkTitle|xlinkType|xmlBase|xmlns|xmlnsXlink|xmlLang|xmlSpace|y|y1|y2|yChannelSelector|z|zoomAndPan|for|class|autofocus)|(([Dd][Aa][Tt][Aa]|[Aa][Rr][Ii][Aa]|x)-.*))$/, cY = /* @__PURE__ */ dT(
    function(e) {
      return uY.test(e) || e.charCodeAt(0) === 111 && e.charCodeAt(1) === 110 && e.charCodeAt(2) < 91;
    }
    /* Z+1 */
  ), dY = cY, fY = function(e) {
    return e !== "theme";
  }, F5 = function(e) {
    return typeof e == "string" && // 96 is one less than the char code
    // for "a" so this is checking that
    // it's a lowercase character
    e.charCodeAt(0) > 96 ? dY : fY;
  }, T5 = function(e, t, n) {
    var r;
    if (t) {
      var o = t.shouldForwardProp;
      r = e.__emotion_forwardProp && o ? function(a) {
        return e.__emotion_forwardProp(a) && o(a);
      } : o;
    }
    return typeof r != "function" && n && (r = e.__emotion_forwardProp), r;
  }, pY = function(e) {
    var t = e.cache, n = e.serialized, r = e.isStringTag;
    return eC(t, n, r), gT(function() {
      return tC(t, n, r);
    }), null;
  }, mY = function e(t, n) {
    var r = t.__emotion_real === t, o = r && t.__emotion_base || t, a, i;
    n !== void 0 && (a = n.label, i = n.target);
    var s = T5(t, n, r), u = s || F5(o), c = !u("as");
    return function() {
      var f = arguments, p = r && t.__emotion_styles !== void 0 ? t.__emotion_styles.slice(0) : [];
      if (a !== void 0 && p.push("label:" + a + ";"), f[0] == null || f[0].raw === void 0)
        p.push.apply(p, f);
      else {
        var g = f[0];
        p.push(g[0]);
        for (var h = f.length, y = 1; y < h; y++)
          p.push(f[y], g[y]);
      }
      var b = nC(function(v, w, _) {
        var k = c && v.as || o, E = "", P = [], O = v;
        if (v.theme == null) {
          O = {};
          for (var M in v)
            O[M] = v[M];
          O.theme = C.useContext(Lm);
        }
        typeof v.className == "string" ? E = pT(w.registered, P, v.className) : v.className != null && (E = v.className + " ");
        var I = Dm(p.concat(P), w.registered, O);
        E += w.key + "-" + I.name, i !== void 0 && (E += " " + i);
        var A = c && s === void 0 ? F5(k) : u, D = {};
        for (var F in v)
          c && F === "as" || A(F) && (D[F] = v[F]);
        return D.className = E, _ && (D.ref = _), /* @__PURE__ */ C.createElement(C.Fragment, null, /* @__PURE__ */ C.createElement(pY, {
          cache: w,
          serialized: I,
          isStringTag: typeof k == "string"
        }), /* @__PURE__ */ C.createElement(k, D));
      });
      return b.displayName = a !== void 0 ? a : "Styled(" + (typeof o == "string" ? o : o.displayName || o.name || "Component") + ")", b.defaultProps = t.defaultProps, b.__emotion_real = b, b.__emotion_base = o, b.__emotion_styles = p, b.__emotion_forwardProp = s, Object.defineProperty(b, "toString", {
        value: function() {
          return "." + i;
        }
      }), b.withComponent = function(v, w) {
        var _ = e(v, Ge({}, n, w, {
          shouldForwardProp: T5(b, w, !0)
        }));
        return _.apply(void 0, p);
      }, b;
    };
  }, hY = [
    "a",
    "abbr",
    "address",
    "area",
    "article",
    "aside",
    "audio",
    "b",
    "base",
    "bdi",
    "bdo",
    "big",
    "blockquote",
    "body",
    "br",
    "button",
    "canvas",
    "caption",
    "cite",
    "code",
    "col",
    "colgroup",
    "data",
    "datalist",
    "dd",
    "del",
    "details",
    "dfn",
    "dialog",
    "div",
    "dl",
    "dt",
    "em",
    "embed",
    "fieldset",
    "figcaption",
    "figure",
    "footer",
    "form",
    "h1",
    "h2",
    "h3",
    "h4",
    "h5",
    "h6",
    "head",
    "header",
    "hgroup",
    "hr",
    "html",
    "i",
    "iframe",
    "img",
    "input",
    "ins",
    "kbd",
    "keygen",
    "label",
    "legend",
    "li",
    "link",
    "main",
    "map",
    "mark",
    "marquee",
    "menu",
    "menuitem",
    "meta",
    "meter",
    "nav",
    "noscript",
    "object",
    "ol",
    "optgroup",
    "option",
    "output",
    "p",
    "param",
    "picture",
    "pre",
    "progress",
    "q",
    "rp",
    "rt",
    "ruby",
    "s",
    "samp",
    "script",
    "section",
    "select",
    "small",
    "source",
    "span",
    "strong",
    "style",
    "sub",
    "summary",
    "sup",
    "table",
    "tbody",
    "td",
    "textarea",
    "tfoot",
    "th",
    "thead",
    "time",
    "title",
    "tr",
    "track",
    "u",
    "ul",
    "var",
    "video",
    "wbr",
    // SVG
    "circle",
    "clipPath",
    "defs",
    "ellipse",
    "foreignObject",
    "g",
    "image",
    "line",
    "linearGradient",
    "mask",
    "path",
    "pattern",
    "polygon",
    "polyline",
    "radialGradient",
    "rect",
    "stop",
    "svg",
    "text",
    "tspan"
  ], n2 = mY.bind(null);
  hY.forEach(function(e) {
    n2[e] = n2(e);
  });
  function gY(e) {
    return e == null || Object.keys(e).length === 0;
  }
  function yT(e) {
    const {
      styles: t,
      defaultTheme: n = {}
    } = e, r = typeof t == "function" ? (o) => t(gY(o) ? n : o) : t;
    return /* @__PURE__ */ S.jsx(lY, {
      styles: r
    });
  }
  function bT(e, t) {
    return n2(e, t);
  }
  function vY(e, t) {
    Array.isArray(e.__emotion_styles) && (e.__emotion_styles = t(e.__emotion_styles));
  }
  const z5 = [];
  function Ys(e) {
    return z5[0] = e, Dm(z5);
  }
  const yY = (e) => {
    const t = Object.keys(e).map((n) => ({
      key: n,
      val: e[n]
    })) || [];
    return t.sort((n, r) => n.val - r.val), t.reduce((n, r) => ({
      ...n,
      [r.key]: r.val
    }), {});
  };
  function bY(e) {
    const {
      // The breakpoint **start** at this value.
      // For instance with the first breakpoint xs: [xs, sm).
      values: t = {
        xs: 0,
        // phone
        sm: 600,
        // tablet
        md: 900,
        // small laptop
        lg: 1200,
        // desktop
        xl: 1536
        // large screen
      },
      unit: n = "px",
      step: r = 5,
      ...o
    } = e, a = yY(t), i = Object.keys(a);
    function s(g) {
      return `@media (min-width:${typeof t[g] == "number" ? t[g] : g}${n})`;
    }
    function u(g) {
      return `@media (max-width:${(typeof t[g] == "number" ? t[g] : g) - r / 100}${n})`;
    }
    function c(g, h) {
      const y = i.indexOf(h);
      return `@media (min-width:${typeof t[g] == "number" ? t[g] : g}${n}) and (max-width:${(y !== -1 && typeof t[i[y]] == "number" ? t[i[y]] : h) - r / 100}${n})`;
    }
    function f(g) {
      return i.indexOf(g) + 1 < i.length ? c(g, i[i.indexOf(g) + 1]) : s(g);
    }
    function p(g) {
      const h = i.indexOf(g);
      return h === 0 ? s(i[1]) : h === i.length - 1 ? u(i[h]) : c(g, i[i.indexOf(g) + 1]).replace("@media", "@media not all and");
    }
    return {
      keys: i,
      values: a,
      up: s,
      down: u,
      between: c,
      only: f,
      not: p,
      unit: n,
      ...o
    };
  }
  const wY = {
    borderRadius: 4
  };
  function wT(e = 8, t = GE({
    spacing: e
  })) {
    if (e.mui)
      return e;
    const n = (...r) => (r.length === 0 ? [1] : r).map((o) => {
      const a = t(o);
      return typeof a == "number" ? `${a}px` : a;
    }).join(" ");
    return n.mui = !0, n;
  }
  function xY(e, t) {
    const n = this;
    if (n.vars) {
      if (!n.colorSchemes?.[e] || typeof n.getColorSchemeSelector != "function")
        return {};
      let r = n.getColorSchemeSelector(e);
      return r === "&" ? t : ((r.includes("data-") || r.includes(".")) && (r = `*:where(${r.replace(/\s*&$/, "")}) &`), {
        [r]: t
      });
    }
    return n.palette.mode === e ? t : {};
  }
  function uw(e = {}, ...t) {
    const {
      breakpoints: n = {},
      palette: r = {},
      spacing: o,
      shape: a = {},
      ...i
    } = e, s = bY(n), u = wT(o);
    let c = wr({
      breakpoints: s,
      direction: "ltr",
      components: {},
      // Inject component definitions.
      palette: {
        mode: "light",
        ...r
      },
      spacing: u,
      shape: {
        ...wY,
        ...a
      }
    }, i);
    return c = jG(c), c.applyStyles = xY, c = t.reduce((f, p) => wr(f, p), c), c.unstable_sxConfig = {
      ...Am,
      ...i?.unstable_sxConfig
    }, c.unstable_sx = function(f) {
      return nl({
        sx: f,
        theme: this
      });
    }, c;
  }
  function kY(e) {
    return Object.keys(e).length === 0;
  }
  function oC(e = null) {
    const t = C.useContext(Lm);
    return !t || kY(t) ? e : t;
  }
  const SY = uw();
  function Tm(e = SY) {
    return oC(e);
  }
  function B5(e) {
    const t = Ys(e);
    return e !== t && t.styles ? (t.styles.match(/^@layer\s+[^{]*$/) || (t.styles = `@layer global{${t.styles}}`), t) : e;
  }
  function xT({
    styles: e,
    themeId: t,
    defaultTheme: n = {}
  }) {
    const r = Tm(n), o = t && r[t] || r;
    let a = typeof e == "function" ? e(o) : e;
    return o.modularCssLayers && (Array.isArray(a) ? a = a.map((i) => B5(typeof i == "function" ? i(o) : i)) : a = B5(a)), /* @__PURE__ */ S.jsx(yT, {
      styles: a
    });
  }
  const V5 = (e) => e, _Y = () => {
    let e = V5;
    return {
      configure(t) {
        e = t;
      },
      generate(t) {
        return e(t);
      },
      reset() {
        e = V5;
      }
    };
  }, kT = _Y();
  function EY(e = {}) {
    const {
      themeId: t,
      defaultTheme: n,
      defaultClassName: r = "MuiBox-root",
      generateClassName: o
    } = e, a = bT("div", {
      shouldForwardProp: (i) => i !== "theme" && i !== "sx" && i !== "as"
    })(nl);
    return /* @__PURE__ */ C.forwardRef(function(i, s) {
      const u = Tm(n), {
        className: c,
        component: f = "div",
        ...p
      } = YE(i);
      return /* @__PURE__ */ S.jsx(a, {
        as: f,
        ref: s,
        className: Le(c, o ? o(r) : r),
        theme: t && u[t] || u,
        ...p
      });
    });
  }
  const CY = {
    active: "active",
    checked: "checked",
    completed: "completed",
    disabled: "disabled",
    error: "error",
    expanded: "expanded",
    focused: "focused",
    focusVisible: "focusVisible",
    open: "open",
    readOnly: "readOnly",
    required: "required",
    selected: "selected"
  };
  function rt(e, t, n = "Mui") {
    const r = CY[t];
    return r ? `${n}-${r}` : `${kT.generate(e)}-${t}`;
  }
  function tt(e, t, n = "Mui") {
    const r = {};
    return t.forEach((o) => {
      r[o] = rt(e, o, n);
    }), r;
  }
  function ST(e) {
    const {
      variants: t,
      ...n
    } = e, r = {
      variants: t,
      style: Ys(n),
      isProcessed: !0
    };
    return r.style === n || t && t.forEach((o) => {
      typeof o.style != "function" && (o.style = Ys(o.style));
    }), r;
  }
  const PY = uw();
  function u_(e) {
    return e !== "ownerState" && e !== "theme" && e !== "sx" && e !== "as";
  }
  function Ql(e, t) {
    return t && e && typeof e == "object" && e.styles && !e.styles.startsWith("@layer") && (e.styles = `@layer ${t}{${String(e.styles)}}`), e;
  }
  function OY(e) {
    return e ? (t, n) => n[e] : null;
  }
  function NY(e, t, n) {
    e.theme = RY(e.theme) ? n : e.theme[t] || e.theme;
  }
  function Ey(e, t, n) {
    const r = typeof t == "function" ? t(e) : t;
    if (Array.isArray(r))
      return r.flatMap((o) => Ey(e, o, n));
    if (Array.isArray(r?.variants)) {
      let o;
      if (r.isProcessed)
        o = n ? Ql(r.style, n) : r.style;
      else {
        const {
          variants: a,
          ...i
        } = r;
        o = n ? Ql(Ys(i), n) : i;
      }
      return _T(e, r.variants, [o], n);
    }
    return r?.isProcessed ? n ? Ql(Ys(r.style), n) : r.style : n ? Ql(Ys(r), n) : r;
  }
  function _T(e, t, n = [], r = void 0) {
    let o;
    e: for (let a = 0; a < t.length; a += 1) {
      const i = t[a];
      if (typeof i.props == "function") {
        if (o ?? (o = {
          ...e,
          ...e.ownerState,
          ownerState: e.ownerState
        }), !i.props(o))
          continue;
      } else
        for (const s in i.props)
          if (e[s] !== i.props[s] && e.ownerState?.[s] !== i.props[s])
            continue e;
      typeof i.style == "function" ? (o ?? (o = {
        ...e,
        ...e.ownerState,
        ownerState: e.ownerState
      }), n.push(r ? Ql(Ys(i.style(o)), r) : i.style(o))) : n.push(r ? Ql(Ys(i.style), r) : i.style);
    }
    return n;
  }
  function ET(e = {}) {
    const {
      themeId: t,
      defaultTheme: n = PY,
      rootShouldForwardProp: r = u_,
      slotShouldForwardProp: o = u_
    } = e;
    function a(i) {
      NY(i, t, n);
    }
    return (i, s = {}) => {
      vY(i, (P) => P.filter((O) => O !== nl));
      const {
        name: u,
        slot: c,
        skipVariantsResolver: f,
        skipSx: p,
        // TODO v6: remove `lowercaseFirstLetter()` in the next major release
        // For more details: https://github.com/mui/material-ui/pull/37908
        overridesResolver: g = OY(IY(c)),
        ...h
      } = s, y = u && u.startsWith("Mui") || c ? "components" : "custom", b = f !== void 0 ? f : (
        // TODO v6: remove `Root` in the next major release
        // For more details: https://github.com/mui/material-ui/pull/37908
        c && c !== "Root" && c !== "root" || !1
      ), v = p || !1;
      let w = u_;
      c === "Root" || c === "root" ? w = r : c ? w = o : jY(i) && (w = void 0);
      const _ = bT(i, {
        shouldForwardProp: w,
        label: MY(),
        ...h
      }), k = (P) => {
        if (P.__emotion_real === P)
          return P;
        if (typeof P == "function")
          return function(O) {
            return Ey(O, P, O.theme.modularCssLayers ? y : void 0);
          };
        if (Na(P)) {
          const O = ST(P);
          return function(M) {
            return O.variants ? Ey(M, O, M.theme.modularCssLayers ? y : void 0) : M.theme.modularCssLayers ? Ql(O.style, y) : O.style;
          };
        }
        return P;
      }, E = (...P) => {
        const O = [], M = P.map(k), I = [];
        if (O.push(a), u && g && I.push(function(F) {
          const j = F.theme.components?.[u]?.styleOverrides;
          if (!j)
            return null;
          const U = {};
          for (const $ in j)
            U[$] = Ey(F, j[$], F.theme.modularCssLayers ? "theme" : void 0);
          return g(F, U);
        }), u && !b && I.push(function(F) {
          const j = F.theme?.components?.[u]?.variants;
          return j ? _T(F, j, [], F.theme.modularCssLayers ? "theme" : void 0) : null;
        }), v || I.push(nl), Array.isArray(M[0])) {
          const F = M.shift(), j = new Array(O.length).fill(""), U = new Array(I.length).fill("");
          let $;
          $ = [...j, ...F, ...U], $.raw = [...j, ...F.raw, ...U], O.unshift($);
        }
        const A = [...O, ...M, ...I], D = _(...A);
        return i.muiName && (D.muiName = i.muiName), D;
      };
      return _.withConfig && (E.withConfig = _.withConfig), E;
    };
  }
  function MY(e, t) {
    return void 0;
  }
  function RY(e) {
    for (const t in e)
      return !1;
    return !0;
  }
  function jY(e) {
    return typeof e == "string" && // 96 is one less than the char code
    // for "a" so this is checking that
    // it's a lowercase character
    e.charCodeAt(0) > 96;
  }
  function IY(e) {
    return e && e.charAt(0).toLowerCase() + e.slice(1);
  }
  const AY = ET();
  function Yp(e, t, n = !1) {
    const r = {
      ...t
    };
    for (const o in e)
      if (Object.prototype.hasOwnProperty.call(e, o)) {
        const a = o;
        if (a === "components" || a === "slots")
          r[a] = {
            ...e[a],
            ...r[a]
          };
        else if (a === "componentsProps" || a === "slotProps") {
          const i = e[a], s = t[a];
          if (!s)
            r[a] = i || {};
          else if (!i)
            r[a] = s;
          else {
            r[a] = {
              ...s
            };
            for (const u in i)
              if (Object.prototype.hasOwnProperty.call(i, u)) {
                const c = u;
                r[a][c] = Yp(i[c], s[c], n);
              }
          }
        } else a === "className" && n && t.className ? r.className = Le(e?.className, t?.className) : a === "style" && n && t.style ? r.style = {
          ...e?.style,
          ...t?.style
        } : r[a] === void 0 && (r[a] = e[a]);
      }
    return r;
  }
  function $Y(e) {
    const {
      theme: t,
      name: n,
      props: r
    } = e;
    return !t || !t.components || !t.components[n] || !t.components[n].defaultProps ? r : Yp(t.components[n].defaultProps, r);
  }
  function DY({
    props: e,
    name: t,
    defaultTheme: n,
    themeId: r
  }) {
    let o = Tm(n);
    return r && (o = o[r] || o), $Y({
      theme: o,
      name: t,
      props: e
    });
  }
  const ta = typeof window < "u" ? C.useLayoutEffect : C.useEffect;
  function Tc(e, t = Number.MIN_SAFE_INTEGER, n = Number.MAX_SAFE_INTEGER) {
    return Math.max(t, Math.min(e, n));
  }
  function aC(e, t = 0, n = 1) {
    return Tc(e, t, n);
  }
  function LY(e) {
    e = e.slice(1);
    const t = new RegExp(`.{1,${e.length >= 6 ? 2 : 1}}`, "g");
    let n = e.match(t);
    return n && n[0].length === 1 && (n = n.map((r) => r + r)), n ? `rgb${n.length === 4 ? "a" : ""}(${n.map((r, o) => o < 3 ? parseInt(r, 16) : Math.round(parseInt(r, 16) / 255 * 1e3) / 1e3).join(", ")})` : "";
  }
  function rl(e) {
    if (e.type)
      return e;
    if (e.charAt(0) === "#")
      return rl(LY(e));
    const t = e.indexOf("("), n = e.substring(0, t);
    if (!["rgb", "rgba", "hsl", "hsla", "color"].includes(n))
      throw new Error(Vi(9, e));
    let r = e.substring(t + 1, e.length - 1), o;
    if (n === "color") {
      if (r = r.split(" "), o = r.shift(), r.length === 4 && r[3].charAt(0) === "/" && (r[3] = r[3].slice(1)), !["srgb", "display-p3", "a98-rgb", "prophoto-rgb", "rec-2020"].includes(o))
        throw new Error(Vi(10, o));
    } else
      r = r.split(",");
    return r = r.map((a) => parseFloat(a)), {
      type: n,
      values: r,
      colorSpace: o
    };
  }
  const FY = (e) => {
    const t = rl(e);
    return t.values.slice(0, 3).map((n, r) => t.type.includes("hsl") && r !== 0 ? `${n}%` : n).join(" ");
  }, mp = (e, t) => {
    try {
      return FY(e);
    } catch {
      return e;
    }
  };
  function cw(e) {
    const {
      type: t,
      colorSpace: n
    } = e;
    let {
      values: r
    } = e;
    return t.includes("rgb") ? r = r.map((o, a) => a < 3 ? parseInt(o, 10) : o) : t.includes("hsl") && (r[1] = `${r[1]}%`, r[2] = `${r[2]}%`), t.includes("color") ? r = `${n} ${r.join(" ")}` : r = `${r.join(", ")}`, `${t}(${r})`;
  }
  function CT(e) {
    e = rl(e);
    const {
      values: t
    } = e, n = t[0], r = t[1] / 100, o = t[2] / 100, a = r * Math.min(o, 1 - o), i = (c, f = (c + n / 30) % 12) => o - a * Math.max(Math.min(f - 3, 9 - f, 1), -1);
    let s = "rgb";
    const u = [Math.round(i(0) * 255), Math.round(i(8) * 255), Math.round(i(4) * 255)];
    return e.type === "hsla" && (s += "a", u.push(t[3])), cw({
      type: s,
      values: u
    });
  }
  function r2(e) {
    e = rl(e);
    let t = e.type === "hsl" || e.type === "hsla" ? rl(CT(e)).values : e.values;
    return t = t.map((n) => (e.type !== "color" && (n /= 255), n <= 0.03928 ? n / 12.92 : ((n + 0.055) / 1.055) ** 2.4)), Number((0.2126 * t[0] + 0.7152 * t[1] + 0.0722 * t[2]).toFixed(3));
  }
  function TY(e, t) {
    const n = r2(e), r = r2(t);
    return (Math.max(n, r) + 0.05) / (Math.min(n, r) + 0.05);
  }
  function Qy(e, t) {
    return e = rl(e), t = aC(t), (e.type === "rgb" || e.type === "hsl") && (e.type += "a"), e.type === "color" ? e.values[3] = `/${t}` : e.values[3] = t, cw(e);
  }
  function Tl(e, t, n) {
    try {
      return Qy(e, t);
    } catch {
      return e;
    }
  }
  function dw(e, t) {
    if (e = rl(e), t = aC(t), e.type.includes("hsl"))
      e.values[2] *= 1 - t;
    else if (e.type.includes("rgb") || e.type.includes("color"))
      for (let n = 0; n < 3; n += 1)
        e.values[n] *= 1 - t;
    return cw(e);
  }
  function Xt(e, t, n) {
    try {
      return dw(e, t);
    } catch {
      return e;
    }
  }
  function fw(e, t) {
    if (e = rl(e), t = aC(t), e.type.includes("hsl"))
      e.values[2] += (100 - e.values[2]) * t;
    else if (e.type.includes("rgb"))
      for (let n = 0; n < 3; n += 1)
        e.values[n] += (255 - e.values[n]) * t;
    else if (e.type.includes("color"))
      for (let n = 0; n < 3; n += 1)
        e.values[n] += (1 - e.values[n]) * t;
    return cw(e);
  }
  function Yt(e, t, n) {
    try {
      return fw(e, t);
    } catch {
      return e;
    }
  }
  function zY(e, t = 0.15) {
    return r2(e) > 0.5 ? dw(e, t) : fw(e, t);
  }
  function Xg(e, t, n) {
    try {
      return zY(e, t);
    } catch {
      return e;
    }
  }
  const PT = /* @__PURE__ */ C.createContext(null);
  function iC() {
    return C.useContext(PT);
  }
  const BY = typeof Symbol == "function" && Symbol.for, VY = BY ? /* @__PURE__ */ Symbol.for("mui.nested") : "__THEME_NESTED__";
  function UY(e, t) {
    return typeof t == "function" ? t(e) : {
      ...e,
      ...t
    };
  }
  function HY(e) {
    const {
      children: t,
      theme: n
    } = e, r = iC(), o = C.useMemo(() => {
      const a = r === null ? {
        ...n
      } : UY(r, n);
      return a != null && (a[VY] = r !== null), a;
    }, [n, r]);
    return /* @__PURE__ */ S.jsx(PT.Provider, {
      value: o,
      children: t
    });
  }
  const OT = /* @__PURE__ */ C.createContext();
  function WY({
    value: e,
    ...t
  }) {
    return /* @__PURE__ */ S.jsx(OT.Provider, {
      value: e ?? !0,
      ...t
    });
  }
  const NT = () => C.useContext(OT) ?? !1, MT = /* @__PURE__ */ C.createContext(void 0);
  function qY({
    value: e,
    children: t
  }) {
    return /* @__PURE__ */ S.jsx(MT.Provider, {
      value: e,
      children: t
    });
  }
  function KY(e) {
    const {
      theme: t,
      name: n,
      props: r
    } = e;
    if (!t || !t.components || !t.components[n])
      return r;
    const o = t.components[n];
    return o.defaultProps ? Yp(o.defaultProps, r, t.components.mergeClassNameAndStyle) : !o.styleOverrides && !o.variants ? Yp(o, r, t.components.mergeClassNameAndStyle) : r;
  }
  function GY({
    props: e,
    name: t
  }) {
    const n = C.useContext(MT);
    return KY({
      props: e,
      name: t,
      theme: {
        components: n
      }
    });
  }
  let U5 = 0;
  function XY(e) {
    const [t, n] = C.useState(e), r = e || t;
    return C.useEffect(() => {
      t == null && (U5 += 1, n(`mui-${U5}`));
    }, [t]), r;
  }
  const YY = {
    ...Rm
  }, H5 = YY.useId;
  function $d(e) {
    if (H5 !== void 0) {
      const t = H5();
      return e ?? t;
    }
    return XY(e);
  }
  function JY(e) {
    const t = oC(), n = $d() || "", {
      modularCssLayers: r
    } = e;
    let o = "mui.global, mui.components, mui.theme, mui.custom, mui.sx";
    return !r || t !== null ? o = "" : typeof r == "string" ? o = r.replace(/mui(?!\.)/g, o) : o = `@layer ${o};`, ta(() => {
      const a = document.querySelector("head");
      if (!a)
        return;
      const i = a.firstChild;
      if (o) {
        if (i && i.hasAttribute?.("data-mui-layer-order") && i.getAttribute("data-mui-layer-order") === n)
          return;
        const s = document.createElement("style");
        s.setAttribute("data-mui-layer-order", n), s.textContent = o, a.prepend(s);
      } else
        a.querySelector(`style[data-mui-layer-order="${n}"]`)?.remove();
    }, [o, n]), o ? /* @__PURE__ */ S.jsx(xT, {
      styles: o
    }) : null;
  }
  const W5 = {};
  function q5(e, t, n, r = !1) {
    return C.useMemo(() => {
      const o = e && t[e] || t;
      if (typeof n == "function") {
        const a = n(o), i = e ? {
          ...t,
          [e]: a
        } : a;
        return r ? () => i : i;
      }
      return e ? {
        ...t,
        [e]: n
      } : {
        ...t,
        ...n
      };
    }, [e, t, n, r]);
  }
  function RT(e) {
    const {
      children: t,
      theme: n,
      themeId: r
    } = e, o = oC(W5), a = iC() || W5, i = q5(r, o, n), s = q5(r, a, n, !0), u = (r ? i[r] : i).direction === "rtl", c = JY(i);
    return /* @__PURE__ */ S.jsx(HY, {
      theme: s,
      children: /* @__PURE__ */ S.jsx(Lm.Provider, {
        value: i,
        children: /* @__PURE__ */ S.jsx(WY, {
          value: u,
          children: /* @__PURE__ */ S.jsxs(qY, {
            value: r ? i[r].components : i.components,
            children: [c, t]
          })
        })
      })
    });
  }
  const K5 = {
    theme: void 0
  };
  function QY(e) {
    let t, n;
    return function(r) {
      let o = t;
      return (o === void 0 || r.theme !== n) && (K5.theme = r.theme, o = ST(e(K5)), t = o, n = r.theme), o;
    };
  }
  const sC = "mode", lC = "color-scheme", ZY = "data-color-scheme";
  function eJ(e) {
    const {
      defaultMode: t = "system",
      defaultLightColorScheme: n = "light",
      defaultDarkColorScheme: r = "dark",
      modeStorageKey: o = sC,
      colorSchemeStorageKey: a = lC,
      attribute: i = ZY,
      colorSchemeNode: s = "document.documentElement",
      nonce: u
    } = e || {};
    let c = "", f = i;
    if (i === "class" && (f = ".%s"), i === "data" && (f = "[data-%s]"), f.startsWith(".")) {
      const g = f.substring(1);
      c += `${s}.classList.remove('${g}'.replace('%s', light), '${g}'.replace('%s', dark));
      ${s}.classList.add('${g}'.replace('%s', colorScheme));`;
    }
    const p = f.match(/\[([^[\]]+)\]/);
    if (p) {
      const [g, h] = p[1].split("=");
      h || (c += `${s}.removeAttribute('${g}'.replace('%s', light));
      ${s}.removeAttribute('${g}'.replace('%s', dark));`), c += `
      ${s}.setAttribute('${g}'.replace('%s', colorScheme), ${h ? `${h}.replace('%s', colorScheme)` : '""'});`;
    } else f !== ".%s" && (c += `${s}.setAttribute('${f}', colorScheme);`);
    return /* @__PURE__ */ S.jsx("script", {
      suppressHydrationWarning: !0,
      nonce: typeof window > "u" ? u : "",
      dangerouslySetInnerHTML: {
        __html: `(function() {
try {
  let colorScheme = '';
  const mode = localStorage.getItem('${o}') || '${t}';
  const dark = localStorage.getItem('${a}-dark') || '${r}';
  const light = localStorage.getItem('${a}-light') || '${n}';
  if (mode === 'system') {
    // handle system mode
    const mql = window.matchMedia('(prefers-color-scheme: dark)');
    if (mql.matches) {
      colorScheme = dark
    } else {
      colorScheme = light
    }
  }
  if (mode === 'light') {
    colorScheme = light;
  }
  if (mode === 'dark') {
    colorScheme = dark;
  }
  if (colorScheme) {
    ${c}
  }
} catch(e){}})();`
      }
    }, "mui-color-scheme-init");
  }
  function tJ() {
  }
  const nJ = ({
    key: e,
    storageWindow: t
  }) => (!t && typeof window < "u" && (t = window), {
    get(n) {
      if (typeof window > "u")
        return;
      if (!t)
        return n;
      let r;
      try {
        r = t.localStorage.getItem(e);
      } catch {
      }
      return r || n;
    },
    set: (n) => {
      if (t)
        try {
          t.localStorage.setItem(e, n);
        } catch {
        }
    },
    subscribe: (n) => {
      if (!t)
        return tJ;
      const r = (o) => {
        const a = o.newValue;
        o.key === e && n(a);
      };
      return t.addEventListener("storage", r), () => {
        t.removeEventListener("storage", r);
      };
    }
  });
  function c_() {
  }
  function G5(e) {
    if (typeof window < "u" && typeof window.matchMedia == "function" && e === "system")
      return window.matchMedia("(prefers-color-scheme: dark)").matches ? "dark" : "light";
  }
  function jT(e, t) {
    if (e.mode === "light" || e.mode === "system" && e.systemMode === "light")
      return t("light");
    if (e.mode === "dark" || e.mode === "system" && e.systemMode === "dark")
      return t("dark");
  }
  function rJ(e) {
    return jT(e, (t) => {
      if (t === "light")
        return e.lightColorScheme;
      if (t === "dark")
        return e.darkColorScheme;
    });
  }
  function oJ(e) {
    const {
      defaultMode: t = "light",
      defaultLightColorScheme: n,
      defaultDarkColorScheme: r,
      supportedColorSchemes: o = [],
      modeStorageKey: a = sC,
      colorSchemeStorageKey: i = lC,
      storageWindow: s = typeof window > "u" ? void 0 : window,
      storageManager: u = nJ,
      noSsr: c = !1
    } = e, f = o.join(","), p = o.length > 1, g = C.useMemo(() => u?.({
      key: a,
      storageWindow: s
    }), [u, a, s]), h = C.useMemo(() => u?.({
      key: `${i}-light`,
      storageWindow: s
    }), [u, i, s]), y = C.useMemo(() => u?.({
      key: `${i}-dark`,
      storageWindow: s
    }), [u, i, s]), [b, v] = C.useState(() => {
      const I = g?.get(t) || t, A = h?.get(n) || n, D = y?.get(r) || r;
      return {
        mode: I,
        systemMode: G5(I),
        lightColorScheme: A,
        darkColorScheme: D
      };
    }), [w, _] = C.useState(c || !p);
    C.useEffect(() => {
      _(!0);
    }, []);
    const k = rJ(b), E = C.useCallback((I) => {
      v((A) => {
        if (I === A.mode)
          return A;
        const D = I ?? t;
        return g?.set(D), {
          ...A,
          mode: D,
          systemMode: G5(D)
        };
      });
    }, [g, t]), P = C.useCallback((I) => {
      I ? typeof I == "string" ? I && !f.includes(I) ? console.error(`\`${I}\` does not exist in \`theme.colorSchemes\`.`) : v((A) => {
        const D = {
          ...A
        };
        return jT(A, (F) => {
          F === "light" && (h?.set(I), D.lightColorScheme = I), F === "dark" && (y?.set(I), D.darkColorScheme = I);
        }), D;
      }) : v((A) => {
        const D = {
          ...A
        }, F = I.light === null ? n : I.light, j = I.dark === null ? r : I.dark;
        return F && (f.includes(F) ? (D.lightColorScheme = F, h?.set(F)) : console.error(`\`${F}\` does not exist in \`theme.colorSchemes\`.`)), j && (f.includes(j) ? (D.darkColorScheme = j, y?.set(j)) : console.error(`\`${j}\` does not exist in \`theme.colorSchemes\`.`)), D;
      }) : v((A) => (h?.set(n), y?.set(r), {
        ...A,
        lightColorScheme: n,
        darkColorScheme: r
      }));
    }, [f, h, y, n, r]), O = C.useCallback((I) => {
      b.mode === "system" && v((A) => {
        const D = I?.matches ? "dark" : "light";
        return A.systemMode === D ? A : {
          ...A,
          systemMode: D
        };
      });
    }, [b.mode]), M = C.useRef(O);
    return M.current = O, C.useEffect(() => {
      if (typeof window.matchMedia != "function" || !p)
        return;
      const I = (...D) => M.current(...D), A = window.matchMedia("(prefers-color-scheme: dark)");
      return A.addListener(I), I(A), () => {
        A.removeListener(I);
      };
    }, [p]), C.useEffect(() => {
      if (p) {
        const I = g?.subscribe((F) => {
          (!F || ["light", "dark", "system"].includes(F)) && E(F || t);
        }) || c_, A = h?.subscribe((F) => {
          (!F || f.match(F)) && P({
            light: F
          });
        }) || c_, D = y?.subscribe((F) => {
          (!F || f.match(F)) && P({
            dark: F
          });
        }) || c_;
        return () => {
          I(), A(), D();
        };
      }
    }, [P, E, f, t, s, p, g, h, y]), {
      ...b,
      mode: w ? b.mode : void 0,
      systemMode: w ? b.systemMode : void 0,
      colorScheme: w ? k : void 0,
      setMode: E,
      setColorScheme: P
    };
  }
  const aJ = "*{-webkit-transition:none!important;-moz-transition:none!important;-o-transition:none!important;-ms-transition:none!important;transition:none!important}";
  function iJ(e) {
    const {
      themeId: t,
      /**
       * This `theme` object needs to follow a certain structure to
       * be used correctly by the finel `CssVarsProvider`. It should have a
       * `colorSchemes` key with the light and dark (and any other) palette.
       * It should also ideally have a vars object created using `prepareCssVars`.
       */
      theme: n = {},
      modeStorageKey: r = sC,
      colorSchemeStorageKey: o = lC,
      disableTransitionOnChange: a = !1,
      defaultColorScheme: i,
      resolveTheme: s
    } = e, u = {
      allColorSchemes: [],
      colorScheme: void 0,
      darkColorScheme: void 0,
      lightColorScheme: void 0,
      mode: void 0,
      setColorScheme: () => {
      },
      setMode: () => {
      },
      systemMode: void 0
    }, c = /* @__PURE__ */ C.createContext(void 0), f = () => C.useContext(c) || u, p = {}, g = {};
    function h(v) {
      const {
        children: w,
        theme: _,
        modeStorageKey: k = r,
        colorSchemeStorageKey: E = o,
        disableTransitionOnChange: P = a,
        storageManager: O,
        storageWindow: M = typeof window > "u" ? void 0 : window,
        documentNode: I = typeof document > "u" ? void 0 : document,
        colorSchemeNode: A = typeof document > "u" ? void 0 : document.documentElement,
        disableNestedContext: D = !1,
        disableStyleSheetGeneration: F = !1,
        defaultMode: j = "system",
        forceThemeRerender: U = !1,
        noSsr: $
      } = v, q = C.useRef(!1), B = iC(), G = C.useContext(c), W = !!G && !D, Y = C.useMemo(() => _ || (typeof n == "function" ? n() : n), [_]), z = Y[t], L = z || Y, {
        colorSchemes: K = p,
        components: T = g,
        cssVarPrefix: V
      } = L, X = Object.keys(K).filter((_e) => !!K[_e]).join(","), Q = C.useMemo(() => X.split(","), [X]), ne = typeof i == "string" ? i : i.light, te = typeof i == "string" ? i : i.dark, ae = K[ne] && K[te] ? j : K[L.defaultColorScheme]?.palette?.mode || L.palette?.mode, {
        mode: ce,
        setMode: Z,
        systemMode: ee,
        lightColorScheme: oe,
        darkColorScheme: le,
        colorScheme: be,
        setColorScheme: ke
      } = oJ({
        supportedColorSchemes: Q,
        defaultLightColorScheme: ne,
        defaultDarkColorScheme: te,
        modeStorageKey: k,
        colorSchemeStorageKey: E,
        defaultMode: ae,
        storageManager: O,
        storageWindow: M,
        noSsr: $
      });
      let De = ce, ze = be;
      W && (De = G.mode, ze = G.colorScheme);
      let Ue = ze || L.defaultColorScheme;
      L.vars && !U && (Ue = L.defaultColorScheme);
      const He = C.useMemo(() => {
        const _e = L.generateThemeVars?.() || L.vars, ie = {
          ...L,
          components: T,
          colorSchemes: K,
          cssVarPrefix: V,
          vars: _e
        };
        if (typeof ie.generateSpacing == "function" && (ie.spacing = ie.generateSpacing()), Ue) {
          const me = K[Ue];
          me && typeof me == "object" && Object.keys(me).forEach((Se) => {
            me[Se] && typeof me[Se] == "object" ? ie[Se] = {
              ...ie[Se],
              ...me[Se]
            } : ie[Se] = me[Se];
          });
        }
        return s ? s(ie) : ie;
      }, [L, Ue, T, K, V]), Pe = L.colorSchemeSelector;
      ta(() => {
        if (ze && A && Pe && Pe !== "media") {
          const _e = Pe;
          let ie = Pe;
          if (_e === "class" && (ie = ".%s"), _e === "data" && (ie = "[data-%s]"), _e?.startsWith("data-") && !_e.includes("%s") && (ie = `[${_e}="%s"]`), ie.startsWith("."))
            A.classList.remove(...Q.map((me) => ie.substring(1).replace("%s", me))), A.classList.add(ie.substring(1).replace("%s", ze));
          else {
            const me = ie.replace("%s", ze).match(/\[([^\]]+)\]/);
            if (me) {
              const [Se, je] = me[1].split("=");
              je || Q.forEach((Ae) => {
                A.removeAttribute(Se.replace(ze, Ae));
              }), A.setAttribute(Se, je ? je.replace(/"|'/g, "") : "");
            } else
              A.setAttribute(ie, ze);
          }
        }
      }, [ze, Pe, A, Q]), C.useEffect(() => {
        let _e;
        if (P && q.current && I) {
          const ie = I.createElement("style");
          ie.appendChild(I.createTextNode(aJ)), I.head.appendChild(ie), window.getComputedStyle(I.body), _e = setTimeout(() => {
            I.head.removeChild(ie);
          }, 1);
        }
        return () => {
          clearTimeout(_e);
        };
      }, [ze, P, I]), C.useEffect(() => (q.current = !0, () => {
        q.current = !1;
      }), []);
      const It = C.useMemo(() => ({
        allColorSchemes: Q,
        colorScheme: ze,
        darkColorScheme: le,
        lightColorScheme: oe,
        mode: De,
        setColorScheme: ke,
        setMode: Z,
        systemMode: ee
      }), [Q, ze, le, oe, De, ke, Z, ee, He.colorSchemeSelector]);
      let Xe = !0;
      (F || L.cssVariables === !1 || W && B?.cssVarPrefix === V) && (Xe = !1);
      const Ee = /* @__PURE__ */ S.jsxs(C.Fragment, {
        children: [/* @__PURE__ */ S.jsx(RT, {
          themeId: z ? t : void 0,
          theme: He,
          children: w
        }), Xe && /* @__PURE__ */ S.jsx(yT, {
          styles: He.generateStyleSheets?.() || []
        })]
      });
      return W ? Ee : /* @__PURE__ */ S.jsx(c.Provider, {
        value: It,
        children: Ee
      });
    }
    const y = typeof i == "string" ? i : i.light, b = typeof i == "string" ? i : i.dark;
    return {
      CssVarsProvider: h,
      useColorScheme: f,
      getInitColorSchemeScript: (v) => eJ({
        colorSchemeStorageKey: o,
        defaultLightColorScheme: y,
        defaultDarkColorScheme: b,
        modeStorageKey: r,
        ...v
      })
    };
  }
  function sJ(e = "") {
    function t(...n) {
      if (!n.length)
        return "";
      const r = n[0];
      return typeof r == "string" && !r.match(/(#|\(|\)|(-?(\d*\.)?\d+)(px|em|%|ex|ch|rem|vw|vh|vmin|vmax|cm|mm|in|pt|pc))|^(-?(\d*\.)?\d+)$|(\d+ \d+ \d+)/) ? `, var(--${e ? `${e}-` : ""}${r}${t(...n.slice(1))})` : `, ${r}`;
    }
    return (n, ...r) => `var(--${e ? `${e}-` : ""}${n}${t(...r)})`;
  }
  const X5 = (e, t, n, r = []) => {
    let o = e;
    t.forEach((a, i) => {
      i === t.length - 1 ? Array.isArray(o) ? o[Number(a)] = n : o && typeof o == "object" && (o[a] = n) : o && typeof o == "object" && (o[a] || (o[a] = r.includes(a) ? [] : {}), o = o[a]);
    });
  }, lJ = (e, t, n) => {
    function r(o, a = [], i = []) {
      Object.entries(o).forEach(([s, u]) => {
        (!n || n && !n([...a, s])) && u != null && (typeof u == "object" && Object.keys(u).length > 0 ? r(u, [...a, s], Array.isArray(u) ? [...i, s] : i) : t([...a, s], u, i));
      });
    }
    r(e);
  }, uJ = (e, t) => typeof t == "number" ? ["lineHeight", "fontWeight", "opacity", "zIndex"].some((n) => e.includes(n)) || e[e.length - 1].toLowerCase().includes("opacity") ? t : `${t}px` : t;
  function d_(e, t) {
    const {
      prefix: n,
      shouldSkipGeneratingVar: r
    } = t || {}, o = {}, a = {}, i = {};
    return lJ(
      e,
      (s, u, c) => {
        if ((typeof u == "string" || typeof u == "number") && (!r || !r(s, u))) {
          const f = `--${n ? `${n}-` : ""}${s.join("-")}`, p = uJ(s, u);
          Object.assign(o, {
            [f]: p
          }), X5(a, s, `var(${f})`, c), X5(i, s, `var(${f}, ${p})`, c);
        }
      },
      (s) => s[0] === "vars"
      // skip 'vars/*' paths
    ), {
      css: o,
      vars: a,
      varsWithDefaults: i
    };
  }
  function cJ(e, t = {}) {
    const {
      getSelector: n = w,
      disableCssColorScheme: r,
      colorSchemeSelector: o,
      enableContrastVars: a
    } = t, {
      colorSchemes: i = {},
      components: s,
      defaultColorScheme: u = "light",
      ...c
    } = e, {
      vars: f,
      css: p,
      varsWithDefaults: g
    } = d_(c, t);
    let h = g;
    const y = {}, {
      [u]: b,
      ...v
    } = i;
    if (Object.entries(v || {}).forEach(([_, k]) => {
      const {
        vars: E,
        css: P,
        varsWithDefaults: O
      } = d_(k, t);
      h = wr(h, O), y[_] = {
        css: P,
        vars: E
      };
    }), b) {
      const {
        css: _,
        vars: k,
        varsWithDefaults: E
      } = d_(b, t);
      h = wr(h, E), y[u] = {
        css: _,
        vars: k
      };
    }
    function w(_, k) {
      let E = o;
      if (o === "class" && (E = ".%s"), o === "data" && (E = "[data-%s]"), o?.startsWith("data-") && !o.includes("%s") && (E = `[${o}="%s"]`), _) {
        if (E === "media")
          return e.defaultColorScheme === _ ? ":root" : {
            [`@media (prefers-color-scheme: ${i[_]?.palette?.mode || _})`]: {
              ":root": k
            }
          };
        if (E)
          return e.defaultColorScheme === _ ? `:root, ${E.replace("%s", String(_))}` : E.replace("%s", String(_));
      }
      return ":root";
    }
    return {
      vars: h,
      generateThemeVars: () => {
        let _ = {
          ...f
        };
        return Object.entries(y).forEach(([, {
          vars: k
        }]) => {
          _ = wr(_, k);
        }), _;
      },
      generateStyleSheets: () => {
        const _ = [], k = e.defaultColorScheme || "light";
        function E(M, I) {
          Object.keys(I).length && _.push(typeof M == "string" ? {
            [M]: {
              ...I
            }
          } : M);
        }
        E(n(void 0, {
          ...p
        }), p);
        const {
          [k]: P,
          ...O
        } = y;
        if (P) {
          const {
            css: M
          } = P, I = i[k]?.palette?.mode, A = !r && I ? {
            colorScheme: I,
            ...M
          } : {
            ...M
          };
          E(n(k, {
            ...A
          }), A);
        }
        return Object.entries(O).forEach(([M, {
          css: I
        }]) => {
          const A = i[M]?.palette?.mode, D = !r && A ? {
            colorScheme: A,
            ...I
          } : {
            ...I
          };
          E(n(M, {
            ...D
          }), D);
        }), a && _.push({
          ":root": {
            // use double underscore to indicate that these are private variables
            "--__l-threshold": "0.7",
            "--__l": "clamp(0, (l / var(--__l-threshold) - 1) * -infinity, 1)",
            "--__a": "clamp(0.87, (l / var(--__l-threshold) - 1) * -infinity, 1)"
            // 0.87 is the default alpha value for black text.
          }
        }), _;
      }
    };
  }
  function dJ(e) {
    return function(t) {
      return e === "media" ? `@media (prefers-color-scheme: ${t})` : e ? e.startsWith("data-") && !e.includes("%s") ? `[${e}="${t}"] &` : e === "class" ? `.${t} &` : e === "data" ? `[data-${t}] &` : `${e.replace("%s", t)} &` : "&";
    };
  }
  function Op(e, t) {
    return /* @__PURE__ */ C.isValidElement(e) && t.indexOf(
      // For server components `muiName` is available in element.type._payload.value.muiName
      // relevant info - https://github.com/facebook/react/blob/2807d781a08db8e9873687fccc25c0f12b4fb3d4/packages/react/src/ReactLazy.js#L45
      // eslint-disable-next-line no-underscore-dangle
      e.type.muiName ?? e.type?._payload?.value?.muiName
    ) !== -1;
  }
  const fJ = (e, t) => e.filter((n) => t.includes(n)), Dd = (e, t, n) => {
    const r = e.keys[0];
    Array.isArray(t) ? t.forEach((o, a) => {
      n((i, s) => {
        a <= e.keys.length - 1 && (a === 0 ? Object.assign(i, s) : i[e.up(e.keys[a])] = s);
      }, o);
    }) : t && typeof t == "object" ? (Object.keys(t).length > e.keys.length ? e.keys : fJ(e.keys, Object.keys(t))).forEach((o) => {
      if (e.keys.includes(o)) {
        const a = t[o];
        a !== void 0 && n((i, s) => {
          r === o ? Object.assign(i, s) : i[e.up(o)] = s;
        }, a);
      }
    }) : (typeof t == "number" || typeof t == "string") && n((o, a) => {
      Object.assign(o, a);
    }, t);
  };
  function Zy(e) {
    return `--Grid-${e}Spacing`;
  }
  function pw(e) {
    return `--Grid-parent-${e}Spacing`;
  }
  const Y5 = "--Grid-columns", ed = "--Grid-parent-columns", pJ = ({
    theme: e,
    ownerState: t
  }) => {
    const n = {};
    return Dd(e.breakpoints, t.size, (r, o) => {
      let a = {};
      o === "grow" && (a = {
        flexBasis: 0,
        flexGrow: 1,
        maxWidth: "100%"
      }), o === "auto" && (a = {
        flexBasis: "auto",
        flexGrow: 0,
        flexShrink: 0,
        maxWidth: "none",
        width: "auto"
      }), typeof o == "number" && (a = {
        flexGrow: 0,
        flexBasis: "auto",
        width: `calc(100% * ${o} / var(${ed}) - (var(${ed}) - ${o}) * (var(${pw("column")}) / var(${ed})))`
      }), r(n, a);
    }), n;
  }, mJ = ({
    theme: e,
    ownerState: t
  }) => {
    const n = {};
    return Dd(e.breakpoints, t.offset, (r, o) => {
      let a = {};
      o === "auto" && (a = {
        marginLeft: "auto"
      }), typeof o == "number" && (a = {
        marginLeft: o === 0 ? "0px" : `calc(100% * ${o} / var(${ed}) + var(${pw("column")}) * ${o} / var(${ed}))`
      }), r(n, a);
    }), n;
  }, hJ = ({
    theme: e,
    ownerState: t
  }) => {
    if (!t.container)
      return {};
    const n = {
      [Y5]: 12
    };
    return Dd(e.breakpoints, t.columns, (r, o) => {
      const a = o ?? 12;
      r(n, {
        [Y5]: a,
        "> *": {
          [ed]: a
        }
      });
    }), n;
  }, gJ = ({
    theme: e,
    ownerState: t
  }) => {
    if (!t.container)
      return {};
    const n = {};
    return Dd(e.breakpoints, t.rowSpacing, (r, o) => {
      const a = typeof o == "string" ? o : e.spacing?.(o);
      r(n, {
        [Zy("row")]: a,
        "> *": {
          [pw("row")]: a
        }
      });
    }), n;
  }, vJ = ({
    theme: e,
    ownerState: t
  }) => {
    if (!t.container)
      return {};
    const n = {};
    return Dd(e.breakpoints, t.columnSpacing, (r, o) => {
      const a = typeof o == "string" ? o : e.spacing?.(o);
      r(n, {
        [Zy("column")]: a,
        "> *": {
          [pw("column")]: a
        }
      });
    }), n;
  }, yJ = ({
    theme: e,
    ownerState: t
  }) => {
    if (!t.container)
      return {};
    const n = {};
    return Dd(e.breakpoints, t.direction, (r, o) => {
      r(n, {
        flexDirection: o
      });
    }), n;
  }, bJ = ({
    ownerState: e
  }) => ({
    minWidth: 0,
    boxSizing: "border-box",
    ...e.container && {
      display: "flex",
      flexWrap: "wrap",
      ...e.wrap && e.wrap !== "wrap" && {
        flexWrap: e.wrap
      },
      gap: `var(${Zy("row")}) var(${Zy("column")})`
    }
  }), wJ = (e) => {
    const t = [];
    return Object.entries(e).forEach(([n, r]) => {
      r !== !1 && r !== void 0 && t.push(`grid-${n}-${String(r)}`);
    }), t;
  }, xJ = (e, t = "xs") => {
    function n(r) {
      return r === void 0 ? !1 : typeof r == "string" && !Number.isNaN(Number(r)) || typeof r == "number" && r > 0;
    }
    if (n(e))
      return [`spacing-${t}-${String(e)}`];
    if (typeof e == "object" && !Array.isArray(e)) {
      const r = [];
      return Object.entries(e).forEach(([o, a]) => {
        n(a) && r.push(`spacing-${o}-${String(a)}`);
      }), r;
    }
    return [];
  }, kJ = (e) => e === void 0 ? [] : typeof e == "object" ? Object.entries(e).map(([t, n]) => `direction-${t}-${n}`) : [`direction-xs-${String(e)}`];
  function SJ(e, t) {
    const n = [];
    e.item !== void 0 && (delete e.item, n.push("item")), e.zeroMinWidth !== void 0 && (delete e.zeroMinWidth, n.push("zeroMinWidth")), t.keys.forEach((r) => {
      e[r] !== void 0 && (n.push(r), delete e[r]);
    });
  }
  const _J = uw(), EJ = AY("div", {
    name: "MuiGrid",
    slot: "Root"
  });
  function CJ(e) {
    return DY({
      props: e,
      name: "MuiGrid",
      defaultTheme: _J
    });
  }
  function PJ(e = {}) {
    const {
      // This will allow adding custom styled fn (for example for custom sx style function)
      createStyledComponent: t = EJ,
      useThemeProps: n = CJ,
      useTheme: r = Tm,
      componentName: o = "MuiGrid"
    } = e, a = (c, f) => {
      const {
        container: p,
        direction: g,
        spacing: h,
        wrap: y,
        size: b
      } = c, v = {
        root: ["root", p && "container", y !== "wrap" && `wrap-xs-${String(y)}`, ...kJ(g), ...wJ(b), ...p ? xJ(h, f.breakpoints.keys[0]) : []]
      };
      return nt(v, (w) => rt(o, w), {});
    };
    function i(c, f, p = () => !0) {
      const g = {};
      return c === null || (Array.isArray(c) ? c.forEach((h, y) => {
        h !== null && p(h) && f.keys[y] && (g[f.keys[y]] = h);
      }) : typeof c == "object" ? Object.keys(c).forEach((h) => {
        const y = c[h];
        y != null && p(y) && (g[h] = y);
      }) : g[f.keys[0]] = c), g;
    }
    const s = t(hJ, vJ, gJ, pJ, yJ, bJ, mJ), u = /* @__PURE__ */ C.forwardRef(function(c, f) {
      const p = r(), g = n(c), h = YE(g);
      SJ(h, p.breakpoints);
      const {
        className: y,
        children: b,
        columns: v = 12,
        container: w = !1,
        component: _ = "div",
        direction: k = "row",
        wrap: E = "wrap",
        size: P = {},
        offset: O = {},
        spacing: M = 0,
        rowSpacing: I = M,
        columnSpacing: A = M,
        unstable_level: D = 0,
        ...F
      } = h, j = i(P, p.breakpoints, (z) => z !== !1), U = i(O, p.breakpoints), $ = c.columns ?? (D ? void 0 : v), q = c.spacing ?? (D ? void 0 : M), B = c.rowSpacing ?? c.spacing ?? (D ? void 0 : I), G = c.columnSpacing ?? c.spacing ?? (D ? void 0 : A), W = {
        ...h,
        level: D,
        columns: $,
        container: w,
        direction: k,
        wrap: E,
        spacing: q,
        rowSpacing: B,
        columnSpacing: G,
        size: j,
        offset: U
      }, Y = a(W, p);
      return /* @__PURE__ */ S.jsx(s, {
        ref: f,
        as: _,
        ownerState: W,
        className: Le(Y.root, y),
        ...F,
        children: C.Children.map(b, (z) => /* @__PURE__ */ C.isValidElement(z) && Op(z, ["Grid"]) && w && z.props.container ? /* @__PURE__ */ C.cloneElement(z, {
          unstable_level: z.props?.unstable_level ?? D + 1
        }) : z)
      });
    });
    return u.muiName = "Grid", u;
  }
  const Jp = {
    black: "#000",
    white: "#fff"
  }, OJ = {
    50: "#fafafa",
    100: "#f5f5f5",
    200: "#eeeeee",
    300: "#e0e0e0",
    400: "#bdbdbd",
    500: "#9e9e9e",
    600: "#757575",
    700: "#616161",
    800: "#424242",
    900: "#212121",
    A100: "#f5f5f5",
    A200: "#eeeeee",
    A400: "#bdbdbd",
    A700: "#616161"
  }, yc = {
    50: "#f3e5f5",
    200: "#ce93d8",
    300: "#ba68c8",
    400: "#ab47bc",
    500: "#9c27b0",
    700: "#7b1fa2"
  }, bc = {
    300: "#e57373",
    400: "#ef5350",
    500: "#f44336",
    700: "#d32f2f",
    800: "#c62828"
  }, Kf = {
    300: "#ffb74d",
    400: "#ffa726",
    500: "#ff9800",
    700: "#f57c00",
    900: "#e65100"
  }, wc = {
    50: "#e3f2fd",
    200: "#90caf9",
    400: "#42a5f5",
    700: "#1976d2",
    800: "#1565c0"
  }, xc = {
    300: "#4fc3f7",
    400: "#29b6f6",
    500: "#03a9f4",
    700: "#0288d1",
    900: "#01579b"
  }, kc = {
    300: "#81c784",
    400: "#66bb6a",
    500: "#4caf50",
    700: "#388e3c",
    800: "#2e7d32",
    900: "#1b5e20"
  };
  function IT() {
    return {
      // The colors used to style the text.
      text: {
        // The most important text.
        primary: "rgba(0, 0, 0, 0.87)",
        // Secondary text.
        secondary: "rgba(0, 0, 0, 0.6)",
        // Disabled text have even lower visual prominence.
        disabled: "rgba(0, 0, 0, 0.38)"
      },
      // The color used to divide different elements.
      divider: "rgba(0, 0, 0, 0.12)",
      // The background colors used to style the surfaces.
      // Consistency between these values is important.
      background: {
        paper: Jp.white,
        default: Jp.white
      },
      // The colors used to style the action elements.
      action: {
        // The color of an active action like an icon button.
        active: "rgba(0, 0, 0, 0.54)",
        // The color of an hovered action.
        hover: "rgba(0, 0, 0, 0.04)",
        hoverOpacity: 0.04,
        // The color of a selected action.
        selected: "rgba(0, 0, 0, 0.08)",
        selectedOpacity: 0.08,
        // The color of a disabled action.
        disabled: "rgba(0, 0, 0, 0.26)",
        // The background color of a disabled action.
        disabledBackground: "rgba(0, 0, 0, 0.12)",
        disabledOpacity: 0.38,
        focus: "rgba(0, 0, 0, 0.12)",
        focusOpacity: 0.12,
        activatedOpacity: 0.12
      }
    };
  }
  const AT = IT();
  function $T() {
    return {
      text: {
        primary: Jp.white,
        secondary: "rgba(255, 255, 255, 0.7)",
        disabled: "rgba(255, 255, 255, 0.5)",
        icon: "rgba(255, 255, 255, 0.5)"
      },
      divider: "rgba(255, 255, 255, 0.12)",
      background: {
        paper: "#121212",
        default: "#121212"
      },
      action: {
        active: Jp.white,
        hover: "rgba(255, 255, 255, 0.08)",
        hoverOpacity: 0.08,
        selected: "rgba(255, 255, 255, 0.16)",
        selectedOpacity: 0.16,
        disabled: "rgba(255, 255, 255, 0.3)",
        disabledBackground: "rgba(255, 255, 255, 0.12)",
        disabledOpacity: 0.38,
        focus: "rgba(255, 255, 255, 0.12)",
        focusOpacity: 0.12,
        activatedOpacity: 0.24
      }
    };
  }
  const o2 = $T();
  function J5(e, t, n, r) {
    const o = r.light || r, a = r.dark || r * 1.5;
    e[t] || (e.hasOwnProperty(n) ? e[t] = e[n] : t === "light" ? e.light = fw(e.main, o) : t === "dark" && (e.dark = dw(e.main, a)));
  }
  function Q5(e, t, n, r, o) {
    const a = o.light || o, i = o.dark || o * 1.5;
    t[n] || (t.hasOwnProperty(r) ? t[n] = t[r] : n === "light" ? t.light = `color-mix(in ${e}, ${t.main}, #fff ${(a * 100).toFixed(0)}%)` : n === "dark" && (t.dark = `color-mix(in ${e}, ${t.main}, #000 ${(i * 100).toFixed(0)}%)`));
  }
  function NJ(e = "light") {
    return e === "dark" ? {
      main: wc[200],
      light: wc[50],
      dark: wc[400]
    } : {
      main: wc[700],
      light: wc[400],
      dark: wc[800]
    };
  }
  function MJ(e = "light") {
    return e === "dark" ? {
      main: yc[200],
      light: yc[50],
      dark: yc[400]
    } : {
      main: yc[500],
      light: yc[300],
      dark: yc[700]
    };
  }
  function RJ(e = "light") {
    return e === "dark" ? {
      main: bc[500],
      light: bc[300],
      dark: bc[700]
    } : {
      main: bc[700],
      light: bc[400],
      dark: bc[800]
    };
  }
  function jJ(e = "light") {
    return e === "dark" ? {
      main: xc[400],
      light: xc[300],
      dark: xc[700]
    } : {
      main: xc[700],
      light: xc[500],
      dark: xc[900]
    };
  }
  function IJ(e = "light") {
    return e === "dark" ? {
      main: kc[400],
      light: kc[300],
      dark: kc[700]
    } : {
      main: kc[800],
      light: kc[500],
      dark: kc[900]
    };
  }
  function AJ(e = "light") {
    return e === "dark" ? {
      main: Kf[400],
      light: Kf[300],
      dark: Kf[700]
    } : {
      main: "#ed6c02",
      // closest to orange[800] that pass 3:1.
      light: Kf[500],
      dark: Kf[900]
    };
  }
  function $J(e) {
    return `oklch(from ${e} var(--__l) 0 h / var(--__a))`;
  }
  function uC(e) {
    const {
      mode: t = "light",
      contrastThreshold: n = 3,
      tonalOffset: r = 0.2,
      colorSpace: o,
      ...a
    } = e, i = e.primary || NJ(t), s = e.secondary || MJ(t), u = e.error || RJ(t), c = e.info || jJ(t), f = e.success || IJ(t), p = e.warning || AJ(t);
    function g(b) {
      return o ? $J(b) : TY(b, o2.text.primary) >= n ? o2.text.primary : AT.text.primary;
    }
    const h = ({
      color: b,
      name: v,
      mainShade: w = 500,
      lightShade: _ = 300,
      darkShade: k = 700
    }) => {
      if (b = {
        ...b
      }, !b.main && b[w] && (b.main = b[w]), !b.hasOwnProperty("main"))
        throw new Error(Vi(11, v ? ` (${v})` : "", w));
      if (typeof b.main != "string")
        throw new Error(Vi(12, v ? ` (${v})` : "", JSON.stringify(b.main)));
      return o ? (Q5(o, b, "light", _, r), Q5(o, b, "dark", k, r)) : (J5(b, "light", _, r), J5(b, "dark", k, r)), b.contrastText || (b.contrastText = g(b.main)), b;
    };
    let y;
    return t === "light" ? y = IT() : t === "dark" && (y = $T()), wr({
      // A collection of common colors.
      common: {
        ...Jp
      },
      // prevent mutable object.
      // The palette mode, can be light or dark.
      mode: t,
      // The colors used to represent primary interface elements for a user.
      primary: h({
        color: i,
        name: "primary"
      }),
      // The colors used to represent secondary interface elements for a user.
      secondary: h({
        color: s,
        name: "secondary",
        mainShade: "A400",
        lightShade: "A200",
        darkShade: "A700"
      }),
      // The colors used to represent interface elements that the user should be made aware of.
      error: h({
        color: u,
        name: "error"
      }),
      // The colors used to represent potentially dangerous actions or important messages.
      warning: h({
        color: p,
        name: "warning"
      }),
      // The colors used to present information to the user that is neutral and not necessarily important.
      info: h({
        color: c,
        name: "info"
      }),
      // The colors used to indicate the successful completion of an action that user triggered.
      success: h({
        color: f,
        name: "success"
      }),
      // The grey colors.
      grey: OJ,
      // Used by `getContrastText()` to maximize the contrast between
      // the background and the text.
      contrastThreshold: n,
      // Takes a background color and returns the text color that maximizes the contrast.
      getContrastText: g,
      // Generate a rich color object.
      augmentColor: h,
      // Used by the functions below to shift a color's luminance by approximately
      // two indexes within its tonal palette.
      // E.g., shift from Red 500 to Red 300 or Red 700.
      tonalOffset: r,
      // The light and dark mode object.
      ...y
    }, a);
  }
  function DJ(e) {
    const t = {};
    return Object.entries(e).forEach((n) => {
      const [r, o] = n;
      typeof o == "object" && (t[r] = `${o.fontStyle ? `${o.fontStyle} ` : ""}${o.fontVariant ? `${o.fontVariant} ` : ""}${o.fontWeight ? `${o.fontWeight} ` : ""}${o.fontStretch ? `${o.fontStretch} ` : ""}${o.fontSize || ""}${o.lineHeight ? `/${o.lineHeight} ` : ""}${o.fontFamily || ""}`);
    }), t;
  }
  function LJ(e, t) {
    return {
      toolbar: {
        minHeight: 56,
        [e.up("xs")]: {
          "@media (orientation: landscape)": {
            minHeight: 48
          }
        },
        [e.up("sm")]: {
          minHeight: 64
        }
      },
      ...t
    };
  }
  function FJ(e) {
    return Math.round(e * 1e5) / 1e5;
  }
  const Z5 = {
    textTransform: "uppercase"
  }, eI = '"Roboto", "Helvetica", "Arial", sans-serif';
  function DT(e, t) {
    const {
      fontFamily: n = eI,
      // The default font size of the Material Specification.
      fontSize: r = 14,
      // px
      fontWeightLight: o = 300,
      fontWeightRegular: a = 400,
      fontWeightMedium: i = 500,
      fontWeightBold: s = 700,
      // Tell MUI what's the font-size on the html element.
      // 16px is the default font-size used by browsers.
      htmlFontSize: u = 16,
      // Apply the CSS properties to all the variants.
      allVariants: c,
      pxToRem: f,
      ...p
    } = typeof t == "function" ? t(e) : t, g = r / 14, h = f || ((v) => `${v / u * g}rem`), y = (v, w, _, k, E) => ({
      fontFamily: n,
      fontWeight: v,
      fontSize: h(w),
      // Unitless following https://meyerweb.com/eric/thoughts/2006/02/08/unitless-line-heights/
      lineHeight: _,
      // The letter spacing was designed for the Roboto font-family. Using the same letter-spacing
      // across font-families can cause issues with the kerning.
      ...n === eI ? {
        letterSpacing: `${FJ(k / w)}em`
      } : {},
      ...E,
      ...c
    }), b = {
      h1: y(o, 96, 1.167, -1.5),
      h2: y(o, 60, 1.2, -0.5),
      h3: y(a, 48, 1.167, 0),
      h4: y(a, 34, 1.235, 0.25),
      h5: y(a, 24, 1.334, 0),
      h6: y(i, 20, 1.6, 0.15),
      subtitle1: y(a, 16, 1.75, 0.15),
      subtitle2: y(i, 14, 1.57, 0.1),
      body1: y(a, 16, 1.5, 0.15),
      body2: y(a, 14, 1.43, 0.15),
      button: y(i, 14, 1.75, 0.4, Z5),
      caption: y(a, 12, 1.66, 0.4),
      overline: y(a, 12, 2.66, 1, Z5),
      // TODO v6: Remove handling of 'inherit' variant from the theme as it is already handled in Material UI's Typography component. Also, remember to remove the associated types.
      inherit: {
        fontFamily: "inherit",
        fontWeight: "inherit",
        fontSize: "inherit",
        lineHeight: "inherit",
        letterSpacing: "inherit"
      }
    };
    return wr({
      htmlFontSize: u,
      pxToRem: h,
      fontFamily: n,
      fontSize: r,
      fontWeightLight: o,
      fontWeightRegular: a,
      fontWeightMedium: i,
      fontWeightBold: s,
      ...b
    }, p, {
      clone: !1
      // No need to clone deep
    });
  }
  const TJ = 0.2, zJ = 0.14, BJ = 0.12;
  function xn(...e) {
    return [`${e[0]}px ${e[1]}px ${e[2]}px ${e[3]}px rgba(0,0,0,${TJ})`, `${e[4]}px ${e[5]}px ${e[6]}px ${e[7]}px rgba(0,0,0,${zJ})`, `${e[8]}px ${e[9]}px ${e[10]}px ${e[11]}px rgba(0,0,0,${BJ})`].join(",");
  }
  const VJ = ["none", xn(0, 2, 1, -1, 0, 1, 1, 0, 0, 1, 3, 0), xn(0, 3, 1, -2, 0, 2, 2, 0, 0, 1, 5, 0), xn(0, 3, 3, -2, 0, 3, 4, 0, 0, 1, 8, 0), xn(0, 2, 4, -1, 0, 4, 5, 0, 0, 1, 10, 0), xn(0, 3, 5, -1, 0, 5, 8, 0, 0, 1, 14, 0), xn(0, 3, 5, -1, 0, 6, 10, 0, 0, 1, 18, 0), xn(0, 4, 5, -2, 0, 7, 10, 1, 0, 2, 16, 1), xn(0, 5, 5, -3, 0, 8, 10, 1, 0, 3, 14, 2), xn(0, 5, 6, -3, 0, 9, 12, 1, 0, 3, 16, 2), xn(0, 6, 6, -3, 0, 10, 14, 1, 0, 4, 18, 3), xn(0, 6, 7, -4, 0, 11, 15, 1, 0, 4, 20, 3), xn(0, 7, 8, -4, 0, 12, 17, 2, 0, 5, 22, 4), xn(0, 7, 8, -4, 0, 13, 19, 2, 0, 5, 24, 4), xn(0, 7, 9, -4, 0, 14, 21, 2, 0, 5, 26, 4), xn(0, 8, 9, -5, 0, 15, 22, 2, 0, 6, 28, 5), xn(0, 8, 10, -5, 0, 16, 24, 2, 0, 6, 30, 5), xn(0, 8, 11, -5, 0, 17, 26, 2, 0, 6, 32, 5), xn(0, 9, 11, -5, 0, 18, 28, 2, 0, 7, 34, 6), xn(0, 9, 12, -6, 0, 19, 29, 2, 0, 7, 36, 6), xn(0, 10, 13, -6, 0, 20, 31, 3, 0, 8, 38, 7), xn(0, 10, 13, -6, 0, 21, 33, 3, 0, 8, 40, 7), xn(0, 10, 14, -6, 0, 22, 35, 3, 0, 8, 42, 7), xn(0, 11, 14, -7, 0, 23, 36, 3, 0, 9, 44, 8), xn(0, 11, 15, -7, 0, 24, 38, 3, 0, 9, 46, 8)], UJ = {
    // This is the most common easing curve.
    easeInOut: "cubic-bezier(0.4, 0, 0.2, 1)",
    // Objects enter the screen at full velocity from off-screen and
    // slowly decelerate to a resting point.
    easeOut: "cubic-bezier(0.0, 0, 0.2, 1)",
    // Objects leave the screen at full velocity. They do not decelerate when off-screen.
    easeIn: "cubic-bezier(0.4, 0, 1, 1)",
    // The sharp curve is used by objects that may return to the screen at any time.
    sharp: "cubic-bezier(0.4, 0, 0.6, 1)"
  }, HJ = {
    shortest: 150,
    shorter: 200,
    short: 250,
    // most basic recommended timing
    standard: 300,
    // this is to be used in complex animations
    complex: 375,
    // recommended when something is entering screen
    enteringScreen: 225,
    // recommended when something is leaving screen
    leavingScreen: 195
  };
  function tI(e) {
    return `${Math.round(e)}ms`;
  }
  function WJ(e) {
    if (!e)
      return 0;
    const t = e / 36;
    return Math.min(Math.round((4 + 15 * t ** 0.25 + t / 5) * 10), 3e3);
  }
  function qJ(e) {
    const t = {
      ...UJ,
      ...e.easing
    }, n = {
      ...HJ,
      ...e.duration
    };
    return {
      getAutoHeightDuration: WJ,
      create: (r = ["all"], o = {}) => {
        const {
          duration: a = n.standard,
          easing: i = t.easeInOut,
          delay: s = 0,
          ...u
        } = o;
        return (Array.isArray(r) ? r : [r]).map((c) => `${c} ${typeof a == "string" ? a : tI(a)} ${i} ${typeof s == "string" ? s : tI(s)}`).join(",");
      },
      ...e,
      easing: t,
      duration: n
    };
  }
  const KJ = {
    mobileStepper: 1e3,
    fab: 1050,
    speedDial: 1050,
    appBar: 1100,
    drawer: 1200,
    modal: 1300,
    snackbar: 1400,
    tooltip: 1500
  };
  function GJ(e) {
    return Na(e) || typeof e > "u" || typeof e == "string" || typeof e == "boolean" || typeof e == "number" || Array.isArray(e);
  }
  function LT(e = {}) {
    const t = {
      ...e
    };
    function n(r) {
      const o = Object.entries(r);
      for (let a = 0; a < o.length; a++) {
        const [i, s] = o[a];
        !GJ(s) || i.startsWith("unstable_") ? delete r[i] : Na(s) && (r[i] = {
          ...s
        }, n(r[i]));
      }
    }
    return n(t), `import { unstable_createBreakpoints as createBreakpoints, createTransitions } from '@mui/material/styles';

const theme = ${JSON.stringify(t, null, 2)};

theme.breakpoints = createBreakpoints(theme.breakpoints || {});
theme.transitions = createTransitions(theme.transitions || {});

export default theme;`;
  }
  function nI(e) {
    return typeof e == "number" ? `${(e * 100).toFixed(0)}%` : `calc((${e}) * 100%)`;
  }
  const XJ = (e) => {
    if (!Number.isNaN(+e))
      return +e;
    const t = e.match(/\d*\.?\d+/g);
    if (!t)
      return 0;
    let n = 0;
    for (let r = 0; r < t.length; r += 1)
      n += +t[r];
    return n;
  };
  function YJ(e) {
    Object.assign(e, {
      alpha(t, n) {
        const r = this || e;
        return r.colorSpace ? `oklch(from ${t} l c h / ${typeof n == "string" ? `calc(${n})` : n})` : r.vars ? `rgba(${t.replace(/var\(--([^,\s)]+)(?:,[^)]+)?\)+/g, "var(--$1Channel)")} / ${typeof n == "string" ? `calc(${n})` : n})` : Qy(t, XJ(n));
      },
      lighten(t, n) {
        const r = this || e;
        return r.colorSpace ? `color-mix(in ${r.colorSpace}, ${t}, #fff ${nI(n)})` : fw(t, n);
      },
      darken(t, n) {
        const r = this || e;
        return r.colorSpace ? `color-mix(in ${r.colorSpace}, ${t}, #000 ${nI(n)})` : dw(t, n);
      }
    });
  }
  function a2(e = {}, ...t) {
    const {
      breakpoints: n,
      mixins: r = {},
      spacing: o,
      palette: a = {},
      transitions: i = {},
      typography: s = {},
      shape: u,
      colorSpace: c,
      ...f
    } = e;
    if (e.vars && // The error should throw only for the root theme creation because user is not allowed to use a custom node `vars`.
    // `generateThemeVars` is the closest identifier for checking that the `options` is a result of `createTheme` with CSS variables so that user can create new theme for nested ThemeProvider.
    e.generateThemeVars === void 0)
      throw new Error(Vi(20));
    const p = uC({
      ...a,
      colorSpace: c
    }), g = uw(e);
    let h = wr(g, {
      mixins: LJ(g.breakpoints, r),
      palette: p,
      // Don't use [...shadows] until you've verified its transpiled code is not invoking the iterator protocol.
      shadows: VJ.slice(),
      typography: DT(p, s),
      transitions: qJ(i),
      zIndex: {
        ...KJ
      }
    });
    return h = wr(h, f), h = t.reduce((y, b) => wr(y, b), h), h.unstable_sxConfig = {
      ...Am,
      ...f?.unstable_sxConfig
    }, h.unstable_sx = function(y) {
      return nl({
        sx: y,
        theme: this
      });
    }, h.toRuntimeSource = LT, YJ(h), h;
  }
  function i2(e) {
    let t;
    return e < 1 ? t = 5.11916 * e ** 2 : t = 4.5 * Math.log(e + 1) + 2, Math.round(t * 10) / 1e3;
  }
  const JJ = [...Array(25)].map((e, t) => {
    if (t === 0)
      return "none";
    const n = i2(t);
    return `linear-gradient(rgba(255 255 255 / ${n}), rgba(255 255 255 / ${n}))`;
  });
  function FT(e) {
    return {
      inputPlaceholder: e === "dark" ? 0.5 : 0.42,
      inputUnderline: e === "dark" ? 0.7 : 0.42,
      switchTrackDisabled: e === "dark" ? 0.2 : 0.12,
      switchTrack: e === "dark" ? 0.3 : 0.38
    };
  }
  function TT(e) {
    return e === "dark" ? JJ : [];
  }
  function QJ(e) {
    const {
      palette: t = {
        mode: "light"
      },
      // need to cast to avoid module augmentation test
      opacity: n,
      overlays: r,
      colorSpace: o,
      ...a
    } = e, i = uC({
      ...t,
      colorSpace: o
    });
    return {
      palette: i,
      opacity: {
        ...FT(i.mode),
        ...n
      },
      overlays: r || TT(i.mode),
      ...a
    };
  }
  function ZJ(e) {
    return !!e[0].match(/(cssVarPrefix|colorSchemeSelector|modularCssLayers|rootSelector|typography|mixins|breakpoints|direction|transitions)/) || !!e[0].match(/sxConfig$/) || // ends with sxConfig
    e[0] === "palette" && !!e[1]?.match(/(mode|contrastThreshold|tonalOffset)/);
  }
  const eQ = (e) => [...[...Array(25)].map((t, n) => `--${e ? `${e}-` : ""}overlays-${n}`), `--${e ? `${e}-` : ""}palette-AppBar-darkBg`, `--${e ? `${e}-` : ""}palette-AppBar-darkColor`], tQ = (e) => (t, n) => {
    const r = e.rootSelector || ":root", o = e.colorSchemeSelector;
    let a = o;
    if (o === "class" && (a = ".%s"), o === "data" && (a = "[data-%s]"), o?.startsWith("data-") && !o.includes("%s") && (a = `[${o}="%s"]`), e.defaultColorScheme === t) {
      if (t === "dark") {
        const i = {};
        return eQ(e.cssVarPrefix).forEach((s) => {
          i[s] = n[s], delete n[s];
        }), a === "media" ? {
          [r]: n,
          "@media (prefers-color-scheme: dark)": {
            [r]: i
          }
        } : a ? {
          [a.replace("%s", t)]: i,
          [`${r}, ${a.replace("%s", t)}`]: n
        } : {
          [r]: {
            ...n,
            ...i
          }
        };
      }
      if (a && a !== "media")
        return `${r}, ${a.replace("%s", String(t))}`;
    } else if (t) {
      if (a === "media")
        return {
          [`@media (prefers-color-scheme: ${String(t)})`]: {
            [r]: n
          }
        };
      if (a)
        return a.replace("%s", String(t));
    }
    return r;
  };
  function nQ(e, t) {
    t.forEach((n) => {
      e[n] || (e[n] = {});
    });
  }
  function ye(e, t, n) {
    !e[t] && n && (e[t] = n);
  }
  function hp(e) {
    return typeof e != "string" || !e.startsWith("hsl") ? e : CT(e);
  }
  function _i(e, t) {
    `${t}Channel` in e || (e[`${t}Channel`] = mp(hp(e[t])));
  }
  function rQ(e) {
    return typeof e == "number" ? `${e}px` : typeof e == "string" || typeof e == "function" || Array.isArray(e) ? e : "8px";
  }
  const ga = (e) => {
    try {
      return e();
    } catch {
    }
  }, oQ = (e = "mui") => sJ(e);
  function f_(e, t, n, r, o) {
    if (!n)
      return;
    n = n === !0 ? {} : n;
    const a = o === "dark" ? "dark" : "light";
    if (!r) {
      t[o] = QJ({
        ...n,
        palette: {
          mode: a,
          ...n?.palette
        },
        colorSpace: e
      });
      return;
    }
    const {
      palette: i,
      ...s
    } = a2({
      ...r,
      palette: {
        mode: a,
        ...n?.palette
      },
      colorSpace: e
    });
    return t[o] = {
      ...n,
      palette: i,
      opacity: {
        ...FT(a),
        ...n?.opacity
      },
      overlays: n?.overlays || TT(a)
    }, s;
  }
  function aQ(e = {}, ...t) {
    const {
      colorSchemes: n = {
        light: !0
      },
      defaultColorScheme: r,
      disableCssColorScheme: o = !1,
      cssVarPrefix: a = "mui",
      nativeColor: i = !1,
      shouldSkipGeneratingVar: s = ZJ,
      colorSchemeSelector: u = n.light && n.dark ? "media" : void 0,
      rootSelector: c = ":root",
      ...f
    } = e, p = Object.keys(n)[0], g = r || (n.light && p !== "light" ? "light" : p), h = oQ(a), {
      [g]: y,
      light: b,
      dark: v,
      ...w
    } = n, _ = {
      ...w
    };
    let k = y;
    if ((g === "dark" && !("dark" in n) || g === "light" && !("light" in n)) && (k = !0), !k)
      throw new Error(Vi(21, g));
    let E;
    i && (E = "oklch");
    const P = f_(E, _, k, f, g);
    b && !_.light && f_(E, _, b, void 0, "light"), v && !_.dark && f_(E, _, v, void 0, "dark");
    let O = {
      defaultColorScheme: g,
      ...P,
      cssVarPrefix: a,
      colorSchemeSelector: u,
      rootSelector: c,
      getCssVar: h,
      colorSchemes: _,
      font: {
        ...DJ(P.typography),
        ...P.font
      },
      spacing: rQ(f.spacing)
    };
    Object.keys(O.colorSchemes).forEach((F) => {
      const j = O.colorSchemes[F].palette, U = (q) => {
        const B = q.split("-"), G = B[1], W = B[2];
        return h(q, j[G][W]);
      };
      j.mode === "light" && (ye(j.common, "background", "#fff"), ye(j.common, "onBackground", "#000")), j.mode === "dark" && (ye(j.common, "background", "#000"), ye(j.common, "onBackground", "#fff"));
      function $(q, B, G) {
        if (E) {
          let W;
          return q === Tl && (W = `transparent ${((1 - G) * 100).toFixed(0)}%`), q === Xt && (W = `#000 ${(G * 100).toFixed(0)}%`), q === Yt && (W = `#fff ${(G * 100).toFixed(0)}%`), `color-mix(in ${E}, ${B}, ${W})`;
        }
        return q(B, G);
      }
      if (nQ(j, ["Alert", "AppBar", "Avatar", "Button", "Chip", "FilledInput", "LinearProgress", "Skeleton", "Slider", "SnackbarContent", "SpeedDialAction", "StepConnector", "StepContent", "Switch", "TableCell", "Tooltip"]), j.mode === "light") {
        ye(j.Alert, "errorColor", $(Xt, j.error.light, 0.6)), ye(j.Alert, "infoColor", $(Xt, j.info.light, 0.6)), ye(j.Alert, "successColor", $(Xt, j.success.light, 0.6)), ye(j.Alert, "warningColor", $(Xt, j.warning.light, 0.6)), ye(j.Alert, "errorFilledBg", U("palette-error-main")), ye(j.Alert, "infoFilledBg", U("palette-info-main")), ye(j.Alert, "successFilledBg", U("palette-success-main")), ye(j.Alert, "warningFilledBg", U("palette-warning-main")), ye(j.Alert, "errorFilledColor", ga(() => j.getContrastText(j.error.main))), ye(j.Alert, "infoFilledColor", ga(() => j.getContrastText(j.info.main))), ye(j.Alert, "successFilledColor", ga(() => j.getContrastText(j.success.main))), ye(j.Alert, "warningFilledColor", ga(() => j.getContrastText(j.warning.main))), ye(j.Alert, "errorStandardBg", $(Yt, j.error.light, 0.9)), ye(j.Alert, "infoStandardBg", $(Yt, j.info.light, 0.9)), ye(j.Alert, "successStandardBg", $(Yt, j.success.light, 0.9)), ye(j.Alert, "warningStandardBg", $(Yt, j.warning.light, 0.9)), ye(j.Alert, "errorIconColor", U("palette-error-main")), ye(j.Alert, "infoIconColor", U("palette-info-main")), ye(j.Alert, "successIconColor", U("palette-success-main")), ye(j.Alert, "warningIconColor", U("palette-warning-main")), ye(j.AppBar, "defaultBg", U("palette-grey-100")), ye(j.Avatar, "defaultBg", U("palette-grey-400")), ye(j.Button, "inheritContainedBg", U("palette-grey-300")), ye(j.Button, "inheritContainedHoverBg", U("palette-grey-A100")), ye(j.Chip, "defaultBorder", U("palette-grey-400")), ye(j.Chip, "defaultAvatarColor", U("palette-grey-700")), ye(j.Chip, "defaultIconColor", U("palette-grey-700")), ye(j.FilledInput, "bg", "rgba(0, 0, 0, 0.06)"), ye(j.FilledInput, "hoverBg", "rgba(0, 0, 0, 0.09)"), ye(j.FilledInput, "disabledBg", "rgba(0, 0, 0, 0.12)"), ye(j.LinearProgress, "primaryBg", $(Yt, j.primary.main, 0.62)), ye(j.LinearProgress, "secondaryBg", $(Yt, j.secondary.main, 0.62)), ye(j.LinearProgress, "errorBg", $(Yt, j.error.main, 0.62)), ye(j.LinearProgress, "infoBg", $(Yt, j.info.main, 0.62)), ye(j.LinearProgress, "successBg", $(Yt, j.success.main, 0.62)), ye(j.LinearProgress, "warningBg", $(Yt, j.warning.main, 0.62)), ye(j.Skeleton, "bg", E ? $(Tl, j.text.primary, 0.11) : `rgba(${U("palette-text-primaryChannel")} / 0.11)`), ye(j.Slider, "primaryTrack", $(Yt, j.primary.main, 0.62)), ye(j.Slider, "secondaryTrack", $(Yt, j.secondary.main, 0.62)), ye(j.Slider, "errorTrack", $(Yt, j.error.main, 0.62)), ye(j.Slider, "infoTrack", $(Yt, j.info.main, 0.62)), ye(j.Slider, "successTrack", $(Yt, j.success.main, 0.62)), ye(j.Slider, "warningTrack", $(Yt, j.warning.main, 0.62));
        const q = E ? $(Xt, j.background.default, 0.6825) : Xg(j.background.default, 0.8);
        ye(j.SnackbarContent, "bg", q), ye(j.SnackbarContent, "color", ga(() => E ? o2.text.primary : j.getContrastText(q))), ye(j.SpeedDialAction, "fabHoverBg", Xg(j.background.paper, 0.15)), ye(j.StepConnector, "border", U("palette-grey-400")), ye(j.StepContent, "border", U("palette-grey-400")), ye(j.Switch, "defaultColor", U("palette-common-white")), ye(j.Switch, "defaultDisabledColor", U("palette-grey-100")), ye(j.Switch, "primaryDisabledColor", $(Yt, j.primary.main, 0.62)), ye(j.Switch, "secondaryDisabledColor", $(Yt, j.secondary.main, 0.62)), ye(j.Switch, "errorDisabledColor", $(Yt, j.error.main, 0.62)), ye(j.Switch, "infoDisabledColor", $(Yt, j.info.main, 0.62)), ye(j.Switch, "successDisabledColor", $(Yt, j.success.main, 0.62)), ye(j.Switch, "warningDisabledColor", $(Yt, j.warning.main, 0.62)), ye(j.TableCell, "border", $(Yt, $(Tl, j.divider, 1), 0.88)), ye(j.Tooltip, "bg", $(Tl, j.grey[700], 0.92));
      }
      if (j.mode === "dark") {
        ye(j.Alert, "errorColor", $(Yt, j.error.light, 0.6)), ye(j.Alert, "infoColor", $(Yt, j.info.light, 0.6)), ye(j.Alert, "successColor", $(Yt, j.success.light, 0.6)), ye(j.Alert, "warningColor", $(Yt, j.warning.light, 0.6)), ye(j.Alert, "errorFilledBg", U("palette-error-dark")), ye(j.Alert, "infoFilledBg", U("palette-info-dark")), ye(j.Alert, "successFilledBg", U("palette-success-dark")), ye(j.Alert, "warningFilledBg", U("palette-warning-dark")), ye(j.Alert, "errorFilledColor", ga(() => j.getContrastText(j.error.dark))), ye(j.Alert, "infoFilledColor", ga(() => j.getContrastText(j.info.dark))), ye(j.Alert, "successFilledColor", ga(() => j.getContrastText(j.success.dark))), ye(j.Alert, "warningFilledColor", ga(() => j.getContrastText(j.warning.dark))), ye(j.Alert, "errorStandardBg", $(Xt, j.error.light, 0.9)), ye(j.Alert, "infoStandardBg", $(Xt, j.info.light, 0.9)), ye(j.Alert, "successStandardBg", $(Xt, j.success.light, 0.9)), ye(j.Alert, "warningStandardBg", $(Xt, j.warning.light, 0.9)), ye(j.Alert, "errorIconColor", U("palette-error-main")), ye(j.Alert, "infoIconColor", U("palette-info-main")), ye(j.Alert, "successIconColor", U("palette-success-main")), ye(j.Alert, "warningIconColor", U("palette-warning-main")), ye(j.AppBar, "defaultBg", U("palette-grey-900")), ye(j.AppBar, "darkBg", U("palette-background-paper")), ye(j.AppBar, "darkColor", U("palette-text-primary")), ye(j.Avatar, "defaultBg", U("palette-grey-600")), ye(j.Button, "inheritContainedBg", U("palette-grey-800")), ye(j.Button, "inheritContainedHoverBg", U("palette-grey-700")), ye(j.Chip, "defaultBorder", U("palette-grey-700")), ye(j.Chip, "defaultAvatarColor", U("palette-grey-300")), ye(j.Chip, "defaultIconColor", U("palette-grey-300")), ye(j.FilledInput, "bg", "rgba(255, 255, 255, 0.09)"), ye(j.FilledInput, "hoverBg", "rgba(255, 255, 255, 0.13)"), ye(j.FilledInput, "disabledBg", "rgba(255, 255, 255, 0.12)"), ye(j.LinearProgress, "primaryBg", $(Xt, j.primary.main, 0.5)), ye(j.LinearProgress, "secondaryBg", $(Xt, j.secondary.main, 0.5)), ye(j.LinearProgress, "errorBg", $(Xt, j.error.main, 0.5)), ye(j.LinearProgress, "infoBg", $(Xt, j.info.main, 0.5)), ye(j.LinearProgress, "successBg", $(Xt, j.success.main, 0.5)), ye(j.LinearProgress, "warningBg", $(Xt, j.warning.main, 0.5)), ye(j.Skeleton, "bg", E ? $(Tl, j.text.primary, 0.13) : `rgba(${U("palette-text-primaryChannel")} / 0.13)`), ye(j.Slider, "primaryTrack", $(Xt, j.primary.main, 0.5)), ye(j.Slider, "secondaryTrack", $(Xt, j.secondary.main, 0.5)), ye(j.Slider, "errorTrack", $(Xt, j.error.main, 0.5)), ye(j.Slider, "infoTrack", $(Xt, j.info.main, 0.5)), ye(j.Slider, "successTrack", $(Xt, j.success.main, 0.5)), ye(j.Slider, "warningTrack", $(Xt, j.warning.main, 0.5));
        const q = E ? $(Yt, j.background.default, 0.985) : Xg(j.background.default, 0.98);
        ye(j.SnackbarContent, "bg", q), ye(j.SnackbarContent, "color", ga(() => E ? AT.text.primary : j.getContrastText(q))), ye(j.SpeedDialAction, "fabHoverBg", Xg(j.background.paper, 0.15)), ye(j.StepConnector, "border", U("palette-grey-600")), ye(j.StepContent, "border", U("palette-grey-600")), ye(j.Switch, "defaultColor", U("palette-grey-300")), ye(j.Switch, "defaultDisabledColor", U("palette-grey-600")), ye(j.Switch, "primaryDisabledColor", $(Xt, j.primary.main, 0.55)), ye(j.Switch, "secondaryDisabledColor", $(Xt, j.secondary.main, 0.55)), ye(j.Switch, "errorDisabledColor", $(Xt, j.error.main, 0.55)), ye(j.Switch, "infoDisabledColor", $(Xt, j.info.main, 0.55)), ye(j.Switch, "successDisabledColor", $(Xt, j.success.main, 0.55)), ye(j.Switch, "warningDisabledColor", $(Xt, j.warning.main, 0.55)), ye(j.TableCell, "border", $(Xt, $(Tl, j.divider, 1), 0.68)), ye(j.Tooltip, "bg", $(Tl, j.grey[700], 0.92));
      }
      _i(j.background, "default"), _i(j.background, "paper"), _i(j.common, "background"), _i(j.common, "onBackground"), _i(j, "divider"), Object.keys(j).forEach((q) => {
        const B = j[q];
        q !== "tonalOffset" && B && typeof B == "object" && (B.main && ye(j[q], "mainChannel", mp(hp(B.main))), B.light && ye(j[q], "lightChannel", mp(hp(B.light))), B.dark && ye(j[q], "darkChannel", mp(hp(B.dark))), B.contrastText && ye(j[q], "contrastTextChannel", mp(hp(B.contrastText))), q === "text" && (_i(j[q], "primary"), _i(j[q], "secondary")), q === "action" && (B.active && _i(j[q], "active"), B.selected && _i(j[q], "selected")));
      });
    }), O = t.reduce((F, j) => wr(F, j), O);
    const M = {
      prefix: a,
      disableCssColorScheme: o,
      shouldSkipGeneratingVar: s,
      getSelector: tQ(O),
      enableContrastVars: i
    }, {
      vars: I,
      generateThemeVars: A,
      generateStyleSheets: D
    } = cJ(O, M);
    return O.vars = I, Object.entries(O.colorSchemes[O.defaultColorScheme]).forEach(([F, j]) => {
      O[F] = j;
    }), O.generateThemeVars = A, O.generateStyleSheets = D, O.generateSpacing = function() {
      return wT(f.spacing, GE(this));
    }, O.getColorSchemeSelector = dJ(u), O.spacing = O.generateSpacing(), O.shouldSkipGeneratingVar = s, O.unstable_sxConfig = {
      ...Am,
      ...f?.unstable_sxConfig
    }, O.unstable_sx = function(F) {
      return nl({
        sx: F,
        theme: this
      });
    }, O.toRuntimeSource = LT, O;
  }
  function rI(e, t, n) {
    e.colorSchemes && n && (e.colorSchemes[t] = {
      ...n !== !0 && n,
      palette: uC({
        ...n === !0 ? {} : n.palette,
        mode: t
      })
      // cast type to skip module augmentation test
    });
  }
  function mw(e = {}, ...t) {
    const {
      palette: n,
      cssVariables: r = !1,
      colorSchemes: o = n ? void 0 : {
        light: !0
      },
      defaultColorScheme: a = n?.mode,
      ...i
    } = e, s = a || "light", u = o?.[s], c = {
      ...o,
      ...n ? {
        [s]: {
          ...typeof u != "boolean" && u,
          palette: n
        }
      } : void 0
    };
    if (r === !1) {
      if (!("colorSchemes" in e))
        return a2(e, ...t);
      let f = n;
      "palette" in e || c[s] && (c[s] !== !0 ? f = c[s].palette : s === "dark" && (f = {
        mode: "dark"
      }));
      const p = a2({
        ...e,
        palette: f
      }, ...t);
      return p.defaultColorScheme = s, p.colorSchemes = c, p.palette.mode === "light" && (p.colorSchemes.light = {
        ...c.light !== !0 && c.light,
        palette: p.palette
      }, rI(p, "dark", c.dark)), p.palette.mode === "dark" && (p.colorSchemes.dark = {
        ...c.dark !== !0 && c.dark,
        palette: p.palette
      }, rI(p, "light", c.light)), p;
    }
    return !n && !("light" in c) && s === "light" && (c.light = !0), aQ({
      ...i,
      colorSchemes: c,
      defaultColorScheme: s,
      ...typeof r != "boolean" && r
    }, ...t);
  }
  const cC = mw(), za = "$$material";
  function hw() {
    const e = Tm(cC);
    return e[za] || e;
  }
  function iQ(e) {
    return /* @__PURE__ */ S.jsx(xT, {
      ...e,
      defaultTheme: cC,
      themeId: za
    });
  }
  function gw(e) {
    return e !== "ownerState" && e !== "theme" && e !== "sx" && e !== "as";
  }
  const kr = (e) => gw(e) && e !== "classes", Me = ET({
    themeId: za,
    defaultTheme: cC,
    rootShouldForwardProp: kr
  });
  function sQ(e) {
    return function(t) {
      return (
        // Pigment CSS `globalCss` support callback with theme inside an object but `GlobalStyles` support theme as a callback value.
        /* @__PURE__ */ S.jsx(iQ, {
          styles: typeof e == "function" ? (n) => e({
            theme: n,
            ...t
          }) : e
        })
      );
    };
  }
  function lQ() {
    return YE;
  }
  const at = QY;
  function lt(e) {
    return GY(e);
  }
  function uQ(e) {
    return rt("MuiTable", e);
  }
  tt("MuiTable", ["root", "stickyHeader"]);
  const cQ = (e) => {
    const {
      classes: t,
      stickyHeader: n
    } = e;
    return nt({
      root: ["root", n && "stickyHeader"]
    }, uQ, t);
  }, dQ = Me("table", {
    name: "MuiTable",
    slot: "Root",
    overridesResolver: (e, t) => {
      const {
        ownerState: n
      } = e;
      return [t.root, n.stickyHeader && t.stickyHeader];
    }
  })(at(({
    theme: e
  }) => ({
    display: "table",
    width: "100%",
    borderCollapse: "collapse",
    borderSpacing: 0,
    "& caption": {
      ...e.typography.body2,
      padding: e.spacing(2),
      color: (e.vars || e).palette.text.secondary,
      textAlign: "left",
      captionSide: "bottom"
    },
    variants: [{
      props: ({
        ownerState: t
      }) => t.stickyHeader,
      style: {
        borderCollapse: "separate"
      }
    }]
  }))), oI = "table", fQ = /* @__PURE__ */ C.forwardRef(function(e, t) {
    const n = lt({
      props: e,
      name: "MuiTable"
    }), {
      className: r,
      component: o = oI,
      padding: a = "normal",
      size: i = "medium",
      stickyHeader: s = !1,
      ...u
    } = n, c = {
      ...n,
      component: o,
      padding: a,
      size: i,
      stickyHeader: s
    }, f = cQ(c), p = C.useMemo(() => ({
      padding: a,
      size: i,
      stickyHeader: s
    }), [a, i, s]);
    return /* @__PURE__ */ S.jsx(tT.Provider, {
      value: p,
      children: /* @__PURE__ */ S.jsx(dQ, {
        as: o,
        role: o === oI ? null : "table",
        ref: t,
        className: Le(f.root, r),
        ownerState: c,
        ...u
      })
    });
  }), vw = /* @__PURE__ */ C.createContext();
  function pQ(e) {
    return rt("MuiTableBody", e);
  }
  tt("MuiTableBody", ["root"]);
  const mQ = (e) => {
    const {
      classes: t
    } = e;
    return nt({
      root: ["root"]
    }, pQ, t);
  }, hQ = Me("tbody", {
    name: "MuiTableBody",
    slot: "Root"
  })({
    display: "table-row-group"
  }), gQ = {
    variant: "body"
  }, aI = "tbody", vQ = /* @__PURE__ */ C.forwardRef(function(e, t) {
    const n = lt({
      props: e,
      name: "MuiTableBody"
    }), {
      className: r,
      component: o = aI,
      ...a
    } = n, i = {
      ...n,
      component: o
    }, s = mQ(i);
    return /* @__PURE__ */ S.jsx(vw.Provider, {
      value: gQ,
      children: /* @__PURE__ */ S.jsx(hQ, {
        className: Le(s.root, r),
        as: o,
        ref: t,
        role: o === aI ? null : "rowgroup",
        ownerState: i,
        ...a
      })
    });
  });
  function yQ(e) {
    return rt("MuiTableCell", e);
  }
  const bQ = tt("MuiTableCell", ["root", "head", "body", "footer", "sizeSmall", "sizeMedium", "paddingCheckbox", "paddingNone", "alignLeft", "alignCenter", "alignRight", "alignJustify", "stickyHeader"]), wQ = (e) => {
    const {
      classes: t,
      variant: n,
      align: r,
      padding: o,
      size: a,
      stickyHeader: i
    } = e, s = {
      root: ["root", n, i && "stickyHeader", r !== "inherit" && `align${$e(r)}`, o !== "normal" && `padding${$e(o)}`, `size${$e(a)}`]
    };
    return nt(s, yQ, t);
  }, xQ = Me("td", {
    name: "MuiTableCell",
    slot: "Root",
    overridesResolver: (e, t) => {
      const {
        ownerState: n
      } = e;
      return [t.root, t[n.variant], t[`size${$e(n.size)}`], n.padding !== "normal" && t[`padding${$e(n.padding)}`], n.align !== "inherit" && t[`align${$e(n.align)}`], n.stickyHeader && t.stickyHeader];
    }
  })(at(({
    theme: e
  }) => ({
    ...e.typography.body2,
    display: "table-cell",
    verticalAlign: "inherit",
    // Workaround for a rendering bug with spanned columns in Chrome 62.0.
    // Removes the alpha (sets it to 1), and lightens or darkens the theme color.
    borderBottom: e.vars ? `1px solid ${e.vars.palette.TableCell.border}` : `1px solid
    ${e.palette.mode === "light" ? e.lighten(e.alpha(e.palette.divider, 1), 0.88) : e.darken(e.alpha(e.palette.divider, 1), 0.68)}`,
    textAlign: "left",
    padding: 16,
    variants: [{
      props: {
        variant: "head"
      },
      style: {
        color: (e.vars || e).palette.text.primary,
        lineHeight: e.typography.pxToRem(24),
        fontWeight: e.typography.fontWeightMedium
      }
    }, {
      props: {
        variant: "body"
      },
      style: {
        color: (e.vars || e).palette.text.primary
      }
    }, {
      props: {
        variant: "footer"
      },
      style: {
        color: (e.vars || e).palette.text.secondary,
        lineHeight: e.typography.pxToRem(21),
        fontSize: e.typography.pxToRem(12)
      }
    }, {
      props: {
        size: "small"
      },
      style: {
        padding: "6px 16px",
        [`&.${bQ.paddingCheckbox}`]: {
          width: 24,
          // prevent the checkbox column from growing
          padding: "0 12px 0 16px",
          "& > *": {
            padding: 0
          }
        }
      }
    }, {
      props: {
        padding: "checkbox"
      },
      style: {
        width: 48,
        // prevent the checkbox column from growing
        padding: "0 0 0 4px"
      }
    }, {
      props: {
        padding: "none"
      },
      style: {
        padding: 0
      }
    }, {
      props: {
        align: "left"
      },
      style: {
        textAlign: "left"
      }
    }, {
      props: {
        align: "center"
      },
      style: {
        textAlign: "center"
      }
    }, {
      props: {
        align: "right"
      },
      style: {
        textAlign: "right",
        flexDirection: "row-reverse"
      }
    }, {
      props: {
        align: "justify"
      },
      style: {
        textAlign: "justify"
      }
    }, {
      props: ({
        ownerState: t
      }) => t.stickyHeader,
      style: {
        position: "sticky",
        top: 0,
        zIndex: 2,
        backgroundColor: (e.vars || e).palette.background.default
      }
    }]
  }))), Yg = /* @__PURE__ */ C.forwardRef(function(e, t) {
    const n = lt({
      props: e,
      name: "MuiTableCell"
    }), {
      align: r = "inherit",
      className: o,
      component: a,
      padding: i,
      scope: s,
      size: u,
      sortDirection: c,
      variant: f,
      ...p
    } = n, g = C.useContext(tT), h = C.useContext(vw), y = h && h.variant === "head";
    let b;
    a ? b = a : b = y ? "th" : "td";
    let v = s;
    b === "td" ? v = void 0 : !v && y && (v = "col");
    const w = f || h && h.variant, _ = {
      ...n,
      align: r,
      component: b,
      padding: i || (g && g.padding ? g.padding : "normal"),
      size: u || (g && g.size ? g.size : "medium"),
      sortDirection: c,
      stickyHeader: w === "head" && g && g.stickyHeader,
      variant: w
    }, k = wQ(_);
    let E = null;
    return c && (E = c === "asc" ? "ascending" : "descending"), /* @__PURE__ */ S.jsx(xQ, {
      as: b,
      ref: t,
      className: Le(k.root, o),
      "aria-sort": E,
      scope: v,
      ownerState: _,
      ...p
    });
  });
  function kQ(e) {
    return rt("MuiTableContainer", e);
  }
  tt("MuiTableContainer", ["root"]);
  const SQ = (e) => {
    const {
      classes: t
    } = e;
    return nt({
      root: ["root"]
    }, kQ, t);
  }, _Q = Me("div", {
    name: "MuiTableContainer",
    slot: "Root"
  })({
    width: "100%",
    overflowX: "auto"
  }), EQ = /* @__PURE__ */ C.forwardRef(function(e, t) {
    const n = lt({
      props: e,
      name: "MuiTableContainer"
    }), {
      className: r,
      component: o = "div",
      ...a
    } = n, i = {
      ...n,
      component: o
    }, s = SQ(i);
    return /* @__PURE__ */ S.jsx(_Q, {
      ref: t,
      as: o,
      className: Le(s.root, r),
      ownerState: i,
      ...a
    });
  });
  function CQ(e) {
    return rt("MuiTableHead", e);
  }
  tt("MuiTableHead", ["root"]);
  const PQ = (e) => {
    const {
      classes: t
    } = e;
    return nt({
      root: ["root"]
    }, CQ, t);
  }, OQ = Me("thead", {
    name: "MuiTableHead",
    slot: "Root"
  })({
    display: "table-header-group"
  }), NQ = {
    variant: "head"
  }, iI = "thead", MQ = /* @__PURE__ */ C.forwardRef(function(e, t) {
    const n = lt({
      props: e,
      name: "MuiTableHead"
    }), {
      className: r,
      component: o = iI,
      ...a
    } = n, i = {
      ...n,
      component: o
    }, s = PQ(i);
    return /* @__PURE__ */ S.jsx(vw.Provider, {
      value: NQ,
      children: /* @__PURE__ */ S.jsx(OQ, {
        as: o,
        className: Le(s.root, r),
        ref: t,
        role: o === iI ? null : "rowgroup",
        ownerState: i,
        ...a
      })
    });
  });
  function RQ(e) {
    return rt("MuiTableRow", e);
  }
  const sI = tt("MuiTableRow", ["root", "selected", "hover", "head", "footer"]), jQ = (e) => {
    const {
      classes: t,
      selected: n,
      hover: r,
      head: o,
      footer: a
    } = e;
    return nt({
      root: ["root", n && "selected", r && "hover", o && "head", a && "footer"]
    }, RQ, t);
  }, IQ = Me("tr", {
    name: "MuiTableRow",
    slot: "Root",
    overridesResolver: (e, t) => {
      const {
        ownerState: n
      } = e;
      return [t.root, n.head && t.head, n.footer && t.footer];
    }
  })(at(({
    theme: e
  }) => ({
    color: "inherit",
    display: "table-row",
    verticalAlign: "middle",
    // We disable the focus ring for mouse, touch and keyboard users.
    outline: 0,
    [`&.${sI.hover}:hover`]: {
      backgroundColor: (e.vars || e).palette.action.hover
    },
    [`&.${sI.selected}`]: {
      backgroundColor: e.alpha((e.vars || e).palette.primary.main, (e.vars || e).palette.action.selectedOpacity),
      "&:hover": {
        backgroundColor: e.alpha((e.vars || e).palette.primary.main, `${(e.vars || e).palette.action.selectedOpacity} + ${(e.vars || e).palette.action.hoverOpacity}`)
      }
    }
  }))), lI = "tr", Jg = /* @__PURE__ */ C.forwardRef(function(e, t) {
    const n = lt({
      props: e,
      name: "MuiTableRow"
    }), {
      className: r,
      component: o = lI,
      hover: a = !1,
      selected: i = !1,
      ...s
    } = n, u = C.useContext(vw), c = {
      ...n,
      component: o,
      hover: a,
      selected: i,
      head: u && u.variant === "head",
      footer: u && u.variant === "footer"
    }, f = jQ(c);
    return /* @__PURE__ */ S.jsx(IQ, {
      as: o,
      ref: t,
      className: Le(f.root, r),
      role: o === lI ? null : "row",
      ownerState: c,
      ...s
    });
  });
  Jc.oneOfType([Jc.func, Jc.object]);
  function dC(e, t) {
    return () => null;
  }
  dC(Jc.elementType);
  function eb(e) {
    try {
      return e.matches(":focus-visible");
    } catch {
    }
    return !1;
  }
  function Zn(...e) {
    const t = C.useRef(void 0), n = C.useCallback((r) => {
      const o = e.map((a) => {
        if (a == null)
          return null;
        if (typeof a == "function") {
          const i = a, s = i(r);
          return typeof s == "function" ? s : () => {
            i(null);
          };
        }
        return a.current = r, () => {
          a.current = null;
        };
      });
      return () => {
        o.forEach((a) => a?.());
      };
    }, e);
    return C.useMemo(() => e.every((r) => r == null) ? null : (r) => {
      t.current && (t.current(), t.current = void 0), r != null && (t.current = n(r));
    }, e);
  }
  function Ba(e) {
    const t = C.useRef(e);
    return ta(() => {
      t.current = e;
    }), C.useRef((...n) => (
      // @ts-expect-error hide `this`
      (0, t.current)(...n)
    )).current;
  }
  const uI = {};
  function zT(e, t) {
    const n = C.useRef(uI);
    return n.current === uI && (n.current = e(t)), n;
  }
  class tb {
    constructor() {
      Gn(this, "mountEffect", () => {
        this.shouldMount && !this.didMount && this.ref.current !== null && (this.didMount = !0, this.mounted.resolve());
      });
      this.ref = {
        current: null
      }, this.mounted = null, this.didMount = !1, this.shouldMount = !1, this.setShouldMount = null;
    }
    /** React ref to the ripple instance */
    /** If the ripple component should be mounted */
    /** Promise that resolves when the ripple component is mounted */
    /** If the ripple component has been mounted */
    /** React state hook setter */
    static create() {
      return new tb();
    }
    static use() {
      const t = zT(tb.create).current, [n, r] = C.useState(!1);
      return t.shouldMount = n, t.setShouldMount = r, C.useEffect(t.mountEffect, [n]), t;
    }
    mount() {
      return this.mounted || (this.mounted = $Q(), this.shouldMount = !0, this.setShouldMount(this.shouldMount)), this.mounted;
    }
    /* Ripple API */
    start(...t) {
      this.mount().then(() => this.ref.current?.start(...t));
    }
    stop(...t) {
      this.mount().then(() => this.ref.current?.stop(...t));
    }
    pulsate(...t) {
      this.mount().then(() => this.ref.current?.pulsate(...t));
    }
  }
  function AQ() {
    return tb.use();
  }
  function $Q() {
    let e, t;
    const n = new Promise((r, o) => {
      e = r, t = o;
    });
    return n.resolve = e, n.reject = t, n;
  }
  function yw(e, t) {
    if (e == null) return {};
    var n = {};
    for (var r in e) if ({}.hasOwnProperty.call(e, r)) {
      if (t.indexOf(r) !== -1) continue;
      n[r] = e[r];
    }
    return n;
  }
  function nb(e, t) {
    return nb = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(n, r) {
      return n.__proto__ = r, n;
    }, nb(e, t);
  }
  function fC(e, t) {
    e.prototype = Object.create(t.prototype), e.prototype.constructor = e, nb(e, t);
  }
  const cI = {
    disabled: !1
  }, rb = gn.createContext(null);
  var DQ = function(e) {
    return e.scrollTop;
  }, gp = "unmounted", Kl = "exited", Gl = "entering", zc = "entered", s2 = "exiting", Ya = /* @__PURE__ */ (function(e) {
    fC(t, e);
    function t(r, o) {
      var a;
      a = e.call(this, r, o) || this;
      var i = o, s = i && !i.isMounting ? r.enter : r.appear, u;
      return a.appearStatus = null, r.in ? s ? (u = Kl, a.appearStatus = Gl) : u = zc : r.unmountOnExit || r.mountOnEnter ? u = gp : u = Kl, a.state = {
        status: u
      }, a.nextCallback = null, a;
    }
    t.getDerivedStateFromProps = function(r, o) {
      var a = r.in;
      return a && o.status === gp ? {
        status: Kl
      } : null;
    };
    var n = t.prototype;
    return n.componentDidMount = function() {
      this.updateStatus(!0, this.appearStatus);
    }, n.componentDidUpdate = function(r) {
      var o = null;
      if (r !== this.props) {
        var a = this.state.status;
        this.props.in ? a !== Gl && a !== zc && (o = Gl) : (a === Gl || a === zc) && (o = s2);
      }
      this.updateStatus(!1, o);
    }, n.componentWillUnmount = function() {
      this.cancelNextCallback();
    }, n.getTimeouts = function() {
      var r = this.props.timeout, o, a, i;
      return o = a = i = r, r != null && typeof r != "number" && (o = r.exit, a = r.enter, i = r.appear !== void 0 ? r.appear : a), {
        exit: o,
        enter: a,
        appear: i
      };
    }, n.updateStatus = function(r, o) {
      if (r === void 0 && (r = !1), o !== null)
        if (this.cancelNextCallback(), o === Gl) {
          if (this.props.unmountOnExit || this.props.mountOnEnter) {
            var a = this.props.nodeRef ? this.props.nodeRef.current : Hc.findDOMNode(this);
            a && DQ(a);
          }
          this.performEnter(r);
        } else
          this.performExit();
      else this.props.unmountOnExit && this.state.status === Kl && this.setState({
        status: gp
      });
    }, n.performEnter = function(r) {
      var o = this, a = this.props.enter, i = this.context ? this.context.isMounting : r, s = this.props.nodeRef ? [i] : [Hc.findDOMNode(this), i], u = s[0], c = s[1], f = this.getTimeouts(), p = i ? f.appear : f.enter;
      if (!r && !a || cI.disabled) {
        this.safeSetState({
          status: zc
        }, function() {
          o.props.onEntered(u);
        });
        return;
      }
      this.props.onEnter(u, c), this.safeSetState({
        status: Gl
      }, function() {
        o.props.onEntering(u, c), o.onTransitionEnd(p, function() {
          o.safeSetState({
            status: zc
          }, function() {
            o.props.onEntered(u, c);
          });
        });
      });
    }, n.performExit = function() {
      var r = this, o = this.props.exit, a = this.getTimeouts(), i = this.props.nodeRef ? void 0 : Hc.findDOMNode(this);
      if (!o || cI.disabled) {
        this.safeSetState({
          status: Kl
        }, function() {
          r.props.onExited(i);
        });
        return;
      }
      this.props.onExit(i), this.safeSetState({
        status: s2
      }, function() {
        r.props.onExiting(i), r.onTransitionEnd(a.exit, function() {
          r.safeSetState({
            status: Kl
          }, function() {
            r.props.onExited(i);
          });
        });
      });
    }, n.cancelNextCallback = function() {
      this.nextCallback !== null && (this.nextCallback.cancel(), this.nextCallback = null);
    }, n.safeSetState = function(r, o) {
      o = this.setNextCallback(o), this.setState(r, o);
    }, n.setNextCallback = function(r) {
      var o = this, a = !0;
      return this.nextCallback = function(i) {
        a && (a = !1, o.nextCallback = null, r(i));
      }, this.nextCallback.cancel = function() {
        a = !1;
      }, this.nextCallback;
    }, n.onTransitionEnd = function(r, o) {
      this.setNextCallback(o);
      var a = this.props.nodeRef ? this.props.nodeRef.current : Hc.findDOMNode(this), i = r == null && !this.props.addEndListener;
      if (!a || i) {
        setTimeout(this.nextCallback, 0);
        return;
      }
      if (this.props.addEndListener) {
        var s = this.props.nodeRef ? [this.nextCallback] : [a, this.nextCallback], u = s[0], c = s[1];
        this.props.addEndListener(u, c);
      }
      r != null && setTimeout(this.nextCallback, r);
    }, n.render = function() {
      var r = this.state.status;
      if (r === gp)
        return null;
      var o = this.props, a = o.children;
      o.in, o.mountOnEnter, o.unmountOnExit, o.appear, o.enter, o.exit, o.timeout, o.addEndListener, o.onEnter, o.onEntering, o.onEntered, o.onExit, o.onExiting, o.onExited, o.nodeRef;
      var i = yw(o, ["children", "in", "mountOnEnter", "unmountOnExit", "appear", "enter", "exit", "timeout", "addEndListener", "onEnter", "onEntering", "onEntered", "onExit", "onExiting", "onExited", "nodeRef"]);
      return (
        // allows for nested Transitions
        /* @__PURE__ */ gn.createElement(rb.Provider, {
          value: null
        }, typeof a == "function" ? a(r, i) : gn.cloneElement(gn.Children.only(a), i))
      );
    }, t;
  })(gn.Component);
  Ya.contextType = rb;
  Ya.propTypes = {};
  function Sc() {
  }
  Ya.defaultProps = {
    in: !1,
    mountOnEnter: !1,
    unmountOnExit: !1,
    appear: !1,
    enter: !0,
    exit: !0,
    onEnter: Sc,
    onEntering: Sc,
    onEntered: Sc,
    onExit: Sc,
    onExiting: Sc,
    onExited: Sc
  };
  Ya.UNMOUNTED = gp;
  Ya.EXITED = Kl;
  Ya.ENTERING = Gl;
  Ya.ENTERED = zc;
  Ya.EXITING = s2;
  function BT(e) {
    if (e === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return e;
  }
  function pC(e, t) {
    var n = function(o) {
      return t && C.isValidElement(o) ? t(o) : o;
    }, r = /* @__PURE__ */ Object.create(null);
    return e && C.Children.map(e, function(o) {
      return o;
    }).forEach(function(o) {
      r[o.key] = n(o);
    }), r;
  }
  function LQ(e, t) {
    e = e || {}, t = t || {};
    function n(f) {
      return f in t ? t[f] : e[f];
    }
    var r = /* @__PURE__ */ Object.create(null), o = [];
    for (var a in e)
      a in t ? o.length && (r[a] = o, o = []) : o.push(a);
    var i, s = {};
    for (var u in t) {
      if (r[u])
        for (i = 0; i < r[u].length; i++) {
          var c = r[u][i];
          s[r[u][i]] = n(c);
        }
      s[u] = n(u);
    }
    for (i = 0; i < o.length; i++)
      s[o[i]] = n(o[i]);
    return s;
  }
  function Zl(e, t, n) {
    return n[t] != null ? n[t] : e.props[t];
  }
  function FQ(e, t) {
    return pC(e.children, function(n) {
      return C.cloneElement(n, {
        onExited: t.bind(null, n),
        in: !0,
        appear: Zl(n, "appear", e),
        enter: Zl(n, "enter", e),
        exit: Zl(n, "exit", e)
      });
    });
  }
  function TQ(e, t, n) {
    var r = pC(e.children), o = LQ(t, r);
    return Object.keys(o).forEach(function(a) {
      var i = o[a];
      if (C.isValidElement(i)) {
        var s = a in t, u = a in r, c = t[a], f = C.isValidElement(c) && !c.props.in;
        u && (!s || f) ? o[a] = C.cloneElement(i, {
          onExited: n.bind(null, i),
          in: !0,
          exit: Zl(i, "exit", e),
          enter: Zl(i, "enter", e)
        }) : !u && s && !f ? o[a] = C.cloneElement(i, {
          in: !1
        }) : u && s && C.isValidElement(c) && (o[a] = C.cloneElement(i, {
          onExited: n.bind(null, i),
          in: c.props.in,
          exit: Zl(i, "exit", e),
          enter: Zl(i, "enter", e)
        }));
      }
    }), o;
  }
  var zQ = Object.values || function(e) {
    return Object.keys(e).map(function(t) {
      return e[t];
    });
  }, BQ = {
    component: "div",
    childFactory: function(e) {
      return e;
    }
  }, mC = /* @__PURE__ */ (function(e) {
    fC(t, e);
    function t(r, o) {
      var a;
      a = e.call(this, r, o) || this;
      var i = a.handleExited.bind(BT(a));
      return a.state = {
        contextValue: {
          isMounting: !0
        },
        handleExited: i,
        firstRender: !0
      }, a;
    }
    var n = t.prototype;
    return n.componentDidMount = function() {
      this.mounted = !0, this.setState({
        contextValue: {
          isMounting: !1
        }
      });
    }, n.componentWillUnmount = function() {
      this.mounted = !1;
    }, t.getDerivedStateFromProps = function(r, o) {
      var a = o.children, i = o.handleExited, s = o.firstRender;
      return {
        children: s ? FQ(r, i) : TQ(r, a, i),
        firstRender: !1
      };
    }, n.handleExited = function(r, o) {
      var a = pC(this.props.children);
      r.key in a || (r.props.onExited && r.props.onExited(o), this.mounted && this.setState(function(i) {
        var s = Ge({}, i.children);
        return delete s[r.key], {
          children: s
        };
      }));
    }, n.render = function() {
      var r = this.props, o = r.component, a = r.childFactory, i = yw(r, ["component", "childFactory"]), s = this.state.contextValue, u = zQ(this.state.children).map(a);
      return delete i.appear, delete i.enter, delete i.exit, o === null ? /* @__PURE__ */ gn.createElement(rb.Provider, {
        value: s
      }, u) : /* @__PURE__ */ gn.createElement(rb.Provider, {
        value: s
      }, /* @__PURE__ */ gn.createElement(o, i, u));
    }, t;
  })(gn.Component);
  mC.propTypes = {};
  mC.defaultProps = BQ;
  const VQ = [];
  function UQ(e) {
    C.useEffect(e, VQ);
  }
  class hC {
    constructor() {
      Gn(this, "currentId", null);
      Gn(this, "clear", () => {
        this.currentId !== null && (clearTimeout(this.currentId), this.currentId = null);
      });
      Gn(this, "disposeEffect", () => this.clear);
    }
    static create() {
      return new hC();
    }
    /**
     * Executes `fn` after `delay`, clearing any previously scheduled call.
     */
    start(t, n) {
      this.clear(), this.currentId = setTimeout(() => {
        this.currentId = null, n();
      }, t);
    }
  }
  function VT() {
    const e = zT(hC.create).current;
    return UQ(e.disposeEffect), e;
  }
  function HQ(e) {
    const {
      className: t,
      classes: n,
      pulsate: r = !1,
      rippleX: o,
      rippleY: a,
      rippleSize: i,
      in: s,
      onExited: u,
      timeout: c
    } = e, [f, p] = C.useState(!1), g = Le(t, n.ripple, n.rippleVisible, r && n.ripplePulsate), h = {
      width: i,
      height: i,
      top: -(i / 2) + a,
      left: -(i / 2) + o
    }, y = Le(n.child, f && n.childLeaving, r && n.childPulsate);
    return !s && !f && p(!0), C.useEffect(() => {
      if (!s && u != null) {
        const b = setTimeout(u, c);
        return () => {
          clearTimeout(b);
        };
      }
    }, [u, s, c]), /* @__PURE__ */ S.jsx("span", {
      className: g,
      style: h,
      children: /* @__PURE__ */ S.jsx("span", {
        className: y
      })
    });
  }
  const Eo = tt("MuiTouchRipple", ["root", "ripple", "rippleVisible", "ripplePulsate", "child", "childLeaving", "childPulsate"]), l2 = 550, WQ = 80, qQ = Ad`
  0% {
    transform: scale(0);
    opacity: 0.1;
  }

  100% {
    transform: scale(1);
    opacity: 0.3;
  }
`, KQ = Ad`
  0% {
    opacity: 1;
  }

  100% {
    opacity: 0;
  }
`, GQ = Ad`
  0% {
    transform: scale(1);
  }

  50% {
    transform: scale(0.92);
  }

  100% {
    transform: scale(1);
  }
`, XQ = Me("span", {
    name: "MuiTouchRipple",
    slot: "Root"
  })({
    overflow: "hidden",
    pointerEvents: "none",
    position: "absolute",
    zIndex: 0,
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    borderRadius: "inherit"
  }), YQ = Me(HQ, {
    name: "MuiTouchRipple",
    slot: "Ripple"
  })`
  opacity: 0;
  position: absolute;

  &.${Eo.rippleVisible} {
    opacity: 0.3;
    transform: scale(1);
    animation-name: ${qQ};
    animation-duration: ${l2}ms;
    animation-timing-function: ${({
    theme: e
  }) => e.transitions.easing.easeInOut};
  }

  &.${Eo.ripplePulsate} {
    animation-duration: ${({
    theme: e
  }) => e.transitions.duration.shorter}ms;
  }

  & .${Eo.child} {
    opacity: 1;
    display: block;
    width: 100%;
    height: 100%;
    border-radius: 50%;
    background-color: currentColor;
  }

  & .${Eo.childLeaving} {
    opacity: 0;
    animation-name: ${KQ};
    animation-duration: ${l2}ms;
    animation-timing-function: ${({
    theme: e
  }) => e.transitions.easing.easeInOut};
  }

  & .${Eo.childPulsate} {
    position: absolute;
    /* @noflip */
    left: 0px;
    top: 0;
    animation-name: ${GQ};
    animation-duration: 2500ms;
    animation-timing-function: ${({
    theme: e
  }) => e.transitions.easing.easeInOut};
    animation-iteration-count: infinite;
    animation-delay: 200ms;
  }
`, JQ = /* @__PURE__ */ C.forwardRef(function(e, t) {
    const n = lt({
      props: e,
      name: "MuiTouchRipple"
    }), {
      center: r = !1,
      classes: o = {},
      className: a,
      ...i
    } = n, [s, u] = C.useState([]), c = C.useRef(0), f = C.useRef(null);
    C.useEffect(() => {
      f.current && (f.current(), f.current = null);
    }, [s]);
    const p = C.useRef(!1), g = VT(), h = C.useRef(null), y = C.useRef(null), b = C.useCallback((k) => {
      const {
        pulsate: E,
        rippleX: P,
        rippleY: O,
        rippleSize: M,
        cb: I
      } = k;
      u((A) => [...A, /* @__PURE__ */ S.jsx(YQ, {
        classes: {
          ripple: Le(o.ripple, Eo.ripple),
          rippleVisible: Le(o.rippleVisible, Eo.rippleVisible),
          ripplePulsate: Le(o.ripplePulsate, Eo.ripplePulsate),
          child: Le(o.child, Eo.child),
          childLeaving: Le(o.childLeaving, Eo.childLeaving),
          childPulsate: Le(o.childPulsate, Eo.childPulsate)
        },
        timeout: l2,
        pulsate: E,
        rippleX: P,
        rippleY: O,
        rippleSize: M
      }, c.current)]), c.current += 1, f.current = I;
    }, [o]), v = C.useCallback((k = {}, E = {}, P = () => {
    }) => {
      const {
        pulsate: O = !1,
        center: M = r || E.pulsate,
        fakeElement: I = !1
        // For test purposes
      } = E;
      if (k?.type === "mousedown" && p.current) {
        p.current = !1;
        return;
      }
      k?.type === "touchstart" && (p.current = !0);
      const A = I ? null : y.current, D = A ? A.getBoundingClientRect() : {
        width: 0,
        height: 0,
        left: 0,
        top: 0
      };
      let F, j, U;
      if (M || k === void 0 || k.clientX === 0 && k.clientY === 0 || !k.clientX && !k.touches)
        F = Math.round(D.width / 2), j = Math.round(D.height / 2);
      else {
        const {
          clientX: $,
          clientY: q
        } = k.touches && k.touches.length > 0 ? k.touches[0] : k;
        F = Math.round($ - D.left), j = Math.round(q - D.top);
      }
      if (M)
        U = Math.sqrt((2 * D.width ** 2 + D.height ** 2) / 3), U % 2 === 0 && (U += 1);
      else {
        const $ = Math.max(Math.abs((A ? A.clientWidth : 0) - F), F) * 2 + 2, q = Math.max(Math.abs((A ? A.clientHeight : 0) - j), j) * 2 + 2;
        U = Math.sqrt($ ** 2 + q ** 2);
      }
      k?.touches ? h.current === null && (h.current = () => {
        b({
          pulsate: O,
          rippleX: F,
          rippleY: j,
          rippleSize: U,
          cb: P
        });
      }, g.start(WQ, () => {
        h.current && (h.current(), h.current = null);
      })) : b({
        pulsate: O,
        rippleX: F,
        rippleY: j,
        rippleSize: U,
        cb: P
      });
    }, [r, b, g]), w = C.useCallback(() => {
      v({}, {
        pulsate: !0
      });
    }, [v]), _ = C.useCallback((k, E) => {
      if (g.clear(), k?.type === "touchend" && h.current) {
        h.current(), h.current = null, g.start(0, () => {
          _(k, E);
        });
        return;
      }
      h.current = null, u((P) => P.length > 0 ? P.slice(1) : P), f.current = E;
    }, [g]);
    return C.useImperativeHandle(t, () => ({
      pulsate: w,
      start: v,
      stop: _
    }), [w, v, _]), /* @__PURE__ */ S.jsx(XQ, {
      className: Le(Eo.root, o.root, a),
      ref: y,
      ...i,
      children: /* @__PURE__ */ S.jsx(mC, {
        component: null,
        exit: !0,
        children: s
      })
    });
  });
  function QQ(e) {
    return rt("MuiButtonBase", e);
  }
  const ZQ = tt("MuiButtonBase", ["root", "disabled", "focusVisible"]), eZ = (e) => {
    const {
      disabled: t,
      focusVisible: n,
      focusVisibleClassName: r,
      classes: o
    } = e, a = nt({
      root: ["root", t && "disabled", n && "focusVisible"]
    }, QQ, o);
    return n && r && (a.root += ` ${r}`), a;
  }, tZ = Me("button", {
    name: "MuiButtonBase",
    slot: "Root"
  })({
    display: "inline-flex",
    alignItems: "center",
    justifyContent: "center",
    position: "relative",
    boxSizing: "border-box",
    WebkitTapHighlightColor: "transparent",
    backgroundColor: "transparent",
    // Reset default value
    // We disable the focus ring for mouse, touch and keyboard users.
    outline: 0,
    border: 0,
    margin: 0,
    // Remove the margin in Safari
    borderRadius: 0,
    padding: 0,
    // Remove the padding in Firefox
    cursor: "pointer",
    userSelect: "none",
    verticalAlign: "middle",
    MozAppearance: "none",
    // Reset
    WebkitAppearance: "none",
    // Reset
    textDecoration: "none",
    // So we take precedent over the style of a native <a /> element.
    color: "inherit",
    "&::-moz-focus-inner": {
      borderStyle: "none"
      // Remove Firefox dotted outline.
    },
    [`&.${ZQ.disabled}`]: {
      pointerEvents: "none",
      // Disable link interactions
      cursor: "default"
    },
    "@media print": {
      colorAdjust: "exact"
    }
  }), zm = /* @__PURE__ */ C.forwardRef(function(e, t) {
    const n = lt({
      props: e,
      name: "MuiButtonBase"
    }), {
      action: r,
      centerRipple: o = !1,
      children: a,
      className: i,
      component: s = "button",
      disabled: u = !1,
      disableRipple: c = !1,
      disableTouchRipple: f = !1,
      focusRipple: p = !1,
      focusVisibleClassName: g,
      LinkComponent: h = "a",
      onBlur: y,
      onClick: b,
      onContextMenu: v,
      onDragLeave: w,
      onFocus: _,
      onFocusVisible: k,
      onKeyDown: E,
      onKeyUp: P,
      onMouseDown: O,
      onMouseLeave: M,
      onMouseUp: I,
      onTouchEnd: A,
      onTouchMove: D,
      onTouchStart: F,
      tabIndex: j = 0,
      TouchRippleProps: U,
      touchRippleRef: $,
      type: q,
      ...B
    } = n, G = C.useRef(null), W = AQ(), Y = Zn(W.ref, $), [z, L] = C.useState(!1);
    u && z && L(!1), C.useImperativeHandle(r, () => ({
      focusVisible: () => {
        L(!0), G.current.focus();
      }
    }), []);
    const K = W.shouldMount && !c && !u;
    C.useEffect(() => {
      z && p && !c && W.pulsate();
    }, [c, p, z, W]);
    const T = Ei(W, "start", O, f), V = Ei(W, "stop", v, f), X = Ei(W, "stop", w, f), Q = Ei(W, "stop", I, f), ne = Ei(W, "stop", (Pe) => {
      z && Pe.preventDefault(), M && M(Pe);
    }, f), te = Ei(W, "start", F, f), ae = Ei(W, "stop", A, f), ce = Ei(W, "stop", D, f), Z = Ei(W, "stop", (Pe) => {
      eb(Pe.target) || L(!1), y && y(Pe);
    }, !1), ee = Ba((Pe) => {
      G.current || (G.current = Pe.currentTarget), eb(Pe.target) && (L(!0), k && k(Pe)), _ && _(Pe);
    }), oe = () => {
      const Pe = G.current;
      return s && s !== "button" && !(Pe.tagName === "A" && Pe.href);
    }, le = Ba((Pe) => {
      p && !Pe.repeat && z && Pe.key === " " && W.stop(Pe, () => {
        W.start(Pe);
      }), Pe.target === Pe.currentTarget && oe() && Pe.key === " " && Pe.preventDefault(), E && E(Pe), Pe.target === Pe.currentTarget && oe() && Pe.key === "Enter" && !u && (Pe.preventDefault(), b && b(Pe));
    }), be = Ba((Pe) => {
      p && Pe.key === " " && z && !Pe.defaultPrevented && W.stop(Pe, () => {
        W.pulsate(Pe);
      }), P && P(Pe), b && Pe.target === Pe.currentTarget && oe() && Pe.key === " " && !Pe.defaultPrevented && b(Pe);
    });
    let ke = s;
    ke === "button" && (B.href || B.to) && (ke = h);
    const De = {};
    if (ke === "button") {
      const Pe = !!B.formAction;
      De.type = q === void 0 && !Pe ? "button" : q, De.disabled = u;
    } else
      !B.href && !B.to && (De.role = "button"), u && (De["aria-disabled"] = u);
    const ze = Zn(t, G), Ue = {
      ...n,
      centerRipple: o,
      component: s,
      disabled: u,
      disableRipple: c,
      disableTouchRipple: f,
      focusRipple: p,
      tabIndex: j,
      focusVisible: z
    }, He = eZ(Ue);
    return /* @__PURE__ */ S.jsxs(tZ, {
      as: ke,
      className: Le(He.root, i),
      ownerState: Ue,
      onBlur: Z,
      onClick: b,
      onContextMenu: V,
      onFocus: ee,
      onKeyDown: le,
      onKeyUp: be,
      onMouseDown: T,
      onMouseLeave: ne,
      onMouseUp: Q,
      onDragLeave: X,
      onTouchEnd: ae,
      onTouchMove: ce,
      onTouchStart: te,
      ref: ze,
      tabIndex: u ? -1 : j,
      type: q,
      ...De,
      ...B,
      children: [a, K ? /* @__PURE__ */ S.jsx(JQ, {
        ref: Y,
        center: o,
        ...U
      }) : null]
    });
  });
  function Ei(e, t, n, r = !1) {
    return Ba((o) => (n && n(o), r || e[t](o), !0));
  }
  function nZ(e) {
    return rt("MuiSvgIcon", e);
  }
  tt("MuiSvgIcon", ["root", "colorPrimary", "colorSecondary", "colorAction", "colorError", "colorDisabled", "fontSizeInherit", "fontSizeSmall", "fontSizeMedium", "fontSizeLarge"]);
  const rZ = (e) => {
    const {
      color: t,
      fontSize: n,
      classes: r
    } = e, o = {
      root: ["root", t !== "inherit" && `color${$e(t)}`, `fontSize${$e(n)}`]
    };
    return nt(o, nZ, r);
  }, oZ = Me("svg", {
    name: "MuiSvgIcon",
    slot: "Root",
    overridesResolver: (e, t) => {
      const {
        ownerState: n
      } = e;
      return [t.root, n.color !== "inherit" && t[`color${$e(n.color)}`], t[`fontSize${$e(n.fontSize)}`]];
    }
  })(at(({
    theme: e
  }) => ({
    userSelect: "none",
    width: "1em",
    height: "1em",
    display: "inline-block",
    flexShrink: 0,
    transition: e.transitions?.create?.("fill", {
      duration: (e.vars ?? e).transitions?.duration?.shorter
    }),
    variants: [
      {
        props: (t) => !t.hasSvgAsChild,
        style: {
          // the <svg> will define the property that has `currentColor`
          // for example heroicons uses fill="none" and stroke="currentColor"
          fill: "currentColor"
        }
      },
      {
        props: {
          fontSize: "inherit"
        },
        style: {
          fontSize: "inherit"
        }
      },
      {
        props: {
          fontSize: "small"
        },
        style: {
          fontSize: e.typography?.pxToRem?.(20) || "1.25rem"
        }
      },
      {
        props: {
          fontSize: "medium"
        },
        style: {
          fontSize: e.typography?.pxToRem?.(24) || "1.5rem"
        }
      },
      {
        props: {
          fontSize: "large"
        },
        style: {
          fontSize: e.typography?.pxToRem?.(35) || "2.1875rem"
        }
      },
      // TODO v5 deprecate color prop, v6 remove for sx
      ...Object.entries((e.vars ?? e).palette).filter(([, t]) => t && t.main).map(([t]) => ({
        props: {
          color: t
        },
        style: {
          color: (e.vars ?? e).palette?.[t]?.main
        }
      })),
      {
        props: {
          color: "action"
        },
        style: {
          color: (e.vars ?? e).palette?.action?.active
        }
      },
      {
        props: {
          color: "disabled"
        },
        style: {
          color: (e.vars ?? e).palette?.action?.disabled
        }
      },
      {
        props: {
          color: "inherit"
        },
        style: {
          color: void 0
        }
      }
    ]
  }))), u2 = /* @__PURE__ */ C.forwardRef(function(e, t) {
    const n = lt({
      props: e,
      name: "MuiSvgIcon"
    }), {
      children: r,
      className: o,
      color: a = "inherit",
      component: i = "svg",
      fontSize: s = "medium",
      htmlColor: u,
      inheritViewBox: c = !1,
      titleAccess: f,
      viewBox: p = "0 0 24 24",
      ...g
    } = n, h = /* @__PURE__ */ C.isValidElement(r) && r.type === "svg", y = {
      ...n,
      color: a,
      component: i,
      fontSize: s,
      instanceFontSize: e.fontSize,
      inheritViewBox: c,
      viewBox: p,
      hasSvgAsChild: h
    }, b = {};
    c || (b.viewBox = p);
    const v = rZ(y);
    return /* @__PURE__ */ S.jsxs(oZ, {
      as: i,
      className: Le(v.root, o),
      focusable: "false",
      color: u,
      "aria-hidden": f ? void 0 : !0,
      role: f ? "img" : void 0,
      ref: t,
      ...b,
      ...g,
      ...h && r.props,
      ownerState: y,
      children: [h ? r.props.children : r, f ? /* @__PURE__ */ S.jsx("title", {
        children: f
      }) : null]
    });
  });
  u2.muiName = "SvgIcon";
  function mo(e, t) {
    function n(r, o) {
      return /* @__PURE__ */ S.jsx(u2, {
        "data-testid": void 0,
        ref: o,
        ...r,
        children: e
      });
    }
    return n.muiName = u2.muiName, /* @__PURE__ */ C.memo(/* @__PURE__ */ C.forwardRef(n));
  }
  const aZ = mo(/* @__PURE__ */ S.jsx("path", {
    d: "M20 12l-1.41-1.41L13 16.17V4h-2v12.17l-5.58-5.59L4 12l8 8 8-8z"
  }));
  function iZ(e) {
    return rt("MuiTableSortLabel", e);
  }
  const p_ = tt("MuiTableSortLabel", ["root", "active", "icon", "iconDirectionDesc", "iconDirectionAsc", "directionDesc", "directionAsc"]);
  function Va(e) {
    return typeof e == "string";
  }
  function UT(e, t, n) {
    return e === void 0 || Va(e) ? t : {
      ...t,
      ownerState: {
        ...t.ownerState,
        ...n
      }
    };
  }
  function HT(e, t, n) {
    return typeof e == "function" ? e(t, n) : e;
  }
  function Np(e, t = []) {
    if (e === void 0)
      return {};
    const n = {};
    return Object.keys(e).filter((r) => r.match(/^on[A-Z]/) && typeof e[r] == "function" && !t.includes(r)).forEach((r) => {
      n[r] = e[r];
    }), n;
  }
  function dI(e) {
    if (e === void 0)
      return {};
    const t = {};
    return Object.keys(e).filter((n) => !(n.match(/^on[A-Z]/) && typeof e[n] == "function")).forEach((n) => {
      t[n] = e[n];
    }), t;
  }
  function WT(e) {
    const {
      getSlotProps: t,
      additionalProps: n,
      externalSlotProps: r,
      externalForwardedProps: o,
      className: a
    } = e;
    if (!t) {
      const h = Le(n?.className, a, o?.className, r?.className), y = {
        ...n?.style,
        ...o?.style,
        ...r?.style
      }, b = {
        ...n,
        ...o,
        ...r
      };
      return h.length > 0 && (b.className = h), Object.keys(y).length > 0 && (b.style = y), {
        props: b,
        internalRef: void 0
      };
    }
    const i = Np({
      ...o,
      ...r
    }), s = dI(r), u = dI(o), c = t(i), f = Le(c?.className, n?.className, a, o?.className, r?.className), p = {
      ...c?.style,
      ...n?.style,
      ...o?.style,
      ...r?.style
    }, g = {
      ...c,
      ...n,
      ...u,
      ...s
    };
    return f.length > 0 && (g.className = f), Object.keys(p).length > 0 && (g.style = p), {
      props: g,
      internalRef: c.ref
    };
  }
  function sn(e, t) {
    const {
      className: n,
      elementType: r,
      ownerState: o,
      externalForwardedProps: a,
      internalForwardedProps: i,
      shouldForwardComponentProp: s = !1,
      ...u
    } = t, {
      component: c,
      slots: f = {
        [e]: void 0
      },
      slotProps: p = {
        [e]: void 0
      },
      ...g
    } = a, h = f[e] || r, y = HT(p[e], o), {
      props: {
        component: b,
        ...v
      },
      internalRef: w
    } = WT({
      className: n,
      ...u,
      externalForwardedProps: e === "root" ? g : void 0,
      externalSlotProps: y
    }), _ = Zn(w, y?.ref, t.ref), k = e === "root" ? b || c : b, E = UT(h, {
      ...e === "root" && !c && !f[e] && i,
      ...e !== "root" && !f[e] && i,
      ...v,
      ...k && !s && {
        as: k
      },
      ...k && s && {
        component: k
      },
      ref: _
    }, o);
    return [h, E];
  }
  const sZ = (e) => {
    const {
      classes: t,
      direction: n,
      active: r
    } = e, o = {
      root: ["root", r && "active", `direction${$e(n)}`],
      icon: ["icon", `iconDirection${$e(n)}`]
    };
    return nt(o, iZ, t);
  }, lZ = Me(zm, {
    name: "MuiTableSortLabel",
    slot: "Root",
    overridesResolver: (e, t) => {
      const {
        ownerState: n
      } = e;
      return [t.root, n.active && t.active];
    }
  })(at(({
    theme: e
  }) => ({
    cursor: "pointer",
    display: "inline-flex",
    justifyContent: "flex-start",
    flexDirection: "inherit",
    alignItems: "center",
    "&:focus": {
      color: (e.vars || e).palette.text.secondary
    },
    "&:hover": {
      color: (e.vars || e).palette.text.secondary,
      [`& .${p_.icon}`]: {
        opacity: 0.5
      }
    },
    [`&.${p_.active}`]: {
      color: (e.vars || e).palette.text.primary,
      [`& .${p_.icon}`]: {
        opacity: 1,
        color: (e.vars || e).palette.text.secondary
      }
    }
  }))), uZ = Me("span", {
    name: "MuiTableSortLabel",
    slot: "Icon",
    overridesResolver: (e, t) => {
      const {
        ownerState: n
      } = e;
      return [t.icon, t[`iconDirection${$e(n.direction)}`]];
    }
  })(at(({
    theme: e
  }) => ({
    fontSize: 18,
    marginRight: 4,
    marginLeft: 4,
    opacity: 0,
    transition: e.transitions.create(["opacity", "transform"], {
      duration: e.transitions.duration.shorter
    }),
    userSelect: "none",
    variants: [{
      props: {
        direction: "desc"
      },
      style: {
        transform: "rotate(0deg)"
      }
    }, {
      props: {
        direction: "asc"
      },
      style: {
        transform: "rotate(180deg)"
      }
    }]
  }))), cZ = /* @__PURE__ */ C.forwardRef(function(e, t) {
    const n = lt({
      props: e,
      name: "MuiTableSortLabel"
    }), {
      active: r = !1,
      children: o,
      className: a,
      direction: i = "asc",
      hideSortIcon: s = !1,
      IconComponent: u = aZ,
      slots: c = {},
      slotProps: f = {},
      ...p
    } = n, g = {
      ...n,
      active: r,
      direction: i,
      hideSortIcon: s,
      IconComponent: u
    }, h = sZ(g), y = {
      slots: c,
      slotProps: f
    }, [b, v] = sn("root", {
      elementType: lZ,
      externalForwardedProps: y,
      ownerState: g,
      className: Le(h.root, a),
      ref: t
    }), [w, _] = sn("icon", {
      elementType: uZ,
      externalForwardedProps: y,
      ownerState: g,
      className: h.icon
    });
    return /* @__PURE__ */ S.jsxs(b, {
      disableRipple: !0,
      component: "span",
      ...v,
      ...p,
      children: [o, s && !r ? null : /* @__PURE__ */ S.jsx(w, {
        as: u,
        ..._
      })]
    });
  }), dZ = (e) => {
    const t = [];
    if (e === void 0)
      return {
        header: [],
        rows: []
      };
    e.data === void 0 && (e.data = []), (e.columns === void 0 || e.columns.length === 0) && (e.data.length === 0 ? e.columns = [] : e.columns = e.data[0].map((r, o) => `col${o}`)), (e.index === void 0 || e.index.length === 0) && (e.index = e.data.map((r, o) => `row${o}`));
    const n = Math.max(e.index.length, e.data.length);
    for (let r = 0; r < n; r++) {
      const o = [r < e.index.length ? e.index[r] : `row${r}`];
      for (let a = 0; a < e.columns.length; a++)
        o.push(e.data[r] ? e.data[r][a] : void 0);
      t.push(o);
    }
    return {
      header: ["index", ...e.columns],
      rows: t
    };
  }, fZ = (e, t) => e === "desc" ? (n, r) => r[t] < n[t] ? -1 : r[t] > n[t] ? 1 : 0 : (n, r) => n[t] < r[t] ? -1 : n[t] > r[t] ? 1 : 0, c2 = (e, t) => {
    const n = e.map((r, o) => [
      r,
      o
    ]);
    return n.sort((r, o) => t(r[0], o[0])), n.map((r) => r[0]);
  }, pZ = (e, t, n = 1e3) => {
    if (e.length <= n)
      return c2(e, t);
    const r = [];
    for (let a = 0; a < e.length; a += n)
      r.push(e.slice(a, a + n));
    const o = r.map((a) => c2(a, t));
    return mZ(o, t);
  }, mZ = (e, t) => {
    if (e.length === 1) return e[0];
    const n = [], r = new Array(e.length).fill(0);
    for (; r.some((o, a) => o < e[a].length); ) {
      let o = -1, a = null;
      for (let i = 0; i < e.length; i++)
        if (r[i] < e[i].length) {
          const s = e[i][r[i]];
          (a === null || t(s, a) < 0) && (a = s, o = i);
        }
      o !== -1 && a !== null && (n.push(a), r[o]++);
    }
    return n;
  }, fI = (e, t, n) => {
    const r = Math.ceil(e / n);
    return {
      currentPage: r === 0 ? 1 : Math.min(Math.max(1, t), r),
      pageSize: n,
      totalPages: r,
      totalRows: e
    };
  }, hZ = (e, t, n) => {
    const r = (t - 1) * n, o = r + n;
    return e.slice(r, o);
  }, gZ = (e, t, n, r, o = 5) => {
    const a = Math.max(0, Math.floor(e / n) - o), i = Math.min(
      r - 1,
      Math.ceil((e + t) / n) + o
    );
    return { startIndex: a, endIndex: i };
  }, vZ = (e, t) => {
    let n;
    return (...r) => {
      clearTimeout(n), n = setTimeout(() => e(...r), t);
    };
  }, qT = ({
    tabledata: e,
    className: t = "",
    size: n = "small",
    onSortChange: r,
    enablePagination: o = void 0,
    pageSize: a = 50,
    enableVirtualScrolling: i = void 0,
    virtualScrollingHeight: s = 400,
    enableLazyLoading: u = void 0,
    onLoadMore: c
  }) => {
    e || (e = {
      columns: [],
      index: [],
      data: []
    });
    const f = e.index.length;
    f > 1e4 && (u = u === void 0 ? !0 : u), f > 1e3 && (i = i === void 0 ? !0 : i), f > 2 * a && (o = o === void 0 ? !0 : o), u = u === void 0 ? !1 : u, i = i === void 0 ? !1 : i, o = o === void 0 ? !1 : o;
    const p = C.useMemo(
      () => dZ(e),
      [e]
    ), [g, h] = C.useState("asc"), [y, b] = C.useState("index"), [v, w] = C.useState(
      () => fI(p.rows.length, 1, a)
    ), [_, k] = C.useState(0), E = C.useRef(null), P = C.useMemo(() => {
      const W = p.header.indexOf(y);
      return W === -1 ? 0 : W;
    }, [p.header, y]), O = C.useMemo(
      () => vZ((W, Y) => {
        h(Y), b(W), r?.(W, Y);
      }, 150),
      [r]
    ), M = C.useCallback(
      (W) => {
        const Y = y === W && g === "asc" ? "desc" : "asc";
        p.rows.length > 1e3 ? O(W, Y) : (h(Y), b(W), r?.(W, Y));
      },
      [
        y,
        g,
        r,
        p.rows.length,
        O
      ]
    ), I = C.useMemo(
      () => fZ(g, P),
      [g, P]
    ), A = C.useMemo(() => p.rows.length > 1e3 ? pZ(p.rows, I) : c2(p.rows, I), [p.rows, I]), D = C.useMemo(() => o ? hZ(A, v.currentPage, v.pageSize) : A, [
      A,
      o,
      v.currentPage,
      v.pageSize
    ]), F = {
      itemHeight: 48,
      // Approximate row height
      overscan: 5,
      containerHeight: s
    }, j = C.useMemo(() => i ? gZ(
      _,
      F.containerHeight,
      F.itemHeight,
      D.length,
      F.overscan
    ) : { startIndex: 0, endIndex: D.length - 1 }, [
      _,
      i,
      D.length,
      F
    ]), U = C.useCallback(
      (W) => {
        i && k(W.currentTarget.scrollTop);
      },
      [i]
    ), $ = C.useCallback((W) => {
      w((Y) => ({
        ...Y,
        currentPage: W
      }));
    }, []), q = C.useCallback(
      (W) => {
        if (!(!o || W.target.closest(".sortable-table-wrapper") !== W.currentTarget))
          switch (W.key) {
            case "ArrowLeft":
              v.currentPage > 1 && (W.preventDefault(), W.stopPropagation(), $(v.currentPage - 1));
              break;
            case "ArrowRight":
              v.currentPage < v.totalPages && (W.preventDefault(), W.stopPropagation(), $(v.currentPage + 1));
              break;
            case "Home":
              v.currentPage > 1 && (W.preventDefault(), W.stopPropagation(), $(1));
              break;
            case "End":
              v.currentPage < v.totalPages && (W.preventDefault(), W.stopPropagation(), $(v.totalPages));
              break;
          }
      },
      [
        o,
        v.currentPage,
        v.totalPages,
        $
      ]
    );
    C.useEffect(() => {
      o && w((W) => fI(
        A.length,
        W.currentPage,
        // Use previous current page instead of hardcoding 1
        a
      ));
    }, [A.length, o, a]), C.useEffect(() => {
      u && c && v.currentPage >= v.totalPages - 1 && c(v.currentPage + 1);
    }, [
      u,
      c,
      v.currentPage,
      v.totalPages
    ]);
    const B = () => o ? /* @__PURE__ */ S.jsxs("div", { className: "sortable-table-pagination", children: [
      /* @__PURE__ */ S.jsx(
        "button",
        {
          onClick: () => $(v.currentPage - 1),
          disabled: v.currentPage <= 1,
          className: "pagination-button",
          children: "Previous"
        }
      ),
      /* @__PURE__ */ S.jsxs("span", { className: "pagination-info", children: [
        "Page ",
        v.currentPage,
        " of ",
        v.totalPages,
        "(",
        v.totalRows,
        " total rows)"
      ] }),
      /* @__PURE__ */ S.jsx(
        "button",
        {
          onClick: () => $(v.currentPage + 1),
          disabled: v.currentPage >= v.totalPages,
          className: "pagination-button",
          children: "Next"
        }
      )
    ] }) : null, G = () => {
      const W = i ? D.slice(
        j.startIndex,
        j.endIndex + 1
      ) : D;
      return /* @__PURE__ */ S.jsxs(vQ, { children: [
        i && /* @__PURE__ */ S.jsx(
          Jg,
          {
            style: {
              height: j.startIndex * F.itemHeight
            },
            children: /* @__PURE__ */ S.jsx(Yg, { colSpan: p.header.length })
          }
        ),
        W.map((Y, z) => {
          const L = i ? j.startIndex + z : z;
          return /* @__PURE__ */ S.jsx(Jg, { children: Y.map((K, T) => /* @__PURE__ */ S.jsx(
            Yg,
            {
              className: T === 0 ? "sortable-table-index-cell" : "sortable-table-data-cell",
              children: K
            },
            `${e.index?.[L] || L}-${T}`
          )) }, e.index?.[L] || L);
        }),
        i && /* @__PURE__ */ S.jsx(
          Jg,
          {
            style: {
              height: (D.length - j.endIndex - 1) * F.itemHeight
            },
            children: /* @__PURE__ */ S.jsx(Yg, { colSpan: p.header.length })
          }
        )
      ] });
    };
    return /* @__PURE__ */ S.jsxs(
      "div",
      {
        className: "sortable-table-wrapper",
        onKeyDown: q,
        tabIndex: o ? 0 : -1,
        role: o ? "application" : void 0,
        "aria-label": o ? "Sortable table with pagination" : void 0,
        children: [
          /* @__PURE__ */ S.jsx(
            EQ,
            {
              className: `sortable-table-container ${t}`,
              ref: E,
              onScroll: U,
              style: i ? { height: s } : void 0,
              children: /* @__PURE__ */ S.jsxs(fQ, { size: n, children: [
                /* @__PURE__ */ S.jsx(MQ, { className: "sortable-table-head", children: /* @__PURE__ */ S.jsx(Jg, { className: "sortable-table-header-row", children: p.header.map((W) => /* @__PURE__ */ S.jsx(
                  Yg,
                  {
                    className: "sortable-table-header-cell",
                    "aria-label": `Sort by ${W}`,
                    children: /* @__PURE__ */ S.jsx(
                      cZ,
                      {
                        active: y === W,
                        direction: y === W ? g : "asc",
                        onClick: () => M(W),
                        className: "sortable-table-sort-label",
                        sx: {
                          "& .MuiTableSortLabel-icon": {
                            color: "inherit !important"
                          }
                        },
                        children: W
                      }
                    )
                  },
                  W
                )) }) }),
                G()
              ] })
            }
          ),
          B()
        ]
      }
    );
  };
  qT.displayName = "SortableTable";
  function Te(e, t, { checkForDefaultPrevented: n = !0 } = {}) {
    return function(r) {
      if (e?.(r), n === !1 || !r.defaultPrevented)
        return t?.(r);
    };
  }
  function pI(e, t) {
    if (typeof e == "function")
      return e(t);
    e != null && (e.current = t);
  }
  function bw(...e) {
    return (t) => {
      let n = !1;
      const r = e.map((o) => {
        const a = pI(o, t);
        return !n && typeof a == "function" && (n = !0), a;
      });
      if (n)
        return () => {
          for (let o = 0; o < r.length; o++) {
            const a = r[o];
            typeof a == "function" ? a() : pI(e[o], null);
          }
        };
    };
  }
  function un(...e) {
    return C.useCallback(bw(...e), e);
  }
  function yZ(e, t) {
    const n = C.createContext(t), r = (a) => {
      const { children: i, ...s } = a, u = C.useMemo(() => s, Object.values(s));
      return /* @__PURE__ */ S.jsx(n.Provider, { value: u, children: i });
    };
    r.displayName = e + "Provider";
    function o(a) {
      const i = C.useContext(n);
      if (i) return i;
      if (t !== void 0) return t;
      throw new Error(`\`${a}\` must be used within \`${e}\``);
    }
    return [r, o];
  }
  function Ja(e, t = []) {
    let n = [];
    function r(a, i) {
      const s = C.createContext(i), u = n.length;
      n = [...n, i];
      const c = (p) => {
        const { scope: g, children: h, ...y } = p, b = g?.[e]?.[u] || s, v = C.useMemo(() => y, Object.values(y));
        return /* @__PURE__ */ S.jsx(b.Provider, { value: v, children: h });
      };
      c.displayName = a + "Provider";
      function f(p, g) {
        const h = g?.[e]?.[u] || s, y = C.useContext(h);
        if (y) return y;
        if (i !== void 0) return i;
        throw new Error(`\`${p}\` must be used within \`${a}\``);
      }
      return [c, f];
    }
    const o = () => {
      const a = n.map((i) => C.createContext(i));
      return function(i) {
        const s = i?.[e] || a;
        return C.useMemo(
          () => ({ [`__scope${e}`]: { ...i, [e]: s } }),
          [i, s]
        );
      };
    };
    return o.scopeName = e, [r, bZ(o, ...t)];
  }
  function bZ(...e) {
    const t = e[0];
    if (e.length === 1) return t;
    const n = () => {
      const r = e.map((o) => ({
        useScope: o(),
        scopeName: o.scopeName
      }));
      return function(o) {
        const a = r.reduce((i, { useScope: s, scopeName: u }) => {
          const c = s(o)[`__scope${u}`];
          return { ...i, ...c };
        }, {});
        return C.useMemo(() => ({ [`__scope${t.scopeName}`]: a }), [a]);
      };
    };
    return n.scopeName = t.scopeName, n;
  }
  var Hi = globalThis?.document ? C.useLayoutEffect : () => {
  }, wZ = Rm[" useId ".trim().toString()] || (() => {
  }), xZ = 0;
  function Ua(e) {
    const [t, n] = C.useState(wZ());
    return Hi(() => {
      n((r) => r ?? String(xZ++));
    }, [e]), t ? `radix-${t}` : "";
  }
  var kZ = Rm[" useInsertionEffect ".trim().toString()] || Hi;
  function ml({
    prop: e,
    defaultProp: t,
    onChange: n = () => {
    },
    caller: r
  }) {
    const [o, a, i] = SZ({
      defaultProp: t,
      onChange: n
    }), s = e !== void 0, u = s ? e : o;
    {
      const f = C.useRef(e !== void 0);
      C.useEffect(() => {
        const p = f.current;
        p !== s && console.warn(
          `${r} is changing from ${p ? "controlled" : "uncontrolled"} to ${s ? "controlled" : "uncontrolled"}. Components should not switch from controlled to uncontrolled (or vice versa). Decide between using a controlled or uncontrolled value for the lifetime of the component.`
        ), f.current = s;
      }, [s, r]);
    }
    const c = C.useCallback(
      (f) => {
        if (s) {
          const p = _Z(f) ? f(e) : f;
          p !== e && i.current?.(p);
        } else
          a(f);
      },
      [s, e, a, i]
    );
    return [u, c];
  }
  function SZ({
    defaultProp: e,
    onChange: t
  }) {
    const [n, r] = C.useState(e), o = C.useRef(n), a = C.useRef(t);
    return kZ(() => {
      a.current = t;
    }, [t]), C.useEffect(() => {
      o.current !== n && (a.current?.(n), o.current = n);
    }, [n, o]), [n, r, a];
  }
  function _Z(e) {
    return typeof e == "function";
  }
  // @__NO_SIDE_EFFECTS__
  function fd(e) {
    const t = /* @__PURE__ */ EZ(e), n = C.forwardRef((r, o) => {
      const { children: a, ...i } = r, s = C.Children.toArray(a), u = s.find(PZ);
      if (u) {
        const c = u.props.children, f = s.map((p) => p === u ? C.Children.count(c) > 1 ? C.Children.only(null) : C.isValidElement(c) ? c.props.children : null : p);
        return /* @__PURE__ */ S.jsx(t, { ...i, ref: o, children: C.isValidElement(c) ? C.cloneElement(c, void 0, f) : null });
      }
      return /* @__PURE__ */ S.jsx(t, { ...i, ref: o, children: a });
    });
    return n.displayName = `${e}.Slot`, n;
  }
  // @__NO_SIDE_EFFECTS__
  function EZ(e) {
    const t = C.forwardRef((n, r) => {
      const { children: o, ...a } = n;
      if (C.isValidElement(o)) {
        const i = NZ(o), s = OZ(a, o.props);
        return o.type !== C.Fragment && (s.ref = r ? bw(r, i) : i), C.cloneElement(o, s);
      }
      return C.Children.count(o) > 1 ? C.Children.only(null) : null;
    });
    return t.displayName = `${e}.SlotClone`, t;
  }
  var CZ = /* @__PURE__ */ Symbol("radix.slottable");
  function PZ(e) {
    return C.isValidElement(e) && typeof e.type == "function" && "__radixId" in e.type && e.type.__radixId === CZ;
  }
  function OZ(e, t) {
    const n = { ...t };
    for (const r in t) {
      const o = e[r], a = t[r];
      /^on[A-Z]/.test(r) ? o && a ? n[r] = (...i) => {
        const s = a(...i);
        return o(...i), s;
      } : o && (n[r] = o) : r === "style" ? n[r] = { ...o, ...a } : r === "className" && (n[r] = [o, a].filter(Boolean).join(" "));
    }
    return { ...e, ...n };
  }
  function NZ(e) {
    let t = Object.getOwnPropertyDescriptor(e.props, "ref")?.get, n = t && "isReactWarning" in t && t.isReactWarning;
    return n ? e.ref : (t = Object.getOwnPropertyDescriptor(e, "ref")?.get, n = t && "isReactWarning" in t && t.isReactWarning, n ? e.props.ref : e.props.ref || e.ref);
  }
  var MZ = [
    "a",
    "button",
    "div",
    "form",
    "h2",
    "h3",
    "img",
    "input",
    "label",
    "li",
    "nav",
    "ol",
    "p",
    "select",
    "span",
    "svg",
    "ul"
  ], gt = MZ.reduce((e, t) => {
    const n = /* @__PURE__ */ fd(`Primitive.${t}`), r = C.forwardRef((o, a) => {
      const { asChild: i, ...s } = o, u = i ? n : t;
      return typeof window < "u" && (window[/* @__PURE__ */ Symbol.for("radix-ui")] = !0), /* @__PURE__ */ S.jsx(u, { ...s, ref: a });
    });
    return r.displayName = `Primitive.${t}`, { ...e, [t]: r };
  }, {});
  function gC(e, t) {
    e && xu.flushSync(() => e.dispatchEvent(t));
  }
  function Wr(e) {
    const t = C.useRef(e);
    return C.useEffect(() => {
      t.current = e;
    }), C.useMemo(() => (...n) => t.current?.(...n), []);
  }
  function RZ(e, t = globalThis?.document) {
    const n = Wr(e);
    C.useEffect(() => {
      const r = (o) => {
        o.key === "Escape" && n(o);
      };
      return t.addEventListener("keydown", r, { capture: !0 }), () => t.removeEventListener("keydown", r, { capture: !0 });
    }, [n, t]);
  }
  var jZ = "DismissableLayer", d2 = "dismissableLayer.update", IZ = "dismissableLayer.pointerDownOutside", AZ = "dismissableLayer.focusOutside", mI, KT = C.createContext({
    layers: /* @__PURE__ */ new Set(),
    layersWithOutsidePointerEventsDisabled: /* @__PURE__ */ new Set(),
    branches: /* @__PURE__ */ new Set()
  }), Bm = C.forwardRef(
    (e, t) => {
      const {
        disableOutsidePointerEvents: n = !1,
        onEscapeKeyDown: r,
        onPointerDownOutside: o,
        onFocusOutside: a,
        onInteractOutside: i,
        onDismiss: s,
        ...u
      } = e, c = C.useContext(KT), [f, p] = C.useState(null), g = f?.ownerDocument ?? globalThis?.document, [, h] = C.useState({}), y = un(t, (M) => p(M)), b = Array.from(c.layers), [v] = [...c.layersWithOutsidePointerEventsDisabled].slice(-1), w = b.indexOf(v), _ = f ? b.indexOf(f) : -1, k = c.layersWithOutsidePointerEventsDisabled.size > 0, E = _ >= w, P = DZ((M) => {
        const I = M.target, A = [...c.branches].some((D) => D.contains(I));
        !E || A || (o?.(M), i?.(M), M.defaultPrevented || s?.());
      }, g), O = LZ((M) => {
        const I = M.target;
        [...c.branches].some((A) => A.contains(I)) || (a?.(M), i?.(M), M.defaultPrevented || s?.());
      }, g);
      return RZ((M) => {
        _ === c.layers.size - 1 && (r?.(M), !M.defaultPrevented && s && (M.preventDefault(), s()));
      }, g), C.useEffect(() => {
        if (f)
          return n && (c.layersWithOutsidePointerEventsDisabled.size === 0 && (mI = g.body.style.pointerEvents, g.body.style.pointerEvents = "none"), c.layersWithOutsidePointerEventsDisabled.add(f)), c.layers.add(f), hI(), () => {
            n && c.layersWithOutsidePointerEventsDisabled.size === 1 && (g.body.style.pointerEvents = mI);
          };
      }, [f, g, n, c]), C.useEffect(() => () => {
        f && (c.layers.delete(f), c.layersWithOutsidePointerEventsDisabled.delete(f), hI());
      }, [f, c]), C.useEffect(() => {
        const M = () => h({});
        return document.addEventListener(d2, M), () => document.removeEventListener(d2, M);
      }, []), /* @__PURE__ */ S.jsx(
        gt.div,
        {
          ...u,
          ref: y,
          style: {
            pointerEvents: k ? E ? "auto" : "none" : void 0,
            ...e.style
          },
          onFocusCapture: Te(e.onFocusCapture, O.onFocusCapture),
          onBlurCapture: Te(e.onBlurCapture, O.onBlurCapture),
          onPointerDownCapture: Te(
            e.onPointerDownCapture,
            P.onPointerDownCapture
          )
        }
      );
    }
  );
  Bm.displayName = jZ;
  var $Z = "DismissableLayerBranch", GT = C.forwardRef((e, t) => {
    const n = C.useContext(KT), r = C.useRef(null), o = un(t, r);
    return C.useEffect(() => {
      const a = r.current;
      if (a)
        return n.branches.add(a), () => {
          n.branches.delete(a);
        };
    }, [n.branches]), /* @__PURE__ */ S.jsx(gt.div, { ...e, ref: o });
  });
  GT.displayName = $Z;
  function DZ(e, t = globalThis?.document) {
    const n = Wr(e), r = C.useRef(!1), o = C.useRef(() => {
    });
    return C.useEffect(() => {
      const a = (s) => {
        if (s.target && !r.current) {
          let u = function() {
            XT(
              IZ,
              n,
              c,
              { discrete: !0 }
            );
          };
          const c = { originalEvent: s };
          s.pointerType === "touch" ? (t.removeEventListener("click", o.current), o.current = u, t.addEventListener("click", o.current, { once: !0 })) : u();
        } else
          t.removeEventListener("click", o.current);
        r.current = !1;
      }, i = window.setTimeout(() => {
        t.addEventListener("pointerdown", a);
      }, 0);
      return () => {
        window.clearTimeout(i), t.removeEventListener("pointerdown", a), t.removeEventListener("click", o.current);
      };
    }, [t, n]), {
      // ensures we check React component tree (not just DOM tree)
      onPointerDownCapture: () => r.current = !0
    };
  }
  function LZ(e, t = globalThis?.document) {
    const n = Wr(e), r = C.useRef(!1);
    return C.useEffect(() => {
      const o = (a) => {
        a.target && !r.current && XT(AZ, n, { originalEvent: a }, {
          discrete: !1
        });
      };
      return t.addEventListener("focusin", o), () => t.removeEventListener("focusin", o);
    }, [t, n]), {
      onFocusCapture: () => r.current = !0,
      onBlurCapture: () => r.current = !1
    };
  }
  function hI() {
    const e = new CustomEvent(d2);
    document.dispatchEvent(e);
  }
  function XT(e, t, n, { discrete: r }) {
    const o = n.originalEvent.target, a = new CustomEvent(e, { bubbles: !1, cancelable: !0, detail: n });
    t && o.addEventListener(e, t, { once: !0 }), r ? gC(o, a) : o.dispatchEvent(a);
  }
  var FZ = Bm, TZ = GT, m_ = "focusScope.autoFocusOnMount", h_ = "focusScope.autoFocusOnUnmount", gI = { bubbles: !1, cancelable: !0 }, zZ = "FocusScope", ww = C.forwardRef((e, t) => {
    const {
      loop: n = !1,
      trapped: r = !1,
      onMountAutoFocus: o,
      onUnmountAutoFocus: a,
      ...i
    } = e, [s, u] = C.useState(null), c = Wr(o), f = Wr(a), p = C.useRef(null), g = un(t, (b) => u(b)), h = C.useRef({
      paused: !1,
      pause() {
        this.paused = !0;
      },
      resume() {
        this.paused = !1;
      }
    }).current;
    C.useEffect(() => {
      if (r) {
        let b = function(k) {
          if (h.paused || !s) return;
          const E = k.target;
          s.contains(E) ? p.current = E : Bs(p.current, { select: !0 });
        }, v = function(k) {
          if (h.paused || !s) return;
          const E = k.relatedTarget;
          E !== null && (s.contains(E) || Bs(p.current, { select: !0 }));
        }, w = function(k) {
          if (document.activeElement === document.body)
            for (const E of k)
              E.removedNodes.length > 0 && Bs(s);
        };
        document.addEventListener("focusin", b), document.addEventListener("focusout", v);
        const _ = new MutationObserver(w);
        return s && _.observe(s, { childList: !0, subtree: !0 }), () => {
          document.removeEventListener("focusin", b), document.removeEventListener("focusout", v), _.disconnect();
        };
      }
    }, [r, s, h.paused]), C.useEffect(() => {
      if (s) {
        yI.add(h);
        const b = document.activeElement;
        if (!s.contains(b)) {
          const v = new CustomEvent(m_, gI);
          s.addEventListener(m_, c), s.dispatchEvent(v), v.defaultPrevented || (BZ(qZ(YT(s)), { select: !0 }), document.activeElement === b && Bs(s));
        }
        return () => {
          s.removeEventListener(m_, c), setTimeout(() => {
            const v = new CustomEvent(h_, gI);
            s.addEventListener(h_, f), s.dispatchEvent(v), v.defaultPrevented || Bs(b ?? document.body, { select: !0 }), s.removeEventListener(h_, f), yI.remove(h);
          }, 0);
        };
      }
    }, [s, c, f, h]);
    const y = C.useCallback(
      (b) => {
        if (!n && !r || h.paused) return;
        const v = b.key === "Tab" && !b.altKey && !b.ctrlKey && !b.metaKey, w = document.activeElement;
        if (v && w) {
          const _ = b.currentTarget, [k, E] = VZ(_);
          k && E ? !b.shiftKey && w === E ? (b.preventDefault(), n && Bs(k, { select: !0 })) : b.shiftKey && w === k && (b.preventDefault(), n && Bs(E, { select: !0 })) : w === _ && b.preventDefault();
        }
      },
      [n, r, h.paused]
    );
    return /* @__PURE__ */ S.jsx(gt.div, { tabIndex: -1, ...i, ref: g, onKeyDown: y });
  });
  ww.displayName = zZ;
  function BZ(e, { select: t = !1 } = {}) {
    const n = document.activeElement;
    for (const r of e)
      if (Bs(r, { select: t }), document.activeElement !== n) return;
  }
  function VZ(e) {
    const t = YT(e), n = vI(t, e), r = vI(t.reverse(), e);
    return [n, r];
  }
  function YT(e) {
    const t = [], n = document.createTreeWalker(e, NodeFilter.SHOW_ELEMENT, {
      acceptNode: (r) => {
        const o = r.tagName === "INPUT" && r.type === "hidden";
        return r.disabled || r.hidden || o ? NodeFilter.FILTER_SKIP : r.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
      }
    });
    for (; n.nextNode(); ) t.push(n.currentNode);
    return t;
  }
  function vI(e, t) {
    for (const n of e)
      if (!UZ(n, { upTo: t })) return n;
  }
  function UZ(e, { upTo: t }) {
    if (getComputedStyle(e).visibility === "hidden") return !0;
    for (; e; ) {
      if (t !== void 0 && e === t) return !1;
      if (getComputedStyle(e).display === "none") return !0;
      e = e.parentElement;
    }
    return !1;
  }
  function HZ(e) {
    return e instanceof HTMLInputElement && "select" in e;
  }
  function Bs(e, { select: t = !1 } = {}) {
    if (e && e.focus) {
      const n = document.activeElement;
      e.focus({ preventScroll: !0 }), e !== n && HZ(e) && t && e.select();
    }
  }
  var yI = WZ();
  function WZ() {
    let e = [];
    return {
      add(t) {
        const n = e[0];
        t !== n && n?.pause(), e = bI(e, t), e.unshift(t);
      },
      remove(t) {
        e = bI(e, t), e[0]?.resume();
      }
    };
  }
  function bI(e, t) {
    const n = [...e], r = n.indexOf(t);
    return r !== -1 && n.splice(r, 1), n;
  }
  function qZ(e) {
    return e.filter((t) => t.tagName !== "A");
  }
  var KZ = "Portal", xw = C.forwardRef((e, t) => {
    const { container: n, ...r } = e, [o, a] = C.useState(!1);
    Hi(() => a(!0), []);
    const i = n || o && globalThis?.document?.body;
    return i ? Hc.createPortal(/* @__PURE__ */ S.jsx(gt.div, { ...r, ref: t }), i) : null;
  });
  xw.displayName = KZ;
  function GZ(e, t) {
    return C.useReducer((n, r) => t[n][r] ?? n, e);
  }
  var ia = (e) => {
    const { present: t, children: n } = e, r = XZ(t), o = typeof n == "function" ? n({ present: r.isPresent }) : C.Children.only(n), a = un(r.ref, YZ(o));
    return typeof n == "function" || r.isPresent ? C.cloneElement(o, { ref: a }) : null;
  };
  ia.displayName = "Presence";
  function XZ(e) {
    const [t, n] = C.useState(), r = C.useRef(null), o = C.useRef(e), a = C.useRef("none"), i = e ? "mounted" : "unmounted", [s, u] = GZ(i, {
      mounted: {
        UNMOUNT: "unmounted",
        ANIMATION_OUT: "unmountSuspended"
      },
      unmountSuspended: {
        MOUNT: "mounted",
        ANIMATION_END: "unmounted"
      },
      unmounted: {
        MOUNT: "mounted"
      }
    });
    return C.useEffect(() => {
      const c = Qg(r.current);
      a.current = s === "mounted" ? c : "none";
    }, [s]), Hi(() => {
      const c = r.current, f = o.current;
      if (f !== e) {
        const p = a.current, g = Qg(c);
        e ? u("MOUNT") : g === "none" || c?.display === "none" ? u("UNMOUNT") : u(f && p !== g ? "ANIMATION_OUT" : "UNMOUNT"), o.current = e;
      }
    }, [e, u]), Hi(() => {
      if (t) {
        let c;
        const f = t.ownerDocument.defaultView ?? window, p = (h) => {
          const y = Qg(r.current).includes(CSS.escape(h.animationName));
          if (h.target === t && y && (u("ANIMATION_END"), !o.current)) {
            const b = t.style.animationFillMode;
            t.style.animationFillMode = "forwards", c = f.setTimeout(() => {
              t.style.animationFillMode === "forwards" && (t.style.animationFillMode = b);
            });
          }
        }, g = (h) => {
          h.target === t && (a.current = Qg(r.current));
        };
        return t.addEventListener("animationstart", g), t.addEventListener("animationcancel", p), t.addEventListener("animationend", p), () => {
          f.clearTimeout(c), t.removeEventListener("animationstart", g), t.removeEventListener("animationcancel", p), t.removeEventListener("animationend", p);
        };
      } else
        u("ANIMATION_END");
    }, [t, u]), {
      isPresent: ["mounted", "unmountSuspended"].includes(s),
      ref: C.useCallback((c) => {
        r.current = c ? getComputedStyle(c) : null, n(c);
      }, [])
    };
  }
  function Qg(e) {
    return e?.animationName || "none";
  }
  function YZ(e) {
    let t = Object.getOwnPropertyDescriptor(e.props, "ref")?.get, n = t && "isReactWarning" in t && t.isReactWarning;
    return n ? e.ref : (t = Object.getOwnPropertyDescriptor(e, "ref")?.get, n = t && "isReactWarning" in t && t.isReactWarning, n ? e.props.ref : e.props.ref || e.ref);
  }
  var g_ = 0;
  function vC() {
    C.useEffect(() => {
      const e = document.querySelectorAll("[data-radix-focus-guard]");
      return document.body.insertAdjacentElement("afterbegin", e[0] ?? wI()), document.body.insertAdjacentElement("beforeend", e[1] ?? wI()), g_++, () => {
        g_ === 1 && document.querySelectorAll("[data-radix-focus-guard]").forEach((t) => t.remove()), g_--;
      };
    }, []);
  }
  function wI() {
    const e = document.createElement("span");
    return e.setAttribute("data-radix-focus-guard", ""), e.tabIndex = 0, e.style.outline = "none", e.style.opacity = "0", e.style.position = "fixed", e.style.pointerEvents = "none", e;
  }
  var Ma = function() {
    return Ma = Object.assign || function(e) {
      for (var t, n = 1, r = arguments.length; n < r; n++) {
        t = arguments[n];
        for (var o in t) Object.prototype.hasOwnProperty.call(t, o) && (e[o] = t[o]);
      }
      return e;
    }, Ma.apply(this, arguments);
  };
  function JT(e, t) {
    var n = {};
    for (var r in e) Object.prototype.hasOwnProperty.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
    if (e != null && typeof Object.getOwnPropertySymbols == "function")
      for (var o = 0, r = Object.getOwnPropertySymbols(e); o < r.length; o++)
        t.indexOf(r[o]) < 0 && Object.prototype.propertyIsEnumerable.call(e, r[o]) && (n[r[o]] = e[r[o]]);
    return n;
  }
  function Cy(e, t, n) {
    if (n || arguments.length === 2) for (var r = 0, o = t.length, a; r < o; r++)
      (a || !(r in t)) && (a || (a = Array.prototype.slice.call(t, 0, r)), a[r] = t[r]);
    return e.concat(a || Array.prototype.slice.call(t));
  }
  var Py = "right-scroll-bar-position", Oy = "width-before-scroll-bar", JZ = "with-scroll-bars-hidden", QZ = "--removed-body-scroll-bar-size";
  function v_(e, t) {
    return typeof e == "function" ? e(t) : e && (e.current = t), e;
  }
  function ZZ(e, t) {
    var n = C.useState(function() {
      return {
        // value
        value: e,
        // last callback
        callback: t,
        // "memoized" public interface
        facade: {
          get current() {
            return n.value;
          },
          set current(r) {
            var o = n.value;
            o !== r && (n.value = r, n.callback(r, o));
          }
        }
      };
    })[0];
    return n.callback = t, n.facade;
  }
  var eee = typeof window < "u" ? C.useLayoutEffect : C.useEffect, xI = /* @__PURE__ */ new WeakMap();
  function tee(e, t) {
    var n = ZZ(null, function(r) {
      return e.forEach(function(o) {
        return v_(o, r);
      });
    });
    return eee(function() {
      var r = xI.get(n);
      if (r) {
        var o = new Set(r), a = new Set(e), i = n.current;
        o.forEach(function(s) {
          a.has(s) || v_(s, null);
        }), a.forEach(function(s) {
          o.has(s) || v_(s, i);
        });
      }
      xI.set(n, e);
    }, [e]), n;
  }
  function nee(e) {
    return e;
  }
  function ree(e, t) {
    t === void 0 && (t = nee);
    var n = [], r = !1, o = {
      read: function() {
        if (r)
          throw new Error("Sidecar: could not `read` from an `assigned` medium. `read` could be used only with `useMedium`.");
        return n.length ? n[n.length - 1] : e;
      },
      useMedium: function(a) {
        var i = t(a, r);
        return n.push(i), function() {
          n = n.filter(function(s) {
            return s !== i;
          });
        };
      },
      assignSyncMedium: function(a) {
        for (r = !0; n.length; ) {
          var i = n;
          n = [], i.forEach(a);
        }
        n = {
          push: function(s) {
            return a(s);
          },
          filter: function() {
            return n;
          }
        };
      },
      assignMedium: function(a) {
        r = !0;
        var i = [];
        if (n.length) {
          var s = n;
          n = [], s.forEach(a), i = n;
        }
        var u = function() {
          var f = i;
          i = [], f.forEach(a);
        }, c = function() {
          return Promise.resolve().then(u);
        };
        c(), n = {
          push: function(f) {
            i.push(f), c();
          },
          filter: function(f) {
            return i = i.filter(f), n;
          }
        };
      }
    };
    return o;
  }
  function oee(e) {
    e === void 0 && (e = {});
    var t = ree(null);
    return t.options = Ma({ async: !0, ssr: !1 }, e), t;
  }
  var QT = function(e) {
    var t = e.sideCar, n = JT(e, ["sideCar"]);
    if (!t)
      throw new Error("Sidecar: please provide `sideCar` property to import the right car");
    var r = t.read();
    if (!r)
      throw new Error("Sidecar medium not found");
    return C.createElement(r, Ma({}, n));
  };
  QT.isSideCarExport = !0;
  function aee(e, t) {
    return e.useMedium(t), QT;
  }
  var ZT = oee(), y_ = function() {
  }, kw = C.forwardRef(function(e, t) {
    var n = C.useRef(null), r = C.useState({
      onScrollCapture: y_,
      onWheelCapture: y_,
      onTouchMoveCapture: y_
    }), o = r[0], a = r[1], i = e.forwardProps, s = e.children, u = e.className, c = e.removeScrollBar, f = e.enabled, p = e.shards, g = e.sideCar, h = e.noRelative, y = e.noIsolation, b = e.inert, v = e.allowPinchZoom, w = e.as, _ = w === void 0 ? "div" : w, k = e.gapMode, E = JT(e, ["forwardProps", "children", "className", "removeScrollBar", "enabled", "shards", "sideCar", "noRelative", "noIsolation", "inert", "allowPinchZoom", "as", "gapMode"]), P = g, O = tee([n, t]), M = Ma(Ma({}, E), o);
    return C.createElement(
      C.Fragment,
      null,
      f && C.createElement(P, { sideCar: ZT, removeScrollBar: c, shards: p, noRelative: h, noIsolation: y, inert: b, setCallbacks: a, allowPinchZoom: !!v, lockRef: n, gapMode: k }),
      i ? C.cloneElement(C.Children.only(s), Ma(Ma({}, M), { ref: O })) : C.createElement(_, Ma({}, M, { className: u, ref: O }), s)
    );
  });
  kw.defaultProps = {
    enabled: !0,
    removeScrollBar: !0,
    inert: !1
  };
  kw.classNames = {
    fullWidth: Oy,
    zeroRight: Py
  };
  var iee = function() {
    if (typeof __webpack_nonce__ < "u")
      return __webpack_nonce__;
  };
  function see() {
    if (!document)
      return null;
    var e = document.createElement("style");
    e.type = "text/css";
    var t = iee();
    return t && e.setAttribute("nonce", t), e;
  }
  function lee(e, t) {
    e.styleSheet ? e.styleSheet.cssText = t : e.appendChild(document.createTextNode(t));
  }
  function uee(e) {
    var t = document.head || document.getElementsByTagName("head")[0];
    t.appendChild(e);
  }
  var cee = function() {
    var e = 0, t = null;
    return {
      add: function(n) {
        e == 0 && (t = see()) && (lee(t, n), uee(t)), e++;
      },
      remove: function() {
        e--, !e && t && (t.parentNode && t.parentNode.removeChild(t), t = null);
      }
    };
  }, dee = function() {
    var e = cee();
    return function(t, n) {
      C.useEffect(function() {
        return e.add(t), function() {
          e.remove();
        };
      }, [t && n]);
    };
  }, e6 = function() {
    var e = dee(), t = function(n) {
      var r = n.styles, o = n.dynamic;
      return e(r, o), null;
    };
    return t;
  }, fee = {
    left: 0,
    top: 0,
    right: 0,
    gap: 0
  }, b_ = function(e) {
    return parseInt(e || "", 10) || 0;
  }, pee = function(e) {
    var t = window.getComputedStyle(document.body), n = t[e === "padding" ? "paddingLeft" : "marginLeft"], r = t[e === "padding" ? "paddingTop" : "marginTop"], o = t[e === "padding" ? "paddingRight" : "marginRight"];
    return [b_(n), b_(r), b_(o)];
  }, mee = function(e) {
    if (e === void 0 && (e = "margin"), typeof window > "u")
      return fee;
    var t = pee(e), n = document.documentElement.clientWidth, r = window.innerWidth;
    return {
      left: t[0],
      top: t[1],
      right: t[2],
      gap: Math.max(0, r - n + t[2] - t[0])
    };
  }, hee = e6(), td = "data-scroll-locked", gee = function(e, t, n, r) {
    var o = e.left, a = e.top, i = e.right, s = e.gap;
    return n === void 0 && (n = "margin"), `
  .`.concat(JZ, ` {
   overflow: hidden `).concat(r, `;
   padding-right: `).concat(s, "px ").concat(r, `;
  }
  body[`).concat(td, `] {
    overflow: hidden `).concat(r, `;
    overscroll-behavior: contain;
    `).concat([
      t && "position: relative ".concat(r, ";"),
      n === "margin" && `
    padding-left: `.concat(o, `px;
    padding-top: `).concat(a, `px;
    padding-right: `).concat(i, `px;
    margin-left:0;
    margin-top:0;
    margin-right: `).concat(s, "px ").concat(r, `;
    `),
      n === "padding" && "padding-right: ".concat(s, "px ").concat(r, ";")
    ].filter(Boolean).join(""), `
  }

  .`).concat(Py, ` {
    right: `).concat(s, "px ").concat(r, `;
  }

  .`).concat(Oy, ` {
    margin-right: `).concat(s, "px ").concat(r, `;
  }

  .`).concat(Py, " .").concat(Py, ` {
    right: 0 `).concat(r, `;
  }

  .`).concat(Oy, " .").concat(Oy, ` {
    margin-right: 0 `).concat(r, `;
  }

  body[`).concat(td, `] {
    `).concat(QZ, ": ").concat(s, `px;
  }
`);
  }, kI = function() {
    var e = parseInt(document.body.getAttribute(td) || "0", 10);
    return isFinite(e) ? e : 0;
  }, vee = function() {
    C.useEffect(function() {
      return document.body.setAttribute(td, (kI() + 1).toString()), function() {
        var e = kI() - 1;
        e <= 0 ? document.body.removeAttribute(td) : document.body.setAttribute(td, e.toString());
      };
    }, []);
  }, yee = function(e) {
    var t = e.noRelative, n = e.noImportant, r = e.gapMode, o = r === void 0 ? "margin" : r;
    vee();
    var a = C.useMemo(function() {
      return mee(o);
    }, [o]);
    return C.createElement(hee, { styles: gee(a, !t, o, n ? "" : "!important") });
  }, f2 = !1;
  if (typeof window < "u")
    try {
      var Zg = Object.defineProperty({}, "passive", {
        get: function() {
          return f2 = !0, !0;
        }
      });
      window.addEventListener("test", Zg, Zg), window.removeEventListener("test", Zg, Zg);
    } catch {
      f2 = !1;
    }
  var _c = f2 ? { passive: !1 } : !1, bee = function(e) {
    return e.tagName === "TEXTAREA";
  }, t6 = function(e, t) {
    if (!(e instanceof Element))
      return !1;
    var n = window.getComputedStyle(e);
    return (
      // not-not-scrollable
      n[t] !== "hidden" && // contains scroll inside self
      !(n.overflowY === n.overflowX && !bee(e) && n[t] === "visible")
    );
  }, wee = function(e) {
    return t6(e, "overflowY");
  }, xee = function(e) {
    return t6(e, "overflowX");
  }, SI = function(e, t) {
    var n = t.ownerDocument, r = t;
    do {
      typeof ShadowRoot < "u" && r instanceof ShadowRoot && (r = r.host);
      var o = n6(e, r);
      if (o) {
        var a = r6(e, r), i = a[1], s = a[2];
        if (i > s)
          return !0;
      }
      r = r.parentNode;
    } while (r && r !== n.body);
    return !1;
  }, kee = function(e) {
    var t = e.scrollTop, n = e.scrollHeight, r = e.clientHeight;
    return [
      t,
      n,
      r
    ];
  }, See = function(e) {
    var t = e.scrollLeft, n = e.scrollWidth, r = e.clientWidth;
    return [
      t,
      n,
      r
    ];
  }, n6 = function(e, t) {
    return e === "v" ? wee(t) : xee(t);
  }, r6 = function(e, t) {
    return e === "v" ? kee(t) : See(t);
  }, _ee = function(e, t) {
    return e === "h" && t === "rtl" ? -1 : 1;
  }, Eee = function(e, t, n, r, o) {
    var a = _ee(e, window.getComputedStyle(t).direction), i = a * r, s = n.target, u = t.contains(s), c = !1, f = i > 0, p = 0, g = 0;
    do {
      if (!s)
        break;
      var h = r6(e, s), y = h[0], b = h[1], v = h[2], w = b - v - a * y;
      (y || w) && n6(e, s) && (p += w, g += y);
      var _ = s.parentNode;
      s = _ && _.nodeType === Node.DOCUMENT_FRAGMENT_NODE ? _.host : _;
    } while (
      // portaled content
      !u && s !== document.body || // self content
      u && (t.contains(s) || t === s)
    );
    return (f && Math.abs(p) < 1 || !f && Math.abs(g) < 1) && (c = !0), c;
  }, ev = function(e) {
    return "changedTouches" in e ? [e.changedTouches[0].clientX, e.changedTouches[0].clientY] : [0, 0];
  }, _I = function(e) {
    return [e.deltaX, e.deltaY];
  }, EI = function(e) {
    return e && "current" in e ? e.current : e;
  }, Cee = function(e, t) {
    return e[0] === t[0] && e[1] === t[1];
  }, Pee = function(e) {
    return `
  .block-interactivity-`.concat(e, ` {pointer-events: none;}
  .allow-interactivity-`).concat(e, ` {pointer-events: all;}
`);
  }, Oee = 0, Ec = [];
  function Nee(e) {
    var t = C.useRef([]), n = C.useRef([0, 0]), r = C.useRef(), o = C.useState(Oee++)[0], a = C.useState(e6)[0], i = C.useRef(e);
    C.useEffect(function() {
      i.current = e;
    }, [e]), C.useEffect(function() {
      if (e.inert) {
        document.body.classList.add("block-interactivity-".concat(o));
        var b = Cy([e.lockRef.current], (e.shards || []).map(EI), !0).filter(Boolean);
        return b.forEach(function(v) {
          return v.classList.add("allow-interactivity-".concat(o));
        }), function() {
          document.body.classList.remove("block-interactivity-".concat(o)), b.forEach(function(v) {
            return v.classList.remove("allow-interactivity-".concat(o));
          });
        };
      }
    }, [e.inert, e.lockRef.current, e.shards]);
    var s = C.useCallback(function(b, v) {
      if ("touches" in b && b.touches.length === 2 || b.type === "wheel" && b.ctrlKey)
        return !i.current.allowPinchZoom;
      var w = ev(b), _ = n.current, k = "deltaX" in b ? b.deltaX : _[0] - w[0], E = "deltaY" in b ? b.deltaY : _[1] - w[1], P, O = b.target, M = Math.abs(k) > Math.abs(E) ? "h" : "v";
      if ("touches" in b && M === "h" && O.type === "range")
        return !1;
      var I = SI(M, O);
      if (!I)
        return !0;
      if (I ? P = M : (P = M === "v" ? "h" : "v", I = SI(M, O)), !I)
        return !1;
      if (!r.current && "changedTouches" in b && (k || E) && (r.current = P), !P)
        return !0;
      var A = r.current || P;
      return Eee(A, v, b, A === "h" ? k : E);
    }, []), u = C.useCallback(function(b) {
      var v = b;
      if (!(!Ec.length || Ec[Ec.length - 1] !== a)) {
        var w = "deltaY" in v ? _I(v) : ev(v), _ = t.current.filter(function(P) {
          return P.name === v.type && (P.target === v.target || v.target === P.shadowParent) && Cee(P.delta, w);
        })[0];
        if (_ && _.should) {
          v.cancelable && v.preventDefault();
          return;
        }
        if (!_) {
          var k = (i.current.shards || []).map(EI).filter(Boolean).filter(function(P) {
            return P.contains(v.target);
          }), E = k.length > 0 ? s(v, k[0]) : !i.current.noIsolation;
          E && v.cancelable && v.preventDefault();
        }
      }
    }, []), c = C.useCallback(function(b, v, w, _) {
      var k = { name: b, delta: v, target: w, should: _, shadowParent: Mee(w) };
      t.current.push(k), setTimeout(function() {
        t.current = t.current.filter(function(E) {
          return E !== k;
        });
      }, 1);
    }, []), f = C.useCallback(function(b) {
      n.current = ev(b), r.current = void 0;
    }, []), p = C.useCallback(function(b) {
      c(b.type, _I(b), b.target, s(b, e.lockRef.current));
    }, []), g = C.useCallback(function(b) {
      c(b.type, ev(b), b.target, s(b, e.lockRef.current));
    }, []);
    C.useEffect(function() {
      return Ec.push(a), e.setCallbacks({
        onScrollCapture: p,
        onWheelCapture: p,
        onTouchMoveCapture: g
      }), document.addEventListener("wheel", u, _c), document.addEventListener("touchmove", u, _c), document.addEventListener("touchstart", f, _c), function() {
        Ec = Ec.filter(function(b) {
          return b !== a;
        }), document.removeEventListener("wheel", u, _c), document.removeEventListener("touchmove", u, _c), document.removeEventListener("touchstart", f, _c);
      };
    }, []);
    var h = e.removeScrollBar, y = e.inert;
    return C.createElement(
      C.Fragment,
      null,
      y ? C.createElement(a, { styles: Pee(o) }) : null,
      h ? C.createElement(yee, { noRelative: e.noRelative, gapMode: e.gapMode }) : null
    );
  }
  function Mee(e) {
    for (var t = null; e !== null; )
      e instanceof ShadowRoot && (t = e.host, e = e.host), e = e.parentNode;
    return t;
  }
  const Ree = aee(ZT, Nee);
  var Sw = C.forwardRef(function(e, t) {
    return C.createElement(kw, Ma({}, e, { ref: t, sideCar: Ree }));
  });
  Sw.classNames = kw.classNames;
  var jee = function(e) {
    if (typeof document > "u")
      return null;
    var t = Array.isArray(e) ? e[0] : e;
    return t.ownerDocument.body;
  }, Cc = /* @__PURE__ */ new WeakMap(), tv = /* @__PURE__ */ new WeakMap(), nv = {}, w_ = 0, o6 = function(e) {
    return e && (e.host || o6(e.parentNode));
  }, Iee = function(e, t) {
    return t.map(function(n) {
      if (e.contains(n))
        return n;
      var r = o6(n);
      return r && e.contains(r) ? r : (console.error("aria-hidden", n, "in not contained inside", e, ". Doing nothing"), null);
    }).filter(function(n) {
      return !!n;
    });
  }, Aee = function(e, t, n, r) {
    var o = Iee(t, Array.isArray(e) ? e : [e]);
    nv[n] || (nv[n] = /* @__PURE__ */ new WeakMap());
    var a = nv[n], i = [], s = /* @__PURE__ */ new Set(), u = new Set(o), c = function(p) {
      !p || s.has(p) || (s.add(p), c(p.parentNode));
    };
    o.forEach(c);
    var f = function(p) {
      !p || u.has(p) || Array.prototype.forEach.call(p.children, function(g) {
        if (s.has(g))
          f(g);
        else
          try {
            var h = g.getAttribute(r), y = h !== null && h !== "false", b = (Cc.get(g) || 0) + 1, v = (a.get(g) || 0) + 1;
            Cc.set(g, b), a.set(g, v), i.push(g), b === 1 && y && tv.set(g, !0), v === 1 && g.setAttribute(n, "true"), y || g.setAttribute(r, "true");
          } catch (w) {
            console.error("aria-hidden: cannot operate on ", g, w);
          }
      });
    };
    return f(t), s.clear(), w_++, function() {
      i.forEach(function(p) {
        var g = Cc.get(p) - 1, h = a.get(p) - 1;
        Cc.set(p, g), a.set(p, h), g || (tv.has(p) || p.removeAttribute(r), tv.delete(p)), h || p.removeAttribute(n);
      }), w_--, w_ || (Cc = /* @__PURE__ */ new WeakMap(), Cc = /* @__PURE__ */ new WeakMap(), tv = /* @__PURE__ */ new WeakMap(), nv = {});
    };
  }, yC = function(e, t, n) {
    n === void 0 && (n = "data-aria-hidden");
    var r = Array.from(Array.isArray(e) ? e : [e]), o = jee(e);
    return o ? (r.push.apply(r, Array.from(o.querySelectorAll("[aria-live], script"))), Aee(r, o, n, "aria-hidden")) : function() {
      return null;
    };
  }, _w = "Dialog", [a6] = Ja(_w), [$ee, sa] = a6(_w), i6 = (e) => {
    const {
      __scopeDialog: t,
      children: n,
      open: r,
      defaultOpen: o,
      onOpenChange: a,
      modal: i = !0
    } = e, s = C.useRef(null), u = C.useRef(null), [c, f] = ml({
      prop: r,
      defaultProp: o ?? !1,
      onChange: a,
      caller: _w
    });
    return /* @__PURE__ */ S.jsx(
      $ee,
      {
        scope: t,
        triggerRef: s,
        contentRef: u,
        contentId: Ua(),
        titleId: Ua(),
        descriptionId: Ua(),
        open: c,
        onOpenChange: f,
        onOpenToggle: C.useCallback(() => f((p) => !p), [f]),
        modal: i,
        children: n
      }
    );
  };
  i6.displayName = _w;
  var s6 = "DialogTrigger", l6 = C.forwardRef(
    (e, t) => {
      const { __scopeDialog: n, ...r } = e, o = sa(s6, n), a = un(t, o.triggerRef);
      return /* @__PURE__ */ S.jsx(
        gt.button,
        {
          type: "button",
          "aria-haspopup": "dialog",
          "aria-expanded": o.open,
          "aria-controls": o.contentId,
          "data-state": xC(o.open),
          ...r,
          ref: a,
          onClick: Te(e.onClick, o.onOpenToggle)
        }
      );
    }
  );
  l6.displayName = s6;
  var bC = "DialogPortal", [Dee, u6] = a6(bC, {
    forceMount: void 0
  }), c6 = (e) => {
    const { __scopeDialog: t, forceMount: n, children: r, container: o } = e, a = sa(bC, t);
    return /* @__PURE__ */ S.jsx(Dee, { scope: t, forceMount: n, children: C.Children.map(r, (i) => /* @__PURE__ */ S.jsx(ia, { present: n || a.open, children: /* @__PURE__ */ S.jsx(xw, { asChild: !0, container: o, children: i }) })) });
  };
  c6.displayName = bC;
  var ob = "DialogOverlay", d6 = C.forwardRef(
    (e, t) => {
      const n = u6(ob, e.__scopeDialog), { forceMount: r = n.forceMount, ...o } = e, a = sa(ob, e.__scopeDialog);
      return a.modal ? /* @__PURE__ */ S.jsx(ia, { present: r || a.open, children: /* @__PURE__ */ S.jsx(Fee, { ...o, ref: t }) }) : null;
    }
  );
  d6.displayName = ob;
  var Lee = /* @__PURE__ */ fd("DialogOverlay.RemoveScroll"), Fee = C.forwardRef(
    (e, t) => {
      const { __scopeDialog: n, ...r } = e, o = sa(ob, n);
      return (
        // Make sure `Content` is scrollable even when it doesn't live inside `RemoveScroll`
        // ie. when `Overlay` and `Content` are siblings
        /* @__PURE__ */ S.jsx(Sw, { as: Lee, allowPinchZoom: !0, shards: [o.contentRef], children: /* @__PURE__ */ S.jsx(
          gt.div,
          {
            "data-state": xC(o.open),
            ...r,
            ref: t,
            style: { pointerEvents: "auto", ...r.style }
          }
        ) })
      );
    }
  ), iu = "DialogContent", f6 = C.forwardRef(
    (e, t) => {
      const n = u6(iu, e.__scopeDialog), { forceMount: r = n.forceMount, ...o } = e, a = sa(iu, e.__scopeDialog);
      return /* @__PURE__ */ S.jsx(ia, { present: r || a.open, children: a.modal ? /* @__PURE__ */ S.jsx(Tee, { ...o, ref: t }) : /* @__PURE__ */ S.jsx(zee, { ...o, ref: t }) });
    }
  );
  f6.displayName = iu;
  var Tee = C.forwardRef(
    (e, t) => {
      const n = sa(iu, e.__scopeDialog), r = C.useRef(null), o = un(t, n.contentRef, r);
      return C.useEffect(() => {
        const a = r.current;
        if (a) return yC(a);
      }, []), /* @__PURE__ */ S.jsx(
        p6,
        {
          ...e,
          ref: o,
          trapFocus: n.open,
          disableOutsidePointerEvents: !0,
          onCloseAutoFocus: Te(e.onCloseAutoFocus, (a) => {
            a.preventDefault(), n.triggerRef.current?.focus();
          }),
          onPointerDownOutside: Te(e.onPointerDownOutside, (a) => {
            const i = a.detail.originalEvent, s = i.button === 0 && i.ctrlKey === !0;
            (i.button === 2 || s) && a.preventDefault();
          }),
          onFocusOutside: Te(
            e.onFocusOutside,
            (a) => a.preventDefault()
          )
        }
      );
    }
  ), zee = C.forwardRef(
    (e, t) => {
      const n = sa(iu, e.__scopeDialog), r = C.useRef(!1), o = C.useRef(!1);
      return /* @__PURE__ */ S.jsx(
        p6,
        {
          ...e,
          ref: t,
          trapFocus: !1,
          disableOutsidePointerEvents: !1,
          onCloseAutoFocus: (a) => {
            e.onCloseAutoFocus?.(a), a.defaultPrevented || (r.current || n.triggerRef.current?.focus(), a.preventDefault()), r.current = !1, o.current = !1;
          },
          onInteractOutside: (a) => {
            e.onInteractOutside?.(a), a.defaultPrevented || (r.current = !0, a.detail.originalEvent.type === "pointerdown" && (o.current = !0));
            const i = a.target;
            n.triggerRef.current?.contains(i) && a.preventDefault(), a.detail.originalEvent.type === "focusin" && o.current && a.preventDefault();
          }
        }
      );
    }
  ), p6 = C.forwardRef(
    (e, t) => {
      const { __scopeDialog: n, trapFocus: r, onOpenAutoFocus: o, onCloseAutoFocus: a, ...i } = e, s = sa(iu, n), u = C.useRef(null), c = un(t, u);
      return vC(), /* @__PURE__ */ S.jsxs(S.Fragment, { children: [
        /* @__PURE__ */ S.jsx(
          ww,
          {
            asChild: !0,
            loop: !0,
            trapped: r,
            onMountAutoFocus: o,
            onUnmountAutoFocus: a,
            children: /* @__PURE__ */ S.jsx(
              Bm,
              {
                role: "dialog",
                id: s.contentId,
                "aria-describedby": s.descriptionId,
                "aria-labelledby": s.titleId,
                "data-state": xC(s.open),
                ...i,
                ref: c,
                onDismiss: () => s.onOpenChange(!1)
              }
            )
          }
        ),
        /* @__PURE__ */ S.jsxs(S.Fragment, { children: [
          /* @__PURE__ */ S.jsx(Bee, { titleId: s.titleId }),
          /* @__PURE__ */ S.jsx(Uee, { contentRef: u, descriptionId: s.descriptionId })
        ] })
      ] });
    }
  ), wC = "DialogTitle", m6 = C.forwardRef(
    (e, t) => {
      const { __scopeDialog: n, ...r } = e, o = sa(wC, n);
      return /* @__PURE__ */ S.jsx(gt.h2, { id: o.titleId, ...r, ref: t });
    }
  );
  m6.displayName = wC;
  var h6 = "DialogDescription", g6 = C.forwardRef(
    (e, t) => {
      const { __scopeDialog: n, ...r } = e, o = sa(h6, n);
      return /* @__PURE__ */ S.jsx(gt.p, { id: o.descriptionId, ...r, ref: t });
    }
  );
  g6.displayName = h6;
  var v6 = "DialogClose", y6 = C.forwardRef(
    (e, t) => {
      const { __scopeDialog: n, ...r } = e, o = sa(v6, n);
      return /* @__PURE__ */ S.jsx(
        gt.button,
        {
          type: "button",
          ...r,
          ref: t,
          onClick: Te(e.onClick, () => o.onOpenChange(!1))
        }
      );
    }
  );
  y6.displayName = v6;
  function xC(e) {
    return e ? "open" : "closed";
  }
  var b6 = "DialogTitleWarning", [zze, w6] = yZ(b6, {
    contentName: iu,
    titleName: wC,
    docsSlug: "dialog"
  }), Bee = ({ titleId: e }) => {
    const t = w6(b6), n = `\`${t.contentName}\` requires a \`${t.titleName}\` for the component to be accessible for screen reader users.

If you want to hide the \`${t.titleName}\`, you can wrap it with our VisuallyHidden component.

For more information, see https://radix-ui.com/primitives/docs/components/${t.docsSlug}`;
    return C.useEffect(() => {
      e && (document.getElementById(e) || console.error(n));
    }, [n, e]), null;
  }, Vee = "DialogDescriptionWarning", Uee = ({ contentRef: e, descriptionId: t }) => {
    const n = `Warning: Missing \`Description\` or \`aria-describedby={undefined}\` for {${w6(Vee).contentName}}.`;
    return C.useEffect(() => {
      const r = e.current?.getAttribute("aria-describedby");
      t && r && (document.getElementById(t) || console.warn(n));
    }, [n, e, t]), null;
  }, Hee = i6, Wee = l6, qee = c6, Kee = d6, Gee = f6, Xee = m6, Yee = g6, x6 = y6;
  function p2(e, t) {
    (t == null || t > e.length) && (t = e.length);
    for (var n = 0, r = Array(t); n < t; n++) r[n] = e[n];
    return r;
  }
  function Jee(e) {
    if (Array.isArray(e)) return e;
  }
  function Qee(e) {
    if (Array.isArray(e)) return p2(e);
  }
  function Zee(e, t) {
    if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function");
  }
  function ete(e, t) {
    for (var n = 0; n < t.length; n++) {
      var r = t[n];
      r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, k6(r.key), r);
    }
  }
  function tte(e, t, n) {
    return t && ete(e.prototype, t), Object.defineProperty(e, "prototype", {
      writable: !1
    }), e;
  }
  function Ny(e, t) {
    var n = typeof Symbol < "u" && e[Symbol.iterator] || e["@@iterator"];
    if (!n) {
      if (Array.isArray(e) || (n = kC(e)) || t) {
        n && (e = n);
        var r = 0, o = function() {
        };
        return {
          s: o,
          n: function() {
            return r >= e.length ? {
              done: !0
            } : {
              done: !1,
              value: e[r++]
            };
          },
          e: function(u) {
            throw u;
          },
          f: o
        };
      }
      throw new TypeError(`Invalid attempt to iterate non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
    }
    var a, i = !0, s = !1;
    return {
      s: function() {
        n = n.call(e);
      },
      n: function() {
        var u = n.next();
        return i = u.done, u;
      },
      e: function(u) {
        s = !0, a = u;
      },
      f: function() {
        try {
          i || n.return == null || n.return();
        } finally {
          if (s) throw a;
        }
      }
    };
  }
  function dt(e, t, n) {
    return (t = k6(t)) in e ? Object.defineProperty(e, t, {
      value: n,
      enumerable: !0,
      configurable: !0,
      writable: !0
    }) : e[t] = n, e;
  }
  function nte(e) {
    if (typeof Symbol < "u" && e[Symbol.iterator] != null || e["@@iterator"] != null) return Array.from(e);
  }
  function rte(e, t) {
    var n = e == null ? null : typeof Symbol < "u" && e[Symbol.iterator] || e["@@iterator"];
    if (n != null) {
      var r, o, a, i, s = [], u = !0, c = !1;
      try {
        if (a = (n = n.call(e)).next, t === 0) {
          if (Object(n) !== n) return;
          u = !1;
        } else for (; !(u = (r = a.call(n)).done) && (s.push(r.value), s.length !== t); u = !0) ;
      } catch (f) {
        c = !0, o = f;
      } finally {
        try {
          if (!u && n.return != null && (i = n.return(), Object(i) !== i)) return;
        } finally {
          if (c) throw o;
        }
      }
      return s;
    }
  }
  function ote() {
    throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
  }
  function ate() {
    throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
  }
  function CI(e, t) {
    var n = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
      var r = Object.getOwnPropertySymbols(e);
      t && (r = r.filter(function(o) {
        return Object.getOwnPropertyDescriptor(e, o).enumerable;
      })), n.push.apply(n, r);
    }
    return n;
  }
  function Ne(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t] != null ? arguments[t] : {};
      t % 2 ? CI(Object(n), !0).forEach(function(r) {
        dt(e, r, n[r]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : CI(Object(n)).forEach(function(r) {
        Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
      });
    }
    return e;
  }
  function Ew(e, t) {
    return Jee(e) || rte(e, t) || kC(e, t) || ote();
  }
  function na(e) {
    return Qee(e) || nte(e) || kC(e) || ate();
  }
  function ite(e, t) {
    if (typeof e != "object" || !e) return e;
    var n = e[Symbol.toPrimitive];
    if (n !== void 0) {
      var r = n.call(e, t);
      if (typeof r != "object") return r;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (t === "string" ? String : Number)(e);
  }
  function k6(e) {
    var t = ite(e, "string");
    return typeof t == "symbol" ? t : t + "";
  }
  function ab(e) {
    "@babel/helpers - typeof";
    return ab = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
      return typeof t;
    } : function(t) {
      return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
    }, ab(e);
  }
  function kC(e, t) {
    if (e) {
      if (typeof e == "string") return p2(e, t);
      var n = {}.toString.call(e).slice(8, -1);
      return n === "Object" && e.constructor && (n = e.constructor.name), n === "Map" || n === "Set" ? Array.from(e) : n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n) ? p2(e, t) : void 0;
    }
  }
  var PI = function() {
  }, SC = {}, S6 = {}, _6 = null, E6 = {
    mark: PI,
    measure: PI
  };
  try {
    typeof window < "u" && (SC = window), typeof document < "u" && (S6 = document), typeof MutationObserver < "u" && (_6 = MutationObserver), typeof performance < "u" && (E6 = performance);
  } catch {
  }
  var ste = SC.navigator || {}, OI = ste.userAgent, NI = OI === void 0 ? "" : OI, ol = SC, vn = S6, MI = _6, rv = E6;
  ol.document;
  var Zi = !!vn.documentElement && !!vn.head && typeof vn.addEventListener == "function" && typeof vn.createElement == "function", C6 = ~NI.indexOf("MSIE") || ~NI.indexOf("Trident/"), x_, lte = /fa(k|kd|s|r|l|t|d|dr|dl|dt|b|slr|slpr|wsb|tl|ns|nds|es|jr|jfr|jdr|usb|ufsb|udsb|cr|ss|sr|sl|st|sds|sdr|sdl|sdt)?[\-\ ]/, ute = /Font ?Awesome ?([567 ]*)(Solid|Regular|Light|Thin|Duotone|Brands|Free|Pro|Sharp Duotone|Sharp|Kit|Notdog Duo|Notdog|Chisel|Etch|Thumbprint|Jelly Fill|Jelly Duo|Jelly|Utility|Utility Fill|Utility Duo|Slab Press|Slab|Whiteboard)?.*/i, P6 = {
    classic: {
      fa: "solid",
      fas: "solid",
      "fa-solid": "solid",
      far: "regular",
      "fa-regular": "regular",
      fal: "light",
      "fa-light": "light",
      fat: "thin",
      "fa-thin": "thin",
      fab: "brands",
      "fa-brands": "brands"
    },
    duotone: {
      fa: "solid",
      fad: "solid",
      "fa-solid": "solid",
      "fa-duotone": "solid",
      fadr: "regular",
      "fa-regular": "regular",
      fadl: "light",
      "fa-light": "light",
      fadt: "thin",
      "fa-thin": "thin"
    },
    sharp: {
      fa: "solid",
      fass: "solid",
      "fa-solid": "solid",
      fasr: "regular",
      "fa-regular": "regular",
      fasl: "light",
      "fa-light": "light",
      fast: "thin",
      "fa-thin": "thin"
    },
    "sharp-duotone": {
      fa: "solid",
      fasds: "solid",
      "fa-solid": "solid",
      fasdr: "regular",
      "fa-regular": "regular",
      fasdl: "light",
      "fa-light": "light",
      fasdt: "thin",
      "fa-thin": "thin"
    },
    slab: {
      "fa-regular": "regular",
      faslr: "regular"
    },
    "slab-press": {
      "fa-regular": "regular",
      faslpr: "regular"
    },
    thumbprint: {
      "fa-light": "light",
      fatl: "light"
    },
    whiteboard: {
      "fa-semibold": "semibold",
      fawsb: "semibold"
    },
    notdog: {
      "fa-solid": "solid",
      fans: "solid"
    },
    "notdog-duo": {
      "fa-solid": "solid",
      fands: "solid"
    },
    etch: {
      "fa-solid": "solid",
      faes: "solid"
    },
    jelly: {
      "fa-regular": "regular",
      fajr: "regular"
    },
    "jelly-fill": {
      "fa-regular": "regular",
      fajfr: "regular"
    },
    "jelly-duo": {
      "fa-regular": "regular",
      fajdr: "regular"
    },
    chisel: {
      "fa-regular": "regular",
      facr: "regular"
    },
    utility: {
      "fa-semibold": "semibold",
      fausb: "semibold"
    },
    "utility-duo": {
      "fa-semibold": "semibold",
      faudsb: "semibold"
    },
    "utility-fill": {
      "fa-semibold": "semibold",
      faufsb: "semibold"
    }
  }, cte = {
    GROUP: "duotone-group",
    PRIMARY: "primary",
    SECONDARY: "secondary"
  }, O6 = ["fa-classic", "fa-duotone", "fa-sharp", "fa-sharp-duotone", "fa-thumbprint", "fa-whiteboard", "fa-notdog", "fa-notdog-duo", "fa-chisel", "fa-etch", "fa-jelly", "fa-jelly-fill", "fa-jelly-duo", "fa-slab", "fa-slab-press", "fa-utility", "fa-utility-duo", "fa-utility-fill"], fr = "classic", Vm = "duotone", N6 = "sharp", M6 = "sharp-duotone", R6 = "chisel", j6 = "etch", I6 = "jelly", A6 = "jelly-duo", $6 = "jelly-fill", D6 = "notdog", L6 = "notdog-duo", F6 = "slab", T6 = "slab-press", z6 = "thumbprint", B6 = "utility", V6 = "utility-duo", U6 = "utility-fill", H6 = "whiteboard", dte = "Classic", fte = "Duotone", pte = "Sharp", mte = "Sharp Duotone", hte = "Chisel", gte = "Etch", vte = "Jelly", yte = "Jelly Duo", bte = "Jelly Fill", wte = "Notdog", xte = "Notdog Duo", kte = "Slab", Ste = "Slab Press", _te = "Thumbprint", Ete = "Utility", Cte = "Utility Duo", Pte = "Utility Fill", Ote = "Whiteboard", W6 = [fr, Vm, N6, M6, R6, j6, I6, A6, $6, D6, L6, F6, T6, z6, B6, V6, U6, H6];
  x_ = {}, dt(dt(dt(dt(dt(dt(dt(dt(dt(dt(x_, fr, dte), Vm, fte), N6, pte), M6, mte), R6, hte), j6, gte), I6, vte), A6, yte), $6, bte), D6, wte), dt(dt(dt(dt(dt(dt(dt(dt(x_, L6, xte), F6, kte), T6, Ste), z6, _te), B6, Ete), V6, Cte), U6, Pte), H6, Ote);
  var Nte = {
    classic: {
      900: "fas",
      400: "far",
      normal: "far",
      300: "fal",
      100: "fat"
    },
    duotone: {
      900: "fad",
      400: "fadr",
      300: "fadl",
      100: "fadt"
    },
    sharp: {
      900: "fass",
      400: "fasr",
      300: "fasl",
      100: "fast"
    },
    "sharp-duotone": {
      900: "fasds",
      400: "fasdr",
      300: "fasdl",
      100: "fasdt"
    },
    slab: {
      400: "faslr"
    },
    "slab-press": {
      400: "faslpr"
    },
    whiteboard: {
      600: "fawsb"
    },
    thumbprint: {
      300: "fatl"
    },
    notdog: {
      900: "fans"
    },
    "notdog-duo": {
      900: "fands"
    },
    etch: {
      900: "faes"
    },
    chisel: {
      400: "facr"
    },
    jelly: {
      400: "fajr"
    },
    "jelly-fill": {
      400: "fajfr"
    },
    "jelly-duo": {
      400: "fajdr"
    },
    utility: {
      600: "fausb"
    },
    "utility-duo": {
      600: "faudsb"
    },
    "utility-fill": {
      600: "faufsb"
    }
  }, Mte = {
    "Font Awesome 7 Free": {
      900: "fas",
      400: "far"
    },
    "Font Awesome 7 Pro": {
      900: "fas",
      400: "far",
      normal: "far",
      300: "fal",
      100: "fat"
    },
    "Font Awesome 7 Brands": {
      400: "fab",
      normal: "fab"
    },
    "Font Awesome 7 Duotone": {
      900: "fad",
      400: "fadr",
      normal: "fadr",
      300: "fadl",
      100: "fadt"
    },
    "Font Awesome 7 Sharp": {
      900: "fass",
      400: "fasr",
      normal: "fasr",
      300: "fasl",
      100: "fast"
    },
    "Font Awesome 7 Sharp Duotone": {
      900: "fasds",
      400: "fasdr",
      normal: "fasdr",
      300: "fasdl",
      100: "fasdt"
    },
    "Font Awesome 7 Jelly": {
      400: "fajr",
      normal: "fajr"
    },
    "Font Awesome 7 Jelly Fill": {
      400: "fajfr",
      normal: "fajfr"
    },
    "Font Awesome 7 Jelly Duo": {
      400: "fajdr",
      normal: "fajdr"
    },
    "Font Awesome 7 Slab": {
      400: "faslr",
      normal: "faslr"
    },
    "Font Awesome 7 Slab Press": {
      400: "faslpr",
      normal: "faslpr"
    },
    "Font Awesome 7 Thumbprint": {
      300: "fatl",
      normal: "fatl"
    },
    "Font Awesome 7 Notdog": {
      900: "fans",
      normal: "fans"
    },
    "Font Awesome 7 Notdog Duo": {
      900: "fands",
      normal: "fands"
    },
    "Font Awesome 7 Etch": {
      900: "faes",
      normal: "faes"
    },
    "Font Awesome 7 Chisel": {
      400: "facr",
      normal: "facr"
    },
    "Font Awesome 7 Whiteboard": {
      600: "fawsb",
      normal: "fawsb"
    },
    "Font Awesome 7 Utility": {
      600: "fausb",
      normal: "fausb"
    },
    "Font Awesome 7 Utility Duo": {
      600: "faudsb",
      normal: "faudsb"
    },
    "Font Awesome 7 Utility Fill": {
      600: "faufsb",
      normal: "faufsb"
    }
  }, Rte = /* @__PURE__ */ new Map([["classic", {
    defaultShortPrefixId: "fas",
    defaultStyleId: "solid",
    styleIds: ["solid", "regular", "light", "thin", "brands"],
    futureStyleIds: [],
    defaultFontWeight: 900
  }], ["duotone", {
    defaultShortPrefixId: "fad",
    defaultStyleId: "solid",
    styleIds: ["solid", "regular", "light", "thin"],
    futureStyleIds: [],
    defaultFontWeight: 900
  }], ["sharp", {
    defaultShortPrefixId: "fass",
    defaultStyleId: "solid",
    styleIds: ["solid", "regular", "light", "thin"],
    futureStyleIds: [],
    defaultFontWeight: 900
  }], ["sharp-duotone", {
    defaultShortPrefixId: "fasds",
    defaultStyleId: "solid",
    styleIds: ["solid", "regular", "light", "thin"],
    futureStyleIds: [],
    defaultFontWeight: 900
  }], ["chisel", {
    defaultShortPrefixId: "facr",
    defaultStyleId: "regular",
    styleIds: ["regular"],
    futureStyleIds: [],
    defaultFontWeight: 400
  }], ["etch", {
    defaultShortPrefixId: "faes",
    defaultStyleId: "solid",
    styleIds: ["solid"],
    futureStyleIds: [],
    defaultFontWeight: 900
  }], ["jelly", {
    defaultShortPrefixId: "fajr",
    defaultStyleId: "regular",
    styleIds: ["regular"],
    futureStyleIds: [],
    defaultFontWeight: 400
  }], ["jelly-duo", {
    defaultShortPrefixId: "fajdr",
    defaultStyleId: "regular",
    styleIds: ["regular"],
    futureStyleIds: [],
    defaultFontWeight: 400
  }], ["jelly-fill", {
    defaultShortPrefixId: "fajfr",
    defaultStyleId: "regular",
    styleIds: ["regular"],
    futureStyleIds: [],
    defaultFontWeight: 400
  }], ["notdog", {
    defaultShortPrefixId: "fans",
    defaultStyleId: "solid",
    styleIds: ["solid"],
    futureStyleIds: [],
    defaultFontWeight: 900
  }], ["notdog-duo", {
    defaultShortPrefixId: "fands",
    defaultStyleId: "solid",
    styleIds: ["solid"],
    futureStyleIds: [],
    defaultFontWeight: 900
  }], ["slab", {
    defaultShortPrefixId: "faslr",
    defaultStyleId: "regular",
    styleIds: ["regular"],
    futureStyleIds: [],
    defaultFontWeight: 400
  }], ["slab-press", {
    defaultShortPrefixId: "faslpr",
    defaultStyleId: "regular",
    styleIds: ["regular"],
    futureStyleIds: [],
    defaultFontWeight: 400
  }], ["thumbprint", {
    defaultShortPrefixId: "fatl",
    defaultStyleId: "light",
    styleIds: ["light"],
    futureStyleIds: [],
    defaultFontWeight: 300
  }], ["utility", {
    defaultShortPrefixId: "fausb",
    defaultStyleId: "semibold",
    styleIds: ["semibold"],
    futureStyleIds: [],
    defaultFontWeight: 600
  }], ["utility-duo", {
    defaultShortPrefixId: "faudsb",
    defaultStyleId: "semibold",
    styleIds: ["semibold"],
    futureStyleIds: [],
    defaultFontWeight: 600
  }], ["utility-fill", {
    defaultShortPrefixId: "faufsb",
    defaultStyleId: "semibold",
    styleIds: ["semibold"],
    futureStyleIds: [],
    defaultFontWeight: 600
  }], ["whiteboard", {
    defaultShortPrefixId: "fawsb",
    defaultStyleId: "semibold",
    styleIds: ["semibold"],
    futureStyleIds: [],
    defaultFontWeight: 600
  }]]), jte = {
    chisel: {
      regular: "facr"
    },
    classic: {
      brands: "fab",
      light: "fal",
      regular: "far",
      solid: "fas",
      thin: "fat"
    },
    duotone: {
      light: "fadl",
      regular: "fadr",
      solid: "fad",
      thin: "fadt"
    },
    etch: {
      solid: "faes"
    },
    jelly: {
      regular: "fajr"
    },
    "jelly-duo": {
      regular: "fajdr"
    },
    "jelly-fill": {
      regular: "fajfr"
    },
    notdog: {
      solid: "fans"
    },
    "notdog-duo": {
      solid: "fands"
    },
    sharp: {
      light: "fasl",
      regular: "fasr",
      solid: "fass",
      thin: "fast"
    },
    "sharp-duotone": {
      light: "fasdl",
      regular: "fasdr",
      solid: "fasds",
      thin: "fasdt"
    },
    slab: {
      regular: "faslr"
    },
    "slab-press": {
      regular: "faslpr"
    },
    thumbprint: {
      light: "fatl"
    },
    utility: {
      semibold: "fausb"
    },
    "utility-duo": {
      semibold: "faudsb"
    },
    "utility-fill": {
      semibold: "faufsb"
    },
    whiteboard: {
      semibold: "fawsb"
    }
  }, q6 = ["fak", "fa-kit", "fakd", "fa-kit-duotone"], RI = {
    kit: {
      fak: "kit",
      "fa-kit": "kit"
    },
    "kit-duotone": {
      fakd: "kit-duotone",
      "fa-kit-duotone": "kit-duotone"
    }
  }, Ite = ["kit"], Ate = "kit", $te = "kit-duotone", Dte = "Kit", Lte = "Kit Duotone";
  dt(dt({}, Ate, Dte), $te, Lte);
  var Fte = {
    kit: {
      "fa-kit": "fak"
    }
  }, Tte = {
    "Font Awesome Kit": {
      400: "fak",
      normal: "fak"
    },
    "Font Awesome Kit Duotone": {
      400: "fakd",
      normal: "fakd"
    }
  }, zte = {
    kit: {
      fak: "fa-kit"
    }
  }, jI = {
    kit: {
      kit: "fak"
    },
    "kit-duotone": {
      "kit-duotone": "fakd"
    }
  }, k_, ov = {
    GROUP: "duotone-group",
    SWAP_OPACITY: "swap-opacity",
    PRIMARY: "primary",
    SECONDARY: "secondary"
  }, Bte = ["fa-classic", "fa-duotone", "fa-sharp", "fa-sharp-duotone", "fa-thumbprint", "fa-whiteboard", "fa-notdog", "fa-notdog-duo", "fa-chisel", "fa-etch", "fa-jelly", "fa-jelly-fill", "fa-jelly-duo", "fa-slab", "fa-slab-press", "fa-utility", "fa-utility-duo", "fa-utility-fill"], Vte = "classic", Ute = "duotone", Hte = "sharp", Wte = "sharp-duotone", qte = "chisel", Kte = "etch", Gte = "jelly", Xte = "jelly-duo", Yte = "jelly-fill", Jte = "notdog", Qte = "notdog-duo", Zte = "slab", ene = "slab-press", tne = "thumbprint", nne = "utility", rne = "utility-duo", one = "utility-fill", ane = "whiteboard", ine = "Classic", sne = "Duotone", lne = "Sharp", une = "Sharp Duotone", cne = "Chisel", dne = "Etch", fne = "Jelly", pne = "Jelly Duo", mne = "Jelly Fill", hne = "Notdog", gne = "Notdog Duo", vne = "Slab", yne = "Slab Press", bne = "Thumbprint", wne = "Utility", xne = "Utility Duo", kne = "Utility Fill", Sne = "Whiteboard";
  k_ = {}, dt(dt(dt(dt(dt(dt(dt(dt(dt(dt(k_, Vte, ine), Ute, sne), Hte, lne), Wte, une), qte, cne), Kte, dne), Gte, fne), Xte, pne), Yte, mne), Jte, hne), dt(dt(dt(dt(dt(dt(dt(dt(k_, Qte, gne), Zte, vne), ene, yne), tne, bne), nne, wne), rne, xne), one, kne), ane, Sne);
  var _ne = "kit", Ene = "kit-duotone", Cne = "Kit", Pne = "Kit Duotone";
  dt(dt({}, _ne, Cne), Ene, Pne);
  var One = {
    classic: {
      "fa-brands": "fab",
      "fa-duotone": "fad",
      "fa-light": "fal",
      "fa-regular": "far",
      "fa-solid": "fas",
      "fa-thin": "fat"
    },
    duotone: {
      "fa-regular": "fadr",
      "fa-light": "fadl",
      "fa-thin": "fadt"
    },
    sharp: {
      "fa-solid": "fass",
      "fa-regular": "fasr",
      "fa-light": "fasl",
      "fa-thin": "fast"
    },
    "sharp-duotone": {
      "fa-solid": "fasds",
      "fa-regular": "fasdr",
      "fa-light": "fasdl",
      "fa-thin": "fasdt"
    },
    slab: {
      "fa-regular": "faslr"
    },
    "slab-press": {
      "fa-regular": "faslpr"
    },
    whiteboard: {
      "fa-semibold": "fawsb"
    },
    thumbprint: {
      "fa-light": "fatl"
    },
    notdog: {
      "fa-solid": "fans"
    },
    "notdog-duo": {
      "fa-solid": "fands"
    },
    etch: {
      "fa-solid": "faes"
    },
    jelly: {
      "fa-regular": "fajr"
    },
    "jelly-fill": {
      "fa-regular": "fajfr"
    },
    "jelly-duo": {
      "fa-regular": "fajdr"
    },
    chisel: {
      "fa-regular": "facr"
    },
    utility: {
      "fa-semibold": "fausb"
    },
    "utility-duo": {
      "fa-semibold": "faudsb"
    },
    "utility-fill": {
      "fa-semibold": "faufsb"
    }
  }, Nne = {
    classic: ["fas", "far", "fal", "fat", "fad"],
    duotone: ["fadr", "fadl", "fadt"],
    sharp: ["fass", "fasr", "fasl", "fast"],
    "sharp-duotone": ["fasds", "fasdr", "fasdl", "fasdt"],
    slab: ["faslr"],
    "slab-press": ["faslpr"],
    whiteboard: ["fawsb"],
    thumbprint: ["fatl"],
    notdog: ["fans"],
    "notdog-duo": ["fands"],
    etch: ["faes"],
    jelly: ["fajr"],
    "jelly-fill": ["fajfr"],
    "jelly-duo": ["fajdr"],
    chisel: ["facr"],
    utility: ["fausb"],
    "utility-duo": ["faudsb"],
    "utility-fill": ["faufsb"]
  }, m2 = {
    classic: {
      fab: "fa-brands",
      fad: "fa-duotone",
      fal: "fa-light",
      far: "fa-regular",
      fas: "fa-solid",
      fat: "fa-thin"
    },
    duotone: {
      fadr: "fa-regular",
      fadl: "fa-light",
      fadt: "fa-thin"
    },
    sharp: {
      fass: "fa-solid",
      fasr: "fa-regular",
      fasl: "fa-light",
      fast: "fa-thin"
    },
    "sharp-duotone": {
      fasds: "fa-solid",
      fasdr: "fa-regular",
      fasdl: "fa-light",
      fasdt: "fa-thin"
    },
    slab: {
      faslr: "fa-regular"
    },
    "slab-press": {
      faslpr: "fa-regular"
    },
    whiteboard: {
      fawsb: "fa-semibold"
    },
    thumbprint: {
      fatl: "fa-light"
    },
    notdog: {
      fans: "fa-solid"
    },
    "notdog-duo": {
      fands: "fa-solid"
    },
    etch: {
      faes: "fa-solid"
    },
    jelly: {
      fajr: "fa-regular"
    },
    "jelly-fill": {
      fajfr: "fa-regular"
    },
    "jelly-duo": {
      fajdr: "fa-regular"
    },
    chisel: {
      facr: "fa-regular"
    },
    utility: {
      fausb: "fa-semibold"
    },
    "utility-duo": {
      faudsb: "fa-semibold"
    },
    "utility-fill": {
      faufsb: "fa-semibold"
    }
  }, Mne = ["fa-solid", "fa-regular", "fa-light", "fa-thin", "fa-duotone", "fa-brands", "fa-semibold"], K6 = ["fa", "fas", "far", "fal", "fat", "fad", "fadr", "fadl", "fadt", "fab", "fass", "fasr", "fasl", "fast", "fasds", "fasdr", "fasdl", "fasdt", "faslr", "faslpr", "fawsb", "fatl", "fans", "fands", "faes", "fajr", "fajfr", "fajdr", "facr", "fausb", "faudsb", "faufsb"].concat(Bte, Mne), Rne = ["solid", "regular", "light", "thin", "duotone", "brands", "semibold"], G6 = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10], jne = G6.concat([11, 12, 13, 14, 15, 16, 17, 18, 19, 20]), Ine = ["aw", "fw", "pull-left", "pull-right"], Ane = [].concat(na(Object.keys(Nne)), Rne, Ine, ["2xs", "xs", "sm", "lg", "xl", "2xl", "beat", "border", "fade", "beat-fade", "bounce", "flip-both", "flip-horizontal", "flip-vertical", "flip", "inverse", "layers", "layers-bottom-left", "layers-bottom-right", "layers-counter", "layers-text", "layers-top-left", "layers-top-right", "li", "pull-end", "pull-start", "pulse", "rotate-180", "rotate-270", "rotate-90", "rotate-by", "shake", "spin-pulse", "spin-reverse", "spin", "stack-1x", "stack-2x", "stack", "ul", "width-auto", "width-fixed", ov.GROUP, ov.SWAP_OPACITY, ov.PRIMARY, ov.SECONDARY]).concat(G6.map(function(e) {
    return "".concat(e, "x");
  })).concat(jne.map(function(e) {
    return "w-".concat(e);
  })), $ne = {
    "Font Awesome 5 Free": {
      900: "fas",
      400: "far"
    },
    "Font Awesome 5 Pro": {
      900: "fas",
      400: "far",
      normal: "far",
      300: "fal"
    },
    "Font Awesome 5 Brands": {
      400: "fab",
      normal: "fab"
    },
    "Font Awesome 5 Duotone": {
      900: "fad"
    }
  }, Wi = "___FONT_AWESOME___", h2 = 16, X6 = "fa", Y6 = "svg-inline--fa", su = "data-fa-i2svg", g2 = "data-fa-pseudo-element", Dne = "data-fa-pseudo-element-pending", _C = "data-prefix", EC = "data-icon", II = "fontawesome-i2svg", Lne = "async", Fne = ["HTML", "HEAD", "STYLE", "SCRIPT"], J6 = ["::before", "::after", ":before", ":after"], Q6 = (function() {
    try {
      return !0;
    } catch {
      return !1;
    }
  })();
  function Um(e) {
    return new Proxy(e, {
      get: function(t, n) {
        return n in t ? t[n] : t[fr];
      }
    });
  }
  var Z6 = Ne({}, P6);
  Z6[fr] = Ne(Ne(Ne(Ne({}, {
    "fa-duotone": "duotone"
  }), P6[fr]), RI.kit), RI["kit-duotone"]);
  var Tne = Um(Z6), v2 = Ne({}, jte);
  v2[fr] = Ne(Ne(Ne(Ne({}, {
    duotone: "fad"
  }), v2[fr]), jI.kit), jI["kit-duotone"]);
  var AI = Um(v2), y2 = Ne({}, m2);
  y2[fr] = Ne(Ne({}, y2[fr]), zte.kit);
  var CC = Um(y2), b2 = Ne({}, One);
  b2[fr] = Ne(Ne({}, b2[fr]), Fte.kit);
  Um(b2);
  var zne = lte, ez = "fa-layers-text", Bne = ute, Vne = Ne({}, Nte);
  Um(Vne);
  var Une = ["class", "data-prefix", "data-icon", "data-fa-transform", "data-fa-mask"], S_ = cte, Hne = [].concat(na(Ite), na(Ane)), Mp = ol.FontAwesomeConfig || {};
  function Wne(e) {
    var t = vn.querySelector("script[" + e + "]");
    if (t)
      return t.getAttribute(e);
  }
  function qne(e) {
    return e === "" ? !0 : e === "false" ? !1 : e === "true" ? !0 : e;
  }
  if (vn && typeof vn.querySelector == "function") {
    var Kne = [["data-family-prefix", "familyPrefix"], ["data-css-prefix", "cssPrefix"], ["data-family-default", "familyDefault"], ["data-style-default", "styleDefault"], ["data-replacement-class", "replacementClass"], ["data-auto-replace-svg", "autoReplaceSvg"], ["data-auto-add-css", "autoAddCss"], ["data-search-pseudo-elements", "searchPseudoElements"], ["data-search-pseudo-elements-warnings", "searchPseudoElementsWarnings"], ["data-search-pseudo-elements-full-scan", "searchPseudoElementsFullScan"], ["data-observe-mutations", "observeMutations"], ["data-mutate-approach", "mutateApproach"], ["data-keep-original-source", "keepOriginalSource"], ["data-measure-performance", "measurePerformance"], ["data-show-missing-icons", "showMissingIcons"]];
    Kne.forEach(function(e) {
      var t = Ew(e, 2), n = t[0], r = t[1], o = qne(Wne(n));
      o != null && (Mp[r] = o);
    });
  }
  var tz = {
    styleDefault: "solid",
    familyDefault: fr,
    cssPrefix: X6,
    replacementClass: Y6,
    autoReplaceSvg: !0,
    autoAddCss: !0,
    searchPseudoElements: !1,
    searchPseudoElementsWarnings: !0,
    searchPseudoElementsFullScan: !1,
    observeMutations: !0,
    mutateApproach: "async",
    keepOriginalSource: !0,
    measurePerformance: !1,
    showMissingIcons: !0
  };
  Mp.familyPrefix && (Mp.cssPrefix = Mp.familyPrefix);
  var pd = Ne(Ne({}, tz), Mp);
  pd.autoReplaceSvg || (pd.observeMutations = !1);
  var Ke = {};
  Object.keys(tz).forEach(function(e) {
    Object.defineProperty(Ke, e, {
      enumerable: !0,
      set: function(t) {
        pd[e] = t, Rp.forEach(function(n) {
          return n(Ke);
        });
      },
      get: function() {
        return pd[e];
      }
    });
  });
  Object.defineProperty(Ke, "familyPrefix", {
    enumerable: !0,
    set: function(e) {
      pd.cssPrefix = e, Rp.forEach(function(t) {
        return t(Ke);
      });
    },
    get: function() {
      return pd.cssPrefix;
    }
  });
  ol.FontAwesomeConfig = Ke;
  var Rp = [];
  function Gne(e) {
    return Rp.push(e), function() {
      Rp.splice(Rp.indexOf(e), 1);
    };
  }
  var Pc = h2, Ra = {
    size: 16,
    x: 0,
    y: 0,
    rotate: 0,
    flipX: !1,
    flipY: !1
  };
  function Xne(e) {
    if (!(!e || !Zi)) {
      var t = vn.createElement("style");
      t.setAttribute("type", "text/css"), t.innerHTML = e;
      for (var n = vn.head.childNodes, r = null, o = n.length - 1; o > -1; o--) {
        var a = n[o], i = (a.tagName || "").toUpperCase();
        ["STYLE", "LINK"].indexOf(i) > -1 && (r = a);
      }
      return vn.head.insertBefore(t, r), e;
    }
  }
  var Yne = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ";
  function $I() {
    for (var e = 12, t = ""; e-- > 0; )
      t += Yne[Math.random() * 62 | 0];
    return t;
  }
  function Ld(e) {
    for (var t = [], n = (e || []).length >>> 0; n--; )
      t[n] = e[n];
    return t;
  }
  function PC(e) {
    return e.classList ? Ld(e.classList) : (e.getAttribute("class") || "").split(" ").filter(function(t) {
      return t;
    });
  }
  function nz(e) {
    return "".concat(e).replace(/&/g, "&amp;").replace(/"/g, "&quot;").replace(/'/g, "&#39;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
  }
  function Jne(e) {
    return Object.keys(e || {}).reduce(function(t, n) {
      return t + "".concat(n, '="').concat(nz(e[n]), '" ');
    }, "").trim();
  }
  function Cw(e) {
    return Object.keys(e || {}).reduce(function(t, n) {
      return t + "".concat(n, ": ").concat(e[n].trim(), ";");
    }, "");
  }
  function OC(e) {
    return e.size !== Ra.size || e.x !== Ra.x || e.y !== Ra.y || e.rotate !== Ra.rotate || e.flipX || e.flipY;
  }
  function Qne(e) {
    var t = e.transform, n = e.containerWidth, r = e.iconWidth, o = {
      transform: "translate(".concat(n / 2, " 256)")
    }, a = "translate(".concat(t.x * 32, ", ").concat(t.y * 32, ") "), i = "scale(".concat(t.size / 16 * (t.flipX ? -1 : 1), ", ").concat(t.size / 16 * (t.flipY ? -1 : 1), ") "), s = "rotate(".concat(t.rotate, " 0 0)"), u = {
      transform: "".concat(a, " ").concat(i, " ").concat(s)
    }, c = {
      transform: "translate(".concat(r / 2 * -1, " -256)")
    };
    return {
      outer: o,
      inner: u,
      path: c
    };
  }
  function Zne(e) {
    var t = e.transform, n = e.width, r = n === void 0 ? h2 : n, o = e.height, a = o === void 0 ? h2 : o, i = "";
    return C6 ? i += "translate(".concat(t.x / Pc - r / 2, "em, ").concat(t.y / Pc - a / 2, "em) ") : i += "translate(calc(-50% + ".concat(t.x / Pc, "em), calc(-50% + ").concat(t.y / Pc, "em)) "), i += "scale(".concat(t.size / Pc * (t.flipX ? -1 : 1), ", ").concat(t.size / Pc * (t.flipY ? -1 : 1), ") "), i += "rotate(".concat(t.rotate, "deg) "), i;
  }
  var ere = `:root, :host {
  --fa-font-solid: normal 900 1em/1 "Font Awesome 7 Free";
  --fa-font-regular: normal 400 1em/1 "Font Awesome 7 Free";
  --fa-font-light: normal 300 1em/1 "Font Awesome 7 Pro";
  --fa-font-thin: normal 100 1em/1 "Font Awesome 7 Pro";
  --fa-font-duotone: normal 900 1em/1 "Font Awesome 7 Duotone";
  --fa-font-duotone-regular: normal 400 1em/1 "Font Awesome 7 Duotone";
  --fa-font-duotone-light: normal 300 1em/1 "Font Awesome 7 Duotone";
  --fa-font-duotone-thin: normal 100 1em/1 "Font Awesome 7 Duotone";
  --fa-font-brands: normal 400 1em/1 "Font Awesome 7 Brands";
  --fa-font-sharp-solid: normal 900 1em/1 "Font Awesome 7 Sharp";
  --fa-font-sharp-regular: normal 400 1em/1 "Font Awesome 7 Sharp";
  --fa-font-sharp-light: normal 300 1em/1 "Font Awesome 7 Sharp";
  --fa-font-sharp-thin: normal 100 1em/1 "Font Awesome 7 Sharp";
  --fa-font-sharp-duotone-solid: normal 900 1em/1 "Font Awesome 7 Sharp Duotone";
  --fa-font-sharp-duotone-regular: normal 400 1em/1 "Font Awesome 7 Sharp Duotone";
  --fa-font-sharp-duotone-light: normal 300 1em/1 "Font Awesome 7 Sharp Duotone";
  --fa-font-sharp-duotone-thin: normal 100 1em/1 "Font Awesome 7 Sharp Duotone";
  --fa-font-slab-regular: normal 400 1em/1 "Font Awesome 7 Slab";
  --fa-font-slab-press-regular: normal 400 1em/1 "Font Awesome 7 Slab Press";
  --fa-font-whiteboard-semibold: normal 600 1em/1 "Font Awesome 7 Whiteboard";
  --fa-font-thumbprint-light: normal 300 1em/1 "Font Awesome 7 Thumbprint";
  --fa-font-notdog-solid: normal 900 1em/1 "Font Awesome 7 Notdog";
  --fa-font-notdog-duo-solid: normal 900 1em/1 "Font Awesome 7 Notdog Duo";
  --fa-font-etch-solid: normal 900 1em/1 "Font Awesome 7 Etch";
  --fa-font-jelly-regular: normal 400 1em/1 "Font Awesome 7 Jelly";
  --fa-font-jelly-fill-regular: normal 400 1em/1 "Font Awesome 7 Jelly Fill";
  --fa-font-jelly-duo-regular: normal 400 1em/1 "Font Awesome 7 Jelly Duo";
  --fa-font-chisel-regular: normal 400 1em/1 "Font Awesome 7 Chisel";
  --fa-font-utility-semibold: normal 600 1em/1 "Font Awesome 7 Utility";
  --fa-font-utility-duo-semibold: normal 600 1em/1 "Font Awesome 7 Utility Duo";
  --fa-font-utility-fill-semibold: normal 600 1em/1 "Font Awesome 7 Utility Fill";
}

.svg-inline--fa {
  box-sizing: content-box;
  display: var(--fa-display, inline-block);
  height: 1em;
  overflow: visible;
  vertical-align: -0.125em;
  width: var(--fa-width, 1.25em);
}
.svg-inline--fa.fa-2xs {
  vertical-align: 0.1em;
}
.svg-inline--fa.fa-xs {
  vertical-align: 0em;
}
.svg-inline--fa.fa-sm {
  vertical-align: -0.0714285714em;
}
.svg-inline--fa.fa-lg {
  vertical-align: -0.2em;
}
.svg-inline--fa.fa-xl {
  vertical-align: -0.25em;
}
.svg-inline--fa.fa-2xl {
  vertical-align: -0.3125em;
}
.svg-inline--fa.fa-pull-left,
.svg-inline--fa .fa-pull-start {
  float: inline-start;
  margin-inline-end: var(--fa-pull-margin, 0.3em);
}
.svg-inline--fa.fa-pull-right,
.svg-inline--fa .fa-pull-end {
  float: inline-end;
  margin-inline-start: var(--fa-pull-margin, 0.3em);
}
.svg-inline--fa.fa-li {
  width: var(--fa-li-width, 2em);
  inset-inline-start: calc(-1 * var(--fa-li-width, 2em));
  inset-block-start: 0.25em; /* syncing vertical alignment with Web Font rendering */
}

.fa-layers-counter, .fa-layers-text {
  display: inline-block;
  position: absolute;
  text-align: center;
}

.fa-layers {
  display: inline-block;
  height: 1em;
  position: relative;
  text-align: center;
  vertical-align: -0.125em;
  width: var(--fa-width, 1.25em);
}
.fa-layers .svg-inline--fa {
  inset: 0;
  margin: auto;
  position: absolute;
  transform-origin: center center;
}

.fa-layers-text {
  left: 50%;
  top: 50%;
  transform: translate(-50%, -50%);
  transform-origin: center center;
}

.fa-layers-counter {
  background-color: var(--fa-counter-background-color, #ff253a);
  border-radius: var(--fa-counter-border-radius, 1em);
  box-sizing: border-box;
  color: var(--fa-inverse, #fff);
  line-height: var(--fa-counter-line-height, 1);
  max-width: var(--fa-counter-max-width, 5em);
  min-width: var(--fa-counter-min-width, 1.5em);
  overflow: hidden;
  padding: var(--fa-counter-padding, 0.25em 0.5em);
  right: var(--fa-right, 0);
  text-overflow: ellipsis;
  top: var(--fa-top, 0);
  transform: scale(var(--fa-counter-scale, 0.25));
  transform-origin: top right;
}

.fa-layers-bottom-right {
  bottom: var(--fa-bottom, 0);
  right: var(--fa-right, 0);
  top: auto;
  transform: scale(var(--fa-layers-scale, 0.25));
  transform-origin: bottom right;
}

.fa-layers-bottom-left {
  bottom: var(--fa-bottom, 0);
  left: var(--fa-left, 0);
  right: auto;
  top: auto;
  transform: scale(var(--fa-layers-scale, 0.25));
  transform-origin: bottom left;
}

.fa-layers-top-right {
  top: var(--fa-top, 0);
  right: var(--fa-right, 0);
  transform: scale(var(--fa-layers-scale, 0.25));
  transform-origin: top right;
}

.fa-layers-top-left {
  left: var(--fa-left, 0);
  right: auto;
  top: var(--fa-top, 0);
  transform: scale(var(--fa-layers-scale, 0.25));
  transform-origin: top left;
}

.fa-1x {
  font-size: 1em;
}

.fa-2x {
  font-size: 2em;
}

.fa-3x {
  font-size: 3em;
}

.fa-4x {
  font-size: 4em;
}

.fa-5x {
  font-size: 5em;
}

.fa-6x {
  font-size: 6em;
}

.fa-7x {
  font-size: 7em;
}

.fa-8x {
  font-size: 8em;
}

.fa-9x {
  font-size: 9em;
}

.fa-10x {
  font-size: 10em;
}

.fa-2xs {
  font-size: calc(10 / 16 * 1em); /* converts a 10px size into an em-based value that's relative to the scale's 16px base */
  line-height: calc(1 / 10 * 1em); /* sets the line-height of the icon back to that of it's parent */
  vertical-align: calc((6 / 10 - 0.375) * 1em); /* vertically centers the icon taking into account the surrounding text's descender */
}

.fa-xs {
  font-size: calc(12 / 16 * 1em); /* converts a 12px size into an em-based value that's relative to the scale's 16px base */
  line-height: calc(1 / 12 * 1em); /* sets the line-height of the icon back to that of it's parent */
  vertical-align: calc((6 / 12 - 0.375) * 1em); /* vertically centers the icon taking into account the surrounding text's descender */
}

.fa-sm {
  font-size: calc(14 / 16 * 1em); /* converts a 14px size into an em-based value that's relative to the scale's 16px base */
  line-height: calc(1 / 14 * 1em); /* sets the line-height of the icon back to that of it's parent */
  vertical-align: calc((6 / 14 - 0.375) * 1em); /* vertically centers the icon taking into account the surrounding text's descender */
}

.fa-lg {
  font-size: calc(20 / 16 * 1em); /* converts a 20px size into an em-based value that's relative to the scale's 16px base */
  line-height: calc(1 / 20 * 1em); /* sets the line-height of the icon back to that of it's parent */
  vertical-align: calc((6 / 20 - 0.375) * 1em); /* vertically centers the icon taking into account the surrounding text's descender */
}

.fa-xl {
  font-size: calc(24 / 16 * 1em); /* converts a 24px size into an em-based value that's relative to the scale's 16px base */
  line-height: calc(1 / 24 * 1em); /* sets the line-height of the icon back to that of it's parent */
  vertical-align: calc((6 / 24 - 0.375) * 1em); /* vertically centers the icon taking into account the surrounding text's descender */
}

.fa-2xl {
  font-size: calc(32 / 16 * 1em); /* converts a 32px size into an em-based value that's relative to the scale's 16px base */
  line-height: calc(1 / 32 * 1em); /* sets the line-height of the icon back to that of it's parent */
  vertical-align: calc((6 / 32 - 0.375) * 1em); /* vertically centers the icon taking into account the surrounding text's descender */
}

.fa-width-auto {
  --fa-width: auto;
}

.fa-fw,
.fa-width-fixed {
  --fa-width: 1.25em;
}

.fa-ul {
  list-style-type: none;
  margin-inline-start: var(--fa-li-margin, 2.5em);
  padding-inline-start: 0;
}
.fa-ul > li {
  position: relative;
}

.fa-li {
  inset-inline-start: calc(-1 * var(--fa-li-width, 2em));
  position: absolute;
  text-align: center;
  width: var(--fa-li-width, 2em);
  line-height: inherit;
}

/* Heads Up: Bordered Icons will not be supported in the future!
  - This feature will be deprecated in the next major release of Font Awesome (v8)!
  - You may continue to use it in this version *v7), but it will not be supported in Font Awesome v8.
*/
/* Notes:
* --@{v.$css-prefix}-border-width = 1/16 by default (to render as ~1px based on a 16px default font-size)
* --@{v.$css-prefix}-border-padding =
  ** 3/16 for vertical padding (to give ~2px of vertical whitespace around an icon considering it's vertical alignment)
  ** 4/16 for horizontal padding (to give ~4px of horizontal whitespace around an icon)
*/
.fa-border {
  border-color: var(--fa-border-color, #eee);
  border-radius: var(--fa-border-radius, 0.1em);
  border-style: var(--fa-border-style, solid);
  border-width: var(--fa-border-width, 0.0625em);
  box-sizing: var(--fa-border-box-sizing, content-box);
  padding: var(--fa-border-padding, 0.1875em 0.25em);
}

.fa-pull-left,
.fa-pull-start {
  float: inline-start;
  margin-inline-end: var(--fa-pull-margin, 0.3em);
}

.fa-pull-right,
.fa-pull-end {
  float: inline-end;
  margin-inline-start: var(--fa-pull-margin, 0.3em);
}

.fa-beat {
  animation-name: fa-beat;
  animation-delay: var(--fa-animation-delay, 0s);
  animation-direction: var(--fa-animation-direction, normal);
  animation-duration: var(--fa-animation-duration, 1s);
  animation-iteration-count: var(--fa-animation-iteration-count, infinite);
  animation-timing-function: var(--fa-animation-timing, ease-in-out);
}

.fa-bounce {
  animation-name: fa-bounce;
  animation-delay: var(--fa-animation-delay, 0s);
  animation-direction: var(--fa-animation-direction, normal);
  animation-duration: var(--fa-animation-duration, 1s);
  animation-iteration-count: var(--fa-animation-iteration-count, infinite);
  animation-timing-function: var(--fa-animation-timing, cubic-bezier(0.28, 0.84, 0.42, 1));
}

.fa-fade {
  animation-name: fa-fade;
  animation-delay: var(--fa-animation-delay, 0s);
  animation-direction: var(--fa-animation-direction, normal);
  animation-duration: var(--fa-animation-duration, 1s);
  animation-iteration-count: var(--fa-animation-iteration-count, infinite);
  animation-timing-function: var(--fa-animation-timing, cubic-bezier(0.4, 0, 0.6, 1));
}

.fa-beat-fade {
  animation-name: fa-beat-fade;
  animation-delay: var(--fa-animation-delay, 0s);
  animation-direction: var(--fa-animation-direction, normal);
  animation-duration: var(--fa-animation-duration, 1s);
  animation-iteration-count: var(--fa-animation-iteration-count, infinite);
  animation-timing-function: var(--fa-animation-timing, cubic-bezier(0.4, 0, 0.6, 1));
}

.fa-flip {
  animation-name: fa-flip;
  animation-delay: var(--fa-animation-delay, 0s);
  animation-direction: var(--fa-animation-direction, normal);
  animation-duration: var(--fa-animation-duration, 1s);
  animation-iteration-count: var(--fa-animation-iteration-count, infinite);
  animation-timing-function: var(--fa-animation-timing, ease-in-out);
}

.fa-shake {
  animation-name: fa-shake;
  animation-delay: var(--fa-animation-delay, 0s);
  animation-direction: var(--fa-animation-direction, normal);
  animation-duration: var(--fa-animation-duration, 1s);
  animation-iteration-count: var(--fa-animation-iteration-count, infinite);
  animation-timing-function: var(--fa-animation-timing, linear);
}

.fa-spin {
  animation-name: fa-spin;
  animation-delay: var(--fa-animation-delay, 0s);
  animation-direction: var(--fa-animation-direction, normal);
  animation-duration: var(--fa-animation-duration, 2s);
  animation-iteration-count: var(--fa-animation-iteration-count, infinite);
  animation-timing-function: var(--fa-animation-timing, linear);
}

.fa-spin-reverse {
  --fa-animation-direction: reverse;
}

.fa-pulse,
.fa-spin-pulse {
  animation-name: fa-spin;
  animation-direction: var(--fa-animation-direction, normal);
  animation-duration: var(--fa-animation-duration, 1s);
  animation-iteration-count: var(--fa-animation-iteration-count, infinite);
  animation-timing-function: var(--fa-animation-timing, steps(8));
}

@media (prefers-reduced-motion: reduce) {
  .fa-beat,
  .fa-bounce,
  .fa-fade,
  .fa-beat-fade,
  .fa-flip,
  .fa-pulse,
  .fa-shake,
  .fa-spin,
  .fa-spin-pulse {
    animation: none !important;
    transition: none !important;
  }
}
@keyframes fa-beat {
  0%, 90% {
    transform: scale(1);
  }
  45% {
    transform: scale(var(--fa-beat-scale, 1.25));
  }
}
@keyframes fa-bounce {
  0% {
    transform: scale(1, 1) translateY(0);
  }
  10% {
    transform: scale(var(--fa-bounce-start-scale-x, 1.1), var(--fa-bounce-start-scale-y, 0.9)) translateY(0);
  }
  30% {
    transform: scale(var(--fa-bounce-jump-scale-x, 0.9), var(--fa-bounce-jump-scale-y, 1.1)) translateY(var(--fa-bounce-height, -0.5em));
  }
  50% {
    transform: scale(var(--fa-bounce-land-scale-x, 1.05), var(--fa-bounce-land-scale-y, 0.95)) translateY(0);
  }
  57% {
    transform: scale(1, 1) translateY(var(--fa-bounce-rebound, -0.125em));
  }
  64% {
    transform: scale(1, 1) translateY(0);
  }
  100% {
    transform: scale(1, 1) translateY(0);
  }
}
@keyframes fa-fade {
  50% {
    opacity: var(--fa-fade-opacity, 0.4);
  }
}
@keyframes fa-beat-fade {
  0%, 100% {
    opacity: var(--fa-beat-fade-opacity, 0.4);
    transform: scale(1);
  }
  50% {
    opacity: 1;
    transform: scale(var(--fa-beat-fade-scale, 1.125));
  }
}
@keyframes fa-flip {
  50% {
    transform: rotate3d(var(--fa-flip-x, 0), var(--fa-flip-y, 1), var(--fa-flip-z, 0), var(--fa-flip-angle, -180deg));
  }
}
@keyframes fa-shake {
  0% {
    transform: rotate(-15deg);
  }
  4% {
    transform: rotate(15deg);
  }
  8%, 24% {
    transform: rotate(-18deg);
  }
  12%, 28% {
    transform: rotate(18deg);
  }
  16% {
    transform: rotate(-22deg);
  }
  20% {
    transform: rotate(22deg);
  }
  32% {
    transform: rotate(-12deg);
  }
  36% {
    transform: rotate(12deg);
  }
  40%, 100% {
    transform: rotate(0deg);
  }
}
@keyframes fa-spin {
  0% {
    transform: rotate(0deg);
  }
  100% {
    transform: rotate(360deg);
  }
}
.fa-rotate-90 {
  transform: rotate(90deg);
}

.fa-rotate-180 {
  transform: rotate(180deg);
}

.fa-rotate-270 {
  transform: rotate(270deg);
}

.fa-flip-horizontal {
  transform: scale(-1, 1);
}

.fa-flip-vertical {
  transform: scale(1, -1);
}

.fa-flip-both,
.fa-flip-horizontal.fa-flip-vertical {
  transform: scale(-1, -1);
}

.fa-rotate-by {
  transform: rotate(var(--fa-rotate-angle, 0));
}

.svg-inline--fa .fa-primary {
  fill: var(--fa-primary-color, currentColor);
  opacity: var(--fa-primary-opacity, 1);
}

.svg-inline--fa .fa-secondary {
  fill: var(--fa-secondary-color, currentColor);
  opacity: var(--fa-secondary-opacity, 0.4);
}

.svg-inline--fa.fa-swap-opacity .fa-primary {
  opacity: var(--fa-secondary-opacity, 0.4);
}

.svg-inline--fa.fa-swap-opacity .fa-secondary {
  opacity: var(--fa-primary-opacity, 1);
}

.svg-inline--fa mask .fa-primary,
.svg-inline--fa mask .fa-secondary {
  fill: black;
}

.svg-inline--fa.fa-inverse {
  fill: var(--fa-inverse, #fff);
}

.fa-stack {
  display: inline-block;
  height: 2em;
  line-height: 2em;
  position: relative;
  vertical-align: middle;
  width: 2.5em;
}

.fa-inverse {
  color: var(--fa-inverse, #fff);
}

.svg-inline--fa.fa-stack-1x {
  --fa-width: 1.25em;
  height: 1em;
  width: var(--fa-width);
}
.svg-inline--fa.fa-stack-2x {
  --fa-width: 2.5em;
  height: 2em;
  width: var(--fa-width);
}

.fa-stack-1x,
.fa-stack-2x {
  inset: 0;
  margin: auto;
  position: absolute;
  z-index: var(--fa-stack-z-index, auto);
}`;
  function rz() {
    var e = X6, t = Y6, n = Ke.cssPrefix, r = Ke.replacementClass, o = ere;
    if (n !== e || r !== t) {
      var a = new RegExp("\\.".concat(e, "\\-"), "g"), i = new RegExp("\\--".concat(e, "\\-"), "g"), s = new RegExp("\\.".concat(t), "g");
      o = o.replace(a, ".".concat(n, "-")).replace(i, "--".concat(n, "-")).replace(s, ".".concat(r));
    }
    return o;
  }
  var DI = !1;
  function __() {
    Ke.autoAddCss && !DI && (Xne(rz()), DI = !0);
  }
  var tre = {
    mixout: function() {
      return {
        dom: {
          css: rz,
          insertCss: __
        }
      };
    },
    hooks: function() {
      return {
        beforeDOMElementCreation: function() {
          __();
        },
        beforeI2svg: function() {
          __();
        }
      };
    }
  }, qi = ol || {};
  qi[Wi] || (qi[Wi] = {});
  qi[Wi].styles || (qi[Wi].styles = {});
  qi[Wi].hooks || (qi[Wi].hooks = {});
  qi[Wi].shims || (qi[Wi].shims = []);
  var Yo = qi[Wi], oz = [], az = function() {
    vn.removeEventListener("DOMContentLoaded", az), ib = 1, oz.map(function(e) {
      return e();
    });
  }, ib = !1;
  Zi && (ib = (vn.documentElement.doScroll ? /^loaded|^c/ : /^loaded|^i|^c/).test(vn.readyState), ib || vn.addEventListener("DOMContentLoaded", az));
  function nre(e) {
    Zi && (ib ? setTimeout(e, 0) : oz.push(e));
  }
  function Hm(e) {
    var t = e.tag, n = e.attributes, r = n === void 0 ? {} : n, o = e.children, a = o === void 0 ? [] : o;
    return typeof e == "string" ? nz(e) : "<".concat(t, " ").concat(Jne(r), ">").concat(a.map(Hm).join(""), "</").concat(t, ">");
  }
  function LI(e, t, n) {
    if (e && e[t] && e[t][n])
      return {
        prefix: t,
        iconName: n,
        icon: e[t][n]
      };
  }
  var E_ = function(e, t, n, r) {
    var o = Object.keys(e), a = o.length, i = t, s, u, c;
    for (n === void 0 ? (s = 1, c = e[o[0]]) : (s = 0, c = n); s < a; s++)
      u = o[s], c = i(c, e[u], u, e);
    return c;
  };
  function iz(e) {
    return na(e).length !== 1 ? null : e.codePointAt(0).toString(16);
  }
  function FI(e) {
    return Object.keys(e).reduce(function(t, n) {
      var r = e[n], o = !!r.icon;
      return o ? t[r.iconName] = r.icon : t[n] = r, t;
    }, {});
  }
  function w2(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, r = n.skipHooks, o = r === void 0 ? !1 : r, a = FI(t);
    typeof Yo.hooks.addPack == "function" && !o ? Yo.hooks.addPack(e, FI(t)) : Yo.styles[e] = Ne(Ne({}, Yo.styles[e] || {}), a), e === "fas" && w2("fa", t);
  }
  var Qp = Yo.styles, rre = Yo.shims, sz = Object.keys(CC), ore = sz.reduce(function(e, t) {
    return e[t] = Object.keys(CC[t]), e;
  }, {}), NC = null, lz = {}, uz = {}, cz = {}, dz = {}, fz = {};
  function are(e) {
    return ~Hne.indexOf(e);
  }
  function ire(e, t) {
    var n = t.split("-"), r = n[0], o = n.slice(1).join("-");
    return r === e && o !== "" && !are(o) ? o : null;
  }
  var pz = function() {
    var e = function(r) {
      return E_(Qp, function(o, a, i) {
        return o[i] = E_(a, r, {}), o;
      }, {});
    };
    lz = e(function(r, o, a) {
      if (o[3] && (r[o[3]] = a), o[2]) {
        var i = o[2].filter(function(s) {
          return typeof s == "number";
        });
        i.forEach(function(s) {
          r[s.toString(16)] = a;
        });
      }
      return r;
    }), uz = e(function(r, o, a) {
      if (r[a] = a, o[2]) {
        var i = o[2].filter(function(s) {
          return typeof s == "string";
        });
        i.forEach(function(s) {
          r[s] = a;
        });
      }
      return r;
    }), fz = e(function(r, o, a) {
      var i = o[2];
      return r[a] = a, i.forEach(function(s) {
        r[s] = a;
      }), r;
    });
    var t = "far" in Qp || Ke.autoFetchSvg, n = E_(rre, function(r, o) {
      var a = o[0], i = o[1], s = o[2];
      return i === "far" && !t && (i = "fas"), typeof a == "string" && (r.names[a] = {
        prefix: i,
        iconName: s
      }), typeof a == "number" && (r.unicodes[a.toString(16)] = {
        prefix: i,
        iconName: s
      }), r;
    }, {
      names: {},
      unicodes: {}
    });
    cz = n.names, dz = n.unicodes, NC = Pw(Ke.styleDefault, {
      family: Ke.familyDefault
    });
  };
  Gne(function(e) {
    NC = Pw(e.styleDefault, {
      family: Ke.familyDefault
    });
  });
  pz();
  function MC(e, t) {
    return (lz[e] || {})[t];
  }
  function sre(e, t) {
    return (uz[e] || {})[t];
  }
  function eu(e, t) {
    return (fz[e] || {})[t];
  }
  function mz(e) {
    return cz[e] || {
      prefix: null,
      iconName: null
    };
  }
  function lre(e) {
    var t = dz[e], n = MC("fas", e);
    return t || (n ? {
      prefix: "fas",
      iconName: n
    } : null) || {
      prefix: null,
      iconName: null
    };
  }
  function al() {
    return NC;
  }
  var hz = function() {
    return {
      prefix: null,
      iconName: null,
      rest: []
    };
  };
  function ure(e) {
    var t = fr, n = sz.reduce(function(r, o) {
      return r[o] = "".concat(Ke.cssPrefix, "-").concat(o), r;
    }, {});
    return W6.forEach(function(r) {
      (e.includes(n[r]) || e.some(function(o) {
        return ore[r].includes(o);
      })) && (t = r);
    }), t;
  }
  function Pw(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, n = t.family, r = n === void 0 ? fr : n, o = Tne[r][e];
    if (r === Vm && !e)
      return "fad";
    var a = AI[r][e] || AI[r][o], i = e in Yo.styles ? e : null, s = a || i || null;
    return s;
  }
  function cre(e) {
    var t = [], n = null;
    return e.forEach(function(r) {
      var o = ire(Ke.cssPrefix, r);
      o ? n = o : r && t.push(r);
    }), {
      iconName: n,
      rest: t
    };
  }
  function TI(e) {
    return e.sort().filter(function(t, n, r) {
      return r.indexOf(t) === n;
    });
  }
  var zI = K6.concat(q6);
  function Ow(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, n = t.skipLookups, r = n === void 0 ? !1 : n, o = null, a = TI(e.filter(function(h) {
      return zI.includes(h);
    })), i = TI(e.filter(function(h) {
      return !zI.includes(h);
    })), s = a.filter(function(h) {
      return o = h, !O6.includes(h);
    }), u = Ew(s, 1), c = u[0], f = c === void 0 ? null : c, p = ure(a), g = Ne(Ne({}, cre(i)), {}, {
      prefix: Pw(f, {
        family: p
      })
    });
    return Ne(Ne(Ne({}, g), mre({
      values: e,
      family: p,
      styles: Qp,
      config: Ke,
      canonical: g,
      givenPrefix: o
    })), dre(r, o, g));
  }
  function dre(e, t, n) {
    var r = n.prefix, o = n.iconName;
    if (e || !r || !o)
      return {
        prefix: r,
        iconName: o
      };
    var a = t === "fa" ? mz(o) : {}, i = eu(r, o);
    return o = a.iconName || i || o, r = a.prefix || r, r === "far" && !Qp.far && Qp.fas && !Ke.autoFetchSvg && (r = "fas"), {
      prefix: r,
      iconName: o
    };
  }
  var fre = W6.filter(function(e) {
    return e !== fr || e !== Vm;
  }), pre = Object.keys(m2).filter(function(e) {
    return e !== fr;
  }).map(function(e) {
    return Object.keys(m2[e]);
  }).flat();
  function mre(e) {
    var t = e.values, n = e.family, r = e.canonical, o = e.givenPrefix, a = o === void 0 ? "" : o, i = e.styles, s = i === void 0 ? {} : i, u = e.config, c = u === void 0 ? {} : u, f = n === Vm, p = t.includes("fa-duotone") || t.includes("fad"), g = c.familyDefault === "duotone", h = r.prefix === "fad" || r.prefix === "fa-duotone";
    if (!f && (p || g || h) && (r.prefix = "fad"), (t.includes("fa-brands") || t.includes("fab")) && (r.prefix = "fab"), !r.prefix && fre.includes(n)) {
      var y = Object.keys(s).find(function(v) {
        return pre.includes(v);
      });
      if (y || c.autoFetchSvg) {
        var b = Rte.get(n).defaultShortPrefixId;
        r.prefix = b, r.iconName = eu(r.prefix, r.iconName) || r.iconName;
      }
    }
    return (r.prefix === "fa" || a === "fa") && (r.prefix = al() || "fas"), r;
  }
  var hre = /* @__PURE__ */ (function() {
    function e() {
      Zee(this, e), this.definitions = {};
    }
    return tte(e, [{
      key: "add",
      value: function() {
        for (var t = this, n = arguments.length, r = new Array(n), o = 0; o < n; o++)
          r[o] = arguments[o];
        var a = r.reduce(this._pullDefinitions, {});
        Object.keys(a).forEach(function(i) {
          t.definitions[i] = Ne(Ne({}, t.definitions[i] || {}), a[i]), w2(i, a[i]);
          var s = CC[fr][i];
          s && w2(s, a[i]), pz();
        });
      }
    }, {
      key: "reset",
      value: function() {
        this.definitions = {};
      }
    }, {
      key: "_pullDefinitions",
      value: function(t, n) {
        var r = n.prefix && n.iconName && n.icon ? {
          0: n
        } : n;
        return Object.keys(r).map(function(o) {
          var a = r[o], i = a.prefix, s = a.iconName, u = a.icon, c = u[2];
          t[i] || (t[i] = {}), c.length > 0 && c.forEach(function(f) {
            typeof f == "string" && (t[i][f] = u);
          }), t[i][s] = u;
        }), t;
      }
    }]);
  })(), BI = [], qc = {}, nd = {}, gre = Object.keys(nd);
  function vre(e, t) {
    var n = t.mixoutsTo;
    return BI = e, qc = {}, Object.keys(nd).forEach(function(r) {
      gre.indexOf(r) === -1 && delete nd[r];
    }), BI.forEach(function(r) {
      var o = r.mixout ? r.mixout() : {};
      if (Object.keys(o).forEach(function(i) {
        typeof o[i] == "function" && (n[i] = o[i]), ab(o[i]) === "object" && Object.keys(o[i]).forEach(function(s) {
          n[i] || (n[i] = {}), n[i][s] = o[i][s];
        });
      }), r.hooks) {
        var a = r.hooks();
        Object.keys(a).forEach(function(i) {
          qc[i] || (qc[i] = []), qc[i].push(a[i]);
        });
      }
      r.provides && r.provides(nd);
    }), n;
  }
  function x2(e, t) {
    for (var n = arguments.length, r = new Array(n > 2 ? n - 2 : 0), o = 2; o < n; o++)
      r[o - 2] = arguments[o];
    var a = qc[e] || [];
    return a.forEach(function(i) {
      t = i.apply(null, [t].concat(r));
    }), t;
  }
  function lu(e) {
    for (var t = arguments.length, n = new Array(t > 1 ? t - 1 : 0), r = 1; r < t; r++)
      n[r - 1] = arguments[r];
    var o = qc[e] || [];
    o.forEach(function(a) {
      a.apply(null, n);
    });
  }
  function il() {
    var e = arguments[0], t = Array.prototype.slice.call(arguments, 1);
    return nd[e] ? nd[e].apply(null, t) : void 0;
  }
  function k2(e) {
    e.prefix === "fa" && (e.prefix = "fas");
    var t = e.iconName, n = e.prefix || al();
    if (t)
      return t = eu(n, t) || t, LI(gz.definitions, n, t) || LI(Yo.styles, n, t);
  }
  var gz = new hre(), yre = function() {
    Ke.autoReplaceSvg = !1, Ke.observeMutations = !1, lu("noAuto");
  }, bre = {
    i2svg: function() {
      var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      return Zi ? (lu("beforeI2svg", e), il("pseudoElements2svg", e), il("i2svg", e)) : Promise.reject(new Error("Operation requires a DOM of some kind."));
    },
    watch: function() {
      var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, t = e.autoReplaceSvgRoot;
      Ke.autoReplaceSvg === !1 && (Ke.autoReplaceSvg = !0), Ke.observeMutations = !0, nre(function() {
        xre({
          autoReplaceSvgRoot: t
        }), lu("watch", e);
      });
    }
  }, wre = {
    icon: function(e) {
      if (e === null)
        return null;
      if (ab(e) === "object" && e.prefix && e.iconName)
        return {
          prefix: e.prefix,
          iconName: eu(e.prefix, e.iconName) || e.iconName
        };
      if (Array.isArray(e) && e.length === 2) {
        var t = e[1].indexOf("fa-") === 0 ? e[1].slice(3) : e[1], n = Pw(e[0]);
        return {
          prefix: n,
          iconName: eu(n, t) || t
        };
      }
      if (typeof e == "string" && (e.indexOf("".concat(Ke.cssPrefix, "-")) > -1 || e.match(zne))) {
        var r = Ow(e.split(" "), {
          skipLookups: !0
        });
        return {
          prefix: r.prefix || al(),
          iconName: eu(r.prefix, r.iconName) || r.iconName
        };
      }
      if (typeof e == "string") {
        var o = al();
        return {
          prefix: o,
          iconName: eu(o, e) || e
        };
      }
    }
  }, ho = {
    noAuto: yre,
    config: Ke,
    dom: bre,
    parse: wre,
    library: gz,
    findIconDefinition: k2,
    toHtml: Hm
  }, xre = function() {
    var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, t = e.autoReplaceSvgRoot, n = t === void 0 ? vn : t;
    (Object.keys(Yo.styles).length > 0 || Ke.autoFetchSvg) && Zi && Ke.autoReplaceSvg && ho.dom.i2svg({
      node: n
    });
  };
  function Nw(e, t) {
    return Object.defineProperty(e, "abstract", {
      get: t
    }), Object.defineProperty(e, "html", {
      get: function() {
        return e.abstract.map(function(n) {
          return Hm(n);
        });
      }
    }), Object.defineProperty(e, "node", {
      get: function() {
        if (Zi) {
          var n = vn.createElement("div");
          return n.innerHTML = e.html, n.children;
        }
      }
    }), e;
  }
  function kre(e) {
    var t = e.children, n = e.main, r = e.mask, o = e.attributes, a = e.styles, i = e.transform;
    if (OC(i) && n.found && !r.found) {
      var s = n.width, u = n.height, c = {
        x: s / u / 2,
        y: 0.5
      };
      o.style = Cw(Ne(Ne({}, a), {}, {
        "transform-origin": "".concat(c.x + i.x / 16, "em ").concat(c.y + i.y / 16, "em")
      }));
    }
    return [{
      tag: "svg",
      attributes: o,
      children: t
    }];
  }
  function Sre(e) {
    var t = e.prefix, n = e.iconName, r = e.children, o = e.attributes, a = e.symbol, i = a === !0 ? "".concat(t, "-").concat(Ke.cssPrefix, "-").concat(n) : a;
    return [{
      tag: "svg",
      attributes: {
        style: "display: none;"
      },
      children: [{
        tag: "symbol",
        attributes: Ne(Ne({}, o), {}, {
          id: i
        }),
        children: r
      }]
    }];
  }
  function _re(e) {
    var t = ["aria-label", "aria-labelledby", "title", "role"];
    return t.some(function(n) {
      return n in e;
    });
  }
  function RC(e) {
    var t = e.icons, n = t.main, r = t.mask, o = e.prefix, a = e.iconName, i = e.transform, s = e.symbol, u = e.maskId, c = e.extra, f = e.watchable, p = f === void 0 ? !1 : f, g = r.found ? r : n, h = g.width, y = g.height, b = [Ke.replacementClass, a ? "".concat(Ke.cssPrefix, "-").concat(a) : ""].filter(function(P) {
      return c.classes.indexOf(P) === -1;
    }).filter(function(P) {
      return P !== "" || !!P;
    }).concat(c.classes).join(" "), v = {
      children: [],
      attributes: Ne(Ne({}, c.attributes), {}, {
        "data-prefix": o,
        "data-icon": a,
        class: b,
        role: c.attributes.role || "img",
        viewBox: "0 0 ".concat(h, " ").concat(y)
      })
    };
    !_re(c.attributes) && !c.attributes["aria-hidden"] && (v.attributes["aria-hidden"] = "true"), p && (v.attributes[su] = "");
    var w = Ne(Ne({}, v), {}, {
      prefix: o,
      iconName: a,
      main: n,
      mask: r,
      maskId: u,
      transform: i,
      symbol: s,
      styles: Ne({}, c.styles)
    }), _ = r.found && n.found ? il("generateAbstractMask", w) || {
      children: [],
      attributes: {}
    } : il("generateAbstractIcon", w) || {
      children: [],
      attributes: {}
    }, k = _.children, E = _.attributes;
    return w.children = k, w.attributes = E, s ? Sre(w) : kre(w);
  }
  function VI(e) {
    var t = e.content, n = e.width, r = e.height, o = e.transform, a = e.extra, i = e.watchable, s = i === void 0 ? !1 : i, u = Ne(Ne({}, a.attributes), {}, {
      class: a.classes.join(" ")
    });
    s && (u[su] = "");
    var c = Ne({}, a.styles);
    OC(o) && (c.transform = Zne({
      transform: o,
      width: n,
      height: r
    }), c["-webkit-transform"] = c.transform);
    var f = Cw(c);
    f.length > 0 && (u.style = f);
    var p = [];
    return p.push({
      tag: "span",
      attributes: u,
      children: [t]
    }), p;
  }
  function Ere(e) {
    var t = e.content, n = e.extra, r = Ne(Ne({}, n.attributes), {}, {
      class: n.classes.join(" ")
    }), o = Cw(n.styles);
    o.length > 0 && (r.style = o);
    var a = [];
    return a.push({
      tag: "span",
      attributes: r,
      children: [t]
    }), a;
  }
  var C_ = Yo.styles;
  function S2(e) {
    var t = e[0], n = e[1], r = e.slice(4), o = Ew(r, 1), a = o[0], i = null;
    return Array.isArray(a) ? i = {
      tag: "g",
      attributes: {
        class: "".concat(Ke.cssPrefix, "-").concat(S_.GROUP)
      },
      children: [{
        tag: "path",
        attributes: {
          class: "".concat(Ke.cssPrefix, "-").concat(S_.SECONDARY),
          fill: "currentColor",
          d: a[0]
        }
      }, {
        tag: "path",
        attributes: {
          class: "".concat(Ke.cssPrefix, "-").concat(S_.PRIMARY),
          fill: "currentColor",
          d: a[1]
        }
      }]
    } : i = {
      tag: "path",
      attributes: {
        fill: "currentColor",
        d: a
      }
    }, {
      found: !0,
      width: t,
      height: n,
      icon: i
    };
  }
  var Cre = {
    found: !1,
    width: 512,
    height: 512
  };
  function Pre(e, t) {
    !Q6 && !Ke.showMissingIcons && e && console.error('Icon with name "'.concat(e, '" and prefix "').concat(t, '" is missing.'));
  }
  function _2(e, t) {
    var n = t;
    return t === "fa" && Ke.styleDefault !== null && (t = al()), new Promise(function(r, o) {
      if (n === "fa") {
        var a = mz(e) || {};
        e = a.iconName || e, t = a.prefix || t;
      }
      if (e && t && C_[t] && C_[t][e]) {
        var i = C_[t][e];
        return r(S2(i));
      }
      Pre(e, t), r(Ne(Ne({}, Cre), {}, {
        icon: Ke.showMissingIcons && e ? il("missingIconAbstract") || {} : {}
      }));
    });
  }
  var UI = function() {
  }, E2 = Ke.measurePerformance && rv && rv.mark && rv.measure ? rv : {
    mark: UI,
    measure: UI
  }, vp = 'FA "7.1.0"', Ore = function(e) {
    return E2.mark("".concat(vp, " ").concat(e, " begins")), function() {
      return vz(e);
    };
  }, vz = function(e) {
    E2.mark("".concat(vp, " ").concat(e, " ends")), E2.measure("".concat(vp, " ").concat(e), "".concat(vp, " ").concat(e, " begins"), "".concat(vp, " ").concat(e, " ends"));
  }, jC = {
    begin: Ore,
    end: vz
  }, My = function() {
  };
  function HI(e) {
    var t = e.getAttribute ? e.getAttribute(su) : null;
    return typeof t == "string";
  }
  function Nre(e) {
    var t = e.getAttribute ? e.getAttribute(_C) : null, n = e.getAttribute ? e.getAttribute(EC) : null;
    return t && n;
  }
  function Mre(e) {
    return e && e.classList && e.classList.contains && e.classList.contains(Ke.replacementClass);
  }
  function Rre() {
    if (Ke.autoReplaceSvg === !0)
      return Ry.replace;
    var e = Ry[Ke.autoReplaceSvg];
    return e || Ry.replace;
  }
  function jre(e) {
    return vn.createElementNS("http://www.w3.org/2000/svg", e);
  }
  function Ire(e) {
    return vn.createElement(e);
  }
  function yz(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, n = t.ceFn, r = n === void 0 ? e.tag === "svg" ? jre : Ire : n;
    if (typeof e == "string")
      return vn.createTextNode(e);
    var o = r(e.tag);
    Object.keys(e.attributes || []).forEach(function(i) {
      o.setAttribute(i, e.attributes[i]);
    });
    var a = e.children || [];
    return a.forEach(function(i) {
      o.appendChild(yz(i, {
        ceFn: r
      }));
    }), o;
  }
  function Are(e) {
    var t = " ".concat(e.outerHTML, " ");
    return t = "".concat(t, "Font Awesome fontawesome.com "), t;
  }
  var Ry = {
    replace: function(e) {
      var t = e[0];
      if (t.parentNode)
        if (e[1].forEach(function(r) {
          t.parentNode.insertBefore(yz(r), t);
        }), t.getAttribute(su) === null && Ke.keepOriginalSource) {
          var n = vn.createComment(Are(t));
          t.parentNode.replaceChild(n, t);
        } else
          t.remove();
    },
    nest: function(e) {
      var t = e[0], n = e[1];
      if (~PC(t).indexOf(Ke.replacementClass))
        return Ry.replace(e);
      var r = new RegExp("".concat(Ke.cssPrefix, "-.*"));
      if (delete n[0].attributes.id, n[0].attributes.class) {
        var o = n[0].attributes.class.split(" ").reduce(function(i, s) {
          return s === Ke.replacementClass || s.match(r) ? i.toSvg.push(s) : i.toNode.push(s), i;
        }, {
          toNode: [],
          toSvg: []
        });
        n[0].attributes.class = o.toSvg.join(" "), o.toNode.length === 0 ? t.removeAttribute("class") : t.setAttribute("class", o.toNode.join(" "));
      }
      var a = n.map(function(i) {
        return Hm(i);
      }).join(`
`);
      t.setAttribute(su, ""), t.innerHTML = a;
    }
  };
  function WI(e) {
    e();
  }
  function bz(e, t) {
    var n = typeof t == "function" ? t : My;
    if (e.length === 0)
      n();
    else {
      var r = WI;
      Ke.mutateApproach === Lne && (r = ol.requestAnimationFrame || WI), r(function() {
        var o = Rre(), a = jC.begin("mutate");
        e.map(o), a(), n();
      });
    }
  }
  var IC = !1;
  function wz() {
    IC = !0;
  }
  function C2() {
    IC = !1;
  }
  var sb = null;
  function qI(e) {
    if (MI && Ke.observeMutations) {
      var t = e.treeCallback, n = t === void 0 ? My : t, r = e.nodeCallback, o = r === void 0 ? My : r, a = e.pseudoElementsCallback, i = a === void 0 ? My : a, s = e.observeMutationsRoot, u = s === void 0 ? vn : s;
      sb = new MI(function(c) {
        if (!IC) {
          var f = al();
          Ld(c).forEach(function(p) {
            if (p.type === "childList" && p.addedNodes.length > 0 && !HI(p.addedNodes[0]) && (Ke.searchPseudoElements && i(p.target), n(p.target)), p.type === "attributes" && p.target.parentNode && Ke.searchPseudoElements && i([p.target], !0), p.type === "attributes" && HI(p.target) && ~Une.indexOf(p.attributeName))
              if (p.attributeName === "class" && Nre(p.target)) {
                var g = Ow(PC(p.target)), h = g.prefix, y = g.iconName;
                p.target.setAttribute(_C, h || f), y && p.target.setAttribute(EC, y);
              } else Mre(p.target) && o(p.target);
          });
        }
      }), Zi && sb.observe(u, {
        childList: !0,
        attributes: !0,
        characterData: !0,
        subtree: !0
      });
    }
  }
  function $re() {
    sb && sb.disconnect();
  }
  function Dre(e) {
    var t = e.getAttribute("style"), n = [];
    return t && (n = t.split(";").reduce(function(r, o) {
      var a = o.split(":"), i = a[0], s = a.slice(1);
      return i && s.length > 0 && (r[i] = s.join(":").trim()), r;
    }, {})), n;
  }
  function Lre(e) {
    var t = e.getAttribute("data-prefix"), n = e.getAttribute("data-icon"), r = e.innerText !== void 0 ? e.innerText.trim() : "", o = Ow(PC(e));
    return o.prefix || (o.prefix = al()), t && n && (o.prefix = t, o.iconName = n), o.iconName && o.prefix || (o.prefix && r.length > 0 && (o.iconName = sre(o.prefix, e.innerText) || MC(o.prefix, iz(e.innerText))), !o.iconName && Ke.autoFetchSvg && e.firstChild && e.firstChild.nodeType === Node.TEXT_NODE && (o.iconName = e.firstChild.data)), o;
  }
  function Fre(e) {
    var t = Ld(e.attributes).reduce(function(n, r) {
      return n.name !== "class" && n.name !== "style" && (n[r.name] = r.value), n;
    }, {});
    return t;
  }
  function Tre() {
    return {
      iconName: null,
      prefix: null,
      transform: Ra,
      symbol: !1,
      mask: {
        iconName: null,
        prefix: null,
        rest: []
      },
      maskId: null,
      extra: {
        classes: [],
        styles: {},
        attributes: {}
      }
    };
  }
  function KI(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
      styleParser: !0
    }, n = Lre(e), r = n.iconName, o = n.prefix, a = n.rest, i = Fre(e), s = x2("parseNodeAttributes", {}, e), u = t.styleParser ? Dre(e) : [];
    return Ne({
      iconName: r,
      prefix: o,
      transform: Ra,
      mask: {
        iconName: null,
        prefix: null,
        rest: []
      },
      maskId: null,
      symbol: !1,
      extra: {
        classes: a,
        styles: u,
        attributes: i
      }
    }, s);
  }
  var zre = Yo.styles;
  function xz(e) {
    var t = Ke.autoReplaceSvg === "nest" ? KI(e, {
      styleParser: !1
    }) : KI(e);
    return ~t.extra.classes.indexOf(ez) ? il("generateLayersText", e, t) : il("generateSvgReplacementMutation", e, t);
  }
  function Bre() {
    return [].concat(na(q6), na(K6));
  }
  function GI(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
    if (!Zi) return Promise.resolve();
    var n = vn.documentElement.classList, r = function(f) {
      return n.add("".concat(II, "-").concat(f));
    }, o = function(f) {
      return n.remove("".concat(II, "-").concat(f));
    }, a = Ke.autoFetchSvg ? Bre() : O6.concat(Object.keys(zre));
    a.includes("fa") || a.push("fa");
    var i = [".".concat(ez, ":not([").concat(su, "])")].concat(a.map(function(f) {
      return ".".concat(f, ":not([").concat(su, "])");
    })).join(", ");
    if (i.length === 0)
      return Promise.resolve();
    var s = [];
    try {
      s = Ld(e.querySelectorAll(i));
    } catch {
    }
    if (s.length > 0)
      r("pending"), o("complete");
    else
      return Promise.resolve();
    var u = jC.begin("onTree"), c = s.reduce(function(f, p) {
      try {
        var g = xz(p);
        g && f.push(g);
      } catch (h) {
        Q6 || h.name === "MissingIcon" && console.error(h);
      }
      return f;
    }, []);
    return new Promise(function(f, p) {
      Promise.all(c).then(function(g) {
        bz(g, function() {
          r("active"), r("complete"), o("pending"), typeof t == "function" && t(), u(), f();
        });
      }).catch(function(g) {
        u(), p(g);
      });
    });
  }
  function Vre(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
    xz(e).then(function(n) {
      n && bz([n], t);
    });
  }
  function Ure(e) {
    return function(t) {
      var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, r = (t || {}).icon ? t : k2(t || {}), o = n.mask;
      return o && (o = (o || {}).icon ? o : k2(o || {})), e(r, Ne(Ne({}, n), {}, {
        mask: o
      }));
    };
  }
  var Hre = function(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, n = t.transform, r = n === void 0 ? Ra : n, o = t.symbol, a = o === void 0 ? !1 : o, i = t.mask, s = i === void 0 ? null : i, u = t.maskId, c = u === void 0 ? null : u, f = t.classes, p = f === void 0 ? [] : f, g = t.attributes, h = g === void 0 ? {} : g, y = t.styles, b = y === void 0 ? {} : y;
    if (e) {
      var v = e.prefix, w = e.iconName, _ = e.icon;
      return Nw(Ne({
        type: "icon"
      }, e), function() {
        return lu("beforeDOMElementCreation", {
          iconDefinition: e,
          params: t
        }), RC({
          icons: {
            main: S2(_),
            mask: s ? S2(s.icon) : {
              found: !1,
              width: null,
              height: null,
              icon: {}
            }
          },
          prefix: v,
          iconName: w,
          transform: Ne(Ne({}, Ra), r),
          symbol: a,
          maskId: c,
          extra: {
            attributes: h,
            styles: b,
            classes: p
          }
        });
      });
    }
  }, Wre = {
    mixout: function() {
      return {
        icon: Ure(Hre)
      };
    },
    hooks: function() {
      return {
        mutationObserverCallbacks: function(e) {
          return e.treeCallback = GI, e.nodeCallback = Vre, e;
        }
      };
    },
    provides: function(e) {
      e.i2svg = function(t) {
        var n = t.node, r = n === void 0 ? vn : n, o = t.callback, a = o === void 0 ? function() {
        } : o;
        return GI(r, a);
      }, e.generateSvgReplacementMutation = function(t, n) {
        var r = n.iconName, o = n.prefix, a = n.transform, i = n.symbol, s = n.mask, u = n.maskId, c = n.extra;
        return new Promise(function(f, p) {
          Promise.all([_2(r, o), s.iconName ? _2(s.iconName, s.prefix) : Promise.resolve({
            found: !1,
            width: 512,
            height: 512,
            icon: {}
          })]).then(function(g) {
            var h = Ew(g, 2), y = h[0], b = h[1];
            f([t, RC({
              icons: {
                main: y,
                mask: b
              },
              prefix: o,
              iconName: r,
              transform: a,
              symbol: i,
              maskId: u,
              extra: c,
              watchable: !0
            })]);
          }).catch(p);
        });
      }, e.generateAbstractIcon = function(t) {
        var n = t.children, r = t.attributes, o = t.main, a = t.transform, i = t.styles, s = Cw(i);
        s.length > 0 && (r.style = s);
        var u;
        return OC(a) && (u = il("generateAbstractTransformGrouping", {
          main: o,
          transform: a,
          containerWidth: o.width,
          iconWidth: o.width
        })), n.push(u || o.icon), {
          children: n,
          attributes: r
        };
      };
    }
  }, qre = {
    mixout: function() {
      return {
        layer: function(e) {
          var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, n = t.classes, r = n === void 0 ? [] : n;
          return Nw({
            type: "layer"
          }, function() {
            lu("beforeDOMElementCreation", {
              assembler: e,
              params: t
            });
            var o = [];
            return e(function(a) {
              Array.isArray(a) ? a.map(function(i) {
                o = o.concat(i.abstract);
              }) : o = o.concat(a.abstract);
            }), [{
              tag: "span",
              attributes: {
                class: ["".concat(Ke.cssPrefix, "-layers")].concat(na(r)).join(" ")
              },
              children: o
            }];
          });
        }
      };
    }
  }, Kre = {
    mixout: function() {
      return {
        counter: function(e) {
          var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
          t.title;
          var n = t.classes, r = n === void 0 ? [] : n, o = t.attributes, a = o === void 0 ? {} : o, i = t.styles, s = i === void 0 ? {} : i;
          return Nw({
            type: "counter",
            content: e
          }, function() {
            return lu("beforeDOMElementCreation", {
              content: e,
              params: t
            }), Ere({
              content: e.toString(),
              extra: {
                attributes: a,
                styles: s,
                classes: ["".concat(Ke.cssPrefix, "-layers-counter")].concat(na(r))
              }
            });
          });
        }
      };
    }
  }, Gre = {
    mixout: function() {
      return {
        text: function(e) {
          var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, n = t.transform, r = n === void 0 ? Ra : n, o = t.classes, a = o === void 0 ? [] : o, i = t.attributes, s = i === void 0 ? {} : i, u = t.styles, c = u === void 0 ? {} : u;
          return Nw({
            type: "text",
            content: e
          }, function() {
            return lu("beforeDOMElementCreation", {
              content: e,
              params: t
            }), VI({
              content: e,
              transform: Ne(Ne({}, Ra), r),
              extra: {
                attributes: s,
                styles: c,
                classes: ["".concat(Ke.cssPrefix, "-layers-text")].concat(na(a))
              }
            });
          });
        }
      };
    },
    provides: function(e) {
      e.generateLayersText = function(t, n) {
        var r = n.transform, o = n.extra, a = null, i = null;
        if (C6) {
          var s = parseInt(getComputedStyle(t).fontSize, 10), u = t.getBoundingClientRect();
          a = u.width / s, i = u.height / s;
        }
        return Promise.resolve([t, VI({
          content: t.innerHTML,
          width: a,
          height: i,
          transform: r,
          extra: o,
          watchable: !0
        })]);
      };
    }
  }, kz = new RegExp('"', "ug"), XI = [1105920, 1112319], YI = Ne(Ne(Ne(Ne({}, {
    FontAwesome: {
      normal: "fas",
      400: "fas"
    }
  }), Mte), $ne), Tte), P2 = Object.keys(YI).reduce(function(e, t) {
    return e[t.toLowerCase()] = YI[t], e;
  }, {}), Xre = Object.keys(P2).reduce(function(e, t) {
    var n = P2[t];
    return e[t] = n[900] || na(Object.entries(n))[0][1], e;
  }, {});
  function Yre(e) {
    var t = e.replace(kz, "");
    return iz(na(t)[0] || "");
  }
  function Jre(e) {
    var t = e.getPropertyValue("font-feature-settings").includes("ss01"), n = e.getPropertyValue("content"), r = n.replace(kz, ""), o = r.codePointAt(0), a = o >= XI[0] && o <= XI[1], i = r.length === 2 ? r[0] === r[1] : !1;
    return a || i || t;
  }
  function Qre(e, t) {
    var n = e.replace(/^['"]|['"]$/g, "").toLowerCase(), r = parseInt(t), o = isNaN(r) ? "normal" : r;
    return (P2[n] || {})[o] || Xre[n];
  }
  function JI(e, t) {
    var n = "".concat(Dne).concat(t.replace(":", "-"));
    return new Promise(function(r, o) {
      if (e.getAttribute(n) !== null)
        return r();
      var a = Ld(e.children), i = a.filter(function(O) {
        return O.getAttribute(g2) === t;
      })[0], s = ol.getComputedStyle(e, t), u = s.getPropertyValue("font-family"), c = u.match(Bne), f = s.getPropertyValue("font-weight"), p = s.getPropertyValue("content");
      if (i && !c)
        return e.removeChild(i), r();
      if (c && p !== "none" && p !== "") {
        var g = s.getPropertyValue("content"), h = Qre(u, f), y = Yre(g), b = c[0].startsWith("FontAwesome"), v = Jre(s), w = MC(h, y), _ = w;
        if (b) {
          var k = lre(y);
          k.iconName && k.prefix && (w = k.iconName, h = k.prefix);
        }
        if (w && !v && (!i || i.getAttribute(_C) !== h || i.getAttribute(EC) !== _)) {
          e.setAttribute(n, _), i && e.removeChild(i);
          var E = Tre(), P = E.extra;
          P.attributes[g2] = t, _2(w, h).then(function(O) {
            var M = RC(Ne(Ne({}, E), {}, {
              icons: {
                main: O,
                mask: hz()
              },
              prefix: h,
              iconName: _,
              extra: P,
              watchable: !0
            })), I = vn.createElementNS("http://www.w3.org/2000/svg", "svg");
            t === "::before" ? e.insertBefore(I, e.firstChild) : e.appendChild(I), I.outerHTML = M.map(function(A) {
              return Hm(A);
            }).join(`
`), e.removeAttribute(n), r();
          }).catch(o);
        } else
          r();
      } else
        r();
    });
  }
  function Zre(e) {
    return Promise.all([JI(e, "::before"), JI(e, "::after")]);
  }
  function eoe(e) {
    return e.parentNode !== document.head && !~Fne.indexOf(e.tagName.toUpperCase()) && !e.getAttribute(g2) && (!e.parentNode || e.parentNode.tagName !== "svg");
  }
  var toe = function(e) {
    return !!e && J6.some(function(t) {
      return e.includes(t);
    });
  }, noe = function(e) {
    if (!e) return [];
    var t = /* @__PURE__ */ new Set(), n = e.split(/,(?![^()]*\))/).map(function(s) {
      return s.trim();
    });
    n = n.flatMap(function(s) {
      return s.includes("(") ? s : s.split(",").map(function(u) {
        return u.trim();
      });
    });
    var r = Ny(n), o;
    try {
      for (r.s(); !(o = r.n()).done; ) {
        var a = o.value;
        if (toe(a)) {
          var i = J6.reduce(function(s, u) {
            return s.replace(u, "");
          }, a);
          i !== "" && i !== "*" && t.add(i);
        }
      }
    } catch (s) {
      r.e(s);
    } finally {
      r.f();
    }
    return t;
  };
  function QI(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1;
    if (Zi) {
      var n;
      if (t)
        n = e;
      else if (Ke.searchPseudoElementsFullScan)
        n = e.querySelectorAll("*");
      else {
        var r = /* @__PURE__ */ new Set(), o = Ny(document.styleSheets), a;
        try {
          for (o.s(); !(a = o.n()).done; ) {
            var i = a.value;
            try {
              var s = Ny(i.cssRules), u;
              try {
                for (s.s(); !(u = s.n()).done; ) {
                  var c = u.value, f = noe(c.selectorText), p = Ny(f), g;
                  try {
                    for (p.s(); !(g = p.n()).done; ) {
                      var h = g.value;
                      r.add(h);
                    }
                  } catch (b) {
                    p.e(b);
                  } finally {
                    p.f();
                  }
                }
              } catch (b) {
                s.e(b);
              } finally {
                s.f();
              }
            } catch (b) {
              Ke.searchPseudoElementsWarnings && console.warn("Font Awesome: cannot parse stylesheet: ".concat(i.href, " (").concat(b.message, `)
If it declares any Font Awesome CSS pseudo-elements, they will not be rendered as SVG icons. Add crossorigin="anonymous" to the <link>, enable searchPseudoElementsFullScan for slower but more thorough DOM parsing, or suppress this warning by setting searchPseudoElementsWarnings to false.`));
            }
          }
        } catch (b) {
          o.e(b);
        } finally {
          o.f();
        }
        if (!r.size) return;
        var y = Array.from(r).join(", ");
        try {
          n = e.querySelectorAll(y);
        } catch {
        }
      }
      return new Promise(function(b, v) {
        var w = Ld(n).filter(eoe).map(Zre), _ = jC.begin("searchPseudoElements");
        wz(), Promise.all(w).then(function() {
          _(), C2(), b();
        }).catch(function() {
          _(), C2(), v();
        });
      });
    }
  }
  var roe = {
    hooks: function() {
      return {
        mutationObserverCallbacks: function(e) {
          return e.pseudoElementsCallback = QI, e;
        }
      };
    },
    provides: function(e) {
      e.pseudoElements2svg = function(t) {
        var n = t.node, r = n === void 0 ? vn : n;
        Ke.searchPseudoElements && QI(r);
      };
    }
  }, ZI = !1, ooe = {
    mixout: function() {
      return {
        dom: {
          unwatch: function() {
            wz(), ZI = !0;
          }
        }
      };
    },
    hooks: function() {
      return {
        bootstrap: function() {
          qI(x2("mutationObserverCallbacks", {}));
        },
        noAuto: function() {
          $re();
        },
        watch: function(e) {
          var t = e.observeMutationsRoot;
          ZI ? C2() : qI(x2("mutationObserverCallbacks", {
            observeMutationsRoot: t
          }));
        }
      };
    }
  }, eA = function(e) {
    var t = {
      size: 16,
      x: 0,
      y: 0,
      flipX: !1,
      flipY: !1,
      rotate: 0
    };
    return e.toLowerCase().split(" ").reduce(function(n, r) {
      var o = r.toLowerCase().split("-"), a = o[0], i = o.slice(1).join("-");
      if (a && i === "h")
        return n.flipX = !0, n;
      if (a && i === "v")
        return n.flipY = !0, n;
      if (i = parseFloat(i), isNaN(i))
        return n;
      switch (a) {
        case "grow":
          n.size = n.size + i;
          break;
        case "shrink":
          n.size = n.size - i;
          break;
        case "left":
          n.x = n.x - i;
          break;
        case "right":
          n.x = n.x + i;
          break;
        case "up":
          n.y = n.y - i;
          break;
        case "down":
          n.y = n.y + i;
          break;
        case "rotate":
          n.rotate = n.rotate + i;
          break;
      }
      return n;
    }, t);
  }, aoe = {
    mixout: function() {
      return {
        parse: {
          transform: function(e) {
            return eA(e);
          }
        }
      };
    },
    hooks: function() {
      return {
        parseNodeAttributes: function(e, t) {
          var n = t.getAttribute("data-fa-transform");
          return n && (e.transform = eA(n)), e;
        }
      };
    },
    provides: function(e) {
      e.generateAbstractTransformGrouping = function(t) {
        var n = t.main, r = t.transform, o = t.containerWidth, a = t.iconWidth, i = {
          transform: "translate(".concat(o / 2, " 256)")
        }, s = "translate(".concat(r.x * 32, ", ").concat(r.y * 32, ") "), u = "scale(".concat(r.size / 16 * (r.flipX ? -1 : 1), ", ").concat(r.size / 16 * (r.flipY ? -1 : 1), ") "), c = "rotate(".concat(r.rotate, " 0 0)"), f = {
          transform: "".concat(s, " ").concat(u, " ").concat(c)
        }, p = {
          transform: "translate(".concat(a / 2 * -1, " -256)")
        }, g = {
          outer: i,
          inner: f,
          path: p
        };
        return {
          tag: "g",
          attributes: Ne({}, g.outer),
          children: [{
            tag: "g",
            attributes: Ne({}, g.inner),
            children: [{
              tag: n.icon.tag,
              children: n.icon.children,
              attributes: Ne(Ne({}, n.icon.attributes), g.path)
            }]
          }]
        };
      };
    }
  }, P_ = {
    x: 0,
    y: 0,
    width: "100%",
    height: "100%"
  };
  function tA(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0;
    return e.attributes && (e.attributes.fill || t) && (e.attributes.fill = "black"), e;
  }
  function ioe(e) {
    return e.tag === "g" ? e.children : [e];
  }
  var soe = {
    hooks: function() {
      return {
        parseNodeAttributes: function(e, t) {
          var n = t.getAttribute("data-fa-mask"), r = n ? Ow(n.split(" ").map(function(o) {
            return o.trim();
          })) : hz();
          return r.prefix || (r.prefix = al()), e.mask = r, e.maskId = t.getAttribute("data-fa-mask-id"), e;
        }
      };
    },
    provides: function(e) {
      e.generateAbstractMask = function(t) {
        var n = t.children, r = t.attributes, o = t.main, a = t.mask, i = t.maskId, s = t.transform, u = o.width, c = o.icon, f = a.width, p = a.icon, g = Qne({
          transform: s,
          containerWidth: f,
          iconWidth: u
        }), h = {
          tag: "rect",
          attributes: Ne(Ne({}, P_), {}, {
            fill: "white"
          })
        }, y = c.children ? {
          children: c.children.map(tA)
        } : {}, b = {
          tag: "g",
          attributes: Ne({}, g.inner),
          children: [tA(Ne({
            tag: c.tag,
            attributes: Ne(Ne({}, c.attributes), g.path)
          }, y))]
        }, v = {
          tag: "g",
          attributes: Ne({}, g.outer),
          children: [b]
        }, w = "mask-".concat(i || $I()), _ = "clip-".concat(i || $I()), k = {
          tag: "mask",
          attributes: Ne(Ne({}, P_), {}, {
            id: w,
            maskUnits: "userSpaceOnUse",
            maskContentUnits: "userSpaceOnUse"
          }),
          children: [h, v]
        }, E = {
          tag: "defs",
          children: [{
            tag: "clipPath",
            attributes: {
              id: _
            },
            children: ioe(p)
          }, k]
        };
        return n.push(E, {
          tag: "rect",
          attributes: Ne({
            fill: "currentColor",
            "clip-path": "url(#".concat(_, ")"),
            mask: "url(#".concat(w, ")")
          }, P_)
        }), {
          children: n,
          attributes: r
        };
      };
    }
  }, loe = {
    provides: function(e) {
      var t = !1;
      ol.matchMedia && (t = ol.matchMedia("(prefers-reduced-motion: reduce)").matches), e.missingIconAbstract = function() {
        var n = [], r = {
          fill: "currentColor"
        }, o = {
          attributeType: "XML",
          repeatCount: "indefinite",
          dur: "2s"
        };
        n.push({
          tag: "path",
          attributes: Ne(Ne({}, r), {}, {
            d: "M156.5,447.7l-12.6,29.5c-18.7-9.5-35.9-21.2-51.5-34.9l22.7-22.7C127.6,430.5,141.5,440,156.5,447.7z M40.6,272H8.5 c1.4,21.2,5.4,41.7,11.7,61.1L50,321.2C45.1,305.5,41.8,289,40.6,272z M40.6,240c1.4-18.8,5.2-37,11.1-54.1l-29.5-12.6 C14.7,194.3,10,216.7,8.5,240H40.6z M64.3,156.5c7.8-14.9,17.2-28.8,28.1-41.5L69.7,92.3c-13.7,15.6-25.5,32.8-34.9,51.5 L64.3,156.5z M397,419.6c-13.9,12-29.4,22.3-46.1,30.4l11.9,29.8c20.7-9.9,39.8-22.6,56.9-37.6L397,419.6z M115,92.4 c13.9-12,29.4-22.3,46.1-30.4l-11.9-29.8c-20.7,9.9-39.8,22.6-56.8,37.6L115,92.4z M447.7,355.5c-7.8,14.9-17.2,28.8-28.1,41.5 l22.7,22.7c13.7-15.6,25.5-32.9,34.9-51.5L447.7,355.5z M471.4,272c-1.4,18.8-5.2,37-11.1,54.1l29.5,12.6 c7.5-21.1,12.2-43.5,13.6-66.8H471.4z M321.2,462c-15.7,5-32.2,8.2-49.2,9.4v32.1c21.2-1.4,41.7-5.4,61.1-11.7L321.2,462z M240,471.4c-18.8-1.4-37-5.2-54.1-11.1l-12.6,29.5c21.1,7.5,43.5,12.2,66.8,13.6V471.4z M462,190.8c5,15.7,8.2,32.2,9.4,49.2h32.1 c-1.4-21.2-5.4-41.7-11.7-61.1L462,190.8z M92.4,397c-12-13.9-22.3-29.4-30.4-46.1l-29.8,11.9c9.9,20.7,22.6,39.8,37.6,56.9 L92.4,397z M272,40.6c18.8,1.4,36.9,5.2,54.1,11.1l12.6-29.5C317.7,14.7,295.3,10,272,8.5V40.6z M190.8,50 c15.7-5,32.2-8.2,49.2-9.4V8.5c-21.2,1.4-41.7,5.4-61.1,11.7L190.8,50z M442.3,92.3L419.6,115c12,13.9,22.3,29.4,30.5,46.1 l29.8-11.9C470,128.5,457.3,109.4,442.3,92.3z M397,92.4l22.7-22.7c-15.6-13.7-32.8-25.5-51.5-34.9l-12.6,29.5 C370.4,72.1,384.4,81.5,397,92.4z"
          })
        });
        var a = Ne(Ne({}, o), {}, {
          attributeName: "opacity"
        }), i = {
          tag: "circle",
          attributes: Ne(Ne({}, r), {}, {
            cx: "256",
            cy: "364",
            r: "28"
          }),
          children: []
        };
        return t || i.children.push({
          tag: "animate",
          attributes: Ne(Ne({}, o), {}, {
            attributeName: "r",
            values: "28;14;28;28;14;28;"
          })
        }, {
          tag: "animate",
          attributes: Ne(Ne({}, a), {}, {
            values: "1;0;1;1;0;1;"
          })
        }), n.push(i), n.push({
          tag: "path",
          attributes: Ne(Ne({}, r), {}, {
            opacity: "1",
            d: "M263.7,312h-16c-6.6,0-12-5.4-12-12c0-71,77.4-63.9,77.4-107.8c0-20-17.8-40.2-57.4-40.2c-29.1,0-44.3,9.6-59.2,28.7 c-3.9,5-11.1,6-16.2,2.4l-13.1-9.2c-5.6-3.9-6.9-11.8-2.6-17.2c21.2-27.2,46.4-44.7,91.2-44.7c52.3,0,97.4,29.8,97.4,80.2 c0,67.6-77.4,63.5-77.4,107.8C275.7,306.6,270.3,312,263.7,312z"
          }),
          children: t ? [] : [{
            tag: "animate",
            attributes: Ne(Ne({}, a), {}, {
              values: "1;0;0;0;0;1;"
            })
          }]
        }), t || n.push({
          tag: "path",
          attributes: Ne(Ne({}, r), {}, {
            opacity: "0",
            d: "M232.5,134.5l7,168c0.3,6.4,5.6,11.5,12,11.5h9c6.4,0,11.7-5.1,12-11.5l7-168c0.3-6.8-5.2-12.5-12-12.5h-23 C237.7,122,232.2,127.7,232.5,134.5z"
          }),
          children: [{
            tag: "animate",
            attributes: Ne(Ne({}, a), {}, {
              values: "0;0;1;1;0;0;"
            })
          }]
        }), {
          tag: "g",
          attributes: {
            class: "missing"
          },
          children: n
        };
      };
    }
  }, uoe = {
    hooks: function() {
      return {
        parseNodeAttributes: function(e, t) {
          var n = t.getAttribute("data-fa-symbol"), r = n === null ? !1 : n === "" ? !0 : n;
          return e.symbol = r, e;
        }
      };
    }
  }, coe = [tre, Wre, qre, Kre, Gre, roe, ooe, aoe, soe, loe, uoe];
  vre(coe, {
    mixoutsTo: ho
  });
  ho.noAuto;
  var md = ho.config;
  ho.library;
  ho.dom;
  var Sz = ho.parse;
  ho.findIconDefinition;
  ho.toHtml;
  var doe = ho.icon;
  ho.layer;
  ho.text;
  ho.counter;
  function foe(e) {
    return e = e - 0, e === e;
  }
  function _z(e) {
    return foe(e) ? e : (e = e.replace(/[_-]+(.)?/g, (t, n) => n ? n.toUpperCase() : ""), e.charAt(0).toLowerCase() + e.slice(1));
  }
  function poe(e) {
    return e.charAt(0).toUpperCase() + e.slice(1);
  }
  var Oc = /* @__PURE__ */ new Map(), moe = 1e3;
  function hoe(e) {
    if (Oc.has(e))
      return Oc.get(e);
    const t = {};
    let n = 0;
    const r = e.length;
    for (; n < r; ) {
      const o = e.indexOf(";", n), a = o === -1 ? r : o, i = e.slice(n, a).trim();
      if (i) {
        const s = i.indexOf(":");
        if (s > 0) {
          const u = i.slice(0, s).trim(), c = i.slice(s + 1).trim();
          if (u && c) {
            const f = _z(u);
            t[f.startsWith("webkit") ? poe(f) : f] = c;
          }
        }
      }
      n = a + 1;
    }
    if (Oc.size === moe) {
      const o = Oc.keys().next().value;
      o && Oc.delete(o);
    }
    return Oc.set(e, t), t;
  }
  function Ez(e, t, n = {}) {
    if (typeof t == "string")
      return t;
    const r = (t.children || []).map((f) => Ez(e, f)), o = t.attributes || {}, a = {};
    for (const [f, p] of Object.entries(o))
      switch (!0) {
        case f === "class": {
          a.className = p;
          break;
        }
        case f === "style": {
          a.style = hoe(String(p));
          break;
        }
        case f.startsWith("aria-"):
        case f.startsWith("data-"): {
          a[f.toLowerCase()] = p;
          break;
        }
        default:
          a[_z(f)] = p;
      }
    const {
      style: i,
      role: s,
      "aria-label": u,
      ...c
    } = n;
    return i && (a.style = a.style ? { ...a.style, ...i } : i), s && (a.role = s), u && (a["aria-label"] = u, a["aria-hidden"] = "false"), e(t.tag, { ...c, ...a }, ...r);
  }
  var goe = Ez.bind(null, gn.createElement), nA = (e, t) => {
    const n = C.useId();
    return e || (t ? n : void 0);
  }, voe = class {
    constructor(e = "react-fontawesome") {
      this.enabled = !1;
      let t = !1;
      try {
        t = typeof process < "u" && !1;
      } catch {
      }
      this.scope = e, this.enabled = t;
    }
    /**
     * Logs messages to the console if not in production.
     * @param args - The message and/or data to log.
     */
    log(...e) {
      this.enabled && console.log(`[${this.scope}]`, ...e);
    }
    /**
     * Logs warnings to the console if not in production.
     * @param args - The warning message and/or data to log.
     */
    warn(...e) {
      this.enabled && console.warn(`[${this.scope}]`, ...e);
    }
    /**
     * Logs errors to the console if not in production.
     * @param args - The error message and/or data to log.
     */
    error(...e) {
      this.enabled && console.error(`[${this.scope}]`, ...e);
    }
  };
  typeof process < "u" && process.env.FA_VERSION;
  var yoe = (
    // @ts-expect-error TS2872 - Expression is always truthy - This is true when v7 of SVGCore is used, but not when v6 is used.
    // This is the point of this check - if the property exists on config, we have v7, otherwise we have v6.
    // TS is checking this against the dev dependencies which uses v7, so it reports a false error here.
    "searchPseudoElementsFullScan" in md ? "7.0.0" : "6.0.0"
  ), boe = Number.parseInt(yoe) >= 7, jp = "fa", Ci = {
    beat: "fa-beat",
    fade: "fa-fade",
    beatFade: "fa-beat-fade",
    bounce: "fa-bounce",
    shake: "fa-shake",
    spin: "fa-spin",
    spinPulse: "fa-spin-pulse",
    spinReverse: "fa-spin-reverse",
    pulse: "fa-pulse"
  }, woe = {
    left: "fa-pull-left",
    right: "fa-pull-right"
  }, xoe = {
    90: "fa-rotate-90",
    180: "fa-rotate-180",
    270: "fa-rotate-270"
  }, koe = {
    "2xs": "fa-2xs",
    xs: "fa-xs",
    sm: "fa-sm",
    lg: "fa-lg",
    xl: "fa-xl",
    "2xl": "fa-2xl",
    "1x": "fa-1x",
    "2x": "fa-2x",
    "3x": "fa-3x",
    "4x": "fa-4x",
    "5x": "fa-5x",
    "6x": "fa-6x",
    "7x": "fa-7x",
    "8x": "fa-8x",
    "9x": "fa-9x",
    "10x": "fa-10x"
  }, Pi = {
    border: "fa-border",
    /** @deprecated */
    fixedWidth: "fa-fw",
    flip: "fa-flip",
    flipHorizontal: "fa-flip-horizontal",
    flipVertical: "fa-flip-vertical",
    inverse: "fa-inverse",
    rotateBy: "fa-rotate-by",
    swapOpacity: "fa-swap-opacity",
    widthAuto: "fa-width-auto"
  };
  function Soe(e) {
    const t = md.cssPrefix || md.familyPrefix || jp;
    return t === jp ? e : e.replace(
      new RegExp(String.raw`(?<=^|\s)${jp}-`, "g"),
      `${t}-`
    );
  }
  function _oe(e) {
    const {
      beat: t,
      fade: n,
      beatFade: r,
      bounce: o,
      shake: a,
      spin: i,
      spinPulse: s,
      spinReverse: u,
      pulse: c,
      fixedWidth: f,
      inverse: p,
      border: g,
      flip: h,
      size: y,
      rotation: b,
      pull: v,
      swapOpacity: w,
      rotateBy: _,
      widthAuto: k,
      className: E
    } = e, P = [];
    return E && P.push(...E.split(" ")), t && P.push(Ci.beat), n && P.push(Ci.fade), r && P.push(Ci.beatFade), o && P.push(Ci.bounce), a && P.push(Ci.shake), i && P.push(Ci.spin), u && P.push(Ci.spinReverse), s && P.push(Ci.spinPulse), c && P.push(Ci.pulse), f && P.push(Pi.fixedWidth), p && P.push(Pi.inverse), g && P.push(Pi.border), h === !0 && P.push(Pi.flip), (h === "horizontal" || h === "both") && P.push(Pi.flipHorizontal), (h === "vertical" || h === "both") && P.push(Pi.flipVertical), y != null && P.push(koe[y]), b != null && b !== 0 && P.push(xoe[b]), v != null && P.push(woe[v]), w && P.push(Pi.swapOpacity), boe ? (_ && P.push(Pi.rotateBy), k && P.push(Pi.widthAuto), (md.cssPrefix || md.familyPrefix || jp) === jp ? P : (
      // TODO: see if we can achieve custom prefix support without iterating
      // eslint-disable-next-line unicorn/no-array-callback-reference
      P.map(Soe)
    )) : P;
  }
  var Eoe = (e) => typeof e == "object" && "icon" in e && !!e.icon;
  function rA(e) {
    if (e)
      return Eoe(e) ? e : Sz.icon(e);
  }
  function Coe(e) {
    return Object.keys(e);
  }
  var oA = new voe("FontAwesomeIcon"), Cz = {
    border: !1,
    className: "",
    mask: void 0,
    maskId: void 0,
    fixedWidth: !1,
    inverse: !1,
    flip: !1,
    icon: void 0,
    listItem: !1,
    pull: void 0,
    pulse: !1,
    rotation: void 0,
    rotateBy: !1,
    size: void 0,
    spin: !1,
    spinPulse: !1,
    spinReverse: !1,
    beat: !1,
    fade: !1,
    beatFade: !1,
    bounce: !1,
    shake: !1,
    symbol: !1,
    title: "",
    titleId: void 0,
    transform: void 0,
    swapOpacity: !1,
    widthAuto: !1
  }, Poe = new Set(Object.keys(Cz)), Pz = gn.forwardRef((e, t) => {
    const n = { ...Cz, ...e }, {
      icon: r,
      mask: o,
      symbol: a,
      title: i,
      titleId: s,
      maskId: u,
      transform: c
    } = n, f = nA(u, !!o), p = nA(s, !!i), g = rA(r);
    if (!g)
      return oA.error("Icon lookup is undefined", r), null;
    const h = _oe(n), y = typeof c == "string" ? Sz.transform(c) : c, b = rA(o), v = doe(g, {
      ...h.length > 0 && { classes: h },
      ...y && { transform: y },
      ...b && { mask: b },
      symbol: a,
      title: i,
      titleId: p,
      maskId: f
    });
    if (!v)
      return oA.error("Could not find icon", g), null;
    const { abstract: w } = v, _ = { ref: t };
    for (const k of Coe(n))
      Poe.has(k) || (_[k] = n[k]);
    return goe(w[0], _);
  });
  Pz.displayName = "FontAwesomeIcon";
  var Ooe = {
    prefix: "fas",
    iconName: "magnifying-glass",
    icon: [512, 512, [128269, "search"], "f002", "M416 208c0 45.9-14.9 88.3-40 122.7L502.6 457.4c12.5 12.5 12.5 32.8 0 45.3s-32.8 12.5-45.3 0L330.7 376C296.3 401.1 253.9 416 208 416 93.1 416 0 322.9 0 208S93.1 0 208 0 416 93.1 416 208zM208 352a144 144 0 1 0 0-288 144 144 0 1 0 0 288z"]
  }, Noe = {
    prefix: "fas",
    iconName: "chevron-up",
    icon: [448, 512, [], "f077", "M201.4 105.4c12.5-12.5 32.8-12.5 45.3 0l192 192c12.5 12.5 12.5 32.8 0 45.3s-32.8 12.5-45.3 0L224 173.3 54.6 342.6c-12.5 12.5-32.8 12.5-45.3 0s-12.5-32.8 0-45.3l192-192z"]
  }, Moe = {
    prefix: "fas",
    iconName: "expand",
    icon: [448, 512, [], "f065", "M32 32C14.3 32 0 46.3 0 64l0 96c0 17.7 14.3 32 32 32s32-14.3 32-32l0-64 64 0c17.7 0 32-14.3 32-32s-14.3-32-32-32L32 32zM64 352c0-17.7-14.3-32-32-32S0 334.3 0 352l0 96c0 17.7 14.3 32 32 32l96 0c17.7 0 32-14.3 32-32s-14.3-32-32-32l-64 0 0-64zM320 32c-17.7 0-32 14.3-32 32s14.3 32 32 32l64 0 0 64c0 17.7 14.3 32 32 32s32-14.3 32-32l0-96c0-17.7-14.3-32-32-32l-96 0zM448 352c0-17.7-14.3-32-32-32s-32 14.3-32 32l0 64-64 0c-17.7 0-32 14.3-32 32s14.3 32 32 32l96 0c17.7 0 32-14.3 32-32l0-96z"]
  }, Roe = {
    prefix: "fas",
    iconName: "chevron-right",
    icon: [320, 512, [9002], "f054", "M311.1 233.4c12.5 12.5 12.5 32.8 0 45.3l-192 192c-12.5 12.5-32.8 12.5-45.3 0s-12.5-32.8 0-45.3L243.2 256 73.9 86.6c-12.5-12.5-12.5-32.8 0-45.3s32.8-12.5 45.3 0l192 192z"]
  }, joe = {
    prefix: "fas",
    iconName: "circle-xmark",
    icon: [512, 512, [61532, "times-circle", "xmark-circle"], "f057", "M256 512a256 256 0 1 0 0-512 256 256 0 1 0 0 512zM167 167c9.4-9.4 24.6-9.4 33.9 0l55 55 55-55c9.4-9.4 24.6-9.4 33.9 0s9.4 24.6 0 33.9l-55 55 55 55c9.4 9.4 9.4 24.6 0 33.9s-24.6 9.4-33.9 0l-55-55-55 55c-9.4 9.4-24.6 9.4-33.9 0s-9.4-24.6 0-33.9l55-55-55-55c-9.4-9.4-9.4-24.6 0-33.9z"]
  }, Ioe = {
    prefix: "fas",
    iconName: "network-wired",
    icon: [576, 512, [], "f6ff", "M248 88l80 0 0 48-80 0 0-48zm-8-56c-26.5 0-48 21.5-48 48l0 64c0 26.5 21.5 48 48 48l16 0 0 32-224 0c-17.7 0-32 14.3-32 32s14.3 32 32 32l96 0 0 32-16 0c-26.5 0-48 21.5-48 48l0 64c0 26.5 21.5 48 48 48l96 0c26.5 0 48-21.5 48-48l0-64c0-26.5-21.5-48-48-48l-16 0 0-32 192 0 0 32-16 0c-26.5 0-48 21.5-48 48l0 64c0 26.5 21.5 48 48 48l96 0c26.5 0 48-21.5 48-48l0-64c0-26.5-21.5-48-48-48l-16 0 0-32 96 0c17.7 0 32-14.3 32-32s-14.3-32-32-32l-224 0 0-32 16 0c26.5 0 48-21.5 48-48l0-64c0-26.5-21.5-48-48-48l-96 0zM448 376l8 0 0 48-80 0 0-48 72 0zm-256 0l8 0 0 48-80 0 0-48 72 0z"]
  }, Aoe = {
    prefix: "fas",
    iconName: "gear",
    icon: [512, 512, [9881, "cog"], "f013", "M195.1 9.5C198.1-5.3 211.2-16 226.4-16l59.8 0c15.2 0 28.3 10.7 31.3 25.5L332 79.5c14.1 6 27.3 13.7 39.3 22.8l67.8-22.5c14.4-4.8 30.2 1.2 37.8 14.4l29.9 51.8c7.6 13.2 4.9 29.8-6.5 39.9L447 233.3c.9 7.4 1.3 15 1.3 22.7s-.5 15.3-1.3 22.7l53.4 47.5c11.4 10.1 14 26.8 6.5 39.9l-29.9 51.8c-7.6 13.1-23.4 19.2-37.8 14.4l-67.8-22.5c-12.1 9.1-25.3 16.7-39.3 22.8l-14.4 69.9c-3.1 14.9-16.2 25.5-31.3 25.5l-59.8 0c-15.2 0-28.3-10.7-31.3-25.5l-14.4-69.9c-14.1-6-27.2-13.7-39.3-22.8L73.5 432.3c-14.4 4.8-30.2-1.2-37.8-14.4L5.8 366.1c-7.6-13.2-4.9-29.8 6.5-39.9l53.4-47.5c-.9-7.4-1.3-15-1.3-22.7s.5-15.3 1.3-22.7L12.3 185.8c-11.4-10.1-14-26.8-6.5-39.9L35.7 94.1c7.6-13.2 23.4-19.2 37.8-14.4l67.8 22.5c12.1-9.1 25.3-16.7 39.3-22.8L195.1 9.5zM256.3 336a80 80 0 1 0 -.6-160 80 80 0 1 0 .6 160z"]
  }, $oe = {
    prefix: "fas",
    iconName: "up-right-and-down-left-from-center",
    icon: [512, 512, ["expand-alt"], "f424", "M344 0L488 0c13.3 0 24 10.7 24 24l0 144c0 9.7-5.8 18.5-14.8 22.2s-19.3 1.7-26.2-5.2l-39-39-87 87c-9.4 9.4-24.6 9.4-33.9 0l-32-32c-9.4-9.4-9.4-24.6 0-33.9l87-87-39-39c-6.9-6.9-8.9-17.2-5.2-26.2S334.3 0 344 0zM168 512L24 512c-13.3 0-24-10.7-24-24L0 344c0-9.7 5.8-18.5 14.8-22.2S34.1 320.2 41 327l39 39 87-87c9.4-9.4 24.6-9.4 33.9 0l32 32c9.4 9.4 9.4 24.6 0 33.9l-87 87 39 39c6.9 6.9 8.9 17.2 5.2 26.2S177.7 512 168 512z"]
  }, Doe = {
    prefix: "fas",
    iconName: "xmark",
    icon: [384, 512, [128473, 10005, 10006, 10060, 215, "close", "multiply", "remove", "times"], "f00d", "M55.1 73.4c-12.5-12.5-32.8-12.5-45.3 0s-12.5 32.8 0 45.3L147.2 256 9.9 393.4c-12.5 12.5-12.5 32.8 0 45.3s32.8 12.5 45.3 0L192.5 301.3 329.9 438.6c12.5 12.5 32.8 12.5 45.3 0s12.5-32.8 0-45.3L237.8 256 375.1 118.6c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0L192.5 210.7 55.1 73.4z"]
  }, Loe = {
    prefix: "fas",
    iconName: "lock-open",
    icon: [576, 512, [], "f3c1", "M384 96c0-35.3 28.7-64 64-64s64 28.7 64 64l0 32c0 17.7 14.3 32 32 32s32-14.3 32-32l0-32c0-70.7-57.3-128-128-128S320 25.3 320 96l0 64-160 0c-35.3 0-64 28.7-64 64l0 224c0 35.3 28.7 64 64 64l256 0c35.3 0 64-28.7 64-64l0-224c0-35.3-28.7-64-64-64l-32 0 0-64z"]
  }, Foe = {
    prefix: "fas",
    iconName: "circle-check",
    icon: [512, 512, [61533, "check-circle"], "f058", "M256 512a256 256 0 1 1 0-512 256 256 0 1 1 0 512zM374 145.7c-10.7-7.8-25.7-5.4-33.5 5.3L221.1 315.2 169 263.1c-9.4-9.4-24.6-9.4-33.9 0s-9.4 24.6 0 33.9l72 72c5 5 11.8 7.5 18.8 7s13.4-4.1 17.5-9.8L379.3 179.2c7.8-10.7 5.4-25.7-5.3-33.5z"]
  }, Toe = {
    prefix: "fas",
    iconName: "circle-play",
    icon: [512, 512, [61469, "play-circle"], "f144", "M0 256a256 256 0 1 1 512 0 256 256 0 1 1 -512 0zM188.3 147.1c-7.6 4.2-12.3 12.3-12.3 20.9l0 176c0 8.7 4.7 16.7 12.3 20.9s16.8 4.1 24.3-.5l144-88c7.1-4.4 11.5-12.1 11.5-20.5s-4.4-16.1-11.5-20.5l-144-88c-7.4-4.5-16.7-4.7-24.3-.5z"]
  }, zoe = {
    prefix: "fas",
    iconName: "chevron-down",
    icon: [448, 512, [], "f078", "M201.4 406.6c12.5 12.5 32.8 12.5 45.3 0l192-192c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0L224 338.7 54.6 169.4c-12.5-12.5-32.8-12.5-45.3 0s-12.5 32.8 0 45.3l192 192z"]
  }, Boe = {
    prefix: "fas",
    iconName: "chevron-left",
    icon: [320, 512, [9001], "f053", "M9.4 233.4c-12.5 12.5-12.5 32.8 0 45.3l192 192c12.5 12.5 32.8 12.5 45.3 0s12.5-32.8 0-45.3L77.3 256 246.6 86.6c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0l-192 192z"]
  }, Voe = {
    prefix: "fas",
    iconName: "lock",
    icon: [384, 512, [128274], "f023", "M128 96l0 64 128 0 0-64c0-35.3-28.7-64-64-64s-64 28.7-64 64zM64 160l0-64C64 25.3 121.3-32 192-32S320 25.3 320 96l0 64c35.3 0 64 28.7 64 64l0 224c0 35.3-28.7 64-64 64L64 512c-35.3 0-64-28.7-64-64L0 224c0-35.3 28.7-64 64-64z"]
  }, Uoe = {
    prefix: "fas",
    iconName: "down-left-and-up-right-to-center",
    icon: [512, 512, ["compress-alt"], "f422", "M439.5 7c9.4-9.4 24.6-9.4 33.9 0l32 32c9.4 9.4 9.4 24.6 0 33.9l-87 87 39 39c6.9 6.9 8.9 17.2 5.2 26.2S450.2 240 440.5 240l-144 0c-13.3 0-24-10.7-24-24l0-144c0-9.7 5.8-18.5 14.8-22.2s19.3-1.7 26.2 5.2l39 39 87-87zM72.5 272l144 0c13.3 0 24 10.7 24 24l0 144c0 9.7-5.8 18.5-14.8 22.2s-19.3 1.7-26.2-5.2l-39-39-87 87c-9.4 9.4-24.6 9.4-33.9 0l-32-32c-9.4-9.4-9.4-24.6 0-33.9l87-87-39-39c-6.9-6.9-8.9-17.2-5.2-26.2S62.8 272 72.5 272z"]
  }, Hoe = {
    prefix: "fas",
    iconName: "compress",
    icon: [448, 512, [], "f066", "M160 64c0-17.7-14.3-32-32-32S96 46.3 96 64l0 64-64 0c-17.7 0-32 14.3-32 32s14.3 32 32 32l96 0c17.7 0 32-14.3 32-32l0-96zM32 320c-17.7 0-32 14.3-32 32s14.3 32 32 32l64 0 0 64c0 17.7 14.3 32 32 32s32-14.3 32-32l0-96c0-17.7-14.3-32-32-32l-96 0zM352 64c0-17.7-14.3-32-32-32s-32 14.3-32 32l0 96c0 17.7 14.3 32 32 32l96 0c17.7 0 32-14.3 32-32s-14.3-32-32-32l-64 0 0-64zM320 320c-17.7 0-32 14.3-32 32l0 96c0 17.7 14.3 32 32 32s32-14.3 32-32l0-64 64 0c17.7 0 32-14.3 32-32s-14.3-32-32-32l-96 0z"]
  }, Woe = {
    prefix: "fas",
    iconName: "bars",
    icon: [448, 512, ["navicon"], "f0c9", "M0 96C0 78.3 14.3 64 32 64l384 0c17.7 0 32 14.3 32 32s-14.3 32-32 32L32 128C14.3 128 0 113.7 0 96zM0 256c0-17.7 14.3-32 32-32l384 0c17.7 0 32 14.3 32 32s-14.3 32-32 32L32 288c-17.7 0-32-14.3-32-32zM448 416c0 17.7-14.3 32-32 32L32 448c-17.7 0-32-14.3-32-32s14.3-32 32-32l384 0c17.7 0 32 14.3 32 32z"]
  };
  md.autoAddCss = !1;
  const er = (e) => {
    const { style: t, ...n } = e;
    return /* @__PURE__ */ S.jsx("span", { style: t, children: /* @__PURE__ */ S.jsx(Pz, { ...n }) });
  }, AC = (e) => /* @__PURE__ */ S.jsx(er, { ...e, icon: Woe }), Zp = (e) => /* @__PURE__ */ S.jsx(er, { ...e, icon: Roe }), lb = (e) => /* @__PURE__ */ S.jsx(er, { ...e, icon: Boe }), Oz = (e) => /* @__PURE__ */ S.jsx(er, { ...e, icon: Moe }), qoe = (e) => /* @__PURE__ */ S.jsx(er, { ...e, icon: Hoe }), Koe = (e) => /* @__PURE__ */ S.jsx(er, { ...e, icon: Uoe }), Goe = (e) => /* @__PURE__ */ S.jsx(er, { ...e, icon: $oe }), ub = (e) => /* @__PURE__ */ S.jsx(er, { ...e, icon: zoe }), em = (e) => /* @__PURE__ */ S.jsx(er, { ...e, icon: Noe }), Wm = em, Mw = (e) => /* @__PURE__ */ S.jsx(er, { ...e, icon: Doe }), Xoe = (e) => /* @__PURE__ */ S.jsx(er, { ...e, icon: Loe }), Yoe = (e) => /* @__PURE__ */ S.jsx(er, { ...e, icon: Voe }), Joe = (e) => /* @__PURE__ */ S.jsx(er, { ...e, icon: Ioe }), Qoe = (e) => /* @__PURE__ */ S.jsx(er, { ...e, icon: Toe }), Zoe = (e) => /* @__PURE__ */ S.jsx(er, { ...e, icon: Ooe }), eae = (e) => /* @__PURE__ */ S.jsx(er, { ...e, icon: Aoe }), tae = (e) => /* @__PURE__ */ S.jsx(er, { ...e, icon: Foe }), nae = (e) => /* @__PURE__ */ S.jsx(er, { ...e, icon: joe }), Nz = C.createContext(null), Vt = () => {
    const e = C.useContext(Nz);
    if (!e)
      throw new Error(
        "useFuncNodesContext must be used within a FuncNodesContext.Provider"
      );
    return e;
  }, Mz = C.createContext(
    void 0
  ), $C = () => {
    const e = C.useContext(Mz);
    if (!e)
      throw new Error("useKeyPress must be used within a KeyPressProvider");
    return e;
  }, rae = ({
    children: e,
    preventDefault: t = !1,
    ignoredKeys: n = [],
    debug: r = !1,
    target: o
  }) => {
    const [a, i] = C.useState(/* @__PURE__ */ new Set()), s = C.useMemo(
      () => new Set(n),
      [n]
    ), u = C.useRef(a);
    u.current = a;
    const c = C.useMemo(
      () => ({
        keys: a,
        isKeyPressed: (f) => a.has(f),
        areKeysPressed: (...f) => f.every((p) => a.has(p)),
        isAnyKeyPressed: (...f) => f.some((p) => a.has(p))
      }),
      [a]
    );
    return C.useEffect(() => {
      const f = o ?? window;
      if (!f) return;
      const p = (b) => {
        const v = b.key;
        s.has(v) || (t && b.preventDefault(), u.current.has(v) || (r && console.log(`[KeyPress] Key down: ${v}`), i((w) => {
          const _ = new Set(w);
          return _.add(v), _;
        })));
      }, g = (b) => {
        const v = b.key;
        u.current.has(v) && (r && console.log(`[KeyPress] Key up: ${v}`), i((w) => {
          const _ = new Set(w);
          return _.delete(v), _;
        }));
      }, h = () => {
        u.current.size > 0 && (r && console.log("[KeyPress] Window blur - clearing all keys"), i(/* @__PURE__ */ new Set()));
      }, y = () => {
        document.hidden && u.current.size > 0 && (r && console.log("[KeyPress] Tab hidden - clearing all keys"), i(/* @__PURE__ */ new Set()));
      };
      return f.addEventListener("keydown", p), f.addEventListener("keyup", g), f.addEventListener("blur", h), document.addEventListener("visibilitychange", y), () => {
        f.removeEventListener("keydown", p), f.removeEventListener("keyup", g), f.removeEventListener("blur", h), document.removeEventListener("visibilitychange", y);
      };
    }, [t, s, r, o]), /* @__PURE__ */ S.jsx(Mz.Provider, { value: c, children: e });
  }, Rz = C.createContext({
    colorTheme: "classic",
    setColorTheme: () => {
    },
    previewColorTheme: () => {
    }
  }), oae = ({
    available_themes: e,
    children: t,
    default_theme: n
  }) => {
    const r = C.useMemo(
      () => new Set(e),
      [e]
    ), [o, a] = C.useState(
      n ?? e[0]
    ), i = C.useCallback(
      (c) => {
        if (!r.has(c))
          throw new Error(
            `Theme "${c}" is not in available_themes: [${Array.from(
              r
            ).join(", ")}]`
          );
        a(c);
        const f = {
          colorTheme: c
        };
        try {
          localStorage.setItem("theme", JSON.stringify(f));
        } catch (p) {
          console.warn("Failed to save theme to localStorage:", p);
        }
      },
      [r]
    ), s = C.useCallback(
      (c) => {
        if (!r.has(c))
          throw new Error(
            `Theme "${c}" is not in available_themes: [${Array.from(
              r
            ).join(", ")}]`
          );
        a(c);
      },
      [r]
    );
    C.useEffect(() => {
      document.documentElement.setAttribute("fn-data-color-theme", o);
    }, [o]), C.useEffect(() => {
      try {
        const c = localStorage.getItem("theme");
        if (!c) return;
        const f = JSON.parse(c);
        f.colorTheme && r.has(f.colorTheme) && a(f.colorTheme);
      } catch (c) {
        console.warn("Failed to load theme from localStorage:", c);
      }
    }, [r]), C.useEffect(() => {
      if (n && !r.has(n)) {
        const c = Array.from(r)[0];
        c && i(c);
      }
    }, [r, n, i]), C.useEffect(() => {
      if (!r.has(o)) {
        const c = Array.from(r)[0];
        c && i(c);
      }
    }, [o, r, i]);
    const u = C.useMemo(
      () => ({
        colorTheme: o,
        setColorTheme: i,
        previewColorTheme: s
      }),
      [o, i, s]
    );
    return /* @__PURE__ */ S.jsx(Rz.Provider, { value: u, children: t });
  }, jz = () => {
    const e = C.useContext(Rz);
    if (!e)
      throw new Error("useTheme must be used within a ThemeProvider");
    return e;
  }, Iz = C.memo(({ button: e, index: t }) => {
    const n = C.useCallback(
      (o) => {
        o.preventDefault(), e.onClick(o);
      },
      [e]
    ), r = /* @__PURE__ */ S.jsx(
      "button",
      {
        className: `dialog-send-button ${e.className || ""}`,
        onClick: n,
        disabled: e.disabled,
        "aria-label": e.ariaLabel,
        type: "button",
        children: e.text
      }
    );
    return e.close !== !1 ? /* @__PURE__ */ S.jsx(x6, { asChild: !0, children: r }, t) : /* @__PURE__ */ S.jsx(C.Fragment, { children: r }, t);
  });
  Iz.displayName = "DialogButton";
  const Qa = C.memo(
    ({
      trigger: e,
      title: t,
      description: n,
      children: r,
      closebutton: o = !0,
      onOpenChange: a,
      buttons: i = [],
      open: s,
      setOpen: u,
      modal: c = !0,
      dialogClassName: f = "default-dialog-content",
      ariaLabel: p,
      ariaDescription: g
    }) => {
      const h = Vt().local_state((w) => w.funcnodescontainerRef), y = C.useMemo(
        () => `dialog-content funcnodescontainer ${f}`,
        [f]
      ), b = C.useCallback(
        (w) => {
          try {
            u?.(w), a?.(w);
          } catch (_) {
            console.error("Error in dialog open change handler:", _);
          }
        },
        [u, a]
      ), v = C.useMemo(
        () => i.map((w, _) => /* @__PURE__ */ S.jsx(
          Iz,
          {
            button: w,
            index: _
          },
          `${w.text}-${_}`
        )),
        [i]
      );
      return /* @__PURE__ */ S.jsxs(Hee, { open: s, onOpenChange: b, modal: c, children: [
        e && /* @__PURE__ */ S.jsx(Wee, { asChild: !0, children: e }),
        /* @__PURE__ */ S.jsxs(qee, { container: h, children: [
          /* @__PURE__ */ S.jsx(Kee, { className: "dialog-overlay funcnodescontainer" }),
          /* @__PURE__ */ S.jsx(Gee, { asChild: !0, ...n ? {} : { "aria-describedby": void 0 }, children: /* @__PURE__ */ S.jsxs(
            "div",
            {
              className: y,
              role: "dialog",
              "aria-label": p || t,
              "aria-description": g || (typeof n == "string" ? n : void 0),
              children: [
                /* @__PURE__ */ S.jsx(
                  Xee,
                  {
                    className: `dialog-title${t ? "" : " dialog-title--visually-hidden"}`,
                    children: t || p || "Dialog"
                  }
                ),
                n && /* @__PURE__ */ S.jsx(
                  Yee,
                  {
                    className: "dialog-description",
                    children: n
                  }
                ),
                /* @__PURE__ */ S.jsx("div", { className: "dialog-children", role: "main", children: r }),
                i.length > 0 && /* @__PURE__ */ S.jsx(
                  "div",
                  {
                    className: "dialog-buttons",
                    role: "group",
                    "aria-label": "Dialog actions",
                    children: v
                  }
                ),
                o && /* @__PURE__ */ S.jsx(x6, { asChild: !0, children: /* @__PURE__ */ S.jsx(
                  "button",
                  {
                    className: "dialog-close-button",
                    "aria-label": "Close dialog",
                    type: "button",
                    children: /* @__PURE__ */ S.jsx(Mw, {})
                  }
                ) })
              ]
            }
          ) })
        ] })
      ] });
    }
  );
  Qa.displayName = "CustomDialog";
  const aae = ["top", "right", "bottom", "left"], sl = Math.min, oo = Math.max, cb = Math.round, av = Math.floor, Ha = (e) => ({
    x: e,
    y: e
  }), iae = {
    left: "right",
    right: "left",
    bottom: "top",
    top: "bottom"
  }, sae = {
    start: "end",
    end: "start"
  };
  function O2(e, t, n) {
    return oo(e, sl(t, n));
  }
  function Ki(e, t) {
    return typeof e == "function" ? e(t) : e;
  }
  function Gi(e) {
    return e.split("-")[0];
  }
  function Fd(e) {
    return e.split("-")[1];
  }
  function DC(e) {
    return e === "x" ? "y" : "x";
  }
  function LC(e) {
    return e === "y" ? "height" : "width";
  }
  const lae = /* @__PURE__ */ new Set(["top", "bottom"]);
  function ja(e) {
    return lae.has(Gi(e)) ? "y" : "x";
  }
  function FC(e) {
    return DC(ja(e));
  }
  function uae(e, t, n) {
    n === void 0 && (n = !1);
    const r = Fd(e), o = FC(e), a = LC(o);
    let i = o === "x" ? r === (n ? "end" : "start") ? "right" : "left" : r === "start" ? "bottom" : "top";
    return t.reference[a] > t.floating[a] && (i = db(i)), [i, db(i)];
  }
  function cae(e) {
    const t = db(e);
    return [N2(e), t, N2(t)];
  }
  function N2(e) {
    return e.replace(/start|end/g, (t) => sae[t]);
  }
  const aA = ["left", "right"], iA = ["right", "left"], dae = ["top", "bottom"], fae = ["bottom", "top"];
  function pae(e, t, n) {
    switch (e) {
      case "top":
      case "bottom":
        return n ? t ? iA : aA : t ? aA : iA;
      case "left":
      case "right":
        return t ? dae : fae;
      default:
        return [];
    }
  }
  function mae(e, t, n, r) {
    const o = Fd(e);
    let a = pae(Gi(e), n === "start", r);
    return o && (a = a.map((i) => i + "-" + o), t && (a = a.concat(a.map(N2)))), a;
  }
  function db(e) {
    return e.replace(/left|right|bottom|top/g, (t) => iae[t]);
  }
  function hae(e) {
    return {
      top: 0,
      right: 0,
      bottom: 0,
      left: 0,
      ...e
    };
  }
  function Az(e) {
    return typeof e != "number" ? hae(e) : {
      top: e,
      right: e,
      bottom: e,
      left: e
    };
  }
  function fb(e) {
    const {
      x: t,
      y: n,
      width: r,
      height: o
    } = e;
    return {
      width: r,
      height: o,
      top: n,
      left: t,
      right: t + r,
      bottom: n + o,
      x: t,
      y: n
    };
  }
  function sA(e, t, n) {
    let {
      reference: r,
      floating: o
    } = e;
    const a = ja(t), i = FC(t), s = LC(i), u = Gi(t), c = a === "y", f = r.x + r.width / 2 - o.width / 2, p = r.y + r.height / 2 - o.height / 2, g = r[s] / 2 - o[s] / 2;
    let h;
    switch (u) {
      case "top":
        h = {
          x: f,
          y: r.y - o.height
        };
        break;
      case "bottom":
        h = {
          x: f,
          y: r.y + r.height
        };
        break;
      case "right":
        h = {
          x: r.x + r.width,
          y: p
        };
        break;
      case "left":
        h = {
          x: r.x - o.width,
          y: p
        };
        break;
      default:
        h = {
          x: r.x,
          y: r.y
        };
    }
    switch (Fd(t)) {
      case "start":
        h[i] -= g * (n && c ? -1 : 1);
        break;
      case "end":
        h[i] += g * (n && c ? -1 : 1);
        break;
    }
    return h;
  }
  const gae = async (e, t, n) => {
    const {
      placement: r = "bottom",
      strategy: o = "absolute",
      middleware: a = [],
      platform: i
    } = n, s = a.filter(Boolean), u = await (i.isRTL == null ? void 0 : i.isRTL(t));
    let c = await i.getElementRects({
      reference: e,
      floating: t,
      strategy: o
    }), {
      x: f,
      y: p
    } = sA(c, r, u), g = r, h = {}, y = 0;
    for (let b = 0; b < s.length; b++) {
      const {
        name: v,
        fn: w
      } = s[b], {
        x: _,
        y: k,
        data: E,
        reset: P
      } = await w({
        x: f,
        y: p,
        initialPlacement: r,
        placement: g,
        strategy: o,
        middlewareData: h,
        rects: c,
        platform: i,
        elements: {
          reference: e,
          floating: t
        }
      });
      f = _ ?? f, p = k ?? p, h = {
        ...h,
        [v]: {
          ...h[v],
          ...E
        }
      }, P && y <= 50 && (y++, typeof P == "object" && (P.placement && (g = P.placement), P.rects && (c = P.rects === !0 ? await i.getElementRects({
        reference: e,
        floating: t,
        strategy: o
      }) : P.rects), {
        x: f,
        y: p
      } = sA(c, g, u)), b = -1);
    }
    return {
      x: f,
      y: p,
      placement: g,
      strategy: o,
      middlewareData: h
    };
  };
  async function tm(e, t) {
    var n;
    t === void 0 && (t = {});
    const {
      x: r,
      y: o,
      platform: a,
      rects: i,
      elements: s,
      strategy: u
    } = e, {
      boundary: c = "clippingAncestors",
      rootBoundary: f = "viewport",
      elementContext: p = "floating",
      altBoundary: g = !1,
      padding: h = 0
    } = Ki(t, e), y = Az(h), b = s[g ? p === "floating" ? "reference" : "floating" : p], v = fb(await a.getClippingRect({
      element: (n = await (a.isElement == null ? void 0 : a.isElement(b))) == null || n ? b : b.contextElement || await (a.getDocumentElement == null ? void 0 : a.getDocumentElement(s.floating)),
      boundary: c,
      rootBoundary: f,
      strategy: u
    })), w = p === "floating" ? {
      x: r,
      y: o,
      width: i.floating.width,
      height: i.floating.height
    } : i.reference, _ = await (a.getOffsetParent == null ? void 0 : a.getOffsetParent(s.floating)), k = await (a.isElement == null ? void 0 : a.isElement(_)) ? await (a.getScale == null ? void 0 : a.getScale(_)) || {
      x: 1,
      y: 1
    } : {
      x: 1,
      y: 1
    }, E = fb(a.convertOffsetParentRelativeRectToViewportRelativeRect ? await a.convertOffsetParentRelativeRectToViewportRelativeRect({
      elements: s,
      rect: w,
      offsetParent: _,
      strategy: u
    }) : w);
    return {
      top: (v.top - E.top + y.top) / k.y,
      bottom: (E.bottom - v.bottom + y.bottom) / k.y,
      left: (v.left - E.left + y.left) / k.x,
      right: (E.right - v.right + y.right) / k.x
    };
  }
  const vae = (e) => ({
    name: "arrow",
    options: e,
    async fn(t) {
      const {
        x: n,
        y: r,
        placement: o,
        rects: a,
        platform: i,
        elements: s,
        middlewareData: u
      } = t, {
        element: c,
        padding: f = 0
      } = Ki(e, t) || {};
      if (c == null)
        return {};
      const p = Az(f), g = {
        x: n,
        y: r
      }, h = FC(o), y = LC(h), b = await i.getDimensions(c), v = h === "y", w = v ? "top" : "left", _ = v ? "bottom" : "right", k = v ? "clientHeight" : "clientWidth", E = a.reference[y] + a.reference[h] - g[h] - a.floating[y], P = g[h] - a.reference[h], O = await (i.getOffsetParent == null ? void 0 : i.getOffsetParent(c));
      let M = O ? O[k] : 0;
      (!M || !await (i.isElement == null ? void 0 : i.isElement(O))) && (M = s.floating[k] || a.floating[y]);
      const I = E / 2 - P / 2, A = M / 2 - b[y] / 2 - 1, D = sl(p[w], A), F = sl(p[_], A), j = D, U = M - b[y] - F, $ = M / 2 - b[y] / 2 + I, q = O2(j, $, U), B = !u.arrow && Fd(o) != null && $ !== q && a.reference[y] / 2 - ($ < j ? D : F) - b[y] / 2 < 0, G = B ? $ < j ? $ - j : $ - U : 0;
      return {
        [h]: g[h] + G,
        data: {
          [h]: q,
          centerOffset: $ - q - G,
          ...B && {
            alignmentOffset: G
          }
        },
        reset: B
      };
    }
  }), yae = function(e) {
    return e === void 0 && (e = {}), {
      name: "flip",
      options: e,
      async fn(t) {
        var n, r;
        const {
          placement: o,
          middlewareData: a,
          rects: i,
          initialPlacement: s,
          platform: u,
          elements: c
        } = t, {
          mainAxis: f = !0,
          crossAxis: p = !0,
          fallbackPlacements: g,
          fallbackStrategy: h = "bestFit",
          fallbackAxisSideDirection: y = "none",
          flipAlignment: b = !0,
          ...v
        } = Ki(e, t);
        if ((n = a.arrow) != null && n.alignmentOffset)
          return {};
        const w = Gi(o), _ = ja(s), k = Gi(s) === s, E = await (u.isRTL == null ? void 0 : u.isRTL(c.floating)), P = g || (k || !b ? [db(s)] : cae(s)), O = y !== "none";
        !g && O && P.push(...mae(s, b, y, E));
        const M = [s, ...P], I = await tm(t, v), A = [];
        let D = ((r = a.flip) == null ? void 0 : r.overflows) || [];
        if (f && A.push(I[w]), p) {
          const $ = uae(o, i, E);
          A.push(I[$[0]], I[$[1]]);
        }
        if (D = [...D, {
          placement: o,
          overflows: A
        }], !A.every(($) => $ <= 0)) {
          var F, j;
          const $ = (((F = a.flip) == null ? void 0 : F.index) || 0) + 1, q = M[$];
          if (q && (!(p === "alignment" && _ !== ja(q)) || // We leave the current main axis only if every placement on that axis
          // overflows the main axis.
          D.every((G) => G.overflows[0] > 0 && ja(G.placement) === _)))
            return {
              data: {
                index: $,
                overflows: D
              },
              reset: {
                placement: q
              }
            };
          let B = (j = D.filter((G) => G.overflows[0] <= 0).sort((G, W) => G.overflows[1] - W.overflows[1])[0]) == null ? void 0 : j.placement;
          if (!B)
            switch (h) {
              case "bestFit": {
                var U;
                const G = (U = D.filter((W) => {
                  if (O) {
                    const Y = ja(W.placement);
                    return Y === _ || // Create a bias to the `y` side axis due to horizontal
                    // reading directions favoring greater width.
                    Y === "y";
                  }
                  return !0;
                }).map((W) => [W.placement, W.overflows.filter((Y) => Y > 0).reduce((Y, z) => Y + z, 0)]).sort((W, Y) => W[1] - Y[1])[0]) == null ? void 0 : U[0];
                G && (B = G);
                break;
              }
              case "initialPlacement":
                B = s;
                break;
            }
          if (o !== B)
            return {
              reset: {
                placement: B
              }
            };
        }
        return {};
      }
    };
  };
  function lA(e, t) {
    return {
      top: e.top - t.height,
      right: e.right - t.width,
      bottom: e.bottom - t.height,
      left: e.left - t.width
    };
  }
  function uA(e) {
    return aae.some((t) => e[t] >= 0);
  }
  const bae = function(e) {
    return e === void 0 && (e = {}), {
      name: "hide",
      options: e,
      async fn(t) {
        const {
          rects: n
        } = t, {
          strategy: r = "referenceHidden",
          ...o
        } = Ki(e, t);
        switch (r) {
          case "referenceHidden": {
            const a = await tm(t, {
              ...o,
              elementContext: "reference"
            }), i = lA(a, n.reference);
            return {
              data: {
                referenceHiddenOffsets: i,
                referenceHidden: uA(i)
              }
            };
          }
          case "escaped": {
            const a = await tm(t, {
              ...o,
              altBoundary: !0
            }), i = lA(a, n.floating);
            return {
              data: {
                escapedOffsets: i,
                escaped: uA(i)
              }
            };
          }
          default:
            return {};
        }
      }
    };
  }, $z = /* @__PURE__ */ new Set(["left", "top"]);
  async function wae(e, t) {
    const {
      placement: n,
      platform: r,
      elements: o
    } = e, a = await (r.isRTL == null ? void 0 : r.isRTL(o.floating)), i = Gi(n), s = Fd(n), u = ja(n) === "y", c = $z.has(i) ? -1 : 1, f = a && u ? -1 : 1, p = Ki(t, e);
    let {
      mainAxis: g,
      crossAxis: h,
      alignmentAxis: y
    } = typeof p == "number" ? {
      mainAxis: p,
      crossAxis: 0,
      alignmentAxis: null
    } : {
      mainAxis: p.mainAxis || 0,
      crossAxis: p.crossAxis || 0,
      alignmentAxis: p.alignmentAxis
    };
    return s && typeof y == "number" && (h = s === "end" ? y * -1 : y), u ? {
      x: h * f,
      y: g * c
    } : {
      x: g * c,
      y: h * f
    };
  }
  const xae = function(e) {
    return e === void 0 && (e = 0), {
      name: "offset",
      options: e,
      async fn(t) {
        var n, r;
        const {
          x: o,
          y: a,
          placement: i,
          middlewareData: s
        } = t, u = await wae(t, e);
        return i === ((n = s.offset) == null ? void 0 : n.placement) && (r = s.arrow) != null && r.alignmentOffset ? {} : {
          x: o + u.x,
          y: a + u.y,
          data: {
            ...u,
            placement: i
          }
        };
      }
    };
  }, kae = function(e) {
    return e === void 0 && (e = {}), {
      name: "shift",
      options: e,
      async fn(t) {
        const {
          x: n,
          y: r,
          placement: o
        } = t, {
          mainAxis: a = !0,
          crossAxis: i = !1,
          limiter: s = {
            fn: (v) => {
              let {
                x: w,
                y: _
              } = v;
              return {
                x: w,
                y: _
              };
            }
          },
          ...u
        } = Ki(e, t), c = {
          x: n,
          y: r
        }, f = await tm(t, u), p = ja(Gi(o)), g = DC(p);
        let h = c[g], y = c[p];
        if (a) {
          const v = g === "y" ? "top" : "left", w = g === "y" ? "bottom" : "right", _ = h + f[v], k = h - f[w];
          h = O2(_, h, k);
        }
        if (i) {
          const v = p === "y" ? "top" : "left", w = p === "y" ? "bottom" : "right", _ = y + f[v], k = y - f[w];
          y = O2(_, y, k);
        }
        const b = s.fn({
          ...t,
          [g]: h,
          [p]: y
        });
        return {
          ...b,
          data: {
            x: b.x - n,
            y: b.y - r,
            enabled: {
              [g]: a,
              [p]: i
            }
          }
        };
      }
    };
  }, Sae = function(e) {
    return e === void 0 && (e = {}), {
      options: e,
      fn(t) {
        const {
          x: n,
          y: r,
          placement: o,
          rects: a,
          middlewareData: i
        } = t, {
          offset: s = 0,
          mainAxis: u = !0,
          crossAxis: c = !0
        } = Ki(e, t), f = {
          x: n,
          y: r
        }, p = ja(o), g = DC(p);
        let h = f[g], y = f[p];
        const b = Ki(s, t), v = typeof b == "number" ? {
          mainAxis: b,
          crossAxis: 0
        } : {
          mainAxis: 0,
          crossAxis: 0,
          ...b
        };
        if (u) {
          const k = g === "y" ? "height" : "width", E = a.reference[g] - a.floating[k] + v.mainAxis, P = a.reference[g] + a.reference[k] - v.mainAxis;
          h < E ? h = E : h > P && (h = P);
        }
        if (c) {
          var w, _;
          const k = g === "y" ? "width" : "height", E = $z.has(Gi(o)), P = a.reference[p] - a.floating[k] + (E && ((w = i.offset) == null ? void 0 : w[p]) || 0) + (E ? 0 : v.crossAxis), O = a.reference[p] + a.reference[k] + (E ? 0 : ((_ = i.offset) == null ? void 0 : _[p]) || 0) - (E ? v.crossAxis : 0);
          y < P ? y = P : y > O && (y = O);
        }
        return {
          [g]: h,
          [p]: y
        };
      }
    };
  }, _ae = function(e) {
    return e === void 0 && (e = {}), {
      name: "size",
      options: e,
      async fn(t) {
        var n, r;
        const {
          placement: o,
          rects: a,
          platform: i,
          elements: s
        } = t, {
          apply: u = () => {
          },
          ...c
        } = Ki(e, t), f = await tm(t, c), p = Gi(o), g = Fd(o), h = ja(o) === "y", {
          width: y,
          height: b
        } = a.floating;
        let v, w;
        p === "top" || p === "bottom" ? (v = p, w = g === (await (i.isRTL == null ? void 0 : i.isRTL(s.floating)) ? "start" : "end") ? "left" : "right") : (w = p, v = g === "end" ? "top" : "bottom");
        const _ = b - f.top - f.bottom, k = y - f.left - f.right, E = sl(b - f[v], _), P = sl(y - f[w], k), O = !t.middlewareData.shift;
        let M = E, I = P;
        if ((n = t.middlewareData.shift) != null && n.enabled.x && (I = k), (r = t.middlewareData.shift) != null && r.enabled.y && (M = _), O && !g) {
          const D = oo(f.left, 0), F = oo(f.right, 0), j = oo(f.top, 0), U = oo(f.bottom, 0);
          h ? I = y - 2 * (D !== 0 || F !== 0 ? D + F : oo(f.left, f.right)) : M = b - 2 * (j !== 0 || U !== 0 ? j + U : oo(f.top, f.bottom));
        }
        await u({
          ...t,
          availableWidth: I,
          availableHeight: M
        });
        const A = await i.getDimensions(s.floating);
        return y !== A.width || b !== A.height ? {
          reset: {
            rects: !0
          }
        } : {};
      }
    };
  };
  function Rw() {
    return typeof window < "u";
  }
  function Td(e) {
    return Dz(e) ? (e.nodeName || "").toLowerCase() : "#document";
  }
  function co(e) {
    var t;
    return (e == null || (t = e.ownerDocument) == null ? void 0 : t.defaultView) || window;
  }
  function Za(e) {
    var t;
    return (t = (Dz(e) ? e.ownerDocument : e.document) || window.document) == null ? void 0 : t.documentElement;
  }
  function Dz(e) {
    return Rw() ? e instanceof Node || e instanceof co(e).Node : !1;
  }
  function ra(e) {
    return Rw() ? e instanceof Element || e instanceof co(e).Element : !1;
  }
  function qa(e) {
    return Rw() ? e instanceof HTMLElement || e instanceof co(e).HTMLElement : !1;
  }
  function cA(e) {
    return !Rw() || typeof ShadowRoot > "u" ? !1 : e instanceof ShadowRoot || e instanceof co(e).ShadowRoot;
  }
  const Eae = /* @__PURE__ */ new Set(["inline", "contents"]);
  function qm(e) {
    const {
      overflow: t,
      overflowX: n,
      overflowY: r,
      display: o
    } = oa(e);
    return /auto|scroll|overlay|hidden|clip/.test(t + r + n) && !Eae.has(o);
  }
  const Cae = /* @__PURE__ */ new Set(["table", "td", "th"]);
  function Pae(e) {
    return Cae.has(Td(e));
  }
  const Oae = [":popover-open", ":modal"];
  function jw(e) {
    return Oae.some((t) => {
      try {
        return e.matches(t);
      } catch {
        return !1;
      }
    });
  }
  const Nae = ["transform", "translate", "scale", "rotate", "perspective"], Mae = ["transform", "translate", "scale", "rotate", "perspective", "filter"], Rae = ["paint", "layout", "strict", "content"];
  function TC(e) {
    const t = zC(), n = ra(e) ? oa(e) : e;
    return Nae.some((r) => n[r] ? n[r] !== "none" : !1) || (n.containerType ? n.containerType !== "normal" : !1) || !t && (n.backdropFilter ? n.backdropFilter !== "none" : !1) || !t && (n.filter ? n.filter !== "none" : !1) || Mae.some((r) => (n.willChange || "").includes(r)) || Rae.some((r) => (n.contain || "").includes(r));
  }
  function jae(e) {
    let t = ll(e);
    for (; qa(t) && !hd(t); ) {
      if (TC(t))
        return t;
      if (jw(t))
        return null;
      t = ll(t);
    }
    return null;
  }
  function zC() {
    return typeof CSS > "u" || !CSS.supports ? !1 : CSS.supports("-webkit-backdrop-filter", "none");
  }
  const Iae = /* @__PURE__ */ new Set(["html", "body", "#document"]);
  function hd(e) {
    return Iae.has(Td(e));
  }
  function oa(e) {
    return co(e).getComputedStyle(e);
  }
  function Iw(e) {
    return ra(e) ? {
      scrollLeft: e.scrollLeft,
      scrollTop: e.scrollTop
    } : {
      scrollLeft: e.scrollX,
      scrollTop: e.scrollY
    };
  }
  function ll(e) {
    if (Td(e) === "html")
      return e;
    const t = (
      // Step into the shadow DOM of the parent of a slotted node.
      e.assignedSlot || // DOM Element detected.
      e.parentNode || // ShadowRoot detected.
      cA(e) && e.host || // Fallback.
      Za(e)
    );
    return cA(t) ? t.host : t;
  }
  function Lz(e) {
    const t = ll(e);
    return hd(t) ? e.ownerDocument ? e.ownerDocument.body : e.body : qa(t) && qm(t) ? t : Lz(t);
  }
  function nm(e, t, n) {
    var r;
    t === void 0 && (t = []), n === void 0 && (n = !0);
    const o = Lz(e), a = o === ((r = e.ownerDocument) == null ? void 0 : r.body), i = co(o);
    if (a) {
      const s = M2(i);
      return t.concat(i, i.visualViewport || [], qm(o) ? o : [], s && n ? nm(s) : []);
    }
    return t.concat(o, nm(o, [], n));
  }
  function M2(e) {
    return e.parent && Object.getPrototypeOf(e.parent) ? e.frameElement : null;
  }
  function Fz(e) {
    const t = oa(e);
    let n = parseFloat(t.width) || 0, r = parseFloat(t.height) || 0;
    const o = qa(e), a = o ? e.offsetWidth : n, i = o ? e.offsetHeight : r, s = cb(n) !== a || cb(r) !== i;
    return s && (n = a, r = i), {
      width: n,
      height: r,
      $: s
    };
  }
  function BC(e) {
    return ra(e) ? e : e.contextElement;
  }
  function rd(e) {
    const t = BC(e);
    if (!qa(t))
      return Ha(1);
    const n = t.getBoundingClientRect(), {
      width: r,
      height: o,
      $: a
    } = Fz(t);
    let i = (a ? cb(n.width) : n.width) / r, s = (a ? cb(n.height) : n.height) / o;
    return (!i || !Number.isFinite(i)) && (i = 1), (!s || !Number.isFinite(s)) && (s = 1), {
      x: i,
      y: s
    };
  }
  const Aae = /* @__PURE__ */ Ha(0);
  function Tz(e) {
    const t = co(e);
    return !zC() || !t.visualViewport ? Aae : {
      x: t.visualViewport.offsetLeft,
      y: t.visualViewport.offsetTop
    };
  }
  function $ae(e, t, n) {
    return t === void 0 && (t = !1), !n || t && n !== co(e) ? !1 : t;
  }
  function uu(e, t, n, r) {
    t === void 0 && (t = !1), n === void 0 && (n = !1);
    const o = e.getBoundingClientRect(), a = BC(e);
    let i = Ha(1);
    t && (r ? ra(r) && (i = rd(r)) : i = rd(e));
    const s = $ae(a, n, r) ? Tz(a) : Ha(0);
    let u = (o.left + s.x) / i.x, c = (o.top + s.y) / i.y, f = o.width / i.x, p = o.height / i.y;
    if (a) {
      const g = co(a), h = r && ra(r) ? co(r) : r;
      let y = g, b = M2(y);
      for (; b && r && h !== y; ) {
        const v = rd(b), w = b.getBoundingClientRect(), _ = oa(b), k = w.left + (b.clientLeft + parseFloat(_.paddingLeft)) * v.x, E = w.top + (b.clientTop + parseFloat(_.paddingTop)) * v.y;
        u *= v.x, c *= v.y, f *= v.x, p *= v.y, u += k, c += E, y = co(b), b = M2(y);
      }
    }
    return fb({
      width: f,
      height: p,
      x: u,
      y: c
    });
  }
  function VC(e, t) {
    const n = Iw(e).scrollLeft;
    return t ? t.left + n : uu(Za(e)).left + n;
  }
  function zz(e, t, n) {
    n === void 0 && (n = !1);
    const r = e.getBoundingClientRect(), o = r.left + t.scrollLeft - (n ? 0 : (
      // RTL <body> scrollbar.
      VC(e, r)
    )), a = r.top + t.scrollTop;
    return {
      x: o,
      y: a
    };
  }
  function Dae(e) {
    let {
      elements: t,
      rect: n,
      offsetParent: r,
      strategy: o
    } = e;
    const a = o === "fixed", i = Za(r), s = t ? jw(t.floating) : !1;
    if (r === i || s && a)
      return n;
    let u = {
      scrollLeft: 0,
      scrollTop: 0
    }, c = Ha(1);
    const f = Ha(0), p = qa(r);
    if ((p || !p && !a) && ((Td(r) !== "body" || qm(i)) && (u = Iw(r)), qa(r))) {
      const h = uu(r);
      c = rd(r), f.x = h.x + r.clientLeft, f.y = h.y + r.clientTop;
    }
    const g = i && !p && !a ? zz(i, u, !0) : Ha(0);
    return {
      width: n.width * c.x,
      height: n.height * c.y,
      x: n.x * c.x - u.scrollLeft * c.x + f.x + g.x,
      y: n.y * c.y - u.scrollTop * c.y + f.y + g.y
    };
  }
  function Lae(e) {
    return Array.from(e.getClientRects());
  }
  function Fae(e) {
    const t = Za(e), n = Iw(e), r = e.ownerDocument.body, o = oo(t.scrollWidth, t.clientWidth, r.scrollWidth, r.clientWidth), a = oo(t.scrollHeight, t.clientHeight, r.scrollHeight, r.clientHeight);
    let i = -n.scrollLeft + VC(e);
    const s = -n.scrollTop;
    return oa(r).direction === "rtl" && (i += oo(t.clientWidth, r.clientWidth) - o), {
      width: o,
      height: a,
      x: i,
      y: s
    };
  }
  function Tae(e, t) {
    const n = co(e), r = Za(e), o = n.visualViewport;
    let a = r.clientWidth, i = r.clientHeight, s = 0, u = 0;
    if (o) {
      a = o.width, i = o.height;
      const c = zC();
      (!c || c && t === "fixed") && (s = o.offsetLeft, u = o.offsetTop);
    }
    return {
      width: a,
      height: i,
      x: s,
      y: u
    };
  }
  const zae = /* @__PURE__ */ new Set(["absolute", "fixed"]);
  function Bae(e, t) {
    const n = uu(e, !0, t === "fixed"), r = n.top + e.clientTop, o = n.left + e.clientLeft, a = qa(e) ? rd(e) : Ha(1), i = e.clientWidth * a.x, s = e.clientHeight * a.y, u = o * a.x, c = r * a.y;
    return {
      width: i,
      height: s,
      x: u,
      y: c
    };
  }
  function dA(e, t, n) {
    let r;
    if (t === "viewport")
      r = Tae(e, n);
    else if (t === "document")
      r = Fae(Za(e));
    else if (ra(t))
      r = Bae(t, n);
    else {
      const o = Tz(e);
      r = {
        x: t.x - o.x,
        y: t.y - o.y,
        width: t.width,
        height: t.height
      };
    }
    return fb(r);
  }
  function Bz(e, t) {
    const n = ll(e);
    return n === t || !ra(n) || hd(n) ? !1 : oa(n).position === "fixed" || Bz(n, t);
  }
  function Vae(e, t) {
    const n = t.get(e);
    if (n)
      return n;
    let r = nm(e, [], !1).filter((s) => ra(s) && Td(s) !== "body"), o = null;
    const a = oa(e).position === "fixed";
    let i = a ? ll(e) : e;
    for (; ra(i) && !hd(i); ) {
      const s = oa(i), u = TC(i);
      !u && s.position === "fixed" && (o = null), (a ? !u && !o : !u && s.position === "static" && o && zae.has(o.position) || qm(i) && !u && Bz(e, i)) ? r = r.filter((c) => c !== i) : o = s, i = ll(i);
    }
    return t.set(e, r), r;
  }
  function Uae(e) {
    let {
      element: t,
      boundary: n,
      rootBoundary: r,
      strategy: o
    } = e;
    const a = [...n === "clippingAncestors" ? jw(t) ? [] : Vae(t, this._c) : [].concat(n), r], i = a[0], s = a.reduce((u, c) => {
      const f = dA(t, c, o);
      return u.top = oo(f.top, u.top), u.right = sl(f.right, u.right), u.bottom = sl(f.bottom, u.bottom), u.left = oo(f.left, u.left), u;
    }, dA(t, i, o));
    return {
      width: s.right - s.left,
      height: s.bottom - s.top,
      x: s.left,
      y: s.top
    };
  }
  function Hae(e) {
    const {
      width: t,
      height: n
    } = Fz(e);
    return {
      width: t,
      height: n
    };
  }
  function Wae(e, t, n) {
    const r = qa(t), o = Za(t), a = n === "fixed", i = uu(e, !0, a, t);
    let s = {
      scrollLeft: 0,
      scrollTop: 0
    };
    const u = Ha(0);
    function c() {
      u.x = VC(o);
    }
    if (r || !r && !a)
      if ((Td(t) !== "body" || qm(o)) && (s = Iw(t)), r) {
        const h = uu(t, !0, a, t);
        u.x = h.x + t.clientLeft, u.y = h.y + t.clientTop;
      } else o && c();
    a && !r && o && c();
    const f = o && !r && !a ? zz(o, s) : Ha(0), p = i.left + s.scrollLeft - u.x - f.x, g = i.top + s.scrollTop - u.y - f.y;
    return {
      x: p,
      y: g,
      width: i.width,
      height: i.height
    };
  }
  function O_(e) {
    return oa(e).position === "static";
  }
  function fA(e, t) {
    if (!qa(e) || oa(e).position === "fixed")
      return null;
    if (t)
      return t(e);
    let n = e.offsetParent;
    return Za(e) === n && (n = n.ownerDocument.body), n;
  }
  function Vz(e, t) {
    const n = co(e);
    if (jw(e))
      return n;
    if (!qa(e)) {
      let o = ll(e);
      for (; o && !hd(o); ) {
        if (ra(o) && !O_(o))
          return o;
        o = ll(o);
      }
      return n;
    }
    let r = fA(e, t);
    for (; r && Pae(r) && O_(r); )
      r = fA(r, t);
    return r && hd(r) && O_(r) && !TC(r) ? n : r || jae(e) || n;
  }
  const qae = async function(e) {
    const t = this.getOffsetParent || Vz, n = this.getDimensions, r = await n(e.floating);
    return {
      reference: Wae(e.reference, await t(e.floating), e.strategy),
      floating: {
        x: 0,
        y: 0,
        width: r.width,
        height: r.height
      }
    };
  };
  function Kae(e) {
    return oa(e).direction === "rtl";
  }
  const Gae = {
    convertOffsetParentRelativeRectToViewportRelativeRect: Dae,
    getDocumentElement: Za,
    getClippingRect: Uae,
    getOffsetParent: Vz,
    getElementRects: qae,
    getClientRects: Lae,
    getDimensions: Hae,
    getScale: rd,
    isElement: ra,
    isRTL: Kae
  };
  function Uz(e, t) {
    return e.x === t.x && e.y === t.y && e.width === t.width && e.height === t.height;
  }
  function Xae(e, t) {
    let n = null, r;
    const o = Za(e);
    function a() {
      var s;
      clearTimeout(r), (s = n) == null || s.disconnect(), n = null;
    }
    function i(s, u) {
      s === void 0 && (s = !1), u === void 0 && (u = 1), a();
      const c = e.getBoundingClientRect(), {
        left: f,
        top: p,
        width: g,
        height: h
      } = c;
      if (s || t(), !g || !h)
        return;
      const y = av(p), b = av(o.clientWidth - (f + g)), v = av(o.clientHeight - (p + h)), w = av(f), _ = {
        rootMargin: -y + "px " + -b + "px " + -v + "px " + -w + "px",
        threshold: oo(0, sl(1, u)) || 1
      };
      let k = !0;
      function E(P) {
        const O = P[0].intersectionRatio;
        if (O !== u) {
          if (!k)
            return i();
          O ? i(!1, O) : r = setTimeout(() => {
            i(!1, 1e-7);
          }, 1e3);
        }
        O === 1 && !Uz(c, e.getBoundingClientRect()) && i(), k = !1;
      }
      try {
        n = new IntersectionObserver(E, {
          ..._,
          // Handle <iframe>s
          root: o.ownerDocument
        });
      } catch {
        n = new IntersectionObserver(E, _);
      }
      n.observe(e);
    }
    return i(!0), a;
  }
  function Hz(e, t, n, r) {
    r === void 0 && (r = {});
    const {
      ancestorScroll: o = !0,
      ancestorResize: a = !0,
      elementResize: i = typeof ResizeObserver == "function",
      layoutShift: s = typeof IntersectionObserver == "function",
      animationFrame: u = !1
    } = r, c = BC(e), f = o || a ? [...c ? nm(c) : [], ...nm(t)] : [];
    f.forEach((w) => {
      o && w.addEventListener("scroll", n, {
        passive: !0
      }), a && w.addEventListener("resize", n);
    });
    const p = c && s ? Xae(c, n) : null;
    let g = -1, h = null;
    i && (h = new ResizeObserver((w) => {
      let [_] = w;
      _ && _.target === c && h && (h.unobserve(t), cancelAnimationFrame(g), g = requestAnimationFrame(() => {
        var k;
        (k = h) == null || k.observe(t);
      })), n();
    }), c && !u && h.observe(c), h.observe(t));
    let y, b = u ? uu(e) : null;
    u && v();
    function v() {
      const w = uu(e);
      b && !Uz(b, w) && n(), b = w, y = requestAnimationFrame(v);
    }
    return n(), () => {
      var w;
      f.forEach((_) => {
        o && _.removeEventListener("scroll", n), a && _.removeEventListener("resize", n);
      }), p?.(), (w = h) == null || w.disconnect(), h = null, u && cancelAnimationFrame(y);
    };
  }
  const Yae = xae, Jae = kae, Qae = yae, Zae = _ae, eie = bae, pA = vae, tie = Sae, nie = (e, t, n) => {
    const r = /* @__PURE__ */ new Map(), o = {
      platform: Gae,
      ...n
    }, a = {
      ...o.platform,
      _c: r
    };
    return gae(e, t, {
      ...o,
      platform: a
    });
  };
  var rie = typeof document < "u", oie = function() {
  }, jy = rie ? C.useLayoutEffect : oie;
  function pb(e, t) {
    if (e === t)
      return !0;
    if (typeof e != typeof t)
      return !1;
    if (typeof e == "function" && e.toString() === t.toString())
      return !0;
    let n, r, o;
    if (e && t && typeof e == "object") {
      if (Array.isArray(e)) {
        if (n = e.length, n !== t.length) return !1;
        for (r = n; r-- !== 0; )
          if (!pb(e[r], t[r]))
            return !1;
        return !0;
      }
      if (o = Object.keys(e), n = o.length, n !== Object.keys(t).length)
        return !1;
      for (r = n; r-- !== 0; )
        if (!{}.hasOwnProperty.call(t, o[r]))
          return !1;
      for (r = n; r-- !== 0; ) {
        const a = o[r];
        if (!(a === "_owner" && e.$$typeof) && !pb(e[a], t[a]))
          return !1;
      }
      return !0;
    }
    return e !== e && t !== t;
  }
  function Wz(e) {
    return typeof window > "u" ? 1 : (e.ownerDocument.defaultView || window).devicePixelRatio || 1;
  }
  function mA(e, t) {
    const n = Wz(e);
    return Math.round(t * n) / n;
  }
  function N_(e) {
    const t = C.useRef(e);
    return jy(() => {
      t.current = e;
    }), t;
  }
  function aie(e) {
    e === void 0 && (e = {});
    const {
      placement: t = "bottom",
      strategy: n = "absolute",
      middleware: r = [],
      platform: o,
      elements: {
        reference: a,
        floating: i
      } = {},
      transform: s = !0,
      whileElementsMounted: u,
      open: c
    } = e, [f, p] = C.useState({
      x: 0,
      y: 0,
      strategy: n,
      placement: t,
      middlewareData: {},
      isPositioned: !1
    }), [g, h] = C.useState(r);
    pb(g, r) || h(r);
    const [y, b] = C.useState(null), [v, w] = C.useState(null), _ = C.useCallback((W) => {
      W !== O.current && (O.current = W, b(W));
    }, []), k = C.useCallback((W) => {
      W !== M.current && (M.current = W, w(W));
    }, []), E = a || y, P = i || v, O = C.useRef(null), M = C.useRef(null), I = C.useRef(f), A = u != null, D = N_(u), F = N_(o), j = N_(c), U = C.useCallback(() => {
      if (!O.current || !M.current)
        return;
      const W = {
        placement: t,
        strategy: n,
        middleware: g
      };
      F.current && (W.platform = F.current), nie(O.current, M.current, W).then((Y) => {
        const z = {
          ...Y,
          // The floating element's position may be recomputed while it's closed
          // but still mounted (such as when transitioning out). To ensure
          // `isPositioned` will be `false` initially on the next open, avoid
          // setting it to `true` when `open === false` (must be specified).
          isPositioned: j.current !== !1
        };
        $.current && !pb(I.current, z) && (I.current = z, xu.flushSync(() => {
          p(z);
        }));
      });
    }, [g, t, n, F, j]);
    jy(() => {
      c === !1 && I.current.isPositioned && (I.current.isPositioned = !1, p((W) => ({
        ...W,
        isPositioned: !1
      })));
    }, [c]);
    const $ = C.useRef(!1);
    jy(() => ($.current = !0, () => {
      $.current = !1;
    }), []), jy(() => {
      if (E && (O.current = E), P && (M.current = P), E && P) {
        if (D.current)
          return D.current(E, P, U);
        U();
      }
    }, [E, P, U, D, A]);
    const q = C.useMemo(() => ({
      reference: O,
      floating: M,
      setReference: _,
      setFloating: k
    }), [_, k]), B = C.useMemo(() => ({
      reference: E,
      floating: P
    }), [E, P]), G = C.useMemo(() => {
      const W = {
        position: n,
        left: 0,
        top: 0
      };
      if (!B.floating)
        return W;
      const Y = mA(B.floating, f.x), z = mA(B.floating, f.y);
      return s ? {
        ...W,
        transform: "translate(" + Y + "px, " + z + "px)",
        ...Wz(B.floating) >= 1.5 && {
          willChange: "transform"
        }
      } : {
        position: n,
        left: Y,
        top: z
      };
    }, [n, s, B.floating, f.x, f.y]);
    return C.useMemo(() => ({
      ...f,
      update: U,
      refs: q,
      elements: B,
      floatingStyles: G
    }), [f, U, q, B, G]);
  }
  const iie = (e) => {
    function t(n) {
      return {}.hasOwnProperty.call(n, "current");
    }
    return {
      name: "arrow",
      options: e,
      fn(n) {
        const {
          element: r,
          padding: o
        } = typeof e == "function" ? e(n) : e;
        return r && t(r) ? r.current != null ? pA({
          element: r.current,
          padding: o
        }).fn(n) : {} : r ? pA({
          element: r,
          padding: o
        }).fn(n) : {};
      }
    };
  }, sie = (e, t) => ({
    ...Yae(e),
    options: [e, t]
  }), lie = (e, t) => ({
    ...Jae(e),
    options: [e, t]
  }), uie = (e, t) => ({
    ...tie(e),
    options: [e, t]
  }), cie = (e, t) => ({
    ...Qae(e),
    options: [e, t]
  }), die = (e, t) => ({
    ...Zae(e),
    options: [e, t]
  }), fie = (e, t) => ({
    ...eie(e),
    options: [e, t]
  }), pie = (e, t) => ({
    ...iie(e),
    options: [e, t]
  });
  var mie = "Arrow", qz = C.forwardRef((e, t) => {
    const { children: n, width: r = 10, height: o = 5, ...a } = e;
    return /* @__PURE__ */ S.jsx(
      gt.svg,
      {
        ...a,
        ref: t,
        width: r,
        height: o,
        viewBox: "0 0 30 10",
        preserveAspectRatio: "none",
        children: e.asChild ? n : /* @__PURE__ */ S.jsx("polygon", { points: "0,0 30,0 15,10" })
      }
    );
  });
  qz.displayName = mie;
  var hie = qz;
  function Kz(e) {
    const [t, n] = C.useState(void 0);
    return Hi(() => {
      if (e) {
        n({ width: e.offsetWidth, height: e.offsetHeight });
        const r = new ResizeObserver((o) => {
          if (!Array.isArray(o) || !o.length)
            return;
          const a = o[0];
          let i, s;
          if ("borderBoxSize" in a) {
            const u = a.borderBoxSize, c = Array.isArray(u) ? u[0] : u;
            i = c.inlineSize, s = c.blockSize;
          } else
            i = e.offsetWidth, s = e.offsetHeight;
          n({ width: i, height: s });
        });
        return r.observe(e, { box: "border-box" }), () => r.unobserve(e);
      } else
        n(void 0);
    }, [e]), t;
  }
  var UC = "Popper", [Gz, Aw] = Ja(UC), [gie, Xz] = Gz(UC), Yz = (e) => {
    const { __scopePopper: t, children: n } = e, [r, o] = C.useState(null);
    return /* @__PURE__ */ S.jsx(gie, { scope: t, anchor: r, onAnchorChange: o, children: n });
  };
  Yz.displayName = UC;
  var Jz = "PopperAnchor", Qz = C.forwardRef(
    (e, t) => {
      const { __scopePopper: n, virtualRef: r, ...o } = e, a = Xz(Jz, n), i = C.useRef(null), s = un(t, i), u = C.useRef(null);
      return C.useEffect(() => {
        const c = u.current;
        u.current = r?.current || i.current, c !== u.current && a.onAnchorChange(u.current);
      }), r ? null : /* @__PURE__ */ S.jsx(gt.div, { ...o, ref: s });
    }
  );
  Qz.displayName = Jz;
  var HC = "PopperContent", [vie, yie] = Gz(HC), Zz = C.forwardRef(
    (e, t) => {
      const {
        __scopePopper: n,
        side: r = "bottom",
        sideOffset: o = 0,
        align: a = "center",
        alignOffset: i = 0,
        arrowPadding: s = 0,
        avoidCollisions: u = !0,
        collisionBoundary: c = [],
        collisionPadding: f = 0,
        sticky: p = "partial",
        hideWhenDetached: g = !1,
        updatePositionStrategy: h = "optimized",
        onPlaced: y,
        ...b
      } = e, v = Xz(HC, n), [w, _] = C.useState(null), k = un(t, (ne) => _(ne)), [E, P] = C.useState(null), O = Kz(E), M = O?.width ?? 0, I = O?.height ?? 0, A = r + (a !== "center" ? "-" + a : ""), D = typeof f == "number" ? f : { top: 0, right: 0, bottom: 0, left: 0, ...f }, F = Array.isArray(c) ? c : [c], j = F.length > 0, U = {
        padding: D,
        boundary: F.filter(wie),
        // with `strategy: 'fixed'`, this is the only way to get it to respect boundaries
        altBoundary: j
      }, { refs: $, floatingStyles: q, placement: B, isPositioned: G, middlewareData: W } = aie({
        // default to `fixed` strategy so users don't have to pick and we also avoid focus scroll issues
        strategy: "fixed",
        placement: A,
        whileElementsMounted: (...ne) => Hz(...ne, {
          animationFrame: h === "always"
        }),
        elements: {
          reference: v.anchor
        },
        middleware: [
          sie({ mainAxis: o + I, alignmentAxis: i }),
          u && lie({
            mainAxis: !0,
            crossAxis: !1,
            limiter: p === "partial" ? uie() : void 0,
            ...U
          }),
          u && cie({ ...U }),
          die({
            ...U,
            apply: ({ elements: ne, rects: te, availableWidth: ae, availableHeight: ce }) => {
              const { width: Z, height: ee } = te.reference, oe = ne.floating.style;
              oe.setProperty("--radix-popper-available-width", `${ae}px`), oe.setProperty("--radix-popper-available-height", `${ce}px`), oe.setProperty("--radix-popper-anchor-width", `${Z}px`), oe.setProperty("--radix-popper-anchor-height", `${ee}px`);
            }
          }),
          E && pie({ element: E, padding: s }),
          xie({ arrowWidth: M, arrowHeight: I }),
          g && fie({ strategy: "referenceHidden", ...U })
        ]
      }), [Y, z] = n9(B), L = Wr(y);
      Hi(() => {
        G && L?.();
      }, [G, L]);
      const K = W.arrow?.x, T = W.arrow?.y, V = W.arrow?.centerOffset !== 0, [X, Q] = C.useState();
      return Hi(() => {
        w && Q(window.getComputedStyle(w).zIndex);
      }, [w]), /* @__PURE__ */ S.jsx(
        "div",
        {
          ref: $.setFloating,
          "data-radix-popper-content-wrapper": "",
          style: {
            ...q,
            transform: G ? q.transform : "translate(0, -200%)",
            // keep off the page when measuring
            minWidth: "max-content",
            zIndex: X,
            "--radix-popper-transform-origin": [
              W.transformOrigin?.x,
              W.transformOrigin?.y
            ].join(" "),
            // hide the content if using the hide middleware and should be hidden
            // set visibility to hidden and disable pointer events so the UI behaves
            // as if the PopperContent isn't there at all
            ...W.hide?.referenceHidden && {
              visibility: "hidden",
              pointerEvents: "none"
            }
          },
          dir: e.dir,
          children: /* @__PURE__ */ S.jsx(
            vie,
            {
              scope: n,
              placedSide: Y,
              onArrowChange: P,
              arrowX: K,
              arrowY: T,
              shouldHideArrow: V,
              children: /* @__PURE__ */ S.jsx(
                gt.div,
                {
                  "data-side": Y,
                  "data-align": z,
                  ...b,
                  ref: k,
                  style: {
                    ...b.style,
                    // if the PopperContent hasn't been placed yet (not all measurements done)
                    // we prevent animations so that users's animation don't kick in too early referring wrong sides
                    animation: G ? void 0 : "none"
                  }
                }
              )
            }
          )
        }
      );
    }
  );
  Zz.displayName = HC;
  var e9 = "PopperArrow", bie = {
    top: "bottom",
    right: "left",
    bottom: "top",
    left: "right"
  }, t9 = C.forwardRef(function(e, t) {
    const { __scopePopper: n, ...r } = e, o = yie(e9, n), a = bie[o.placedSide];
    return (
      // we have to use an extra wrapper because `ResizeObserver` (used by `useSize`)
      // doesn't report size as we'd expect on SVG elements.
      // it reports their bounding box which is effectively the largest path inside the SVG.
      /* @__PURE__ */ S.jsx(
        "span",
        {
          ref: o.onArrowChange,
          style: {
            position: "absolute",
            left: o.arrowX,
            top: o.arrowY,
            [a]: 0,
            transformOrigin: {
              top: "",
              right: "0 0",
              bottom: "center 0",
              left: "100% 0"
            }[o.placedSide],
            transform: {
              top: "translateY(100%)",
              right: "translateY(50%) rotate(90deg) translateX(-50%)",
              bottom: "rotate(180deg)",
              left: "translateY(50%) rotate(-90deg) translateX(50%)"
            }[o.placedSide],
            visibility: o.shouldHideArrow ? "hidden" : void 0
          },
          children: /* @__PURE__ */ S.jsx(
            hie,
            {
              ...r,
              ref: t,
              style: {
                ...r.style,
                // ensures the element can be measured correctly (mostly for if SVG)
                display: "block"
              }
            }
          )
        }
      )
    );
  });
  t9.displayName = e9;
  function wie(e) {
    return e !== null;
  }
  var xie = (e) => ({
    name: "transformOrigin",
    options: e,
    fn(t) {
      const { placement: n, rects: r, middlewareData: o } = t, a = o.arrow?.centerOffset !== 0, i = a ? 0 : e.arrowWidth, s = a ? 0 : e.arrowHeight, [u, c] = n9(n), f = { start: "0%", center: "50%", end: "100%" }[c], p = (o.arrow?.x ?? 0) + i / 2, g = (o.arrow?.y ?? 0) + s / 2;
      let h = "", y = "";
      return u === "bottom" ? (h = a ? f : `${p}px`, y = `${-s}px`) : u === "top" ? (h = a ? f : `${p}px`, y = `${r.floating.height + s}px`) : u === "right" ? (h = `${-s}px`, y = a ? f : `${g}px`) : u === "left" && (h = `${r.floating.width + s}px`, y = a ? f : `${g}px`), { data: { x: h, y } };
    }
  });
  function n9(e) {
    const [t, n = "center"] = e.split("-");
    return [t, n];
  }
  var WC = Yz, qC = Qz, r9 = Zz, o9 = t9, $w = "Popover", [a9] = Ja($w, [
    Aw
  ]), Km = Aw(), [kie, hl] = a9($w), i9 = (e) => {
    const {
      __scopePopover: t,
      children: n,
      open: r,
      defaultOpen: o,
      onOpenChange: a,
      modal: i = !1
    } = e, s = Km(t), u = C.useRef(null), [c, f] = C.useState(!1), [p, g] = ml({
      prop: r,
      defaultProp: o ?? !1,
      onChange: a,
      caller: $w
    });
    return /* @__PURE__ */ S.jsx(WC, { ...s, children: /* @__PURE__ */ S.jsx(
      kie,
      {
        scope: t,
        contentId: Ua(),
        triggerRef: u,
        open: p,
        onOpenChange: g,
        onOpenToggle: C.useCallback(() => g((h) => !h), [g]),
        hasCustomAnchor: c,
        onCustomAnchorAdd: C.useCallback(() => f(!0), []),
        onCustomAnchorRemove: C.useCallback(() => f(!1), []),
        modal: i,
        children: n
      }
    ) });
  };
  i9.displayName = $w;
  var s9 = "PopoverAnchor", Sie = C.forwardRef(
    (e, t) => {
      const { __scopePopover: n, ...r } = e, o = hl(s9, n), a = Km(n), { onCustomAnchorAdd: i, onCustomAnchorRemove: s } = o;
      return C.useEffect(() => (i(), () => s()), [i, s]), /* @__PURE__ */ S.jsx(qC, { ...a, ...r, ref: t });
    }
  );
  Sie.displayName = s9;
  var l9 = "PopoverTrigger", u9 = C.forwardRef(
    (e, t) => {
      const { __scopePopover: n, ...r } = e, o = hl(l9, n), a = Km(n), i = un(t, o.triggerRef), s = /* @__PURE__ */ S.jsx(
        gt.button,
        {
          type: "button",
          "aria-haspopup": "dialog",
          "aria-expanded": o.open,
          "aria-controls": o.contentId,
          "data-state": h9(o.open),
          ...r,
          ref: i,
          onClick: Te(e.onClick, o.onOpenToggle)
        }
      );
      return o.hasCustomAnchor ? s : /* @__PURE__ */ S.jsx(qC, { asChild: !0, ...a, children: s });
    }
  );
  u9.displayName = l9;
  var KC = "PopoverPortal", [_ie, Eie] = a9(KC, {
    forceMount: void 0
  }), c9 = (e) => {
    const { __scopePopover: t, forceMount: n, children: r, container: o } = e, a = hl(KC, t);
    return /* @__PURE__ */ S.jsx(_ie, { scope: t, forceMount: n, children: /* @__PURE__ */ S.jsx(ia, { present: n || a.open, children: /* @__PURE__ */ S.jsx(xw, { asChild: !0, container: o, children: r }) }) });
  };
  c9.displayName = KC;
  var gd = "PopoverContent", d9 = C.forwardRef(
    (e, t) => {
      const n = Eie(gd, e.__scopePopover), { forceMount: r = n.forceMount, ...o } = e, a = hl(gd, e.__scopePopover);
      return /* @__PURE__ */ S.jsx(ia, { present: r || a.open, children: a.modal ? /* @__PURE__ */ S.jsx(Pie, { ...o, ref: t }) : /* @__PURE__ */ S.jsx(Oie, { ...o, ref: t }) });
    }
  );
  d9.displayName = gd;
  var Cie = /* @__PURE__ */ fd("PopoverContent.RemoveScroll"), Pie = C.forwardRef(
    (e, t) => {
      const n = hl(gd, e.__scopePopover), r = C.useRef(null), o = un(t, r), a = C.useRef(!1);
      return C.useEffect(() => {
        const i = r.current;
        if (i) return yC(i);
      }, []), /* @__PURE__ */ S.jsx(Sw, { as: Cie, allowPinchZoom: !0, children: /* @__PURE__ */ S.jsx(
        f9,
        {
          ...e,
          ref: o,
          trapFocus: n.open,
          disableOutsidePointerEvents: !0,
          onCloseAutoFocus: Te(e.onCloseAutoFocus, (i) => {
            i.preventDefault(), a.current || n.triggerRef.current?.focus();
          }),
          onPointerDownOutside: Te(
            e.onPointerDownOutside,
            (i) => {
              const s = i.detail.originalEvent, u = s.button === 0 && s.ctrlKey === !0, c = s.button === 2 || u;
              a.current = c;
            },
            { checkForDefaultPrevented: !1 }
          ),
          onFocusOutside: Te(
            e.onFocusOutside,
            (i) => i.preventDefault(),
            { checkForDefaultPrevented: !1 }
          )
        }
      ) });
    }
  ), Oie = C.forwardRef(
    (e, t) => {
      const n = hl(gd, e.__scopePopover), r = C.useRef(!1), o = C.useRef(!1);
      return /* @__PURE__ */ S.jsx(
        f9,
        {
          ...e,
          ref: t,
          trapFocus: !1,
          disableOutsidePointerEvents: !1,
          onCloseAutoFocus: (a) => {
            e.onCloseAutoFocus?.(a), a.defaultPrevented || (r.current || n.triggerRef.current?.focus(), a.preventDefault()), r.current = !1, o.current = !1;
          },
          onInteractOutside: (a) => {
            e.onInteractOutside?.(a), a.defaultPrevented || (r.current = !0, a.detail.originalEvent.type === "pointerdown" && (o.current = !0));
            const i = a.target;
            n.triggerRef.current?.contains(i) && a.preventDefault(), a.detail.originalEvent.type === "focusin" && o.current && a.preventDefault();
          }
        }
      );
    }
  ), f9 = C.forwardRef(
    (e, t) => {
      const {
        __scopePopover: n,
        trapFocus: r,
        onOpenAutoFocus: o,
        onCloseAutoFocus: a,
        disableOutsidePointerEvents: i,
        onEscapeKeyDown: s,
        onPointerDownOutside: u,
        onFocusOutside: c,
        onInteractOutside: f,
        ...p
      } = e, g = hl(gd, n), h = Km(n);
      return vC(), /* @__PURE__ */ S.jsx(
        ww,
        {
          asChild: !0,
          loop: !0,
          trapped: r,
          onMountAutoFocus: o,
          onUnmountAutoFocus: a,
          children: /* @__PURE__ */ S.jsx(
            Bm,
            {
              asChild: !0,
              disableOutsidePointerEvents: i,
              onInteractOutside: f,
              onEscapeKeyDown: s,
              onPointerDownOutside: u,
              onFocusOutside: c,
              onDismiss: () => g.onOpenChange(!1),
              children: /* @__PURE__ */ S.jsx(
                r9,
                {
                  "data-state": h9(g.open),
                  role: "dialog",
                  id: g.contentId,
                  ...h,
                  ...p,
                  ref: t,
                  style: {
                    ...p.style,
                    "--radix-popover-content-transform-origin": "var(--radix-popper-transform-origin)",
                    "--radix-popover-content-available-width": "var(--radix-popper-available-width)",
                    "--radix-popover-content-available-height": "var(--radix-popper-available-height)",
                    "--radix-popover-trigger-width": "var(--radix-popper-anchor-width)",
                    "--radix-popover-trigger-height": "var(--radix-popper-anchor-height)"
                  }
                }
              )
            }
          )
        }
      );
    }
  ), p9 = "PopoverClose", Nie = C.forwardRef(
    (e, t) => {
      const { __scopePopover: n, ...r } = e, o = hl(p9, n);
      return /* @__PURE__ */ S.jsx(
        gt.button,
        {
          type: "button",
          ...r,
          ref: t,
          onClick: Te(e.onClick, () => o.onOpenChange(!1))
        }
      );
    }
  );
  Nie.displayName = p9;
  var Mie = "PopoverArrow", m9 = C.forwardRef(
    (e, t) => {
      const { __scopePopover: n, ...r } = e, o = Km(n);
      return /* @__PURE__ */ S.jsx(o9, { ...o, ...r, ref: t });
    }
  );
  m9.displayName = Mie;
  function h9(e) {
    return e ? "open" : "closed";
  }
  var g9 = i9, v9 = u9, y9 = c9, b9 = d9, Rie = m9;
  const rm = {
    aliceblue: [240, 248, 255],
    antiquewhite: [250, 235, 215],
    aqua: [0, 255, 255],
    aquamarine: [127, 255, 212],
    azure: [240, 255, 255],
    beige: [245, 245, 220],
    bisque: [255, 228, 196],
    black: [0, 0, 0],
    blanchedalmond: [255, 235, 205],
    blue: [0, 0, 255],
    blueviolet: [138, 43, 226],
    brown: [165, 42, 42],
    burlywood: [222, 184, 135],
    cadetblue: [95, 158, 160],
    chartreuse: [127, 255, 0],
    chocolate: [210, 105, 30],
    coral: [255, 127, 80],
    cornflowerblue: [100, 149, 237],
    cornsilk: [255, 248, 220],
    crimson: [220, 20, 60],
    cyan: [0, 255, 255],
    darkblue: [0, 0, 139],
    darkcyan: [0, 139, 139],
    darkgoldenrod: [184, 134, 11],
    darkgray: [169, 169, 169],
    darkgreen: [0, 100, 0],
    darkgrey: [169, 169, 169],
    darkkhaki: [189, 183, 107],
    darkmagenta: [139, 0, 139],
    darkolivegreen: [85, 107, 47],
    darkorange: [255, 140, 0],
    darkorchid: [153, 50, 204],
    darkred: [139, 0, 0],
    darksalmon: [233, 150, 122],
    darkseagreen: [143, 188, 143],
    darkslateblue: [72, 61, 139],
    darkslategray: [47, 79, 79],
    darkslategrey: [47, 79, 79],
    darkturquoise: [0, 206, 209],
    darkviolet: [148, 0, 211],
    deeppink: [255, 20, 147],
    deepskyblue: [0, 191, 255],
    dimgray: [105, 105, 105],
    dimgrey: [105, 105, 105],
    dodgerblue: [30, 144, 255],
    firebrick: [178, 34, 34],
    floralwhite: [255, 250, 240],
    forestgreen: [34, 139, 34],
    fuchsia: [255, 0, 255],
    gainsboro: [220, 220, 220],
    ghostwhite: [248, 248, 255],
    gold: [255, 215, 0],
    goldenrod: [218, 165, 32],
    gray: [128, 128, 128],
    green: [0, 128, 0],
    greenyellow: [173, 255, 47],
    grey: [128, 128, 128],
    honeydew: [240, 255, 240],
    hotpink: [255, 105, 180],
    indianred: [205, 92, 92],
    indigo: [75, 0, 130],
    ivory: [255, 255, 240],
    khaki: [240, 230, 140],
    lavender: [230, 230, 250],
    lavenderblush: [255, 240, 245],
    lawngreen: [124, 252, 0],
    lemonchiffon: [255, 250, 205],
    lightblue: [173, 216, 230],
    lightcoral: [240, 128, 128],
    lightcyan: [224, 255, 255],
    lightgoldenrodyellow: [250, 250, 210],
    lightgray: [211, 211, 211],
    lightgreen: [144, 238, 144],
    lightgrey: [211, 211, 211],
    lightpink: [255, 182, 193],
    lightsalmon: [255, 160, 122],
    lightseagreen: [32, 178, 170],
    lightskyblue: [135, 206, 250],
    lightslategray: [119, 136, 153],
    lightslategrey: [119, 136, 153],
    lightsteelblue: [176, 196, 222],
    lightyellow: [255, 255, 224],
    lime: [0, 255, 0],
    limegreen: [50, 205, 50],
    linen: [250, 240, 230],
    magenta: [255, 0, 255],
    maroon: [128, 0, 0],
    mediumaquamarine: [102, 205, 170],
    mediumblue: [0, 0, 205],
    mediumorchid: [186, 85, 211],
    mediumpurple: [147, 112, 219],
    mediumseagreen: [60, 179, 113],
    mediumslateblue: [123, 104, 238],
    mediumspringgreen: [0, 250, 154],
    mediumturquoise: [72, 209, 204],
    mediumvioletred: [199, 21, 133],
    midnightblue: [25, 25, 112],
    mintcream: [245, 255, 250],
    mistyrose: [255, 228, 225],
    moccasin: [255, 228, 181],
    navajowhite: [255, 222, 173],
    navy: [0, 0, 128],
    oldlace: [253, 245, 230],
    olive: [128, 128, 0],
    olivedrab: [107, 142, 35],
    orange: [255, 165, 0],
    orangered: [255, 69, 0],
    orchid: [218, 112, 214],
    palegoldenrod: [238, 232, 170],
    palegreen: [152, 251, 152],
    paleturquoise: [175, 238, 238],
    palevioletred: [219, 112, 147],
    papayawhip: [255, 239, 213],
    peachpuff: [255, 218, 185],
    peru: [205, 133, 63],
    pink: [255, 192, 203],
    plum: [221, 160, 221],
    powderblue: [176, 224, 230],
    purple: [128, 0, 128],
    rebeccapurple: [102, 51, 153],
    red: [255, 0, 0],
    rosybrown: [188, 143, 143],
    royalblue: [65, 105, 225],
    saddlebrown: [139, 69, 19],
    salmon: [250, 128, 114],
    sandybrown: [244, 164, 96],
    seagreen: [46, 139, 87],
    seashell: [255, 245, 238],
    sienna: [160, 82, 45],
    silver: [192, 192, 192],
    skyblue: [135, 206, 235],
    slateblue: [106, 90, 205],
    slategray: [112, 128, 144],
    slategrey: [112, 128, 144],
    snow: [255, 250, 250],
    springgreen: [0, 255, 127],
    steelblue: [70, 130, 180],
    tan: [210, 180, 140],
    teal: [0, 128, 128],
    thistle: [216, 191, 216],
    tomato: [255, 99, 71],
    turquoise: [64, 224, 208],
    violet: [238, 130, 238],
    wheat: [245, 222, 179],
    white: [255, 255, 255],
    whitesmoke: [245, 245, 245],
    yellow: [255, 255, 0],
    yellowgreen: [154, 205, 50]
  }, w9 = {};
  for (const e of Object.keys(rm))
    w9[rm[e]] = e;
  const Ie = {
    rgb: { channels: 3, labels: "rgb" },
    hsl: { channels: 3, labels: "hsl" },
    hsv: { channels: 3, labels: "hsv" },
    hwb: { channels: 3, labels: "hwb" },
    cmyk: { channels: 4, labels: "cmyk" },
    xyz: { channels: 3, labels: "xyz" },
    lab: { channels: 3, labels: "lab" },
    oklab: { channels: 3, labels: ["okl", "oka", "okb"] },
    lch: { channels: 3, labels: "lch" },
    oklch: { channels: 3, labels: ["okl", "okc", "okh"] },
    hex: { channels: 1, labels: ["hex"] },
    keyword: { channels: 1, labels: ["keyword"] },
    ansi16: { channels: 1, labels: ["ansi16"] },
    ansi256: { channels: 1, labels: ["ansi256"] },
    hcg: { channels: 3, labels: ["h", "c", "g"] },
    apple: { channels: 3, labels: ["r16", "g16", "b16"] },
    gray: { channels: 1, labels: ["gray"] }
  }, Fi = (6 / 29) ** 3;
  function od(e) {
    const t = e > 31308e-7 ? 1.055 * e ** 0.4166666666666667 - 0.055 : e * 12.92;
    return Math.min(Math.max(0, t), 1);
  }
  function ad(e) {
    return e > 0.04045 ? ((e + 0.055) / 1.055) ** 2.4 : e / 12.92;
  }
  for (const e of Object.keys(Ie)) {
    if (!("channels" in Ie[e]))
      throw new Error("missing channels property: " + e);
    if (!("labels" in Ie[e]))
      throw new Error("missing channel labels property: " + e);
    if (Ie[e].labels.length !== Ie[e].channels)
      throw new Error("channel and label counts mismatch: " + e);
    const { channels: t, labels: n } = Ie[e];
    delete Ie[e].channels, delete Ie[e].labels, Object.defineProperty(Ie[e], "channels", { value: t }), Object.defineProperty(Ie[e], "labels", { value: n });
  }
  Ie.rgb.hsl = function(e) {
    const t = e[0] / 255, n = e[1] / 255, r = e[2] / 255, o = Math.min(t, n, r), a = Math.max(t, n, r), i = a - o;
    let s, u;
    switch (a) {
      case o: {
        s = 0;
        break;
      }
      case t: {
        s = (n - r) / i;
        break;
      }
      case n: {
        s = 2 + (r - t) / i;
        break;
      }
      case r: {
        s = 4 + (t - n) / i;
        break;
      }
    }
    s = Math.min(s * 60, 360), s < 0 && (s += 360);
    const c = (o + a) / 2;
    return a === o ? u = 0 : c <= 0.5 ? u = i / (a + o) : u = i / (2 - a - o), [s, u * 100, c * 100];
  };
  Ie.rgb.hsv = function(e) {
    let t, n, r, o, a;
    const i = e[0] / 255, s = e[1] / 255, u = e[2] / 255, c = Math.max(i, s, u), f = c - Math.min(i, s, u), p = function(g) {
      return (c - g) / 6 / f + 1 / 2;
    };
    if (f === 0)
      o = 0, a = 0;
    else {
      switch (a = f / c, t = p(i), n = p(s), r = p(u), c) {
        case i: {
          o = r - n;
          break;
        }
        case s: {
          o = 1 / 3 + t - r;
          break;
        }
        case u: {
          o = 2 / 3 + n - t;
          break;
        }
      }
      o < 0 ? o += 1 : o > 1 && (o -= 1);
    }
    return [
      o * 360,
      a * 100,
      c * 100
    ];
  };
  Ie.rgb.hwb = function(e) {
    const t = e[0], n = e[1];
    let r = e[2];
    const o = Ie.rgb.hsl(e)[0], a = 1 / 255 * Math.min(t, Math.min(n, r));
    return r = 1 - 1 / 255 * Math.max(t, Math.max(n, r)), [o, a * 100, r * 100];
  };
  Ie.rgb.oklab = function(e) {
    const t = ad(e[0] / 255), n = ad(e[1] / 255), r = ad(e[2] / 255), o = Math.cbrt(0.4122214708 * t + 0.5363325363 * n + 0.0514459929 * r), a = Math.cbrt(0.2119034982 * t + 0.6806995451 * n + 0.1073969566 * r), i = Math.cbrt(0.0883024619 * t + 0.2817188376 * n + 0.6299787005 * r), s = 0.2104542553 * o + 0.793617785 * a - 0.0040720468 * i, u = 1.9779984951 * o - 2.428592205 * a + 0.4505937099 * i, c = 0.0259040371 * o + 0.7827717662 * a - 0.808675766 * i;
    return [s * 100, u * 100, c * 100];
  };
  Ie.rgb.cmyk = function(e) {
    const t = e[0] / 255, n = e[1] / 255, r = e[2] / 255, o = Math.min(1 - t, 1 - n, 1 - r), a = (1 - t - o) / (1 - o) || 0, i = (1 - n - o) / (1 - o) || 0, s = (1 - r - o) / (1 - o) || 0;
    return [a * 100, i * 100, s * 100, o * 100];
  };
  function jie(e, t) {
    return (e[0] - t[0]) ** 2 + (e[1] - t[1]) ** 2 + (e[2] - t[2]) ** 2;
  }
  Ie.rgb.keyword = function(e) {
    const t = w9[e];
    if (t)
      return t;
    let n = Number.POSITIVE_INFINITY, r;
    for (const o of Object.keys(rm)) {
      const a = rm[o], i = jie(e, a);
      i < n && (n = i, r = o);
    }
    return r;
  };
  Ie.keyword.rgb = function(e) {
    return [...rm[e]];
  };
  Ie.rgb.xyz = function(e) {
    const t = ad(e[0] / 255), n = ad(e[1] / 255), r = ad(e[2] / 255), o = t * 0.4124564 + n * 0.3575761 + r * 0.1804375, a = t * 0.2126729 + n * 0.7151522 + r * 0.072175, i = t * 0.0193339 + n * 0.119192 + r * 0.9503041;
    return [o * 100, a * 100, i * 100];
  };
  Ie.rgb.lab = function(e) {
    const t = Ie.rgb.xyz(e);
    let n = t[0], r = t[1], o = t[2];
    n /= 95.047, r /= 100, o /= 108.883, n = n > Fi ? n ** (1 / 3) : 7.787 * n + 16 / 116, r = r > Fi ? r ** (1 / 3) : 7.787 * r + 16 / 116, o = o > Fi ? o ** (1 / 3) : 7.787 * o + 16 / 116;
    const a = 116 * r - 16, i = 500 * (n - r), s = 200 * (r - o);
    return [a, i, s];
  };
  Ie.hsl.rgb = function(e) {
    const t = e[0] / 360, n = e[1] / 100, r = e[2] / 100;
    let o, a;
    if (n === 0)
      return a = r * 255, [a, a, a];
    const i = r < 0.5 ? r * (1 + n) : r + n - r * n, s = 2 * r - i, u = [0, 0, 0];
    for (let c = 0; c < 3; c++)
      o = t + 1 / 3 * -(c - 1), o < 0 && o++, o > 1 && o--, 6 * o < 1 ? a = s + (i - s) * 6 * o : 2 * o < 1 ? a = i : 3 * o < 2 ? a = s + (i - s) * (2 / 3 - o) * 6 : a = s, u[c] = a * 255;
    return u;
  };
  Ie.hsl.hsv = function(e) {
    const t = e[0];
    let n = e[1] / 100, r = e[2] / 100, o = n;
    const a = Math.max(r, 0.01);
    r *= 2, n *= r <= 1 ? r : 2 - r, o *= a <= 1 ? a : 2 - a;
    const i = (r + n) / 2, s = r === 0 ? 2 * o / (a + o) : 2 * n / (r + n);
    return [t, s * 100, i * 100];
  };
  Ie.hsv.rgb = function(e) {
    const t = e[0] / 60, n = e[1] / 100;
    let r = e[2] / 100;
    const o = Math.floor(t) % 6, a = t - Math.floor(t), i = 255 * r * (1 - n), s = 255 * r * (1 - n * a), u = 255 * r * (1 - n * (1 - a));
    switch (r *= 255, o) {
      case 0:
        return [r, u, i];
      case 1:
        return [s, r, i];
      case 2:
        return [i, r, u];
      case 3:
        return [i, s, r];
      case 4:
        return [u, i, r];
      case 5:
        return [r, i, s];
    }
  };
  Ie.hsv.hsl = function(e) {
    const t = e[0], n = e[1] / 100, r = e[2] / 100, o = Math.max(r, 0.01);
    let a, i;
    i = (2 - n) * r;
    const s = (2 - n) * o;
    return a = n * o, a /= s <= 1 ? s : 2 - s, a = a || 0, i /= 2, [t, a * 100, i * 100];
  };
  Ie.hwb.rgb = function(e) {
    const t = e[0] / 360;
    let n = e[1] / 100, r = e[2] / 100;
    const o = n + r;
    let a;
    o > 1 && (n /= o, r /= o);
    const i = Math.floor(6 * t), s = 1 - r;
    a = 6 * t - i, (i & 1) !== 0 && (a = 1 - a);
    const u = n + a * (s - n);
    let c, f, p;
    switch (i) {
      default:
      case 6:
      case 0: {
        c = s, f = u, p = n;
        break;
      }
      case 1: {
        c = u, f = s, p = n;
        break;
      }
      case 2: {
        c = n, f = s, p = u;
        break;
      }
      case 3: {
        c = n, f = u, p = s;
        break;
      }
      case 4: {
        c = u, f = n, p = s;
        break;
      }
      case 5: {
        c = s, f = n, p = u;
        break;
      }
    }
    return [c * 255, f * 255, p * 255];
  };
  Ie.cmyk.rgb = function(e) {
    const t = e[0] / 100, n = e[1] / 100, r = e[2] / 100, o = e[3] / 100, a = 1 - Math.min(1, t * (1 - o) + o), i = 1 - Math.min(1, n * (1 - o) + o), s = 1 - Math.min(1, r * (1 - o) + o);
    return [a * 255, i * 255, s * 255];
  };
  Ie.xyz.rgb = function(e) {
    const t = e[0] / 100, n = e[1] / 100, r = e[2] / 100;
    let o, a, i;
    return o = t * 3.2404542 + n * -1.5371385 + r * -0.4985314, a = t * -0.969266 + n * 1.8760108 + r * 0.041556, i = t * 0.0556434 + n * -0.2040259 + r * 1.0572252, o = od(o), a = od(a), i = od(i), [o * 255, a * 255, i * 255];
  };
  Ie.xyz.lab = function(e) {
    let t = e[0], n = e[1], r = e[2];
    t /= 95.047, n /= 100, r /= 108.883, t = t > Fi ? t ** (1 / 3) : 7.787 * t + 16 / 116, n = n > Fi ? n ** (1 / 3) : 7.787 * n + 16 / 116, r = r > Fi ? r ** (1 / 3) : 7.787 * r + 16 / 116;
    const o = 116 * n - 16, a = 500 * (t - n), i = 200 * (n - r);
    return [o, a, i];
  };
  Ie.xyz.oklab = function(e) {
    const t = e[0] / 100, n = e[1] / 100, r = e[2] / 100, o = Math.cbrt(0.8189330101 * t + 0.3618667424 * n - 0.1288597137 * r), a = Math.cbrt(0.0329845436 * t + 0.9293118715 * n + 0.0361456387 * r), i = Math.cbrt(0.0482003018 * t + 0.2643662691 * n + 0.633851707 * r), s = 0.2104542553 * o + 0.793617785 * a - 0.0040720468 * i, u = 1.9779984951 * o - 2.428592205 * a + 0.4505937099 * i, c = 0.0259040371 * o + 0.7827717662 * a - 0.808675766 * i;
    return [s * 100, u * 100, c * 100];
  };
  Ie.oklab.oklch = function(e) {
    return Ie.lab.lch(e);
  };
  Ie.oklab.xyz = function(e) {
    const t = e[0] / 100, n = e[1] / 100, r = e[2] / 100, o = (0.999999998 * t + 0.396337792 * n + 0.215803758 * r) ** 3, a = (1.000000008 * t - 0.105561342 * n - 0.063854175 * r) ** 3, i = (1.000000055 * t - 0.089484182 * n - 1.291485538 * r) ** 3, s = 1.227013851 * o - 0.55779998 * a + 0.281256149 * i, u = -0.040580178 * o + 1.11225687 * a - 0.071676679 * i, c = -0.076381285 * o - 0.421481978 * a + 1.58616322 * i;
    return [s * 100, u * 100, c * 100];
  };
  Ie.oklab.rgb = function(e) {
    const t = e[0] / 100, n = e[1] / 100, r = e[2] / 100, o = (t + 0.3963377774 * n + 0.2158037573 * r) ** 3, a = (t - 0.1055613458 * n - 0.0638541728 * r) ** 3, i = (t - 0.0894841775 * n - 1.291485548 * r) ** 3, s = od(4.0767416621 * o - 3.3077115913 * a + 0.2309699292 * i), u = od(-1.2684380046 * o + 2.6097574011 * a - 0.3413193965 * i), c = od(-0.0041960863 * o - 0.7034186147 * a + 1.707614701 * i);
    return [s * 255, u * 255, c * 255];
  };
  Ie.oklch.oklab = function(e) {
    return Ie.lch.lab(e);
  };
  Ie.lab.xyz = function(e) {
    const t = e[0], n = e[1], r = e[2];
    let o, a, i;
    a = (t + 16) / 116, o = n / 500 + a, i = a - r / 200;
    const s = a ** 3, u = o ** 3, c = i ** 3;
    return a = s > Fi ? s : (a - 16 / 116) / 7.787, o = u > Fi ? u : (o - 16 / 116) / 7.787, i = c > Fi ? c : (i - 16 / 116) / 7.787, o *= 95.047, a *= 100, i *= 108.883, [o, a, i];
  };
  Ie.lab.lch = function(e) {
    const t = e[0], n = e[1], r = e[2];
    let o;
    o = Math.atan2(r, n) * 360 / 2 / Math.PI, o < 0 && (o += 360);
    const a = Math.sqrt(n * n + r * r);
    return [t, a, o];
  };
  Ie.lch.lab = function(e) {
    const t = e[0], n = e[1], r = e[2] / 360 * 2 * Math.PI, o = n * Math.cos(r), a = n * Math.sin(r);
    return [t, o, a];
  };
  Ie.rgb.ansi16 = function(e, t = null) {
    const [n, r, o] = e;
    let a = t === null ? Ie.rgb.hsv(e)[2] : t;
    if (a = Math.round(a / 50), a === 0)
      return 30;
    let i = 30 + (Math.round(o / 255) << 2 | Math.round(r / 255) << 1 | Math.round(n / 255));
    return a === 2 && (i += 60), i;
  };
  Ie.hsv.ansi16 = function(e) {
    return Ie.rgb.ansi16(Ie.hsv.rgb(e), e[2]);
  };
  Ie.rgb.ansi256 = function(e) {
    const t = e[0], n = e[1], r = e[2];
    return t >> 4 === n >> 4 && n >> 4 === r >> 4 ? t < 8 ? 16 : t > 248 ? 231 : Math.round((t - 8) / 247 * 24) + 232 : 16 + 36 * Math.round(t / 255 * 5) + 6 * Math.round(n / 255 * 5) + Math.round(r / 255 * 5);
  };
  Ie.ansi16.rgb = function(e) {
    e = e[0];
    let t = e % 10;
    if (t === 0 || t === 7)
      return e > 50 && (t += 3.5), t = t / 10.5 * 255, [t, t, t];
    const n = (Math.trunc(e > 50) + 1) * 0.5, r = (t & 1) * n * 255, o = (t >> 1 & 1) * n * 255, a = (t >> 2 & 1) * n * 255;
    return [r, o, a];
  };
  Ie.ansi256.rgb = function(e) {
    if (e = e[0], e >= 232) {
      const a = (e - 232) * 10 + 8;
      return [a, a, a];
    }
    e -= 16;
    let t;
    const n = Math.floor(e / 36) / 5 * 255, r = Math.floor((t = e % 36) / 6) / 5 * 255, o = t % 6 / 5 * 255;
    return [n, r, o];
  };
  Ie.rgb.hex = function(e) {
    const t = (((Math.round(e[0]) & 255) << 16) + ((Math.round(e[1]) & 255) << 8) + (Math.round(e[2]) & 255)).toString(16).toUpperCase();
    return "000000".slice(t.length) + t;
  };
  Ie.hex.rgb = function(e) {
    const t = e.toString(16).match(/[a-f\d]{6}|[a-f\d]{3}/i);
    if (!t)
      return [0, 0, 0];
    let n = t[0];
    t[0].length === 3 && (n = [...n].map((s) => s + s).join(""));
    const r = Number.parseInt(n, 16), o = r >> 16 & 255, a = r >> 8 & 255, i = r & 255;
    return [o, a, i];
  };
  Ie.rgb.hcg = function(e) {
    const t = e[0] / 255, n = e[1] / 255, r = e[2] / 255, o = Math.max(Math.max(t, n), r), a = Math.min(Math.min(t, n), r), i = o - a;
    let s;
    const u = i < 1 ? a / (1 - i) : 0;
    return i <= 0 ? s = 0 : o === t ? s = (n - r) / i % 6 : o === n ? s = 2 + (r - t) / i : s = 4 + (t - n) / i, s /= 6, s %= 1, [s * 360, i * 100, u * 100];
  };
  Ie.hsl.hcg = function(e) {
    const t = e[1] / 100, n = e[2] / 100, r = n < 0.5 ? 2 * t * n : 2 * t * (1 - n);
    let o = 0;
    return r < 1 && (o = (n - 0.5 * r) / (1 - r)), [e[0], r * 100, o * 100];
  };
  Ie.hsv.hcg = function(e) {
    const t = e[1] / 100, n = e[2] / 100, r = t * n;
    let o = 0;
    return r < 1 && (o = (n - r) / (1 - r)), [e[0], r * 100, o * 100];
  };
  Ie.hcg.rgb = function(e) {
    const t = e[0] / 360, n = e[1] / 100, r = e[2] / 100;
    if (n === 0)
      return [r * 255, r * 255, r * 255];
    const o = [0, 0, 0], a = t % 1 * 6, i = a % 1, s = 1 - i;
    let u = 0;
    switch (Math.floor(a)) {
      case 0: {
        o[0] = 1, o[1] = i, o[2] = 0;
        break;
      }
      case 1: {
        o[0] = s, o[1] = 1, o[2] = 0;
        break;
      }
      case 2: {
        o[0] = 0, o[1] = 1, o[2] = i;
        break;
      }
      case 3: {
        o[0] = 0, o[1] = s, o[2] = 1;
        break;
      }
      case 4: {
        o[0] = i, o[1] = 0, o[2] = 1;
        break;
      }
      default:
        o[0] = 1, o[1] = 0, o[2] = s;
    }
    return u = (1 - n) * r, [
      (n * o[0] + u) * 255,
      (n * o[1] + u) * 255,
      (n * o[2] + u) * 255
    ];
  };
  Ie.hcg.hsv = function(e) {
    const t = e[1] / 100, n = e[2] / 100, r = t + n * (1 - t);
    let o = 0;
    return r > 0 && (o = t / r), [e[0], o * 100, r * 100];
  };
  Ie.hcg.hsl = function(e) {
    const t = e[1] / 100, n = e[2] / 100 * (1 - t) + 0.5 * t;
    let r = 0;
    return n > 0 && n < 0.5 ? r = t / (2 * n) : n >= 0.5 && n < 1 && (r = t / (2 * (1 - n))), [e[0], r * 100, n * 100];
  };
  Ie.hcg.hwb = function(e) {
    const t = e[1] / 100, n = e[2] / 100, r = t + n * (1 - t);
    return [e[0], (r - t) * 100, (1 - r) * 100];
  };
  Ie.hwb.hcg = function(e) {
    const t = e[1] / 100, n = 1 - e[2] / 100, r = n - t;
    let o = 0;
    return r < 1 && (o = (n - r) / (1 - r)), [e[0], r * 100, o * 100];
  };
  Ie.apple.rgb = function(e) {
    return [e[0] / 65535 * 255, e[1] / 65535 * 255, e[2] / 65535 * 255];
  };
  Ie.rgb.apple = function(e) {
    return [e[0] / 255 * 65535, e[1] / 255 * 65535, e[2] / 255 * 65535];
  };
  Ie.gray.rgb = function(e) {
    return [e[0] / 100 * 255, e[0] / 100 * 255, e[0] / 100 * 255];
  };
  Ie.gray.hsl = function(e) {
    return [0, 0, e[0]];
  };
  Ie.gray.hsv = Ie.gray.hsl;
  Ie.gray.hwb = function(e) {
    return [0, 100, e[0]];
  };
  Ie.gray.cmyk = function(e) {
    return [0, 0, 0, e[0]];
  };
  Ie.gray.lab = function(e) {
    return [e[0], 0, 0];
  };
  Ie.gray.hex = function(e) {
    const t = Math.round(e[0] / 100 * 255) & 255, n = ((t << 16) + (t << 8) + t).toString(16).toUpperCase();
    return "000000".slice(n.length) + n;
  };
  Ie.rgb.gray = function(e) {
    return [(e[0] + e[1] + e[2]) / 3 / 255 * 100];
  };
  function Iie() {
    const e = {}, t = Object.keys(Ie);
    for (let { length: n } = t, r = 0; r < n; r++)
      e[t[r]] = {
        // http://jsperf.com/1-vs-infinity
        // micro-opt, but this is simple.
        distance: -1,
        parent: null
      };
    return e;
  }
  function Aie(e) {
    const t = Iie(), n = [e];
    for (t[e].distance = 0; n.length > 0; ) {
      const r = n.pop(), o = Object.keys(Ie[r]);
      for (let { length: a } = o, i = 0; i < a; i++) {
        const s = o[i], u = t[s];
        u.distance === -1 && (u.distance = t[r].distance + 1, u.parent = r, n.unshift(s));
      }
    }
    return t;
  }
  function $ie(e, t) {
    return function(n) {
      return t(e(n));
    };
  }
  function Die(e, t) {
    const n = [t[e].parent, e];
    let r = Ie[t[e].parent][e], o = t[e].parent;
    for (; t[o].parent; )
      n.unshift(t[o].parent), r = $ie(Ie[t[o].parent][o], r), o = t[o].parent;
    return r.conversion = n, r;
  }
  function Lie(e) {
    const t = Aie(e), n = {}, r = Object.keys(t);
    for (let { length: o } = r, a = 0; a < o; a++) {
      const i = r[a];
      t[i].parent !== null && (n[i] = Die(i, t));
    }
    return n;
  }
  const Jl = {}, Fie = Object.keys(Ie);
  function Tie(e) {
    const t = function(...n) {
      const r = n[0];
      return r == null ? r : (r.length > 1 && (n = r), e(n));
    };
    return "conversion" in e && (t.conversion = e.conversion), t;
  }
  function zie(e) {
    const t = function(...n) {
      const r = n[0];
      if (r == null)
        return r;
      r.length > 1 && (n = r);
      const o = e(n);
      if (typeof o == "object")
        for (let { length: a } = o, i = 0; i < a; i++)
          o[i] = Math.round(o[i]);
      return o;
    };
    return "conversion" in e && (t.conversion = e.conversion), t;
  }
  for (const e of Fie) {
    Jl[e] = {}, Object.defineProperty(Jl[e], "channels", { value: Ie[e].channels }), Object.defineProperty(Jl[e], "labels", { value: Ie[e].labels });
    const t = Lie(e), n = Object.keys(t);
    for (const r of n) {
      const o = t[r];
      Jl[e][r] = zie(o), Jl[e][r].raw = Tie(o);
    }
  }
  const Bie = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    default: Jl
  }, Symbol.toStringTag, { value: "Module" })), gr = (e, t) => {
    const n = Array.isArray(t) ? t : [t];
    if (n[0] === void 0 || n[0] === null)
      return gr("rgb", [0, 0, 0]);
    const r = Jl[e];
    if (!r)
      throw new Error(
        `Unsupported color type: ${e} allowed are ${Object.keys(Bie).join(
          ", "
        )}`
      );
    r[e] = () => n;
    const o = (i) => {
      const s = i(...n);
      return Array.isArray(s) ? s[0] != null : s;
    };
    if (!o(r.rgb) || !o(r.hsl))
      return gr("rgb", [0, 0, 0]);
    const a = {};
    return Object.keys(r).forEach((i) => {
      const s = r[i];
      typeof s == "function" && (a[i] = () => i === e ? n : s(...n));
    }), a;
  }, Vie = ({
    onChange: e,
    colorconverter: t,
    allow_null: n = !1
  }) => {
    if (t === null && !n)
      throw new Error("Color converter is null");
    const [r, o] = C.useState(t), [a, i] = C.useState([0, 0, 0]), [s, u] = C.useState([0, 0, 0]), [c, f] = C.useState([0, 0, 0]), [p, g] = C.useState("000");
    C.useEffect(() => {
      if (!r) {
        if (!n) throw new Error("Color converter is null");
        u([0, 0, 0]), i([0, 0, 0]), f([0, 0, 0]), g("");
        return;
      }
      i(r.hsl()), u(r.rgb()), f(r.hsv()), g(r.hex());
    }, [r]);
    const h = {
      backgroundColor: `hsl(${a[0]}, ${a[1]}%, ${a[2]}%)`,
      padding: "10px",
      margin: "10px 0"
    };
    return /* @__PURE__ */ S.jsxs("div", { style: { backgroundColor: "white" }, children: [
      /* @__PURE__ */ S.jsx("div", { style: h, children: "Color Preview" }),
      /* @__PURE__ */ S.jsxs("div", { className: "colorspace", children: [
        /* @__PURE__ */ S.jsx("div", { className: "colorspace_title", children: "RGB" }),
        /* @__PURE__ */ S.jsx("div", {}),
        /* @__PURE__ */ S.jsx("label", { children: "Red" }),
        /* @__PURE__ */ S.jsx(
          "input",
          {
            type: "range",
            min: "0",
            max: "255",
            value: s[0],
            onChange: (y) => {
              const b = [parseInt(y.target.value), s[1], s[2]], v = gr("rgb", b);
              o(v), e(v);
            },
            style: { background: "linear-gradient(to right, #000, #f00)" }
          }
        ),
        /* @__PURE__ */ S.jsx("label", { children: "Green" }),
        /* @__PURE__ */ S.jsx(
          "input",
          {
            type: "range",
            min: "0",
            max: "255",
            value: s[1],
            onChange: (y) => {
              const b = [s[0], parseInt(y.target.value), s[2]], v = gr("rgb", b);
              o(v), e(v);
            },
            style: { background: "linear-gradient(to right, #000, #0f0)" }
          }
        ),
        /* @__PURE__ */ S.jsx("label", { children: "Blue" }),
        /* @__PURE__ */ S.jsx(
          "input",
          {
            type: "range",
            min: "0",
            max: "255",
            value: s[2],
            onChange: (y) => {
              const b = [s[0], s[1], parseInt(y.target.value)], v = gr("rgb", b);
              o(v), e(v);
            },
            style: { background: "linear-gradient(to right, #000, #00f)" }
          }
        )
      ] }),
      /* @__PURE__ */ S.jsxs("div", { className: "colorspace", children: [
        /* @__PURE__ */ S.jsx("div", { className: "colorspace_title", children: "HSL" }),
        /* @__PURE__ */ S.jsx("div", {}),
        /* @__PURE__ */ S.jsx("label", { children: "Hue" }),
        /* @__PURE__ */ S.jsx(
          "input",
          {
            type: "range",
            min: "0",
            max: "360",
            value: a[0],
            onChange: (y) => {
              const b = [parseInt(y.target.value), a[1], a[2]], v = gr("hsl", b);
              o(v), e(v);
            },
            style: {
              background: "linear-gradient(to right, #f00, #ff0, #0f0, #0ff, #00f, #f0f, #f00)"
            }
          }
        ),
        /* @__PURE__ */ S.jsx("label", { children: "Saturation" }),
        /* @__PURE__ */ S.jsx(
          "input",
          {
            type: "range",
            min: "0",
            max: "100",
            value: a[1],
            onChange: (y) => {
              const b = [a[0], parseInt(y.target.value), a[2]], v = gr("hsl", b);
              o(v), e(v);
            },
            style: {
              background: `linear-gradient(to right, #fff, hsl(${a[0]}, 100%, 50%))`
            }
          }
        ),
        /* @__PURE__ */ S.jsx("label", { children: "Lightness" }),
        /* @__PURE__ */ S.jsx(
          "input",
          {
            type: "range",
            min: "0",
            max: "100",
            value: a[2],
            onChange: (y) => {
              const b = [a[0], a[1], parseInt(y.target.value)], v = gr("hsl", b);
              o(v), e(v);
            },
            style: {
              background: `linear-gradient(to right, #000, hsl(${a[0]}, 100%, 50%), #fff)`
            }
          }
        )
      ] }),
      /* @__PURE__ */ S.jsxs("div", { className: "colorspace", children: [
        /* @__PURE__ */ S.jsx("div", { className: "colorspace_title", children: "HSV" }),
        /* @__PURE__ */ S.jsx("div", {}),
        /* @__PURE__ */ S.jsx("label", { children: "Hue" }),
        /* @__PURE__ */ S.jsx(
          "input",
          {
            type: "range",
            min: "0",
            max: "360",
            value: c[0],
            onChange: (y) => {
              const b = [parseInt(y.target.value), c[1], c[2]], v = gr("hsv", b);
              o(v), e(v);
            },
            style: {
              background: "linear-gradient(to right, #f00, #ff0, #0f0, #0ff, #00f, #f0f, #f00)"
            }
          }
        ),
        /* @__PURE__ */ S.jsx("label", { children: "Saturation" }),
        /* @__PURE__ */ S.jsx(
          "input",
          {
            type: "range",
            min: "0",
            max: "100",
            value: c[1],
            onChange: (y) => {
              const b = [c[0], parseInt(y.target.value), c[2]], v = gr("hsv", b);
              o(v), e(v);
            },
            style: {
              background: `linear-gradient(to right, #fff, hsl(${a[0]}, 100%, 50%))`
            }
          }
        ),
        /* @__PURE__ */ S.jsx("label", { children: "Value" }),
        /* @__PURE__ */ S.jsx(
          "input",
          {
            type: "range",
            min: "0",
            max: "100",
            value: c[2],
            onChange: (y) => {
              const b = [c[0], c[1], parseInt(y.target.value)], v = gr("hsv", b);
              o(v), e(v);
            },
            style: {
              background: `linear-gradient(to right, #000, hsl(${a[0]}, 100%, 50%))`
            }
          }
        )
      ] }),
      /* @__PURE__ */ S.jsxs("div", { className: "colorspace", children: [
        /* @__PURE__ */ S.jsx("div", { className: "colorspace_title", children: "HEX" }),
        /* @__PURE__ */ S.jsx("div", {}),
        /* @__PURE__ */ S.jsx(
          "input",
          {
            type: "text",
            value: p,
            onChange: (y) => {
              const b = y.target.value === "" ? null : gr("hex", [y.target.value]);
              o(b), e(b);
            }
          }
        )
      ] })
    ] });
  }, Uie = ({
    inicolordata: e,
    inicolorspace: t,
    allow_null: n = !1,
    delay: r = 1e3,
    onChange: o,
    portalContainer: a
  }) => {
    const i = e !== void 0 ? e : [0, 0, 0], s = e === void 0 ? "rgb" : t || "hex", u = Array.isArray(i) ? i : [i], c = C.useMemo(() => {
      let b = gr(s, u);
      return b.rgb() === void 0 && (b = gr("rgb", [0, 0, 0])), b;
    }, [s, u]), [f, p] = C.useState(c);
    C.useEffect(() => {
      const b = e !== void 0 ? e : [0, 0, 0], v = e === void 0 ? "rgb" : t || "hex", w = Array.isArray(b) ? b : [b];
      let _ = gr(v, w);
      _.rgb() === void 0 && (_ = gr("rgb", [0, 0, 0])), p(_);
    }, [JSON.stringify(e), t]);
    const g = C.useRef(null), h = C.useCallback(
      (b) => {
        if (b === null && !n)
          throw new Error("Color is null");
        b !== null && p(b), g.current && clearTimeout(g.current), o && (g.current = setTimeout(() => {
          o(b), g.current = null;
        }, r));
      },
      [n, o, r]
    );
    C.useEffect(() => () => {
      g.current && clearTimeout(g.current);
    }, []);
    const y = C.useMemo(
      () => ({
        background: "#" + f.hex(),
        borderRadius: "0.3rem",
        width: "2rem",
        height: "1rem"
      }),
      [f]
    );
    return /* @__PURE__ */ S.jsxs(g9, { children: [
      /* @__PURE__ */ S.jsx(v9, { asChild: !0, children: /* @__PURE__ */ S.jsx("button", { style: y }) }),
      /* @__PURE__ */ S.jsx(y9, { container: a, children: /* @__PURE__ */ S.jsx(b9, { side: "left", className: "iotooltipcontent", children: /* @__PURE__ */ S.jsx(
        Vie,
        {
          onChange: h,
          colorconverter: f,
          allow_null: n
        }
      ) }) })
    ] });
  };
  function cu(e) {
    "@babel/helpers - typeof";
    return cu = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
      return typeof t;
    } : function(t) {
      return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
    }, cu(e);
  }
  function Hie(e, t) {
    if (cu(e) != "object" || !e) return e;
    var n = e[Symbol.toPrimitive];
    if (n !== void 0) {
      var r = n.call(e, t);
      if (cu(r) != "object") return r;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (t === "string" ? String : Number)(e);
  }
  function x9(e) {
    var t = Hie(e, "string");
    return cu(t) == "symbol" ? t : t + "";
  }
  function yp(e, t, n) {
    return (t = x9(t)) in e ? Object.defineProperty(e, t, {
      value: n,
      enumerable: !0,
      configurable: !0,
      writable: !0
    }) : e[t] = n, e;
  }
  function hA(e, t) {
    var n = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
      var r = Object.getOwnPropertySymbols(e);
      t && (r = r.filter(function(o) {
        return Object.getOwnPropertyDescriptor(e, o).enumerable;
      })), n.push.apply(n, r);
    }
    return n;
  }
  function Ye(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t] != null ? arguments[t] : {};
      t % 2 ? hA(Object(n), !0).forEach(function(r) {
        yp(e, r, n[r]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : hA(Object(n)).forEach(function(r) {
        Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
      });
    }
    return e;
  }
  function Wie(e) {
    if (Array.isArray(e)) return e;
  }
  function qie(e, t) {
    var n = e == null ? null : typeof Symbol < "u" && e[Symbol.iterator] || e["@@iterator"];
    if (n != null) {
      var r, o, a, i, s = [], u = !0, c = !1;
      try {
        if (a = (n = n.call(e)).next, t === 0) {
          if (Object(n) !== n) return;
          u = !1;
        } else for (; !(u = (r = a.call(n)).done) && (s.push(r.value), s.length !== t); u = !0) ;
      } catch (f) {
        c = !0, o = f;
      } finally {
        try {
          if (!u && n.return != null && (i = n.return(), Object(i) !== i)) return;
        } finally {
          if (c) throw o;
        }
      }
      return s;
    }
  }
  function R2(e, t) {
    (t == null || t > e.length) && (t = e.length);
    for (var n = 0, r = Array(t); n < t; n++) r[n] = e[n];
    return r;
  }
  function k9(e, t) {
    if (e) {
      if (typeof e == "string") return R2(e, t);
      var n = {}.toString.call(e).slice(8, -1);
      return n === "Object" && e.constructor && (n = e.constructor.name), n === "Map" || n === "Set" ? Array.from(e) : n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n) ? R2(e, t) : void 0;
    }
  }
  function Kie() {
    throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
  }
  function Ti(e, t) {
    return Wie(e) || qie(e, t) || k9(e, t) || Kie();
  }
  function es(e, t) {
    if (e == null) return {};
    var n, r, o = yw(e, t);
    if (Object.getOwnPropertySymbols) {
      var a = Object.getOwnPropertySymbols(e);
      for (r = 0; r < a.length; r++) n = a[r], t.indexOf(n) === -1 && {}.propertyIsEnumerable.call(e, n) && (o[n] = e[n]);
    }
    return o;
  }
  var Gie = ["defaultInputValue", "defaultMenuIsOpen", "defaultValue", "inputValue", "menuIsOpen", "onChange", "onInputChange", "onMenuClose", "onMenuOpen", "value"];
  function Xie(e) {
    var t = e.defaultInputValue, n = t === void 0 ? "" : t, r = e.defaultMenuIsOpen, o = r === void 0 ? !1 : r, a = e.defaultValue, i = a === void 0 ? null : a, s = e.inputValue, u = e.menuIsOpen, c = e.onChange, f = e.onInputChange, p = e.onMenuClose, g = e.onMenuOpen, h = e.value, y = es(e, Gie), b = C.useState(s !== void 0 ? s : n), v = Ti(b, 2), w = v[0], _ = v[1], k = C.useState(u !== void 0 ? u : o), E = Ti(k, 2), P = E[0], O = E[1], M = C.useState(h !== void 0 ? h : i), I = Ti(M, 2), A = I[0], D = I[1], F = C.useCallback(function(W, Y) {
      typeof c == "function" && c(W, Y), D(W);
    }, [c]), j = C.useCallback(function(W, Y) {
      var z;
      typeof f == "function" && (z = f(W, Y)), _(z !== void 0 ? z : W);
    }, [f]), U = C.useCallback(function() {
      typeof g == "function" && g(), O(!0);
    }, [g]), $ = C.useCallback(function() {
      typeof p == "function" && p(), O(!1);
    }, [p]), q = s !== void 0 ? s : w, B = u !== void 0 ? u : P, G = h !== void 0 ? h : A;
    return Ye(Ye({}, y), {}, {
      inputValue: q,
      menuIsOpen: B,
      onChange: F,
      onInputChange: j,
      onMenuClose: $,
      onMenuOpen: U,
      value: G
    });
  }
  function Yie(e, t) {
    if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function");
  }
  function gA(e, t) {
    for (var n = 0; n < t.length; n++) {
      var r = t[n];
      r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, x9(r.key), r);
    }
  }
  function Jie(e, t, n) {
    return t && gA(e.prototype, t), n && gA(e, n), Object.defineProperty(e, "prototype", {
      writable: !1
    }), e;
  }
  function Qie(e, t) {
    if (typeof t != "function" && t !== null) throw new TypeError("Super expression must either be null or a function");
    e.prototype = Object.create(t && t.prototype, {
      constructor: {
        value: e,
        writable: !0,
        configurable: !0
      }
    }), Object.defineProperty(e, "prototype", {
      writable: !1
    }), t && nb(e, t);
  }
  function mb(e) {
    return mb = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t) {
      return t.__proto__ || Object.getPrototypeOf(t);
    }, mb(e);
  }
  function S9() {
    try {
      var e = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
      }));
    } catch {
    }
    return (S9 = function() {
      return !!e;
    })();
  }
  function Zie(e, t) {
    if (t && (cu(t) == "object" || typeof t == "function")) return t;
    if (t !== void 0) throw new TypeError("Derived constructors may only return object or undefined");
    return BT(e);
  }
  function ese(e) {
    var t = S9();
    return function() {
      var n, r = mb(e);
      if (t) {
        var o = mb(this).constructor;
        n = Reflect.construct(r, arguments, o);
      } else n = r.apply(this, arguments);
      return Zie(this, n);
    };
  }
  function tse(e) {
    if (Array.isArray(e)) return R2(e);
  }
  function nse(e) {
    if (typeof Symbol < "u" && e[Symbol.iterator] != null || e["@@iterator"] != null) return Array.from(e);
  }
  function rse() {
    throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
  }
  function GC(e) {
    return tse(e) || nse(e) || k9(e) || rse();
  }
  function ose(e, t) {
    return t || (t = e.slice(0)), Object.freeze(Object.defineProperties(e, {
      raw: {
        value: Object.freeze(t)
      }
    }));
  }
  var j2 = C.useLayoutEffect, ase = ["className", "clearValue", "cx", "getStyles", "getClassNames", "getValue", "hasValue", "isMulti", "isRtl", "options", "selectOption", "selectProps", "setValue", "theme"], hb = function() {
  };
  function ise(e, t) {
    return t ? t[0] === "-" ? e + t : e + "__" + t : e;
  }
  function sse(e, t) {
    for (var n = arguments.length, r = new Array(n > 2 ? n - 2 : 0), o = 2; o < n; o++)
      r[o - 2] = arguments[o];
    var a = [].concat(r);
    if (t && e)
      for (var i in t)
        t.hasOwnProperty(i) && t[i] && a.push("".concat(ise(e, i)));
    return a.filter(function(s) {
      return s;
    }).map(function(s) {
      return String(s).trim();
    }).join(" ");
  }
  var vA = function(e) {
    return gse(e) ? e.filter(Boolean) : cu(e) === "object" && e !== null ? [e] : [];
  }, _9 = function(e) {
    e.className, e.clearValue, e.cx, e.getStyles, e.getClassNames, e.getValue, e.hasValue, e.isMulti, e.isRtl, e.options, e.selectOption, e.selectProps, e.setValue, e.theme;
    var t = es(e, ase);
    return Ye({}, t);
  }, Nn = function(e, t, n) {
    var r = e.cx, o = e.getStyles, a = e.getClassNames, i = e.className;
    return {
      css: o(t, e),
      className: r(n ?? {}, a(t, e), i)
    };
  };
  function Dw(e) {
    return [document.documentElement, document.body, window].indexOf(e) > -1;
  }
  function lse(e) {
    return Dw(e) ? window.innerHeight : e.clientHeight;
  }
  function E9(e) {
    return Dw(e) ? window.pageYOffset : e.scrollTop;
  }
  function gb(e, t) {
    if (Dw(e)) {
      window.scrollTo(0, t);
      return;
    }
    e.scrollTop = t;
  }
  function use(e) {
    var t = getComputedStyle(e), n = t.position === "absolute", r = /(auto|scroll)/;
    if (t.position === "fixed") return document.documentElement;
    for (var o = e; o = o.parentElement; )
      if (t = getComputedStyle(o), !(n && t.position === "static") && r.test(t.overflow + t.overflowY + t.overflowX))
        return o;
    return document.documentElement;
  }
  function cse(e, t, n, r) {
    return n * ((e = e / r - 1) * e * e + 1) + t;
  }
  function iv(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 200, r = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : hb, o = E9(e), a = t - o, i = 10, s = 0;
    function u() {
      s += i;
      var c = cse(s, o, a, n);
      gb(e, c), s < n ? window.requestAnimationFrame(u) : r(e);
    }
    u();
  }
  function yA(e, t) {
    var n = e.getBoundingClientRect(), r = t.getBoundingClientRect(), o = t.offsetHeight / 3;
    r.bottom + o > n.bottom ? gb(e, Math.min(t.offsetTop + t.clientHeight - e.offsetHeight + o, e.scrollHeight)) : r.top - o < n.top && gb(e, Math.max(t.offsetTop - o, 0));
  }
  function dse(e) {
    var t = e.getBoundingClientRect();
    return {
      bottom: t.bottom,
      height: t.height,
      left: t.left,
      right: t.right,
      top: t.top,
      width: t.width
    };
  }
  function bA() {
    try {
      return document.createEvent("TouchEvent"), !0;
    } catch {
      return !1;
    }
  }
  function fse() {
    try {
      return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
    } catch {
      return !1;
    }
  }
  var C9 = !1, pse = {
    get passive() {
      return C9 = !0;
    }
  }, sv = typeof window < "u" ? window : {};
  sv.addEventListener && sv.removeEventListener && (sv.addEventListener("p", hb, pse), sv.removeEventListener("p", hb, !1));
  var mse = C9;
  function hse(e) {
    return e != null;
  }
  function gse(e) {
    return Array.isArray(e);
  }
  function lv(e, t, n) {
    return e ? t : n;
  }
  var vse = function(e) {
    for (var t = arguments.length, n = new Array(t > 1 ? t - 1 : 0), r = 1; r < t; r++)
      n[r - 1] = arguments[r];
    var o = Object.entries(e).filter(function(a) {
      var i = Ti(a, 1), s = i[0];
      return !n.includes(s);
    });
    return o.reduce(function(a, i) {
      var s = Ti(i, 2), u = s[0], c = s[1];
      return a[u] = c, a;
    }, {});
  }, yse = ["children", "innerProps"], bse = ["children", "innerProps"];
  function wse(e) {
    var t = e.maxHeight, n = e.menuEl, r = e.minHeight, o = e.placement, a = e.shouldScroll, i = e.isFixedPosition, s = e.controlHeight, u = use(n), c = {
      placement: "bottom",
      maxHeight: t
    };
    if (!n || !n.offsetParent) return c;
    var f = u.getBoundingClientRect(), p = f.height, g = n.getBoundingClientRect(), h = g.bottom, y = g.height, b = g.top, v = n.offsetParent.getBoundingClientRect(), w = v.top, _ = i ? window.innerHeight : lse(u), k = E9(u), E = parseInt(getComputedStyle(n).marginBottom, 10), P = parseInt(getComputedStyle(n).marginTop, 10), O = w - P, M = _ - b, I = O + k, A = p - k - b, D = h - _ + k + E, F = k + b - P, j = 160;
    switch (o) {
      case "auto":
      case "bottom":
        if (M >= y)
          return {
            placement: "bottom",
            maxHeight: t
          };
        if (A >= y && !i)
          return a && iv(u, D, j), {
            placement: "bottom",
            maxHeight: t
          };
        if (!i && A >= r || i && M >= r) {
          a && iv(u, D, j);
          var U = i ? M - E : A - E;
          return {
            placement: "bottom",
            maxHeight: U
          };
        }
        if (o === "auto" || i) {
          var $ = t, q = i ? O : I;
          return q >= r && ($ = Math.min(q - E - s, t)), {
            placement: "top",
            maxHeight: $
          };
        }
        if (o === "bottom")
          return a && gb(u, D), {
            placement: "bottom",
            maxHeight: t
          };
        break;
      case "top":
        if (O >= y)
          return {
            placement: "top",
            maxHeight: t
          };
        if (I >= y && !i)
          return a && iv(u, F, j), {
            placement: "top",
            maxHeight: t
          };
        if (!i && I >= r || i && O >= r) {
          var B = t;
          return (!i && I >= r || i && O >= r) && (B = i ? O - P : I - P), a && iv(u, F, j), {
            placement: "top",
            maxHeight: B
          };
        }
        return {
          placement: "bottom",
          maxHeight: t
        };
      default:
        throw new Error('Invalid placement provided "'.concat(o, '".'));
    }
    return c;
  }
  function xse(e) {
    var t = {
      bottom: "top",
      top: "bottom"
    };
    return e ? t[e] : "bottom";
  }
  var P9 = function(e) {
    return e === "auto" ? "bottom" : e;
  }, kse = function(e, t) {
    var n, r = e.placement, o = e.theme, a = o.borderRadius, i = o.spacing, s = o.colors;
    return Ye((n = {
      label: "menu"
    }, yp(n, xse(r), "100%"), yp(n, "position", "absolute"), yp(n, "width", "100%"), yp(n, "zIndex", 1), n), t ? {} : {
      backgroundColor: s.neutral0,
      borderRadius: a,
      boxShadow: "0 0 0 1px hsla(0, 0%, 0%, 0.1), 0 4px 11px hsla(0, 0%, 0%, 0.1)",
      marginBottom: i.menuGutter,
      marginTop: i.menuGutter
    });
  }, O9 = /* @__PURE__ */ C.createContext(null), Sse = function(e) {
    var t = e.children, n = e.minMenuHeight, r = e.maxMenuHeight, o = e.menuPlacement, a = e.menuPosition, i = e.menuShouldScrollIntoView, s = e.theme, u = C.useContext(O9) || {}, c = u.setPortalPlacement, f = C.useRef(null), p = C.useState(r), g = Ti(p, 2), h = g[0], y = g[1], b = C.useState(null), v = Ti(b, 2), w = v[0], _ = v[1], k = s.spacing.controlHeight;
    return j2(function() {
      var E = f.current;
      if (E) {
        var P = a === "fixed", O = i && !P, M = wse({
          maxHeight: r,
          menuEl: E,
          minHeight: n,
          placement: o,
          shouldScroll: O,
          isFixedPosition: P,
          controlHeight: k
        });
        y(M.maxHeight), _(M.placement), c?.(M.placement);
      }
    }, [r, o, a, i, n, c, k]), t({
      ref: f,
      placerProps: Ye(Ye({}, e), {}, {
        placement: w || P9(o),
        maxHeight: h
      })
    });
  }, _se = function(e) {
    var t = e.children, n = e.innerRef, r = e.innerProps;
    return qe("div", Ge({}, Nn(e, "menu", {
      menu: !0
    }), {
      ref: n
    }, r), t);
  }, Ese = _se, Cse = function(e, t) {
    var n = e.maxHeight, r = e.theme.spacing.baseUnit;
    return Ye({
      maxHeight: n,
      overflowY: "auto",
      position: "relative",
      // required for offset[Height, Top] > keyboard scroll
      WebkitOverflowScrolling: "touch"
    }, t ? {} : {
      paddingBottom: r,
      paddingTop: r
    });
  }, Pse = function(e) {
    var t = e.children, n = e.innerProps, r = e.innerRef, o = e.isMulti;
    return qe("div", Ge({}, Nn(e, "menuList", {
      "menu-list": !0,
      "menu-list--is-multi": o
    }), {
      ref: r
    }, n), t);
  }, N9 = function(e, t) {
    var n = e.theme, r = n.spacing.baseUnit, o = n.colors;
    return Ye({
      textAlign: "center"
    }, t ? {} : {
      color: o.neutral40,
      padding: "".concat(r * 2, "px ").concat(r * 3, "px")
    });
  }, Ose = N9, Nse = N9, Mse = function(e) {
    var t = e.children, n = t === void 0 ? "No options" : t, r = e.innerProps, o = es(e, yse);
    return qe("div", Ge({}, Nn(Ye(Ye({}, o), {}, {
      children: n,
      innerProps: r
    }), "noOptionsMessage", {
      "menu-notice": !0,
      "menu-notice--no-options": !0
    }), r), n);
  }, Rse = function(e) {
    var t = e.children, n = t === void 0 ? "Loading..." : t, r = e.innerProps, o = es(e, bse);
    return qe("div", Ge({}, Nn(Ye(Ye({}, o), {}, {
      children: n,
      innerProps: r
    }), "loadingMessage", {
      "menu-notice": !0,
      "menu-notice--loading": !0
    }), r), n);
  }, jse = function(e) {
    var t = e.rect, n = e.offset, r = e.position;
    return {
      left: t.left,
      position: r,
      top: n,
      width: t.width,
      zIndex: 1
    };
  }, Ise = function(e) {
    var t = e.appendTo, n = e.children, r = e.controlElement, o = e.innerProps, a = e.menuPlacement, i = e.menuPosition, s = C.useRef(null), u = C.useRef(null), c = C.useState(P9(a)), f = Ti(c, 2), p = f[0], g = f[1], h = C.useMemo(function() {
      return {
        setPortalPlacement: g
      };
    }, []), y = C.useState(null), b = Ti(y, 2), v = b[0], w = b[1], _ = C.useCallback(function() {
      if (r) {
        var O = dse(r), M = i === "fixed" ? 0 : window.pageYOffset, I = O[p] + M;
        (I !== v?.offset || O.left !== v?.rect.left || O.width !== v?.rect.width) && w({
          offset: I,
          rect: O
        });
      }
    }, [r, i, p, v?.offset, v?.rect.left, v?.rect.width]);
    j2(function() {
      _();
    }, [_]);
    var k = C.useCallback(function() {
      typeof u.current == "function" && (u.current(), u.current = null), r && s.current && (u.current = Hz(r, s.current, _, {
        elementResize: "ResizeObserver" in window
      }));
    }, [r, _]);
    j2(function() {
      k();
    }, [k]);
    var E = C.useCallback(function(O) {
      s.current = O, k();
    }, [k]);
    if (!t && i !== "fixed" || !v) return null;
    var P = qe("div", Ge({
      ref: E
    }, Nn(Ye(Ye({}, e), {}, {
      offset: v.offset,
      position: i,
      rect: v.rect
    }), "menuPortal", {
      "menu-portal": !0
    }), o), n);
    return qe(O9.Provider, {
      value: h
    }, t ? /* @__PURE__ */ xu.createPortal(P, t) : P);
  }, Ase = function(e) {
    var t = e.isDisabled, n = e.isRtl;
    return {
      label: "container",
      direction: n ? "rtl" : void 0,
      pointerEvents: t ? "none" : void 0,
      // cancel mouse events when disabled
      position: "relative"
    };
  }, $se = function(e) {
    var t = e.children, n = e.innerProps, r = e.isDisabled, o = e.isRtl;
    return qe("div", Ge({}, Nn(e, "container", {
      "--is-disabled": r,
      "--is-rtl": o
    }), n), t);
  }, Dse = function(e, t) {
    var n = e.theme.spacing, r = e.isMulti, o = e.hasValue, a = e.selectProps.controlShouldRenderValue;
    return Ye({
      alignItems: "center",
      display: r && o && a ? "flex" : "grid",
      flex: 1,
      flexWrap: "wrap",
      WebkitOverflowScrolling: "touch",
      position: "relative",
      overflow: "hidden"
    }, t ? {} : {
      padding: "".concat(n.baseUnit / 2, "px ").concat(n.baseUnit * 2, "px")
    });
  }, Lse = function(e) {
    var t = e.children, n = e.innerProps, r = e.isMulti, o = e.hasValue;
    return qe("div", Ge({}, Nn(e, "valueContainer", {
      "value-container": !0,
      "value-container--is-multi": r,
      "value-container--has-value": o
    }), n), t);
  }, Fse = function() {
    return {
      alignItems: "center",
      alignSelf: "stretch",
      display: "flex",
      flexShrink: 0
    };
  }, Tse = function(e) {
    var t = e.children, n = e.innerProps;
    return qe("div", Ge({}, Nn(e, "indicatorsContainer", {
      indicators: !0
    }), n), t);
  }, wA, zse = ["size"], Bse = ["innerProps", "isRtl", "size"], Vse = {
    name: "8mmkcg",
    styles: "display:inline-block;fill:currentColor;line-height:1;stroke:currentColor;stroke-width:0"
  }, M9 = function(e) {
    var t = e.size, n = es(e, zse);
    return qe("svg", Ge({
      height: t,
      width: t,
      viewBox: "0 0 20 20",
      "aria-hidden": "true",
      focusable: "false",
      css: Vse
    }, n));
  }, XC = function(e) {
    return qe(M9, Ge({
      size: 20
    }, e), qe("path", {
      d: "M14.348 14.849c-0.469 0.469-1.229 0.469-1.697 0l-2.651-3.030-2.651 3.029c-0.469 0.469-1.229 0.469-1.697 0-0.469-0.469-0.469-1.229 0-1.697l2.758-3.15-2.759-3.152c-0.469-0.469-0.469-1.228 0-1.697s1.228-0.469 1.697 0l2.652 3.031 2.651-3.031c0.469-0.469 1.228-0.469 1.697 0s0.469 1.229 0 1.697l-2.758 3.152 2.758 3.15c0.469 0.469 0.469 1.229 0 1.698z"
    }));
  }, R9 = function(e) {
    return qe(M9, Ge({
      size: 20
    }, e), qe("path", {
      d: "M4.516 7.548c0.436-0.446 1.043-0.481 1.576 0l3.908 3.747 3.908-3.747c0.533-0.481 1.141-0.446 1.574 0 0.436 0.445 0.408 1.197 0 1.615-0.406 0.418-4.695 4.502-4.695 4.502-0.217 0.223-0.502 0.335-0.787 0.335s-0.57-0.112-0.789-0.335c0 0-4.287-4.084-4.695-4.502s-0.436-1.17 0-1.615z"
    }));
  }, j9 = function(e, t) {
    var n = e.isFocused, r = e.theme, o = r.spacing.baseUnit, a = r.colors;
    return Ye({
      label: "indicatorContainer",
      display: "flex",
      transition: "color 150ms"
    }, t ? {} : {
      color: n ? a.neutral60 : a.neutral20,
      padding: o * 2,
      ":hover": {
        color: n ? a.neutral80 : a.neutral40
      }
    });
  }, Use = j9, Hse = function(e) {
    var t = e.children, n = e.innerProps;
    return qe("div", Ge({}, Nn(e, "dropdownIndicator", {
      indicator: !0,
      "dropdown-indicator": !0
    }), n), t || qe(R9, null));
  }, Wse = j9, qse = function(e) {
    var t = e.children, n = e.innerProps;
    return qe("div", Ge({}, Nn(e, "clearIndicator", {
      indicator: !0,
      "clear-indicator": !0
    }), n), t || qe(XC, null));
  }, Kse = function(e, t) {
    var n = e.isDisabled, r = e.theme, o = r.spacing.baseUnit, a = r.colors;
    return Ye({
      label: "indicatorSeparator",
      alignSelf: "stretch",
      width: 1
    }, t ? {} : {
      backgroundColor: n ? a.neutral10 : a.neutral20,
      marginBottom: o * 2,
      marginTop: o * 2
    });
  }, Gse = function(e) {
    var t = e.innerProps;
    return qe("span", Ge({}, t, Nn(e, "indicatorSeparator", {
      "indicator-separator": !0
    })));
  }, Xse = Ad(wA || (wA = ose([`
  0%, 80%, 100% { opacity: 0; }
  40% { opacity: 1; }
`]))), Yse = function(e, t) {
    var n = e.isFocused, r = e.size, o = e.theme, a = o.colors, i = o.spacing.baseUnit;
    return Ye({
      label: "loadingIndicator",
      display: "flex",
      transition: "color 150ms",
      alignSelf: "center",
      fontSize: r,
      lineHeight: 1,
      marginRight: r,
      textAlign: "center",
      verticalAlign: "middle"
    }, t ? {} : {
      color: n ? a.neutral60 : a.neutral20,
      padding: i * 2
    });
  }, M_ = function(e) {
    var t = e.delay, n = e.offset;
    return qe("span", {
      css: /* @__PURE__ */ Fm({
        animation: "".concat(Xse, " 1s ease-in-out ").concat(t, "ms infinite;"),
        backgroundColor: "currentColor",
        borderRadius: "1em",
        display: "inline-block",
        marginLeft: n ? "1em" : void 0,
        height: "1em",
        verticalAlign: "top",
        width: "1em"
      }, "", "")
    });
  }, Jse = function(e) {
    var t = e.innerProps, n = e.isRtl, r = e.size, o = r === void 0 ? 4 : r, a = es(e, Bse);
    return qe("div", Ge({}, Nn(Ye(Ye({}, a), {}, {
      innerProps: t,
      isRtl: n,
      size: o
    }), "loadingIndicator", {
      indicator: !0,
      "loading-indicator": !0
    }), t), qe(M_, {
      delay: 0,
      offset: n
    }), qe(M_, {
      delay: 160,
      offset: !0
    }), qe(M_, {
      delay: 320,
      offset: !n
    }));
  }, Qse = function(e, t) {
    var n = e.isDisabled, r = e.isFocused, o = e.theme, a = o.colors, i = o.borderRadius, s = o.spacing;
    return Ye({
      label: "control",
      alignItems: "center",
      cursor: "default",
      display: "flex",
      flexWrap: "wrap",
      justifyContent: "space-between",
      minHeight: s.controlHeight,
      outline: "0 !important",
      position: "relative",
      transition: "all 100ms"
    }, t ? {} : {
      backgroundColor: n ? a.neutral5 : a.neutral0,
      borderColor: n ? a.neutral10 : r ? a.primary : a.neutral20,
      borderRadius: i,
      borderStyle: "solid",
      borderWidth: 1,
      boxShadow: r ? "0 0 0 1px ".concat(a.primary) : void 0,
      "&:hover": {
        borderColor: r ? a.primary : a.neutral30
      }
    });
  }, Zse = function(e) {
    var t = e.children, n = e.isDisabled, r = e.isFocused, o = e.innerRef, a = e.innerProps, i = e.menuIsOpen;
    return qe("div", Ge({
      ref: o
    }, Nn(e, "control", {
      control: !0,
      "control--is-disabled": n,
      "control--is-focused": r,
      "control--menu-is-open": i
    }), a, {
      "aria-disabled": n || void 0
    }), t);
  }, ele = Zse, tle = ["data"], nle = function(e, t) {
    var n = e.theme.spacing;
    return t ? {} : {
      paddingBottom: n.baseUnit * 2,
      paddingTop: n.baseUnit * 2
    };
  }, rle = function(e) {
    var t = e.children, n = e.cx, r = e.getStyles, o = e.getClassNames, a = e.Heading, i = e.headingProps, s = e.innerProps, u = e.label, c = e.theme, f = e.selectProps;
    return qe("div", Ge({}, Nn(e, "group", {
      group: !0
    }), s), qe(a, Ge({}, i, {
      selectProps: f,
      theme: c,
      getStyles: r,
      getClassNames: o,
      cx: n
    }), u), qe("div", null, t));
  }, ole = function(e, t) {
    var n = e.theme, r = n.colors, o = n.spacing;
    return Ye({
      label: "group",
      cursor: "default",
      display: "block"
    }, t ? {} : {
      color: r.neutral40,
      fontSize: "75%",
      fontWeight: 500,
      marginBottom: "0.25em",
      paddingLeft: o.baseUnit * 3,
      paddingRight: o.baseUnit * 3,
      textTransform: "uppercase"
    });
  }, ale = function(e) {
    var t = _9(e);
    t.data;
    var n = es(t, tle);
    return qe("div", Ge({}, Nn(e, "groupHeading", {
      "group-heading": !0
    }), n));
  }, ile = rle, sle = ["innerRef", "isDisabled", "isHidden", "inputClassName"], lle = function(e, t) {
    var n = e.isDisabled, r = e.value, o = e.theme, a = o.spacing, i = o.colors;
    return Ye(Ye({
      visibility: n ? "hidden" : "visible",
      // force css to recompute when value change due to @emotion bug.
      // We can remove it whenever the bug is fixed.
      transform: r ? "translateZ(0)" : ""
    }, ule), t ? {} : {
      margin: a.baseUnit / 2,
      paddingBottom: a.baseUnit / 2,
      paddingTop: a.baseUnit / 2,
      color: i.neutral80
    });
  }, I9 = {
    gridArea: "1 / 2",
    font: "inherit",
    minWidth: "2px",
    border: 0,
    margin: 0,
    outline: 0,
    padding: 0
  }, ule = {
    flex: "1 1 auto",
    display: "inline-grid",
    gridArea: "1 / 1 / 2 / 3",
    gridTemplateColumns: "0 min-content",
    "&:after": Ye({
      content: 'attr(data-value) " "',
      visibility: "hidden",
      whiteSpace: "pre"
    }, I9)
  }, cle = function(e) {
    return Ye({
      label: "input",
      color: "inherit",
      background: 0,
      opacity: e ? 0 : 1,
      width: "100%"
    }, I9);
  }, dle = function(e) {
    var t = e.cx, n = e.value, r = _9(e), o = r.innerRef, a = r.isDisabled, i = r.isHidden, s = r.inputClassName, u = es(r, sle);
    return qe("div", Ge({}, Nn(e, "input", {
      "input-container": !0
    }), {
      "data-value": n || ""
    }), qe("input", Ge({
      className: t({
        input: !0
      }, s),
      ref: o,
      style: cle(i),
      disabled: a
    }, u)));
  }, fle = dle, ple = function(e, t) {
    var n = e.theme, r = n.spacing, o = n.borderRadius, a = n.colors;
    return Ye({
      label: "multiValue",
      display: "flex",
      minWidth: 0
    }, t ? {} : {
      backgroundColor: a.neutral10,
      borderRadius: o / 2,
      margin: r.baseUnit / 2
    });
  }, mle = function(e, t) {
    var n = e.theme, r = n.borderRadius, o = n.colors, a = e.cropWithEllipsis;
    return Ye({
      overflow: "hidden",
      textOverflow: a || a === void 0 ? "ellipsis" : void 0,
      whiteSpace: "nowrap"
    }, t ? {} : {
      borderRadius: r / 2,
      color: o.neutral80,
      fontSize: "85%",
      padding: 3,
      paddingLeft: 6
    });
  }, hle = function(e, t) {
    var n = e.theme, r = n.spacing, o = n.borderRadius, a = n.colors, i = e.isFocused;
    return Ye({
      alignItems: "center",
      display: "flex"
    }, t ? {} : {
      borderRadius: o / 2,
      backgroundColor: i ? a.dangerLight : void 0,
      paddingLeft: r.baseUnit,
      paddingRight: r.baseUnit,
      ":hover": {
        backgroundColor: a.dangerLight,
        color: a.danger
      }
    });
  }, A9 = function(e) {
    var t = e.children, n = e.innerProps;
    return qe("div", n, t);
  }, gle = A9, vle = A9;
  function yle(e) {
    var t = e.children, n = e.innerProps;
    return qe("div", Ge({
      role: "button"
    }, n), t || qe(XC, {
      size: 14
    }));
  }
  var ble = function(e) {
    var t = e.children, n = e.components, r = e.data, o = e.innerProps, a = e.isDisabled, i = e.removeProps, s = e.selectProps, u = n.Container, c = n.Label, f = n.Remove;
    return qe(u, {
      data: r,
      innerProps: Ye(Ye({}, Nn(e, "multiValue", {
        "multi-value": !0,
        "multi-value--is-disabled": a
      })), o),
      selectProps: s
    }, qe(c, {
      data: r,
      innerProps: Ye({}, Nn(e, "multiValueLabel", {
        "multi-value__label": !0
      })),
      selectProps: s
    }, t), qe(f, {
      data: r,
      innerProps: Ye(Ye({}, Nn(e, "multiValueRemove", {
        "multi-value__remove": !0
      })), {}, {
        "aria-label": "Remove ".concat(t || "option")
      }, i),
      selectProps: s
    }));
  }, wle = ble, xle = function(e, t) {
    var n = e.isDisabled, r = e.isFocused, o = e.isSelected, a = e.theme, i = a.spacing, s = a.colors;
    return Ye({
      label: "option",
      cursor: "default",
      display: "block",
      fontSize: "inherit",
      width: "100%",
      userSelect: "none",
      WebkitTapHighlightColor: "rgba(0, 0, 0, 0)"
    }, t ? {} : {
      backgroundColor: o ? s.primary : r ? s.primary25 : "transparent",
      color: n ? s.neutral20 : o ? s.neutral0 : "inherit",
      padding: "".concat(i.baseUnit * 2, "px ").concat(i.baseUnit * 3, "px"),
      // provide some affordance on touch devices
      ":active": {
        backgroundColor: n ? void 0 : o ? s.primary : s.primary50
      }
    });
  }, kle = function(e) {
    var t = e.children, n = e.isDisabled, r = e.isFocused, o = e.isSelected, a = e.innerRef, i = e.innerProps;
    return qe("div", Ge({}, Nn(e, "option", {
      option: !0,
      "option--is-disabled": n,
      "option--is-focused": r,
      "option--is-selected": o
    }), {
      ref: a,
      "aria-disabled": n
    }, i), t);
  }, Sle = kle, _le = function(e, t) {
    var n = e.theme, r = n.spacing, o = n.colors;
    return Ye({
      label: "placeholder",
      gridArea: "1 / 1 / 2 / 3"
    }, t ? {} : {
      color: o.neutral50,
      marginLeft: r.baseUnit / 2,
      marginRight: r.baseUnit / 2
    });
  }, Ele = function(e) {
    var t = e.children, n = e.innerProps;
    return qe("div", Ge({}, Nn(e, "placeholder", {
      placeholder: !0
    }), n), t);
  }, Cle = Ele, Ple = function(e, t) {
    var n = e.isDisabled, r = e.theme, o = r.spacing, a = r.colors;
    return Ye({
      label: "singleValue",
      gridArea: "1 / 1 / 2 / 3",
      maxWidth: "100%",
      overflow: "hidden",
      textOverflow: "ellipsis",
      whiteSpace: "nowrap"
    }, t ? {} : {
      color: n ? a.neutral40 : a.neutral80,
      marginLeft: o.baseUnit / 2,
      marginRight: o.baseUnit / 2
    });
  }, Ole = function(e) {
    var t = e.children, n = e.isDisabled, r = e.innerProps;
    return qe("div", Ge({}, Nn(e, "singleValue", {
      "single-value": !0,
      "single-value--is-disabled": n
    }), r), t);
  }, Nle = Ole, Mle = {
    ClearIndicator: qse,
    Control: ele,
    DropdownIndicator: Hse,
    DownChevron: R9,
    CrossIcon: XC,
    Group: ile,
    GroupHeading: ale,
    IndicatorsContainer: Tse,
    IndicatorSeparator: Gse,
    Input: fle,
    LoadingIndicator: Jse,
    Menu: Ese,
    MenuList: Pse,
    MenuPortal: Ise,
    LoadingMessage: Rse,
    NoOptionsMessage: Mse,
    MultiValue: wle,
    MultiValueContainer: gle,
    MultiValueLabel: vle,
    MultiValueRemove: yle,
    Option: Sle,
    Placeholder: Cle,
    SelectContainer: $se,
    SingleValue: Nle,
    ValueContainer: Lse
  }, Rle = function(e) {
    return Ye(Ye({}, Mle), e.components);
  }, xA = Number.isNaN || function(e) {
    return typeof e == "number" && e !== e;
  };
  function jle(e, t) {
    return !!(e === t || xA(e) && xA(t));
  }
  function Ile(e, t) {
    if (e.length !== t.length)
      return !1;
    for (var n = 0; n < e.length; n++)
      if (!jle(e[n], t[n]))
        return !1;
    return !0;
  }
  function Ale(e, t) {
    t === void 0 && (t = Ile);
    var n = null;
    function r() {
      for (var o = [], a = 0; a < arguments.length; a++)
        o[a] = arguments[a];
      if (n && n.lastThis === this && t(o, n.lastArgs))
        return n.lastResult;
      var i = e.apply(this, o);
      return n = {
        lastResult: i,
        lastArgs: o,
        lastThis: this
      }, i;
    }
    return r.clear = function() {
      n = null;
    }, r;
  }
  var $le = {
    name: "7pg0cj-a11yText",
    styles: "label:a11yText;z-index:9999;border:0;clip:rect(1px, 1px, 1px, 1px);height:1px;width:1px;position:absolute;overflow:hidden;padding:0;white-space:nowrap"
  }, Dle = function(e) {
    return qe("span", Ge({
      css: $le
    }, e));
  }, kA = Dle, Lle = {
    guidance: function(e) {
      var t = e.isSearchable, n = e.isMulti, r = e.tabSelectsValue, o = e.context, a = e.isInitialFocus;
      switch (o) {
        case "menu":
          return "Use Up and Down to choose options, press Enter to select the currently focused option, press Escape to exit the menu".concat(r ? ", press Tab to select the option and exit the menu" : "", ".");
        case "input":
          return a ? "".concat(e["aria-label"] || "Select", " is focused ").concat(t ? ",type to refine list" : "", ", press Down to open the menu, ").concat(n ? " press left to focus selected values" : "") : "";
        case "value":
          return "Use left and right to toggle between focused values, press Backspace to remove the currently focused value";
        default:
          return "";
      }
    },
    onChange: function(e) {
      var t = e.action, n = e.label, r = n === void 0 ? "" : n, o = e.labels, a = e.isDisabled;
      switch (t) {
        case "deselect-option":
        case "pop-value":
        case "remove-value":
          return "option ".concat(r, ", deselected.");
        case "clear":
          return "All selected options have been cleared.";
        case "initial-input-focus":
          return "option".concat(o.length > 1 ? "s" : "", " ").concat(o.join(","), ", selected.");
        case "select-option":
          return a ? "option ".concat(r, " is disabled. Select another option.") : "option ".concat(r, ", selected.");
        default:
          return "";
      }
    },
    onFocus: function(e) {
      var t = e.context, n = e.focused, r = e.options, o = e.label, a = o === void 0 ? "" : o, i = e.selectValue, s = e.isDisabled, u = e.isSelected, c = e.isAppleDevice, f = function(h, y) {
        return h && h.length ? "".concat(h.indexOf(y) + 1, " of ").concat(h.length) : "";
      };
      if (t === "value" && i)
        return "value ".concat(a, " focused, ").concat(f(i, n), ".");
      if (t === "menu" && c) {
        var p = s ? " disabled" : "", g = "".concat(u ? " selected" : "").concat(p);
        return "".concat(a).concat(g, ", ").concat(f(r, n), ".");
      }
      return "";
    },
    onFilter: function(e) {
      var t = e.inputValue, n = e.resultsMessage;
      return "".concat(n).concat(t ? " for search term " + t : "", ".");
    }
  }, Fle = function(e) {
    var t = e.ariaSelection, n = e.focusedOption, r = e.focusedValue, o = e.focusableOptions, a = e.isFocused, i = e.selectValue, s = e.selectProps, u = e.id, c = e.isAppleDevice, f = s.ariaLiveMessages, p = s.getOptionLabel, g = s.inputValue, h = s.isMulti, y = s.isOptionDisabled, b = s.isSearchable, v = s.menuIsOpen, w = s.options, _ = s.screenReaderStatus, k = s.tabSelectsValue, E = s.isLoading, P = s["aria-label"], O = s["aria-live"], M = C.useMemo(function() {
      return Ye(Ye({}, Lle), f || {});
    }, [f]), I = C.useMemo(function() {
      var $ = "";
      if (t && M.onChange) {
        var q = t.option, B = t.options, G = t.removedValue, W = t.removedValues, Y = t.value, z = function(Q) {
          return Array.isArray(Q) ? null : Q;
        }, L = G || q || z(Y), K = L ? p(L) : "", T = B || W || void 0, V = T ? T.map(p) : [], X = Ye({
          // multiSelected items are usually items that have already been selected
          // or set by the user as a default value so we assume they are not disabled
          isDisabled: L && y(L, i),
          label: K,
          labels: V
        }, t);
        $ = M.onChange(X);
      }
      return $;
    }, [t, M, y, i, p]), A = C.useMemo(function() {
      var $ = "", q = n || r, B = !!(n && i && i.includes(n));
      if (q && M.onFocus) {
        var G = {
          focused: q,
          label: p(q),
          isDisabled: y(q, i),
          isSelected: B,
          options: o,
          context: q === n ? "menu" : "value",
          selectValue: i,
          isAppleDevice: c
        };
        $ = M.onFocus(G);
      }
      return $;
    }, [n, r, p, y, M, o, i, c]), D = C.useMemo(function() {
      var $ = "";
      if (v && w.length && !E && M.onFilter) {
        var q = _({
          count: o.length
        });
        $ = M.onFilter({
          inputValue: g,
          resultsMessage: q
        });
      }
      return $;
    }, [o, g, v, M, w, _, E]), F = t?.action === "initial-input-focus", j = C.useMemo(function() {
      var $ = "";
      if (M.guidance) {
        var q = r ? "value" : v ? "menu" : "input";
        $ = M.guidance({
          "aria-label": P,
          context: q,
          isDisabled: n && y(n, i),
          isMulti: h,
          isSearchable: b,
          tabSelectsValue: k,
          isInitialFocus: F
        });
      }
      return $;
    }, [P, n, r, h, y, b, v, M, i, k, F]), U = qe(C.Fragment, null, qe("span", {
      id: "aria-selection"
    }, I), qe("span", {
      id: "aria-focused"
    }, A), qe("span", {
      id: "aria-results"
    }, D), qe("span", {
      id: "aria-guidance"
    }, j));
    return qe(C.Fragment, null, qe(kA, {
      id: u
    }, F && U), qe(kA, {
      "aria-live": O,
      "aria-atomic": "false",
      "aria-relevant": "additions text",
      role: "log"
    }, a && !F && U));
  }, Tle = Fle, I2 = [{
    base: "A",
    letters: "A"
  }, {
    base: "AA",
    letters: ""
  }, {
    base: "AE",
    letters: ""
  }, {
    base: "AO",
    letters: ""
  }, {
    base: "AU",
    letters: ""
  }, {
    base: "AV",
    letters: ""
  }, {
    base: "AY",
    letters: ""
  }, {
    base: "B",
    letters: "B"
  }, {
    base: "C",
    letters: "C"
  }, {
    base: "D",
    letters: "D"
  }, {
    base: "DZ",
    letters: ""
  }, {
    base: "Dz",
    letters: ""
  }, {
    base: "E",
    letters: "E"
  }, {
    base: "F",
    letters: "F"
  }, {
    base: "G",
    letters: "G"
  }, {
    base: "H",
    letters: "H"
  }, {
    base: "I",
    letters: "I"
  }, {
    base: "J",
    letters: "J"
  }, {
    base: "K",
    letters: "K"
  }, {
    base: "L",
    letters: "L"
  }, {
    base: "LJ",
    letters: ""
  }, {
    base: "Lj",
    letters: ""
  }, {
    base: "M",
    letters: "M"
  }, {
    base: "N",
    letters: "N"
  }, {
    base: "NJ",
    letters: ""
  }, {
    base: "Nj",
    letters: ""
  }, {
    base: "O",
    letters: "O"
  }, {
    base: "OI",
    letters: ""
  }, {
    base: "OO",
    letters: ""
  }, {
    base: "OU",
    letters: ""
  }, {
    base: "P",
    letters: "P"
  }, {
    base: "Q",
    letters: "Q"
  }, {
    base: "R",
    letters: "R"
  }, {
    base: "S",
    letters: "S"
  }, {
    base: "T",
    letters: "T"
  }, {
    base: "TZ",
    letters: ""
  }, {
    base: "U",
    letters: "U"
  }, {
    base: "V",
    letters: "V"
  }, {
    base: "VY",
    letters: ""
  }, {
    base: "W",
    letters: "W"
  }, {
    base: "X",
    letters: "X"
  }, {
    base: "Y",
    letters: "Y"
  }, {
    base: "Z",
    letters: "Z"
  }, {
    base: "a",
    letters: "a"
  }, {
    base: "aa",
    letters: ""
  }, {
    base: "ae",
    letters: ""
  }, {
    base: "ao",
    letters: ""
  }, {
    base: "au",
    letters: ""
  }, {
    base: "av",
    letters: ""
  }, {
    base: "ay",
    letters: ""
  }, {
    base: "b",
    letters: "b"
  }, {
    base: "c",
    letters: "c"
  }, {
    base: "d",
    letters: "d"
  }, {
    base: "dz",
    letters: ""
  }, {
    base: "e",
    letters: "e"
  }, {
    base: "f",
    letters: "f"
  }, {
    base: "g",
    letters: "g"
  }, {
    base: "h",
    letters: "h"
  }, {
    base: "hv",
    letters: ""
  }, {
    base: "i",
    letters: "i"
  }, {
    base: "j",
    letters: "j"
  }, {
    base: "k",
    letters: "k"
  }, {
    base: "l",
    letters: "l"
  }, {
    base: "lj",
    letters: ""
  }, {
    base: "m",
    letters: "m"
  }, {
    base: "n",
    letters: "n"
  }, {
    base: "nj",
    letters: ""
  }, {
    base: "o",
    letters: "o"
  }, {
    base: "oi",
    letters: ""
  }, {
    base: "ou",
    letters: ""
  }, {
    base: "oo",
    letters: ""
  }, {
    base: "p",
    letters: "p"
  }, {
    base: "q",
    letters: "q"
  }, {
    base: "r",
    letters: "r"
  }, {
    base: "s",
    letters: "s"
  }, {
    base: "t",
    letters: "t"
  }, {
    base: "tz",
    letters: ""
  }, {
    base: "u",
    letters: "u"
  }, {
    base: "v",
    letters: "v"
  }, {
    base: "vy",
    letters: ""
  }, {
    base: "w",
    letters: "w"
  }, {
    base: "x",
    letters: "x"
  }, {
    base: "y",
    letters: "y"
  }, {
    base: "z",
    letters: "z"
  }], zle = new RegExp("[" + I2.map(function(e) {
    return e.letters;
  }).join("") + "]", "g"), $9 = {};
  for (var R_ = 0; R_ < I2.length; R_++)
    for (var j_ = I2[R_], I_ = 0; I_ < j_.letters.length; I_++)
      $9[j_.letters[I_]] = j_.base;
  var D9 = function(e) {
    return e.replace(zle, function(t) {
      return $9[t];
    });
  }, Ble = Ale(D9), SA = function(e) {
    return e.replace(/^\s+|\s+$/g, "");
  }, Vle = function(e) {
    return "".concat(e.label, " ").concat(e.value);
  }, Ule = function(e) {
    return function(t, n) {
      if (t.data.__isNew__) return !0;
      var r = Ye({
        ignoreCase: !0,
        ignoreAccents: !0,
        stringify: Vle,
        trim: !0,
        matchFrom: "any"
      }, e), o = r.ignoreCase, a = r.ignoreAccents, i = r.stringify, s = r.trim, u = r.matchFrom, c = s ? SA(n) : n, f = s ? SA(i(t)) : i(t);
      return o && (c = c.toLowerCase(), f = f.toLowerCase()), a && (c = Ble(c), f = D9(f)), u === "start" ? f.substr(0, c.length) === c : f.indexOf(c) > -1;
    };
  }, Hle = ["innerRef"];
  function Wle(e) {
    var t = e.innerRef, n = es(e, Hle), r = vse(n, "onExited", "in", "enter", "exit", "appear");
    return qe("input", Ge({
      ref: t
    }, r, {
      css: /* @__PURE__ */ Fm({
        label: "dummyInput",
        // get rid of any default styles
        background: 0,
        border: 0,
        // important! this hides the flashing cursor
        caretColor: "transparent",
        fontSize: "inherit",
        gridArea: "1 / 1 / 2 / 3",
        outline: 0,
        padding: 0,
        // important! without `width` browsers won't allow focus
        width: 1,
        // remove cursor on desktop
        color: "transparent",
        // remove cursor on mobile whilst maintaining "scroll into view" behaviour
        left: -100,
        opacity: 0,
        position: "relative",
        transform: "scale(.01)"
      }, "", "")
    }));
  }
  var qle = function(e) {
    e.cancelable && e.preventDefault(), e.stopPropagation();
  };
  function Kle(e) {
    var t = e.isEnabled, n = e.onBottomArrive, r = e.onBottomLeave, o = e.onTopArrive, a = e.onTopLeave, i = C.useRef(!1), s = C.useRef(!1), u = C.useRef(0), c = C.useRef(null), f = C.useCallback(function(v, w) {
      if (c.current !== null) {
        var _ = c.current, k = _.scrollTop, E = _.scrollHeight, P = _.clientHeight, O = c.current, M = w > 0, I = E - P - k, A = !1;
        I > w && i.current && (r && r(v), i.current = !1), M && s.current && (a && a(v), s.current = !1), M && w > I ? (n && !i.current && n(v), O.scrollTop = E, A = !0, i.current = !0) : !M && -w > k && (o && !s.current && o(v), O.scrollTop = 0, A = !0, s.current = !0), A && qle(v);
      }
    }, [n, r, o, a]), p = C.useCallback(function(v) {
      f(v, v.deltaY);
    }, [f]), g = C.useCallback(function(v) {
      u.current = v.changedTouches[0].clientY;
    }, []), h = C.useCallback(function(v) {
      var w = u.current - v.changedTouches[0].clientY;
      f(v, w);
    }, [f]), y = C.useCallback(function(v) {
      if (v) {
        var w = mse ? {
          passive: !1
        } : !1;
        v.addEventListener("wheel", p, w), v.addEventListener("touchstart", g, w), v.addEventListener("touchmove", h, w);
      }
    }, [h, g, p]), b = C.useCallback(function(v) {
      v && (v.removeEventListener("wheel", p, !1), v.removeEventListener("touchstart", g, !1), v.removeEventListener("touchmove", h, !1));
    }, [h, g, p]);
    return C.useEffect(function() {
      if (t) {
        var v = c.current;
        return y(v), function() {
          b(v);
        };
      }
    }, [t, y, b]), function(v) {
      c.current = v;
    };
  }
  var _A = ["boxSizing", "height", "overflow", "paddingRight", "position"], EA = {
    boxSizing: "border-box",
    // account for possible declaration `width: 100%;` on body
    overflow: "hidden",
    position: "relative",
    height: "100%"
  };
  function CA(e) {
    e.cancelable && e.preventDefault();
  }
  function PA(e) {
    e.stopPropagation();
  }
  function OA() {
    var e = this.scrollTop, t = this.scrollHeight, n = e + this.offsetHeight;
    e === 0 ? this.scrollTop = 1 : n === t && (this.scrollTop = e - 1);
  }
  function NA() {
    return "ontouchstart" in window || navigator.maxTouchPoints;
  }
  var MA = !!(typeof window < "u" && window.document && window.document.createElement), Gf = 0, Nc = {
    capture: !1,
    passive: !1
  };
  function Gle(e) {
    var t = e.isEnabled, n = e.accountForScrollbars, r = n === void 0 ? !0 : n, o = C.useRef({}), a = C.useRef(null), i = C.useCallback(function(u) {
      if (MA) {
        var c = document.body, f = c && c.style;
        if (r && _A.forEach(function(y) {
          var b = f && f[y];
          o.current[y] = b;
        }), r && Gf < 1) {
          var p = parseInt(o.current.paddingRight, 10) || 0, g = document.body ? document.body.clientWidth : 0, h = window.innerWidth - g + p || 0;
          Object.keys(EA).forEach(function(y) {
            var b = EA[y];
            f && (f[y] = b);
          }), f && (f.paddingRight = "".concat(h, "px"));
        }
        c && NA() && (c.addEventListener("touchmove", CA, Nc), u && (u.addEventListener("touchstart", OA, Nc), u.addEventListener("touchmove", PA, Nc))), Gf += 1;
      }
    }, [r]), s = C.useCallback(function(u) {
      if (MA) {
        var c = document.body, f = c && c.style;
        Gf = Math.max(Gf - 1, 0), r && Gf < 1 && _A.forEach(function(p) {
          var g = o.current[p];
          f && (f[p] = g);
        }), c && NA() && (c.removeEventListener("touchmove", CA, Nc), u && (u.removeEventListener("touchstart", OA, Nc), u.removeEventListener("touchmove", PA, Nc)));
      }
    }, [r]);
    return C.useEffect(function() {
      if (t) {
        var u = a.current;
        return i(u), function() {
          s(u);
        };
      }
    }, [t, i, s]), function(u) {
      a.current = u;
    };
  }
  var Xle = function(e) {
    var t = e.target;
    return t.ownerDocument.activeElement && t.ownerDocument.activeElement.blur();
  }, Yle = {
    name: "1kfdb0e",
    styles: "position:fixed;left:0;bottom:0;right:0;top:0"
  };
  function Jle(e) {
    var t = e.children, n = e.lockEnabled, r = e.captureEnabled, o = r === void 0 ? !0 : r, a = e.onBottomArrive, i = e.onBottomLeave, s = e.onTopArrive, u = e.onTopLeave, c = Kle({
      isEnabled: o,
      onBottomArrive: a,
      onBottomLeave: i,
      onTopArrive: s,
      onTopLeave: u
    }), f = Gle({
      isEnabled: n
    }), p = function(g) {
      c(g), f(g);
    };
    return qe(C.Fragment, null, n && qe("div", {
      onClick: Xle,
      css: Yle
    }), t(p));
  }
  var Qle = {
    name: "1a0ro4n-requiredInput",
    styles: "label:requiredInput;opacity:0;pointer-events:none;position:absolute;bottom:0;left:0;right:0;width:100%"
  }, Zle = function(e) {
    var t = e.name, n = e.onFocus;
    return qe("input", {
      required: !0,
      name: t,
      tabIndex: -1,
      "aria-hidden": "true",
      onFocus: n,
      css: Qle,
      value: "",
      onChange: function() {
      }
    });
  }, eue = Zle;
  function YC(e) {
    var t;
    return typeof window < "u" && window.navigator != null ? e.test(((t = window.navigator.userAgentData) === null || t === void 0 ? void 0 : t.platform) || window.navigator.platform) : !1;
  }
  function tue() {
    return YC(/^iPhone/i);
  }
  function L9() {
    return YC(/^Mac/i);
  }
  function nue() {
    return YC(/^iPad/i) || // iPadOS 13 lies and says it's a Mac, but we can distinguish by detecting touch support.
    L9() && navigator.maxTouchPoints > 1;
  }
  function rue() {
    return tue() || nue();
  }
  function oue() {
    return L9() || rue();
  }
  var aue = function(e) {
    return e.label;
  }, iue = function(e) {
    return e.label;
  }, sue = function(e) {
    return e.value;
  }, lue = function(e) {
    return !!e.isDisabled;
  }, uue = {
    clearIndicator: Wse,
    container: Ase,
    control: Qse,
    dropdownIndicator: Use,
    group: nle,
    groupHeading: ole,
    indicatorsContainer: Fse,
    indicatorSeparator: Kse,
    input: lle,
    loadingIndicator: Yse,
    loadingMessage: Nse,
    menu: kse,
    menuList: Cse,
    menuPortal: jse,
    multiValue: ple,
    multiValueLabel: mle,
    multiValueRemove: hle,
    noOptionsMessage: Ose,
    option: xle,
    placeholder: _le,
    singleValue: Ple,
    valueContainer: Dse
  }, cue = {
    primary: "#2684FF",
    primary75: "#4C9AFF",
    primary50: "#B2D4FF",
    primary25: "#DEEBFF",
    danger: "#DE350B",
    dangerLight: "#FFBDAD",
    neutral0: "hsl(0, 0%, 100%)",
    neutral5: "hsl(0, 0%, 95%)",
    neutral10: "hsl(0, 0%, 90%)",
    neutral20: "hsl(0, 0%, 80%)",
    neutral30: "hsl(0, 0%, 70%)",
    neutral40: "hsl(0, 0%, 60%)",
    neutral50: "hsl(0, 0%, 50%)",
    neutral60: "hsl(0, 0%, 40%)",
    neutral70: "hsl(0, 0%, 30%)",
    neutral80: "hsl(0, 0%, 20%)",
    neutral90: "hsl(0, 0%, 10%)"
  }, due = 4, F9 = 4, fue = 38, pue = F9 * 2, mue = {
    baseUnit: F9,
    controlHeight: fue,
    menuGutter: pue
  }, A_ = {
    borderRadius: due,
    colors: cue,
    spacing: mue
  }, hue = {
    "aria-live": "polite",
    backspaceRemovesValue: !0,
    blurInputOnSelect: bA(),
    captureMenuScroll: !bA(),
    classNames: {},
    closeMenuOnSelect: !0,
    closeMenuOnScroll: !1,
    components: {},
    controlShouldRenderValue: !0,
    escapeClearsValue: !1,
    filterOption: Ule(),
    formatGroupLabel: aue,
    getOptionLabel: iue,
    getOptionValue: sue,
    isDisabled: !1,
    isLoading: !1,
    isMulti: !1,
    isRtl: !1,
    isSearchable: !0,
    isOptionDisabled: lue,
    loadingMessage: function() {
      return "Loading...";
    },
    maxMenuHeight: 300,
    minMenuHeight: 140,
    menuIsOpen: !1,
    menuPlacement: "bottom",
    menuPosition: "absolute",
    menuShouldBlockScroll: !1,
    menuShouldScrollIntoView: !fse(),
    noOptionsMessage: function() {
      return "No options";
    },
    openMenuOnFocus: !1,
    openMenuOnClick: !0,
    options: [],
    pageSize: 5,
    placeholder: "Select...",
    screenReaderStatus: function(e) {
      var t = e.count;
      return "".concat(t, " result").concat(t !== 1 ? "s" : "", " available");
    },
    styles: {},
    tabIndex: 0,
    tabSelectsValue: !0,
    unstyled: !1
  };
  function RA(e, t, n, r) {
    var o = B9(e, t, n), a = V9(e, t, n), i = z9(e, t), s = vb(e, t);
    return {
      type: "option",
      data: t,
      isDisabled: o,
      isSelected: a,
      label: i,
      value: s,
      index: r
    };
  }
  function Iy(e, t) {
    return e.options.map(function(n, r) {
      if ("options" in n) {
        var o = n.options.map(function(i, s) {
          return RA(e, i, t, s);
        }).filter(function(i) {
          return IA(e, i);
        });
        return o.length > 0 ? {
          type: "group",
          data: n,
          options: o,
          index: r
        } : void 0;
      }
      var a = RA(e, n, t, r);
      return IA(e, a) ? a : void 0;
    }).filter(hse);
  }
  function T9(e) {
    return e.reduce(function(t, n) {
      return n.type === "group" ? t.push.apply(t, GC(n.options.map(function(r) {
        return r.data;
      }))) : t.push(n.data), t;
    }, []);
  }
  function jA(e, t) {
    return e.reduce(function(n, r) {
      return r.type === "group" ? n.push.apply(n, GC(r.options.map(function(o) {
        return {
          data: o.data,
          id: "".concat(t, "-").concat(r.index, "-").concat(o.index)
        };
      }))) : n.push({
        data: r.data,
        id: "".concat(t, "-").concat(r.index)
      }), n;
    }, []);
  }
  function gue(e, t) {
    return T9(Iy(e, t));
  }
  function IA(e, t) {
    var n = e.inputValue, r = n === void 0 ? "" : n, o = t.data, a = t.isSelected, i = t.label, s = t.value;
    return (!H9(e) || !a) && U9(e, {
      label: i,
      value: s,
      data: o
    }, r);
  }
  function vue(e, t) {
    var n = e.focusedValue, r = e.selectValue, o = r.indexOf(n);
    if (o > -1) {
      var a = t.indexOf(n);
      if (a > -1)
        return n;
      if (o < t.length)
        return t[o];
    }
    return null;
  }
  function yue(e, t) {
    var n = e.focusedOption;
    return n && t.indexOf(n) > -1 ? n : t[0];
  }
  var $_ = function(e, t) {
    var n, r = (n = e.find(function(o) {
      return o.data === t;
    })) === null || n === void 0 ? void 0 : n.id;
    return r || null;
  }, z9 = function(e, t) {
    return e.getOptionLabel(t);
  }, vb = function(e, t) {
    return e.getOptionValue(t);
  };
  function B9(e, t, n) {
    return typeof e.isOptionDisabled == "function" ? e.isOptionDisabled(t, n) : !1;
  }
  function V9(e, t, n) {
    if (n.indexOf(t) > -1) return !0;
    if (typeof e.isOptionSelected == "function")
      return e.isOptionSelected(t, n);
    var r = vb(e, t);
    return n.some(function(o) {
      return vb(e, o) === r;
    });
  }
  function U9(e, t, n) {
    return e.filterOption ? e.filterOption(t, n) : !0;
  }
  var H9 = function(e) {
    var t = e.hideSelectedOptions, n = e.isMulti;
    return t === void 0 ? n : t;
  }, bue = 1, W9 = /* @__PURE__ */ (function(e) {
    Qie(n, e);
    var t = ese(n);
    function n(r) {
      var o;
      if (Yie(this, n), o = t.call(this, r), o.state = {
        ariaSelection: null,
        focusedOption: null,
        focusedOptionId: null,
        focusableOptionsWithIds: [],
        focusedValue: null,
        inputIsHidden: !1,
        isFocused: !1,
        selectValue: [],
        clearFocusValueOnUpdate: !1,
        prevWasFocused: !1,
        inputIsHiddenAfterUpdate: void 0,
        prevProps: void 0,
        instancePrefix: "",
        isAppleDevice: !1
      }, o.blockOptionHover = !1, o.isComposing = !1, o.commonProps = void 0, o.initialTouchX = 0, o.initialTouchY = 0, o.openAfterFocus = !1, o.scrollToFocusedOptionOnUpdate = !1, o.userIsDragging = void 0, o.controlRef = null, o.getControlRef = function(u) {
        o.controlRef = u;
      }, o.focusedOptionRef = null, o.getFocusedOptionRef = function(u) {
        o.focusedOptionRef = u;
      }, o.menuListRef = null, o.getMenuListRef = function(u) {
        o.menuListRef = u;
      }, o.inputRef = null, o.getInputRef = function(u) {
        o.inputRef = u;
      }, o.focus = o.focusInput, o.blur = o.blurInput, o.onChange = function(u, c) {
        var f = o.props, p = f.onChange, g = f.name;
        c.name = g, o.ariaOnChange(u, c), p(u, c);
      }, o.setValue = function(u, c, f) {
        var p = o.props, g = p.closeMenuOnSelect, h = p.isMulti, y = p.inputValue;
        o.onInputChange("", {
          action: "set-value",
          prevInputValue: y
        }), g && (o.setState({
          inputIsHiddenAfterUpdate: !h
        }), o.onMenuClose()), o.setState({
          clearFocusValueOnUpdate: !0
        }), o.onChange(u, {
          action: c,
          option: f
        });
      }, o.selectOption = function(u) {
        var c = o.props, f = c.blurInputOnSelect, p = c.isMulti, g = c.name, h = o.state.selectValue, y = p && o.isOptionSelected(u, h), b = o.isOptionDisabled(u, h);
        if (y) {
          var v = o.getOptionValue(u);
          o.setValue(h.filter(function(w) {
            return o.getOptionValue(w) !== v;
          }), "deselect-option", u);
        } else if (!b)
          p ? o.setValue([].concat(GC(h), [u]), "select-option", u) : o.setValue(u, "select-option");
        else {
          o.ariaOnChange(u, {
            action: "select-option",
            option: u,
            name: g
          });
          return;
        }
        f && o.blurInput();
      }, o.removeValue = function(u) {
        var c = o.props.isMulti, f = o.state.selectValue, p = o.getOptionValue(u), g = f.filter(function(y) {
          return o.getOptionValue(y) !== p;
        }), h = lv(c, g, g[0] || null);
        o.onChange(h, {
          action: "remove-value",
          removedValue: u
        }), o.focusInput();
      }, o.clearValue = function() {
        var u = o.state.selectValue;
        o.onChange(lv(o.props.isMulti, [], null), {
          action: "clear",
          removedValues: u
        });
      }, o.popValue = function() {
        var u = o.props.isMulti, c = o.state.selectValue, f = c[c.length - 1], p = c.slice(0, c.length - 1), g = lv(u, p, p[0] || null);
        f && o.onChange(g, {
          action: "pop-value",
          removedValue: f
        });
      }, o.getFocusedOptionId = function(u) {
        return $_(o.state.focusableOptionsWithIds, u);
      }, o.getFocusableOptionsWithIds = function() {
        return jA(Iy(o.props, o.state.selectValue), o.getElementId("option"));
      }, o.getValue = function() {
        return o.state.selectValue;
      }, o.cx = function() {
        for (var u = arguments.length, c = new Array(u), f = 0; f < u; f++)
          c[f] = arguments[f];
        return sse.apply(void 0, [o.props.classNamePrefix].concat(c));
      }, o.getOptionLabel = function(u) {
        return z9(o.props, u);
      }, o.getOptionValue = function(u) {
        return vb(o.props, u);
      }, o.getStyles = function(u, c) {
        var f = o.props.unstyled, p = uue[u](c, f);
        p.boxSizing = "border-box";
        var g = o.props.styles[u];
        return g ? g(p, c) : p;
      }, o.getClassNames = function(u, c) {
        var f, p;
        return (f = (p = o.props.classNames)[u]) === null || f === void 0 ? void 0 : f.call(p, c);
      }, o.getElementId = function(u) {
        return "".concat(o.state.instancePrefix, "-").concat(u);
      }, o.getComponents = function() {
        return Rle(o.props);
      }, o.buildCategorizedOptions = function() {
        return Iy(o.props, o.state.selectValue);
      }, o.getCategorizedOptions = function() {
        return o.props.menuIsOpen ? o.buildCategorizedOptions() : [];
      }, o.buildFocusableOptions = function() {
        return T9(o.buildCategorizedOptions());
      }, o.getFocusableOptions = function() {
        return o.props.menuIsOpen ? o.buildFocusableOptions() : [];
      }, o.ariaOnChange = function(u, c) {
        o.setState({
          ariaSelection: Ye({
            value: u
          }, c)
        });
      }, o.onMenuMouseDown = function(u) {
        u.button === 0 && (u.stopPropagation(), u.preventDefault(), o.focusInput());
      }, o.onMenuMouseMove = function(u) {
        o.blockOptionHover = !1;
      }, o.onControlMouseDown = function(u) {
        if (!u.defaultPrevented) {
          var c = o.props.openMenuOnClick;
          o.state.isFocused ? o.props.menuIsOpen ? u.target.tagName !== "INPUT" && u.target.tagName !== "TEXTAREA" && o.onMenuClose() : c && o.openMenu("first") : (c && (o.openAfterFocus = !0), o.focusInput()), u.target.tagName !== "INPUT" && u.target.tagName !== "TEXTAREA" && u.preventDefault();
        }
      }, o.onDropdownIndicatorMouseDown = function(u) {
        if (!(u && u.type === "mousedown" && u.button !== 0) && !o.props.isDisabled) {
          var c = o.props, f = c.isMulti, p = c.menuIsOpen;
          o.focusInput(), p ? (o.setState({
            inputIsHiddenAfterUpdate: !f
          }), o.onMenuClose()) : o.openMenu("first"), u.preventDefault();
        }
      }, o.onClearIndicatorMouseDown = function(u) {
        u && u.type === "mousedown" && u.button !== 0 || (o.clearValue(), u.preventDefault(), o.openAfterFocus = !1, u.type === "touchend" ? o.focusInput() : setTimeout(function() {
          return o.focusInput();
        }));
      }, o.onScroll = function(u) {
        typeof o.props.closeMenuOnScroll == "boolean" ? u.target instanceof HTMLElement && Dw(u.target) && o.props.onMenuClose() : typeof o.props.closeMenuOnScroll == "function" && o.props.closeMenuOnScroll(u) && o.props.onMenuClose();
      }, o.onCompositionStart = function() {
        o.isComposing = !0;
      }, o.onCompositionEnd = function() {
        o.isComposing = !1;
      }, o.onTouchStart = function(u) {
        var c = u.touches, f = c && c.item(0);
        f && (o.initialTouchX = f.clientX, o.initialTouchY = f.clientY, o.userIsDragging = !1);
      }, o.onTouchMove = function(u) {
        var c = u.touches, f = c && c.item(0);
        if (f) {
          var p = Math.abs(f.clientX - o.initialTouchX), g = Math.abs(f.clientY - o.initialTouchY), h = 5;
          o.userIsDragging = p > h || g > h;
        }
      }, o.onTouchEnd = function(u) {
        o.userIsDragging || (o.controlRef && !o.controlRef.contains(u.target) && o.menuListRef && !o.menuListRef.contains(u.target) && o.blurInput(), o.initialTouchX = 0, o.initialTouchY = 0);
      }, o.onControlTouchEnd = function(u) {
        o.userIsDragging || o.onControlMouseDown(u);
      }, o.onClearIndicatorTouchEnd = function(u) {
        o.userIsDragging || o.onClearIndicatorMouseDown(u);
      }, o.onDropdownIndicatorTouchEnd = function(u) {
        o.userIsDragging || o.onDropdownIndicatorMouseDown(u);
      }, o.handleInputChange = function(u) {
        var c = o.props.inputValue, f = u.currentTarget.value;
        o.setState({
          inputIsHiddenAfterUpdate: !1
        }), o.onInputChange(f, {
          action: "input-change",
          prevInputValue: c
        }), o.props.menuIsOpen || o.onMenuOpen();
      }, o.onInputFocus = function(u) {
        o.props.onFocus && o.props.onFocus(u), o.setState({
          inputIsHiddenAfterUpdate: !1,
          isFocused: !0
        }), (o.openAfterFocus || o.props.openMenuOnFocus) && o.openMenu("first"), o.openAfterFocus = !1;
      }, o.onInputBlur = function(u) {
        var c = o.props.inputValue;
        if (o.menuListRef && o.menuListRef.contains(document.activeElement)) {
          o.inputRef.focus();
          return;
        }
        o.props.onBlur && o.props.onBlur(u), o.onInputChange("", {
          action: "input-blur",
          prevInputValue: c
        }), o.onMenuClose(), o.setState({
          focusedValue: null,
          isFocused: !1
        });
      }, o.onOptionHover = function(u) {
        if (!(o.blockOptionHover || o.state.focusedOption === u)) {
          var c = o.getFocusableOptions(), f = c.indexOf(u);
          o.setState({
            focusedOption: u,
            focusedOptionId: f > -1 ? o.getFocusedOptionId(u) : null
          });
        }
      }, o.shouldHideSelectedOptions = function() {
        return H9(o.props);
      }, o.onValueInputFocus = function(u) {
        u.preventDefault(), u.stopPropagation(), o.focus();
      }, o.onKeyDown = function(u) {
        var c = o.props, f = c.isMulti, p = c.backspaceRemovesValue, g = c.escapeClearsValue, h = c.inputValue, y = c.isClearable, b = c.isDisabled, v = c.menuIsOpen, w = c.onKeyDown, _ = c.tabSelectsValue, k = c.openMenuOnFocus, E = o.state, P = E.focusedOption, O = E.focusedValue, M = E.selectValue;
        if (!b && !(typeof w == "function" && (w(u), u.defaultPrevented))) {
          switch (o.blockOptionHover = !0, u.key) {
            case "ArrowLeft":
              if (!f || h) return;
              o.focusValue("previous");
              break;
            case "ArrowRight":
              if (!f || h) return;
              o.focusValue("next");
              break;
            case "Delete":
            case "Backspace":
              if (h) return;
              if (O)
                o.removeValue(O);
              else {
                if (!p) return;
                f ? o.popValue() : y && o.clearValue();
              }
              break;
            case "Tab":
              if (o.isComposing || u.shiftKey || !v || !_ || !P || // don't capture the event if the menu opens on focus and the focused
              // option is already selected; it breaks the flow of navigation
              k && o.isOptionSelected(P, M))
                return;
              o.selectOption(P);
              break;
            case "Enter":
              if (u.keyCode === 229)
                break;
              if (v) {
                if (!P || o.isComposing) return;
                o.selectOption(P);
                break;
              }
              return;
            case "Escape":
              v ? (o.setState({
                inputIsHiddenAfterUpdate: !1
              }), o.onInputChange("", {
                action: "menu-close",
                prevInputValue: h
              }), o.onMenuClose()) : y && g && o.clearValue();
              break;
            case " ":
              if (h)
                return;
              if (!v) {
                o.openMenu("first");
                break;
              }
              if (!P) return;
              o.selectOption(P);
              break;
            case "ArrowUp":
              v ? o.focusOption("up") : o.openMenu("last");
              break;
            case "ArrowDown":
              v ? o.focusOption("down") : o.openMenu("first");
              break;
            case "PageUp":
              if (!v) return;
              o.focusOption("pageup");
              break;
            case "PageDown":
              if (!v) return;
              o.focusOption("pagedown");
              break;
            case "Home":
              if (!v) return;
              o.focusOption("first");
              break;
            case "End":
              if (!v) return;
              o.focusOption("last");
              break;
            default:
              return;
          }
          u.preventDefault();
        }
      }, o.state.instancePrefix = "react-select-" + (o.props.instanceId || ++bue), o.state.selectValue = vA(r.value), r.menuIsOpen && o.state.selectValue.length) {
        var a = o.getFocusableOptionsWithIds(), i = o.buildFocusableOptions(), s = i.indexOf(o.state.selectValue[0]);
        o.state.focusableOptionsWithIds = a, o.state.focusedOption = i[s], o.state.focusedOptionId = $_(a, i[s]);
      }
      return o;
    }
    return Jie(n, [{
      key: "componentDidMount",
      value: function() {
        this.startListeningComposition(), this.startListeningToTouch(), this.props.closeMenuOnScroll && document && document.addEventListener && document.addEventListener("scroll", this.onScroll, !0), this.props.autoFocus && this.focusInput(), this.props.menuIsOpen && this.state.focusedOption && this.menuListRef && this.focusedOptionRef && yA(this.menuListRef, this.focusedOptionRef), oue() && this.setState({
          isAppleDevice: !0
        });
      }
    }, {
      key: "componentDidUpdate",
      value: function(r) {
        var o = this.props, a = o.isDisabled, i = o.menuIsOpen, s = this.state.isFocused;
        (s && !a && r.isDisabled || // ensure focus is on the Input when the menu opens
        s && i && !r.menuIsOpen) && this.focusInput(), s && a && !r.isDisabled ? this.setState({
          isFocused: !1
        }, this.onMenuClose) : !s && !a && r.isDisabled && this.inputRef === document.activeElement && this.setState({
          isFocused: !0
        }), this.menuListRef && this.focusedOptionRef && this.scrollToFocusedOptionOnUpdate && (yA(this.menuListRef, this.focusedOptionRef), this.scrollToFocusedOptionOnUpdate = !1);
      }
    }, {
      key: "componentWillUnmount",
      value: function() {
        this.stopListeningComposition(), this.stopListeningToTouch(), document.removeEventListener("scroll", this.onScroll, !0);
      }
      // ==============================
      // Consumer Handlers
      // ==============================
    }, {
      key: "onMenuOpen",
      value: function() {
        this.props.onMenuOpen();
      }
    }, {
      key: "onMenuClose",
      value: function() {
        this.onInputChange("", {
          action: "menu-close",
          prevInputValue: this.props.inputValue
        }), this.props.onMenuClose();
      }
    }, {
      key: "onInputChange",
      value: function(r, o) {
        this.props.onInputChange(r, o);
      }
      // ==============================
      // Methods
      // ==============================
    }, {
      key: "focusInput",
      value: function() {
        this.inputRef && this.inputRef.focus();
      }
    }, {
      key: "blurInput",
      value: function() {
        this.inputRef && this.inputRef.blur();
      }
      // aliased for consumers
    }, {
      key: "openMenu",
      value: function(r) {
        var o = this, a = this.state, i = a.selectValue, s = a.isFocused, u = this.buildFocusableOptions(), c = r === "first" ? 0 : u.length - 1;
        if (!this.props.isMulti) {
          var f = u.indexOf(i[0]);
          f > -1 && (c = f);
        }
        this.scrollToFocusedOptionOnUpdate = !(s && this.menuListRef), this.setState({
          inputIsHiddenAfterUpdate: !1,
          focusedValue: null,
          focusedOption: u[c],
          focusedOptionId: this.getFocusedOptionId(u[c])
        }, function() {
          return o.onMenuOpen();
        });
      }
    }, {
      key: "focusValue",
      value: function(r) {
        var o = this.state, a = o.selectValue, i = o.focusedValue;
        if (this.props.isMulti) {
          this.setState({
            focusedOption: null
          });
          var s = a.indexOf(i);
          i || (s = -1);
          var u = a.length - 1, c = -1;
          if (a.length) {
            switch (r) {
              case "previous":
                s === 0 ? c = 0 : s === -1 ? c = u : c = s - 1;
                break;
              case "next":
                s > -1 && s < u && (c = s + 1);
                break;
            }
            this.setState({
              inputIsHidden: c !== -1,
              focusedValue: a[c]
            });
          }
        }
      }
    }, {
      key: "focusOption",
      value: function() {
        var r = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "first", o = this.props.pageSize, a = this.state.focusedOption, i = this.getFocusableOptions();
        if (i.length) {
          var s = 0, u = i.indexOf(a);
          a || (u = -1), r === "up" ? s = u > 0 ? u - 1 : i.length - 1 : r === "down" ? s = (u + 1) % i.length : r === "pageup" ? (s = u - o, s < 0 && (s = 0)) : r === "pagedown" ? (s = u + o, s > i.length - 1 && (s = i.length - 1)) : r === "last" && (s = i.length - 1), this.scrollToFocusedOptionOnUpdate = !0, this.setState({
            focusedOption: i[s],
            focusedValue: null,
            focusedOptionId: this.getFocusedOptionId(i[s])
          });
        }
      }
    }, {
      key: "getTheme",
      value: (
        // ==============================
        // Getters
        // ==============================
        (function() {
          return this.props.theme ? typeof this.props.theme == "function" ? this.props.theme(A_) : Ye(Ye({}, A_), this.props.theme) : A_;
        })
      )
    }, {
      key: "getCommonProps",
      value: function() {
        var r = this.clearValue, o = this.cx, a = this.getStyles, i = this.getClassNames, s = this.getValue, u = this.selectOption, c = this.setValue, f = this.props, p = f.isMulti, g = f.isRtl, h = f.options, y = this.hasValue();
        return {
          clearValue: r,
          cx: o,
          getStyles: a,
          getClassNames: i,
          getValue: s,
          hasValue: y,
          isMulti: p,
          isRtl: g,
          options: h,
          selectOption: u,
          selectProps: f,
          setValue: c,
          theme: this.getTheme()
        };
      }
    }, {
      key: "hasValue",
      value: function() {
        var r = this.state.selectValue;
        return r.length > 0;
      }
    }, {
      key: "hasOptions",
      value: function() {
        return !!this.getFocusableOptions().length;
      }
    }, {
      key: "isClearable",
      value: function() {
        var r = this.props, o = r.isClearable, a = r.isMulti;
        return o === void 0 ? a : o;
      }
    }, {
      key: "isOptionDisabled",
      value: function(r, o) {
        return B9(this.props, r, o);
      }
    }, {
      key: "isOptionSelected",
      value: function(r, o) {
        return V9(this.props, r, o);
      }
    }, {
      key: "filterOption",
      value: function(r, o) {
        return U9(this.props, r, o);
      }
    }, {
      key: "formatOptionLabel",
      value: function(r, o) {
        if (typeof this.props.formatOptionLabel == "function") {
          var a = this.props.inputValue, i = this.state.selectValue;
          return this.props.formatOptionLabel(r, {
            context: o,
            inputValue: a,
            selectValue: i
          });
        } else
          return this.getOptionLabel(r);
      }
    }, {
      key: "formatGroupLabel",
      value: function(r) {
        return this.props.formatGroupLabel(r);
      }
      // ==============================
      // Mouse Handlers
      // ==============================
    }, {
      key: "startListeningComposition",
      value: (
        // ==============================
        // Composition Handlers
        // ==============================
        (function() {
          document && document.addEventListener && (document.addEventListener("compositionstart", this.onCompositionStart, !1), document.addEventListener("compositionend", this.onCompositionEnd, !1));
        })
      )
    }, {
      key: "stopListeningComposition",
      value: function() {
        document && document.removeEventListener && (document.removeEventListener("compositionstart", this.onCompositionStart), document.removeEventListener("compositionend", this.onCompositionEnd));
      }
    }, {
      key: "startListeningToTouch",
      value: (
        // ==============================
        // Touch Handlers
        // ==============================
        (function() {
          document && document.addEventListener && (document.addEventListener("touchstart", this.onTouchStart, !1), document.addEventListener("touchmove", this.onTouchMove, !1), document.addEventListener("touchend", this.onTouchEnd, !1));
        })
      )
    }, {
      key: "stopListeningToTouch",
      value: function() {
        document && document.removeEventListener && (document.removeEventListener("touchstart", this.onTouchStart), document.removeEventListener("touchmove", this.onTouchMove), document.removeEventListener("touchend", this.onTouchEnd));
      }
    }, {
      key: "renderInput",
      value: (
        // ==============================
        // Renderers
        // ==============================
        (function() {
          var r = this.props, o = r.isDisabled, a = r.isSearchable, i = r.inputId, s = r.inputValue, u = r.tabIndex, c = r.form, f = r.menuIsOpen, p = r.required, g = this.getComponents(), h = g.Input, y = this.state, b = y.inputIsHidden, v = y.ariaSelection, w = this.commonProps, _ = i || this.getElementId("input"), k = Ye(Ye(Ye({
            "aria-autocomplete": "list",
            "aria-expanded": f,
            "aria-haspopup": !0,
            "aria-errormessage": this.props["aria-errormessage"],
            "aria-invalid": this.props["aria-invalid"],
            "aria-label": this.props["aria-label"],
            "aria-labelledby": this.props["aria-labelledby"],
            "aria-required": p,
            role: "combobox",
            "aria-activedescendant": this.state.isAppleDevice ? void 0 : this.state.focusedOptionId || ""
          }, f && {
            "aria-controls": this.getElementId("listbox")
          }), !a && {
            "aria-readonly": !0
          }), this.hasValue() ? v?.action === "initial-input-focus" && {
            "aria-describedby": this.getElementId("live-region")
          } : {
            "aria-describedby": this.getElementId("placeholder")
          });
          return a ? /* @__PURE__ */ C.createElement(h, Ge({}, w, {
            autoCapitalize: "none",
            autoComplete: "off",
            autoCorrect: "off",
            id: _,
            innerRef: this.getInputRef,
            isDisabled: o,
            isHidden: b,
            onBlur: this.onInputBlur,
            onChange: this.handleInputChange,
            onFocus: this.onInputFocus,
            spellCheck: "false",
            tabIndex: u,
            form: c,
            type: "text",
            value: s
          }, k)) : /* @__PURE__ */ C.createElement(Wle, Ge({
            id: _,
            innerRef: this.getInputRef,
            onBlur: this.onInputBlur,
            onChange: hb,
            onFocus: this.onInputFocus,
            disabled: o,
            tabIndex: u,
            inputMode: "none",
            form: c,
            value: ""
          }, k));
        })
      )
    }, {
      key: "renderPlaceholderOrValue",
      value: function() {
        var r = this, o = this.getComponents(), a = o.MultiValue, i = o.MultiValueContainer, s = o.MultiValueLabel, u = o.MultiValueRemove, c = o.SingleValue, f = o.Placeholder, p = this.commonProps, g = this.props, h = g.controlShouldRenderValue, y = g.isDisabled, b = g.isMulti, v = g.inputValue, w = g.placeholder, _ = this.state, k = _.selectValue, E = _.focusedValue, P = _.isFocused;
        if (!this.hasValue() || !h)
          return v ? null : /* @__PURE__ */ C.createElement(f, Ge({}, p, {
            key: "placeholder",
            isDisabled: y,
            isFocused: P,
            innerProps: {
              id: this.getElementId("placeholder")
            }
          }), w);
        if (b)
          return k.map(function(M, I) {
            var A = M === E, D = "".concat(r.getOptionLabel(M), "-").concat(r.getOptionValue(M));
            return /* @__PURE__ */ C.createElement(a, Ge({}, p, {
              components: {
                Container: i,
                Label: s,
                Remove: u
              },
              isFocused: A,
              isDisabled: y,
              key: D,
              index: I,
              removeProps: {
                onClick: function() {
                  return r.removeValue(M);
                },
                onTouchEnd: function() {
                  return r.removeValue(M);
                },
                onMouseDown: function(F) {
                  F.preventDefault();
                }
              },
              data: M
            }), r.formatOptionLabel(M, "value"));
          });
        if (v)
          return null;
        var O = k[0];
        return /* @__PURE__ */ C.createElement(c, Ge({}, p, {
          data: O,
          isDisabled: y
        }), this.formatOptionLabel(O, "value"));
      }
    }, {
      key: "renderClearIndicator",
      value: function() {
        var r = this.getComponents(), o = r.ClearIndicator, a = this.commonProps, i = this.props, s = i.isDisabled, u = i.isLoading, c = this.state.isFocused;
        if (!this.isClearable() || !o || s || !this.hasValue() || u)
          return null;
        var f = {
          onMouseDown: this.onClearIndicatorMouseDown,
          onTouchEnd: this.onClearIndicatorTouchEnd,
          "aria-hidden": "true"
        };
        return /* @__PURE__ */ C.createElement(o, Ge({}, a, {
          innerProps: f,
          isFocused: c
        }));
      }
    }, {
      key: "renderLoadingIndicator",
      value: function() {
        var r = this.getComponents(), o = r.LoadingIndicator, a = this.commonProps, i = this.props, s = i.isDisabled, u = i.isLoading, c = this.state.isFocused;
        if (!o || !u) return null;
        var f = {
          "aria-hidden": "true"
        };
        return /* @__PURE__ */ C.createElement(o, Ge({}, a, {
          innerProps: f,
          isDisabled: s,
          isFocused: c
        }));
      }
    }, {
      key: "renderIndicatorSeparator",
      value: function() {
        var r = this.getComponents(), o = r.DropdownIndicator, a = r.IndicatorSeparator;
        if (!o || !a) return null;
        var i = this.commonProps, s = this.props.isDisabled, u = this.state.isFocused;
        return /* @__PURE__ */ C.createElement(a, Ge({}, i, {
          isDisabled: s,
          isFocused: u
        }));
      }
    }, {
      key: "renderDropdownIndicator",
      value: function() {
        var r = this.getComponents(), o = r.DropdownIndicator;
        if (!o) return null;
        var a = this.commonProps, i = this.props.isDisabled, s = this.state.isFocused, u = {
          onMouseDown: this.onDropdownIndicatorMouseDown,
          onTouchEnd: this.onDropdownIndicatorTouchEnd,
          "aria-hidden": "true"
        };
        return /* @__PURE__ */ C.createElement(o, Ge({}, a, {
          innerProps: u,
          isDisabled: i,
          isFocused: s
        }));
      }
    }, {
      key: "renderMenu",
      value: function() {
        var r = this, o = this.getComponents(), a = o.Group, i = o.GroupHeading, s = o.Menu, u = o.MenuList, c = o.MenuPortal, f = o.LoadingMessage, p = o.NoOptionsMessage, g = o.Option, h = this.commonProps, y = this.state.focusedOption, b = this.props, v = b.captureMenuScroll, w = b.inputValue, _ = b.isLoading, k = b.loadingMessage, E = b.minMenuHeight, P = b.maxMenuHeight, O = b.menuIsOpen, M = b.menuPlacement, I = b.menuPosition, A = b.menuPortalTarget, D = b.menuShouldBlockScroll, F = b.menuShouldScrollIntoView, j = b.noOptionsMessage, U = b.onMenuScrollToTop, $ = b.onMenuScrollToBottom;
        if (!O) return null;
        var q = function(L, K) {
          var T = L.type, V = L.data, X = L.isDisabled, Q = L.isSelected, ne = L.label, te = L.value, ae = y === V, ce = X ? void 0 : function() {
            return r.onOptionHover(V);
          }, Z = X ? void 0 : function() {
            return r.selectOption(V);
          }, ee = "".concat(r.getElementId("option"), "-").concat(K), oe = {
            id: ee,
            onClick: Z,
            onMouseMove: ce,
            onMouseOver: ce,
            tabIndex: -1,
            role: "option",
            "aria-selected": r.state.isAppleDevice ? void 0 : Q
            // is not supported on Apple devices
          };
          return /* @__PURE__ */ C.createElement(g, Ge({}, h, {
            innerProps: oe,
            data: V,
            isDisabled: X,
            isSelected: Q,
            key: ee,
            label: ne,
            type: T,
            value: te,
            isFocused: ae,
            innerRef: ae ? r.getFocusedOptionRef : void 0
          }), r.formatOptionLabel(L.data, "menu"));
        }, B;
        if (this.hasOptions())
          B = this.getCategorizedOptions().map(function(L) {
            if (L.type === "group") {
              var K = L.data, T = L.options, V = L.index, X = "".concat(r.getElementId("group"), "-").concat(V), Q = "".concat(X, "-heading");
              return /* @__PURE__ */ C.createElement(a, Ge({}, h, {
                key: X,
                data: K,
                options: T,
                Heading: i,
                headingProps: {
                  id: Q,
                  data: L.data
                },
                label: r.formatGroupLabel(L.data)
              }), L.options.map(function(ne) {
                return q(ne, "".concat(V, "-").concat(ne.index));
              }));
            } else if (L.type === "option")
              return q(L, "".concat(L.index));
          });
        else if (_) {
          var G = k({
            inputValue: w
          });
          if (G === null) return null;
          B = /* @__PURE__ */ C.createElement(f, h, G);
        } else {
          var W = j({
            inputValue: w
          });
          if (W === null) return null;
          B = /* @__PURE__ */ C.createElement(p, h, W);
        }
        var Y = {
          minMenuHeight: E,
          maxMenuHeight: P,
          menuPlacement: M,
          menuPosition: I,
          menuShouldScrollIntoView: F
        }, z = /* @__PURE__ */ C.createElement(Sse, Ge({}, h, Y), function(L) {
          var K = L.ref, T = L.placerProps, V = T.placement, X = T.maxHeight;
          return /* @__PURE__ */ C.createElement(s, Ge({}, h, Y, {
            innerRef: K,
            innerProps: {
              onMouseDown: r.onMenuMouseDown,
              onMouseMove: r.onMenuMouseMove
            },
            isLoading: _,
            placement: V
          }), /* @__PURE__ */ C.createElement(Jle, {
            captureEnabled: v,
            onTopArrive: U,
            onBottomArrive: $,
            lockEnabled: D
          }, function(Q) {
            return /* @__PURE__ */ C.createElement(u, Ge({}, h, {
              innerRef: function(ne) {
                r.getMenuListRef(ne), Q(ne);
              },
              innerProps: {
                role: "listbox",
                "aria-multiselectable": h.isMulti,
                id: r.getElementId("listbox")
              },
              isLoading: _,
              maxHeight: X,
              focusedOption: y
            }), B);
          }));
        });
        return A || I === "fixed" ? /* @__PURE__ */ C.createElement(c, Ge({}, h, {
          appendTo: A,
          controlElement: this.controlRef,
          menuPlacement: M,
          menuPosition: I
        }), z) : z;
      }
    }, {
      key: "renderFormField",
      value: function() {
        var r = this, o = this.props, a = o.delimiter, i = o.isDisabled, s = o.isMulti, u = o.name, c = o.required, f = this.state.selectValue;
        if (c && !this.hasValue() && !i)
          return /* @__PURE__ */ C.createElement(eue, {
            name: u,
            onFocus: this.onValueInputFocus
          });
        if (!(!u || i))
          if (s)
            if (a) {
              var p = f.map(function(y) {
                return r.getOptionValue(y);
              }).join(a);
              return /* @__PURE__ */ C.createElement("input", {
                name: u,
                type: "hidden",
                value: p
              });
            } else {
              var g = f.length > 0 ? f.map(function(y, b) {
                return /* @__PURE__ */ C.createElement("input", {
                  key: "i-".concat(b),
                  name: u,
                  type: "hidden",
                  value: r.getOptionValue(y)
                });
              }) : /* @__PURE__ */ C.createElement("input", {
                name: u,
                type: "hidden",
                value: ""
              });
              return /* @__PURE__ */ C.createElement("div", null, g);
            }
          else {
            var h = f[0] ? this.getOptionValue(f[0]) : "";
            return /* @__PURE__ */ C.createElement("input", {
              name: u,
              type: "hidden",
              value: h
            });
          }
      }
    }, {
      key: "renderLiveRegion",
      value: function() {
        var r = this.commonProps, o = this.state, a = o.ariaSelection, i = o.focusedOption, s = o.focusedValue, u = o.isFocused, c = o.selectValue, f = this.getFocusableOptions();
        return /* @__PURE__ */ C.createElement(Tle, Ge({}, r, {
          id: this.getElementId("live-region"),
          ariaSelection: a,
          focusedOption: i,
          focusedValue: s,
          isFocused: u,
          selectValue: c,
          focusableOptions: f,
          isAppleDevice: this.state.isAppleDevice
        }));
      }
    }, {
      key: "render",
      value: function() {
        var r = this.getComponents(), o = r.Control, a = r.IndicatorsContainer, i = r.SelectContainer, s = r.ValueContainer, u = this.props, c = u.className, f = u.id, p = u.isDisabled, g = u.menuIsOpen, h = this.state.isFocused, y = this.commonProps = this.getCommonProps();
        return /* @__PURE__ */ C.createElement(i, Ge({}, y, {
          className: c,
          innerProps: {
            id: f,
            onKeyDown: this.onKeyDown
          },
          isDisabled: p,
          isFocused: h
        }), this.renderLiveRegion(), /* @__PURE__ */ C.createElement(o, Ge({}, y, {
          innerRef: this.getControlRef,
          innerProps: {
            onMouseDown: this.onControlMouseDown,
            onTouchEnd: this.onControlTouchEnd
          },
          isDisabled: p,
          isFocused: h,
          menuIsOpen: g
        }), /* @__PURE__ */ C.createElement(s, Ge({}, y, {
          isDisabled: p
        }), this.renderPlaceholderOrValue(), this.renderInput()), /* @__PURE__ */ C.createElement(a, Ge({}, y, {
          isDisabled: p
        }), this.renderClearIndicator(), this.renderLoadingIndicator(), this.renderIndicatorSeparator(), this.renderDropdownIndicator())), this.renderMenu(), this.renderFormField());
      }
    }], [{
      key: "getDerivedStateFromProps",
      value: function(r, o) {
        var a = o.prevProps, i = o.clearFocusValueOnUpdate, s = o.inputIsHiddenAfterUpdate, u = o.ariaSelection, c = o.isFocused, f = o.prevWasFocused, p = o.instancePrefix, g = r.options, h = r.value, y = r.menuIsOpen, b = r.inputValue, v = r.isMulti, w = vA(h), _ = {};
        if (a && (h !== a.value || g !== a.options || y !== a.menuIsOpen || b !== a.inputValue)) {
          var k = y ? gue(r, w) : [], E = y ? jA(Iy(r, w), "".concat(p, "-option")) : [], P = i ? vue(o, w) : null, O = yue(o, k), M = $_(E, O);
          _ = {
            selectValue: w,
            focusedOption: O,
            focusedOptionId: M,
            focusableOptionsWithIds: E,
            focusedValue: P,
            clearFocusValueOnUpdate: !1
          };
        }
        var I = s != null && r !== a ? {
          inputIsHidden: s,
          inputIsHiddenAfterUpdate: void 0
        } : {}, A = u, D = c && f;
        return c && !D && (A = {
          value: lv(v, w, w[0] || null),
          options: w,
          action: "initial-input-focus"
        }, D = !f), u?.action === "initial-input-focus" && (A = null), Ye(Ye(Ye({}, _), I), {}, {
          prevProps: r,
          ariaSelection: A,
          prevWasFocused: D
        });
      }
    }]), n;
  })(C.Component);
  W9.defaultProps = hue;
  var wue = /* @__PURE__ */ C.forwardRef(function(e, t) {
    var n = Xie(e);
    return /* @__PURE__ */ C.createElement(W9, Ge({
      ref: t
    }, n));
  }), xue = wue;
  const kue = ({
    options: e,
    items_per_page: t,
    className: n,
    defaultValue: r,
    onChange: o
  }) => {
    const [a, i] = C.useState(""), [s, u] = C.useState(0), c = (h) => {
      i(h.toLowerCase()), u(0);
    }, f = e.filter((h) => h.label.toLowerCase().includes(a) || h.value.toLowerCase().includes(a));
    var p;
    t !== void 0 ? p = f.slice(
      s * t,
      (s + 1) * t
    ) : p = f;
    const g = {
      control: (h) => ({
        ...h,
        minHeight: void 0
      })
    };
    return /* @__PURE__ */ S.jsx(
      xue,
      {
        options: p,
        onInputChange: c,
        onChange: o,
        inputValue: a,
        isSearchable: !0,
        placeholder: "Select an option...",
        className: n,
        unstyled: !0,
        styles: g,
        classNamePrefix: "styled-select",
        defaultValue: r,
        value: r
      }
    );
  }, Sue = (e) => typeof e == "boolean" || e instanceof Boolean, _ue = (e) => typeof e == "number" || e instanceof Number, Eue = (e) => typeof e == "bigint" || e instanceof BigInt, q9 = (e) => !!e && e instanceof Date, Cue = (e) => typeof e == "string" || e instanceof String, Pue = (e) => Array.isArray(e), K9 = (e) => typeof e == "object" && e !== null, G9 = (e) => !!e && e instanceof Object && typeof e == "function";
  function yb(e, t) {
    return t === void 0 && (t = !1), !e || t ? `"${e}"` : e;
  }
  function Oue(e, t, n) {
    return n ? JSON.stringify(e) : t ? `"${e}"` : e;
  }
  function X9(e) {
    let {
      field: t,
      value: n,
      data: r,
      lastElement: o,
      openBracket: a,
      closeBracket: i,
      level: s,
      style: u,
      shouldExpandNode: c,
      clickToExpandNode: f,
      outerRef: p,
      beforeExpandChange: g
    } = e;
    const h = C.useRef(!1), [y, b] = C.useState(() => c(s, n, t)), v = C.useRef(null);
    C.useEffect(() => {
      h.current ? b(c(s, n, t)) : h.current = !0;
    }, [c]);
    const w = C.useId();
    if (r.length === 0)
      return Nue({
        field: t,
        openBracket: a,
        closeBracket: i,
        lastElement: o,
        style: u
      });
    const _ = y ? u.collapseIcon : u.expandIcon, k = y ? u.ariaLables.collapseJson : u.ariaLables.expandJson, E = s + 1, P = r.length - 1, O = (A) => {
      y !== A && (!g || g({
        level: s,
        value: n,
        field: t,
        newExpandValue: A
      })) && b(A);
    }, M = (A) => {
      if (A.key === "ArrowRight" || A.key === "ArrowLeft")
        A.preventDefault(), O(A.key === "ArrowRight");
      else if (A.key === "ArrowUp" || A.key === "ArrowDown") {
        A.preventDefault();
        const D = A.key === "ArrowUp" ? -1 : 1;
        if (!p.current) return;
        const F = p.current.querySelectorAll("[role=button]");
        let j = -1;
        for (let $ = 0; $ < F.length; $++)
          if (F[$].tabIndex === 0) {
            j = $;
            break;
          }
        if (j < 0)
          return;
        const U = (j + D + F.length) % F.length;
        F[j].tabIndex = -1, F[U].tabIndex = 0, F[U].focus();
      }
    }, I = () => {
      var A;
      O(!y);
      const D = v.current;
      if (!D) return;
      const F = (A = p.current) === null || A === void 0 ? void 0 : A.querySelector('[role=button][tabindex="0"]');
      F && (F.tabIndex = -1), D.tabIndex = 0, D.focus();
    };
    return /* @__PURE__ */ C.createElement("div", {
      className: u.basicChildStyle,
      role: "treeitem",
      "aria-expanded": y,
      "aria-selected": void 0
    }, /* @__PURE__ */ C.createElement("span", {
      className: _,
      onClick: I,
      onKeyDown: M,
      role: "button",
      "aria-label": k,
      "aria-expanded": y,
      "aria-controls": y ? w : void 0,
      ref: v,
      tabIndex: s === 0 ? 0 : -1
    }), (t || t === "") && (f ? /* @__PURE__ */ C.createElement("span", {
      className: u.clickableLabel,
      onClick: I,
      onKeyDown: M
    }, yb(t, u.quotesForFieldNames), ":") : /* @__PURE__ */ C.createElement("span", {
      className: u.label
    }, yb(t, u.quotesForFieldNames), ":")), /* @__PURE__ */ C.createElement("span", {
      className: u.punctuation
    }, a), y ? /* @__PURE__ */ C.createElement("ul", {
      id: w,
      role: "group",
      className: u.childFieldsContainer
    }, r.map((A, D) => /* @__PURE__ */ C.createElement(A2, {
      key: A[0] || D,
      field: A[0],
      value: A[1],
      style: u,
      lastElement: D === P,
      level: E,
      shouldExpandNode: c,
      clickToExpandNode: f,
      beforeExpandChange: g,
      outerRef: p
    }))) : /* @__PURE__ */ C.createElement("span", {
      className: u.collapsedContent,
      onClick: I,
      onKeyDown: M
    }), /* @__PURE__ */ C.createElement("span", {
      className: u.punctuation
    }, i), !o && /* @__PURE__ */ C.createElement("span", {
      className: u.punctuation
    }, ","));
  }
  function Nue(e) {
    let {
      field: t,
      openBracket: n,
      closeBracket: r,
      lastElement: o,
      style: a
    } = e;
    return /* @__PURE__ */ C.createElement("div", {
      className: a.basicChildStyle,
      role: "treeitem",
      "aria-selected": void 0
    }, (t || t === "") && /* @__PURE__ */ C.createElement("span", {
      className: a.label
    }, yb(t, a.quotesForFieldNames), ":"), /* @__PURE__ */ C.createElement("span", {
      className: a.punctuation
    }, n), /* @__PURE__ */ C.createElement("span", {
      className: a.punctuation
    }, r), !o && /* @__PURE__ */ C.createElement("span", {
      className: a.punctuation
    }, ","));
  }
  function Mue(e) {
    let {
      field: t,
      value: n,
      style: r,
      lastElement: o,
      shouldExpandNode: a,
      clickToExpandNode: i,
      level: s,
      outerRef: u,
      beforeExpandChange: c
    } = e;
    return X9({
      field: t,
      value: n,
      lastElement: o || !1,
      level: s,
      openBracket: "{",
      closeBracket: "}",
      style: r,
      shouldExpandNode: a,
      clickToExpandNode: i,
      data: Object.keys(n).map((f) => [f, n[f]]),
      outerRef: u,
      beforeExpandChange: c
    });
  }
  function Rue(e) {
    let {
      field: t,
      value: n,
      style: r,
      lastElement: o,
      level: a,
      shouldExpandNode: i,
      clickToExpandNode: s,
      outerRef: u,
      beforeExpandChange: c
    } = e;
    return X9({
      field: t,
      value: n,
      lastElement: o || !1,
      level: a,
      openBracket: "[",
      closeBracket: "]",
      style: r,
      shouldExpandNode: i,
      clickToExpandNode: s,
      data: n.map((f) => [void 0, f]),
      outerRef: u,
      beforeExpandChange: c
    });
  }
  function jue(e) {
    let {
      field: t,
      value: n,
      style: r,
      lastElement: o
    } = e, a, i = r.otherValue;
    return n === null ? (a = "null", i = r.nullValue) : n === void 0 ? (a = "undefined", i = r.undefinedValue) : Cue(n) ? (a = Oue(n, !r.noQuotesForStringValues, r.stringifyStringValues), i = r.stringValue) : Sue(n) ? (a = n ? "true" : "false", i = r.booleanValue) : _ue(n) ? (a = n.toString(), i = r.numberValue) : Eue(n) ? (a = `${n.toString()}n`, i = r.numberValue) : q9(n) ? a = n.toISOString() : G9(n) ? a = "function() { }" : a = n.toString(), /* @__PURE__ */ C.createElement("div", {
      className: r.basicChildStyle,
      role: "treeitem",
      "aria-selected": void 0
    }, (t || t === "") && /* @__PURE__ */ C.createElement("span", {
      className: r.label
    }, yb(t, r.quotesForFieldNames), ":"), /* @__PURE__ */ C.createElement("span", {
      className: i
    }, a), !o && /* @__PURE__ */ C.createElement("span", {
      className: r.punctuation
    }, ","));
  }
  function A2(e) {
    const t = e.value;
    return Pue(t) ? /* @__PURE__ */ C.createElement(Rue, Object.assign({}, e)) : K9(t) && !q9(t) && !G9(t) ? /* @__PURE__ */ C.createElement(Mue, Object.assign({}, e)) : /* @__PURE__ */ C.createElement(jue, Object.assign({}, e));
  }
  var Wt = { "container-light": "_2IvMF _GzYRV", "basic-element-style": "_2bkNM", "child-fields-container": "_1BXBN", "label-light": "_1MGIk", "clickable-label-light": "_2YKJg _1MGIk _1MFti", "punctuation-light": "_3uHL6 _3eOF8", "value-null-light": "_2T6PJ", "value-undefined-light": "_1Gho6", "value-string-light": "_vGjyY", "value-number-light": "_1bQdo", "value-boolean-light": "_3zQKs", "value-other-light": "_1xvuR", "collapse-icon-light": "_oLqym _f10Tu _1MFti _1LId0", "expand-icon-light": "_2AXVT _f10Tu _1MFti _1UmXx", "collapsed-content-light": "_2KJWg _1pNG9 _1MFti", "container-dark": "_11RoI _GzYRV", "expand-icon-dark": "_17H2C _f10Tu _1MFti _1UmXx", "collapse-icon-dark": "_3QHg2 _f10Tu _1MFti _1LId0", "collapsed-content-dark": "_3fDAz _1pNG9 _1MFti", "label-dark": "_2bSDX", "clickable-label-dark": "_1RQEj _2bSDX _1MFti", "punctuation-dark": "_gsbQL _3eOF8", "value-null-dark": "_LaAZe", "value-undefined-dark": "_GTKgm", "value-string-dark": "_Chy1W", "value-number-dark": "_2bveF", "value-boolean-dark": "_2vRm-", "value-other-dark": "_1prJR" };
  const Y9 = {
    collapseJson: "collapse JSON",
    expandJson: "expand JSON"
  }, D_ = {
    container: Wt["container-light"],
    basicChildStyle: Wt["basic-element-style"],
    childFieldsContainer: Wt["child-fields-container"],
    label: Wt["label-light"],
    clickableLabel: Wt["clickable-label-light"],
    nullValue: Wt["value-null-light"],
    undefinedValue: Wt["value-undefined-light"],
    stringValue: Wt["value-string-light"],
    booleanValue: Wt["value-boolean-light"],
    numberValue: Wt["value-number-light"],
    otherValue: Wt["value-other-light"],
    punctuation: Wt["punctuation-light"],
    collapseIcon: Wt["collapse-icon-light"],
    expandIcon: Wt["expand-icon-light"],
    collapsedContent: Wt["collapsed-content-light"],
    noQuotesForStringValues: !1,
    quotesForFieldNames: !1,
    ariaLables: Y9,
    stringifyStringValues: !1
  }, Iue = {
    container: Wt["container-dark"],
    basicChildStyle: Wt["basic-element-style"],
    childFieldsContainer: Wt["child-fields-container"],
    label: Wt["label-dark"],
    clickableLabel: Wt["clickable-label-dark"],
    nullValue: Wt["value-null-dark"],
    undefinedValue: Wt["value-undefined-dark"],
    stringValue: Wt["value-string-dark"],
    booleanValue: Wt["value-boolean-dark"],
    numberValue: Wt["value-number-dark"],
    otherValue: Wt["value-other-dark"],
    punctuation: Wt["punctuation-dark"],
    collapseIcon: Wt["collapse-icon-dark"],
    expandIcon: Wt["expand-icon-dark"],
    collapsedContent: Wt["collapsed-content-dark"],
    noQuotesForStringValues: !1,
    quotesForFieldNames: !1,
    ariaLables: Y9,
    stringifyStringValues: !1
  }, Aue = () => !0, $ue = (e) => e < 1, Due = (e) => {
    let {
      data: t,
      style: n = D_,
      shouldExpandNode: r = Aue,
      clickToExpandNode: o = !1,
      beforeExpandChange: a,
      compactTopLevel: i,
      ...s
    } = e;
    const u = C.useRef(null);
    return /* @__PURE__ */ C.createElement("div", Object.assign({
      "aria-label": "JSON view"
    }, s, {
      className: n.container,
      ref: u,
      role: "tree"
    }), i && K9(t) ? Object.entries(t).map((c) => {
      let [f, p] = c;
      return /* @__PURE__ */ C.createElement(A2, {
        key: f,
        field: f,
        value: p,
        style: {
          ...D_,
          ...n
        },
        lastElement: !0,
        level: 1,
        shouldExpandNode: r,
        clickToExpandNode: o,
        beforeExpandChange: a,
        outerRef: u
      });
    }) : /* @__PURE__ */ C.createElement(A2, {
      value: t,
      style: {
        ...D_,
        ...n
      },
      lastElement: !0,
      level: 0,
      shouldExpandNode: r,
      clickToExpandNode: o,
      outerRef: u,
      beforeExpandChange: a
    }));
  };
  function Lue(e) {
    for (const t in e)
      if (Object.hasOwn(e, t))
        return !1;
    return !0;
  }
  function Fue(e) {
    if (e == null || typeof e != "object")
      return !1;
    const t = Object.getPrototypeOf(e);
    return t !== null && t !== Object.prototype ? !1 : Lue(e);
  }
  const Tue = ({
    data: e,
    className: t = "json-display"
  }) => /* @__PURE__ */ S.jsx("div", { className: t, children: /* @__PURE__ */ S.jsx(
    Due,
    {
      data: Fue(e) ? "" : e,
      style: Iue,
      shouldExpandNode: $ue
    }
  ) });
  function zue(e, t, n = {}) {
    const {
      maxFontSize: r = 100,
      // default maximum font size
      minFontSize: o = 6,
      // default minimum font size
      decrementFactor: a = 0.9
      // font size decrement step
    } = n;
    if (!e || !t)
      return;
    if (a >= 1 || a <= 0)
      throw new Error("decrementFactor must be between 0 and 1");
    const i = e.getBoundingClientRect(), s = i.width, u = i.height;
    let c = r;
    t.style.whiteSpace = "nowrap", t.style.display = "inline-block", t.style.fontSize = c + "px";
    let f = t.getBoundingClientRect();
    for (; (f.width > s || f.height > u) && c > o; )
      c *= a, t.style.fontSize = c + "px", f = t.getBoundingClientRect();
  }
  function Bue(e = {
    n: 0,
    elapsed: 0,
    ascii: !1,
    unit: "it",
    unit_scale: !1,
    unit_divisor: 1e3
  }) {
    let t = e.total ?? null;
    const {
      n = 0,
      unit_scale: r = !1,
      elapsed: o = 0,
      // ascii,
      unit: a = "it",
      unit_divisor: i = 1e3,
      // ncols = undefined,
      prefix: s = "",
      rate: u = void 0,
      // bar_format = undefined,
      postfix: c = null,
      initial: f = 0
      // colour = undefined,
    } = e;
    t !== null && n >= t + 0.5 && (t = null);
    let p = n, g = t, h = u;
    r && r !== !0 && r !== 1 && (t !== null && (g = t * r), p = n * r, u !== void 0 && (h = u * r));
    const y = AA(o);
    h === void 0 && o > 0 && (h = (p - f) / o);
    const b = h ? 1 / h : void 0, [v, w] = h ? uv(h, i) : [void 0, ""], [_, k] = b ? uv(b, 1e3) : [void 0, ""], E = (v || "?") + `${w}${a}/s`, P = _ ? `${_}${k}s/` + a : "?", O = b && b > 1 ? P : E, M = r ? uv(p, i).join("") : p.toString(), I = r && g !== null ? uv(g, i).join("") : g?.toString() ?? "?", A = h && g !== null ? (g - p) / h : 0, D = h ? AA(A) : "?", F = s ? `${s}: ` : "";
    if (t !== null) {
      const j = p / t * 100, U = ` ${M}/${I} [${y} < ${D}, ${O}${c ?? ""}]`;
      return `${F}${j.toFixed(0)}%${U}`;
    }
    return `${F}${M}${a} [${y}, ${O}${c ?? ""}]`;
  }
  function AA(e) {
    const t = Math.floor(e / 60), n = Math.floor(e % 60);
    return `${t}:${n.toString().padStart(2, "0")}`;
  }
  function uv(e, t) {
    const n = ["", "K", "M", "G", "T"];
    let r = 0;
    for (; e >= t && r < n.length - 1; )
      e /= t, r++;
    return [e.toFixed(2), n[r]];
  }
  const Vue = ({ state: e, className: t = "reacttqdm", ...n }) => {
    const r = C.useRef(null), o = C.useRef(null);
    C.useEffect(() => {
      const i = () => {
        !r.current || !o.current || zue(r.current, o.current, {
          maxFontSize: 12,
          decrementFactor: 0.9
        });
      };
      return i(), window.addEventListener("resize", i), () => {
        window.removeEventListener("resize", i);
      };
    }, [e]);
    const a = e.total ? (e.n ?? 0) / e.total * 100 : 0;
    return /* @__PURE__ */ S.jsx("div", { ref: r, className: t, ...n, children: /* @__PURE__ */ S.jsxs(
      "div",
      {
        style: {
          position: "relative",
          display: "flex",
          flexDirection: "column",
          justifyContent: "center",
          alignItems: "center"
        },
        children: [
          /* @__PURE__ */ S.jsx(
            "div",
            {
              className: t + "-bar",
              style: {
                position: "absolute",
                width: "100%",
                height: "100%",
                // Adjust height if needed
                overflow: "hidden"
              },
              children: /* @__PURE__ */ S.jsx(
                "div",
                {
                  className: t + "-progress",
                  style: {
                    width: `${a}%`,
                    height: "100%"
                  }
                }
              )
            }
          ),
          /* @__PURE__ */ S.jsx("div", { className: t + "-text", ref: o, children: Bue(e) })
        ]
      }
    ) });
  };
  var cv = {}, $A;
  function Uue() {
    if ($A) return cv;
    $A = 1;
    var e = /; *([!#$%&'*+.^_`|~0-9A-Za-z-]+) *= *("(?:[\u000b\u0020\u0021\u0023-\u005b\u005d-\u007e\u0080-\u00ff]|\\[\u000b\u0020-\u00ff])*"|[!#$%&'*+.^_`|~0-9A-Za-z-]+) */g, t = /^[\u000b\u0020-\u007e\u0080-\u00ff]+$/, n = /^[!#$%&'*+.^_`|~0-9A-Za-z-]+$/, r = /\\([\u000b\u0020-\u00ff])/g, o = /([\\"])/g, a = /^[!#$%&'*+.^_`|~0-9A-Za-z-]+\/[!#$%&'*+.^_`|~0-9A-Za-z-]+$/;
    cv.format = i, cv.parse = s;
    function i(p) {
      if (!p || typeof p != "object")
        throw new TypeError("argument obj is required");
      var g = p.parameters, h = p.type;
      if (!h || !a.test(h))
        throw new TypeError("invalid type");
      var y = h;
      if (g && typeof g == "object")
        for (var b, v = Object.keys(g).sort(), w = 0; w < v.length; w++) {
          if (b = v[w], !n.test(b))
            throw new TypeError("invalid parameter name");
          y += "; " + b + "=" + c(g[b]);
        }
      return y;
    }
    function s(p) {
      if (!p)
        throw new TypeError("argument string is required");
      var g = typeof p == "object" ? u(p) : p;
      if (typeof g != "string")
        throw new TypeError("argument string is required to be a string");
      var h = g.indexOf(";"), y = h !== -1 ? g.slice(0, h).trim() : g.trim();
      if (!a.test(y))
        throw new TypeError("invalid media type");
      var b = new f(y.toLowerCase());
      if (h !== -1) {
        var v, w, _;
        for (e.lastIndex = h; w = e.exec(g); ) {
          if (w.index !== h)
            throw new TypeError("invalid parameter format");
          h += w[0].length, v = w[1].toLowerCase(), _ = w[2], _.charCodeAt(0) === 34 && (_ = _.slice(1, -1), _.indexOf("\\") !== -1 && (_ = _.replace(r, "$1"))), b.parameters[v] = _;
        }
        if (h !== g.length)
          throw new TypeError("invalid parameter format");
      }
      return b;
    }
    function u(p) {
      var g;
      if (typeof p.getHeader == "function" ? g = p.getHeader("content-type") : typeof p.headers == "object" && (g = p.headers && p.headers["content-type"]), typeof g != "string")
        throw new TypeError("content-type header is missing from object");
      return g;
    }
    function c(p) {
      var g = String(p);
      if (n.test(g))
        return g;
      if (g.length > 0 && !t.test(g))
        throw new TypeError("invalid parameter value");
      return '"' + g.replace(o, "\\$1") + '"';
    }
    function f(p) {
      this.parameters = /* @__PURE__ */ Object.create(null), this.type = p;
    }
    return cv;
  }
  var Hue = Uue(), Bc = /* @__PURE__ */ new Map(), J9 = function(e) {
    return e.cloneNode(!0);
  }, DA = function() {
    return window.location.protocol === "file:";
  }, Q9 = function(e, t, n) {
    var r = new XMLHttpRequest();
    r.onreadystatechange = function() {
      try {
        if (!/\.svg/i.test(e) && r.readyState === 2) {
          var o = r.getResponseHeader("Content-Type");
          if (!o)
            throw new Error("Content type not found");
          var a = Hue.parse(o).type;
          if (!(a === "image/svg+xml" || a === "text/plain"))
            throw new Error("Invalid content type: ".concat(a));
        }
        if (r.readyState === 4) {
          if (r.status === 404 || r.responseXML === null)
            throw new Error(DA() ? "Note: SVG injection ajax calls do not work locally without adjusting security settings in your browser. Or consider using a local webserver." : "Unable to load SVG file: " + e);
          if (r.status === 200 || DA() && r.status === 0)
            n(null, r);
          else
            throw new Error("There was a problem injecting the SVG: " + r.status + " " + r.statusText);
        }
      } catch (i) {
        if (r.abort(), i instanceof Error)
          n(i, r);
        else
          throw i;
      }
    }, r.open("GET", e), r.withCredentials = t, r.overrideMimeType && r.overrideMimeType("text/xml"), r.send();
  }, Hs = {}, LA = function(e, t) {
    Hs[e] = Hs[e] || [], Hs[e].push(t);
  }, Wue = function(e) {
    for (var t = function(o, a) {
      setTimeout(function() {
        if (Array.isArray(Hs[e])) {
          var i = Bc.get(e), s = Hs[e][o];
          i instanceof SVGSVGElement && s(null, J9(i)), i instanceof Error && s(i), o === Hs[e].length - 1 && delete Hs[e];
        }
      }, 0);
    }, n = 0, r = Hs[e].length; n < r; n++)
      t(n);
  }, que = function(e, t, n) {
    if (Bc.has(e)) {
      var r = Bc.get(e);
      if (r === void 0) {
        LA(e, n);
        return;
      }
      if (r instanceof SVGSVGElement) {
        n(null, J9(r));
        return;
      }
    }
    Bc.set(e, void 0), LA(e, n), Q9(e, t, function(o, a) {
      var i;
      o ? Bc.set(e, o) : ((i = a.responseXML) === null || i === void 0 ? void 0 : i.documentElement) instanceof SVGSVGElement && Bc.set(e, a.responseXML.documentElement), Wue(e);
    });
  }, Kue = function(e, t, n) {
    Q9(e, t, function(r, o) {
      var a;
      r ? n(r) : ((a = o.responseXML) === null || a === void 0 ? void 0 : a.documentElement) instanceof SVGSVGElement && n(null, o.responseXML.documentElement);
    });
  }, Gue = 0, Xue = function() {
    return ++Gue;
  }, va = [], FA = {}, Yue = "http://www.w3.org/2000/svg", L_ = "http://www.w3.org/1999/xlink", TA = function(e, t, n, r, o, a, i) {
    var s = e.getAttribute("data-src") || e.getAttribute("src");
    if (!s) {
      i(new Error("Invalid data-src or src attribute"));
      return;
    }
    if (va.indexOf(e) !== -1) {
      va.splice(va.indexOf(e), 1), e = null;
      return;
    }
    va.push(e), e.setAttribute("src", "");
    var u = r ? que : Kue;
    u(s, o, function(c, f) {
      if (!f) {
        va.splice(va.indexOf(e), 1), e = null, i(c);
        return;
      }
      var p = e.getAttribute("id");
      p && f.setAttribute("id", p);
      var g = e.getAttribute("title");
      g && f.setAttribute("title", g);
      var h = e.getAttribute("width");
      h && f.setAttribute("width", h);
      var y = e.getAttribute("height");
      y && f.setAttribute("height", y);
      var b = Array.from(new Set(Cy(Cy(Cy([], (f.getAttribute("class") || "").split(" "), !0), ["injected-svg"], !1), (e.getAttribute("class") || "").split(" "), !0))).join(" ").trim();
      f.setAttribute("class", b);
      var v = e.getAttribute("style");
      v && f.setAttribute("style", v), f.setAttribute("data-src", s);
      var w = [].filter.call(e.attributes, function(G) {
        return /^data-\w[\w-]*$/.test(G.name);
      });
      if (Array.prototype.forEach.call(w, function(G) {
        G.name && G.value && f.setAttribute(G.name, G.value);
      }), n) {
        var _ = {
          clipPath: ["clip-path"],
          "color-profile": ["color-profile"],
          cursor: ["cursor"],
          filter: ["filter"],
          linearGradient: ["fill", "stroke"],
          marker: ["marker", "marker-start", "marker-mid", "marker-end"],
          mask: ["mask"],
          path: [],
          pattern: ["fill", "stroke"],
          radialGradient: ["fill", "stroke"]
        }, k, E, P, O, M;
        Object.keys(_).forEach(function(G) {
          k = G, P = _[G], E = f.querySelectorAll(k + "[id]");
          for (var W = function(L, K) {
            O = E[L].id, M = O + "-" + Xue();
            var T;
            Array.prototype.forEach.call(P, function(Z) {
              T = f.querySelectorAll("[" + Z + '*="' + O + '"]');
              for (var ee = 0, oe = T.length; ee < oe; ee++) {
                var le = T[ee].getAttribute(Z);
                le && !le.match(new RegExp('url\\("?#' + O + '"?\\)')) || T[ee].setAttribute(Z, "url(#" + M + ")");
              }
            });
            for (var V = f.querySelectorAll("[*|href]"), X = [], Q = 0, ne = V.length; Q < ne; Q++) {
              var te = V[Q].getAttributeNS(L_, "href");
              te && te.toString() === "#" + E[L].id && X.push(V[Q]);
            }
            for (var ae = 0, ce = X.length; ae < ce; ae++)
              X[ae].setAttributeNS(L_, "href", "#" + M);
            E[L].id = M;
          }, Y = 0, z = E.length; Y < z; Y++)
            W(Y);
        });
      }
      f.removeAttribute("xmlns:a");
      for (var I = f.querySelectorAll("script"), A = [], D, F, j = 0, U = I.length; j < U; j++)
        F = I[j].getAttribute("type"), (!F || F === "application/ecmascript" || F === "application/javascript" || F === "text/javascript") && (D = I[j].innerText || I[j].textContent, D && A.push(D), f.removeChild(I[j]));
      if (A.length > 0 && (t === "always" || t === "once" && !FA[s])) {
        for (var $ = 0, q = A.length; $ < q; $++)
          new Function(A[$])(window);
        FA[s] = !0;
      }
      var B = f.querySelectorAll("style");
      if (Array.prototype.forEach.call(B, function(G) {
        G.textContent += "";
      }), f.setAttribute("xmlns", Yue), f.setAttribute("xmlns:xlink", L_), a(f), !e.parentNode) {
        va.splice(va.indexOf(e), 1), e = null, i(new Error("Parent node is null"));
        return;
      }
      e.parentNode.replaceChild(f, e), va.splice(va.indexOf(e), 1), e = null, i(null, f);
    });
  }, Jue = function(e, t) {
    var n = t === void 0 ? {} : t, r = n.afterAll, o = r === void 0 ? function() {
    } : r, a = n.afterEach, i = a === void 0 ? function() {
    } : a, s = n.beforeEach, u = s === void 0 ? function() {
    } : s, c = n.cacheRequests, f = c === void 0 ? !0 : c, p = n.evalScripts, g = p === void 0 ? "never" : p, h = n.httpRequestWithCredentials, y = h === void 0 ? !1 : h, b = n.renumerateIRIElements, v = b === void 0 ? !0 : b;
    if (e && "length" in e)
      for (var w = 0, _ = 0, k = e.length; _ < k; _++)
        TA(e[_], g, v, f, y, u, function(E, P) {
          i(E, P), e && "length" in e && e.length === ++w && o(w);
        });
    else e ? TA(e, g, v, f, y, u, function(E, P) {
      i(E, P), o(1), e = null;
    }) : o(0);
  }, Que = function(e) {
    var t = e?.ownerDocument || document;
    return t.defaultView || window;
  }, Zue = function(e, t) {
    for (var n in e)
      if (!(n in t))
        return !0;
    for (var r in t)
      if (e[r] !== t[r])
        return !0;
    return !1;
  }, ece = ["afterInjection", "beforeInjection", "desc", "evalScripts", "fallback", "httpRequestWithCredentials", "loading", "renumerateIRIElements", "src", "title", "useRequestCache", "wrapper"], dv = "http://www.w3.org/2000/svg", zA = "http://www.w3.org/1999/xlink", JC = /* @__PURE__ */ (function(e) {
    function t() {
      for (var r, o = arguments.length, a = new Array(o), i = 0; i < o; i++)
        a[i] = arguments[i];
      return r = e.call.apply(e, [this].concat(a)) || this, r.initialState = {
        hasError: !1,
        isLoading: !0
      }, r.state = r.initialState, r._isMounted = !1, r.reactWrapper = void 0, r.nonReactWrapper = void 0, r.refCallback = function(s) {
        r.reactWrapper = s;
      }, r;
    }
    fC(t, e);
    var n = t.prototype;
    return n.renderSVG = function() {
      var r = this;
      if (this.reactWrapper instanceof Que(this.reactWrapper).Node) {
        var o = this.props, a = o.desc, i = o.evalScripts, s = o.httpRequestWithCredentials, u = o.renumerateIRIElements, c = o.src, f = o.title, p = o.useRequestCache, g = this.props.onError, h = this.props.beforeInjection, y = this.props.afterInjection, b = this.props.wrapper, v, w;
        b === "svg" ? (v = document.createElementNS(dv, b), v.setAttribute("xmlns", dv), v.setAttribute("xmlns:xlink", zA), w = document.createElementNS(dv, b)) : (v = document.createElement(b), w = document.createElement(b)), v.appendChild(w), w.dataset.src = c, this.nonReactWrapper = this.reactWrapper.appendChild(v);
        var _ = function(P) {
          if (r.removeSVG(), !r._isMounted) {
            g(P);
            return;
          }
          r.setState(function() {
            return {
              hasError: !0,
              isLoading: !1
            };
          }, function() {
            g(P);
          });
        }, k = function(P, O) {
          if (P) {
            _(P);
            return;
          }
          r._isMounted && r.setState(function() {
            return {
              isLoading: !1
            };
          }, function() {
            try {
              y(O);
            } catch (M) {
              _(M);
            }
          });
        }, E = function(P) {
          if (P.setAttribute("role", "img"), a) {
            var O = P.querySelector(":scope > desc");
            O && P.removeChild(O);
            var M = document.createElement("desc");
            M.innerHTML = a, P.prepend(M);
          }
          if (f) {
            var I = P.querySelector(":scope > title");
            I && P.removeChild(I);
            var A = document.createElement("title");
            A.innerHTML = f, P.prepend(A);
          }
          try {
            h(P);
          } catch (D) {
            _(D);
          }
        };
        Jue(w, {
          afterEach: k,
          beforeEach: E,
          cacheRequests: p,
          evalScripts: i,
          httpRequestWithCredentials: s,
          renumerateIRIElements: u
        });
      }
    }, n.removeSVG = function() {
      var r;
      (r = this.nonReactWrapper) != null && r.parentNode && (this.nonReactWrapper.parentNode.removeChild(this.nonReactWrapper), this.nonReactWrapper = null);
    }, n.componentDidMount = function() {
      this._isMounted = !0, this.renderSVG();
    }, n.componentDidUpdate = function(r) {
      var o = this;
      Zue(Ge({}, r), this.props) && this.setState(function() {
        return o.initialState;
      }, function() {
        o.removeSVG(), o.renderSVG();
      });
    }, n.componentWillUnmount = function() {
      this._isMounted = !1, this.removeSVG();
    }, n.render = function() {
      var r = this.props;
      r.afterInjection, r.beforeInjection, r.desc, r.evalScripts;
      var o = r.fallback;
      r.httpRequestWithCredentials;
      var a = r.loading;
      r.renumerateIRIElements, r.src, r.title, r.useRequestCache;
      var i = r.wrapper, s = yw(r, ece), u = i;
      return /* @__PURE__ */ C.createElement(u, Ge({}, s, {
        ref: this.refCallback
      }, i === "svg" ? {
        xmlns: dv,
        xmlnsXlink: zA
      } : {}), this.state.isLoading && a && /* @__PURE__ */ C.createElement(a, null), this.state.hasError && o && /* @__PURE__ */ C.createElement(o, null));
    }, t;
  })(C.Component);
  JC.defaultProps = {
    afterInjection: function() {
    },
    beforeInjection: function() {
    },
    desc: "",
    evalScripts: "never",
    fallback: null,
    httpRequestWithCredentials: !1,
    loading: null,
    onError: function() {
    },
    renumerateIRIElements: !0,
    title: "",
    useRequestCache: !0,
    wrapper: "div"
  };
  JC.propTypes = {
    afterInjection: Bn.func,
    beforeInjection: Bn.func,
    desc: Bn.string,
    evalScripts: Bn.oneOf(["always", "once", "never"]),
    fallback: Bn.oneOfType([Bn.func, Bn.object, Bn.string]),
    httpRequestWithCredentials: Bn.bool,
    loading: Bn.oneOfType([Bn.func, Bn.object, Bn.string]),
    onError: Bn.func,
    renumerateIRIElements: Bn.bool,
    src: Bn.string.isRequired,
    title: Bn.string,
    useRequestCache: Bn.bool,
    wrapper: Bn.oneOf(["div", "span", "svg"])
  };
  const QC = ({
    text: e = "No image data provided"
  }) => /* @__PURE__ */ S.jsx(
    "div",
    {
      style: {
        display: "flex",
        alignItems: "center",
        justifyContent: "center",
        minHeight: "100px",
        border: "1px dashed #ccc",
        color: "#666"
      },
      children: e
    }
  ), tce = C.memo(
    ({
      value: e,
      format: t = "jpeg",
      alt: n = "Base64 image",
      onError: r,
      onLoad: o,
      ...a
    }) => {
      const [i, s] = C.useState(!1), [u, c] = C.useState(!0), f = C.useRef(null), p = C.useMemo(() => {
        if (typeof e == "string")
          return e;
        if (e && typeof e == "object" && "data" in e) {
          const b = e.data;
          if (b instanceof ArrayBuffer) {
            const v = new Uint8Array(b);
            let w = "";
            for (let _ = 0; _ < v.byteLength; _++)
              w += String.fromCharCode(v[_]);
            return btoa(w);
          }
        }
        return "";
      }, [e]), g = C.useMemo(() => p ? `data:image/${t};base64,${p}` : "", [p, t]), h = C.useCallback(
        (b) => {
          s(!0), c(!1), r?.(b);
        },
        [r]
      ), y = C.useCallback(() => {
        c(!1), s(!1), o?.();
      }, [o]);
      return C.useEffect(() => {
        const b = f.current;
        if (b)
          return b.addEventListener("error", h), b.addEventListener("load", y), () => {
            b.removeEventListener("error", h), b.removeEventListener("load", y);
          };
      }, [h, y, e]), C.useEffect(() => {
        s(!1), c(!0);
      }, [e]), p ? i ? /* @__PURE__ */ S.jsx(
        "div",
        {
          style: {
            display: "flex",
            alignItems: "center",
            justifyContent: "center",
            minHeight: "100px",
            border: "1px dashed #ccc",
            color: "#666"
          },
          children: "Failed to load base64 image"
        }
      ) : /* @__PURE__ */ S.jsx(
        "img",
        {
          ref: f,
          src: g,
          alt: n,
          className: `base64-image-renderer image-renderer ${a.className || ""} ${u ? " loading" : ""}`,
          ...a
        }
      ) : /* @__PURE__ */ S.jsx(QC, {});
    }
  ), nce = C.memo(
    ({
      value: e,
      alt: t = "SVG image",
      onError: n,
      onLoad: r,
      ...o
    }) => {
      const [a, i] = C.useState(!1), s = C.useMemo(() => {
        if (!e) return "";
        try {
          return `data:image/svg+xml;base64,${btoa(e)}`;
        } catch (c) {
          return console.error("Failed to encode SVG to base64:", c), "";
        }
      }, [e]);
      C.useEffect(() => {
        i(!1);
      }, [e]);
      const u = C.useCallback(
        (c) => {
          i(!0), n?.(c);
        },
        [n]
      );
      return e ? a || !s ? /* @__PURE__ */ S.jsx(
        "div",
        {
          style: {
            display: "flex",
            alignItems: "center",
            justifyContent: "center",
            minHeight: "100px",
            border: "1px dashed #ccc",
            color: "#666"
          },
          children: "Failed to load SVG"
        }
      ) : /* @__PURE__ */ S.jsx(
        JC,
        {
          src: s,
          className: `svg-renderer ${o.className || ""}`,
          style: {
            maxWidth: "100%",
            maxHeight: "100%",
            ...o.style
          },
          beforeInjection: (c) => {
            c.classList.add("svg-renderer"), c.setAttribute("style", "max-width: 100%; max-height: 100%;"), c.setAttribute("width", "100%"), c.setAttribute("height", "100%"), c.setAttribute("aria-label", t);
            const f = () => {
              i(!1), r?.();
            }, p = (g) => {
              i(!0), n?.(g);
            };
            try {
              c.addEventListener("load", f), c.addEventListener("error", p);
            } catch {
              f();
            }
          },
          onError: u
        }
      ) : /* @__PURE__ */ S.jsx(QC, {});
    }
  ), rce = C.memo(
    ({
      src: e,
      alt: t = "Streaming image",
      onError: n,
      onLoad: r,
      ...o
    }) => {
      const a = C.useRef(null), [i, s] = C.useState(!1), [u, c] = C.useState(!0);
      C.useEffect(() => {
        a.current && e && (c(!0), s(!1), a.current.src = e);
      }, [e]);
      const f = C.useCallback(
        (g) => {
          s(!0), c(!1), n?.(g);
        },
        [n]
      ), p = C.useCallback(() => {
        c(!1), s(!1), r?.();
      }, [r]);
      return C.useEffect(() => {
        const g = a.current;
        if (g)
          return g.addEventListener("error", f), g.addEventListener("load", p), () => {
            g.removeEventListener("error", f), g.removeEventListener("load", p);
          };
      }, [f, p]), i ? /* @__PURE__ */ S.jsx(QC, { text: "Failed to load image" }) : /* @__PURE__ */ S.jsx(
        "img",
        {
          ref: a,
          className: `streaming-image image-renderer ${o.className || ""} ${u ? " loading" : ""}`,
          alt: t,
          ...o
        }
      );
    }
  );
  function Lw(e) {
    const t = e + "CollectionProvider", [n, r] = Ja(t), [o, a] = n(
      t,
      { collectionRef: { current: null }, itemMap: /* @__PURE__ */ new Map() }
    ), i = (b) => {
      const { scope: v, children: w } = b, _ = gn.useRef(null), k = gn.useRef(/* @__PURE__ */ new Map()).current;
      return /* @__PURE__ */ S.jsx(o, { scope: v, itemMap: k, collectionRef: _, children: w });
    };
    i.displayName = t;
    const s = e + "CollectionSlot", u = /* @__PURE__ */ fd(s), c = gn.forwardRef(
      (b, v) => {
        const { scope: w, children: _ } = b, k = a(s, w), E = un(v, k.collectionRef);
        return /* @__PURE__ */ S.jsx(u, { ref: E, children: _ });
      }
    );
    c.displayName = s;
    const f = e + "CollectionItemSlot", p = "data-radix-collection-item", g = /* @__PURE__ */ fd(f), h = gn.forwardRef(
      (b, v) => {
        const { scope: w, children: _, ...k } = b, E = gn.useRef(null), P = un(v, E), O = a(f, w);
        return gn.useEffect(() => (O.itemMap.set(E, { ref: E, ...k }), () => {
          O.itemMap.delete(E);
        })), /* @__PURE__ */ S.jsx(g, { [p]: "", ref: P, children: _ });
      }
    );
    h.displayName = f;
    function y(b) {
      const v = a(e + "CollectionConsumer", b);
      return gn.useCallback(() => {
        const w = v.collectionRef.current;
        if (!w) return [];
        const _ = Array.from(w.querySelectorAll(`[${p}]`));
        return Array.from(v.itemMap.values()).sort(
          (k, E) => _.indexOf(k.ref.current) - _.indexOf(E.ref.current)
        );
      }, [v.collectionRef, v.itemMap]);
    }
    return [
      { Provider: i, Slot: c, ItemSlot: h },
      y,
      r
    ];
  }
  var oce = Object.freeze({
    // See: https://github.com/twbs/bootstrap/blob/main/scss/mixins/_visually-hidden.scss
    position: "absolute",
    border: 0,
    width: 1,
    height: 1,
    padding: 0,
    margin: -1,
    overflow: "hidden",
    clip: "rect(0, 0, 0, 0)",
    whiteSpace: "nowrap",
    wordWrap: "normal"
  }), ace = "VisuallyHidden", ZC = C.forwardRef(
    (e, t) => /* @__PURE__ */ S.jsx(
      gt.span,
      {
        ...e,
        ref: t,
        style: { ...oce, ...e.style }
      }
    )
  );
  ZC.displayName = ace;
  var eP = "ToastProvider", [tP, ice, sce] = Lw("Toast"), [Z9] = Ja("Toast", [sce]), [lce, Fw] = Z9(eP), e8 = (e) => {
    const {
      __scopeToast: t,
      label: n = "Notification",
      duration: r = 5e3,
      swipeDirection: o = "right",
      swipeThreshold: a = 50,
      children: i
    } = e, [s, u] = C.useState(null), [c, f] = C.useState(0), p = C.useRef(!1), g = C.useRef(!1);
    return n.trim() || console.error(
      `Invalid prop \`label\` supplied to \`${eP}\`. Expected non-empty \`string\`.`
    ), /* @__PURE__ */ S.jsx(tP.Provider, { scope: t, children: /* @__PURE__ */ S.jsx(
      lce,
      {
        scope: t,
        label: n,
        duration: r,
        swipeDirection: o,
        swipeThreshold: a,
        toastCount: c,
        viewport: s,
        onViewportChange: u,
        onToastAdd: C.useCallback(() => f((h) => h + 1), []),
        onToastRemove: C.useCallback(() => f((h) => h - 1), []),
        isFocusedToastEscapeKeyDownRef: p,
        isClosePausedRef: g,
        children: i
      }
    ) });
  };
  e8.displayName = eP;
  var t8 = "ToastViewport", uce = ["F8"], $2 = "toast.viewportPause", D2 = "toast.viewportResume", n8 = C.forwardRef(
    (e, t) => {
      const {
        __scopeToast: n,
        hotkey: r = uce,
        label: o = "Notifications ({hotkey})",
        ...a
      } = e, i = Fw(t8, n), s = ice(n), u = C.useRef(null), c = C.useRef(null), f = C.useRef(null), p = C.useRef(null), g = un(t, p, i.onViewportChange), h = r.join("+").replace(/Key/g, "").replace(/Digit/g, ""), y = i.toastCount > 0;
      C.useEffect(() => {
        const v = (w) => {
          r.length !== 0 && r.every((_) => w[_] || w.code === _) && p.current?.focus();
        };
        return document.addEventListener("keydown", v), () => document.removeEventListener("keydown", v);
      }, [r]), C.useEffect(() => {
        const v = u.current, w = p.current;
        if (y && v && w) {
          const _ = () => {
            if (!i.isClosePausedRef.current) {
              const O = new CustomEvent($2);
              w.dispatchEvent(O), i.isClosePausedRef.current = !0;
            }
          }, k = () => {
            if (i.isClosePausedRef.current) {
              const O = new CustomEvent(D2);
              w.dispatchEvent(O), i.isClosePausedRef.current = !1;
            }
          }, E = (O) => {
            !v.contains(O.relatedTarget) && k();
          }, P = () => {
            v.contains(document.activeElement) || k();
          };
          return v.addEventListener("focusin", _), v.addEventListener("focusout", E), v.addEventListener("pointermove", _), v.addEventListener("pointerleave", P), window.addEventListener("blur", _), window.addEventListener("focus", k), () => {
            v.removeEventListener("focusin", _), v.removeEventListener("focusout", E), v.removeEventListener("pointermove", _), v.removeEventListener("pointerleave", P), window.removeEventListener("blur", _), window.removeEventListener("focus", k);
          };
        }
      }, [y, i.isClosePausedRef]);
      const b = C.useCallback(
        ({ tabbingDirection: v }) => {
          const w = s().map((_) => {
            const k = _.ref.current, E = [k, ...kce(k)];
            return v === "forwards" ? E : E.reverse();
          });
          return (v === "forwards" ? w.reverse() : w).flat();
        },
        [s]
      );
      return C.useEffect(() => {
        const v = p.current;
        if (v) {
          const w = (_) => {
            const k = _.altKey || _.ctrlKey || _.metaKey;
            if (_.key === "Tab" && !k) {
              const E = document.activeElement, P = _.shiftKey;
              if (_.target === v && P) {
                c.current?.focus();
                return;
              }
              const O = b({ tabbingDirection: P ? "backwards" : "forwards" }), M = O.findIndex((I) => I === E);
              F_(O.slice(M + 1)) ? _.preventDefault() : P ? c.current?.focus() : f.current?.focus();
            }
          };
          return v.addEventListener("keydown", w), () => v.removeEventListener("keydown", w);
        }
      }, [s, b]), /* @__PURE__ */ S.jsxs(
        TZ,
        {
          ref: u,
          role: "region",
          "aria-label": o.replace("{hotkey}", h),
          tabIndex: -1,
          style: { pointerEvents: y ? void 0 : "none" },
          children: [
            y && /* @__PURE__ */ S.jsx(
              L2,
              {
                ref: c,
                onFocusFromOutsideViewport: () => {
                  const v = b({
                    tabbingDirection: "forwards"
                  });
                  F_(v);
                }
              }
            ),
            /* @__PURE__ */ S.jsx(tP.Slot, { scope: n, children: /* @__PURE__ */ S.jsx(gt.ol, { tabIndex: -1, ...a, ref: g }) }),
            y && /* @__PURE__ */ S.jsx(
              L2,
              {
                ref: f,
                onFocusFromOutsideViewport: () => {
                  const v = b({
                    tabbingDirection: "backwards"
                  });
                  F_(v);
                }
              }
            )
          ]
        }
      );
    }
  );
  n8.displayName = t8;
  var r8 = "ToastFocusProxy", L2 = C.forwardRef(
    (e, t) => {
      const { __scopeToast: n, onFocusFromOutsideViewport: r, ...o } = e, a = Fw(r8, n);
      return /* @__PURE__ */ S.jsx(
        ZC,
        {
          tabIndex: 0,
          ...o,
          ref: t,
          style: { position: "fixed" },
          onFocus: (i) => {
            const s = i.relatedTarget;
            !a.viewport?.contains(s) && r();
          }
        }
      );
    }
  );
  L2.displayName = r8;
  var Gm = "Toast", cce = "toast.swipeStart", dce = "toast.swipeMove", fce = "toast.swipeCancel", pce = "toast.swipeEnd", o8 = C.forwardRef(
    (e, t) => {
      const { forceMount: n, open: r, defaultOpen: o, onOpenChange: a, ...i } = e, [s, u] = ml({
        prop: r,
        defaultProp: o ?? !0,
        onChange: a,
        caller: Gm
      });
      return /* @__PURE__ */ S.jsx(ia, { present: n || s, children: /* @__PURE__ */ S.jsx(
        gce,
        {
          open: s,
          ...i,
          ref: t,
          onClose: () => u(!1),
          onPause: Wr(e.onPause),
          onResume: Wr(e.onResume),
          onSwipeStart: Te(e.onSwipeStart, (c) => {
            c.currentTarget.setAttribute("data-swipe", "start");
          }),
          onSwipeMove: Te(e.onSwipeMove, (c) => {
            const { x: f, y: p } = c.detail.delta;
            c.currentTarget.setAttribute("data-swipe", "move"), c.currentTarget.style.setProperty("--radix-toast-swipe-move-x", `${f}px`), c.currentTarget.style.setProperty("--radix-toast-swipe-move-y", `${p}px`);
          }),
          onSwipeCancel: Te(e.onSwipeCancel, (c) => {
            c.currentTarget.setAttribute("data-swipe", "cancel"), c.currentTarget.style.removeProperty("--radix-toast-swipe-move-x"), c.currentTarget.style.removeProperty("--radix-toast-swipe-move-y"), c.currentTarget.style.removeProperty("--radix-toast-swipe-end-x"), c.currentTarget.style.removeProperty("--radix-toast-swipe-end-y");
          }),
          onSwipeEnd: Te(e.onSwipeEnd, (c) => {
            const { x: f, y: p } = c.detail.delta;
            c.currentTarget.setAttribute("data-swipe", "end"), c.currentTarget.style.removeProperty("--radix-toast-swipe-move-x"), c.currentTarget.style.removeProperty("--radix-toast-swipe-move-y"), c.currentTarget.style.setProperty("--radix-toast-swipe-end-x", `${f}px`), c.currentTarget.style.setProperty("--radix-toast-swipe-end-y", `${p}px`), u(!1);
          })
        }
      ) });
    }
  );
  o8.displayName = Gm;
  var [mce, hce] = Z9(Gm, {
    onClose() {
    }
  }), gce = C.forwardRef(
    (e, t) => {
      const {
        __scopeToast: n,
        type: r = "foreground",
        duration: o,
        open: a,
        onClose: i,
        onEscapeKeyDown: s,
        onPause: u,
        onResume: c,
        onSwipeStart: f,
        onSwipeMove: p,
        onSwipeCancel: g,
        onSwipeEnd: h,
        ...y
      } = e, b = Fw(Gm, n), [v, w] = C.useState(null), _ = un(t, ($) => w($)), k = C.useRef(null), E = C.useRef(null), P = o || b.duration, O = C.useRef(0), M = C.useRef(P), I = C.useRef(0), { onToastAdd: A, onToastRemove: D } = b, F = Wr(() => {
        v?.contains(document.activeElement) && b.viewport?.focus(), i();
      }), j = C.useCallback(
        ($) => {
          !$ || $ === 1 / 0 || (window.clearTimeout(I.current), O.current = (/* @__PURE__ */ new Date()).getTime(), I.current = window.setTimeout(F, $));
        },
        [F]
      );
      C.useEffect(() => {
        const $ = b.viewport;
        if ($) {
          const q = () => {
            j(M.current), c?.();
          }, B = () => {
            const G = (/* @__PURE__ */ new Date()).getTime() - O.current;
            M.current = M.current - G, window.clearTimeout(I.current), u?.();
          };
          return $.addEventListener($2, B), $.addEventListener(D2, q), () => {
            $.removeEventListener($2, B), $.removeEventListener(D2, q);
          };
        }
      }, [b.viewport, P, u, c, j]), C.useEffect(() => {
        a && !b.isClosePausedRef.current && j(P);
      }, [a, P, b.isClosePausedRef, j]), C.useEffect(() => (A(), () => D()), [A, D]);
      const U = C.useMemo(() => v ? d8(v) : null, [v]);
      return b.viewport ? /* @__PURE__ */ S.jsxs(S.Fragment, { children: [
        U && /* @__PURE__ */ S.jsx(
          vce,
          {
            __scopeToast: n,
            role: "status",
            "aria-live": r === "foreground" ? "assertive" : "polite",
            children: U
          }
        ),
        /* @__PURE__ */ S.jsx(mce, { scope: n, onClose: F, children: xu.createPortal(
          /* @__PURE__ */ S.jsx(tP.ItemSlot, { scope: n, children: /* @__PURE__ */ S.jsx(
            FZ,
            {
              asChild: !0,
              onEscapeKeyDown: Te(s, () => {
                b.isFocusedToastEscapeKeyDownRef.current || F(), b.isFocusedToastEscapeKeyDownRef.current = !1;
              }),
              children: /* @__PURE__ */ S.jsx(
                gt.li,
                {
                  tabIndex: 0,
                  "data-state": a ? "open" : "closed",
                  "data-swipe-direction": b.swipeDirection,
                  ...y,
                  ref: _,
                  style: { userSelect: "none", touchAction: "none", ...e.style },
                  onKeyDown: Te(e.onKeyDown, ($) => {
                    $.key === "Escape" && (s?.($.nativeEvent), $.nativeEvent.defaultPrevented || (b.isFocusedToastEscapeKeyDownRef.current = !0, F()));
                  }),
                  onPointerDown: Te(e.onPointerDown, ($) => {
                    $.button === 0 && (k.current = { x: $.clientX, y: $.clientY });
                  }),
                  onPointerMove: Te(e.onPointerMove, ($) => {
                    if (!k.current) return;
                    const q = $.clientX - k.current.x, B = $.clientY - k.current.y, G = !!E.current, W = ["left", "right"].includes(b.swipeDirection), Y = ["left", "up"].includes(b.swipeDirection) ? Math.min : Math.max, z = W ? Y(0, q) : 0, L = W ? 0 : Y(0, B), K = $.pointerType === "touch" ? 10 : 2, T = { x: z, y: L }, V = { originalEvent: $, delta: T };
                    G ? (E.current = T, fv(dce, p, V, {
                      discrete: !1
                    })) : BA(T, b.swipeDirection, K) ? (E.current = T, fv(cce, f, V, {
                      discrete: !1
                    }), $.target.setPointerCapture($.pointerId)) : (Math.abs(q) > K || Math.abs(B) > K) && (k.current = null);
                  }),
                  onPointerUp: Te(e.onPointerUp, ($) => {
                    const q = E.current, B = $.target;
                    if (B.hasPointerCapture($.pointerId) && B.releasePointerCapture($.pointerId), E.current = null, k.current = null, q) {
                      const G = $.currentTarget, W = { originalEvent: $, delta: q };
                      BA(q, b.swipeDirection, b.swipeThreshold) ? fv(pce, h, W, {
                        discrete: !0
                      }) : fv(
                        fce,
                        g,
                        W,
                        {
                          discrete: !0
                        }
                      ), G.addEventListener("click", (Y) => Y.preventDefault(), {
                        once: !0
                      });
                    }
                  })
                }
              )
            }
          ) }),
          b.viewport
        ) })
      ] }) : null;
    }
  ), vce = (e) => {
    const { __scopeToast: t, children: n, ...r } = e, o = Fw(Gm, t), [a, i] = C.useState(!1), [s, u] = C.useState(!1);
    return wce(() => i(!0)), C.useEffect(() => {
      const c = window.setTimeout(() => u(!0), 1e3);
      return () => window.clearTimeout(c);
    }, []), s ? null : /* @__PURE__ */ S.jsx(xw, { asChild: !0, children: /* @__PURE__ */ S.jsx(ZC, { ...r, children: a && /* @__PURE__ */ S.jsxs(S.Fragment, { children: [
      o.label,
      " ",
      n
    ] }) }) });
  }, yce = "ToastTitle", a8 = C.forwardRef(
    (e, t) => {
      const { __scopeToast: n, ...r } = e;
      return /* @__PURE__ */ S.jsx(gt.div, { ...r, ref: t });
    }
  );
  a8.displayName = yce;
  var bce = "ToastDescription", i8 = C.forwardRef(
    (e, t) => {
      const { __scopeToast: n, ...r } = e;
      return /* @__PURE__ */ S.jsx(gt.div, { ...r, ref: t });
    }
  );
  i8.displayName = bce;
  var s8 = "ToastAction", l8 = C.forwardRef(
    (e, t) => {
      const { altText: n, ...r } = e;
      return n.trim() ? /* @__PURE__ */ S.jsx(c8, { altText: n, asChild: !0, children: /* @__PURE__ */ S.jsx(nP, { ...r, ref: t }) }) : (console.error(
        `Invalid prop \`altText\` supplied to \`${s8}\`. Expected non-empty \`string\`.`
      ), null);
    }
  );
  l8.displayName = s8;
  var u8 = "ToastClose", nP = C.forwardRef(
    (e, t) => {
      const { __scopeToast: n, ...r } = e, o = hce(u8, n);
      return /* @__PURE__ */ S.jsx(c8, { asChild: !0, children: /* @__PURE__ */ S.jsx(
        gt.button,
        {
          type: "button",
          ...r,
          ref: t,
          onClick: Te(e.onClick, o.onClose)
        }
      ) });
    }
  );
  nP.displayName = u8;
  var c8 = C.forwardRef((e, t) => {
    const { __scopeToast: n, altText: r, ...o } = e;
    return /* @__PURE__ */ S.jsx(
      gt.div,
      {
        "data-radix-toast-announce-exclude": "",
        "data-radix-toast-announce-alt": r || void 0,
        ...o,
        ref: t
      }
    );
  });
  function d8(e) {
    const t = [];
    return Array.from(e.childNodes).forEach((n) => {
      if (n.nodeType === n.TEXT_NODE && n.textContent && t.push(n.textContent), xce(n)) {
        const r = n.ariaHidden || n.hidden || n.style.display === "none", o = n.dataset.radixToastAnnounceExclude === "";
        if (!r)
          if (o) {
            const a = n.dataset.radixToastAnnounceAlt;
            a && t.push(a);
          } else
            t.push(...d8(n));
      }
    }), t;
  }
  function fv(e, t, n, { discrete: r }) {
    const o = n.originalEvent.currentTarget, a = new CustomEvent(e, { bubbles: !0, cancelable: !0, detail: n });
    t && o.addEventListener(e, t, { once: !0 }), r ? gC(o, a) : o.dispatchEvent(a);
  }
  var BA = (e, t, n = 0) => {
    const r = Math.abs(e.x), o = Math.abs(e.y), a = r > o;
    return t === "left" || t === "right" ? a && r > n : !a && o > n;
  };
  function wce(e = () => {
  }) {
    const t = Wr(e);
    Hi(() => {
      let n = 0, r = 0;
      return n = window.requestAnimationFrame(() => r = window.requestAnimationFrame(t)), () => {
        window.cancelAnimationFrame(n), window.cancelAnimationFrame(r);
      };
    }, [t]);
  }
  function xce(e) {
    return e.nodeType === e.ELEMENT_NODE;
  }
  function kce(e) {
    const t = [], n = document.createTreeWalker(e, NodeFilter.SHOW_ELEMENT, {
      acceptNode: (r) => {
        const o = r.tagName === "INPUT" && r.type === "hidden";
        return r.disabled || r.hidden || o ? NodeFilter.FILTER_SKIP : r.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
      }
    });
    for (; n.nextNode(); ) t.push(n.currentNode);
    return t;
  }
  function F_(e) {
    const t = document.activeElement;
    return e.some((n) => n === t ? !0 : (n.focus(), document.activeElement !== t));
  }
  var Sce = e8, _ce = n8, Ece = o8, Cce = a8, Pce = i8, Oce = l8, Nce = nP;
  const sr = [];
  for (let e = 0; e < 256; ++e)
    sr.push((e + 256).toString(16).slice(1));
  function Mce(e, t = 0) {
    return (sr[e[t + 0]] + sr[e[t + 1]] + sr[e[t + 2]] + sr[e[t + 3]] + "-" + sr[e[t + 4]] + sr[e[t + 5]] + "-" + sr[e[t + 6]] + sr[e[t + 7]] + "-" + sr[e[t + 8]] + sr[e[t + 9]] + "-" + sr[e[t + 10]] + sr[e[t + 11]] + sr[e[t + 12]] + sr[e[t + 13]] + sr[e[t + 14]] + sr[e[t + 15]]).toLowerCase();
  }
  let T_;
  const Rce = new Uint8Array(16);
  function jce() {
    if (!T_) {
      if (typeof crypto > "u" || !crypto.getRandomValues)
        throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
      T_ = crypto.getRandomValues.bind(crypto);
    }
    return T_(Rce);
  }
  const Ice = typeof crypto < "u" && crypto.randomUUID && crypto.randomUUID.bind(crypto), VA = { randomUUID: Ice };
  function Ace(e, t, n) {
    e = e || {};
    const r = e.random ?? e.rng?.() ?? jce();
    if (r.length < 16)
      throw new Error("Random bytes length must be >= 16");
    return r[6] = r[6] & 15 | 64, r[8] = r[8] & 63 | 128, Mce(r);
  }
  function rP(e, t, n) {
    return VA.randomUUID && !e ? VA.randomUUID() : Ace(e);
  }
  const f8 = C.createContext(
    void 0
  ), p8 = C.createContext(
    void 0
  ), $ce = 350, Dce = ({ children: e, fixedHeight: t, duration: n = 5e3, maxVisible: r = 3, ...o }) => {
    const [a, i] = C.useState(/* @__PURE__ */ new Map()), s = C.useRef(/* @__PURE__ */ new Map()), u = C.useRef(null), c = C.useRef(!0), f = C.useCallback(() => {
      const w = Array.from(s.current).reverse();
      if (t) {
        const _ = t;
        w.forEach(([, k], E) => {
          if (!k) return;
          k.setAttribute("data-front", String(E === 0)), k.setAttribute("data-hidden", String(E >= r)), k.style.setProperty("--index", String(E)), k.style.setProperty("--height", `${t}px`), k.style.setProperty("--front-height", `${_}px`);
          const P = t * E;
          k.style.setProperty("--hover-offset-y", `-${P}px`);
        });
      } else {
        const _ = w.map(([, E]) => {
          if (!E) return 0;
          const P = E.querySelector(
            ".ToastInner"
          );
          if (!P) return E.clientHeight;
          const O = P.style.height;
          P.style.height = "auto";
          const M = E.clientHeight;
          return P.style.height = O, M;
        }), k = _[0] || 0;
        w.forEach(([, E], P) => {
          if (!E) return;
          const O = _[P];
          E.setAttribute("data-front", String(P === 0)), E.setAttribute("data-hidden", String(P >= r)), E.style.setProperty("--index", String(P)), E.style.setProperty("--height", `${O}px`), E.style.setProperty("--front-height", `${k}px`);
          const M = _.slice(0, P).reduce((I, A) => I + A, 0);
          E.style.setProperty("--hover-offset-y", `-${M}px`);
        });
      }
    }, [t, r]), p = C.useCallback(
      (w) => {
        i((_) => {
          const k = new Map(_);
          return k.set(rP(), {
            ...w,
            duration: w.duration || n,
            open: !0
          }), k;
        });
      },
      [n]
    ), g = C.useCallback((w) => {
      c.current && i((_) => {
        const k = new Map(_);
        return k.delete(w), k;
      });
    }, []), h = C.useCallback(
      (w) => p({ ...w, status: w.status || "default" }),
      [p]
    ), y = C.useCallback(
      (w) => p({ ...w, status: "success" }),
      [p]
    ), b = C.useCallback(
      (w) => p({ ...w, status: "error" }),
      [p]
    );
    C.useEffect(() => (c.current = !0, () => {
      c.current = !1;
    }), []), C.useEffect(() => {
      const w = u.current;
      if (w) {
        const _ = () => {
          s.current.forEach((P) => {
            P.setAttribute("data-hovering", "true");
          });
        }, k = (P) => {
          (!w.contains(P.target) || w === P.target) && s.current.forEach((O) => {
            O.setAttribute("data-hovering", "false");
          });
        }, E = () => {
          s.current.forEach((P) => {
            P.setAttribute("data-hovering", "false");
          });
        };
        return w.addEventListener("pointermove", _), w.addEventListener("pointerleave", E), w.addEventListener("focusin", _), w.addEventListener("focusout", k), () => {
          w.removeEventListener("pointermove", _), w.removeEventListener("pointerleave", E), w.removeEventListener("focusin", _), w.removeEventListener("focusout", k);
        };
      }
    }, []);
    const v = C.useMemo(
      () => Object.assign(h, {
        success: y,
        error: b
      }),
      [h, y, b]
    );
    return /* @__PURE__ */ S.jsx(f8.Provider, { value: v, children: /* @__PURE__ */ S.jsx(
      p8.Provider,
      {
        value: C.useMemo(
          () => ({
            toastElementsMapRef: s,
            sortToasts: f
          }),
          [f]
        ),
        children: /* @__PURE__ */ S.jsxs(Sce, { ...o, children: [
          e,
          Array.from(a).map(([w, _]) => /* @__PURE__ */ S.jsx(
            Tce,
            {
              id: w,
              toast: _,
              onOpenChange: (k) => {
                k || (s.current.delete(w), f(), i((E) => {
                  const P = new Map(E), O = P.get(w);
                  return O && P.set(w, { ...O, open: !1 }), P;
                }), setTimeout(() => {
                  g(w);
                }, $ce));
              }
            },
            w
          )),
          /* @__PURE__ */ S.jsx(
            _ce,
            {
              ref: u,
              className: "ToastViewport",
              style: t ? {
                "--fixed-toast-height": `${t}px`
              } : void 0
            }
          )
        ] })
      }
    ) });
  }, Lce = () => {
    const e = C.useContext(f8);
    if (e) return e;
    throw new Error("useToast must be used within Toasts");
  }, Fce = () => {
    const e = C.useContext(p8);
    if (e) return e;
    throw new Error("useToastContext must be used within Toasts");
  }, Tce = ({
    onOpenChange: e,
    toast: t,
    id: n,
    ...r
  }) => {
    const o = C.useRef(null), a = Fce(), { sortToasts: i, toastElementsMapRef: s } = a, u = s.current;
    return C.useLayoutEffect(() => (o.current && (u.set(n, o.current), i()), () => {
      u.delete(n), i();
    }), [n, i, u]), /* @__PURE__ */ S.jsx(
      Ece,
      {
        ...r,
        ref: o,
        type: t.type,
        duration: t.duration,
        className: "ToastRoot",
        onOpenChange: e,
        open: t.open,
        children: /* @__PURE__ */ S.jsxs("div", { className: "ToastInner", "data-status": t.status, children: [
          /* @__PURE__ */ S.jsx(zce, { status: t.status }),
          t.title && /* @__PURE__ */ S.jsx(Cce, { className: "ToastTitle", children: t.title }),
          /* @__PURE__ */ S.jsx(Pce, { className: "ToastDescription", children: t.description }),
          t.action && /* @__PURE__ */ S.jsx(
            Oce,
            {
              className: "ToastAction Button small green",
              altText: t.action.altText,
              onClick: t.action.onClick,
              asChild: !0,
              children: /* @__PURE__ */ S.jsx("button", { children: t.action.label })
            }
          ),
          /* @__PURE__ */ S.jsx(Nce, { "aria-label": "Close", className: "ToastClose", children: /* @__PURE__ */ S.jsx(Mw, { style: { fontSize: "12px" } }) })
        ] })
      }
    );
  }, zce = ({ status: e }) => e !== "default" && e ? /* @__PURE__ */ S.jsxs("div", { style: { gridArea: "icon", alignSelf: "start" }, children: [
    e === "success" && /* @__PURE__ */ S.jsx(tae, { style: { color: "#61d345", fontSize: "20px" } }),
    e === "error" && /* @__PURE__ */ S.jsx(nae, { style: { color: "#ff4b4b", fontSize: "20px" } })
  ] }) : null, Bce = {}, UA = (e) => {
    let t;
    const n = /* @__PURE__ */ new Set(), r = (s, u) => {
      const c = typeof s == "function" ? s(t) : s;
      if (!Object.is(c, t)) {
        const f = t;
        t = u ?? (typeof c != "object" || c === null) ? c : Object.assign({}, t, c), n.forEach((p) => p(t, f));
      }
    }, o = () => t, a = { setState: r, getState: o, getInitialState: () => i, subscribe: (s) => (n.add(s), () => n.delete(s)), destroy: () => {
      (Bce ? "production" : void 0) !== "production" && console.warn(
        "[DEPRECATED] The `destroy` method will be unsupported in a future version. Instead use unsubscribe function returned by subscribe. Everything will be garbage-collected if store is garbage-collected."
      ), n.clear();
    } }, i = t = e(r, o, a);
    return a;
  }, m8 = (e) => e ? UA(e) : UA;
  var HA = { exports: {} }, z_ = {}, WA = { exports: {} }, B_ = {}, qA;
  function Vce() {
    if (qA) return B_;
    qA = 1;
    var e = gn;
    function t(p, g) {
      return p === g && (p !== 0 || 1 / p === 1 / g) || p !== p && g !== g;
    }
    var n = typeof Object.is == "function" ? Object.is : t, r = e.useState, o = e.useEffect, a = e.useLayoutEffect, i = e.useDebugValue;
    function s(p, g) {
      var h = g(), y = r({ inst: { value: h, getSnapshot: g } }), b = y[0].inst, v = y[1];
      return a(
        function() {
          b.value = h, b.getSnapshot = g, u(b) && v({ inst: b });
        },
        [p, h, g]
      ), o(
        function() {
          return u(b) && v({ inst: b }), p(function() {
            u(b) && v({ inst: b });
          });
        },
        [p]
      ), i(h), h;
    }
    function u(p) {
      var g = p.getSnapshot;
      p = p.value;
      try {
        var h = g();
        return !n(p, h);
      } catch {
        return !0;
      }
    }
    function c(p, g) {
      return g();
    }
    var f = typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u" ? c : s;
    return B_.useSyncExternalStore = e.useSyncExternalStore !== void 0 ? e.useSyncExternalStore : f, B_;
  }
  var KA;
  function Uce() {
    return KA || (KA = 1, WA.exports = Vce()), WA.exports;
  }
  var GA;
  function Hce() {
    if (GA) return z_;
    GA = 1;
    var e = gn, t = Uce();
    function n(c, f) {
      return c === f && (c !== 0 || 1 / c === 1 / f) || c !== c && f !== f;
    }
    var r = typeof Object.is == "function" ? Object.is : n, o = t.useSyncExternalStore, a = e.useRef, i = e.useEffect, s = e.useMemo, u = e.useDebugValue;
    return z_.useSyncExternalStoreWithSelector = function(c, f, p, g, h) {
      var y = a(null);
      if (y.current === null) {
        var b = { hasValue: !1, value: null };
        y.current = b;
      } else b = y.current;
      y = s(
        function() {
          function w(O) {
            if (!_) {
              if (_ = !0, k = O, O = g(O), h !== void 0 && b.hasValue) {
                var M = b.value;
                if (h(M, O))
                  return E = M;
              }
              return E = O;
            }
            if (M = E, r(k, O)) return M;
            var I = g(O);
            return h !== void 0 && h(M, I) ? (k = O, M) : (k = O, E = I);
          }
          var _ = !1, k, E, P = p === void 0 ? null : p;
          return [
            function() {
              return w(f());
            },
            P === null ? void 0 : function() {
              return w(P());
            }
          ];
        },
        [f, p, g, h]
      );
      var v = o(c, y[0], y[1]);
      return i(
        function() {
          b.hasValue = !0, b.value = v;
        },
        [v]
      ), u(v), v;
    }, z_;
  }
  var XA;
  function Wce() {
    return XA || (XA = 1, HA.exports = Hce()), HA.exports;
  }
  var qce = Wce();
  const h8 = /* @__PURE__ */ Qi(qce), g8 = {}, { useDebugValue: Kce } = gn, { useSyncExternalStoreWithSelector: Gce } = h8;
  let YA = !1;
  const Xce = (e) => e;
  function Yce(e, t = Xce, n) {
    (g8 ? "production" : void 0) !== "production" && n && !YA && (console.warn(
      "[DEPRECATED] Use `createWithEqualityFn` instead of `create` or use `useStoreWithEqualityFn` instead of `useStore`. They can be imported from 'zustand/traditional'. https://github.com/pmndrs/zustand/discussions/1937"
    ), YA = !0);
    const r = Gce(
      e.subscribe,
      e.getState,
      e.getServerState || e.getInitialState,
      t,
      n
    );
    return Kce(r), r;
  }
  const JA = (e) => {
    (g8 ? "production" : void 0) !== "production" && typeof e != "function" && console.warn(
      "[DEPRECATED] Passing a vanilla store will be unsupported in a future version. Instead use `import { useStore } from 'zustand'`."
    );
    const t = typeof e == "function" ? m8(e) : e, n = (r, o) => Yce(t, r, o);
    return Object.assign(n, t), n;
  }, Ro = (e) => e ? JA(e) : JA;
  class ts {
    constructor(t) {
      this.context = t;
    }
    get communicationManager() {
      return this.context.worker.getCommunicationManager();
    }
    get eventManager() {
      return this.context.worker.getEventManager();
    }
    get hookManager() {
      return this.context.worker.getHookManager();
    }
    get nodeManager() {
      return this.context.worker.getNodeManager();
    }
    get syncManager() {
      return this.context.worker.getSyncManager();
    }
    get connectionHealthManager() {
      return this.context.worker.getConnectionHealthManager();
    }
    get edgeManager() {
      return this.context.worker.getEdgeManager();
    }
    get groupManager() {
      return this.context.worker.getGroupManager();
    }
    get libraryManager() {
      return this.context.worker.getLibraryManager();
    }
  }
  const pv = 2e3;
  class Jce extends ts {
    constructor(t) {
      super(t), this._responsive = !1, this._last_pong = 0, this._last_pong = Date.now() - pv * 100;
    }
    start() {
      this.stop(), this.pingInterval = setInterval(() => {
        this.context.worker.is_open && this.context.worker.send({ type: "ping" });
      }, pv), this.responsivenessCheckInterval = setInterval(() => {
        this._responsive = Date.now() - this._last_pong <= pv * 3;
      }, pv * 2);
    }
    stop() {
      this.pingInterval && clearInterval(this.pingInterval), this.responsivenessCheckInterval && clearInterval(this.responsivenessCheckInterval);
    }
    receivePong() {
      this._last_pong = Date.now(), this._responsive = !0;
    }
    isResponsive() {
      return this._responsive;
    }
  }
  const QA = (e, t) => {
    e.properties = e.properties || {}, t.pos && (e.properties["frontend:pos"] = t.pos), t.size && (e.properties["frontend:size"] = t.size), t.collapsed !== void 0 && (e.properties["frontend:collapsed"] = !!t.collapsed);
  }, ZA = 2e3, e$ = 2e3;
  class Qce extends ts {
    constructor(t) {
      super(t), this._local_nodeupdates = /* @__PURE__ */ new Map(), this._local_groupupdates = /* @__PURE__ */ new Map(), this.on_sync_complete = t.on_sync_complete || (async () => {
      });
    }
    start() {
      this._nodeupdatetimer = setTimeout(() => {
        this.sync_local_node_updates();
      }, ZA), this._groupupdatetimer = setTimeout(() => {
        this.sync_local_group_updates();
      }, e$);
    }
    stop() {
      this._nodeupdatetimer && clearTimeout(this._nodeupdatetimer), this._groupupdatetimer && clearTimeout(this._groupupdatetimer);
    }
    async stepwise_fullsync() {
      this.context.worker._zustand && this.context.worker.is_open && (await this.sync_lib(), await this.sync_external_worker(), await this.sync_funcnodes_plugins(), await this.sync_nodespace(), await this.sync_view_state(), await this.on_sync_complete(this.context.worker));
    }
    async sync_lib() {
      if (!this.context.worker._zustand || !this.context.worker.is_open) return;
      const t = await this.communicationManager._send_cmd({
        cmd: "get_library",
        wait_for_response: !0,
        retries: 2,
        unique: !0
      });
      this.context.worker._zustand.lib.libstate.getState().set({
        lib: t
      });
    }
    async sync_external_worker() {
      if (!this.context.worker._zustand || !this.context.worker.is_open) return;
      const t = await this.communicationManager._send_cmd({
        cmd: "get_worker_dependencies",
        wait_for_response: !0,
        unique: !0
      });
      this.context.worker._zustand.lib.libstate.getState().set({
        external_worker: t
      });
    }
    async sync_funcnodes_plugins() {
      if (!this.context.worker._zustand || !this.context.worker.is_open) return;
      const t = await this.context.worker.getCommunicationManager()._send_cmd({
        cmd: "get_plugin_keys",
        wait_for_response: !0,
        unique: !0,
        kwargs: { type: "react" }
      });
      for (const n of t) {
        const r = await this.context.worker.getCommunicationManager()._send_cmd({
          cmd: "get_plugin",
          wait_for_response: !0,
          kwargs: { key: n, type: "react" },
          unique: !0
        });
        this.context.worker._zustand.add_packed_plugin(n, r);
      }
    }
    async sync_view_state() {
      if (!this.context.worker._zustand || !this.context.worker.is_open) return;
      const t = await this.context.worker.getCommunicationManager()._send_cmd({
        cmd: "view_state",
        wait_for_response: !0,
        unique: !0
      });
      t.renderoptions && this.context.worker._zustand.update_render_options(t.renderoptions);
      const n = t.nodes;
      if (n)
        for (const r in n) {
          const o = {};
          QA(o, n[r]), this.context.worker._zustand.on_node_action({
            type: "update",
            node: o,
            id: r,
            from_remote: !0
          });
        }
    }
    async sync_nodespace() {
      if (!this.context.worker._zustand || !this.context.worker.is_open) return;
      const t = await this.context.worker.getCommunicationManager()._send_cmd({
        cmd: "get_nodes",
        kwargs: { with_frontend: !0 },
        wait_for_response: !0,
        unique: !0
      });
      for (const o of t)
        this.eventManager._receive_node_added(o);
      const n = await this.context.worker.getCommunicationManager()._send_cmd({
        cmd: "get_edges",
        wait_for_response: !0,
        unique: !0
      });
      for (const o of n)
        this.eventManager._receive_edge_added(...o);
      const r = await this.context.worker.getCommunicationManager()._send_cmd({
        cmd: "get_groups",
        kwargs: {},
        wait_for_response: !0,
        unique: !0
      });
      this.eventManager._receive_groups(r);
    }
    async fullsync() {
      if (!this.context.worker._zustand || !this.context.worker.is_open) return;
      let t;
      for (; ; )
        try {
          t = await this.communicationManager._send_cmd({
            cmd: "full_state",
            unique: !0
          });
          break;
        } catch (o) {
          o instanceof Error ? this.context.worker._zustand.logger.error("Error in fullsync", o) : this.context.worker._zustand.logger.error(
            "Error in fullsync",
            new Error(JSON.stringify(o))
          );
        }
      this.context.worker._zustand.logger.debug("Full state", t), this.context.worker._zustand.lib.libstate.getState().set({
        lib: t.backend.lib,
        external_worker: t.worker_dependencies
      }), t.view.renderoptions && this.context.worker._zustand.update_render_options(
        t.view.renderoptions
      );
      const n = t.view.nodes;
      for (const o of t.backend.nodes) {
        const a = n[o.id];
        a !== void 0 && QA(o, a), this.eventManager._receive_node_added(o);
      }
      for (const o of t.backend.edges)
        this.eventManager._receive_edge_added(...o);
      const r = t.backend.groups;
      r && this.eventManager._receive_groups(r);
    }
    sync_local_node_updates() {
      clearTimeout(this._nodeupdatetimer), this._local_nodeupdates.forEach(async (t, n) => {
        const r = await this.context.worker.getCommunicationManager()._send_cmd({
          cmd: "update_node",
          kwargs: { nid: n, data: t },
          wait_for_response: !0
        });
        this.context.worker._zustand && Object.keys(r).length > 0 && this.context.worker._zustand.on_node_action({
          type: "update",
          node: r,
          id: n,
          from_remote: !0
        });
      }), this._local_nodeupdates.clear(), this._nodeupdatetimer = setTimeout(() => {
        this.sync_local_node_updates();
      }, ZA);
    }
    sync_local_group_updates() {
      clearTimeout(this._groupupdatetimer), this._local_groupupdates.forEach(async (t, n) => {
        const r = await this.communicationManager._send_cmd({
          cmd: "update_group",
          kwargs: { gid: n, data: t },
          wait_for_response: !0
        });
        this.context.worker._zustand && this.context.worker._zustand.on_group_action({
          type: "update",
          group: r,
          id: n,
          from_remote: !0
        });
      }), this._local_groupupdates.clear(), this._groupupdatetimer = setTimeout(() => {
        this.sync_local_group_updates();
      }, e$);
    }
    locally_update_node(t) {
      const n = this._local_nodeupdates.get(t.id);
      if (n) {
        const { new_obj: r, change: o } = tl(n, t.node);
        o && this._local_nodeupdates.set(t.id, r);
      } else
        this._local_nodeupdates.set(t.id, t.node);
      t.immediate && this.sync_local_node_updates();
    }
    locally_update_group(t) {
      const n = this._local_groupupdates.get(t.id);
      if (n) {
        const { new_obj: r, change: o } = tl(n, t.group);
        o && this._local_groupupdates.set(t.id, r);
      } else
        this._local_groupupdates.set(t.id, t.group);
      t.immediate && this.sync_local_group_updates();
    }
  }
  class Ia {
    /**
     * Creates a new DataStructure instance.
     *
     * @param props - Configuration object containing data and MIME type
     */
    constructor({ data: t, mime: n }) {
      this._data = t, this._mime = n;
    }
    /**
     * Gets the raw wrapped data.
     *
     * @returns The original data in its native type
     */
    get data() {
      return this._data;
    }
    /**
     * Gets the data cast to the expected return type.
     * This is a type assertion and should be overridden in subclasses for proper type conversion.
     *
     * @returns The data cast to type R
     */
    get value() {
      return this._data;
    }
    /**
     * Gets the MIME type of the wrapped data.
     *
     * @returns The MIME type string
     */
    get mime() {
      return this._mime;
    }
    /**
     * Returns a string representation of the DataStructure.
     * The format varies based on the data type:
     * - ArrayBuffer: shows byte length
     * - Blob: shows size
     * - String/Array: shows length
     * - Object: shows number of keys
     * - Other types: shows only MIME type
     *
     * @returns String representation in format "DataStructure(size,mime)" or "DataStructure(mime)"
     */
    toString() {
      return this._data instanceof ArrayBuffer ? `DataStructure(${this._data.byteLength},${this._mime})` : this._data instanceof Blob ? `DataStructure(${this._data.size},${this._mime})` : this._data instanceof String ? `DataStructure(${this._data.length},${this._mime})` : this._data instanceof Array ? `DataStructure(${this._data.length},${this._mime})` : this._data instanceof Object ? `DataStructure(${Object.keys(this._data).length},${this._mime})` : `DataStructure(${this._mime})`;
    }
    /**
     * Returns the JSON representation of this DataStructure.
     * Currently delegates to toString() method.
     *
     * @returns JSON string representation
     */
    toJSON() {
      return this.toString();
    }
    /**
     * Cleans up resources associated with this DataStructure.
     * Base implementation does nothing, but subclasses may override to release resources.
     */
    dispose() {
    }
  }
  class v8 extends Ia {
    constructor({ data: t, mime: n }) {
      super({ data: Tw(t), mime: n });
    }
    get objectUrl() {
      if (this._objectUrl)
        return this._objectUrl;
      const t = this.data instanceof Blob ? this.data : new Blob([this.data], { type: this.mime });
      return this._objectUrl = URL.createObjectURL(t), this._objectUrl;
    }
    dispose() {
      this._objectUrl && URL.revokeObjectURL(this._objectUrl), super.dispose();
    }
    get value() {
      return this.objectUrl;
    }
  }
  const Tw = (e) => {
    if (e instanceof ArrayBuffer)
      return e;
    const t = ArrayBuffer.isView(e) ? new Uint8Array(e.buffer, e.byteOffset, e.byteLength) : new Uint8Array(e), n = new ArrayBuffer(t.byteLength);
    return new Uint8Array(n).set(t), n;
  }, Zce = {
    x: (e, t) => null,
    //  pad byte 	no value 	(7 )
    c: (e, t) => new DataView(e).getInt8(0),
    //  char 	bytes of length 1 	1 	b 	signed char 	integer 	1 	(1 ), (2 )
    B: (e, t) => new DataView(e).getUint8(0),
    //  unsigned char 	integer 	1 	(2 )
    "?": (e, t) => new DataView(e).getInt8(0) === 1,
    //  _Bool 	bool 	1 	(1 )
    h: (e, t) => new DataView(e).getInt16(0, t),
    //  short 	integer 	2 	(2 )
    H: (e, t) => new DataView(e).getUint16(0, t),
    //  unsigned short 	integer 	2 	(2 )
    i: (e, t) => new DataView(e).getInt32(0, t),
    //  int 	integer 	4 	(2 )
    I: (e, t) => new DataView(e).getUint32(0, t),
    //  unsigned int 	integer 	4 	(2 )
    l: (e, t) => new DataView(e).getInt32(0, t),
    //  long 	integer 	4 	(2 )
    L: (e, t) => new DataView(e).getUint32(0, t),
    //  unsigned long 	integer 	4 	(2 )
    q: (e, t) => Number(
      new DataView(e).getBigInt64(0, t)
    ),
    //  long long 	integer 	8 	(2 )
    Q: (e, t) => Number(
      new DataView(e).getBigUint64(0, t)
    ),
    //  unsigned long long 	integer 	8 	(2 )
    n: (e, t) => Number(
      new DataView(e).getBigInt64(0, t)
    ),
    //  ssize_t 	integer 	(3 )
    N: (e, t) => Number(
      new DataView(e).getBigUint64(0, t)
    ),
    //  size_t 	integer 	(3 )
    // "e":(data:ArrayBufferLike)=>{return new DataView(to_arraybuffer(data)).getFloat16(0)}, //  (6 ) float 	2 	(4 )
    f: (e, t) => new DataView(e).getFloat32(0, t),
    //  float 	float 	4 	(4 )
    d: (e, t) => new DataView(e).getFloat64(0, t),
    //  double 	float 	8 	(4 )
    s: (e, t) => new TextDecoder().decode(e),
    //  char[] 	bytes 	(9 )
    p: (e, t) => new TextDecoder().decode(e),
    //  char[] 	bytes 	(8 )
    P: (e, t) => Number(
      new DataView(e).getBigUint64(0, t)
    )
    //  void* 	int
  };
  class y8 extends Ia {
    constructor({ data: t, mime: n }) {
      super({ data: Tw(t), mime: n }), this._cType = n.split("application/fn.struct.")[1], this._value = null, this.parse_value();
    }
    parse_value() {
      let t = !0, n = this._cType;
      return n.startsWith("<") && (t = !0, n = n.slice(1)), n.startsWith(">") && (t = !1, n = n.slice(1)), n.startsWith("!") && (t = !1, n = n.slice(1)), n.startsWith("@") && (t = !1, n = n.slice(1)), n.startsWith("=") && (t = !1, n = n.slice(1)), this._value = Zce[n](this.data, t), this._value;
    }
    get value() {
      return this._value;
    }
    toString() {
      return this._value === null ? "null" : this._value.toString();
    }
  }
  class Gs extends Ia {
    constructor({ data: t, mime: n }) {
      const r = Tw(t);
      super({ data: r, mime: n }), r.byteLength === 0 ? this._json = void 0 : (this._json = JSON.parse(new TextDecoder().decode(r)), this._json === "<NoValue>" && (this._json = void 0));
    }
    get value() {
      return this._json;
    }
    static fromObject(t) {
      const n = t === "<NoValue>" ? new Uint8Array(0) : new TextEncoder().encode(JSON.stringify(t));
      return new Gs({ data: n, mime: "application/json" });
    }
    toString() {
      return typeof this._json == "string" ? this._json : JSON.stringify(this._json);
    }
  }
  class b8 extends Ia {
    constructor({ data: t, mime: n }) {
      const r = Tw(t);
      super({ data: r, mime: n }), this._value = new TextDecoder().decode(r);
    }
    get value() {
      return this._value;
    }
    toString() {
      return this._value;
    }
  }
  const w8 = ({
    data: e,
    mime: t
  }) => {
    const n = typeof SharedArrayBuffer < "u" && e instanceof SharedArrayBuffer;
    return e instanceof ArrayBuffer || ArrayBuffer.isView(e) || n ? t.startsWith("application/fn.struct.") ? new y8({ data: e, mime: t }) : t.startsWith("application/json") ? new Gs({ data: e, mime: t }) : t === "text" || t.startsWith("text/") ? new b8({ data: e, mime: t }) : new v8({ data: e, mime: t }) : new Ia({ data: e, mime: t });
  };
  class ede extends ts {
    constructor(t) {
      super(t), this.CHUNK_TIMEOUT = 1e4, this._unique_cmd_outs = {}, this.blobChunks = {}, this.cleanupChunks = () => {
        const n = Date.now();
        for (const r in this.blobChunks)
          n - this.blobChunks[r].timestamp > this.CHUNK_TIMEOUT && delete this.blobChunks[r];
      }, this.messagePromises = /* @__PURE__ */ new Map();
    }
    start() {
      this._chunk_cleanup_timer = setInterval(
        this.cleanupChunks.bind(this),
        this.CHUNK_TIMEOUT / 2
      );
    }
    stop() {
      this._chunk_cleanup_timer && clearInterval(this._chunk_cleanup_timer);
    }
    send(t) {
      this.context.worker.send(t);
    }
    async _send_cmd({
      cmd: t,
      kwargs: n,
      as_bytes: r = !1,
      wait_for_response: o = !0,
      response_timeout: a = 5e3,
      retries: i = 2,
      unique: s = !1
    }) {
      const u = {
        type: "cmd",
        as_bytes: r,
        cmd: t,
        kwargs: n || {}
      };
      if (await new Promise(async (c) => {
        if (this.context.worker.is_responsive) return c();
        const f = setInterval(() => {
          this.context.worker.is_responsive && (clearInterval(f), c());
        }, 100);
      }), o) {
        if (s && this._unique_cmd_outs[u.cmd] !== void 0)
          return this._unique_cmd_outs[u.cmd];
        i < 0 && (i = 0);
        const c = (async () => {
          let f;
          for (; i >= 0; ) {
            const p = u.id || rP();
            u.id = p;
            const g = new Promise((h, y) => {
              const b = setTimeout(() => {
                y("Timeout@wait_for_response for " + t);
              }, a);
              this.messagePromises.set(p, {
                resolve: (v) => {
                  clearTimeout(b), h(v), this.messagePromises.delete(p);
                },
                reject: (v) => {
                  clearTimeout(b), y(v), this.messagePromises.delete(p);
                }
              });
            });
            await this.send(u);
            try {
              f = await g;
              break;
            } catch (h) {
              if (i === 0)
                throw delete this._unique_cmd_outs[u.cmd], h;
              i -= 1;
              continue;
            }
          }
          return delete this._unique_cmd_outs[u.cmd], f;
        })();
        return s && (this._unique_cmd_outs[u.cmd] = c), c;
      }
      return this.send(u);
    }
    async receive(t) {
      let n;
      switch (this.connectionHealthManager.receivePong(), t.type) {
        case "pong":
          return this.connectionHealthManager.receivePong();
        case "nsevent":
          return await this.context.worker.getEventManager().receive_nodespace_event(t);
        case "result":
          if (n = t.id && this.messagePromises.get(t.id), n)
            return n.resolve(t.result);
          break;
        case "error":
          if (this.context.worker.on_error(t.tb + `
` + t.error), n = t.id && this.messagePromises.get(t.id), n)
            return n.reject(t.error);
          break;
        case "progress":
          if (!this.context.worker._zustand) return;
          this.context.worker._zustand.set_progress(t);
          break;
        case "workerevent":
          return await this.context.worker.getEventManager().receive_workerevent(t);
        case "large_message":
          return await this.context.worker.handle_large_message_hint(t);
        default:
          console.warn("Unhandled message", t);
          break;
      }
    }
    async receive_bytes(t, n) {
      const { type: r } = t;
      if (r === "io_value") {
        if (!this.context.worker._zustand) return;
        const { node: o, io: a, preview: i, mime: s } = t, u = i ? "value" : "fullvalue";
        (!o || !a) && console.error("Invalid io_value message", t);
        const c = w8({
          data: n,
          mime: s || "application/octet-stream"
        });
        this.context.worker._zustand.on_node_action({
          type: "update",
          node: {
            id: o,
            io: {
              [a]: {
                [u]: c
              }
            }
          },
          id: o,
          from_remote: !0
        });
      } else if (r == "result") {
        const o = t.id && this.messagePromises.get(t.id);
        o && o.resolve({ bytes: n, header: t });
      } else
        console.warn("Unhandled bytes message", t);
    }
    async onbytes(t) {
      try {
        const n = new TextDecoder("utf-8").decode(t), r = n.indexOf(`\r
\r
`);
        if (r === -1) {
          console.error(`Header terminator not found for:
`, n);
          return;
        }
        const o = n.substring(0, r + 4), a = t.slice(r + 4), i = o.split(";"), s = {};
        if (i.forEach((p) => {
          const [g, h] = p.split("=");
          s[g.trim()] = h.trim();
        }), !s.chunk || !s.msgid) {
          console.error(
            "Header missing required fields chunk or msgid",
            s
          );
          return;
        }
        const [u, c] = s.chunk.split("/"), f = s.msgid;
        if (u === "1" && c === "1")
          return this.receive_bytes(s, a);
        if (this.blobChunks[f] || (this.blobChunks[f] = {
          chunks: Array.from({ length: parseInt(c) }, () => null),
          timestamp: Date.now()
        }), this.blobChunks[f].chunks.length !== parseInt(c)) {
          console.error("Total chunks mismatch");
          return;
        }
        if (this.blobChunks[f].chunks[parseInt(u) - 1] = t, this.blobChunks[f].chunks.every((p) => p !== null)) {
          const p = new Uint8Array(
            this.blobChunks[f].chunks.reduce((g, h) => g.concat(Array.from(h)), [])
          );
          this.receive_bytes(s, p), delete this.blobChunks[f];
        }
      } catch (n) {
        console.error("Websocketworker: onbytes error", n, t);
        return;
      }
    }
  }
  class tde extends ts {
    constructor() {
      super(...arguments), this._ns_event_intercepts = /* @__PURE__ */ new Map();
    }
    start() {
    }
    stop() {
    }
    async _receive_edge_added(t, n, r, o) {
      this.context.worker._zustand && this.context.worker._zustand.on_edge_action({
        type: "add",
        from_remote: !0,
        src_nid: t,
        src_ioid: n,
        trg_nid: r,
        trg_ioid: o
      });
    }
    async _receive_groups(t) {
      this.context.worker._zustand && this.context.worker._zustand.on_group_action({
        type: "set",
        groups: t
      });
    }
    async _receive_node_added(t) {
      if (this.context.worker._zustand)
        return this.context.worker._zustand.on_node_action({
          type: "add",
          node: t,
          id: t.id,
          from_remote: !0
        });
    }
    async receive_workerevent({ event: t, data: n }) {
      switch (t) {
        case "worker_error":
          return this.context.worker._zustand ? this.context.worker._zustand.logger.error(n.error) : void 0;
        case "update_worker_dependencies":
          return this.context.worker._zustand ? this.context.worker._zustand.lib.libstate.getState().set({
            external_worker: n.worker_dependencies
          }) : void 0;
        case "lib_update":
          await this.context.worker.getSyncManager().sync_lib();
          return;
        case "fullsync":
          await this.context.worker.getSyncManager().stepwise_fullsync();
          return;
        case "external_worker_update":
          await this.context.worker.getSyncManager().sync_lib(), await this.context.worker.getSyncManager().sync_external_worker();
          return;
        case "repos_update":
          await this.hookManager.call_hooks(
            "repos_update",
            n.repos ?? n
          );
          return;
        case "starting":
          this.hookManager.call_hooks("starting");
          return;
        case "stopping":
          this.hookManager.call_hooks("stopping");
          return;
        default:
          console.warn("Unhandled worker event", t, n);
          break;
      }
    }
    async intercept_ns_event(t) {
      let n = t;
      for (const r of this._ns_event_intercepts.get(t.event) || [])
        n = await r(n);
      return n;
    }
    async receive_nodespace_event(t) {
      const { event: n, data: r } = await this.intercept_ns_event(t);
      switch (n) {
        case "after_set_value":
          return this.context.worker._zustand ? this.context.worker._zustand.on_node_action({
            type: "update",
            node: {
              id: r.node,
              io: {
                [r.io]: {
                  value: r.result
                }
              }
            },
            id: r.node,
            from_remote: !0
          }) : void 0;
        case "after_update_value_options":
          return this.context.worker._zustand ? this.context.worker._zustand.on_node_action({
            type: "update",
            node: {
              id: r.node,
              io: {
                [r.io]: {
                  value_options: r.result
                }
              }
            },
            id: r.node,
            from_remote: !0
          }) : void 0;
        case "triggerstart":
          return this.context.worker._zustand ? this.context.worker._zustand.on_node_action({
            type: "update",
            node: {
              id: r.node,
              in_trigger: !0
            },
            id: r.node,
            from_remote: !0
          }) : void 0;
        case "triggerdone":
          return this.context.worker._zustand ? this.context.worker._zustand.on_node_action({
            type: "update",
            node: {
              id: r.node,
              in_trigger: !1
            },
            id: r.node,
            from_remote: !0
          }) : void 0;
        case "triggerfast":
          if (!this.context.worker._zustand) return;
          this.context.worker._zustand.on_node_action({
            type: "update",
            node: {
              id: r.node,
              in_trigger: !0
            },
            id: r.node,
            from_remote: !0
          }), setTimeout(() => {
            this.context.worker._zustand && this.context.worker._zustand.on_node_action({
              type: "update",
              node: {
                id: r.node,
                in_trigger: !1
              },
              id: r.node,
              from_remote: !0
            });
          }, 50);
          return;
        case "node_trigger_error":
          return this.context.worker._zustand ? this.context.worker._zustand.on_node_action({
            type: "error",
            errortype: "trigger",
            error: r.error,
            id: r.node,
            tb: r.tb,
            from_remote: !0
          }) : void 0;
        case "node_removed":
          if (!this.context.worker._zustand) return;
          this.context.worker._zustand.on_node_action({
            type: "delete",
            id: r.node,
            from_remote: !0
          }), this.hookManager.call_hooks("node_removed", {
            node: r.node
          });
          return;
        case "node_added":
          this._receive_node_added(r.node);
          return;
        case "after_disconnect":
          return !r.result || !Array.isArray(r.result) || r.result.length !== 4 || !this.context.worker._zustand ? void 0 : this.context.worker._zustand.on_edge_action({
            type: "delete",
            from_remote: !0,
            src_nid: r.result[0],
            src_ioid: r.result[1],
            trg_nid: r.result[2],
            trg_ioid: r.result[3]
          });
        case "after_unforward":
          return !r.result || !Array.isArray(r.result) || r.result.length !== 4 || !this.context.worker._zustand ? void 0 : this.context.worker._zustand.on_edge_action({
            type: "delete",
            from_remote: !0,
            src_nid: r.result[0],
            src_ioid: r.result[1],
            trg_nid: r.result[2],
            trg_ioid: r.result[3]
          });
        case "after_connect":
          return !r.result || !Array.isArray(r.result) || r.result.length !== 4 ? void 0 : this._receive_edge_added(
            ...r.result
          );
        case "after_forward":
          return !r.result || !Array.isArray(r.result) || r.result.length !== 4 ? void 0 : this._receive_edge_added(
            ...r.result
          );
        case "after_add_shelf":
          return !r.result || !this.context.worker._zustand ? void 0 : this.context.worker._zustand.lib.libstate.getState().set({
            lib: r.result
          });
        case "after_remove_shelf":
          return !r.result || !this.context.worker._zustand ? void 0 : this.context.worker._zustand.lib.libstate.getState().set({
            lib: r.result
          });
        case "progress":
          if (!this.context.worker._zustand) return;
          if (r.node)
            return this.context.worker._zustand.on_node_action({
              type: "update",
              node: {
                id: r.node,
                progress: r.info
              },
              id: r.node,
              from_remote: !0
            });
          console.warn("Unhandled nodepsace event", n, r);
          break;
        default:
          if (["after_set_nodespace"].includes(n)) return;
          console.warn("Unhandled nodepsace event", n, r);
          break;
      }
    }
    add_ns_event_intercept(t, n) {
      const r = this._ns_event_intercepts.get(t) || [];
      return r.push(n), this._ns_event_intercepts.set(t, r), () => {
        const o = this._ns_event_intercepts.get(t) || [], a = o.indexOf(n);
        a >= 0 && o.splice(a, 1);
      };
    }
  }
  class nde extends ts {
    constructor() {
      super(...arguments), this._hooks = /* @__PURE__ */ new Map();
    }
    start() {
    }
    stop() {
    }
    add_hook(t, n) {
      const r = this._hooks.get(t) || [];
      return r.push(n), this._hooks.set(t, r), () => {
        const o = this._hooks.get(t) || [], a = o.indexOf(n);
        a >= 0 && o.splice(a, 1);
      };
    }
    async call_hooks(t, n) {
      const r = [];
      for (const o of this._hooks.get(t) || []) {
        const a = o({ worker: this.context.worker, data: n });
        a instanceof Promise && r.push(a);
      }
      await Promise.all(r);
    }
  }
  class rde extends ts {
    start() {
    }
    stop() {
    }
    async trigger_node(t) {
      await this.communicationManager._send_cmd({
        cmd: "trigger_node",
        kwargs: { nid: t },
        wait_for_response: !1
      });
    }
    async add_node(t) {
      const n = await this.communicationManager._send_cmd({
        cmd: "add_node",
        kwargs: { id: t }
      });
      return this.eventManager._receive_node_added(n);
    }
    async remove_node(t) {
      await this.communicationManager._send_cmd({
        cmd: "remove_node",
        kwargs: { id: t }
      });
    }
    locally_update_node(t) {
      this.syncManager.locally_update_node(t);
    }
    set_io_value({
      nid: t,
      ioid: n,
      value: r,
      set_default: o = !1
    }) {
      return this.communicationManager._send_cmd({
        cmd: "set_io_value",
        kwargs: { nid: t, ioid: n, value: r, set_default: o },
        wait_for_response: !0
      });
    }
    set_io_value_options({
      nid: t,
      ioid: n,
      values: r,
      keys: o,
      nullable: a
    }) {
      return this.communicationManager._send_cmd({
        cmd: "update_io_value_options",
        kwargs: {
          nid: t,
          ioid: n,
          options: {
            options: {
              type: "enum",
              values: r,
              keys: o,
              nullable: a
            }
          }
        }
      });
    }
    async get_io_value({ nid: t, ioid: n }) {
      const r = await this.communicationManager._send_cmd({
        cmd: "get_io_value",
        kwargs: { nid: t, ioid: n },
        wait_for_response: !0
      });
      return this.context.worker._zustand && this.context.worker._zustand.on_node_action({
        type: "update",
        node: {
          io: {
            [n]: {
              value: r
            }
          }
        },
        id: t,
        from_remote: !0
      }), r;
    }
    async get_ios_values({ nid: t }) {
      const n = await this.communicationManager._send_cmd({
        cmd: "get_ios_values",
        kwargs: { nid: t },
        wait_for_response: !0
      });
      if (!this.context.worker._zustand) return n;
      const r = {};
      for (const o in n)
        r[o] = { value: n[o] };
      return this.context.worker._zustand.on_node_action({
        type: "update",
        node: {
          io: r
        },
        id: t,
        from_remote: !0
      }), n;
    }
    async get_io_full_value({ nid: t, ioid: n }) {
      const r = await this.communicationManager._send_cmd({
        cmd: "get_io_full_value",
        kwargs: { nid: t, ioid: n },
        wait_for_response: !0,
        as_bytes: !0
      }), { header: o, bytes: a } = r, { mime: i } = o, s = w8({
        data: a,
        mime: i || "application/octet-stream"
      });
      return this.context.worker._zustand?.on_node_action?.({
        type: "update",
        node: {
          id: t,
          io: {
            [n]: {
              fullvalue: s
            }
          }
        },
        id: t,
        from_remote: !0
      }), s;
    }
    async update_io_options({
      nid: t,
      ioid: n,
      options: r
    }) {
      const o = await this.communicationManager._send_cmd({
        cmd: "update_io_options",
        kwargs: { nid: t, ioid: n, ...r },
        wait_for_response: !0
      });
      if (!this.context.worker._zustand) return o;
      this.context.worker._zustand.on_node_action({
        type: "update",
        node: {
          io: {
            [n]: {
              ...r
            }
          }
        },
        id: t,
        from_remote: !0
      });
    }
    async get_node_status(t) {
      return await this.communicationManager._send_cmd({
        cmd: "get_node_state",
        kwargs: { nid: t },
        wait_for_response: !0
      });
    }
    async get_remote_node_state(t) {
      const n = await this.communicationManager._send_cmd({
        cmd: "get_node_state",
        kwargs: { nid: t },
        wait_for_response: !0
      });
      this.context.worker._zustand && this.context.worker._zustand.on_node_action({
        type: "update",
        node: n,
        id: n.id,
        from_remote: !0
      });
    }
  }
  class ode extends ts {
    start() {
    }
    stop() {
    }
    add_edge({
      src_nid: t,
      src_ioid: n,
      trg_nid: r,
      trg_ioid: o,
      replace: a = !1
    }) {
      return this.communicationManager._send_cmd({
        cmd: "add_edge",
        kwargs: { src_nid: t, src_ioid: n, trg_nid: r, trg_ioid: o, replace: a }
      });
    }
    remove_edge({
      src_nid: t,
      src_ioid: n,
      trg_nid: r,
      trg_ioid: o
    }) {
      return this.communicationManager._send_cmd({
        cmd: "remove_edge",
        kwargs: { src_nid: t, src_ioid: n, trg_nid: r, trg_ioid: o }
      });
    }
  }
  class ade extends ts {
    start() {
    }
    stop() {
    }
    async group_nodes(t, n) {
      const r = await this.communicationManager._send_cmd({
        cmd: "group_nodes",
        kwargs: { node_ids: t, group_ids: n },
        wait_for_response: !0
      });
      return this.eventManager._receive_groups(r), r;
    }
    async remove_group(t) {
      await this.communicationManager._send_cmd({
        cmd: "remove_group",
        kwargs: { gid: t },
        wait_for_response: !0
      }), await this.syncManager.sync_nodespace();
    }
    locally_update_group(t) {
      this.syncManager.locally_update_group(t);
    }
  }
  class ide extends ts {
    constructor() {
      super(...arguments), this._available_modules_cache = {
        installed: [],
        available: [],
        active: []
      };
    }
    start() {
    }
    stop() {
    }
    async add_external_worker({
      module: t,
      cls_module: n,
      cls_name: r
    }) {
      return await this.communicationManager._send_cmd({
        cmd: "add_external_worker",
        kwargs: { module: t, cls_module: n, cls_name: r }
      });
    }
    async add_lib(t, n) {
      return await this.communicationManager._send_cmd({
        cmd: "add_package_dependency",
        kwargs: { name: t, version: n },
        wait_for_response: !1
      });
    }
    async remove_lib(t) {
      return await this.communicationManager._send_cmd({
        cmd: "remove_package_dependency",
        kwargs: { name: t },
        wait_for_response: !1
      });
    }
    async get_available_modules({
      wait_for_response: t = !1,
      on_load: n
    }) {
      const r = this.communicationManager._send_cmd({
        cmd: "get_available_modules",
        wait_for_response: !0,
        unique: !0
      }).then((o) => {
        this._available_modules_cache = o, n && n(this._available_modules_cache);
      });
      return t && await r, this._available_modules_cache;
    }
    async remove_external_worker(t, n) {
      return await this.communicationManager._send_cmd({
        cmd: "remove_external_worker",
        kwargs: { worker_id: t, class_id: n },
        wait_for_response: !0
      });
    }
    async get_external_worker_config(t, n) {
      return await this.communicationManager._send_cmd({
        cmd: "get_external_worker_config",
        kwargs: { worker_id: t, class_id: n },
        wait_for_response: !0
      });
    }
  }
  class oP {
    // Public getter for handlers to access eventManager
    getEventManager() {
      return this._eventManager;
    }
    getSyncManager() {
      return this._syncManager;
    }
    getCommunicationManager() {
      return this._communicationManager;
    }
    getConnectionHealthManager() {
      return this._connectionhealthManager;
    }
    getHookManager() {
      return this._hookManager;
    }
    getNodeManager() {
      return this._nodeManager;
    }
    getEdgeManager() {
      return this._edgeManager;
    }
    getGroupManager() {
      return this._groupManager;
    }
    getLibraryManager() {
      return this._libraryManager;
    }
    constructor(t) {
      this.uuid = t.uuid, this.on_error = t.on_error || ((r) => {
        this._zustand?.logger.error(r);
      }), this.state = Ro((r, o) => ({
        is_open: !1
      }));
      const n = { worker: this };
      this._connectionhealthManager = new Jce(
        n
      ), this._communicationManager = new ede(n), this._eventManager = new tde({
        ...n
      }), this._syncManager = new Qce({
        ...n,
        on_sync_complete: t.on_sync_complete
      }), this._hookManager = new nde(n), this._nodeManager = new rde(n), this._edgeManager = new ode(n), this._groupManager = new ade(n), this._libraryManager = new ide(n), this._communicationManager.start(), this._connectionhealthManager.start(), this._syncManager.start(), this._eventManager.start(), this._hookManager.start(), this._nodeManager.start(), this._edgeManager.start(), this._groupManager.start(), this._libraryManager.start(), t.zustand && this.set_zustand(t.zustand), this.api = {
        node: this._nodeManager,
        group: this._groupManager,
        edge: this._edgeManager,
        hooks: this._hookManager,
        lib: this._libraryManager
      };
    }
    set_zustand(t) {
      t !== this._zustand && (t.logger.debug("Setting zustand for worker"), this._zustand = t, t.set_worker(this), this._zustand.auto_progress(), this._syncManager.stepwise_fullsync());
    }
    get is_open() {
      return this.state.getState().is_open;
    }
    set is_open(t) {
      this.state.setState({ is_open: t });
    }
    get is_responsive() {
      return this._connectionhealthManager.isResponsive();
    }
    clear() {
      return this._communicationManager._send_cmd({ cmd: "clear", unique: !0 });
    }
    save() {
      return this._communicationManager._send_cmd({
        cmd: "save",
        wait_for_response: !0,
        unique: !0
      });
    }
    load(t) {
      return this._communicationManager._send_cmd({
        cmd: "load_data",
        kwargs: { data: t },
        wait_for_response: !0
      }).then(() => {
        this._syncManager.stepwise_fullsync();
      });
    }
    async get_runstate() {
      return await this._communicationManager._send_cmd({
        cmd: "get_runstate",
        wait_for_response: !0,
        unique: !0
      });
    }
    async send(t) {
      throw new Error("async send(data: any)  not implemented");
    }
    async upload_file(t) {
      throw new Error("upload_file not implemented ");
    }
    async handle_large_message_hint({}) {
      throw new Error(
        "async handle_large_message_hint({}: LargeMessageHint) not implemented "
      );
    }
    disconnect() {
    }
    onclose() {
      this.is_open = !1, this._zustand && this._zustand.auto_progress();
    }
    async reconnect() {
    }
    async stop() {
      window.localStorage.getItem("funcnodes__active_worker") == this.uuid && window.localStorage.removeItem("funcnodes__active_worker"), await this._communicationManager._send_cmd({
        cmd: "stop_worker",
        wait_for_response: !1
      });
      const t = this.onclose.bind(this);
      this.onclose = () => {
        t(), this._zustand && (this._zustand.worker === this && this._zustand.clear_all(), this.onclose = t);
      };
    }
    async update_external_worker(t, n, r) {
      return await this._communicationManager._send_cmd({
        cmd: "update_external_worker",
        kwargs: { worker_id: t, class_id: n, ...r },
        wait_for_response: !0
      });
    }
    async export({ withFiles: t = !1 }) {
      return await this._communicationManager._send_cmd({
        cmd: "export_worker",
        wait_for_response: !0,
        kwargs: { with_files: t }
      });
    }
    async update_from_export(t) {
      const n = this._hookManager.add_hook("node_added", async ({}) => {
        this._zustand?.center_all();
      });
      try {
        const r = await this._communicationManager._send_cmd({
          cmd: "update_from_export",
          kwargs: { data: t },
          wait_for_response: !0,
          response_timeout: 6e5,
          // 10 minutes
          unique: !0
        });
        return await new Promise((o) => {
          setTimeout(() => {
            o();
          }, 1e3);
        }), await this._syncManager.stepwise_fullsync(), r;
      } finally {
        n();
      }
    }
    /**
     * @deprecated This method is deprecated. Use the API or getCommunicationManager()._send_cmd directly instead.
     */
    _send_cmd(t) {
      return this._communicationManager._send_cmd(t);
    }
    /**
     * @deprecated This method is deprecated. Use the API or getNodeManager().set_io_value directly instead.
     */
    set_io_value(t) {
      return this._nodeManager.set_io_value(t);
    }
    /**
     * @deprecated This method is deprecated. Use the API or getNodeManager().get_io_value directly instead.
     */
    get_io_value(t) {
      return this._nodeManager.get_io_value(t);
    }
  }
  function x8(e, t) {
    return function() {
      return e.apply(t, arguments);
    };
  }
  const { toString: sde } = Object.prototype, { getPrototypeOf: aP } = Object, { iterator: zw, toStringTag: k8 } = Symbol, Bw = /* @__PURE__ */ ((e) => (t) => {
    const n = sde.call(t);
    return e[n] || (e[n] = n.slice(8, -1).toLowerCase());
  })(/* @__PURE__ */ Object.create(null)), la = (e) => (e = e.toLowerCase(), (t) => Bw(t) === e), Vw = (e) => (t) => typeof t === e, { isArray: zd } = Array, vd = Vw("undefined");
  function Xm(e) {
    return e !== null && !vd(e) && e.constructor !== null && !vd(e.constructor) && Vr(e.constructor.isBuffer) && e.constructor.isBuffer(e);
  }
  const S8 = la("ArrayBuffer");
  function lde(e) {
    let t;
    return typeof ArrayBuffer < "u" && ArrayBuffer.isView ? t = ArrayBuffer.isView(e) : t = e && e.buffer && S8(e.buffer), t;
  }
  const ude = Vw("string"), Vr = Vw("function"), _8 = Vw("number"), Ym = (e) => e !== null && typeof e == "object", cde = (e) => e === !0 || e === !1, Ay = (e) => {
    if (Bw(e) !== "object")
      return !1;
    const t = aP(e);
    return (t === null || t === Object.prototype || Object.getPrototypeOf(t) === null) && !(k8 in e) && !(zw in e);
  }, dde = (e) => {
    if (!Ym(e) || Xm(e))
      return !1;
    try {
      return Object.keys(e).length === 0 && Object.getPrototypeOf(e) === Object.prototype;
    } catch {
      return !1;
    }
  }, fde = la("Date"), pde = la("File"), mde = la("Blob"), hde = la("FileList"), gde = (e) => Ym(e) && Vr(e.pipe), vde = (e) => {
    let t;
    return e && (typeof FormData == "function" && e instanceof FormData || Vr(e.append) && ((t = Bw(e)) === "formdata" || // detect form-data instance
    t === "object" && Vr(e.toString) && e.toString() === "[object FormData]"));
  }, yde = la("URLSearchParams"), [bde, wde, xde, kde] = ["ReadableStream", "Request", "Response", "Headers"].map(la), Sde = (e) => e.trim ? e.trim() : e.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
  function Jm(e, t, { allOwnKeys: n = !1 } = {}) {
    if (e === null || typeof e > "u")
      return;
    let r, o;
    if (typeof e != "object" && (e = [e]), zd(e))
      for (r = 0, o = e.length; r < o; r++)
        t.call(null, e[r], r, e);
    else {
      if (Xm(e))
        return;
      const a = n ? Object.getOwnPropertyNames(e) : Object.keys(e), i = a.length;
      let s;
      for (r = 0; r < i; r++)
        s = a[r], t.call(null, e[s], s, e);
    }
  }
  function E8(e, t) {
    if (Xm(e))
      return null;
    t = t.toLowerCase();
    const n = Object.keys(e);
    let r = n.length, o;
    for (; r-- > 0; )
      if (o = n[r], t === o.toLowerCase())
        return o;
    return null;
  }
  const tu = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : pp, C8 = (e) => !vd(e) && e !== tu;
  function F2() {
    const { caseless: e, skipUndefined: t } = C8(this) && this || {}, n = {}, r = (o, a) => {
      const i = e && E8(n, a) || a;
      Ay(n[i]) && Ay(o) ? n[i] = F2(n[i], o) : Ay(o) ? n[i] = F2({}, o) : zd(o) ? n[i] = o.slice() : (!t || !vd(o)) && (n[i] = o);
    };
    for (let o = 0, a = arguments.length; o < a; o++)
      arguments[o] && Jm(arguments[o], r);
    return n;
  }
  const _de = (e, t, n, { allOwnKeys: r } = {}) => (Jm(t, (o, a) => {
    n && Vr(o) ? e[a] = x8(o, n) : e[a] = o;
  }, { allOwnKeys: r }), e), Ede = (e) => (e.charCodeAt(0) === 65279 && (e = e.slice(1)), e), Cde = (e, t, n, r) => {
    e.prototype = Object.create(t.prototype, r), e.prototype.constructor = e, Object.defineProperty(e, "super", {
      value: t.prototype
    }), n && Object.assign(e.prototype, n);
  }, Pde = (e, t, n, r) => {
    let o, a, i;
    const s = {};
    if (t = t || {}, e == null) return t;
    do {
      for (o = Object.getOwnPropertyNames(e), a = o.length; a-- > 0; )
        i = o[a], (!r || r(i, e, t)) && !s[i] && (t[i] = e[i], s[i] = !0);
      e = n !== !1 && aP(e);
    } while (e && (!n || n(e, t)) && e !== Object.prototype);
    return t;
  }, Ode = (e, t, n) => {
    e = String(e), (n === void 0 || n > e.length) && (n = e.length), n -= t.length;
    const r = e.indexOf(t, n);
    return r !== -1 && r === n;
  }, Nde = (e) => {
    if (!e) return null;
    if (zd(e)) return e;
    let t = e.length;
    if (!_8(t)) return null;
    const n = new Array(t);
    for (; t-- > 0; )
      n[t] = e[t];
    return n;
  }, Mde = /* @__PURE__ */ ((e) => (t) => e && t instanceof e)(typeof Uint8Array < "u" && aP(Uint8Array)), Rde = (e, t) => {
    const n = (e && e[zw]).call(e);
    let r;
    for (; (r = n.next()) && !r.done; ) {
      const o = r.value;
      t.call(e, o[0], o[1]);
    }
  }, jde = (e, t) => {
    let n;
    const r = [];
    for (; (n = e.exec(t)) !== null; )
      r.push(n);
    return r;
  }, Ide = la("HTMLFormElement"), Ade = (e) => e.toLowerCase().replace(
    /[-_\s]([a-z\d])(\w*)/g,
    function(t, n, r) {
      return n.toUpperCase() + r;
    }
  ), t$ = (({ hasOwnProperty: e }) => (t, n) => e.call(t, n))(Object.prototype), $de = la("RegExp"), P8 = (e, t) => {
    const n = Object.getOwnPropertyDescriptors(e), r = {};
    Jm(n, (o, a) => {
      let i;
      (i = t(o, a, e)) !== !1 && (r[a] = i || o);
    }), Object.defineProperties(e, r);
  }, Dde = (e) => {
    P8(e, (t, n) => {
      if (Vr(e) && ["arguments", "caller", "callee"].indexOf(n) !== -1)
        return !1;
      const r = e[n];
      if (Vr(r)) {
        if (t.enumerable = !1, "writable" in t) {
          t.writable = !1;
          return;
        }
        t.set || (t.set = () => {
          throw Error("Can not rewrite read-only method '" + n + "'");
        });
      }
    });
  }, Lde = (e, t) => {
    const n = {}, r = (o) => {
      o.forEach((a) => {
        n[a] = !0;
      });
    };
    return zd(e) ? r(e) : r(String(e).split(t)), n;
  }, Fde = () => {
  }, Tde = (e, t) => e != null && Number.isFinite(e = +e) ? e : t;
  function zde(e) {
    return !!(e && Vr(e.append) && e[k8] === "FormData" && e[zw]);
  }
  const Bde = (e) => {
    const t = new Array(10), n = (r, o) => {
      if (Ym(r)) {
        if (t.indexOf(r) >= 0)
          return;
        if (Xm(r))
          return r;
        if (!("toJSON" in r)) {
          t[o] = r;
          const a = zd(r) ? [] : {};
          return Jm(r, (i, s) => {
            const u = n(i, o + 1);
            !vd(u) && (a[s] = u);
          }), t[o] = void 0, a;
        }
      }
      return r;
    };
    return n(e, 0);
  }, Vde = la("AsyncFunction"), Ude = (e) => e && (Ym(e) || Vr(e)) && Vr(e.then) && Vr(e.catch), O8 = ((e, t) => e ? setImmediate : t ? ((n, r) => (tu.addEventListener("message", ({ source: o, data: a }) => {
    o === tu && a === n && r.length && r.shift()();
  }, !1), (o) => {
    r.push(o), tu.postMessage(n, "*");
  }))(`axios@${Math.random()}`, []) : (n) => setTimeout(n))(
    typeof setImmediate == "function",
    Vr(tu.postMessage)
  ), Hde = typeof queueMicrotask < "u" ? queueMicrotask.bind(tu) : typeof process < "u" && process.nextTick || O8, Wde = (e) => e != null && Vr(e[zw]), he = {
    isArray: zd,
    isArrayBuffer: S8,
    isBuffer: Xm,
    isFormData: vde,
    isArrayBufferView: lde,
    isString: ude,
    isNumber: _8,
    isBoolean: cde,
    isObject: Ym,
    isPlainObject: Ay,
    isEmptyObject: dde,
    isReadableStream: bde,
    isRequest: wde,
    isResponse: xde,
    isHeaders: kde,
    isUndefined: vd,
    isDate: fde,
    isFile: pde,
    isBlob: mde,
    isRegExp: $de,
    isFunction: Vr,
    isStream: gde,
    isURLSearchParams: yde,
    isTypedArray: Mde,
    isFileList: hde,
    forEach: Jm,
    merge: F2,
    extend: _de,
    trim: Sde,
    stripBOM: Ede,
    inherits: Cde,
    toFlatObject: Pde,
    kindOf: Bw,
    kindOfTest: la,
    endsWith: Ode,
    toArray: Nde,
    forEachEntry: Rde,
    matchAll: jde,
    isHTMLForm: Ide,
    hasOwnProperty: t$,
    hasOwnProp: t$,
    // an alias to avoid ESLint no-prototype-builtins detection
    reduceDescriptors: P8,
    freezeMethods: Dde,
    toObjectSet: Lde,
    toCamelCase: Ade,
    noop: Fde,
    toFiniteNumber: Tde,
    findKey: E8,
    global: tu,
    isContextDefined: C8,
    isSpecCompliantForm: zde,
    toJSONObject: Bde,
    isAsyncFn: Vde,
    isThenable: Ude,
    setImmediate: O8,
    asap: Hde,
    isIterable: Wde
  };
  function st(e, t, n, r, o) {
    Error.call(this), Error.captureStackTrace ? Error.captureStackTrace(this, this.constructor) : this.stack = new Error().stack, this.message = e, this.name = "AxiosError", t && (this.code = t), n && (this.config = n), r && (this.request = r), o && (this.response = o, this.status = o.status ? o.status : null);
  }
  he.inherits(st, Error, {
    toJSON: function() {
      return {
        // Standard
        message: this.message,
        name: this.name,
        // Microsoft
        description: this.description,
        number: this.number,
        // Mozilla
        fileName: this.fileName,
        lineNumber: this.lineNumber,
        columnNumber: this.columnNumber,
        stack: this.stack,
        // Axios
        config: he.toJSONObject(this.config),
        code: this.code,
        status: this.status
      };
    }
  });
  const N8 = st.prototype, M8 = {};
  [
    "ERR_BAD_OPTION_VALUE",
    "ERR_BAD_OPTION",
    "ECONNABORTED",
    "ETIMEDOUT",
    "ERR_NETWORK",
    "ERR_FR_TOO_MANY_REDIRECTS",
    "ERR_DEPRECATED",
    "ERR_BAD_RESPONSE",
    "ERR_BAD_REQUEST",
    "ERR_CANCELED",
    "ERR_NOT_SUPPORT",
    "ERR_INVALID_URL"
    // eslint-disable-next-line func-names
  ].forEach((e) => {
    M8[e] = { value: e };
  });
  Object.defineProperties(st, M8);
  Object.defineProperty(N8, "isAxiosError", { value: !0 });
  st.from = (e, t, n, r, o, a) => {
    const i = Object.create(N8);
    he.toFlatObject(e, i, function(c) {
      return c !== Error.prototype;
    }, (c) => c !== "isAxiosError");
    const s = e && e.message ? e.message : "Error", u = t == null && e ? e.code : t;
    return st.call(i, s, u, n, r, o), e && i.cause == null && Object.defineProperty(i, "cause", { value: e, configurable: !0 }), i.name = e && e.name || "Error", a && Object.assign(i, a), i;
  };
  const qde = null;
  function T2(e) {
    return he.isPlainObject(e) || he.isArray(e);
  }
  function R8(e) {
    return he.endsWith(e, "[]") ? e.slice(0, -2) : e;
  }
  function n$(e, t, n) {
    return e ? e.concat(t).map(function(r, o) {
      return r = R8(r), !n && o ? "[" + r + "]" : r;
    }).join(n ? "." : "") : t;
  }
  function Kde(e) {
    return he.isArray(e) && !e.some(T2);
  }
  const Gde = he.toFlatObject(he, {}, null, function(e) {
    return /^is[A-Z]/.test(e);
  });
  function Uw(e, t, n) {
    if (!he.isObject(e))
      throw new TypeError("target must be an object");
    t = t || new FormData(), n = he.toFlatObject(n, {
      metaTokens: !0,
      dots: !1,
      indexes: !1
    }, !1, function(h, y) {
      return !he.isUndefined(y[h]);
    });
    const r = n.metaTokens, o = n.visitor || c, a = n.dots, i = n.indexes, s = (n.Blob || typeof Blob < "u" && Blob) && he.isSpecCompliantForm(t);
    if (!he.isFunction(o))
      throw new TypeError("visitor must be a function");
    function u(h) {
      if (h === null) return "";
      if (he.isDate(h))
        return h.toISOString();
      if (he.isBoolean(h))
        return h.toString();
      if (!s && he.isBlob(h))
        throw new st("Blob is not supported. Use a Buffer instead.");
      return he.isArrayBuffer(h) || he.isTypedArray(h) ? s && typeof Blob == "function" ? new Blob([h]) : Buffer.from(h) : h;
    }
    function c(h, y, b) {
      let v = h;
      if (h && !b && typeof h == "object") {
        if (he.endsWith(y, "{}"))
          y = r ? y : y.slice(0, -2), h = JSON.stringify(h);
        else if (he.isArray(h) && Kde(h) || (he.isFileList(h) || he.endsWith(y, "[]")) && (v = he.toArray(h)))
          return y = R8(y), v.forEach(function(w, _) {
            !(he.isUndefined(w) || w === null) && t.append(
              // eslint-disable-next-line no-nested-ternary
              i === !0 ? n$([y], _, a) : i === null ? y : y + "[]",
              u(w)
            );
          }), !1;
      }
      return T2(h) ? !0 : (t.append(n$(b, y, a), u(h)), !1);
    }
    const f = [], p = Object.assign(Gde, {
      defaultVisitor: c,
      convertValue: u,
      isVisitable: T2
    });
    function g(h, y) {
      if (!he.isUndefined(h)) {
        if (f.indexOf(h) !== -1)
          throw Error("Circular reference detected in " + y.join("."));
        f.push(h), he.forEach(h, function(b, v) {
          (!(he.isUndefined(b) || b === null) && o.call(
            t,
            b,
            he.isString(v) ? v.trim() : v,
            y,
            p
          )) === !0 && g(b, y ? y.concat(v) : [v]);
        }), f.pop();
      }
    }
    if (!he.isObject(e))
      throw new TypeError("data must be an object");
    return g(e), t;
  }
  function r$(e) {
    const t = {
      "!": "%21",
      "'": "%27",
      "(": "%28",
      ")": "%29",
      "~": "%7E",
      "%20": "+",
      "%00": "\0"
    };
    return encodeURIComponent(e).replace(/[!'()~]|%20|%00/g, function(n) {
      return t[n];
    });
  }
  function iP(e, t) {
    this._pairs = [], e && Uw(e, this, t);
  }
  const j8 = iP.prototype;
  j8.append = function(e, t) {
    this._pairs.push([e, t]);
  };
  j8.toString = function(e) {
    const t = e ? function(n) {
      return e.call(this, n, r$);
    } : r$;
    return this._pairs.map(function(n) {
      return t(n[0]) + "=" + t(n[1]);
    }, "").join("&");
  };
  function Xde(e) {
    return encodeURIComponent(e).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+");
  }
  function I8(e, t, n) {
    if (!t)
      return e;
    const r = n && n.encode || Xde;
    he.isFunction(n) && (n = {
      serialize: n
    });
    const o = n && n.serialize;
    let a;
    if (o ? a = o(t, n) : a = he.isURLSearchParams(t) ? t.toString() : new iP(t, n).toString(r), a) {
      const i = e.indexOf("#");
      i !== -1 && (e = e.slice(0, i)), e += (e.indexOf("?") === -1 ? "?" : "&") + a;
    }
    return e;
  }
  class o$ {
    constructor() {
      this.handlers = [];
    }
    /**
     * Add a new interceptor to the stack
     *
     * @param {Function} fulfilled The function to handle `then` for a `Promise`
     * @param {Function} rejected The function to handle `reject` for a `Promise`
     *
     * @return {Number} An ID used to remove interceptor later
     */
    use(t, n, r) {
      return this.handlers.push({
        fulfilled: t,
        rejected: n,
        synchronous: r ? r.synchronous : !1,
        runWhen: r ? r.runWhen : null
      }), this.handlers.length - 1;
    }
    /**
     * Remove an interceptor from the stack
     *
     * @param {Number} id The ID that was returned by `use`
     *
     * @returns {void}
     */
    eject(t) {
      this.handlers[t] && (this.handlers[t] = null);
    }
    /**
     * Clear all interceptors from the stack
     *
     * @returns {void}
     */
    clear() {
      this.handlers && (this.handlers = []);
    }
    /**
     * Iterate over all the registered interceptors
     *
     * This method is particularly useful for skipping over any
     * interceptors that may have become `null` calling `eject`.
     *
     * @param {Function} fn The function to call for each interceptor
     *
     * @returns {void}
     */
    forEach(t) {
      he.forEach(this.handlers, function(n) {
        n !== null && t(n);
      });
    }
  }
  const A8 = {
    silentJSONParsing: !0,
    forcedJSONParsing: !0,
    clarifyTimeoutError: !1
  }, Yde = typeof URLSearchParams < "u" ? URLSearchParams : iP, Jde = typeof FormData < "u" ? FormData : null, Qde = typeof Blob < "u" ? Blob : null, Zde = {
    isBrowser: !0,
    classes: {
      URLSearchParams: Yde,
      FormData: Jde,
      Blob: Qde
    },
    protocols: ["http", "https", "file", "blob", "url", "data"]
  }, sP = typeof window < "u" && typeof document < "u", z2 = typeof navigator == "object" && navigator || void 0, efe = sP && (!z2 || ["ReactNative", "NativeScript", "NS"].indexOf(z2.product) < 0), tfe = typeof WorkerGlobalScope < "u" && // eslint-disable-next-line no-undef
  self instanceof WorkerGlobalScope && typeof self.importScripts == "function", nfe = sP && window.location.href || "http://localhost", rfe = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    hasBrowserEnv: sP,
    hasStandardBrowserEnv: efe,
    hasStandardBrowserWebWorkerEnv: tfe,
    navigator: z2,
    origin: nfe
  }, Symbol.toStringTag, { value: "Module" })), vr = {
    ...rfe,
    ...Zde
  };
  function ofe(e, t) {
    return Uw(e, new vr.classes.URLSearchParams(), {
      visitor: function(n, r, o, a) {
        return vr.isNode && he.isBuffer(n) ? (this.append(r, n.toString("base64")), !1) : a.defaultVisitor.apply(this, arguments);
      },
      ...t
    });
  }
  function afe(e) {
    return he.matchAll(/\w+|\[(\w*)]/g, e).map((t) => t[0] === "[]" ? "" : t[1] || t[0]);
  }
  function ife(e) {
    const t = {}, n = Object.keys(e);
    let r;
    const o = n.length;
    let a;
    for (r = 0; r < o; r++)
      a = n[r], t[a] = e[a];
    return t;
  }
  function $8(e) {
    function t(n, r, o, a) {
      let i = n[a++];
      if (i === "__proto__") return !0;
      const s = Number.isFinite(+i), u = a >= n.length;
      return i = !i && he.isArray(o) ? o.length : i, u ? (he.hasOwnProp(o, i) ? o[i] = [o[i], r] : o[i] = r, !s) : ((!o[i] || !he.isObject(o[i])) && (o[i] = []), t(n, r, o[i], a) && he.isArray(o[i]) && (o[i] = ife(o[i])), !s);
    }
    if (he.isFormData(e) && he.isFunction(e.entries)) {
      const n = {};
      return he.forEachEntry(e, (r, o) => {
        t(afe(r), o, n, 0);
      }), n;
    }
    return null;
  }
  function sfe(e, t, n) {
    if (he.isString(e))
      try {
        return (t || JSON.parse)(e), he.trim(e);
      } catch (r) {
        if (r.name !== "SyntaxError")
          throw r;
      }
    return (n || JSON.stringify)(e);
  }
  const Qm = {
    transitional: A8,
    adapter: ["xhr", "http", "fetch"],
    transformRequest: [function(e, t) {
      const n = t.getContentType() || "", r = n.indexOf("application/json") > -1, o = he.isObject(e);
      if (o && he.isHTMLForm(e) && (e = new FormData(e)), he.isFormData(e))
        return r ? JSON.stringify($8(e)) : e;
      if (he.isArrayBuffer(e) || he.isBuffer(e) || he.isStream(e) || he.isFile(e) || he.isBlob(e) || he.isReadableStream(e))
        return e;
      if (he.isArrayBufferView(e))
        return e.buffer;
      if (he.isURLSearchParams(e))
        return t.setContentType("application/x-www-form-urlencoded;charset=utf-8", !1), e.toString();
      let a;
      if (o) {
        if (n.indexOf("application/x-www-form-urlencoded") > -1)
          return ofe(e, this.formSerializer).toString();
        if ((a = he.isFileList(e)) || n.indexOf("multipart/form-data") > -1) {
          const i = this.env && this.env.FormData;
          return Uw(
            a ? { "files[]": e } : e,
            i && new i(),
            this.formSerializer
          );
        }
      }
      return o || r ? (t.setContentType("application/json", !1), sfe(e)) : e;
    }],
    transformResponse: [function(e) {
      const t = this.transitional || Qm.transitional, n = t && t.forcedJSONParsing, r = this.responseType === "json";
      if (he.isResponse(e) || he.isReadableStream(e))
        return e;
      if (e && he.isString(e) && (n && !this.responseType || r)) {
        const o = !(t && t.silentJSONParsing) && r;
        try {
          return JSON.parse(e, this.parseReviver);
        } catch (a) {
          if (o)
            throw a.name === "SyntaxError" ? st.from(a, st.ERR_BAD_RESPONSE, this, null, this.response) : a;
        }
      }
      return e;
    }],
    /**
     * A timeout in milliseconds to abort a request. If set to 0 (default) a
     * timeout is not created.
     */
    timeout: 0,
    xsrfCookieName: "XSRF-TOKEN",
    xsrfHeaderName: "X-XSRF-TOKEN",
    maxContentLength: -1,
    maxBodyLength: -1,
    env: {
      FormData: vr.classes.FormData,
      Blob: vr.classes.Blob
    },
    validateStatus: function(e) {
      return e >= 200 && e < 300;
    },
    headers: {
      common: {
        Accept: "application/json, text/plain, */*",
        "Content-Type": void 0
      }
    }
  };
  he.forEach(["delete", "get", "head", "post", "put", "patch"], (e) => {
    Qm.headers[e] = {};
  });
  const lfe = he.toObjectSet([
    "age",
    "authorization",
    "content-length",
    "content-type",
    "etag",
    "expires",
    "from",
    "host",
    "if-modified-since",
    "if-unmodified-since",
    "last-modified",
    "location",
    "max-forwards",
    "proxy-authorization",
    "referer",
    "retry-after",
    "user-agent"
  ]), ufe = (e) => {
    const t = {};
    let n, r, o;
    return e && e.split(`
`).forEach(function(a) {
      o = a.indexOf(":"), n = a.substring(0, o).trim().toLowerCase(), r = a.substring(o + 1).trim(), !(!n || t[n] && lfe[n]) && (n === "set-cookie" ? t[n] ? t[n].push(r) : t[n] = [r] : t[n] = t[n] ? t[n] + ", " + r : r);
    }), t;
  }, a$ = /* @__PURE__ */ Symbol("internals");
  function Xf(e) {
    return e && String(e).trim().toLowerCase();
  }
  function $y(e) {
    return e === !1 || e == null ? e : he.isArray(e) ? e.map($y) : String(e);
  }
  function cfe(e) {
    const t = /* @__PURE__ */ Object.create(null), n = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
    let r;
    for (; r = n.exec(e); )
      t[r[1]] = r[2];
    return t;
  }
  const dfe = (e) => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(e.trim());
  function V_(e, t, n, r, o) {
    if (he.isFunction(r))
      return r.call(this, t, n);
    if (o && (t = n), !!he.isString(t)) {
      if (he.isString(r))
        return t.indexOf(r) !== -1;
      if (he.isRegExp(r))
        return r.test(t);
    }
  }
  function ffe(e) {
    return e.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (t, n, r) => n.toUpperCase() + r);
  }
  function pfe(e, t) {
    const n = he.toCamelCase(" " + t);
    ["get", "set", "has"].forEach((r) => {
      Object.defineProperty(e, r + n, {
        value: function(o, a, i) {
          return this[r].call(this, t, o, a, i);
        },
        configurable: !0
      });
    });
  }
  let Ur = class {
    constructor(e) {
      e && this.set(e);
    }
    set(e, t, n) {
      const r = this;
      function o(i, s, u) {
        const c = Xf(s);
        if (!c)
          throw new Error("header name must be a non-empty string");
        const f = he.findKey(r, c);
        (!f || r[f] === void 0 || u === !0 || u === void 0 && r[f] !== !1) && (r[f || s] = $y(i));
      }
      const a = (i, s) => he.forEach(i, (u, c) => o(u, c, s));
      if (he.isPlainObject(e) || e instanceof this.constructor)
        a(e, t);
      else if (he.isString(e) && (e = e.trim()) && !dfe(e))
        a(ufe(e), t);
      else if (he.isObject(e) && he.isIterable(e)) {
        let i = {}, s, u;
        for (const c of e) {
          if (!he.isArray(c))
            throw TypeError("Object iterator must return a key-value pair");
          i[u = c[0]] = (s = i[u]) ? he.isArray(s) ? [...s, c[1]] : [s, c[1]] : c[1];
        }
        a(i, t);
      } else
        e != null && o(t, e, n);
      return this;
    }
    get(e, t) {
      if (e = Xf(e), e) {
        const n = he.findKey(this, e);
        if (n) {
          const r = this[n];
          if (!t)
            return r;
          if (t === !0)
            return cfe(r);
          if (he.isFunction(t))
            return t.call(this, r, n);
          if (he.isRegExp(t))
            return t.exec(r);
          throw new TypeError("parser must be boolean|regexp|function");
        }
      }
    }
    has(e, t) {
      if (e = Xf(e), e) {
        const n = he.findKey(this, e);
        return !!(n && this[n] !== void 0 && (!t || V_(this, this[n], n, t)));
      }
      return !1;
    }
    delete(e, t) {
      const n = this;
      let r = !1;
      function o(a) {
        if (a = Xf(a), a) {
          const i = he.findKey(n, a);
          i && (!t || V_(n, n[i], i, t)) && (delete n[i], r = !0);
        }
      }
      return he.isArray(e) ? e.forEach(o) : o(e), r;
    }
    clear(e) {
      const t = Object.keys(this);
      let n = t.length, r = !1;
      for (; n--; ) {
        const o = t[n];
        (!e || V_(this, this[o], o, e, !0)) && (delete this[o], r = !0);
      }
      return r;
    }
    normalize(e) {
      const t = this, n = {};
      return he.forEach(this, (r, o) => {
        const a = he.findKey(n, o);
        if (a) {
          t[a] = $y(r), delete t[o];
          return;
        }
        const i = e ? ffe(o) : String(o).trim();
        i !== o && delete t[o], t[i] = $y(r), n[i] = !0;
      }), this;
    }
    concat(...e) {
      return this.constructor.concat(this, ...e);
    }
    toJSON(e) {
      const t = /* @__PURE__ */ Object.create(null);
      return he.forEach(this, (n, r) => {
        n != null && n !== !1 && (t[r] = e && he.isArray(n) ? n.join(", ") : n);
      }), t;
    }
    [Symbol.iterator]() {
      return Object.entries(this.toJSON())[Symbol.iterator]();
    }
    toString() {
      return Object.entries(this.toJSON()).map(([e, t]) => e + ": " + t).join(`
`);
    }
    getSetCookie() {
      return this.get("set-cookie") || [];
    }
    get [Symbol.toStringTag]() {
      return "AxiosHeaders";
    }
    static from(e) {
      return e instanceof this ? e : new this(e);
    }
    static concat(e, ...t) {
      const n = new this(e);
      return t.forEach((r) => n.set(r)), n;
    }
    static accessor(e) {
      const t = (this[a$] = this[a$] = {
        accessors: {}
      }).accessors, n = this.prototype;
      function r(o) {
        const a = Xf(o);
        t[a] || (pfe(n, o), t[a] = !0);
      }
      return he.isArray(e) ? e.forEach(r) : r(e), this;
    }
  };
  Ur.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent", "Authorization"]);
  he.reduceDescriptors(Ur.prototype, ({ value: e }, t) => {
    let n = t[0].toUpperCase() + t.slice(1);
    return {
      get: () => e,
      set(r) {
        this[n] = r;
      }
    };
  });
  he.freezeMethods(Ur);
  function U_(e, t) {
    const n = this || Qm, r = t || n, o = Ur.from(r.headers);
    let a = r.data;
    return he.forEach(e, function(i) {
      a = i.call(n, a, o.normalize(), t ? t.status : void 0);
    }), o.normalize(), a;
  }
  function D8(e) {
    return !!(e && e.__CANCEL__);
  }
  function Bd(e, t, n) {
    st.call(this, e ?? "canceled", st.ERR_CANCELED, t, n), this.name = "CanceledError";
  }
  he.inherits(Bd, st, {
    __CANCEL__: !0
  });
  function L8(e, t, n) {
    const r = n.config.validateStatus;
    !n.status || !r || r(n.status) ? e(n) : t(new st(
      "Request failed with status code " + n.status,
      [st.ERR_BAD_REQUEST, st.ERR_BAD_RESPONSE][Math.floor(n.status / 100) - 4],
      n.config,
      n.request,
      n
    ));
  }
  function mfe(e) {
    const t = /^([-+\w]{1,25})(:?\/\/|:)/.exec(e);
    return t && t[1] || "";
  }
  function hfe(e, t) {
    e = e || 10;
    const n = new Array(e), r = new Array(e);
    let o = 0, a = 0, i;
    return t = t !== void 0 ? t : 1e3, function(s) {
      const u = Date.now(), c = r[a];
      i || (i = u), n[o] = s, r[o] = u;
      let f = a, p = 0;
      for (; f !== o; )
        p += n[f++], f = f % e;
      if (o = (o + 1) % e, o === a && (a = (a + 1) % e), u - i < t)
        return;
      const g = c && u - c;
      return g ? Math.round(p * 1e3 / g) : void 0;
    };
  }
  function gfe(e, t) {
    let n = 0, r = 1e3 / t, o, a;
    const i = (s, u = Date.now()) => {
      n = u, o = null, a && (clearTimeout(a), a = null), e(...s);
    };
    return [(...s) => {
      const u = Date.now(), c = u - n;
      c >= r ? i(s, u) : (o = s, a || (a = setTimeout(() => {
        a = null, i(o);
      }, r - c)));
    }, () => o && i(o)];
  }
  const bb = (e, t, n = 3) => {
    let r = 0;
    const o = hfe(50, 250);
    return gfe((a) => {
      const i = a.loaded, s = a.lengthComputable ? a.total : void 0, u = i - r, c = o(u), f = i <= s;
      r = i;
      const p = {
        loaded: i,
        total: s,
        progress: s ? i / s : void 0,
        bytes: u,
        rate: c || void 0,
        estimated: c && s && f ? (s - i) / c : void 0,
        event: a,
        lengthComputable: s != null,
        [t ? "download" : "upload"]: !0
      };
      e(p);
    }, n);
  }, i$ = (e, t) => {
    const n = e != null;
    return [(r) => t[0]({
      lengthComputable: n,
      total: e,
      loaded: r
    }), t[1]];
  }, s$ = (e) => (...t) => he.asap(() => e(...t)), vfe = vr.hasStandardBrowserEnv ? /* @__PURE__ */ ((e, t) => (n) => (n = new URL(n, vr.origin), e.protocol === n.protocol && e.host === n.host && (t || e.port === n.port)))(
    new URL(vr.origin),
    vr.navigator && /(msie|trident)/i.test(vr.navigator.userAgent)
  ) : () => !0, yfe = vr.hasStandardBrowserEnv ? (
    // Standard browser envs support document.cookie
    {
      write(e, t, n, r, o, a, i) {
        if (typeof document > "u") return;
        const s = [`${e}=${encodeURIComponent(t)}`];
        he.isNumber(n) && s.push(`expires=${new Date(n).toUTCString()}`), he.isString(r) && s.push(`path=${r}`), he.isString(o) && s.push(`domain=${o}`), a === !0 && s.push("secure"), he.isString(i) && s.push(`SameSite=${i}`), document.cookie = s.join("; ");
      },
      read(e) {
        if (typeof document > "u") return null;
        const t = document.cookie.match(new RegExp("(?:^|; )" + e + "=([^;]*)"));
        return t ? decodeURIComponent(t[1]) : null;
      },
      remove(e) {
        this.write(e, "", Date.now() - 864e5, "/");
      }
    }
  ) : (
    // Non-standard browser env (web workers, react-native) lack needed support.
    {
      write() {
      },
      read() {
        return null;
      },
      remove() {
      }
    }
  );
  function bfe(e) {
    return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(e);
  }
  function wfe(e, t) {
    return t ? e.replace(/\/?\/$/, "") + "/" + t.replace(/^\/+/, "") : e;
  }
  function F8(e, t, n) {
    let r = !bfe(t);
    return e && (r || n == !1) ? wfe(e, t) : t;
  }
  const l$ = (e) => e instanceof Ur ? { ...e } : e;
  function du(e, t) {
    t = t || {};
    const n = {};
    function r(c, f, p, g) {
      return he.isPlainObject(c) && he.isPlainObject(f) ? he.merge.call({ caseless: g }, c, f) : he.isPlainObject(f) ? he.merge({}, f) : he.isArray(f) ? f.slice() : f;
    }
    function o(c, f, p, g) {
      if (he.isUndefined(f)) {
        if (!he.isUndefined(c))
          return r(void 0, c, p, g);
      } else return r(c, f, p, g);
    }
    function a(c, f) {
      if (!he.isUndefined(f))
        return r(void 0, f);
    }
    function i(c, f) {
      if (he.isUndefined(f)) {
        if (!he.isUndefined(c))
          return r(void 0, c);
      } else return r(void 0, f);
    }
    function s(c, f, p) {
      if (p in t)
        return r(c, f);
      if (p in e)
        return r(void 0, c);
    }
    const u = {
      url: a,
      method: a,
      data: a,
      baseURL: i,
      transformRequest: i,
      transformResponse: i,
      paramsSerializer: i,
      timeout: i,
      timeoutMessage: i,
      withCredentials: i,
      withXSRFToken: i,
      adapter: i,
      responseType: i,
      xsrfCookieName: i,
      xsrfHeaderName: i,
      onUploadProgress: i,
      onDownloadProgress: i,
      decompress: i,
      maxContentLength: i,
      maxBodyLength: i,
      beforeRedirect: i,
      transport: i,
      httpAgent: i,
      httpsAgent: i,
      cancelToken: i,
      socketPath: i,
      responseEncoding: i,
      validateStatus: s,
      headers: (c, f, p) => o(l$(c), l$(f), p, !0)
    };
    return he.forEach(Object.keys({ ...e, ...t }), function(c) {
      const f = u[c] || o, p = f(e[c], t[c], c);
      he.isUndefined(p) && f !== s || (n[c] = p);
    }), n;
  }
  const T8 = (e) => {
    const t = du({}, e);
    let { data: n, withXSRFToken: r, xsrfHeaderName: o, xsrfCookieName: a, headers: i, auth: s } = t;
    if (t.headers = i = Ur.from(i), t.url = I8(F8(t.baseURL, t.url, t.allowAbsoluteUrls), e.params, e.paramsSerializer), s && i.set(
      "Authorization",
      "Basic " + btoa((s.username || "") + ":" + (s.password ? unescape(encodeURIComponent(s.password)) : ""))
    ), he.isFormData(n)) {
      if (vr.hasStandardBrowserEnv || vr.hasStandardBrowserWebWorkerEnv)
        i.setContentType(void 0);
      else if (he.isFunction(n.getHeaders)) {
        const u = n.getHeaders(), c = ["content-type", "content-length"];
        Object.entries(u).forEach(([f, p]) => {
          c.includes(f.toLowerCase()) && i.set(f, p);
        });
      }
    }
    if (vr.hasStandardBrowserEnv && (r && he.isFunction(r) && (r = r(t)), r || r !== !1 && vfe(t.url))) {
      const u = o && a && yfe.read(a);
      u && i.set(o, u);
    }
    return t;
  }, xfe = typeof XMLHttpRequest < "u", kfe = xfe && function(e) {
    return new Promise(function(t, n) {
      const r = T8(e);
      let o = r.data;
      const a = Ur.from(r.headers).normalize();
      let { responseType: i, onUploadProgress: s, onDownloadProgress: u } = r, c, f, p, g, h;
      function y() {
        g && g(), h && h(), r.cancelToken && r.cancelToken.unsubscribe(c), r.signal && r.signal.removeEventListener("abort", c);
      }
      let b = new XMLHttpRequest();
      b.open(r.method.toUpperCase(), r.url, !0), b.timeout = r.timeout;
      function v() {
        if (!b)
          return;
        const _ = Ur.from(
          "getAllResponseHeaders" in b && b.getAllResponseHeaders()
        ), k = {
          data: !i || i === "text" || i === "json" ? b.responseText : b.response,
          status: b.status,
          statusText: b.statusText,
          headers: _,
          config: e,
          request: b
        };
        L8(function(E) {
          t(E), y();
        }, function(E) {
          n(E), y();
        }, k), b = null;
      }
      "onloadend" in b ? b.onloadend = v : b.onreadystatechange = function() {
        !b || b.readyState !== 4 || b.status === 0 && !(b.responseURL && b.responseURL.indexOf("file:") === 0) || setTimeout(v);
      }, b.onabort = function() {
        b && (n(new st("Request aborted", st.ECONNABORTED, e, b)), b = null);
      }, b.onerror = function(_) {
        const k = _ && _.message ? _.message : "Network Error", E = new st(k, st.ERR_NETWORK, e, b);
        E.event = _ || null, n(E), b = null;
      }, b.ontimeout = function() {
        let _ = r.timeout ? "timeout of " + r.timeout + "ms exceeded" : "timeout exceeded";
        const k = r.transitional || A8;
        r.timeoutErrorMessage && (_ = r.timeoutErrorMessage), n(new st(
          _,
          k.clarifyTimeoutError ? st.ETIMEDOUT : st.ECONNABORTED,
          e,
          b
        )), b = null;
      }, o === void 0 && a.setContentType(null), "setRequestHeader" in b && he.forEach(a.toJSON(), function(_, k) {
        b.setRequestHeader(k, _);
      }), he.isUndefined(r.withCredentials) || (b.withCredentials = !!r.withCredentials), i && i !== "json" && (b.responseType = r.responseType), u && ([p, h] = bb(u, !0), b.addEventListener("progress", p)), s && b.upload && ([f, g] = bb(s), b.upload.addEventListener("progress", f), b.upload.addEventListener("loadend", g)), (r.cancelToken || r.signal) && (c = (_) => {
        b && (n(!_ || _.type ? new Bd(null, e, b) : _), b.abort(), b = null);
      }, r.cancelToken && r.cancelToken.subscribe(c), r.signal && (r.signal.aborted ? c() : r.signal.addEventListener("abort", c)));
      const w = mfe(r.url);
      if (w && vr.protocols.indexOf(w) === -1) {
        n(new st("Unsupported protocol " + w + ":", st.ERR_BAD_REQUEST, e));
        return;
      }
      b.send(o || null);
    });
  }, Sfe = (e, t) => {
    const { length: n } = e = e ? e.filter(Boolean) : [];
    if (t || n) {
      let r = new AbortController(), o;
      const a = function(c) {
        if (!o) {
          o = !0, s();
          const f = c instanceof Error ? c : this.reason;
          r.abort(f instanceof st ? f : new Bd(f instanceof Error ? f.message : f));
        }
      };
      let i = t && setTimeout(() => {
        i = null, a(new st(`timeout ${t} of ms exceeded`, st.ETIMEDOUT));
      }, t);
      const s = () => {
        e && (i && clearTimeout(i), i = null, e.forEach((c) => {
          c.unsubscribe ? c.unsubscribe(a) : c.removeEventListener("abort", a);
        }), e = null);
      };
      e.forEach((c) => c.addEventListener("abort", a));
      const { signal: u } = r;
      return u.unsubscribe = () => he.asap(s), u;
    }
  }, _fe = function* (e, t) {
    let n = e.byteLength;
    if (n < t) {
      yield e;
      return;
    }
    let r = 0, o;
    for (; r < n; )
      o = r + t, yield e.slice(r, o), r = o;
  }, Efe = async function* (e, t) {
    for await (const n of Cfe(e))
      yield* _fe(n, t);
  }, Cfe = async function* (e) {
    if (e[Symbol.asyncIterator]) {
      yield* e;
      return;
    }
    const t = e.getReader();
    try {
      for (; ; ) {
        const { done: n, value: r } = await t.read();
        if (n)
          break;
        yield r;
      }
    } finally {
      await t.cancel();
    }
  }, u$ = (e, t, n, r) => {
    const o = Efe(e, t);
    let a = 0, i, s = (u) => {
      i || (i = !0, r && r(u));
    };
    return new ReadableStream({
      async pull(u) {
        try {
          const { done: c, value: f } = await o.next();
          if (c) {
            s(), u.close();
            return;
          }
          let p = f.byteLength;
          if (n) {
            let g = a += p;
            n(g);
          }
          u.enqueue(new Uint8Array(f));
        } catch (c) {
          throw s(c), c;
        }
      },
      cancel(u) {
        return s(u), o.return();
      }
    }, {
      highWaterMark: 2
    });
  }, c$ = 64 * 1024, { isFunction: mv } = he, Pfe = (({ Request: e, Response: t }) => ({
    Request: e,
    Response: t
  }))(he.global), {
    ReadableStream: d$,
    TextEncoder: f$
  } = he.global, p$ = (e, ...t) => {
    try {
      return !!e(...t);
    } catch {
      return !1;
    }
  }, Ofe = (e) => {
    e = he.merge.call({
      skipUndefined: !0
    }, Pfe, e);
    const { fetch: t, Request: n, Response: r } = e, o = t ? mv(t) : typeof fetch == "function", a = mv(n), i = mv(r);
    if (!o)
      return !1;
    const s = o && mv(d$), u = o && (typeof f$ == "function" ? /* @__PURE__ */ ((y) => (b) => y.encode(b))(new f$()) : async (y) => new Uint8Array(await new n(y).arrayBuffer())), c = a && s && p$(() => {
      let y = !1;
      const b = new n(vr.origin, {
        body: new d$(),
        method: "POST",
        get duplex() {
          return y = !0, "half";
        }
      }).headers.has("Content-Type");
      return y && !b;
    }), f = i && s && p$(() => he.isReadableStream(new r("").body)), p = {
      stream: f && ((y) => y.body)
    };
    o && ["text", "arrayBuffer", "blob", "formData", "stream"].forEach((y) => {
      !p[y] && (p[y] = (b, v) => {
        let w = b && b[y];
        if (w)
          return w.call(b);
        throw new st(`Response type '${y}' is not supported`, st.ERR_NOT_SUPPORT, v);
      });
    });
    const g = async (y) => {
      if (y == null)
        return 0;
      if (he.isBlob(y))
        return y.size;
      if (he.isSpecCompliantForm(y))
        return (await new n(vr.origin, {
          method: "POST",
          body: y
        }).arrayBuffer()).byteLength;
      if (he.isArrayBufferView(y) || he.isArrayBuffer(y))
        return y.byteLength;
      if (he.isURLSearchParams(y) && (y = y + ""), he.isString(y))
        return (await u(y)).byteLength;
    }, h = async (y, b) => he.toFiniteNumber(y.getContentLength()) ?? g(b);
    return async (y) => {
      let {
        url: b,
        method: v,
        data: w,
        signal: _,
        cancelToken: k,
        timeout: E,
        onDownloadProgress: P,
        onUploadProgress: O,
        responseType: M,
        headers: I,
        withCredentials: A = "same-origin",
        fetchOptions: D
      } = T8(y), F = t || fetch;
      M = M ? (M + "").toLowerCase() : "text";
      let j = Sfe([_, k && k.toAbortSignal()], E), U = null;
      const $ = j && j.unsubscribe && (() => {
        j.unsubscribe();
      });
      let q;
      try {
        if (O && c && v !== "get" && v !== "head" && (q = await h(I, w)) !== 0) {
          let L = new n(b, {
            method: "POST",
            body: w,
            duplex: "half"
          }), K;
          if (he.isFormData(w) && (K = L.headers.get("content-type")) && I.setContentType(K), L.body) {
            const [T, V] = i$(
              q,
              bb(s$(O))
            );
            w = u$(L.body, c$, T, V);
          }
        }
        he.isString(A) || (A = A ? "include" : "omit");
        const B = a && "credentials" in n.prototype, G = {
          ...D,
          signal: j,
          method: v.toUpperCase(),
          headers: I.normalize().toJSON(),
          body: w,
          duplex: "half",
          credentials: B ? A : void 0
        };
        U = a && new n(b, G);
        let W = await (a ? F(U, D) : F(b, G));
        const Y = f && (M === "stream" || M === "response");
        if (f && (P || Y && $)) {
          const L = {};
          ["status", "statusText", "headers"].forEach((X) => {
            L[X] = W[X];
          });
          const K = he.toFiniteNumber(W.headers.get("content-length")), [T, V] = P && i$(
            K,
            bb(s$(P), !0)
          ) || [];
          W = new r(
            u$(W.body, c$, T, () => {
              V && V(), $ && $();
            }),
            L
          );
        }
        M = M || "text";
        let z = await p[he.findKey(p, M) || "text"](W, y);
        return !Y && $ && $(), await new Promise((L, K) => {
          L8(L, K, {
            data: z,
            headers: Ur.from(W.headers),
            status: W.status,
            statusText: W.statusText,
            config: y,
            request: U
          });
        });
      } catch (B) {
        throw $ && $(), B && B.name === "TypeError" && /Load failed|fetch/i.test(B.message) ? Object.assign(
          new st("Network Error", st.ERR_NETWORK, y, U),
          {
            cause: B.cause || B
          }
        ) : st.from(B, B && B.code, y, U);
      }
    };
  }, Nfe = /* @__PURE__ */ new Map(), z8 = (e) => {
    let t = e && e.env || {};
    const { fetch: n, Request: r, Response: o } = t, a = [
      r,
      o,
      n
    ];
    let i = a.length, s = i, u, c, f = Nfe;
    for (; s--; )
      u = a[s], c = f.get(u), c === void 0 && f.set(u, c = s ? /* @__PURE__ */ new Map() : Ofe(t)), f = c;
    return c;
  };
  z8();
  const lP = {
    http: qde,
    xhr: kfe,
    fetch: {
      get: z8
    }
  };
  he.forEach(lP, (e, t) => {
    if (e) {
      try {
        Object.defineProperty(e, "name", { value: t });
      } catch {
      }
      Object.defineProperty(e, "adapterName", { value: t });
    }
  });
  const m$ = (e) => `- ${e}`, Mfe = (e) => he.isFunction(e) || e === null || e === !1;
  function Rfe(e, t) {
    e = he.isArray(e) ? e : [e];
    const { length: n } = e;
    let r, o;
    const a = {};
    for (let i = 0; i < n; i++) {
      r = e[i];
      let s;
      if (o = r, !Mfe(r) && (o = lP[(s = String(r)).toLowerCase()], o === void 0))
        throw new st(`Unknown adapter '${s}'`);
      if (o && (he.isFunction(o) || (o = o.get(t))))
        break;
      a[s || "#" + i] = o;
    }
    if (!o) {
      const i = Object.entries(a).map(
        ([u, c]) => `adapter ${u} ` + (c === !1 ? "is not supported by the environment" : "is not available in the build")
      );
      let s = n ? i.length > 1 ? `since :
` + i.map(m$).join(`
`) : " " + m$(i[0]) : "as no adapter specified";
      throw new st(
        "There is no suitable adapter to dispatch the request " + s,
        "ERR_NOT_SUPPORT"
      );
    }
    return o;
  }
  const B8 = {
    /**
     * Resolve an adapter from a list of adapter names or functions.
     * @type {Function}
     */
    getAdapter: Rfe,
    /**
     * Exposes all known adapters
     * @type {Object<string, Function|Object>}
     */
    adapters: lP
  };
  function H_(e) {
    if (e.cancelToken && e.cancelToken.throwIfRequested(), e.signal && e.signal.aborted)
      throw new Bd(null, e);
  }
  function h$(e) {
    return H_(e), e.headers = Ur.from(e.headers), e.data = U_.call(
      e,
      e.transformRequest
    ), ["post", "put", "patch"].indexOf(e.method) !== -1 && e.headers.setContentType("application/x-www-form-urlencoded", !1), B8.getAdapter(e.adapter || Qm.adapter, e)(e).then(function(t) {
      return H_(e), t.data = U_.call(
        e,
        e.transformResponse,
        t
      ), t.headers = Ur.from(t.headers), t;
    }, function(t) {
      return D8(t) || (H_(e), t && t.response && (t.response.data = U_.call(
        e,
        e.transformResponse,
        t.response
      ), t.response.headers = Ur.from(t.response.headers))), Promise.reject(t);
    });
  }
  const V8 = "1.13.2", Hw = {};
  ["object", "boolean", "number", "function", "string", "symbol"].forEach((e, t) => {
    Hw[e] = function(n) {
      return typeof n === e || "a" + (t < 1 ? "n " : " ") + e;
    };
  });
  const g$ = {};
  Hw.transitional = function(e, t, n) {
    function r(o, a) {
      return "[Axios v" + V8 + "] Transitional option '" + o + "'" + a + (n ? ". " + n : "");
    }
    return (o, a, i) => {
      if (e === !1)
        throw new st(
          r(a, " has been removed" + (t ? " in " + t : "")),
          st.ERR_DEPRECATED
        );
      return t && !g$[a] && (g$[a] = !0, console.warn(
        r(
          a,
          " has been deprecated since v" + t + " and will be removed in the near future"
        )
      )), e ? e(o, a, i) : !0;
    };
  };
  Hw.spelling = function(e) {
    return (t, n) => (console.warn(`${n} is likely a misspelling of ${e}`), !0);
  };
  function jfe(e, t, n) {
    if (typeof e != "object")
      throw new st("options must be an object", st.ERR_BAD_OPTION_VALUE);
    const r = Object.keys(e);
    let o = r.length;
    for (; o-- > 0; ) {
      const a = r[o], i = t[a];
      if (i) {
        const s = e[a], u = s === void 0 || i(s, a, e);
        if (u !== !0)
          throw new st("option " + a + " must be " + u, st.ERR_BAD_OPTION_VALUE);
        continue;
      }
      if (n !== !0)
        throw new st("Unknown option " + a, st.ERR_BAD_OPTION);
    }
  }
  const Dy = {
    assertOptions: jfe,
    validators: Hw
  }, ya = Dy.validators;
  let ru = class {
    constructor(e) {
      this.defaults = e || {}, this.interceptors = {
        request: new o$(),
        response: new o$()
      };
    }
    /**
     * Dispatch a request
     *
     * @param {String|Object} configOrUrl The config specific for this request (merged with this.defaults)
     * @param {?Object} config
     *
     * @returns {Promise} The Promise to be fulfilled
     */
    async request(e, t) {
      try {
        return await this._request(e, t);
      } catch (n) {
        if (n instanceof Error) {
          let r = {};
          Error.captureStackTrace ? Error.captureStackTrace(r) : r = new Error();
          const o = r.stack ? r.stack.replace(/^.+\n/, "") : "";
          try {
            n.stack ? o && !String(n.stack).endsWith(o.replace(/^.+\n.+\n/, "")) && (n.stack += `
` + o) : n.stack = o;
          } catch {
          }
        }
        throw n;
      }
    }
    _request(e, t) {
      typeof e == "string" ? (t = t || {}, t.url = e) : t = e || {}, t = du(this.defaults, t);
      const { transitional: n, paramsSerializer: r, headers: o } = t;
      n !== void 0 && Dy.assertOptions(n, {
        silentJSONParsing: ya.transitional(ya.boolean),
        forcedJSONParsing: ya.transitional(ya.boolean),
        clarifyTimeoutError: ya.transitional(ya.boolean)
      }, !1), r != null && (he.isFunction(r) ? t.paramsSerializer = {
        serialize: r
      } : Dy.assertOptions(r, {
        encode: ya.function,
        serialize: ya.function
      }, !0)), t.allowAbsoluteUrls !== void 0 || (this.defaults.allowAbsoluteUrls !== void 0 ? t.allowAbsoluteUrls = this.defaults.allowAbsoluteUrls : t.allowAbsoluteUrls = !0), Dy.assertOptions(t, {
        baseUrl: ya.spelling("baseURL"),
        withXsrfToken: ya.spelling("withXSRFToken")
      }, !0), t.method = (t.method || this.defaults.method || "get").toLowerCase();
      let a = o && he.merge(
        o.common,
        o[t.method]
      );
      o && he.forEach(
        ["delete", "get", "head", "post", "put", "patch", "common"],
        (h) => {
          delete o[h];
        }
      ), t.headers = Ur.concat(a, o);
      const i = [];
      let s = !0;
      this.interceptors.request.forEach(function(h) {
        typeof h.runWhen == "function" && h.runWhen(t) === !1 || (s = s && h.synchronous, i.unshift(h.fulfilled, h.rejected));
      });
      const u = [];
      this.interceptors.response.forEach(function(h) {
        u.push(h.fulfilled, h.rejected);
      });
      let c, f = 0, p;
      if (!s) {
        const h = [h$.bind(this), void 0];
        for (h.unshift(...i), h.push(...u), p = h.length, c = Promise.resolve(t); f < p; )
          c = c.then(h[f++], h[f++]);
        return c;
      }
      p = i.length;
      let g = t;
      for (; f < p; ) {
        const h = i[f++], y = i[f++];
        try {
          g = h(g);
        } catch (b) {
          y.call(this, b);
          break;
        }
      }
      try {
        c = h$.call(this, g);
      } catch (h) {
        return Promise.reject(h);
      }
      for (f = 0, p = u.length; f < p; )
        c = c.then(u[f++], u[f++]);
      return c;
    }
    getUri(e) {
      e = du(this.defaults, e);
      const t = F8(e.baseURL, e.url, e.allowAbsoluteUrls);
      return I8(t, e.params, e.paramsSerializer);
    }
  };
  he.forEach(["delete", "get", "head", "options"], function(e) {
    ru.prototype[e] = function(t, n) {
      return this.request(du(n || {}, {
        method: e,
        url: t,
        data: (n || {}).data
      }));
    };
  });
  he.forEach(["post", "put", "patch"], function(e) {
    function t(n) {
      return function(r, o, a) {
        return this.request(du(a || {}, {
          method: e,
          headers: n ? {
            "Content-Type": "multipart/form-data"
          } : {},
          url: r,
          data: o
        }));
      };
    }
    ru.prototype[e] = t(), ru.prototype[e + "Form"] = t(!0);
  });
  let Ife = class U8 {
    constructor(t) {
      if (typeof t != "function")
        throw new TypeError("executor must be a function.");
      let n;
      this.promise = new Promise(function(o) {
        n = o;
      });
      const r = this;
      this.promise.then((o) => {
        if (!r._listeners) return;
        let a = r._listeners.length;
        for (; a-- > 0; )
          r._listeners[a](o);
        r._listeners = null;
      }), this.promise.then = (o) => {
        let a;
        const i = new Promise((s) => {
          r.subscribe(s), a = s;
        }).then(o);
        return i.cancel = function() {
          r.unsubscribe(a);
        }, i;
      }, t(function(o, a, i) {
        r.reason || (r.reason = new Bd(o, a, i), n(r.reason));
      });
    }
    /**
     * Throws a `CanceledError` if cancellation has been requested.
     */
    throwIfRequested() {
      if (this.reason)
        throw this.reason;
    }
    /**
     * Subscribe to the cancel signal
     */
    subscribe(t) {
      if (this.reason) {
        t(this.reason);
        return;
      }
      this._listeners ? this._listeners.push(t) : this._listeners = [t];
    }
    /**
     * Unsubscribe from the cancel signal
     */
    unsubscribe(t) {
      if (!this._listeners)
        return;
      const n = this._listeners.indexOf(t);
      n !== -1 && this._listeners.splice(n, 1);
    }
    toAbortSignal() {
      const t = new AbortController(), n = (r) => {
        t.abort(r);
      };
      return this.subscribe(n), t.signal.unsubscribe = () => this.unsubscribe(n), t.signal;
    }
    /**
     * Returns an object that contains a new `CancelToken` and a function that, when called,
     * cancels the `CancelToken`.
     */
    static source() {
      let t;
      return {
        token: new U8(function(n) {
          t = n;
        }),
        cancel: t
      };
    }
  };
  function Afe(e) {
    return function(t) {
      return e.apply(null, t);
    };
  }
  function $fe(e) {
    return he.isObject(e) && e.isAxiosError === !0;
  }
  const B2 = {
    Continue: 100,
    SwitchingProtocols: 101,
    Processing: 102,
    EarlyHints: 103,
    Ok: 200,
    Created: 201,
    Accepted: 202,
    NonAuthoritativeInformation: 203,
    NoContent: 204,
    ResetContent: 205,
    PartialContent: 206,
    MultiStatus: 207,
    AlreadyReported: 208,
    ImUsed: 226,
    MultipleChoices: 300,
    MovedPermanently: 301,
    Found: 302,
    SeeOther: 303,
    NotModified: 304,
    UseProxy: 305,
    Unused: 306,
    TemporaryRedirect: 307,
    PermanentRedirect: 308,
    BadRequest: 400,
    Unauthorized: 401,
    PaymentRequired: 402,
    Forbidden: 403,
    NotFound: 404,
    MethodNotAllowed: 405,
    NotAcceptable: 406,
    ProxyAuthenticationRequired: 407,
    RequestTimeout: 408,
    Conflict: 409,
    Gone: 410,
    LengthRequired: 411,
    PreconditionFailed: 412,
    PayloadTooLarge: 413,
    UriTooLong: 414,
    UnsupportedMediaType: 415,
    RangeNotSatisfiable: 416,
    ExpectationFailed: 417,
    ImATeapot: 418,
    MisdirectedRequest: 421,
    UnprocessableEntity: 422,
    Locked: 423,
    FailedDependency: 424,
    TooEarly: 425,
    UpgradeRequired: 426,
    PreconditionRequired: 428,
    TooManyRequests: 429,
    RequestHeaderFieldsTooLarge: 431,
    UnavailableForLegalReasons: 451,
    InternalServerError: 500,
    NotImplemented: 501,
    BadGateway: 502,
    ServiceUnavailable: 503,
    GatewayTimeout: 504,
    HttpVersionNotSupported: 505,
    VariantAlsoNegotiates: 506,
    InsufficientStorage: 507,
    LoopDetected: 508,
    NotExtended: 510,
    NetworkAuthenticationRequired: 511,
    WebServerIsDown: 521,
    ConnectionTimedOut: 522,
    OriginIsUnreachable: 523,
    TimeoutOccurred: 524,
    SslHandshakeFailed: 525,
    InvalidSslCertificate: 526
  };
  Object.entries(B2).forEach(([e, t]) => {
    B2[t] = e;
  });
  function H8(e) {
    const t = new ru(e), n = x8(ru.prototype.request, t);
    return he.extend(n, ru.prototype, t, { allOwnKeys: !0 }), he.extend(n, t, null, { allOwnKeys: !0 }), n.create = function(r) {
      return H8(du(e, r));
    }, n;
  }
  const In = H8(Qm);
  In.Axios = ru;
  In.CanceledError = Bd;
  In.CancelToken = Ife;
  In.isCancel = D8;
  In.VERSION = V8;
  In.toFormData = Uw;
  In.AxiosError = st;
  In.Cancel = In.CanceledError;
  In.all = function(e) {
    return Promise.all(e);
  };
  In.spread = Afe;
  In.isAxiosError = $fe;
  In.mergeConfig = du;
  In.AxiosHeaders = Ur;
  In.formToJSON = (e) => $8(he.isHTMLForm(e) ? new FormData(e) : e);
  In.getAdapter = B8.getAdapter;
  In.HttpStatusCode = B2;
  In.default = In;
  const {
    Axios: Bze,
    AxiosError: Vze,
    CanceledError: Uze,
    isCancel: Hze,
    CancelToken: Wze,
    VERSION: qze,
    all: Kze,
    Cancel: Gze,
    isAxiosError: Xze,
    spread: Yze,
    toFormData: Jze,
    AxiosHeaders: Qze,
    HttpStatusCode: Zze,
    formToJSON: e9e,
    getAdapter: t9e,
    mergeConfig: n9e
  } = In;
  class W8 extends oP {
    constructor(t) {
      super(t), this._websocket = null, this.reconnectAttempts = 0, this.maxReconnectAttempts = 999, this.initialTimeout = 200, this.maxTimeout = 5e3, this._reconnect = !0, this._reconnect_timeout = void 0, this._url = t.url, this._reconnect_timeout = setTimeout(() => {
        this.connect();
      }, 200), this._zustand && this._zustand.auto_progress();
    }
    connect() {
      this._zustand?.logger.info("Connecting to websocket"), this.is_open = !1, this._websocket = new WebSocket(this._url), this._websocket.onopen = () => {
        this.onopen();
      }, this._websocket.onclose = () => {
        this.onclose();
      }, this._websocket.onerror = () => {
        this.on_ws_error();
      }, this._websocket.onmessage = (t) => {
        typeof t.data == "string" ? this.onmessage(t.data) : t.data instanceof Blob && t.data.arrayBuffer().then((n) => {
          const r = new Uint8Array(n);
          this.getCommunicationManager().onbytes(r);
        });
      };
    }
    calculateReconnectTimeout() {
      return Math.min(
        this.initialTimeout * Math.pow(2, this.reconnectAttempts),
        this.maxTimeout
      );
    }
    auto_reconnect() {
      if (this.reconnectAttempts < this.maxReconnectAttempts) {
        let t = this.calculateReconnectTimeout();
        this._zustand?.logger.info(`Attempting to reconnect in ${t} ms`), this._reconnect_timeout = setTimeout(() => {
          this._websocket && this._websocket.readyState === WebSocket.OPEN || (this.reconnectAttempts++, this.connect());
        }, t);
      } else
        this._zustand?.logger.warn(
          "Maximum reconnect attempts reached. Giving up."
        );
    }
    async onmessage(t) {
      try {
        const n = JSON.parse(t);
        this._zustand?.logger.debug(
          `Recieved data of length: ${t.length} and data"`,
          n
        ), await this.getCommunicationManager().receive(n);
      } catch (n) {
        console.error("Websocketworker: onmessage JSON.parse error", n, t);
        return;
      }
    }
    get http_protocol() {
      return this.secure_url ? "https" : "http";
    }
    get secure_url() {
      return this._url.startsWith("wss");
    }
    get url_wo_protocol() {
      return this._url.substring(this.secure_url ? 6 : 5);
    }
    get http_url() {
      var t = this.http_protocol + "://" + this.url_wo_protocol;
      return t[t.length - 1] !== "/" && (t += "/"), t;
    }
    get_io_subscription_url({
      node_id: t,
      io_id: n,
      stream: r
    }) {
      let o = this.http_url + `node/${t}/io/${n}/value`;
      return r && (o += "/stream"), o;
    }
    async upload_file({
      files: t,
      onProgressCallback: n,
      root: r
    }) {
      const o = `${this.http_url}upload/`, a = new FormData(), i = Array.isArray(t) ? t : Array.from(t);
      for (const s of i) {
        const u = s.webkitRelativePath || s.name, c = r ? `${r}/${u}` : u;
        a.append("file", s, c);
      }
      try {
        return (await In.post(o, a, {
          headers: {
            "Content-Type": "multipart/form-data"
          },
          onUploadProgress: (s) => {
            n && n(s.loaded, s.total);
          }
        })).data.file;
      } catch {
        throw new Error("Failed to upload file");
      }
    }
    async handle_large_message_hint({ msg_id: t }) {
      const n = this.http_url + "message/" + t, r = await (await fetch(n, {
        method: "GET",
        headers: {
          "Content-Type": "application/json",
          "Access-Control-Allow-Origin": "*"
        }
      })).json();
      this.getCommunicationManager().receive(r);
    }
    onopen() {
      this._zustand?.logger.info("Websocket opened"), this.is_open = !0, this._zustand && this._zustand.auto_progress(), this.reconnectAttempts = 0, this.getSyncManager().stepwise_fullsync();
    }
    onclose() {
      this._zustand?.logger.info("Websocket closed"), super.onclose(), this._reconnect && (this._zustand?.logger.info("Websocket closed,reconnecting"), this.auto_reconnect());
    }
    on_ws_error() {
      this._zustand?.logger.warn("Websocket error"), this._websocket ? this._websocket.close() : this.auto_reconnect();
    }
    async send_large_message(t) {
      const n = `${this.http_url}message/`;
      await fetch(n, {
        method: "POST",
        headers: {
          "Content-Type": "application/json"
        },
        body: t
      });
    }
    async send(t) {
      if (!this._websocket || this._websocket.readyState !== WebSocket.OPEN) {
        this._zustand?.logger.warn("Websocket not connected");
        return;
      }
      const n = JSON.stringify(t);
      if (new Blob([n]).size > 1e6)
        return this._zustand?.logger.info("Data too large, sending via http"), await this.send_large_message(n);
      this._zustand?.logger.debug("Sending data", t), this._websocket.send(n);
    }
    async stop() {
      await super.stop(), this._reconnect = !1;
    }
    close() {
      this._websocket && this._websocket.close();
    }
    disconnect() {
      super.disconnect(), this._reconnect = !1, this._reconnect_timeout && (clearTimeout(this._reconnect_timeout), this._reconnect_timeout = void 0), this.close();
    }
    async reconnect() {
      if (await super.reconnect(), this._reconnect = !0, this._websocket && (this._zustand?.logger.info("Reconnecting"), (this._websocket.readyState === WebSocket.OPEN || this._websocket.readyState === WebSocket.CONNECTING) && (this._websocket.readyState === WebSocket.CONNECTING && await new Promise((t, n) => {
        if (this._websocket === null) return;
        let r = setTimeout(() => {
          n("Timeout@reconnect");
        }, 2e3);
        this._websocket.addEventListener(
          "open",
          () => {
            clearTimeout(r), t(null);
          },
          { once: !0 }
        ), this._websocket.readyState === WebSocket.OPEN && (clearTimeout(r), t(null));
      }), this._websocket.readyState === WebSocket.OPEN))) {
        this.getSyncManager().stepwise_fullsync();
        return;
      }
      this.connect();
    }
  }
  class Dfe {
    constructor(t, n) {
      this.ws = null, this.reconnectAttempts = 0, this.maxReconnectAttempts = 999, this.initialTimeout = 200, this.maxTimeout = 2e3, n.logger.debug("Initializing worker manager"), this._wsuri = t, this.zustand = n, this.workers = {}, this.on_setWorker = (r) => {
        this.zustand.set_worker(r);
      }, this.connectionTimeout = setTimeout(() => {
        this.connect();
      }, 200);
    }
    get wsuri() {
      return this._wsuri;
    }
    get open() {
      return this.ws?.readyState === WebSocket.OPEN;
    }
    connect() {
      this.zustand.set_progress({
        progress: 0,
        message: "connecting to worker manager",
        status: "info",
        blocking: !0
      }), this.zustand.logger.info("Connecting to websocket:", this._wsuri), this.ws = new WebSocket(this._wsuri), this.ws.onopen = () => {
        this.onopen();
      }, this.ws.onclose = () => {
        this.onclose();
      }, this.ws.onerror = () => {
        this.on_ws_error();
      }, this.ws.onmessage = (t) => {
        typeof t.data == "string" ? this.onmessage(t.data) : console.error(
          "WorkerManager: onmessage event.data is not a string",
          typeof t.data
        );
      }, this.connectionTimeout = setTimeout(() => {
        this.ws?.readyState !== WebSocket.OPEN && this.on_ws_error();
      }, 5e3);
    }
    on_ws_error() {
      console.warn("Websocket error"), this.ws ? this.ws.close() : this.reconnect();
    }
    onopen() {
      this.connectionTimeout && (clearTimeout(this.connectionTimeout), this.connectionTimeout = void 0), this.zustand.auto_progress(), this.ws && this.ws.send("worker_status");
    }
    onmessage(t) {
      try {
        let n = JSON.parse(t);
        if (n.type === "worker_status") {
          const r = {};
          for (let o of n.active)
            o.active = !0, r[o.uuid] = o;
          for (let o of n.inactive)
            o.active = !1, r[o.uuid] = o;
          if (this.zustand.workers.setState(r), !this.zustand.worker) {
            const o = window.localStorage.getItem(
              "funcnodes__active_worker"
            );
            o && r[o] && r[o].active && this.set_active(o);
          }
          return;
        } else if (n.type === "set_worker") {
          if (n.data.type === "WSWorker") {
            let r = "ws" + (n.data.ssl ? "s" : "") + "://" + n.data.host + ":" + n.data.port;
            this.setWorker(
              this.workers[n.data.uuid] || new W8({
                url: r,
                zustand: this.zustand,
                uuid: n.data.uuid,
                on_sync_complete: this.zustand.options.on_sync_complete
              })
            );
          } else
            this.zustand.logger.error("WorkerManager: unknown worker type", n);
          return;
        } else if (n.type === "progress") {
          this.zustand.set_progress(n);
          return;
        }
        this.zustand.logger.error("WorkerManager: unknown message", n);
      } catch (n) {
        console.error("WorkerManager: onmessage JSON.parse error", n, t);
        return;
      }
    }
    setWorker(t) {
      for (let n in this.workers)
        n !== t?.uuid && this.workers[n].disconnect();
      t !== void 0 && (this.workers[t.uuid] = t, t.reconnect()), t?.uuid && window.localStorage.setItem("funcnodes__active_worker", t?.uuid), this.zustand.worker !== void 0 && this.zustand.clear_all(), this.zustand.set_worker(t), this.on_setWorker(t);
    }
    async restart_worker(t) {
      this.ws?.send(JSON.stringify({ type: "restart_worker", workerid: t }));
    }
    calculateReconnectTimeout() {
      return Math.min(
        this.initialTimeout * Math.pow(2, this.reconnectAttempts),
        this.maxTimeout
      );
    }
    reconnect() {
      if (this.reconnectAttempts < this.maxReconnectAttempts) {
        let t = this.calculateReconnectTimeout();
        this.zustand.logger.info(`Attempting to reconnect in ${t} ms`), setTimeout(() => {
          this.ws && this.ws.readyState === WebSocket.OPEN || (this.reconnectAttempts++, this.connect());
        }, t);
      } else
        this.zustand.logger.warn(
          "Maximum reconnect attempts reached. Giving up."
        );
    }
    onclose() {
      this.zustand.logger.warn("WorkerManager: onclose"), this.reconnect();
    }
    set_active(t) {
      this.ws && this.ws.send(JSON.stringify({ type: "set_active", workerid: t }));
    }
    new_worker({
      name: t,
      reference: n,
      copyLib: r,
      copyNS: o,
      in_venv: a
    }) {
      t || (t = void 0), r || (r = !1), o || (o = !1), n || (n = void 0, r = !1, o = !1), this.ws && this.ws.send(
        JSON.stringify({
          type: "new_worker",
          kwargs: {
            name: t,
            reference: n,
            copyLib: r,
            copyNS: o,
            in_venv: a
          }
        })
      );
    }
    remove() {
      for (let t in this.workers)
        this.workers[t].disconnect();
      this.connectionTimeout && (clearTimeout(this.connectionTimeout), this.connectionTimeout = void 0), this.ws && (this.ws.onclose = () => {
      }, this.ws.onerror = () => {
      }, this.ws.onmessage = () => {
      }, this.ws.onopen = () => {
      }, this.ws.close());
    }
  }
  const Nr = () => {
    const e = Vt();
    return e.worker ? {
      ...e.worker.api,
      worker: e.worker
    } : {
      node: void 0,
      group: void 0,
      edge: void 0,
      hooks: void 0,
      lib: void 0,
      worker: e.worker
    };
  }, Lfe = {
    show: !0
  }, Ffe = {
    show: !0,
    showmenu: !0
  }, Tfe = {
    minimap: !0,
    static: !1,
    minZoom: 0.1,
    maxZoom: 5,
    allowFullScreen: !0,
    allowExpand: !0,
    showNodeSettings: !0
  }, zfe = {
    id: "",
    // required
    debug: !1,
    useWorkerManager: !0,
    show_library: !0,
    header: Ffe,
    flow: Tfe,
    library: Lfe
  }, q8 = [
    "classic",
    "metal",
    "light",
    "solarized",
    "midnight",
    "forest",
    "scientific",
    "neon",
    "ocean",
    "sunset"
  ];
  function Wn(e) {
    if (typeof e == "string" || typeof e == "number") return "" + e;
    let t = "";
    if (Array.isArray(e))
      for (let n = 0, r; n < e.length; n++)
        (r = Wn(e[n])) !== "" && (t += (t && " ") + r);
    else
      for (let n in e)
        e[n] && (t += (t && " ") + n);
    return t;
  }
  var Bfe = { value: () => {
  } };
  function Ww() {
    for (var e = 0, t = arguments.length, n = {}, r; e < t; ++e) {
      if (!(r = arguments[e] + "") || r in n || /[\s.]/.test(r)) throw new Error("illegal type: " + r);
      n[r] = [];
    }
    return new Ly(n);
  }
  function Ly(e) {
    this._ = e;
  }
  function Vfe(e, t) {
    return e.trim().split(/^|\s+/).map(function(n) {
      var r = "", o = n.indexOf(".");
      if (o >= 0 && (r = n.slice(o + 1), n = n.slice(0, o)), n && !t.hasOwnProperty(n)) throw new Error("unknown type: " + n);
      return { type: n, name: r };
    });
  }
  Ly.prototype = Ww.prototype = {
    constructor: Ly,
    on: function(e, t) {
      var n = this._, r = Vfe(e + "", n), o, a = -1, i = r.length;
      if (arguments.length < 2) {
        for (; ++a < i; ) if ((o = (e = r[a]).type) && (o = Ufe(n[o], e.name))) return o;
        return;
      }
      if (t != null && typeof t != "function") throw new Error("invalid callback: " + t);
      for (; ++a < i; )
        if (o = (e = r[a]).type) n[o] = v$(n[o], e.name, t);
        else if (t == null) for (o in n) n[o] = v$(n[o], e.name, null);
      return this;
    },
    copy: function() {
      var e = {}, t = this._;
      for (var n in t) e[n] = t[n].slice();
      return new Ly(e);
    },
    call: function(e, t) {
      if ((o = arguments.length - 2) > 0) for (var n = new Array(o), r = 0, o, a; r < o; ++r) n[r] = arguments[r + 2];
      if (!this._.hasOwnProperty(e)) throw new Error("unknown type: " + e);
      for (a = this._[e], r = 0, o = a.length; r < o; ++r) a[r].value.apply(t, n);
    },
    apply: function(e, t, n) {
      if (!this._.hasOwnProperty(e)) throw new Error("unknown type: " + e);
      for (var r = this._[e], o = 0, a = r.length; o < a; ++o) r[o].value.apply(t, n);
    }
  };
  function Ufe(e, t) {
    for (var n = 0, r = e.length, o; n < r; ++n)
      if ((o = e[n]).name === t)
        return o.value;
  }
  function v$(e, t, n) {
    for (var r = 0, o = e.length; r < o; ++r)
      if (e[r].name === t) {
        e[r] = Bfe, e = e.slice(0, r).concat(e.slice(r + 1));
        break;
      }
    return n != null && e.push({ name: t, value: n }), e;
  }
  var V2 = "http://www.w3.org/1999/xhtml";
  const y$ = {
    svg: "http://www.w3.org/2000/svg",
    xhtml: V2,
    xlink: "http://www.w3.org/1999/xlink",
    xml: "http://www.w3.org/XML/1998/namespace",
    xmlns: "http://www.w3.org/2000/xmlns/"
  };
  function qw(e) {
    var t = e += "", n = t.indexOf(":");
    return n >= 0 && (t = e.slice(0, n)) !== "xmlns" && (e = e.slice(n + 1)), y$.hasOwnProperty(t) ? { space: y$[t], local: e } : e;
  }
  function Hfe(e) {
    return function() {
      var t = this.ownerDocument, n = this.namespaceURI;
      return n === V2 && t.documentElement.namespaceURI === V2 ? t.createElement(e) : t.createElementNS(n, e);
    };
  }
  function Wfe(e) {
    return function() {
      return this.ownerDocument.createElementNS(e.space, e.local);
    };
  }
  function K8(e) {
    var t = qw(e);
    return (t.local ? Wfe : Hfe)(t);
  }
  function qfe() {
  }
  function uP(e) {
    return e == null ? qfe : function() {
      return this.querySelector(e);
    };
  }
  function Kfe(e) {
    typeof e != "function" && (e = uP(e));
    for (var t = this._groups, n = t.length, r = new Array(n), o = 0; o < n; ++o)
      for (var a = t[o], i = a.length, s = r[o] = new Array(i), u, c, f = 0; f < i; ++f)
        (u = a[f]) && (c = e.call(u, u.__data__, f, a)) && ("__data__" in u && (c.__data__ = u.__data__), s[f] = c);
    return new po(r, this._parents);
  }
  function Gfe(e) {
    return e == null ? [] : Array.isArray(e) ? e : Array.from(e);
  }
  function Xfe() {
    return [];
  }
  function G8(e) {
    return e == null ? Xfe : function() {
      return this.querySelectorAll(e);
    };
  }
  function Yfe(e) {
    return function() {
      return Gfe(e.apply(this, arguments));
    };
  }
  function Jfe(e) {
    typeof e == "function" ? e = Yfe(e) : e = G8(e);
    for (var t = this._groups, n = t.length, r = [], o = [], a = 0; a < n; ++a)
      for (var i = t[a], s = i.length, u, c = 0; c < s; ++c)
        (u = i[c]) && (r.push(e.call(u, u.__data__, c, i)), o.push(u));
    return new po(r, o);
  }
  function X8(e) {
    return function() {
      return this.matches(e);
    };
  }
  function Y8(e) {
    return function(t) {
      return t.matches(e);
    };
  }
  var Qfe = Array.prototype.find;
  function Zfe(e) {
    return function() {
      return Qfe.call(this.children, e);
    };
  }
  function epe() {
    return this.firstElementChild;
  }
  function tpe(e) {
    return this.select(e == null ? epe : Zfe(typeof e == "function" ? e : Y8(e)));
  }
  var npe = Array.prototype.filter;
  function rpe() {
    return Array.from(this.children);
  }
  function ope(e) {
    return function() {
      return npe.call(this.children, e);
    };
  }
  function ape(e) {
    return this.selectAll(e == null ? rpe : ope(typeof e == "function" ? e : Y8(e)));
  }
  function ipe(e) {
    typeof e != "function" && (e = X8(e));
    for (var t = this._groups, n = t.length, r = new Array(n), o = 0; o < n; ++o)
      for (var a = t[o], i = a.length, s = r[o] = [], u, c = 0; c < i; ++c)
        (u = a[c]) && e.call(u, u.__data__, c, a) && s.push(u);
    return new po(r, this._parents);
  }
  function J8(e) {
    return new Array(e.length);
  }
  function spe() {
    return new po(this._enter || this._groups.map(J8), this._parents);
  }
  function wb(e, t) {
    this.ownerDocument = e.ownerDocument, this.namespaceURI = e.namespaceURI, this._next = null, this._parent = e, this.__data__ = t;
  }
  wb.prototype = {
    constructor: wb,
    appendChild: function(e) {
      return this._parent.insertBefore(e, this._next);
    },
    insertBefore: function(e, t) {
      return this._parent.insertBefore(e, t);
    },
    querySelector: function(e) {
      return this._parent.querySelector(e);
    },
    querySelectorAll: function(e) {
      return this._parent.querySelectorAll(e);
    }
  };
  function lpe(e) {
    return function() {
      return e;
    };
  }
  function upe(e, t, n, r, o, a) {
    for (var i = 0, s, u = t.length, c = a.length; i < c; ++i)
      (s = t[i]) ? (s.__data__ = a[i], r[i] = s) : n[i] = new wb(e, a[i]);
    for (; i < u; ++i)
      (s = t[i]) && (o[i] = s);
  }
  function cpe(e, t, n, r, o, a, i) {
    var s, u, c = /* @__PURE__ */ new Map(), f = t.length, p = a.length, g = new Array(f), h;
    for (s = 0; s < f; ++s)
      (u = t[s]) && (g[s] = h = i.call(u, u.__data__, s, t) + "", c.has(h) ? o[s] = u : c.set(h, u));
    for (s = 0; s < p; ++s)
      h = i.call(e, a[s], s, a) + "", (u = c.get(h)) ? (r[s] = u, u.__data__ = a[s], c.delete(h)) : n[s] = new wb(e, a[s]);
    for (s = 0; s < f; ++s)
      (u = t[s]) && c.get(g[s]) === u && (o[s] = u);
  }
  function dpe(e) {
    return e.__data__;
  }
  function fpe(e, t) {
    if (!arguments.length) return Array.from(this, dpe);
    var n = t ? cpe : upe, r = this._parents, o = this._groups;
    typeof e != "function" && (e = lpe(e));
    for (var a = o.length, i = new Array(a), s = new Array(a), u = new Array(a), c = 0; c < a; ++c) {
      var f = r[c], p = o[c], g = p.length, h = ppe(e.call(f, f && f.__data__, c, r)), y = h.length, b = s[c] = new Array(y), v = i[c] = new Array(y), w = u[c] = new Array(g);
      n(f, p, b, v, w, h, t);
      for (var _ = 0, k = 0, E, P; _ < y; ++_)
        if (E = b[_]) {
          for (_ >= k && (k = _ + 1); !(P = v[k]) && ++k < y; ) ;
          E._next = P || null;
        }
    }
    return i = new po(i, r), i._enter = s, i._exit = u, i;
  }
  function ppe(e) {
    return typeof e == "object" && "length" in e ? e : Array.from(e);
  }
  function mpe() {
    return new po(this._exit || this._groups.map(J8), this._parents);
  }
  function hpe(e, t, n) {
    var r = this.enter(), o = this, a = this.exit();
    return typeof e == "function" ? (r = e(r), r && (r = r.selection())) : r = r.append(e + ""), t != null && (o = t(o), o && (o = o.selection())), n == null ? a.remove() : n(a), r && o ? r.merge(o).order() : o;
  }
  function gpe(e) {
    for (var t = e.selection ? e.selection() : e, n = this._groups, r = t._groups, o = n.length, a = r.length, i = Math.min(o, a), s = new Array(o), u = 0; u < i; ++u)
      for (var c = n[u], f = r[u], p = c.length, g = s[u] = new Array(p), h, y = 0; y < p; ++y)
        (h = c[y] || f[y]) && (g[y] = h);
    for (; u < o; ++u)
      s[u] = n[u];
    return new po(s, this._parents);
  }
  function vpe() {
    for (var e = this._groups, t = -1, n = e.length; ++t < n; )
      for (var r = e[t], o = r.length - 1, a = r[o], i; --o >= 0; )
        (i = r[o]) && (a && i.compareDocumentPosition(a) ^ 4 && a.parentNode.insertBefore(i, a), a = i);
    return this;
  }
  function ype(e) {
    e || (e = bpe);
    function t(p, g) {
      return p && g ? e(p.__data__, g.__data__) : !p - !g;
    }
    for (var n = this._groups, r = n.length, o = new Array(r), a = 0; a < r; ++a) {
      for (var i = n[a], s = i.length, u = o[a] = new Array(s), c, f = 0; f < s; ++f)
        (c = i[f]) && (u[f] = c);
      u.sort(t);
    }
    return new po(o, this._parents).order();
  }
  function bpe(e, t) {
    return e < t ? -1 : e > t ? 1 : e >= t ? 0 : NaN;
  }
  function wpe() {
    var e = arguments[0];
    return arguments[0] = this, e.apply(null, arguments), this;
  }
  function xpe() {
    return Array.from(this);
  }
  function kpe() {
    for (var e = this._groups, t = 0, n = e.length; t < n; ++t)
      for (var r = e[t], o = 0, a = r.length; o < a; ++o) {
        var i = r[o];
        if (i) return i;
      }
    return null;
  }
  function Spe() {
    let e = 0;
    for (const t of this) ++e;
    return e;
  }
  function _pe() {
    return !this.node();
  }
  function Epe(e) {
    for (var t = this._groups, n = 0, r = t.length; n < r; ++n)
      for (var o = t[n], a = 0, i = o.length, s; a < i; ++a)
        (s = o[a]) && e.call(s, s.__data__, a, o);
    return this;
  }
  function Cpe(e) {
    return function() {
      this.removeAttribute(e);
    };
  }
  function Ppe(e) {
    return function() {
      this.removeAttributeNS(e.space, e.local);
    };
  }
  function Ope(e, t) {
    return function() {
      this.setAttribute(e, t);
    };
  }
  function Npe(e, t) {
    return function() {
      this.setAttributeNS(e.space, e.local, t);
    };
  }
  function Mpe(e, t) {
    return function() {
      var n = t.apply(this, arguments);
      n == null ? this.removeAttribute(e) : this.setAttribute(e, n);
    };
  }
  function Rpe(e, t) {
    return function() {
      var n = t.apply(this, arguments);
      n == null ? this.removeAttributeNS(e.space, e.local) : this.setAttributeNS(e.space, e.local, n);
    };
  }
  function jpe(e, t) {
    var n = qw(e);
    if (arguments.length < 2) {
      var r = this.node();
      return n.local ? r.getAttributeNS(n.space, n.local) : r.getAttribute(n);
    }
    return this.each((t == null ? n.local ? Ppe : Cpe : typeof t == "function" ? n.local ? Rpe : Mpe : n.local ? Npe : Ope)(n, t));
  }
  function Q8(e) {
    return e.ownerDocument && e.ownerDocument.defaultView || e.document && e || e.defaultView;
  }
  function Ipe(e) {
    return function() {
      this.style.removeProperty(e);
    };
  }
  function Ape(e, t, n) {
    return function() {
      this.style.setProperty(e, t, n);
    };
  }
  function $pe(e, t, n) {
    return function() {
      var r = t.apply(this, arguments);
      r == null ? this.style.removeProperty(e) : this.style.setProperty(e, r, n);
    };
  }
  function Dpe(e, t, n) {
    return arguments.length > 1 ? this.each((t == null ? Ipe : typeof t == "function" ? $pe : Ape)(e, t, n ?? "")) : yd(this.node(), e);
  }
  function yd(e, t) {
    return e.style.getPropertyValue(t) || Q8(e).getComputedStyle(e, null).getPropertyValue(t);
  }
  function Lpe(e) {
    return function() {
      delete this[e];
    };
  }
  function Fpe(e, t) {
    return function() {
      this[e] = t;
    };
  }
  function Tpe(e, t) {
    return function() {
      var n = t.apply(this, arguments);
      n == null ? delete this[e] : this[e] = n;
    };
  }
  function zpe(e, t) {
    return arguments.length > 1 ? this.each((t == null ? Lpe : typeof t == "function" ? Tpe : Fpe)(e, t)) : this.node()[e];
  }
  function Z8(e) {
    return e.trim().split(/^|\s+/);
  }
  function cP(e) {
    return e.classList || new eB(e);
  }
  function eB(e) {
    this._node = e, this._names = Z8(e.getAttribute("class") || "");
  }
  eB.prototype = {
    add: function(e) {
      var t = this._names.indexOf(e);
      t < 0 && (this._names.push(e), this._node.setAttribute("class", this._names.join(" ")));
    },
    remove: function(e) {
      var t = this._names.indexOf(e);
      t >= 0 && (this._names.splice(t, 1), this._node.setAttribute("class", this._names.join(" ")));
    },
    contains: function(e) {
      return this._names.indexOf(e) >= 0;
    }
  };
  function tB(e, t) {
    for (var n = cP(e), r = -1, o = t.length; ++r < o; ) n.add(t[r]);
  }
  function nB(e, t) {
    for (var n = cP(e), r = -1, o = t.length; ++r < o; ) n.remove(t[r]);
  }
  function Bpe(e) {
    return function() {
      tB(this, e);
    };
  }
  function Vpe(e) {
    return function() {
      nB(this, e);
    };
  }
  function Upe(e, t) {
    return function() {
      (t.apply(this, arguments) ? tB : nB)(this, e);
    };
  }
  function Hpe(e, t) {
    var n = Z8(e + "");
    if (arguments.length < 2) {
      for (var r = cP(this.node()), o = -1, a = n.length; ++o < a; ) if (!r.contains(n[o])) return !1;
      return !0;
    }
    return this.each((typeof t == "function" ? Upe : t ? Bpe : Vpe)(n, t));
  }
  function Wpe() {
    this.textContent = "";
  }
  function qpe(e) {
    return function() {
      this.textContent = e;
    };
  }
  function Kpe(e) {
    return function() {
      var t = e.apply(this, arguments);
      this.textContent = t ?? "";
    };
  }
  function Gpe(e) {
    return arguments.length ? this.each(e == null ? Wpe : (typeof e == "function" ? Kpe : qpe)(e)) : this.node().textContent;
  }
  function Xpe() {
    this.innerHTML = "";
  }
  function Ype(e) {
    return function() {
      this.innerHTML = e;
    };
  }
  function Jpe(e) {
    return function() {
      var t = e.apply(this, arguments);
      this.innerHTML = t ?? "";
    };
  }
  function Qpe(e) {
    return arguments.length ? this.each(e == null ? Xpe : (typeof e == "function" ? Jpe : Ype)(e)) : this.node().innerHTML;
  }
  function Zpe() {
    this.nextSibling && this.parentNode.appendChild(this);
  }
  function eme() {
    return this.each(Zpe);
  }
  function tme() {
    this.previousSibling && this.parentNode.insertBefore(this, this.parentNode.firstChild);
  }
  function nme() {
    return this.each(tme);
  }
  function rme(e) {
    var t = typeof e == "function" ? e : K8(e);
    return this.select(function() {
      return this.appendChild(t.apply(this, arguments));
    });
  }
  function ome() {
    return null;
  }
  function ame(e, t) {
    var n = typeof e == "function" ? e : K8(e), r = t == null ? ome : typeof t == "function" ? t : uP(t);
    return this.select(function() {
      return this.insertBefore(n.apply(this, arguments), r.apply(this, arguments) || null);
    });
  }
  function ime() {
    var e = this.parentNode;
    e && e.removeChild(this);
  }
  function sme() {
    return this.each(ime);
  }
  function lme() {
    var e = this.cloneNode(!1), t = this.parentNode;
    return t ? t.insertBefore(e, this.nextSibling) : e;
  }
  function ume() {
    var e = this.cloneNode(!0), t = this.parentNode;
    return t ? t.insertBefore(e, this.nextSibling) : e;
  }
  function cme(e) {
    return this.select(e ? ume : lme);
  }
  function dme(e) {
    return arguments.length ? this.property("__data__", e) : this.node().__data__;
  }
  function fme(e) {
    return function(t) {
      e.call(this, t, this.__data__);
    };
  }
  function pme(e) {
    return e.trim().split(/^|\s+/).map(function(t) {
      var n = "", r = t.indexOf(".");
      return r >= 0 && (n = t.slice(r + 1), t = t.slice(0, r)), { type: t, name: n };
    });
  }
  function mme(e) {
    return function() {
      var t = this.__on;
      if (t) {
        for (var n = 0, r = -1, o = t.length, a; n < o; ++n)
          a = t[n], (!e.type || a.type === e.type) && a.name === e.name ? this.removeEventListener(a.type, a.listener, a.options) : t[++r] = a;
        ++r ? t.length = r : delete this.__on;
      }
    };
  }
  function hme(e, t, n) {
    return function() {
      var r = this.__on, o, a = fme(t);
      if (r) {
        for (var i = 0, s = r.length; i < s; ++i)
          if ((o = r[i]).type === e.type && o.name === e.name) {
            this.removeEventListener(o.type, o.listener, o.options), this.addEventListener(o.type, o.listener = a, o.options = n), o.value = t;
            return;
          }
      }
      this.addEventListener(e.type, a, n), o = { type: e.type, name: e.name, value: t, listener: a, options: n }, r ? r.push(o) : this.__on = [o];
    };
  }
  function gme(e, t, n) {
    var r = pme(e + ""), o, a = r.length, i;
    if (arguments.length < 2) {
      var s = this.node().__on;
      if (s) {
        for (var u = 0, c = s.length, f; u < c; ++u)
          for (o = 0, f = s[u]; o < a; ++o)
            if ((i = r[o]).type === f.type && i.name === f.name)
              return f.value;
      }
      return;
    }
    for (s = t ? hme : mme, o = 0; o < a; ++o) this.each(s(r[o], t, n));
    return this;
  }
  function rB(e, t, n) {
    var r = Q8(e), o = r.CustomEvent;
    typeof o == "function" ? o = new o(t, n) : (o = r.document.createEvent("Event"), n ? (o.initEvent(t, n.bubbles, n.cancelable), o.detail = n.detail) : o.initEvent(t, !1, !1)), e.dispatchEvent(o);
  }
  function vme(e, t) {
    return function() {
      return rB(this, e, t);
    };
  }
  function yme(e, t) {
    return function() {
      return rB(this, e, t.apply(this, arguments));
    };
  }
  function bme(e, t) {
    return this.each((typeof t == "function" ? yme : vme)(e, t));
  }
  function* wme() {
    for (var e = this._groups, t = 0, n = e.length; t < n; ++t)
      for (var r = e[t], o = 0, a = r.length, i; o < a; ++o)
        (i = r[o]) && (yield i);
  }
  var oB = [null];
  function po(e, t) {
    this._groups = e, this._parents = t;
  }
  function Zm() {
    return new po([[document.documentElement]], oB);
  }
  function xme() {
    return this;
  }
  po.prototype = Zm.prototype = {
    constructor: po,
    select: Kfe,
    selectAll: Jfe,
    selectChild: tpe,
    selectChildren: ape,
    filter: ipe,
    data: fpe,
    enter: spe,
    exit: mpe,
    join: hpe,
    merge: gpe,
    selection: xme,
    order: vpe,
    sort: ype,
    call: wpe,
    nodes: xpe,
    node: kpe,
    size: Spe,
    empty: _pe,
    each: Epe,
    attr: jpe,
    style: Dpe,
    property: zpe,
    classed: Hpe,
    text: Gpe,
    html: Qpe,
    raise: eme,
    lower: nme,
    append: rme,
    insert: ame,
    remove: sme,
    clone: cme,
    datum: dme,
    on: gme,
    dispatch: bme,
    [Symbol.iterator]: wme
  };
  function io(e) {
    return typeof e == "string" ? new po([[document.querySelector(e)]], [document.documentElement]) : new po([[e]], oB);
  }
  function kme(e) {
    let t;
    for (; t = e.sourceEvent; ) e = t;
    return e;
  }
  function Ko(e, t) {
    if (e = kme(e), t === void 0 && (t = e.currentTarget), t) {
      var n = t.ownerSVGElement || t;
      if (n.createSVGPoint) {
        var r = n.createSVGPoint();
        return r.x = e.clientX, r.y = e.clientY, r = r.matrixTransform(t.getScreenCTM().inverse()), [r.x, r.y];
      }
      if (t.getBoundingClientRect) {
        var o = t.getBoundingClientRect();
        return [e.clientX - o.left - t.clientLeft, e.clientY - o.top - t.clientTop];
      }
    }
    return [e.pageX, e.pageY];
  }
  const Sme = { passive: !1 }, om = { capture: !0, passive: !1 };
  function W_(e) {
    e.stopImmediatePropagation();
  }
  function id(e) {
    e.preventDefault(), e.stopImmediatePropagation();
  }
  function aB(e) {
    var t = e.document.documentElement, n = io(e).on("dragstart.drag", id, om);
    "onselectstart" in t ? n.on("selectstart.drag", id, om) : (t.__noselect = t.style.MozUserSelect, t.style.MozUserSelect = "none");
  }
  function iB(e, t) {
    var n = e.document.documentElement, r = io(e).on("dragstart.drag", null);
    t && (r.on("click.drag", id, om), setTimeout(function() {
      r.on("click.drag", null);
    }, 0)), "onselectstart" in n ? r.on("selectstart.drag", null) : (n.style.MozUserSelect = n.__noselect, delete n.__noselect);
  }
  const hv = (e) => () => e;
  function U2(e, {
    sourceEvent: t,
    subject: n,
    target: r,
    identifier: o,
    active: a,
    x: i,
    y: s,
    dx: u,
    dy: c,
    dispatch: f
  }) {
    Object.defineProperties(this, {
      type: { value: e, enumerable: !0, configurable: !0 },
      sourceEvent: { value: t, enumerable: !0, configurable: !0 },
      subject: { value: n, enumerable: !0, configurable: !0 },
      target: { value: r, enumerable: !0, configurable: !0 },
      identifier: { value: o, enumerable: !0, configurable: !0 },
      active: { value: a, enumerable: !0, configurable: !0 },
      x: { value: i, enumerable: !0, configurable: !0 },
      y: { value: s, enumerable: !0, configurable: !0 },
      dx: { value: u, enumerable: !0, configurable: !0 },
      dy: { value: c, enumerable: !0, configurable: !0 },
      _: { value: f }
    });
  }
  U2.prototype.on = function() {
    var e = this._.on.apply(this._, arguments);
    return e === this._ ? this : e;
  };
  function _me(e) {
    return !e.ctrlKey && !e.button;
  }
  function Eme() {
    return this.parentNode;
  }
  function Cme(e, t) {
    return t ?? { x: e.x, y: e.y };
  }
  function Pme() {
    return navigator.maxTouchPoints || "ontouchstart" in this;
  }
  function sB() {
    var e = _me, t = Eme, n = Cme, r = Pme, o = {}, a = Ww("start", "drag", "end"), i = 0, s, u, c, f, p = 0;
    function g(E) {
      E.on("mousedown.drag", h).filter(r).on("touchstart.drag", v).on("touchmove.drag", w, Sme).on("touchend.drag touchcancel.drag", _).style("touch-action", "none").style("-webkit-tap-highlight-color", "rgba(0,0,0,0)");
    }
    function h(E, P) {
      if (!(f || !e.call(this, E, P))) {
        var O = k(this, t.call(this, E, P), E, P, "mouse");
        O && (io(E.view).on("mousemove.drag", y, om).on("mouseup.drag", b, om), aB(E.view), W_(E), c = !1, s = E.clientX, u = E.clientY, O("start", E));
      }
    }
    function y(E) {
      if (id(E), !c) {
        var P = E.clientX - s, O = E.clientY - u;
        c = P * P + O * O > p;
      }
      o.mouse("drag", E);
    }
    function b(E) {
      io(E.view).on("mousemove.drag mouseup.drag", null), iB(E.view, c), id(E), o.mouse("end", E);
    }
    function v(E, P) {
      if (e.call(this, E, P)) {
        var O = E.changedTouches, M = t.call(this, E, P), I = O.length, A, D;
        for (A = 0; A < I; ++A)
          (D = k(this, M, E, P, O[A].identifier, O[A])) && (W_(E), D("start", E, O[A]));
      }
    }
    function w(E) {
      var P = E.changedTouches, O = P.length, M, I;
      for (M = 0; M < O; ++M)
        (I = o[P[M].identifier]) && (id(E), I("drag", E, P[M]));
    }
    function _(E) {
      var P = E.changedTouches, O = P.length, M, I;
      for (f && clearTimeout(f), f = setTimeout(function() {
        f = null;
      }, 500), M = 0; M < O; ++M)
        (I = o[P[M].identifier]) && (W_(E), I("end", E, P[M]));
    }
    function k(E, P, O, M, I, A) {
      var D = a.copy(), F = Ko(A || O, P), j, U, $;
      if (($ = n.call(E, new U2("beforestart", {
        sourceEvent: O,
        target: g,
        identifier: I,
        active: i,
        x: F[0],
        y: F[1],
        dx: 0,
        dy: 0,
        dispatch: D
      }), M)) != null)
        return j = $.x - F[0] || 0, U = $.y - F[1] || 0, function q(B, G, W) {
          var Y = F, z;
          switch (B) {
            case "start":
              o[I] = q, z = i++;
              break;
            case "end":
              delete o[I], --i;
            // falls through
            case "drag":
              F = Ko(W || G, P), z = i;
              break;
          }
          D.call(
            B,
            E,
            new U2(B, {
              sourceEvent: G,
              subject: $,
              target: g,
              identifier: I,
              active: z,
              x: F[0] + j,
              y: F[1] + U,
              dx: F[0] - Y[0],
              dy: F[1] - Y[1],
              dispatch: D
            }),
            M
          );
        };
    }
    return g.filter = function(E) {
      return arguments.length ? (e = typeof E == "function" ? E : hv(!!E), g) : e;
    }, g.container = function(E) {
      return arguments.length ? (t = typeof E == "function" ? E : hv(E), g) : t;
    }, g.subject = function(E) {
      return arguments.length ? (n = typeof E == "function" ? E : hv(E), g) : n;
    }, g.touchable = function(E) {
      return arguments.length ? (r = typeof E == "function" ? E : hv(!!E), g) : r;
    }, g.on = function() {
      var E = a.on.apply(a, arguments);
      return E === a ? g : E;
    }, g.clickDistance = function(E) {
      return arguments.length ? (p = (E = +E) * E, g) : Math.sqrt(p);
    }, g;
  }
  function dP(e, t, n) {
    e.prototype = t.prototype = n, n.constructor = e;
  }
  function lB(e, t) {
    var n = Object.create(e.prototype);
    for (var r in t) n[r] = t[r];
    return n;
  }
  function eh() {
  }
  var am = 0.7, xb = 1 / am, sd = "\\s*([+-]?\\d+)\\s*", im = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)\\s*", Wa = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)%\\s*", Ome = /^#([0-9a-f]{3,8})$/, Nme = new RegExp(`^rgb\\(${sd},${sd},${sd}\\)$`), Mme = new RegExp(`^rgb\\(${Wa},${Wa},${Wa}\\)$`), Rme = new RegExp(`^rgba\\(${sd},${sd},${sd},${im}\\)$`), jme = new RegExp(`^rgba\\(${Wa},${Wa},${Wa},${im}\\)$`), Ime = new RegExp(`^hsl\\(${im},${Wa},${Wa}\\)$`), Ame = new RegExp(`^hsla\\(${im},${Wa},${Wa},${im}\\)$`), b$ = {
    aliceblue: 15792383,
    antiquewhite: 16444375,
    aqua: 65535,
    aquamarine: 8388564,
    azure: 15794175,
    beige: 16119260,
    bisque: 16770244,
    black: 0,
    blanchedalmond: 16772045,
    blue: 255,
    blueviolet: 9055202,
    brown: 10824234,
    burlywood: 14596231,
    cadetblue: 6266528,
    chartreuse: 8388352,
    chocolate: 13789470,
    coral: 16744272,
    cornflowerblue: 6591981,
    cornsilk: 16775388,
    crimson: 14423100,
    cyan: 65535,
    darkblue: 139,
    darkcyan: 35723,
    darkgoldenrod: 12092939,
    darkgray: 11119017,
    darkgreen: 25600,
    darkgrey: 11119017,
    darkkhaki: 12433259,
    darkmagenta: 9109643,
    darkolivegreen: 5597999,
    darkorange: 16747520,
    darkorchid: 10040012,
    darkred: 9109504,
    darksalmon: 15308410,
    darkseagreen: 9419919,
    darkslateblue: 4734347,
    darkslategray: 3100495,
    darkslategrey: 3100495,
    darkturquoise: 52945,
    darkviolet: 9699539,
    deeppink: 16716947,
    deepskyblue: 49151,
    dimgray: 6908265,
    dimgrey: 6908265,
    dodgerblue: 2003199,
    firebrick: 11674146,
    floralwhite: 16775920,
    forestgreen: 2263842,
    fuchsia: 16711935,
    gainsboro: 14474460,
    ghostwhite: 16316671,
    gold: 16766720,
    goldenrod: 14329120,
    gray: 8421504,
    green: 32768,
    greenyellow: 11403055,
    grey: 8421504,
    honeydew: 15794160,
    hotpink: 16738740,
    indianred: 13458524,
    indigo: 4915330,
    ivory: 16777200,
    khaki: 15787660,
    lavender: 15132410,
    lavenderblush: 16773365,
    lawngreen: 8190976,
    lemonchiffon: 16775885,
    lightblue: 11393254,
    lightcoral: 15761536,
    lightcyan: 14745599,
    lightgoldenrodyellow: 16448210,
    lightgray: 13882323,
    lightgreen: 9498256,
    lightgrey: 13882323,
    lightpink: 16758465,
    lightsalmon: 16752762,
    lightseagreen: 2142890,
    lightskyblue: 8900346,
    lightslategray: 7833753,
    lightslategrey: 7833753,
    lightsteelblue: 11584734,
    lightyellow: 16777184,
    lime: 65280,
    limegreen: 3329330,
    linen: 16445670,
    magenta: 16711935,
    maroon: 8388608,
    mediumaquamarine: 6737322,
    mediumblue: 205,
    mediumorchid: 12211667,
    mediumpurple: 9662683,
    mediumseagreen: 3978097,
    mediumslateblue: 8087790,
    mediumspringgreen: 64154,
    mediumturquoise: 4772300,
    mediumvioletred: 13047173,
    midnightblue: 1644912,
    mintcream: 16121850,
    mistyrose: 16770273,
    moccasin: 16770229,
    navajowhite: 16768685,
    navy: 128,
    oldlace: 16643558,
    olive: 8421376,
    olivedrab: 7048739,
    orange: 16753920,
    orangered: 16729344,
    orchid: 14315734,
    palegoldenrod: 15657130,
    palegreen: 10025880,
    paleturquoise: 11529966,
    palevioletred: 14381203,
    papayawhip: 16773077,
    peachpuff: 16767673,
    peru: 13468991,
    pink: 16761035,
    plum: 14524637,
    powderblue: 11591910,
    purple: 8388736,
    rebeccapurple: 6697881,
    red: 16711680,
    rosybrown: 12357519,
    royalblue: 4286945,
    saddlebrown: 9127187,
    salmon: 16416882,
    sandybrown: 16032864,
    seagreen: 3050327,
    seashell: 16774638,
    sienna: 10506797,
    silver: 12632256,
    skyblue: 8900331,
    slateblue: 6970061,
    slategray: 7372944,
    slategrey: 7372944,
    snow: 16775930,
    springgreen: 65407,
    steelblue: 4620980,
    tan: 13808780,
    teal: 32896,
    thistle: 14204888,
    tomato: 16737095,
    turquoise: 4251856,
    violet: 15631086,
    wheat: 16113331,
    white: 16777215,
    whitesmoke: 16119285,
    yellow: 16776960,
    yellowgreen: 10145074
  };
  dP(eh, fu, {
    copy(e) {
      return Object.assign(new this.constructor(), this, e);
    },
    displayable() {
      return this.rgb().displayable();
    },
    hex: w$,
    // Deprecated! Use color.formatHex.
    formatHex: w$,
    formatHex8: $me,
    formatHsl: Dme,
    formatRgb: x$,
    toString: x$
  });
  function w$() {
    return this.rgb().formatHex();
  }
  function $me() {
    return this.rgb().formatHex8();
  }
  function Dme() {
    return uB(this).formatHsl();
  }
  function x$() {
    return this.rgb().formatRgb();
  }
  function fu(e) {
    var t, n;
    return e = (e + "").trim().toLowerCase(), (t = Ome.exec(e)) ? (n = t[1].length, t = parseInt(t[1], 16), n === 6 ? k$(t) : n === 3 ? new Br(t >> 8 & 15 | t >> 4 & 240, t >> 4 & 15 | t & 240, (t & 15) << 4 | t & 15, 1) : n === 8 ? gv(t >> 24 & 255, t >> 16 & 255, t >> 8 & 255, (t & 255) / 255) : n === 4 ? gv(t >> 12 & 15 | t >> 8 & 240, t >> 8 & 15 | t >> 4 & 240, t >> 4 & 15 | t & 240, ((t & 15) << 4 | t & 15) / 255) : null) : (t = Nme.exec(e)) ? new Br(t[1], t[2], t[3], 1) : (t = Mme.exec(e)) ? new Br(t[1] * 255 / 100, t[2] * 255 / 100, t[3] * 255 / 100, 1) : (t = Rme.exec(e)) ? gv(t[1], t[2], t[3], t[4]) : (t = jme.exec(e)) ? gv(t[1] * 255 / 100, t[2] * 255 / 100, t[3] * 255 / 100, t[4]) : (t = Ime.exec(e)) ? E$(t[1], t[2] / 100, t[3] / 100, 1) : (t = Ame.exec(e)) ? E$(t[1], t[2] / 100, t[3] / 100, t[4]) : b$.hasOwnProperty(e) ? k$(b$[e]) : e === "transparent" ? new Br(NaN, NaN, NaN, 0) : null;
  }
  function k$(e) {
    return new Br(e >> 16 & 255, e >> 8 & 255, e & 255, 1);
  }
  function gv(e, t, n, r) {
    return r <= 0 && (e = t = n = NaN), new Br(e, t, n, r);
  }
  function Lme(e) {
    return e instanceof eh || (e = fu(e)), e ? (e = e.rgb(), new Br(e.r, e.g, e.b, e.opacity)) : new Br();
  }
  function H2(e, t, n, r) {
    return arguments.length === 1 ? Lme(e) : new Br(e, t, n, r ?? 1);
  }
  function Br(e, t, n, r) {
    this.r = +e, this.g = +t, this.b = +n, this.opacity = +r;
  }
  dP(Br, H2, lB(eh, {
    brighter(e) {
      return e = e == null ? xb : Math.pow(xb, e), new Br(this.r * e, this.g * e, this.b * e, this.opacity);
    },
    darker(e) {
      return e = e == null ? am : Math.pow(am, e), new Br(this.r * e, this.g * e, this.b * e, this.opacity);
    },
    rgb() {
      return this;
    },
    clamp() {
      return new Br(ou(this.r), ou(this.g), ou(this.b), kb(this.opacity));
    },
    displayable() {
      return -0.5 <= this.r && this.r < 255.5 && -0.5 <= this.g && this.g < 255.5 && -0.5 <= this.b && this.b < 255.5 && 0 <= this.opacity && this.opacity <= 1;
    },
    hex: S$,
    // Deprecated! Use color.formatHex.
    formatHex: S$,
    formatHex8: Fme,
    formatRgb: _$,
    toString: _$
  }));
  function S$() {
    return `#${nu(this.r)}${nu(this.g)}${nu(this.b)}`;
  }
  function Fme() {
    return `#${nu(this.r)}${nu(this.g)}${nu(this.b)}${nu((isNaN(this.opacity) ? 1 : this.opacity) * 255)}`;
  }
  function _$() {
    const e = kb(this.opacity);
    return `${e === 1 ? "rgb(" : "rgba("}${ou(this.r)}, ${ou(this.g)}, ${ou(this.b)}${e === 1 ? ")" : `, ${e})`}`;
  }
  function kb(e) {
    return isNaN(e) ? 1 : Math.max(0, Math.min(1, e));
  }
  function ou(e) {
    return Math.max(0, Math.min(255, Math.round(e) || 0));
  }
  function nu(e) {
    return e = ou(e), (e < 16 ? "0" : "") + e.toString(16);
  }
  function E$(e, t, n, r) {
    return r <= 0 ? e = t = n = NaN : n <= 0 || n >= 1 ? e = t = NaN : t <= 0 && (e = NaN), new Go(e, t, n, r);
  }
  function uB(e) {
    if (e instanceof Go) return new Go(e.h, e.s, e.l, e.opacity);
    if (e instanceof eh || (e = fu(e)), !e) return new Go();
    if (e instanceof Go) return e;
    e = e.rgb();
    var t = e.r / 255, n = e.g / 255, r = e.b / 255, o = Math.min(t, n, r), a = Math.max(t, n, r), i = NaN, s = a - o, u = (a + o) / 2;
    return s ? (t === a ? i = (n - r) / s + (n < r) * 6 : n === a ? i = (r - t) / s + 2 : i = (t - n) / s + 4, s /= u < 0.5 ? a + o : 2 - a - o, i *= 60) : s = u > 0 && u < 1 ? 0 : i, new Go(i, s, u, e.opacity);
  }
  function Tme(e, t, n, r) {
    return arguments.length === 1 ? uB(e) : new Go(e, t, n, r ?? 1);
  }
  function Go(e, t, n, r) {
    this.h = +e, this.s = +t, this.l = +n, this.opacity = +r;
  }
  dP(Go, Tme, lB(eh, {
    brighter(e) {
      return e = e == null ? xb : Math.pow(xb, e), new Go(this.h, this.s, this.l * e, this.opacity);
    },
    darker(e) {
      return e = e == null ? am : Math.pow(am, e), new Go(this.h, this.s, this.l * e, this.opacity);
    },
    rgb() {
      var e = this.h % 360 + (this.h < 0) * 360, t = isNaN(e) || isNaN(this.s) ? 0 : this.s, n = this.l, r = n + (n < 0.5 ? n : 1 - n) * t, o = 2 * n - r;
      return new Br(
        q_(e >= 240 ? e - 240 : e + 120, o, r),
        q_(e, o, r),
        q_(e < 120 ? e + 240 : e - 120, o, r),
        this.opacity
      );
    },
    clamp() {
      return new Go(C$(this.h), vv(this.s), vv(this.l), kb(this.opacity));
    },
    displayable() {
      return (0 <= this.s && this.s <= 1 || isNaN(this.s)) && 0 <= this.l && this.l <= 1 && 0 <= this.opacity && this.opacity <= 1;
    },
    formatHsl() {
      const e = kb(this.opacity);
      return `${e === 1 ? "hsl(" : "hsla("}${C$(this.h)}, ${vv(this.s) * 100}%, ${vv(this.l) * 100}%${e === 1 ? ")" : `, ${e})`}`;
    }
  }));
  function C$(e) {
    return e = (e || 0) % 360, e < 0 ? e + 360 : e;
  }
  function vv(e) {
    return Math.max(0, Math.min(1, e || 0));
  }
  function q_(e, t, n) {
    return (e < 60 ? t + (n - t) * e / 60 : e < 180 ? n : e < 240 ? t + (n - t) * (240 - e) / 60 : t) * 255;
  }
  const fP = (e) => () => e;
  function zme(e, t) {
    return function(n) {
      return e + n * t;
    };
  }
  function Bme(e, t, n) {
    return e = Math.pow(e, n), t = Math.pow(t, n) - e, n = 1 / n, function(r) {
      return Math.pow(e + r * t, n);
    };
  }
  function Vme(e) {
    return (e = +e) == 1 ? cB : function(t, n) {
      return n - t ? Bme(t, n, e) : fP(isNaN(t) ? n : t);
    };
  }
  function cB(e, t) {
    var n = t - e;
    return n ? zme(e, n) : fP(isNaN(e) ? t : e);
  }
  const Sb = (function e(t) {
    var n = Vme(t);
    function r(o, a) {
      var i = n((o = H2(o)).r, (a = H2(a)).r), s = n(o.g, a.g), u = n(o.b, a.b), c = cB(o.opacity, a.opacity);
      return function(f) {
        return o.r = i(f), o.g = s(f), o.b = u(f), o.opacity = c(f), o + "";
      };
    }
    return r.gamma = e, r;
  })(1);
  function Ume(e, t) {
    t || (t = []);
    var n = e ? Math.min(t.length, e.length) : 0, r = t.slice(), o;
    return function(a) {
      for (o = 0; o < n; ++o) r[o] = e[o] * (1 - a) + t[o] * a;
      return r;
    };
  }
  function Hme(e) {
    return ArrayBuffer.isView(e) && !(e instanceof DataView);
  }
  function Wme(e, t) {
    var n = t ? t.length : 0, r = e ? Math.min(n, e.length) : 0, o = new Array(r), a = new Array(n), i;
    for (i = 0; i < r; ++i) o[i] = Ip(e[i], t[i]);
    for (; i < n; ++i) a[i] = t[i];
    return function(s) {
      for (i = 0; i < r; ++i) a[i] = o[i](s);
      return a;
    };
  }
  function qme(e, t) {
    var n = /* @__PURE__ */ new Date();
    return e = +e, t = +t, function(r) {
      return n.setTime(e * (1 - r) + t * r), n;
    };
  }
  function Pa(e, t) {
    return e = +e, t = +t, function(n) {
      return e * (1 - n) + t * n;
    };
  }
  function Kme(e, t) {
    var n = {}, r = {}, o;
    (e === null || typeof e != "object") && (e = {}), (t === null || typeof t != "object") && (t = {});
    for (o in t)
      o in e ? n[o] = Ip(e[o], t[o]) : r[o] = t[o];
    return function(a) {
      for (o in n) r[o] = n[o](a);
      return r;
    };
  }
  var W2 = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g, K_ = new RegExp(W2.source, "g");
  function Gme(e) {
    return function() {
      return e;
    };
  }
  function Xme(e) {
    return function(t) {
      return e(t) + "";
    };
  }
  function dB(e, t) {
    var n = W2.lastIndex = K_.lastIndex = 0, r, o, a, i = -1, s = [], u = [];
    for (e = e + "", t = t + ""; (r = W2.exec(e)) && (o = K_.exec(t)); )
      (a = o.index) > n && (a = t.slice(n, a), s[i] ? s[i] += a : s[++i] = a), (r = r[0]) === (o = o[0]) ? s[i] ? s[i] += o : s[++i] = o : (s[++i] = null, u.push({ i, x: Pa(r, o) })), n = K_.lastIndex;
    return n < t.length && (a = t.slice(n), s[i] ? s[i] += a : s[++i] = a), s.length < 2 ? u[0] ? Xme(u[0].x) : Gme(t) : (t = u.length, function(c) {
      for (var f = 0, p; f < t; ++f) s[(p = u[f]).i] = p.x(c);
      return s.join("");
    });
  }
  function Ip(e, t) {
    var n = typeof t, r;
    return t == null || n === "boolean" ? fP(t) : (n === "number" ? Pa : n === "string" ? (r = fu(t)) ? (t = r, Sb) : dB : t instanceof fu ? Sb : t instanceof Date ? qme : Hme(t) ? Ume : Array.isArray(t) ? Wme : typeof t.valueOf != "function" && typeof t.toString != "function" || isNaN(t) ? Kme : Pa)(e, t);
  }
  var P$ = 180 / Math.PI, fB = {
    translateX: 0,
    translateY: 0,
    rotate: 0,
    skewX: 0,
    scaleX: 1,
    scaleY: 1
  };
  function pB(e, t, n, r, o, a) {
    var i, s, u;
    return (i = Math.sqrt(e * e + t * t)) && (e /= i, t /= i), (u = e * n + t * r) && (n -= e * u, r -= t * u), (s = Math.sqrt(n * n + r * r)) && (n /= s, r /= s, u /= s), e * r < t * n && (e = -e, t = -t, u = -u, i = -i), {
      translateX: o,
      translateY: a,
      rotate: Math.atan2(t, e) * P$,
      skewX: Math.atan(u) * P$,
      scaleX: i,
      scaleY: s
    };
  }
  var yv;
  function Yme(e) {
    const t = new (typeof DOMMatrix == "function" ? DOMMatrix : WebKitCSSMatrix)(e + "");
    return t.isIdentity ? fB : pB(t.a, t.b, t.c, t.d, t.e, t.f);
  }
  function Jme(e) {
    return e == null || (yv || (yv = document.createElementNS("http://www.w3.org/2000/svg", "g")), yv.setAttribute("transform", e), !(e = yv.transform.baseVal.consolidate())) ? fB : (e = e.matrix, pB(e.a, e.b, e.c, e.d, e.e, e.f));
  }
  function mB(e, t, n, r) {
    function o(c) {
      return c.length ? c.pop() + " " : "";
    }
    function a(c, f, p, g, h, y) {
      if (c !== p || f !== g) {
        var b = h.push("translate(", null, t, null, n);
        y.push({ i: b - 4, x: Pa(c, p) }, { i: b - 2, x: Pa(f, g) });
      } else (p || g) && h.push("translate(" + p + t + g + n);
    }
    function i(c, f, p, g) {
      c !== f ? (c - f > 180 ? f += 360 : f - c > 180 && (c += 360), g.push({ i: p.push(o(p) + "rotate(", null, r) - 2, x: Pa(c, f) })) : f && p.push(o(p) + "rotate(" + f + r);
    }
    function s(c, f, p, g) {
      c !== f ? g.push({ i: p.push(o(p) + "skewX(", null, r) - 2, x: Pa(c, f) }) : f && p.push(o(p) + "skewX(" + f + r);
    }
    function u(c, f, p, g, h, y) {
      if (c !== p || f !== g) {
        var b = h.push(o(h) + "scale(", null, ",", null, ")");
        y.push({ i: b - 4, x: Pa(c, p) }, { i: b - 2, x: Pa(f, g) });
      } else (p !== 1 || g !== 1) && h.push(o(h) + "scale(" + p + "," + g + ")");
    }
    return function(c, f) {
      var p = [], g = [];
      return c = e(c), f = e(f), a(c.translateX, c.translateY, f.translateX, f.translateY, p, g), i(c.rotate, f.rotate, p, g), s(c.skewX, f.skewX, p, g), u(c.scaleX, c.scaleY, f.scaleX, f.scaleY, p, g), c = f = null, function(h) {
        for (var y = -1, b = g.length, v; ++y < b; ) p[(v = g[y]).i] = v.x(h);
        return p.join("");
      };
    };
  }
  var Qme = mB(Yme, "px, ", "px)", "deg)"), Zme = mB(Jme, ", ", ")", ")"), ehe = 1e-12;
  function O$(e) {
    return ((e = Math.exp(e)) + 1 / e) / 2;
  }
  function the(e) {
    return ((e = Math.exp(e)) - 1 / e) / 2;
  }
  function nhe(e) {
    return ((e = Math.exp(2 * e)) - 1) / (e + 1);
  }
  const Fy = (function e(t, n, r) {
    function o(a, i) {
      var s = a[0], u = a[1], c = a[2], f = i[0], p = i[1], g = i[2], h = f - s, y = p - u, b = h * h + y * y, v, w;
      if (b < ehe)
        w = Math.log(g / c) / t, v = function(M) {
          return [
            s + M * h,
            u + M * y,
            c * Math.exp(t * M * w)
          ];
        };
      else {
        var _ = Math.sqrt(b), k = (g * g - c * c + r * b) / (2 * c * n * _), E = (g * g - c * c - r * b) / (2 * g * n * _), P = Math.log(Math.sqrt(k * k + 1) - k), O = Math.log(Math.sqrt(E * E + 1) - E);
        w = (O - P) / t, v = function(M) {
          var I = M * w, A = O$(P), D = c / (n * _) * (A * nhe(t * I + P) - the(P));
          return [
            s + D * h,
            u + D * y,
            c * A / O$(t * I + P)
          ];
        };
      }
      return v.duration = w * 1e3 * t / Math.SQRT2, v;
    }
    return o.rho = function(a) {
      var i = Math.max(1e-3, +a), s = i * i, u = s * s;
      return e(i, s, u);
    }, o;
  })(Math.SQRT2, 2, 4);
  var bd = 0, bp = 0, Yf = 0, hB = 1e3, _b, wp, Eb = 0, pu = 0, Kw = 0, sm = typeof performance == "object" && performance.now ? performance : Date, gB = typeof window == "object" && window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : function(e) {
    setTimeout(e, 17);
  };
  function pP() {
    return pu || (gB(rhe), pu = sm.now() + Kw);
  }
  function rhe() {
    pu = 0;
  }
  function Cb() {
    this._call = this._time = this._next = null;
  }
  Cb.prototype = vB.prototype = {
    constructor: Cb,
    restart: function(e, t, n) {
      if (typeof e != "function") throw new TypeError("callback is not a function");
      n = (n == null ? pP() : +n) + (t == null ? 0 : +t), !this._next && wp !== this && (wp ? wp._next = this : _b = this, wp = this), this._call = e, this._time = n, q2();
    },
    stop: function() {
      this._call && (this._call = null, this._time = 1 / 0, q2());
    }
  };
  function vB(e, t, n) {
    var r = new Cb();
    return r.restart(e, t, n), r;
  }
  function ohe() {
    pP(), ++bd;
    for (var e = _b, t; e; )
      (t = pu - e._time) >= 0 && e._call.call(void 0, t), e = e._next;
    --bd;
  }
  function N$() {
    pu = (Eb = sm.now()) + Kw, bd = bp = 0;
    try {
      ohe();
    } finally {
      bd = 0, ihe(), pu = 0;
    }
  }
  function ahe() {
    var e = sm.now(), t = e - Eb;
    t > hB && (Kw -= t, Eb = e);
  }
  function ihe() {
    for (var e, t = _b, n, r = 1 / 0; t; )
      t._call ? (r > t._time && (r = t._time), e = t, t = t._next) : (n = t._next, t._next = null, t = e ? e._next = n : _b = n);
    wp = e, q2(r);
  }
  function q2(e) {
    if (!bd) {
      bp && (bp = clearTimeout(bp));
      var t = e - pu;
      t > 24 ? (e < 1 / 0 && (bp = setTimeout(N$, e - sm.now() - Kw)), Yf && (Yf = clearInterval(Yf))) : (Yf || (Eb = sm.now(), Yf = setInterval(ahe, hB)), bd = 1, gB(N$));
    }
  }
  function M$(e, t, n) {
    var r = new Cb();
    return t = t == null ? 0 : +t, r.restart((o) => {
      r.stop(), e(o + t);
    }, t, n), r;
  }
  var she = Ww("start", "end", "cancel", "interrupt"), lhe = [], yB = 0, R$ = 1, K2 = 2, Ty = 3, j$ = 4, G2 = 5, zy = 6;
  function Gw(e, t, n, r, o, a) {
    var i = e.__transition;
    if (!i) e.__transition = {};
    else if (n in i) return;
    uhe(e, n, {
      name: t,
      index: r,
      // For context during callback.
      group: o,
      // For context during callback.
      on: she,
      tween: lhe,
      time: a.time,
      delay: a.delay,
      duration: a.duration,
      ease: a.ease,
      timer: null,
      state: yB
    });
  }
  function mP(e, t) {
    var n = ua(e, t);
    if (n.state > yB) throw new Error("too late; already scheduled");
    return n;
  }
  function ei(e, t) {
    var n = ua(e, t);
    if (n.state > Ty) throw new Error("too late; already running");
    return n;
  }
  function ua(e, t) {
    var n = e.__transition;
    if (!n || !(n = n[t])) throw new Error("transition not found");
    return n;
  }
  function uhe(e, t, n) {
    var r = e.__transition, o;
    r[t] = n, n.timer = vB(a, 0, n.time);
    function a(c) {
      n.state = R$, n.timer.restart(i, n.delay, n.time), n.delay <= c && i(c - n.delay);
    }
    function i(c) {
      var f, p, g, h;
      if (n.state !== R$) return u();
      for (f in r)
        if (h = r[f], h.name === n.name) {
          if (h.state === Ty) return M$(i);
          h.state === j$ ? (h.state = zy, h.timer.stop(), h.on.call("interrupt", e, e.__data__, h.index, h.group), delete r[f]) : +f < t && (h.state = zy, h.timer.stop(), h.on.call("cancel", e, e.__data__, h.index, h.group), delete r[f]);
        }
      if (M$(function() {
        n.state === Ty && (n.state = j$, n.timer.restart(s, n.delay, n.time), s(c));
      }), n.state = K2, n.on.call("start", e, e.__data__, n.index, n.group), n.state === K2) {
        for (n.state = Ty, o = new Array(g = n.tween.length), f = 0, p = -1; f < g; ++f)
          (h = n.tween[f].value.call(e, e.__data__, n.index, n.group)) && (o[++p] = h);
        o.length = p + 1;
      }
    }
    function s(c) {
      for (var f = c < n.duration ? n.ease.call(null, c / n.duration) : (n.timer.restart(u), n.state = G2, 1), p = -1, g = o.length; ++p < g; )
        o[p].call(e, f);
      n.state === G2 && (n.on.call("end", e, e.__data__, n.index, n.group), u());
    }
    function u() {
      n.state = zy, n.timer.stop(), delete r[t];
      for (var c in r) return;
      delete e.__transition;
    }
  }
  function By(e, t) {
    var n = e.__transition, r, o, a = !0, i;
    if (n) {
      t = t == null ? null : t + "";
      for (i in n) {
        if ((r = n[i]).name !== t) {
          a = !1;
          continue;
        }
        o = r.state > K2 && r.state < G2, r.state = zy, r.timer.stop(), r.on.call(o ? "interrupt" : "cancel", e, e.__data__, r.index, r.group), delete n[i];
      }
      a && delete e.__transition;
    }
  }
  function che(e) {
    return this.each(function() {
      By(this, e);
    });
  }
  function dhe(e, t) {
    var n, r;
    return function() {
      var o = ei(this, e), a = o.tween;
      if (a !== n) {
        r = n = a;
        for (var i = 0, s = r.length; i < s; ++i)
          if (r[i].name === t) {
            r = r.slice(), r.splice(i, 1);
            break;
          }
      }
      o.tween = r;
    };
  }
  function fhe(e, t, n) {
    var r, o;
    if (typeof n != "function") throw new Error();
    return function() {
      var a = ei(this, e), i = a.tween;
      if (i !== r) {
        o = (r = i).slice();
        for (var s = { name: t, value: n }, u = 0, c = o.length; u < c; ++u)
          if (o[u].name === t) {
            o[u] = s;
            break;
          }
        u === c && o.push(s);
      }
      a.tween = o;
    };
  }
  function phe(e, t) {
    var n = this._id;
    if (e += "", arguments.length < 2) {
      for (var r = ua(this.node(), n).tween, o = 0, a = r.length, i; o < a; ++o)
        if ((i = r[o]).name === e)
          return i.value;
      return null;
    }
    return this.each((t == null ? dhe : fhe)(n, e, t));
  }
  function hP(e, t, n) {
    var r = e._id;
    return e.each(function() {
      var o = ei(this, r);
      (o.value || (o.value = {}))[t] = n.apply(this, arguments);
    }), function(o) {
      return ua(o, r).value[t];
    };
  }
  function bB(e, t) {
    var n;
    return (typeof t == "number" ? Pa : t instanceof fu ? Sb : (n = fu(t)) ? (t = n, Sb) : dB)(e, t);
  }
  function mhe(e) {
    return function() {
      this.removeAttribute(e);
    };
  }
  function hhe(e) {
    return function() {
      this.removeAttributeNS(e.space, e.local);
    };
  }
  function ghe(e, t, n) {
    var r, o = n + "", a;
    return function() {
      var i = this.getAttribute(e);
      return i === o ? null : i === r ? a : a = t(r = i, n);
    };
  }
  function vhe(e, t, n) {
    var r, o = n + "", a;
    return function() {
      var i = this.getAttributeNS(e.space, e.local);
      return i === o ? null : i === r ? a : a = t(r = i, n);
    };
  }
  function yhe(e, t, n) {
    var r, o, a;
    return function() {
      var i, s = n(this), u;
      return s == null ? void this.removeAttribute(e) : (i = this.getAttribute(e), u = s + "", i === u ? null : i === r && u === o ? a : (o = u, a = t(r = i, s)));
    };
  }
  function bhe(e, t, n) {
    var r, o, a;
    return function() {
      var i, s = n(this), u;
      return s == null ? void this.removeAttributeNS(e.space, e.local) : (i = this.getAttributeNS(e.space, e.local), u = s + "", i === u ? null : i === r && u === o ? a : (o = u, a = t(r = i, s)));
    };
  }
  function whe(e, t) {
    var n = qw(e), r = n === "transform" ? Zme : bB;
    return this.attrTween(e, typeof t == "function" ? (n.local ? bhe : yhe)(n, r, hP(this, "attr." + e, t)) : t == null ? (n.local ? hhe : mhe)(n) : (n.local ? vhe : ghe)(n, r, t));
  }
  function xhe(e, t) {
    return function(n) {
      this.setAttribute(e, t.call(this, n));
    };
  }
  function khe(e, t) {
    return function(n) {
      this.setAttributeNS(e.space, e.local, t.call(this, n));
    };
  }
  function She(e, t) {
    var n, r;
    function o() {
      var a = t.apply(this, arguments);
      return a !== r && (n = (r = a) && khe(e, a)), n;
    }
    return o._value = t, o;
  }
  function _he(e, t) {
    var n, r;
    function o() {
      var a = t.apply(this, arguments);
      return a !== r && (n = (r = a) && xhe(e, a)), n;
    }
    return o._value = t, o;
  }
  function Ehe(e, t) {
    var n = "attr." + e;
    if (arguments.length < 2) return (n = this.tween(n)) && n._value;
    if (t == null) return this.tween(n, null);
    if (typeof t != "function") throw new Error();
    var r = qw(e);
    return this.tween(n, (r.local ? She : _he)(r, t));
  }
  function Che(e, t) {
    return function() {
      mP(this, e).delay = +t.apply(this, arguments);
    };
  }
  function Phe(e, t) {
    return t = +t, function() {
      mP(this, e).delay = t;
    };
  }
  function Ohe(e) {
    var t = this._id;
    return arguments.length ? this.each((typeof e == "function" ? Che : Phe)(t, e)) : ua(this.node(), t).delay;
  }
  function Nhe(e, t) {
    return function() {
      ei(this, e).duration = +t.apply(this, arguments);
    };
  }
  function Mhe(e, t) {
    return t = +t, function() {
      ei(this, e).duration = t;
    };
  }
  function Rhe(e) {
    var t = this._id;
    return arguments.length ? this.each((typeof e == "function" ? Nhe : Mhe)(t, e)) : ua(this.node(), t).duration;
  }
  function jhe(e, t) {
    if (typeof t != "function") throw new Error();
    return function() {
      ei(this, e).ease = t;
    };
  }
  function Ihe(e) {
    var t = this._id;
    return arguments.length ? this.each(jhe(t, e)) : ua(this.node(), t).ease;
  }
  function Ahe(e, t) {
    return function() {
      var n = t.apply(this, arguments);
      if (typeof n != "function") throw new Error();
      ei(this, e).ease = n;
    };
  }
  function $he(e) {
    if (typeof e != "function") throw new Error();
    return this.each(Ahe(this._id, e));
  }
  function Dhe(e) {
    typeof e != "function" && (e = X8(e));
    for (var t = this._groups, n = t.length, r = new Array(n), o = 0; o < n; ++o)
      for (var a = t[o], i = a.length, s = r[o] = [], u, c = 0; c < i; ++c)
        (u = a[c]) && e.call(u, u.__data__, c, a) && s.push(u);
    return new Xi(r, this._parents, this._name, this._id);
  }
  function Lhe(e) {
    if (e._id !== this._id) throw new Error();
    for (var t = this._groups, n = e._groups, r = t.length, o = n.length, a = Math.min(r, o), i = new Array(r), s = 0; s < a; ++s)
      for (var u = t[s], c = n[s], f = u.length, p = i[s] = new Array(f), g, h = 0; h < f; ++h)
        (g = u[h] || c[h]) && (p[h] = g);
    for (; s < r; ++s)
      i[s] = t[s];
    return new Xi(i, this._parents, this._name, this._id);
  }
  function Fhe(e) {
    return (e + "").trim().split(/^|\s+/).every(function(t) {
      var n = t.indexOf(".");
      return n >= 0 && (t = t.slice(0, n)), !t || t === "start";
    });
  }
  function The(e, t, n) {
    var r, o, a = Fhe(t) ? mP : ei;
    return function() {
      var i = a(this, e), s = i.on;
      s !== r && (o = (r = s).copy()).on(t, n), i.on = o;
    };
  }
  function zhe(e, t) {
    var n = this._id;
    return arguments.length < 2 ? ua(this.node(), n).on.on(e) : this.each(The(n, e, t));
  }
  function Bhe(e) {
    return function() {
      var t = this.parentNode;
      for (var n in this.__transition) if (+n !== e) return;
      t && t.removeChild(this);
    };
  }
  function Vhe() {
    return this.on("end.remove", Bhe(this._id));
  }
  function Uhe(e) {
    var t = this._name, n = this._id;
    typeof e != "function" && (e = uP(e));
    for (var r = this._groups, o = r.length, a = new Array(o), i = 0; i < o; ++i)
      for (var s = r[i], u = s.length, c = a[i] = new Array(u), f, p, g = 0; g < u; ++g)
        (f = s[g]) && (p = e.call(f, f.__data__, g, s)) && ("__data__" in f && (p.__data__ = f.__data__), c[g] = p, Gw(c[g], t, n, g, c, ua(f, n)));
    return new Xi(a, this._parents, t, n);
  }
  function Hhe(e) {
    var t = this._name, n = this._id;
    typeof e != "function" && (e = G8(e));
    for (var r = this._groups, o = r.length, a = [], i = [], s = 0; s < o; ++s)
      for (var u = r[s], c = u.length, f, p = 0; p < c; ++p)
        if (f = u[p]) {
          for (var g = e.call(f, f.__data__, p, u), h, y = ua(f, n), b = 0, v = g.length; b < v; ++b)
            (h = g[b]) && Gw(h, t, n, b, g, y);
          a.push(g), i.push(f);
        }
    return new Xi(a, i, t, n);
  }
  var Whe = Zm.prototype.constructor;
  function qhe() {
    return new Whe(this._groups, this._parents);
  }
  function Khe(e, t) {
    var n, r, o;
    return function() {
      var a = yd(this, e), i = (this.style.removeProperty(e), yd(this, e));
      return a === i ? null : a === n && i === r ? o : o = t(n = a, r = i);
    };
  }
  function wB(e) {
    return function() {
      this.style.removeProperty(e);
    };
  }
  function Ghe(e, t, n) {
    var r, o = n + "", a;
    return function() {
      var i = yd(this, e);
      return i === o ? null : i === r ? a : a = t(r = i, n);
    };
  }
  function Xhe(e, t, n) {
    var r, o, a;
    return function() {
      var i = yd(this, e), s = n(this), u = s + "";
      return s == null && (u = s = (this.style.removeProperty(e), yd(this, e))), i === u ? null : i === r && u === o ? a : (o = u, a = t(r = i, s));
    };
  }
  function Yhe(e, t) {
    var n, r, o, a = "style." + t, i = "end." + a, s;
    return function() {
      var u = ei(this, e), c = u.on, f = u.value[a] == null ? s || (s = wB(t)) : void 0;
      (c !== n || o !== f) && (r = (n = c).copy()).on(i, o = f), u.on = r;
    };
  }
  function Jhe(e, t, n) {
    var r = (e += "") == "transform" ? Qme : bB;
    return t == null ? this.styleTween(e, Khe(e, r)).on("end.style." + e, wB(e)) : typeof t == "function" ? this.styleTween(e, Xhe(e, r, hP(this, "style." + e, t))).each(Yhe(this._id, e)) : this.styleTween(e, Ghe(e, r, t), n).on("end.style." + e, null);
  }
  function Qhe(e, t, n) {
    return function(r) {
      this.style.setProperty(e, t.call(this, r), n);
    };
  }
  function Zhe(e, t, n) {
    var r, o;
    function a() {
      var i = t.apply(this, arguments);
      return i !== o && (r = (o = i) && Qhe(e, i, n)), r;
    }
    return a._value = t, a;
  }
  function ege(e, t, n) {
    var r = "style." + (e += "");
    if (arguments.length < 2) return (r = this.tween(r)) && r._value;
    if (t == null) return this.tween(r, null);
    if (typeof t != "function") throw new Error();
    return this.tween(r, Zhe(e, t, n ?? ""));
  }
  function tge(e) {
    return function() {
      this.textContent = e;
    };
  }
  function nge(e) {
    return function() {
      var t = e(this);
      this.textContent = t ?? "";
    };
  }
  function rge(e) {
    return this.tween("text", typeof e == "function" ? nge(hP(this, "text", e)) : tge(e == null ? "" : e + ""));
  }
  function oge(e) {
    return function(t) {
      this.textContent = e.call(this, t);
    };
  }
  function age(e) {
    var t, n;
    function r() {
      var o = e.apply(this, arguments);
      return o !== n && (t = (n = o) && oge(o)), t;
    }
    return r._value = e, r;
  }
  function ige(e) {
    var t = "text";
    if (arguments.length < 1) return (t = this.tween(t)) && t._value;
    if (e == null) return this.tween(t, null);
    if (typeof e != "function") throw new Error();
    return this.tween(t, age(e));
  }
  function sge() {
    for (var e = this._name, t = this._id, n = xB(), r = this._groups, o = r.length, a = 0; a < o; ++a)
      for (var i = r[a], s = i.length, u, c = 0; c < s; ++c)
        if (u = i[c]) {
          var f = ua(u, t);
          Gw(u, e, n, c, i, {
            time: f.time + f.delay + f.duration,
            delay: 0,
            duration: f.duration,
            ease: f.ease
          });
        }
    return new Xi(r, this._parents, e, n);
  }
  function lge() {
    var e, t, n = this, r = n._id, o = n.size();
    return new Promise(function(a, i) {
      var s = { value: i }, u = { value: function() {
        --o === 0 && a();
      } };
      n.each(function() {
        var c = ei(this, r), f = c.on;
        f !== e && (t = (e = f).copy(), t._.cancel.push(s), t._.interrupt.push(s), t._.end.push(u)), c.on = t;
      }), o === 0 && a();
    });
  }
  var uge = 0;
  function Xi(e, t, n, r) {
    this._groups = e, this._parents = t, this._name = n, this._id = r;
  }
  function xB() {
    return ++uge;
  }
  var Oi = Zm.prototype;
  Xi.prototype = {
    constructor: Xi,
    select: Uhe,
    selectAll: Hhe,
    selectChild: Oi.selectChild,
    selectChildren: Oi.selectChildren,
    filter: Dhe,
    merge: Lhe,
    selection: qhe,
    transition: sge,
    call: Oi.call,
    nodes: Oi.nodes,
    node: Oi.node,
    size: Oi.size,
    empty: Oi.empty,
    each: Oi.each,
    on: zhe,
    attr: whe,
    attrTween: Ehe,
    style: Jhe,
    styleTween: ege,
    text: rge,
    textTween: ige,
    remove: Vhe,
    tween: phe,
    delay: Ohe,
    duration: Rhe,
    ease: Ihe,
    easeVarying: $he,
    end: lge,
    [Symbol.iterator]: Oi[Symbol.iterator]
  };
  function cge(e) {
    return ((e *= 2) <= 1 ? e * e * e : (e -= 2) * e * e + 2) / 2;
  }
  var dge = {
    time: null,
    // Set on use.
    delay: 0,
    duration: 250,
    ease: cge
  };
  function fge(e, t) {
    for (var n; !(n = e.__transition) || !(n = n[t]); )
      if (!(e = e.parentNode))
        throw new Error(`transition ${t} not found`);
    return n;
  }
  function pge(e) {
    var t, n;
    e instanceof Xi ? (t = e._id, e = e._name) : (t = xB(), (n = dge).time = pP(), e = e == null ? null : e + "");
    for (var r = this._groups, o = r.length, a = 0; a < o; ++a)
      for (var i = r[a], s = i.length, u, c = 0; c < s; ++c)
        (u = i[c]) && Gw(u, e, t, c, i, n || fge(u, t));
    return new Xi(r, this._parents, e, t);
  }
  Zm.prototype.interrupt = che;
  Zm.prototype.transition = pge;
  const bv = (e) => () => e;
  function mge(e, {
    sourceEvent: t,
    target: n,
    transform: r,
    dispatch: o
  }) {
    Object.defineProperties(this, {
      type: { value: e, enumerable: !0, configurable: !0 },
      sourceEvent: { value: t, enumerable: !0, configurable: !0 },
      target: { value: n, enumerable: !0, configurable: !0 },
      transform: { value: r, enumerable: !0, configurable: !0 },
      _: { value: o }
    });
  }
  function Di(e, t, n) {
    this.k = e, this.x = t, this.y = n;
  }
  Di.prototype = {
    constructor: Di,
    scale: function(e) {
      return e === 1 ? this : new Di(this.k * e, this.x, this.y);
    },
    translate: function(e, t) {
      return e === 0 & t === 0 ? this : new Di(this.k, this.x + this.k * e, this.y + this.k * t);
    },
    apply: function(e) {
      return [e[0] * this.k + this.x, e[1] * this.k + this.y];
    },
    applyX: function(e) {
      return e * this.k + this.x;
    },
    applyY: function(e) {
      return e * this.k + this.y;
    },
    invert: function(e) {
      return [(e[0] - this.x) / this.k, (e[1] - this.y) / this.k];
    },
    invertX: function(e) {
      return (e - this.x) / this.k;
    },
    invertY: function(e) {
      return (e - this.y) / this.k;
    },
    rescaleX: function(e) {
      return e.copy().domain(e.range().map(this.invertX, this).map(e.invert, e));
    },
    rescaleY: function(e) {
      return e.copy().domain(e.range().map(this.invertY, this).map(e.invert, e));
    },
    toString: function() {
      return "translate(" + this.x + "," + this.y + ") scale(" + this.k + ")";
    }
  };
  var Xw = new Di(1, 0, 0);
  kB.prototype = Di.prototype;
  function kB(e) {
    for (; !e.__zoom; ) if (!(e = e.parentNode)) return Xw;
    return e.__zoom;
  }
  function G_(e) {
    e.stopImmediatePropagation();
  }
  function Jf(e) {
    e.preventDefault(), e.stopImmediatePropagation();
  }
  function hge(e) {
    return (!e.ctrlKey || e.type === "wheel") && !e.button;
  }
  function gge() {
    var e = this;
    return e instanceof SVGElement ? (e = e.ownerSVGElement || e, e.hasAttribute("viewBox") ? (e = e.viewBox.baseVal, [[e.x, e.y], [e.x + e.width, e.y + e.height]]) : [[0, 0], [e.width.baseVal.value, e.height.baseVal.value]]) : [[0, 0], [e.clientWidth, e.clientHeight]];
  }
  function I$() {
    return this.__zoom || Xw;
  }
  function vge(e) {
    return -e.deltaY * (e.deltaMode === 1 ? 0.05 : e.deltaMode ? 1 : 2e-3) * (e.ctrlKey ? 10 : 1);
  }
  function yge() {
    return navigator.maxTouchPoints || "ontouchstart" in this;
  }
  function bge(e, t, n) {
    var r = e.invertX(t[0][0]) - n[0][0], o = e.invertX(t[1][0]) - n[1][0], a = e.invertY(t[0][1]) - n[0][1], i = e.invertY(t[1][1]) - n[1][1];
    return e.translate(
      o > r ? (r + o) / 2 : Math.min(0, r) || Math.max(0, o),
      i > a ? (a + i) / 2 : Math.min(0, a) || Math.max(0, i)
    );
  }
  function SB() {
    var e = hge, t = gge, n = bge, r = vge, o = yge, a = [0, 1 / 0], i = [[-1 / 0, -1 / 0], [1 / 0, 1 / 0]], s = 250, u = Fy, c = Ww("start", "zoom", "end"), f, p, g, h = 500, y = 150, b = 0, v = 10;
    function w($) {
      $.property("__zoom", I$).on("wheel.zoom", I, { passive: !1 }).on("mousedown.zoom", A).on("dblclick.zoom", D).filter(o).on("touchstart.zoom", F).on("touchmove.zoom", j).on("touchend.zoom touchcancel.zoom", U).style("-webkit-tap-highlight-color", "rgba(0,0,0,0)");
    }
    w.transform = function($, q, B, G) {
      var W = $.selection ? $.selection() : $;
      W.property("__zoom", I$), $ !== W ? P($, q, B, G) : W.interrupt().each(function() {
        O(this, arguments).event(G).start().zoom(null, typeof q == "function" ? q.apply(this, arguments) : q).end();
      });
    }, w.scaleBy = function($, q, B, G) {
      w.scaleTo($, function() {
        var W = this.__zoom.k, Y = typeof q == "function" ? q.apply(this, arguments) : q;
        return W * Y;
      }, B, G);
    }, w.scaleTo = function($, q, B, G) {
      w.transform($, function() {
        var W = t.apply(this, arguments), Y = this.__zoom, z = B == null ? E(W) : typeof B == "function" ? B.apply(this, arguments) : B, L = Y.invert(z), K = typeof q == "function" ? q.apply(this, arguments) : q;
        return n(k(_(Y, K), z, L), W, i);
      }, B, G);
    }, w.translateBy = function($, q, B, G) {
      w.transform($, function() {
        return n(this.__zoom.translate(
          typeof q == "function" ? q.apply(this, arguments) : q,
          typeof B == "function" ? B.apply(this, arguments) : B
        ), t.apply(this, arguments), i);
      }, null, G);
    }, w.translateTo = function($, q, B, G, W) {
      w.transform($, function() {
        var Y = t.apply(this, arguments), z = this.__zoom, L = G == null ? E(Y) : typeof G == "function" ? G.apply(this, arguments) : G;
        return n(Xw.translate(L[0], L[1]).scale(z.k).translate(
          typeof q == "function" ? -q.apply(this, arguments) : -q,
          typeof B == "function" ? -B.apply(this, arguments) : -B
        ), Y, i);
      }, G, W);
    };
    function _($, q) {
      return q = Math.max(a[0], Math.min(a[1], q)), q === $.k ? $ : new Di(q, $.x, $.y);
    }
    function k($, q, B) {
      var G = q[0] - B[0] * $.k, W = q[1] - B[1] * $.k;
      return G === $.x && W === $.y ? $ : new Di($.k, G, W);
    }
    function E($) {
      return [(+$[0][0] + +$[1][0]) / 2, (+$[0][1] + +$[1][1]) / 2];
    }
    function P($, q, B, G) {
      $.on("start.zoom", function() {
        O(this, arguments).event(G).start();
      }).on("interrupt.zoom end.zoom", function() {
        O(this, arguments).event(G).end();
      }).tween("zoom", function() {
        var W = this, Y = arguments, z = O(W, Y).event(G), L = t.apply(W, Y), K = B == null ? E(L) : typeof B == "function" ? B.apply(W, Y) : B, T = Math.max(L[1][0] - L[0][0], L[1][1] - L[0][1]), V = W.__zoom, X = typeof q == "function" ? q.apply(W, Y) : q, Q = u(V.invert(K).concat(T / V.k), X.invert(K).concat(T / X.k));
        return function(ne) {
          if (ne === 1) ne = X;
          else {
            var te = Q(ne), ae = T / te[2];
            ne = new Di(ae, K[0] - te[0] * ae, K[1] - te[1] * ae);
          }
          z.zoom(null, ne);
        };
      });
    }
    function O($, q, B) {
      return !B && $.__zooming || new M($, q);
    }
    function M($, q) {
      this.that = $, this.args = q, this.active = 0, this.sourceEvent = null, this.extent = t.apply($, q), this.taps = 0;
    }
    M.prototype = {
      event: function($) {
        return $ && (this.sourceEvent = $), this;
      },
      start: function() {
        return ++this.active === 1 && (this.that.__zooming = this, this.emit("start")), this;
      },
      zoom: function($, q) {
        return this.mouse && $ !== "mouse" && (this.mouse[1] = q.invert(this.mouse[0])), this.touch0 && $ !== "touch" && (this.touch0[1] = q.invert(this.touch0[0])), this.touch1 && $ !== "touch" && (this.touch1[1] = q.invert(this.touch1[0])), this.that.__zoom = q, this.emit("zoom"), this;
      },
      end: function() {
        return --this.active === 0 && (delete this.that.__zooming, this.emit("end")), this;
      },
      emit: function($) {
        var q = io(this.that).datum();
        c.call(
          $,
          this.that,
          new mge($, {
            sourceEvent: this.sourceEvent,
            target: w,
            transform: this.that.__zoom,
            dispatch: c
          }),
          q
        );
      }
    };
    function I($, ...q) {
      if (!e.apply(this, arguments)) return;
      var B = O(this, q).event($), G = this.__zoom, W = Math.max(a[0], Math.min(a[1], G.k * Math.pow(2, r.apply(this, arguments)))), Y = Ko($);
      if (B.wheel)
        (B.mouse[0][0] !== Y[0] || B.mouse[0][1] !== Y[1]) && (B.mouse[1] = G.invert(B.mouse[0] = Y)), clearTimeout(B.wheel);
      else {
        if (G.k === W) return;
        B.mouse = [Y, G.invert(Y)], By(this), B.start();
      }
      Jf($), B.wheel = setTimeout(z, y), B.zoom("mouse", n(k(_(G, W), B.mouse[0], B.mouse[1]), B.extent, i));
      function z() {
        B.wheel = null, B.end();
      }
    }
    function A($, ...q) {
      if (g || !e.apply(this, arguments)) return;
      var B = $.currentTarget, G = O(this, q, !0).event($), W = io($.view).on("mousemove.zoom", K, !0).on("mouseup.zoom", T, !0), Y = Ko($, B), z = $.clientX, L = $.clientY;
      aB($.view), G_($), G.mouse = [Y, this.__zoom.invert(Y)], By(this), G.start();
      function K(V) {
        if (Jf(V), !G.moved) {
          var X = V.clientX - z, Q = V.clientY - L;
          G.moved = X * X + Q * Q > b;
        }
        G.event(V).zoom("mouse", n(k(G.that.__zoom, G.mouse[0] = Ko(V, B), G.mouse[1]), G.extent, i));
      }
      function T(V) {
        W.on("mousemove.zoom mouseup.zoom", null), iB(V.view, G.moved), Jf(V), G.event(V).end();
      }
    }
    function D($, ...q) {
      if (e.apply(this, arguments)) {
        var B = this.__zoom, G = Ko($.changedTouches ? $.changedTouches[0] : $, this), W = B.invert(G), Y = B.k * ($.shiftKey ? 0.5 : 2), z = n(k(_(B, Y), G, W), t.apply(this, q), i);
        Jf($), s > 0 ? io(this).transition().duration(s).call(P, z, G, $) : io(this).call(w.transform, z, G, $);
      }
    }
    function F($, ...q) {
      if (e.apply(this, arguments)) {
        var B = $.touches, G = B.length, W = O(this, q, $.changedTouches.length === G).event($), Y, z, L, K;
        for (G_($), z = 0; z < G; ++z)
          L = B[z], K = Ko(L, this), K = [K, this.__zoom.invert(K), L.identifier], W.touch0 ? !W.touch1 && W.touch0[2] !== K[2] && (W.touch1 = K, W.taps = 0) : (W.touch0 = K, Y = !0, W.taps = 1 + !!f);
        f && (f = clearTimeout(f)), Y && (W.taps < 2 && (p = K[0], f = setTimeout(function() {
          f = null;
        }, h)), By(this), W.start());
      }
    }
    function j($, ...q) {
      if (this.__zooming) {
        var B = O(this, q).event($), G = $.changedTouches, W = G.length, Y, z, L, K;
        for (Jf($), Y = 0; Y < W; ++Y)
          z = G[Y], L = Ko(z, this), B.touch0 && B.touch0[2] === z.identifier ? B.touch0[0] = L : B.touch1 && B.touch1[2] === z.identifier && (B.touch1[0] = L);
        if (z = B.that.__zoom, B.touch1) {
          var T = B.touch0[0], V = B.touch0[1], X = B.touch1[0], Q = B.touch1[1], ne = (ne = X[0] - T[0]) * ne + (ne = X[1] - T[1]) * ne, te = (te = Q[0] - V[0]) * te + (te = Q[1] - V[1]) * te;
          z = _(z, Math.sqrt(ne / te)), L = [(T[0] + X[0]) / 2, (T[1] + X[1]) / 2], K = [(V[0] + Q[0]) / 2, (V[1] + Q[1]) / 2];
        } else if (B.touch0) L = B.touch0[0], K = B.touch0[1];
        else return;
        B.zoom("touch", n(k(z, L, K), B.extent, i));
      }
    }
    function U($, ...q) {
      if (this.__zooming) {
        var B = O(this, q).event($), G = $.changedTouches, W = G.length, Y, z;
        for (G_($), g && clearTimeout(g), g = setTimeout(function() {
          g = null;
        }, h), Y = 0; Y < W; ++Y)
          z = G[Y], B.touch0 && B.touch0[2] === z.identifier ? delete B.touch0 : B.touch1 && B.touch1[2] === z.identifier && delete B.touch1;
        if (B.touch1 && !B.touch0 && (B.touch0 = B.touch1, delete B.touch1), B.touch0) B.touch0[1] = this.__zoom.invert(B.touch0[0]);
        else if (B.end(), B.taps === 2 && (z = Ko(z, this), Math.hypot(p[0] - z[0], p[1] - z[1]) < v)) {
          var L = io(this).on("dblclick.zoom");
          L && L.apply(this, arguments);
        }
      }
    }
    return w.wheelDelta = function($) {
      return arguments.length ? (r = typeof $ == "function" ? $ : bv(+$), w) : r;
    }, w.filter = function($) {
      return arguments.length ? (e = typeof $ == "function" ? $ : bv(!!$), w) : e;
    }, w.touchable = function($) {
      return arguments.length ? (o = typeof $ == "function" ? $ : bv(!!$), w) : o;
    }, w.extent = function($) {
      return arguments.length ? (t = typeof $ == "function" ? $ : bv([[+$[0][0], +$[0][1]], [+$[1][0], +$[1][1]]]), w) : t;
    }, w.scaleExtent = function($) {
      return arguments.length ? (a[0] = +$[0], a[1] = +$[1], w) : [a[0], a[1]];
    }, w.translateExtent = function($) {
      return arguments.length ? (i[0][0] = +$[0][0], i[1][0] = +$[1][0], i[0][1] = +$[0][1], i[1][1] = +$[1][1], w) : [[i[0][0], i[0][1]], [i[1][0], i[1][1]]];
    }, w.constrain = function($) {
      return arguments.length ? (n = $, w) : n;
    }, w.duration = function($) {
      return arguments.length ? (s = +$, w) : s;
    }, w.interpolate = function($) {
      return arguments.length ? (u = $, w) : u;
    }, w.on = function() {
      var $ = c.on.apply(c, arguments);
      return $ === c ? w : $;
    }, w.clickDistance = function($) {
      return arguments.length ? (b = ($ = +$) * $, w) : Math.sqrt(b);
    }, w.tapDistance = function($) {
      return arguments.length ? (v = +$, w) : v;
    }, w;
  }
  const Ka = {
    error001: () => "[React Flow]: Seems like you have not used zustand provider as an ancestor. Help: https://reactflow.dev/error#001",
    error002: () => "It looks like you've created a new nodeTypes or edgeTypes object. If this wasn't on purpose please define the nodeTypes/edgeTypes outside of the component or memoize them.",
    error003: (e) => `Node type "${e}" not found. Using fallback type "default".`,
    error004: () => "The React Flow parent container needs a width and a height to render the graph.",
    error005: () => "Only child nodes can use a parent extent.",
    error006: () => "Can't create edge. An edge needs a source and a target.",
    error007: (e) => `The old edge with id=${e} does not exist.`,
    error009: (e) => `Marker type "${e}" doesn't exist.`,
    error008: (e, { id: t, sourceHandle: n, targetHandle: r }) => `Couldn't create edge for ${e} handle id: "${e === "source" ? n : r}", edge id: ${t}.`,
    error010: () => "Handle: No node id found. Make sure to only use a Handle inside a custom Node.",
    error011: (e) => `Edge type "${e}" not found. Using fallback type "default".`,
    error012: (e) => `Node with id "${e}" does not exist, it may have been removed. This can happen when a node is deleted before the "onNodeClick" handler is called.`,
    error013: (e = "react") => `It seems that you haven't loaded the styles. Please import '@xyflow/${e}/dist/style.css' or base.css to make sure everything is working properly.`,
    error014: () => "useNodeConnections: No node ID found. Call useNodeConnections inside a custom Node or provide a node ID.",
    error015: () => "It seems that you are trying to drag a node that is not initialized. Please use onNodesChange as explained in the docs."
  }, lm = [
    [Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY],
    [Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY]
  ], _B = ["Enter", " ", "Escape"], EB = {
    "node.a11yDescription.default": "Press enter or space to select a node. Press delete to remove it and escape to cancel.",
    "node.a11yDescription.keyboardDisabled": "Press enter or space to select a node. You can then use the arrow keys to move the node around. Press delete to remove it and escape to cancel.",
    "node.a11yDescription.ariaLiveMessage": ({ direction: e, x: t, y: n }) => `Moved selected node ${e}. New position, x: ${t}, y: ${n}`,
    "edge.a11yDescription.default": "Press enter or space to select an edge. You can then press delete to remove it or escape to cancel.",
    // Control elements
    "controls.ariaLabel": "Control Panel",
    "controls.zoomIn.ariaLabel": "Zoom In",
    "controls.zoomOut.ariaLabel": "Zoom Out",
    "controls.fitView.ariaLabel": "Fit View",
    "controls.interactive.ariaLabel": "Toggle Interactivity",
    // Mini map
    "minimap.ariaLabel": "Mini Map",
    // Handle
    "handle.ariaLabel": "Handle"
  };
  var wd;
  (function(e) {
    e.Strict = "strict", e.Loose = "loose";
  })(wd || (wd = {}));
  var au;
  (function(e) {
    e.Free = "free", e.Vertical = "vertical", e.Horizontal = "horizontal";
  })(au || (au = {}));
  var um;
  (function(e) {
    e.Partial = "partial", e.Full = "full";
  })(um || (um = {}));
  const CB = {
    inProgress: !1,
    isValid: null,
    from: null,
    fromHandle: null,
    fromPosition: null,
    fromNode: null,
    to: null,
    toHandle: null,
    toPosition: null,
    toNode: null,
    pointer: null
  };
  var Ws;
  (function(e) {
    e.Bezier = "default", e.Straight = "straight", e.Step = "step", e.SmoothStep = "smoothstep", e.SimpleBezier = "simplebezier";
  })(Ws || (Ws = {}));
  var Pb;
  (function(e) {
    e.Arrow = "arrow", e.ArrowClosed = "arrowclosed";
  })(Pb || (Pb = {}));
  var Ve;
  (function(e) {
    e.Left = "left", e.Top = "top", e.Right = "right", e.Bottom = "bottom";
  })(Ve || (Ve = {}));
  const A$ = {
    [Ve.Left]: Ve.Right,
    [Ve.Right]: Ve.Left,
    [Ve.Top]: Ve.Bottom,
    [Ve.Bottom]: Ve.Top
  };
  function PB(e) {
    return e === null ? null : e ? "valid" : "invalid";
  }
  const OB = (e) => "id" in e && "source" in e && "target" in e, wge = (e) => "id" in e && "position" in e && !("source" in e) && !("target" in e), gP = (e) => "id" in e && "internals" in e && !("source" in e) && !("target" in e), th = (e, t = [0, 0]) => {
    const { width: n, height: r } = ns(e), o = e.origin ?? t, a = n * o[0], i = r * o[1];
    return {
      x: e.position.x - a,
      y: e.position.y - i
    };
  }, xge = (e, t = { nodeOrigin: [0, 0] }) => {
    if (e.length === 0)
      return { x: 0, y: 0, width: 0, height: 0 };
    const n = e.reduce((r, o) => {
      const a = typeof o == "string";
      let i = !t.nodeLookup && !a ? o : void 0;
      t.nodeLookup && (i = a ? t.nodeLookup.get(o) : gP(o) ? o : t.nodeLookup.get(o.id));
      const s = i ? Ob(i, t.nodeOrigin) : { x: 0, y: 0, x2: 0, y2: 0 };
      return Yw(r, s);
    }, { x: 1 / 0, y: 1 / 0, x2: -1 / 0, y2: -1 / 0 });
    return Jw(n);
  }, nh = (e, t = {}) => {
    let n = { x: 1 / 0, y: 1 / 0, x2: -1 / 0, y2: -1 / 0 }, r = !1;
    return e.forEach((o) => {
      (t.filter === void 0 || t.filter(o)) && (n = Yw(n, Ob(o)), r = !0);
    }), r ? Jw(n) : { x: 0, y: 0, width: 0, height: 0 };
  }, vP = (e, t, [n, r, o] = [0, 0, 1], a = !1, i = !1) => {
    const s = {
      ...oh(t, [n, r, o]),
      width: t.width / o,
      height: t.height / o
    }, u = [];
    for (const c of e.values()) {
      const { measured: f, selectable: p = !0, hidden: g = !1 } = c;
      if (i && !p || g)
        continue;
      const h = f.width ?? c.width ?? c.initialWidth ?? null, y = f.height ?? c.height ?? c.initialHeight ?? null, b = cm(s, kd(c)), v = (h ?? 0) * (y ?? 0), w = a && b > 0;
      (!c.internals.handleBounds || w || b >= v || c.dragging) && u.push(c);
    }
    return u;
  }, kge = (e, t) => {
    const n = /* @__PURE__ */ new Set();
    return e.forEach((r) => {
      n.add(r.id);
    }), t.filter((r) => n.has(r.source) || n.has(r.target));
  };
  function Sge(e, t) {
    const n = /* @__PURE__ */ new Map(), r = t?.nodes ? new Set(t.nodes.map((o) => o.id)) : null;
    return e.forEach((o) => {
      o.measured.width && o.measured.height && (t?.includeHiddenNodes || !o.hidden) && (!r || r.has(o.id)) && n.set(o.id, o);
    }), n;
  }
  async function _ge({ nodes: e, width: t, height: n, panZoom: r, minZoom: o, maxZoom: a }, i) {
    if (e.size === 0)
      return Promise.resolve(!0);
    const s = Sge(e, i), u = nh(s), c = yP(u, t, n, i?.minZoom ?? o, i?.maxZoom ?? a, i?.padding ?? 0.1);
    return await r.setViewport(c, {
      duration: i?.duration,
      ease: i?.ease,
      interpolate: i?.interpolate
    }), Promise.resolve(!0);
  }
  function NB({ nodeId: e, nextPosition: t, nodeLookup: n, nodeOrigin: r = [0, 0], nodeExtent: o, onError: a }) {
    const i = n.get(e), s = i.parentId ? n.get(i.parentId) : void 0, { x: u, y: c } = s ? s.internals.positionAbsolute : { x: 0, y: 0 }, f = i.origin ?? r;
    let p = i.extent || o;
    if (i.extent === "parent" && !i.expandParent)
      if (!s)
        a?.("005", Ka.error005());
      else {
        const h = s.measured.width, y = s.measured.height;
        h && y && (p = [
          [u, c],
          [u + h, c + y]
        ]);
      }
    else s && Sd(i.extent) && (p = [
      [i.extent[0][0] + u, i.extent[0][1] + c],
      [i.extent[1][0] + u, i.extent[1][1] + c]
    ]);
    const g = Sd(p) ? mu(t, p, i.measured) : t;
    return (i.measured.width === void 0 || i.measured.height === void 0) && a?.("015", Ka.error015()), {
      position: {
        x: g.x - u + (i.measured.width ?? 0) * f[0],
        y: g.y - c + (i.measured.height ?? 0) * f[1]
      },
      positionAbsolute: g
    };
  }
  async function Ege({ nodesToRemove: e = [], edgesToRemove: t = [], nodes: n, edges: r, onBeforeDelete: o }) {
    const a = new Set(e.map((p) => p.id)), i = [];
    for (const p of n) {
      if (p.deletable === !1)
        continue;
      const g = a.has(p.id), h = !g && p.parentId && i.find((y) => y.id === p.parentId);
      (g || h) && i.push(p);
    }
    const s = new Set(t.map((p) => p.id)), u = r.filter((p) => p.deletable !== !1), c = kge(i, u);
    for (const p of u)
      s.has(p.id) && !c.find((g) => g.id === p.id) && c.push(p);
    if (!o)
      return {
        edges: c,
        nodes: i
      };
    const f = await o({
      nodes: i,
      edges: c
    });
    return typeof f == "boolean" ? f ? { edges: c, nodes: i } : { edges: [], nodes: [] } : f;
  }
  const xd = (e, t = 0, n = 1) => Math.min(Math.max(e, t), n), mu = (e = { x: 0, y: 0 }, t, n) => ({
    x: xd(e.x, t[0][0], t[1][0] - (n?.width ?? 0)),
    y: xd(e.y, t[0][1], t[1][1] - (n?.height ?? 0))
  });
  function MB(e, t, n) {
    const { width: r, height: o } = ns(n), { x: a, y: i } = n.internals.positionAbsolute;
    return mu(e, [
      [a, i],
      [a + r, i + o]
    ], t);
  }
  const $$ = (e, t, n) => e < t ? xd(Math.abs(e - t), 1, t) / t : e > n ? -xd(Math.abs(e - n), 1, t) / t : 0, RB = (e, t, n = 15, r = 40) => {
    const o = $$(e.x, r, t.width - r) * n, a = $$(e.y, r, t.height - r) * n;
    return [o, a];
  }, Yw = (e, t) => ({
    x: Math.min(e.x, t.x),
    y: Math.min(e.y, t.y),
    x2: Math.max(e.x2, t.x2),
    y2: Math.max(e.y2, t.y2)
  }), X2 = ({ x: e, y: t, width: n, height: r }) => ({
    x: e,
    y: t,
    x2: e + n,
    y2: t + r
  }), Jw = ({ x: e, y: t, x2: n, y2: r }) => ({
    x: e,
    y: t,
    width: n - e,
    height: r - t
  }), kd = (e, t = [0, 0]) => {
    const { x: n, y: r } = gP(e) ? e.internals.positionAbsolute : th(e, t);
    return {
      x: n,
      y: r,
      width: e.measured?.width ?? e.width ?? e.initialWidth ?? 0,
      height: e.measured?.height ?? e.height ?? e.initialHeight ?? 0
    };
  }, Ob = (e, t = [0, 0]) => {
    const { x: n, y: r } = gP(e) ? e.internals.positionAbsolute : th(e, t);
    return {
      x: n,
      y: r,
      x2: n + (e.measured?.width ?? e.width ?? e.initialWidth ?? 0),
      y2: r + (e.measured?.height ?? e.height ?? e.initialHeight ?? 0)
    };
  }, jB = (e, t) => Jw(Yw(X2(e), X2(t))), cm = (e, t) => {
    const n = Math.max(0, Math.min(e.x + e.width, t.x + t.width) - Math.max(e.x, t.x)), r = Math.max(0, Math.min(e.y + e.height, t.y + t.height) - Math.max(e.y, t.y));
    return Math.ceil(n * r);
  }, D$ = (e) => Jo(e.width) && Jo(e.height) && Jo(e.x) && Jo(e.y), Jo = (e) => !isNaN(e) && isFinite(e), Cge = (e, t) => {
  }, rh = (e, t = [1, 1]) => ({
    x: t[0] * Math.round(e.x / t[0]),
    y: t[1] * Math.round(e.y / t[1])
  }), oh = ({ x: e, y: t }, [n, r, o], a = !1, i = [1, 1]) => {
    const s = {
      x: (e - n) / o,
      y: (t - r) / o
    };
    return a ? rh(s, i) : s;
  }, Nb = ({ x: e, y: t }, [n, r, o]) => ({
    x: e * o + n,
    y: t * o + r
  });
  function Mc(e, t) {
    if (typeof e == "number")
      return Math.floor((t - t / (1 + e)) * 0.5);
    if (typeof e == "string" && e.endsWith("px")) {
      const n = parseFloat(e);
      if (!Number.isNaN(n))
        return Math.floor(n);
    }
    if (typeof e == "string" && e.endsWith("%")) {
      const n = parseFloat(e);
      if (!Number.isNaN(n))
        return Math.floor(t * n * 0.01);
    }
    return console.error(`[React Flow] The padding value "${e}" is invalid. Please provide a number or a string with a valid unit (px or %).`), 0;
  }
  function Pge(e, t, n) {
    if (typeof e == "string" || typeof e == "number") {
      const r = Mc(e, n), o = Mc(e, t);
      return {
        top: r,
        right: o,
        bottom: r,
        left: o,
        x: o * 2,
        y: r * 2
      };
    }
    if (typeof e == "object") {
      const r = Mc(e.top ?? e.y ?? 0, n), o = Mc(e.bottom ?? e.y ?? 0, n), a = Mc(e.left ?? e.x ?? 0, t), i = Mc(e.right ?? e.x ?? 0, t);
      return { top: r, right: i, bottom: o, left: a, x: a + i, y: r + o };
    }
    return { top: 0, right: 0, bottom: 0, left: 0, x: 0, y: 0 };
  }
  function Oge(e, t, n, r, o, a) {
    const { x: i, y: s } = Nb(e, [t, n, r]), { x: u, y: c } = Nb({ x: e.x + e.width, y: e.y + e.height }, [t, n, r]), f = o - u, p = a - c;
    return {
      left: Math.floor(i),
      top: Math.floor(s),
      right: Math.floor(f),
      bottom: Math.floor(p)
    };
  }
  const yP = (e, t, n, r, o, a) => {
    const i = Pge(a, t, n), s = (t - i.x) / e.width, u = (n - i.y) / e.height, c = Math.min(s, u), f = xd(c, r, o), p = e.x + e.width / 2, g = e.y + e.height / 2, h = t / 2 - p * f, y = n / 2 - g * f, b = Oge(e, h, y, f, t, n), v = {
      left: Math.min(b.left - i.left, 0),
      top: Math.min(b.top - i.top, 0),
      right: Math.min(b.right - i.right, 0),
      bottom: Math.min(b.bottom - i.bottom, 0)
    };
    return {
      x: h - v.left + v.right,
      y: y - v.top + v.bottom,
      zoom: f
    };
  }, dm = () => typeof navigator < "u" && navigator?.userAgent?.indexOf("Mac") >= 0;
  function Sd(e) {
    return e != null && e !== "parent";
  }
  function ns(e) {
    return {
      width: e.measured?.width ?? e.width ?? e.initialWidth ?? 0,
      height: e.measured?.height ?? e.height ?? e.initialHeight ?? 0
    };
  }
  function IB(e) {
    return (e.measured?.width ?? e.width ?? e.initialWidth) !== void 0 && (e.measured?.height ?? e.height ?? e.initialHeight) !== void 0;
  }
  function AB(e, t = { width: 0, height: 0 }, n, r, o) {
    const a = { ...e }, i = r.get(n);
    if (i) {
      const s = i.origin || o;
      a.x += i.internals.positionAbsolute.x - (t.width ?? 0) * s[0], a.y += i.internals.positionAbsolute.y - (t.height ?? 0) * s[1];
    }
    return a;
  }
  function L$(e, t) {
    if (e.size !== t.size)
      return !1;
    for (const n of e)
      if (!t.has(n))
        return !1;
    return !0;
  }
  function Nge() {
    let e, t;
    return { promise: new Promise((n, r) => {
      e = n, t = r;
    }), resolve: e, reject: t };
  }
  function Mge(e) {
    return { ...EB, ...e || {} };
  }
  function Ap(e, { snapGrid: t = [0, 0], snapToGrid: n = !1, transform: r, containerBounds: o }) {
    const { x: a, y: i } = Qo(e), s = oh({ x: a - (o?.left ?? 0), y: i - (o?.top ?? 0) }, r), { x: u, y: c } = n ? rh(s, t) : s;
    return {
      xSnapped: u,
      ySnapped: c,
      ...s
    };
  }
  const bP = (e) => ({
    width: e.offsetWidth,
    height: e.offsetHeight
  }), $B = (e) => e?.getRootNode?.() || window?.document, Rge = ["INPUT", "SELECT", "TEXTAREA"];
  function DB(e) {
    const t = e.composedPath?.()?.[0] || e.target;
    return t?.nodeType !== 1 ? !1 : Rge.includes(t.nodeName) || t.hasAttribute("contenteditable") || !!t.closest(".nokey");
  }
  const LB = (e) => "clientX" in e, Qo = (e, t) => {
    const n = LB(e), r = n ? e.clientX : e.touches?.[0].clientX, o = n ? e.clientY : e.touches?.[0].clientY;
    return {
      x: r - (t?.left ?? 0),
      y: o - (t?.top ?? 0)
    };
  }, F$ = (e, t, n, r, o) => {
    const a = t.querySelectorAll(`.${e}`);
    return !a || !a.length ? null : Array.from(a).map((i) => {
      const s = i.getBoundingClientRect();
      return {
        id: i.getAttribute("data-handleid"),
        type: e,
        nodeId: o,
        position: i.getAttribute("data-handlepos"),
        x: (s.left - n.left) / r,
        y: (s.top - n.top) / r,
        ...bP(i)
      };
    });
  };
  function FB({ sourceX: e, sourceY: t, targetX: n, targetY: r, sourceControlX: o, sourceControlY: a, targetControlX: i, targetControlY: s }) {
    const u = e * 0.125 + o * 0.375 + i * 0.375 + n * 0.125, c = t * 0.125 + a * 0.375 + s * 0.375 + r * 0.125, f = Math.abs(u - e), p = Math.abs(c - t);
    return [u, c, f, p];
  }
  function wv(e, t) {
    return e >= 0 ? 0.5 * e : t * 25 * Math.sqrt(-e);
  }
  function T$({ pos: e, x1: t, y1: n, x2: r, y2: o, c: a }) {
    switch (e) {
      case Ve.Left:
        return [t - wv(t - r, a), n];
      case Ve.Right:
        return [t + wv(r - t, a), n];
      case Ve.Top:
        return [t, n - wv(n - o, a)];
      case Ve.Bottom:
        return [t, n + wv(o - n, a)];
    }
  }
  function wP({ sourceX: e, sourceY: t, sourcePosition: n = Ve.Bottom, targetX: r, targetY: o, targetPosition: a = Ve.Top, curvature: i = 0.25 }) {
    const [s, u] = T$({
      pos: n,
      x1: e,
      y1: t,
      x2: r,
      y2: o,
      c: i
    }), [c, f] = T$({
      pos: a,
      x1: r,
      y1: o,
      x2: e,
      y2: t,
      c: i
    }), [p, g, h, y] = FB({
      sourceX: e,
      sourceY: t,
      targetX: r,
      targetY: o,
      sourceControlX: s,
      sourceControlY: u,
      targetControlX: c,
      targetControlY: f
    });
    return [
      `M${e},${t} C${s},${u} ${c},${f} ${r},${o}`,
      p,
      g,
      h,
      y
    ];
  }
  function TB({ sourceX: e, sourceY: t, targetX: n, targetY: r }) {
    const o = Math.abs(n - e) / 2, a = n < e ? n + o : n - o, i = Math.abs(r - t) / 2, s = r < t ? r + i : r - i;
    return [a, s, o, i];
  }
  function jge({ sourceNode: e, targetNode: t, selected: n = !1, zIndex: r = 0, elevateOnSelect: o = !1, zIndexMode: a = "basic" }) {
    if (a === "manual")
      return r;
    const i = o && n ? r + 1e3 : r, s = Math.max(e.parentId || o && e.selected ? e.internals.z : 0, t.parentId || o && t.selected ? t.internals.z : 0);
    return i + s;
  }
  function Ige({ sourceNode: e, targetNode: t, width: n, height: r, transform: o }) {
    const a = Yw(Ob(e), Ob(t));
    a.x === a.x2 && (a.x2 += 1), a.y === a.y2 && (a.y2 += 1);
    const i = {
      x: -o[0] / o[2],
      y: -o[1] / o[2],
      width: n / o[2],
      height: r / o[2]
    };
    return cm(i, Jw(a)) > 0;
  }
  const Age = ({ source: e, sourceHandle: t, target: n, targetHandle: r }) => `xy-edge__${e}${t || ""}-${n}${r || ""}`, $ge = (e, t) => t.some((n) => n.source === e.source && n.target === e.target && (n.sourceHandle === e.sourceHandle || !n.sourceHandle && !e.sourceHandle) && (n.targetHandle === e.targetHandle || !n.targetHandle && !e.targetHandle)), Dge = (e, t, n = {}) => {
    if (!e.source || !e.target)
      return t;
    const r = n.getEdgeId || Age;
    let o;
    return OB(e) ? o = { ...e } : o = {
      ...e,
      id: r(e)
    }, $ge(o, t) ? t : (o.sourceHandle === null && delete o.sourceHandle, o.targetHandle === null && delete o.targetHandle, t.concat(o));
  };
  function zB({ sourceX: e, sourceY: t, targetX: n, targetY: r }) {
    const [o, a, i, s] = TB({
      sourceX: e,
      sourceY: t,
      targetX: n,
      targetY: r
    });
    return [`M ${e},${t}L ${n},${r}`, o, a, i, s];
  }
  const z$ = {
    [Ve.Left]: { x: -1, y: 0 },
    [Ve.Right]: { x: 1, y: 0 },
    [Ve.Top]: { x: 0, y: -1 },
    [Ve.Bottom]: { x: 0, y: 1 }
  }, Lge = ({ source: e, sourcePosition: t = Ve.Bottom, target: n }) => t === Ve.Left || t === Ve.Right ? e.x < n.x ? { x: 1, y: 0 } : { x: -1, y: 0 } : e.y < n.y ? { x: 0, y: 1 } : { x: 0, y: -1 }, B$ = (e, t) => Math.sqrt(Math.pow(t.x - e.x, 2) + Math.pow(t.y - e.y, 2));
  function Fge({ source: e, sourcePosition: t = Ve.Bottom, target: n, targetPosition: r = Ve.Top, center: o, offset: a, stepPosition: i }) {
    const s = z$[t], u = z$[r], c = { x: e.x + s.x * a, y: e.y + s.y * a }, f = { x: n.x + u.x * a, y: n.y + u.y * a }, p = Lge({
      source: c,
      sourcePosition: t,
      target: f
    }), g = p.x !== 0 ? "x" : "y", h = p[g];
    let y = [], b, v;
    const w = { x: 0, y: 0 }, _ = { x: 0, y: 0 }, [, , k, E] = TB({
      sourceX: e.x,
      sourceY: e.y,
      targetX: n.x,
      targetY: n.y
    });
    if (s[g] * u[g] === -1) {
      g === "x" ? (b = o.x ?? c.x + (f.x - c.x) * i, v = o.y ?? (c.y + f.y) / 2) : (b = o.x ?? (c.x + f.x) / 2, v = o.y ?? c.y + (f.y - c.y) * i);
      const P = [
        { x: b, y: c.y },
        { x: b, y: f.y }
      ], O = [
        { x: c.x, y: v },
        { x: f.x, y: v }
      ];
      s[g] === h ? y = g === "x" ? P : O : y = g === "x" ? O : P;
    } else {
      const P = [{ x: c.x, y: f.y }], O = [{ x: f.x, y: c.y }];
      if (g === "x" ? y = s.x === h ? O : P : y = s.y === h ? P : O, t === r) {
        const F = Math.abs(e[g] - n[g]);
        if (F <= a) {
          const j = Math.min(a - 1, a - F);
          s[g] === h ? w[g] = (c[g] > e[g] ? -1 : 1) * j : _[g] = (f[g] > n[g] ? -1 : 1) * j;
        }
      }
      if (t !== r) {
        const F = g === "x" ? "y" : "x", j = s[g] === u[F], U = c[F] > f[F], $ = c[F] < f[F];
        (s[g] === 1 && (!j && U || j && $) || s[g] !== 1 && (!j && $ || j && U)) && (y = g === "x" ? P : O);
      }
      const M = { x: c.x + w.x, y: c.y + w.y }, I = { x: f.x + _.x, y: f.y + _.y }, A = Math.max(Math.abs(M.x - y[0].x), Math.abs(I.x - y[0].x)), D = Math.max(Math.abs(M.y - y[0].y), Math.abs(I.y - y[0].y));
      A >= D ? (b = (M.x + I.x) / 2, v = y[0].y) : (b = y[0].x, v = (M.y + I.y) / 2);
    }
    return [[
      e,
      { x: c.x + w.x, y: c.y + w.y },
      ...y,
      { x: f.x + _.x, y: f.y + _.y },
      n
    ], b, v, k, E];
  }
  function Tge(e, t, n, r) {
    const o = Math.min(B$(e, t) / 2, B$(t, n) / 2, r), { x: a, y: i } = t;
    if (e.x === a && a === n.x || e.y === i && i === n.y)
      return `L${a} ${i}`;
    if (e.y === i) {
      const c = e.x < n.x ? -1 : 1, f = e.y < n.y ? 1 : -1;
      return `L ${a + o * c},${i}Q ${a},${i} ${a},${i + o * f}`;
    }
    const s = e.x < n.x ? 1 : -1, u = e.y < n.y ? -1 : 1;
    return `L ${a},${i + o * u}Q ${a},${i} ${a + o * s},${i}`;
  }
  function Y2({ sourceX: e, sourceY: t, sourcePosition: n = Ve.Bottom, targetX: r, targetY: o, targetPosition: a = Ve.Top, borderRadius: i = 5, centerX: s, centerY: u, offset: c = 20, stepPosition: f = 0.5 }) {
    const [p, g, h, y, b] = Fge({
      source: { x: e, y: t },
      sourcePosition: n,
      target: { x: r, y: o },
      targetPosition: a,
      center: { x: s, y: u },
      offset: c,
      stepPosition: f
    });
    return [p.reduce((v, w, _) => {
      let k = "";
      return _ > 0 && _ < p.length - 1 ? k = Tge(p[_ - 1], w, p[_ + 1], i) : k = `${_ === 0 ? "M" : "L"}${w.x} ${w.y}`, v += k, v;
    }, ""), g, h, y, b];
  }
  function V$(e) {
    return e && !!(e.internals.handleBounds || e.handles?.length) && !!(e.measured.width || e.width || e.initialWidth);
  }
  function zge(e) {
    const { sourceNode: t, targetNode: n } = e;
    if (!V$(t) || !V$(n))
      return null;
    const r = t.internals.handleBounds || U$(t.handles), o = n.internals.handleBounds || U$(n.handles), a = H$(r?.source ?? [], e.sourceHandle), i = H$(
      // when connection type is loose we can define all handles as sources and connect source -> source
      e.connectionMode === wd.Strict ? o?.target ?? [] : (o?.target ?? []).concat(o?.source ?? []),
      e.targetHandle
    );
    if (!a || !i)
      return e.onError?.("008", Ka.error008(a ? "target" : "source", {
        id: e.id,
        sourceHandle: e.sourceHandle,
        targetHandle: e.targetHandle
      })), null;
    const s = a?.position || Ve.Bottom, u = i?.position || Ve.Top, c = hu(t, a, s), f = hu(n, i, u);
    return {
      sourceX: c.x,
      sourceY: c.y,
      targetX: f.x,
      targetY: f.y,
      sourcePosition: s,
      targetPosition: u
    };
  }
  function U$(e) {
    if (!e)
      return null;
    const t = [], n = [];
    for (const r of e)
      r.width = r.width ?? 1, r.height = r.height ?? 1, r.type === "source" ? t.push(r) : r.type === "target" && n.push(r);
    return {
      source: t,
      target: n
    };
  }
  function hu(e, t, n = Ve.Left, r = !1) {
    const o = (t?.x ?? 0) + e.internals.positionAbsolute.x, a = (t?.y ?? 0) + e.internals.positionAbsolute.y, { width: i, height: s } = t ?? ns(e);
    if (r)
      return { x: o + i / 2, y: a + s / 2 };
    switch (t?.position ?? n) {
      case Ve.Top:
        return { x: o + i / 2, y: a };
      case Ve.Right:
        return { x: o + i, y: a + s / 2 };
      case Ve.Bottom:
        return { x: o + i / 2, y: a + s };
      case Ve.Left:
        return { x: o, y: a + s / 2 };
    }
  }
  function H$(e, t) {
    return e && (t ? e.find((n) => n.id === t) : e[0]) || null;
  }
  function J2(e, t) {
    return e ? typeof e == "string" ? e : `${t ? `${t}__` : ""}${Object.keys(e).sort().map((n) => `${n}=${e[n]}`).join("&")}` : "";
  }
  function Bge(e, { id: t, defaultColor: n, defaultMarkerStart: r, defaultMarkerEnd: o }) {
    const a = /* @__PURE__ */ new Set();
    return e.reduce((i, s) => ([s.markerStart || r, s.markerEnd || o].forEach((u) => {
      if (u && typeof u == "object") {
        const c = J2(u, t);
        a.has(c) || (i.push({ id: c, color: u.color || n, ...u }), a.add(c));
      }
    }), i), []).sort((i, s) => i.id.localeCompare(s.id));
  }
  const BB = 1e3, Vge = 10, xP = {
    nodeOrigin: [0, 0],
    nodeExtent: lm,
    elevateNodesOnSelect: !0,
    zIndexMode: "basic",
    defaults: {}
  }, Uge = {
    ...xP,
    checkEquality: !0
  };
  function kP(e, t) {
    const n = { ...e };
    for (const r in t)
      t[r] !== void 0 && (n[r] = t[r]);
    return n;
  }
  function Hge(e, t, n) {
    const r = kP(xP, n);
    for (const o of e.values())
      if (o.parentId)
        _P(o, e, t, r);
      else {
        const a = th(o, r.nodeOrigin), i = Sd(o.extent) ? o.extent : r.nodeExtent, s = mu(a, i, ns(o));
        o.internals.positionAbsolute = s;
      }
  }
  function Wge(e, t) {
    if (!e.handles)
      return e.measured ? t?.internals.handleBounds : void 0;
    const n = [], r = [];
    for (const o of e.handles) {
      const a = {
        id: o.id,
        width: o.width ?? 1,
        height: o.height ?? 1,
        nodeId: e.id,
        x: o.x,
        y: o.y,
        position: o.position,
        type: o.type
      };
      o.type === "source" ? n.push(a) : o.type === "target" && r.push(a);
    }
    return {
      source: n,
      target: r
    };
  }
  function SP(e) {
    return e === "manual";
  }
  function Q2(e, t, n, r = {}) {
    const o = kP(Uge, r), a = { i: 0 }, i = new Map(t), s = o?.elevateNodesOnSelect && !SP(o.zIndexMode) ? BB : 0;
    let u = e.length > 0;
    t.clear(), n.clear();
    for (const c of e) {
      let f = i.get(c.id);
      if (o.checkEquality && c === f?.internals.userNode)
        t.set(c.id, f);
      else {
        const p = th(c, o.nodeOrigin), g = Sd(c.extent) ? c.extent : o.nodeExtent, h = mu(p, g, ns(c));
        f = {
          ...o.defaults,
          ...c,
          measured: {
            width: c.measured?.width,
            height: c.measured?.height
          },
          internals: {
            positionAbsolute: h,
            // if user re-initializes the node or removes `measured` for whatever reason, we reset the handleBounds so that the node gets re-measured
            handleBounds: Wge(c, f),
            z: VB(c, s, o.zIndexMode),
            userNode: c
          }
        }, t.set(c.id, f);
      }
      (f.measured === void 0 || f.measured.width === void 0 || f.measured.height === void 0) && !f.hidden && (u = !1), c.parentId && _P(f, t, n, r, a);
    }
    return u;
  }
  function qge(e, t) {
    if (!e.parentId)
      return;
    const n = t.get(e.parentId);
    n ? n.set(e.id, e) : t.set(e.parentId, /* @__PURE__ */ new Map([[e.id, e]]));
  }
  function _P(e, t, n, r, o) {
    const { elevateNodesOnSelect: a, nodeOrigin: i, nodeExtent: s, zIndexMode: u } = kP(xP, r), c = e.parentId, f = t.get(c);
    if (!f) {
      console.warn(`Parent node ${c} not found. Please make sure that parent nodes are in front of their child nodes in the nodes array.`);
      return;
    }
    qge(e, n), o && !f.parentId && f.internals.rootParentIndex === void 0 && u === "auto" && (f.internals.rootParentIndex = ++o.i, f.internals.z = f.internals.z + o.i * Vge), o && f.internals.rootParentIndex !== void 0 && (o.i = f.internals.rootParentIndex);
    const p = a && !SP(u) ? BB : 0, { x: g, y: h, z: y } = Kge(e, f, i, s, p, u), { positionAbsolute: b } = e.internals, v = g !== b.x || h !== b.y;
    (v || y !== e.internals.z) && t.set(e.id, {
      ...e,
      internals: {
        ...e.internals,
        positionAbsolute: v ? { x: g, y: h } : b,
        z: y
      }
    });
  }
  function VB(e, t, n) {
    const r = Jo(e.zIndex) ? e.zIndex : 0;
    return SP(n) ? r : r + (e.selected ? t : 0);
  }
  function Kge(e, t, n, r, o, a) {
    const { x: i, y: s } = t.internals.positionAbsolute, u = ns(e), c = th(e, n), f = Sd(e.extent) ? mu(c, e.extent, u) : c;
    let p = mu({ x: i + f.x, y: s + f.y }, r, u);
    e.extent === "parent" && (p = MB(p, u, t));
    const g = VB(e, o, a), h = t.internals.z ?? 0;
    return {
      x: p.x,
      y: p.y,
      z: h >= g ? h + 1 : g
    };
  }
  function EP(e, t, n, r = [0, 0]) {
    const o = [], a = /* @__PURE__ */ new Map();
    for (const i of e) {
      const s = t.get(i.parentId);
      if (!s)
        continue;
      const u = a.get(i.parentId)?.expandedRect ?? kd(s), c = jB(u, i.rect);
      a.set(i.parentId, { expandedRect: c, parent: s });
    }
    return a.size > 0 && a.forEach(({ expandedRect: i, parent: s }, u) => {
      const c = s.internals.positionAbsolute, f = ns(s), p = s.origin ?? r, g = i.x < c.x ? Math.round(Math.abs(c.x - i.x)) : 0, h = i.y < c.y ? Math.round(Math.abs(c.y - i.y)) : 0, y = Math.max(f.width, Math.round(i.width)), b = Math.max(f.height, Math.round(i.height)), v = (y - f.width) * p[0], w = (b - f.height) * p[1];
      (g > 0 || h > 0 || v || w) && (o.push({
        id: u,
        type: "position",
        position: {
          x: s.position.x - g + v,
          y: s.position.y - h + w
        }
      }), n.get(u)?.forEach((_) => {
        e.some((k) => k.id === _.id) || o.push({
          id: _.id,
          type: "position",
          position: {
            x: _.position.x + g,
            y: _.position.y + h
          }
        });
      })), (f.width < i.width || f.height < i.height || g || h) && o.push({
        id: u,
        type: "dimensions",
        setAttributes: !0,
        dimensions: {
          width: y + (g ? p[0] * g - v : 0),
          height: b + (h ? p[1] * h - w : 0)
        }
      });
    }), o;
  }
  function Gge(e, t, n, r, o, a, i) {
    const s = r?.querySelector(".xyflow__viewport");
    let u = !1;
    if (!s)
      return { changes: [], updatedInternals: u };
    const c = [], f = window.getComputedStyle(s), { m22: p } = new window.DOMMatrixReadOnly(f.transform), g = [];
    for (const h of e.values()) {
      const y = t.get(h.id);
      if (!y)
        continue;
      if (y.hidden) {
        t.set(y.id, {
          ...y,
          internals: {
            ...y.internals,
            handleBounds: void 0
          }
        }), u = !0;
        continue;
      }
      const b = bP(h.nodeElement), v = y.measured.width !== b.width || y.measured.height !== b.height;
      if (b.width && b.height && (v || !y.internals.handleBounds || h.force)) {
        const w = h.nodeElement.getBoundingClientRect(), _ = Sd(y.extent) ? y.extent : a;
        let { positionAbsolute: k } = y.internals;
        y.parentId && y.extent === "parent" ? k = MB(k, b, t.get(y.parentId)) : _ && (k = mu(k, _, b));
        const E = {
          ...y,
          measured: b,
          internals: {
            ...y.internals,
            positionAbsolute: k,
            handleBounds: {
              source: F$("source", h.nodeElement, w, p, y.id),
              target: F$("target", h.nodeElement, w, p, y.id)
            }
          }
        };
        t.set(y.id, E), y.parentId && _P(E, t, n, { nodeOrigin: o, zIndexMode: i }), u = !0, v && (c.push({
          id: y.id,
          type: "dimensions",
          dimensions: b
        }), y.expandParent && y.parentId && g.push({
          id: y.id,
          parentId: y.parentId,
          rect: kd(E, o)
        }));
      }
    }
    if (g.length > 0) {
      const h = EP(g, t, n, o);
      c.push(...h);
    }
    return { changes: c, updatedInternals: u };
  }
  async function Xge({ delta: e, panZoom: t, transform: n, translateExtent: r, width: o, height: a }) {
    if (!t || !e.x && !e.y)
      return Promise.resolve(!1);
    const i = await t.setViewportConstrained({
      x: n[0] + e.x,
      y: n[1] + e.y,
      zoom: n[2]
    }, [
      [0, 0],
      [o, a]
    ], r), s = !!i && (i.x !== n[0] || i.y !== n[1] || i.k !== n[2]);
    return Promise.resolve(s);
  }
  function W$(e, t, n, r, o, a) {
    let i = o;
    const s = r.get(i) || /* @__PURE__ */ new Map();
    r.set(i, s.set(n, t)), i = `${o}-${e}`;
    const u = r.get(i) || /* @__PURE__ */ new Map();
    if (r.set(i, u.set(n, t)), a) {
      i = `${o}-${e}-${a}`;
      const c = r.get(i) || /* @__PURE__ */ new Map();
      r.set(i, c.set(n, t));
    }
  }
  function UB(e, t, n) {
    e.clear(), t.clear();
    for (const r of n) {
      const { source: o, target: a, sourceHandle: i = null, targetHandle: s = null } = r, u = { edgeId: r.id, source: o, target: a, sourceHandle: i, targetHandle: s }, c = `${o}-${i}--${a}-${s}`, f = `${a}-${s}--${o}-${i}`;
      W$("source", u, f, e, o, i), W$("target", u, c, e, a, s), t.set(r.id, r);
    }
  }
  function HB(e, t) {
    if (!e.parentId)
      return !1;
    const n = t.get(e.parentId);
    return n ? n.selected ? !0 : HB(n, t) : !1;
  }
  function q$(e, t, n) {
    let r = e;
    do {
      if (r?.matches?.(t))
        return !0;
      if (r === n)
        return !1;
      r = r?.parentElement;
    } while (r);
    return !1;
  }
  function Yge(e, t, n, r) {
    const o = /* @__PURE__ */ new Map();
    for (const [a, i] of e)
      if ((i.selected || i.id === r) && (!i.parentId || !HB(i, e)) && (i.draggable || t && typeof i.draggable > "u")) {
        const s = e.get(a);
        s && o.set(a, {
          id: a,
          position: s.position || { x: 0, y: 0 },
          distance: {
            x: n.x - s.internals.positionAbsolute.x,
            y: n.y - s.internals.positionAbsolute.y
          },
          extent: s.extent,
          parentId: s.parentId,
          origin: s.origin,
          expandParent: s.expandParent,
          internals: {
            positionAbsolute: s.internals.positionAbsolute || { x: 0, y: 0 }
          },
          measured: {
            width: s.measured.width ?? 0,
            height: s.measured.height ?? 0
          }
        });
      }
    return o;
  }
  function X_({ nodeId: e, dragItems: t, nodeLookup: n, dragging: r = !0 }) {
    const o = [];
    for (const [i, s] of t) {
      const u = n.get(i)?.internals.userNode;
      u && o.push({
        ...u,
        position: s.position,
        dragging: r
      });
    }
    if (!e)
      return [o[0], o];
    const a = n.get(e)?.internals.userNode;
    return [
      a ? {
        ...a,
        position: t.get(e)?.position || a.position,
        dragging: r
      } : o[0],
      o
    ];
  }
  function Jge({ dragItems: e, snapGrid: t, x: n, y: r }) {
    const o = e.values().next().value;
    if (!o)
      return null;
    const a = {
      x: n - o.distance.x,
      y: r - o.distance.y
    }, i = rh(a, t);
    return {
      x: i.x - a.x,
      y: i.y - a.y
    };
  }
  function Qge({ onNodeMouseDown: e, getStoreItems: t, onDragStart: n, onDrag: r, onDragStop: o }) {
    let a = { x: null, y: null }, i = 0, s = /* @__PURE__ */ new Map(), u = !1, c = { x: 0, y: 0 }, f = null, p = !1, g = null, h = !1, y = !1, b = null;
    function v({ noDragClassName: _, handleSelector: k, domNode: E, isSelectable: P, nodeId: O, nodeClickDistance: M = 0 }) {
      g = io(E);
      function I({ x: j, y: U }) {
        const { nodeLookup: $, nodeExtent: q, snapGrid: B, snapToGrid: G, nodeOrigin: W, onNodeDrag: Y, onSelectionDrag: z, onError: L, updateNodePositions: K } = t();
        a = { x: j, y: U };
        let T = !1;
        const V = s.size > 1, X = V && q ? X2(nh(s)) : null, Q = V && G ? Jge({
          dragItems: s,
          snapGrid: B,
          x: j,
          y: U
        }) : null;
        for (const [ne, te] of s) {
          if (!$.has(ne))
            continue;
          let ae = { x: j - te.distance.x, y: U - te.distance.y };
          G && (ae = Q ? {
            x: Math.round(ae.x + Q.x),
            y: Math.round(ae.y + Q.y)
          } : rh(ae, B));
          let ce = null;
          if (V && q && !te.extent && X) {
            const { positionAbsolute: oe } = te.internals, le = oe.x - X.x + q[0][0], be = oe.x + te.measured.width - X.x2 + q[1][0], ke = oe.y - X.y + q[0][1], De = oe.y + te.measured.height - X.y2 + q[1][1];
            ce = [
              [le, ke],
              [be, De]
            ];
          }
          const { position: Z, positionAbsolute: ee } = NB({
            nodeId: ne,
            nextPosition: ae,
            nodeLookup: $,
            nodeExtent: ce || q,
            nodeOrigin: W,
            onError: L
          });
          T = T || te.position.x !== Z.x || te.position.y !== Z.y, te.position = Z, te.internals.positionAbsolute = ee;
        }
        if (y = y || T, !!T && (K(s, !0), b && (r || Y || !O && z))) {
          const [ne, te] = X_({
            nodeId: O,
            dragItems: s,
            nodeLookup: $
          });
          r?.(b, s, ne, te), Y?.(b, ne, te), O || z?.(b, te);
        }
      }
      async function A() {
        if (!f)
          return;
        const { transform: j, panBy: U, autoPanSpeed: $, autoPanOnNodeDrag: q } = t();
        if (!q) {
          u = !1, cancelAnimationFrame(i);
          return;
        }
        const [B, G] = RB(c, f, $);
        (B !== 0 || G !== 0) && (a.x = (a.x ?? 0) - B / j[2], a.y = (a.y ?? 0) - G / j[2], await U({ x: B, y: G }) && I(a)), i = requestAnimationFrame(A);
      }
      function D(j) {
        const { nodeLookup: U, multiSelectionActive: $, nodesDraggable: q, transform: B, snapGrid: G, snapToGrid: W, selectNodesOnDrag: Y, onNodeDragStart: z, onSelectionDragStart: L, unselectNodesAndEdges: K } = t();
        p = !0, (!Y || !P) && !$ && O && (U.get(O)?.selected || K()), P && Y && O && e?.(O);
        const T = Ap(j.sourceEvent, { transform: B, snapGrid: G, snapToGrid: W, containerBounds: f });
        if (a = T, s = Yge(U, q, T, O), s.size > 0 && (n || z || !O && L)) {
          const [V, X] = X_({
            nodeId: O,
            dragItems: s,
            nodeLookup: U
          });
          n?.(j.sourceEvent, s, V, X), z?.(j.sourceEvent, V, X), O || L?.(j.sourceEvent, X);
        }
      }
      const F = sB().clickDistance(M).on("start", (j) => {
        const { domNode: U, nodeDragThreshold: $, transform: q, snapGrid: B, snapToGrid: G } = t();
        f = U?.getBoundingClientRect() || null, h = !1, y = !1, b = j.sourceEvent, $ === 0 && D(j), a = Ap(j.sourceEvent, { transform: q, snapGrid: B, snapToGrid: G, containerBounds: f }), c = Qo(j.sourceEvent, f);
      }).on("drag", (j) => {
        const { autoPanOnNodeDrag: U, transform: $, snapGrid: q, snapToGrid: B, nodeDragThreshold: G, nodeLookup: W } = t(), Y = Ap(j.sourceEvent, { transform: $, snapGrid: q, snapToGrid: B, containerBounds: f });
        if (b = j.sourceEvent, (j.sourceEvent.type === "touchmove" && j.sourceEvent.touches.length > 1 || // if user deletes a node while dragging, we need to abort the drag to prevent errors
        O && !W.has(O)) && (h = !0), !h) {
          if (!u && U && p && (u = !0, A()), !p) {
            const z = Qo(j.sourceEvent, f), L = z.x - c.x, K = z.y - c.y;
            Math.sqrt(L * L + K * K) > G && D(j);
          }
          (a.x !== Y.xSnapped || a.y !== Y.ySnapped) && s && p && (c = Qo(j.sourceEvent, f), I(Y));
        }
      }).on("end", (j) => {
        if (!(!p || h) && (u = !1, p = !1, cancelAnimationFrame(i), s.size > 0)) {
          const { nodeLookup: U, updateNodePositions: $, onNodeDragStop: q, onSelectionDragStop: B } = t();
          if (y && ($(s, !1), y = !1), o || q || !O && B) {
            const [G, W] = X_({
              nodeId: O,
              dragItems: s,
              nodeLookup: U,
              dragging: !1
            });
            o?.(j.sourceEvent, s, G, W), q?.(j.sourceEvent, G, W), O || B?.(j.sourceEvent, W);
          }
        }
      }).filter((j) => {
        const U = j.target;
        return !j.button && (!_ || !q$(U, `.${_}`, E)) && (!k || q$(U, k, E));
      });
      g.call(F);
    }
    function w() {
      g?.on(".drag", null);
    }
    return {
      update: v,
      destroy: w
    };
  }
  function Zge(e, t, n) {
    const r = [], o = {
      x: e.x - n,
      y: e.y - n,
      width: n * 2,
      height: n * 2
    };
    for (const a of t.values())
      cm(o, kd(a)) > 0 && r.push(a);
    return r;
  }
  const eve = 250;
  function tve(e, t, n, r) {
    let o = [], a = 1 / 0;
    const i = Zge(e, n, t + eve);
    for (const s of i) {
      const u = [...s.internals.handleBounds?.source ?? [], ...s.internals.handleBounds?.target ?? []];
      for (const c of u) {
        if (r.nodeId === c.nodeId && r.type === c.type && r.id === c.id)
          continue;
        const { x: f, y: p } = hu(s, c, c.position, !0), g = Math.sqrt(Math.pow(f - e.x, 2) + Math.pow(p - e.y, 2));
        g > t || (g < a ? (o = [{ ...c, x: f, y: p }], a = g) : g === a && o.push({ ...c, x: f, y: p }));
      }
    }
    if (!o.length)
      return null;
    if (o.length > 1) {
      const s = r.type === "source" ? "target" : "source";
      return o.find((u) => u.type === s) ?? o[0];
    }
    return o[0];
  }
  function WB(e, t, n, r, o, a = !1) {
    const i = r.get(e);
    if (!i)
      return null;
    const s = o === "strict" ? i.internals.handleBounds?.[t] : [...i.internals.handleBounds?.source ?? [], ...i.internals.handleBounds?.target ?? []], u = (n ? s?.find((c) => c.id === n) : s?.[0]) ?? null;
    return u && a ? { ...u, ...hu(i, u, u.position, !0) } : u;
  }
  function qB(e, t) {
    return e || (t?.classList.contains("target") ? "target" : t?.classList.contains("source") ? "source" : null);
  }
  function nve(e, t) {
    let n = null;
    return t ? n = !0 : e && !t && (n = !1), n;
  }
  const KB = () => !0;
  function rve(e, { connectionMode: t, connectionRadius: n, handleId: r, nodeId: o, edgeUpdaterType: a, isTarget: i, domNode: s, nodeLookup: u, lib: c, autoPanOnConnect: f, flowId: p, panBy: g, cancelConnection: h, onConnectStart: y, onConnect: b, onConnectEnd: v, isValidConnection: w = KB, onReconnectEnd: _, updateConnection: k, getTransform: E, getFromHandle: P, autoPanSpeed: O, dragThreshold: M = 1, handleDomNode: I }) {
    const A = $B(e.target);
    let D = 0, F;
    const { x: j, y: U } = Qo(e), $ = qB(a, I), q = s?.getBoundingClientRect();
    let B = !1;
    if (!q || !$)
      return;
    const G = WB(o, $, r, u, t);
    if (!G)
      return;
    let W = Qo(e, q), Y = !1, z = null, L = !1, K = null;
    function T() {
      if (!f || !q)
        return;
      const [ce, Z] = RB(W, q, O);
      g({ x: ce, y: Z }), D = requestAnimationFrame(T);
    }
    const V = {
      ...G,
      nodeId: o,
      type: $,
      position: G.position
    }, X = u.get(o);
    let Q = {
      inProgress: !0,
      isValid: null,
      from: hu(X, V, Ve.Left, !0),
      fromHandle: V,
      fromPosition: V.position,
      fromNode: X,
      to: W,
      toHandle: null,
      toPosition: A$[V.position],
      toNode: null,
      pointer: W
    };
    function ne() {
      B = !0, k(Q), y?.(e, { nodeId: o, handleId: r, handleType: $ });
    }
    M === 0 && ne();
    function te(ce) {
      if (!B) {
        const { x: ke, y: De } = Qo(ce), ze = ke - j, Ue = De - U;
        if (!(ze * ze + Ue * Ue > M * M))
          return;
        ne();
      }
      if (!P() || !V) {
        ae(ce);
        return;
      }
      const Z = E();
      W = Qo(ce, q), F = tve(oh(W, Z, !1, [1, 1]), n, u, V), Y || (T(), Y = !0);
      const ee = GB(ce, {
        handle: F,
        connectionMode: t,
        fromNodeId: o,
        fromHandleId: r,
        fromType: i ? "target" : "source",
        isValidConnection: w,
        doc: A,
        lib: c,
        flowId: p,
        nodeLookup: u
      });
      K = ee.handleDomNode, z = ee.connection, L = nve(!!F, ee.isValid);
      const oe = u.get(o), le = oe ? hu(oe, V, Ve.Left, !0) : Q.from, be = {
        ...Q,
        from: le,
        isValid: L,
        to: ee.toHandle && L ? Nb({ x: ee.toHandle.x, y: ee.toHandle.y }, Z) : W,
        toHandle: ee.toHandle,
        toPosition: L && ee.toHandle ? ee.toHandle.position : A$[V.position],
        toNode: ee.toHandle ? u.get(ee.toHandle.nodeId) : null,
        pointer: W
      };
      k(be), Q = be;
    }
    function ae(ce) {
      if (!("touches" in ce && ce.touches.length > 0)) {
        if (B) {
          (F || K) && z && L && b?.(z);
          const { inProgress: Z, ...ee } = Q, oe = {
            ...ee,
            toPosition: Q.toHandle ? Q.toPosition : null
          };
          v?.(ce, oe), a && _?.(ce, oe);
        }
        h(), cancelAnimationFrame(D), Y = !1, L = !1, z = null, K = null, A.removeEventListener("mousemove", te), A.removeEventListener("mouseup", ae), A.removeEventListener("touchmove", te), A.removeEventListener("touchend", ae);
      }
    }
    A.addEventListener("mousemove", te), A.addEventListener("mouseup", ae), A.addEventListener("touchmove", te), A.addEventListener("touchend", ae);
  }
  function GB(e, { handle: t, connectionMode: n, fromNodeId: r, fromHandleId: o, fromType: a, doc: i, lib: s, flowId: u, isValidConnection: c = KB, nodeLookup: f }) {
    const p = a === "target", g = t ? i.querySelector(`.${s}-flow__handle[data-id="${u}-${t?.nodeId}-${t?.id}-${t?.type}"]`) : null, { x: h, y } = Qo(e), b = i.elementFromPoint(h, y), v = b?.classList.contains(`${s}-flow__handle`) ? b : g, w = {
      handleDomNode: v,
      isValid: !1,
      connection: null,
      toHandle: null
    };
    if (v) {
      const _ = qB(void 0, v), k = v.getAttribute("data-nodeid"), E = v.getAttribute("data-handleid"), P = v.classList.contains("connectable"), O = v.classList.contains("connectableend");
      if (!k || !_)
        return w;
      const M = {
        source: p ? k : r,
        sourceHandle: p ? E : o,
        target: p ? r : k,
        targetHandle: p ? o : E
      };
      w.connection = M;
      const I = P && O && (n === wd.Strict ? p && _ === "source" || !p && _ === "target" : k !== r || E !== o);
      w.isValid = I && c(M), w.toHandle = WB(k, _, E, f, n, !0);
    }
    return w;
  }
  const Z2 = {
    onPointerDown: rve,
    isValid: GB
  };
  function ove({ domNode: e, panZoom: t, getTransform: n, getViewScale: r }) {
    const o = io(e);
    function a({ translateExtent: s, width: u, height: c, zoomStep: f = 1, pannable: p = !0, zoomable: g = !0, inversePan: h = !1 }) {
      const y = (k) => {
        if (k.sourceEvent.type !== "wheel" || !t)
          return;
        const E = n(), P = k.sourceEvent.ctrlKey && dm() ? 10 : 1, O = -k.sourceEvent.deltaY * (k.sourceEvent.deltaMode === 1 ? 0.05 : k.sourceEvent.deltaMode ? 1 : 2e-3) * f, M = E[2] * Math.pow(2, O * P);
        t.scaleTo(M);
      };
      let b = [0, 0];
      const v = (k) => {
        (k.sourceEvent.type === "mousedown" || k.sourceEvent.type === "touchstart") && (b = [
          k.sourceEvent.clientX ?? k.sourceEvent.touches[0].clientX,
          k.sourceEvent.clientY ?? k.sourceEvent.touches[0].clientY
        ]);
      }, w = (k) => {
        const E = n();
        if (k.sourceEvent.type !== "mousemove" && k.sourceEvent.type !== "touchmove" || !t)
          return;
        const P = [
          k.sourceEvent.clientX ?? k.sourceEvent.touches[0].clientX,
          k.sourceEvent.clientY ?? k.sourceEvent.touches[0].clientY
        ], O = [P[0] - b[0], P[1] - b[1]];
        b = P;
        const M = r() * Math.max(E[2], Math.log(E[2])) * (h ? -1 : 1), I = {
          x: E[0] - O[0] * M,
          y: E[1] - O[1] * M
        }, A = [
          [0, 0],
          [u, c]
        ];
        t.setViewportConstrained({
          x: I.x,
          y: I.y,
          zoom: E[2]
        }, A, s);
      }, _ = SB().on("start", v).on("zoom", p ? w : null).on("zoom.wheel", g ? y : null);
      o.call(_, {});
    }
    function i() {
      o.on("zoom", null);
    }
    return {
      update: a,
      destroy: i,
      pointer: Ko
    };
  }
  const Qw = (e) => ({
    x: e.x,
    y: e.y,
    zoom: e.k
  }), Y_ = ({ x: e, y: t, zoom: n }) => Xw.translate(e, t).scale(n), Kc = (e, t) => e.target.closest(`.${t}`), XB = (e, t) => t === 2 && Array.isArray(e) && e.includes(2), ave = (e) => ((e *= 2) <= 1 ? e * e * e : (e -= 2) * e * e + 2) / 2, J_ = (e, t = 0, n = ave, r = () => {
  }) => {
    const o = typeof t == "number" && t > 0;
    return o || r(), o ? e.transition().duration(t).ease(n).on("end", r) : e;
  }, YB = (e) => {
    const t = e.ctrlKey && dm() ? 10 : 1;
    return -e.deltaY * (e.deltaMode === 1 ? 0.05 : e.deltaMode ? 1 : 2e-3) * t;
  };
  function ive({ zoomPanValues: e, noWheelClassName: t, d3Selection: n, d3Zoom: r, panOnScrollMode: o, panOnScrollSpeed: a, zoomOnPinch: i, onPanZoomStart: s, onPanZoom: u, onPanZoomEnd: c }) {
    return (f) => {
      if (Kc(f, t))
        return f.ctrlKey && f.preventDefault(), !1;
      f.preventDefault(), f.stopImmediatePropagation();
      const p = n.property("__zoom").k || 1;
      if (f.ctrlKey && i) {
        const v = Ko(f), w = YB(f), _ = p * Math.pow(2, w);
        r.scaleTo(n, _, v, f);
        return;
      }
      const g = f.deltaMode === 1 ? 20 : 1;
      let h = o === au.Vertical ? 0 : f.deltaX * g, y = o === au.Horizontal ? 0 : f.deltaY * g;
      !dm() && f.shiftKey && o !== au.Vertical && (h = f.deltaY * g, y = 0), r.translateBy(
        n,
        -(h / p) * a,
        -(y / p) * a,
        // @ts-ignore
        { internal: !0 }
      );
      const b = Qw(n.property("__zoom"));
      clearTimeout(e.panScrollTimeout), e.isPanScrolling ? (u?.(f, b), e.panScrollTimeout = setTimeout(() => {
        c?.(f, b), e.isPanScrolling = !1;
      }, 150)) : (e.isPanScrolling = !0, s?.(f, b));
    };
  }
  function sve({ noWheelClassName: e, preventScrolling: t, d3ZoomHandler: n }) {
    return function(r, o) {
      const a = r.type === "wheel", i = !t && a && !r.ctrlKey, s = Kc(r, e);
      if (r.ctrlKey && a && s && r.preventDefault(), i || s)
        return null;
      r.preventDefault(), n.call(this, r, o);
    };
  }
  function lve({ zoomPanValues: e, onDraggingChange: t, onPanZoomStart: n }) {
    return (r) => {
      if (r.sourceEvent?.internal)
        return;
      const o = Qw(r.transform);
      e.mouseButton = r.sourceEvent?.button || 0, e.isZoomingOrPanning = !0, e.prevViewport = o, r.sourceEvent?.type === "mousedown" && t(!0), n && n?.(r.sourceEvent, o);
    };
  }
  function uve({ zoomPanValues: e, panOnDrag: t, onPaneContextMenu: n, onTransformChange: r, onPanZoom: o }) {
    return (a) => {
      e.usedRightMouseButton = !!(n && XB(t, e.mouseButton ?? 0)), a.sourceEvent?.sync || r([a.transform.x, a.transform.y, a.transform.k]), o && !a.sourceEvent?.internal && o?.(a.sourceEvent, Qw(a.transform));
    };
  }
  function cve({ zoomPanValues: e, panOnDrag: t, panOnScroll: n, onDraggingChange: r, onPanZoomEnd: o, onPaneContextMenu: a }) {
    return (i) => {
      if (!i.sourceEvent?.internal && (e.isZoomingOrPanning = !1, a && XB(t, e.mouseButton ?? 0) && !e.usedRightMouseButton && i.sourceEvent && a(i.sourceEvent), e.usedRightMouseButton = !1, r(!1), o)) {
        const s = Qw(i.transform);
        e.prevViewport = s, clearTimeout(e.timerId), e.timerId = setTimeout(
          () => {
            o?.(i.sourceEvent, s);
          },
          // we need a setTimeout for panOnScroll to supress multiple end events fired during scroll
          n ? 150 : 0
        );
      }
    };
  }
  function dve({ zoomActivationKeyPressed: e, zoomOnScroll: t, zoomOnPinch: n, panOnDrag: r, panOnScroll: o, zoomOnDoubleClick: a, userSelectionActive: i, noWheelClassName: s, noPanClassName: u, lib: c, connectionInProgress: f }) {
    return (p) => {
      const g = e || t, h = n && p.ctrlKey, y = p.type === "wheel";
      if (p.button === 1 && p.type === "mousedown" && (Kc(p, `${c}-flow__node`) || Kc(p, `${c}-flow__edge`)))
        return !0;
      if (!r && !g && !o && !a && !n || i || f && !y || Kc(p, s) && y || Kc(p, u) && (!y || o && y && !e) || !n && p.ctrlKey && y)
        return !1;
      if (!n && p.type === "touchstart" && p.touches?.length > 1)
        return p.preventDefault(), !1;
      if (!g && !o && !h && y || !r && (p.type === "mousedown" || p.type === "touchstart") || Array.isArray(r) && !r.includes(p.button) && p.type === "mousedown")
        return !1;
      const b = Array.isArray(r) && r.includes(p.button) || !p.button || p.button <= 1;
      return (!p.ctrlKey || y) && b;
    };
  }
  function fve({ domNode: e, minZoom: t, maxZoom: n, translateExtent: r, viewport: o, onPanZoom: a, onPanZoomStart: i, onPanZoomEnd: s, onDraggingChange: u }) {
    const c = {
      isZoomingOrPanning: !1,
      usedRightMouseButton: !1,
      prevViewport: {},
      mouseButton: 0,
      timerId: void 0,
      panScrollTimeout: void 0,
      isPanScrolling: !1
    }, f = e.getBoundingClientRect(), p = SB().scaleExtent([t, n]).translateExtent(r), g = io(e).call(p);
    _({
      x: o.x,
      y: o.y,
      zoom: xd(o.zoom, t, n)
    }, [
      [0, 0],
      [f.width, f.height]
    ], r);
    const h = g.on("wheel.zoom"), y = g.on("dblclick.zoom");
    p.wheelDelta(YB);
    function b(F, j) {
      return g ? new Promise((U) => {
        p?.interpolate(j?.interpolate === "linear" ? Ip : Fy).transform(J_(g, j?.duration, j?.ease, () => U(!0)), F);
      }) : Promise.resolve(!1);
    }
    function v({ noWheelClassName: F, noPanClassName: j, onPaneContextMenu: U, userSelectionActive: $, panOnScroll: q, panOnDrag: B, panOnScrollMode: G, panOnScrollSpeed: W, preventScrolling: Y, zoomOnPinch: z, zoomOnScroll: L, zoomOnDoubleClick: K, zoomActivationKeyPressed: T, lib: V, onTransformChange: X, connectionInProgress: Q, paneClickDistance: ne, selectionOnDrag: te }) {
      $ && !c.isZoomingOrPanning && w();
      const ae = q && !T && !$;
      p.clickDistance(te ? 1 / 0 : !Jo(ne) || ne < 0 ? 0 : ne);
      const ce = ae ? ive({
        zoomPanValues: c,
        noWheelClassName: F,
        d3Selection: g,
        d3Zoom: p,
        panOnScrollMode: G,
        panOnScrollSpeed: W,
        zoomOnPinch: z,
        onPanZoomStart: i,
        onPanZoom: a,
        onPanZoomEnd: s
      }) : sve({
        noWheelClassName: F,
        preventScrolling: Y,
        d3ZoomHandler: h
      });
      if (g.on("wheel.zoom", ce, { passive: !1 }), !$) {
        const ee = lve({
          zoomPanValues: c,
          onDraggingChange: u,
          onPanZoomStart: i
        });
        p.on("start", ee);
        const oe = uve({
          zoomPanValues: c,
          panOnDrag: B,
          onPaneContextMenu: !!U,
          onPanZoom: a,
          onTransformChange: X
        });
        p.on("zoom", oe);
        const le = cve({
          zoomPanValues: c,
          panOnDrag: B,
          panOnScroll: q,
          onPaneContextMenu: U,
          onPanZoomEnd: s,
          onDraggingChange: u
        });
        p.on("end", le);
      }
      const Z = dve({
        zoomActivationKeyPressed: T,
        panOnDrag: B,
        zoomOnScroll: L,
        panOnScroll: q,
        zoomOnDoubleClick: K,
        zoomOnPinch: z,
        userSelectionActive: $,
        noPanClassName: j,
        noWheelClassName: F,
        lib: V,
        connectionInProgress: Q
      });
      p.filter(Z), K ? g.on("dblclick.zoom", y) : g.on("dblclick.zoom", null);
    }
    function w() {
      p.on("zoom", null);
    }
    async function _(F, j, U) {
      const $ = Y_(F), q = p?.constrain()($, j, U);
      return q && await b(q), new Promise((B) => B(q));
    }
    async function k(F, j) {
      const U = Y_(F);
      return await b(U, j), new Promise(($) => $(U));
    }
    function E(F) {
      if (g) {
        const j = Y_(F), U = g.property("__zoom");
        (U.k !== F.zoom || U.x !== F.x || U.y !== F.y) && p?.transform(g, j, null, { sync: !0 });
      }
    }
    function P() {
      const F = g ? kB(g.node()) : { x: 0, y: 0, k: 1 };
      return { x: F.x, y: F.y, zoom: F.k };
    }
    function O(F, j) {
      return g ? new Promise((U) => {
        p?.interpolate(j?.interpolate === "linear" ? Ip : Fy).scaleTo(J_(g, j?.duration, j?.ease, () => U(!0)), F);
      }) : Promise.resolve(!1);
    }
    function M(F, j) {
      return g ? new Promise((U) => {
        p?.interpolate(j?.interpolate === "linear" ? Ip : Fy).scaleBy(J_(g, j?.duration, j?.ease, () => U(!0)), F);
      }) : Promise.resolve(!1);
    }
    function I(F) {
      p?.scaleExtent(F);
    }
    function A(F) {
      p?.translateExtent(F);
    }
    function D(F) {
      const j = !Jo(F) || F < 0 ? 0 : F;
      p?.clickDistance(j);
    }
    return {
      update: v,
      destroy: w,
      setViewport: k,
      setViewportConstrained: _,
      getViewport: P,
      scaleTo: O,
      scaleBy: M,
      setScaleExtent: I,
      setTranslateExtent: A,
      syncViewport: E,
      setClickDistance: D
    };
  }
  var _d;
  (function(e) {
    e.Line = "line", e.Handle = "handle";
  })(_d || (_d = {}));
  function pve({ width: e, prevWidth: t, height: n, prevHeight: r, affectsX: o, affectsY: a }) {
    const i = e - t, s = n - r, u = [i > 0 ? 1 : i < 0 ? -1 : 0, s > 0 ? 1 : s < 0 ? -1 : 0];
    return i && o && (u[0] = u[0] * -1), s && a && (u[1] = u[1] * -1), u;
  }
  function K$(e) {
    const t = e.includes("right") || e.includes("left"), n = e.includes("bottom") || e.includes("top"), r = e.includes("left"), o = e.includes("top");
    return {
      isHorizontal: t,
      isVertical: n,
      affectsX: r,
      affectsY: o
    };
  }
  function Ds(e, t) {
    return Math.max(0, t - e);
  }
  function Ls(e, t) {
    return Math.max(0, e - t);
  }
  function xv(e, t, n) {
    return Math.max(0, t - e, e - n);
  }
  function G$(e, t) {
    return e ? !t : t;
  }
  function mve(e, t, n, r, o, a, i, s) {
    let { affectsX: u, affectsY: c } = t;
    const { isHorizontal: f, isVertical: p } = t, g = f && p, { xSnapped: h, ySnapped: y } = n, { minWidth: b, maxWidth: v, minHeight: w, maxHeight: _ } = r, { x: k, y: E, width: P, height: O, aspectRatio: M } = e;
    let I = Math.floor(f ? h - e.pointerX : 0), A = Math.floor(p ? y - e.pointerY : 0);
    const D = P + (u ? -I : I), F = O + (c ? -A : A), j = -a[0] * P, U = -a[1] * O;
    let $ = xv(D, b, v), q = xv(F, w, _);
    if (i) {
      let W = 0, Y = 0;
      u && I < 0 ? W = Ds(k + I + j, i[0][0]) : !u && I > 0 && (W = Ls(k + D + j, i[1][0])), c && A < 0 ? Y = Ds(E + A + U, i[0][1]) : !c && A > 0 && (Y = Ls(E + F + U, i[1][1])), $ = Math.max($, W), q = Math.max(q, Y);
    }
    if (s) {
      let W = 0, Y = 0;
      u && I > 0 ? W = Ls(k + I, s[0][0]) : !u && I < 0 && (W = Ds(k + D, s[1][0])), c && A > 0 ? Y = Ls(E + A, s[0][1]) : !c && A < 0 && (Y = Ds(E + F, s[1][1])), $ = Math.max($, W), q = Math.max(q, Y);
    }
    if (o) {
      if (f) {
        const W = xv(D / M, w, _) * M;
        if ($ = Math.max($, W), i) {
          let Y = 0;
          !u && !c || u && !c && g ? Y = Ls(E + U + D / M, i[1][1]) * M : Y = Ds(E + U + (u ? I : -I) / M, i[0][1]) * M, $ = Math.max($, Y);
        }
        if (s) {
          let Y = 0;
          !u && !c || u && !c && g ? Y = Ds(E + D / M, s[1][1]) * M : Y = Ls(E + (u ? I : -I) / M, s[0][1]) * M, $ = Math.max($, Y);
        }
      }
      if (p) {
        const W = xv(F * M, b, v) / M;
        if (q = Math.max(q, W), i) {
          let Y = 0;
          !u && !c || c && !u && g ? Y = Ls(k + F * M + j, i[1][0]) / M : Y = Ds(k + (c ? A : -A) * M + j, i[0][0]) / M, q = Math.max(q, Y);
        }
        if (s) {
          let Y = 0;
          !u && !c || c && !u && g ? Y = Ds(k + F * M, s[1][0]) / M : Y = Ls(k + (c ? A : -A) * M, s[0][0]) / M, q = Math.max(q, Y);
        }
      }
    }
    A = A + (A < 0 ? q : -q), I = I + (I < 0 ? $ : -$), o && (g ? D > F * M ? A = (G$(u, c) ? -I : I) / M : I = (G$(u, c) ? -A : A) * M : f ? (A = I / M, c = u) : (I = A * M, u = c));
    const B = u ? k + I : k, G = c ? E + A : E;
    return {
      width: P + (u ? -I : I),
      height: O + (c ? -A : A),
      x: a[0] * I * (u ? -1 : 1) + B,
      y: a[1] * A * (c ? -1 : 1) + G
    };
  }
  const JB = { width: 0, height: 0, x: 0, y: 0 }, hve = {
    ...JB,
    pointerX: 0,
    pointerY: 0,
    aspectRatio: 1
  };
  function gve(e) {
    return [
      [0, 0],
      [e.measured.width, e.measured.height]
    ];
  }
  function vve(e, t, n) {
    const r = t.position.x + e.position.x, o = t.position.y + e.position.y, a = e.measured.width ?? 0, i = e.measured.height ?? 0, s = n[0] * a, u = n[1] * i;
    return [
      [r - s, o - u],
      [r + a - s, o + i - u]
    ];
  }
  function yve({ domNode: e, nodeId: t, getStoreItems: n, onChange: r, onEnd: o }) {
    const a = io(e);
    let i = {
      controlDirection: K$("bottom-right"),
      boundaries: {
        minWidth: 0,
        minHeight: 0,
        maxWidth: Number.MAX_VALUE,
        maxHeight: Number.MAX_VALUE
      },
      resizeDirection: void 0,
      keepAspectRatio: !1
    };
    function s({ controlPosition: c, boundaries: f, keepAspectRatio: p, resizeDirection: g, onResizeStart: h, onResize: y, onResizeEnd: b, shouldResize: v }) {
      let w = { ...JB }, _ = { ...hve };
      i = {
        boundaries: f,
        resizeDirection: g,
        keepAspectRatio: p,
        controlDirection: K$(c)
      };
      let k, E = null, P = [], O, M, I, A = !1;
      const D = sB().on("start", (F) => {
        const { nodeLookup: j, transform: U, snapGrid: $, snapToGrid: q, nodeOrigin: B, paneDomNode: G } = n();
        if (k = j.get(t), !k)
          return;
        E = G?.getBoundingClientRect() ?? null;
        const { xSnapped: W, ySnapped: Y } = Ap(F.sourceEvent, {
          transform: U,
          snapGrid: $,
          snapToGrid: q,
          containerBounds: E
        });
        w = {
          width: k.measured.width ?? 0,
          height: k.measured.height ?? 0,
          x: k.position.x ?? 0,
          y: k.position.y ?? 0
        }, _ = {
          ...w,
          pointerX: W,
          pointerY: Y,
          aspectRatio: w.width / w.height
        }, O = void 0, k.parentId && (k.extent === "parent" || k.expandParent) && (O = j.get(k.parentId), M = O && k.extent === "parent" ? gve(O) : void 0), P = [], I = void 0;
        for (const [z, L] of j)
          if (L.parentId === t && (P.push({
            id: z,
            position: { ...L.position },
            extent: L.extent
          }), L.extent === "parent" || L.expandParent)) {
            const K = vve(L, k, L.origin ?? B);
            I ? I = [
              [Math.min(K[0][0], I[0][0]), Math.min(K[0][1], I[0][1])],
              [Math.max(K[1][0], I[1][0]), Math.max(K[1][1], I[1][1])]
            ] : I = K;
          }
        h?.(F, { ...w });
      }).on("drag", (F) => {
        const { transform: j, snapGrid: U, snapToGrid: $, nodeOrigin: q } = n(), B = Ap(F.sourceEvent, {
          transform: j,
          snapGrid: U,
          snapToGrid: $,
          containerBounds: E
        }), G = [];
        if (!k)
          return;
        const { x: W, y: Y, width: z, height: L } = w, K = {}, T = k.origin ?? q, { width: V, height: X, x: Q, y: ne } = mve(_, i.controlDirection, B, i.boundaries, i.keepAspectRatio, T, M, I), te = V !== z, ae = X !== L, ce = Q !== W && te, Z = ne !== Y && ae;
        if (!ce && !Z && !te && !ae)
          return;
        if ((ce || Z || T[0] === 1 || T[1] === 1) && (K.x = ce ? Q : w.x, K.y = Z ? ne : w.y, w.x = K.x, w.y = K.y, P.length > 0)) {
          const le = Q - W, be = ne - Y;
          for (const ke of P)
            ke.position = {
              x: ke.position.x - le + T[0] * (V - z),
              y: ke.position.y - be + T[1] * (X - L)
            }, G.push(ke);
        }
        if ((te || ae) && (K.width = te && (!i.resizeDirection || i.resizeDirection === "horizontal") ? V : w.width, K.height = ae && (!i.resizeDirection || i.resizeDirection === "vertical") ? X : w.height, w.width = K.width, w.height = K.height), O && k.expandParent) {
          const le = T[0] * (K.width ?? 0);
          K.x && K.x < le && (w.x = le, _.x = _.x - (K.x - le));
          const be = T[1] * (K.height ?? 0);
          K.y && K.y < be && (w.y = be, _.y = _.y - (K.y - be));
        }
        const ee = pve({
          width: w.width,
          prevWidth: z,
          height: w.height,
          prevHeight: L,
          affectsX: i.controlDirection.affectsX,
          affectsY: i.controlDirection.affectsY
        }), oe = { ...w, direction: ee };
        v?.(F, oe) !== !1 && (A = !0, y?.(F, oe), r(K, G));
      }).on("end", (F) => {
        A && (b?.(F, { ...w }), o?.({ ...w }), A = !1);
      });
      a.call(D);
    }
    function u() {
      a.on(".drag", null);
    }
    return {
      update: s,
      destroy: u
    };
  }
  const { useDebugValue: bve } = gn, { useSyncExternalStoreWithSelector: wve } = h8, xve = (e) => e;
  function QB(e, t = xve, n) {
    const r = wve(
      e.subscribe,
      e.getState,
      e.getServerState || e.getInitialState,
      t,
      n
    );
    return bve(r), r;
  }
  const X$ = (e, t) => {
    const n = m8(e), r = (o, a = t) => QB(n, o, a);
    return Object.assign(r, n), r;
  }, kve = (e, t) => e ? X$(e, t) : X$;
  function kn(e, t) {
    if (Object.is(e, t))
      return !0;
    if (typeof e != "object" || e === null || typeof t != "object" || t === null)
      return !1;
    if (e instanceof Map && t instanceof Map) {
      if (e.size !== t.size) return !1;
      for (const [r, o] of e)
        if (!Object.is(o, t.get(r)))
          return !1;
      return !0;
    }
    if (e instanceof Set && t instanceof Set) {
      if (e.size !== t.size) return !1;
      for (const r of e)
        if (!t.has(r))
          return !1;
      return !0;
    }
    const n = Object.keys(e);
    if (n.length !== Object.keys(t).length)
      return !1;
    for (const r of n)
      if (!Object.prototype.hasOwnProperty.call(t, r) || !Object.is(e[r], t[r]))
        return !1;
    return !0;
  }
  const Zw = C.createContext(null), Sve = Zw.Provider, ZB = Ka.error001();
  function Rt(e, t) {
    const n = C.useContext(Zw);
    if (n === null)
      throw new Error(ZB);
    return QB(n, e, t);
  }
  function _n() {
    const e = C.useContext(Zw);
    if (e === null)
      throw new Error(ZB);
    return C.useMemo(() => ({
      getState: e.getState,
      setState: e.setState,
      subscribe: e.subscribe
    }), [e]);
  }
  const Y$ = { display: "none" }, _ve = {
    position: "absolute",
    width: 1,
    height: 1,
    margin: -1,
    border: 0,
    padding: 0,
    overflow: "hidden",
    clip: "rect(0px, 0px, 0px, 0px)",
    clipPath: "inset(100%)"
  }, e7 = "react-flow__node-desc", t7 = "react-flow__edge-desc", Eve = "react-flow__aria-live", Cve = (e) => e.ariaLiveMessage, Pve = (e) => e.ariaLabelConfig;
  function Ove({ rfId: e }) {
    const t = Rt(Cve);
    return S.jsx("div", { id: `${Eve}-${e}`, "aria-live": "assertive", "aria-atomic": "true", style: _ve, children: t });
  }
  function Nve({ rfId: e, disableKeyboardA11y: t }) {
    const n = Rt(Pve);
    return S.jsxs(S.Fragment, { children: [S.jsx("div", { id: `${e7}-${e}`, style: Y$, children: t ? n["node.a11yDescription.default"] : n["node.a11yDescription.keyboardDisabled"] }), S.jsx("div", { id: `${t7}-${e}`, style: Y$, children: n["edge.a11yDescription.default"] }), !t && S.jsx(Ove, { rfId: e })] });
  }
  const ex = C.forwardRef(({ position: e = "top-left", children: t, className: n, style: r, ...o }, a) => {
    const i = `${e}`.split("-");
    return S.jsx("div", { className: Wn(["react-flow__panel", n, ...i]), style: r, ref: a, ...o, children: t });
  });
  ex.displayName = "Panel";
  function Mve({ proOptions: e, position: t = "bottom-right" }) {
    return e?.hideAttribution ? null : S.jsx(ex, { position: t, className: "react-flow__attribution", "data-message": "Please only hide this attribution when you are subscribed to React Flow Pro: https://pro.reactflow.dev", children: S.jsx("a", { href: "https://reactflow.dev", target: "_blank", rel: "noopener noreferrer", "aria-label": "React Flow attribution", children: "React Flow" }) });
  }
  const Rve = (e) => {
    const t = [], n = [];
    for (const [, r] of e.nodeLookup)
      r.selected && t.push(r.internals.userNode);
    for (const [, r] of e.edgeLookup)
      r.selected && n.push(r);
    return { selectedNodes: t, selectedEdges: n };
  }, kv = (e) => e.id;
  function jve(e, t) {
    return kn(e.selectedNodes.map(kv), t.selectedNodes.map(kv)) && kn(e.selectedEdges.map(kv), t.selectedEdges.map(kv));
  }
  function Ive({ onSelectionChange: e }) {
    const t = _n(), { selectedNodes: n, selectedEdges: r } = Rt(Rve, jve);
    return C.useEffect(() => {
      const o = { nodes: n, edges: r };
      e?.(o), t.getState().onSelectionChangeHandlers.forEach((a) => a(o));
    }, [n, r, e]), null;
  }
  const Ave = (e) => !!e.onSelectionChangeHandlers;
  function $ve({ onSelectionChange: e }) {
    const t = Rt(Ave);
    return e || t ? S.jsx(Ive, { onSelectionChange: e }) : null;
  }
  const n7 = [0, 0], Dve = { x: 0, y: 0, zoom: 1 }, Lve = [
    "nodes",
    "edges",
    "defaultNodes",
    "defaultEdges",
    "onConnect",
    "onConnectStart",
    "onConnectEnd",
    "onClickConnectStart",
    "onClickConnectEnd",
    "nodesDraggable",
    "autoPanOnNodeFocus",
    "nodesConnectable",
    "nodesFocusable",
    "edgesFocusable",
    "edgesReconnectable",
    "elevateNodesOnSelect",
    "elevateEdgesOnSelect",
    "minZoom",
    "maxZoom",
    "nodeExtent",
    "onNodesChange",
    "onEdgesChange",
    "elementsSelectable",
    "connectionMode",
    "snapGrid",
    "snapToGrid",
    "translateExtent",
    "connectOnClick",
    "defaultEdgeOptions",
    "fitView",
    "fitViewOptions",
    "onNodesDelete",
    "onEdgesDelete",
    "onDelete",
    "onNodeDrag",
    "onNodeDragStart",
    "onNodeDragStop",
    "onSelectionDrag",
    "onSelectionDragStart",
    "onSelectionDragStop",
    "onMoveStart",
    "onMove",
    "onMoveEnd",
    "noPanClassName",
    "nodeOrigin",
    "autoPanOnConnect",
    "autoPanOnNodeDrag",
    "onError",
    "connectionRadius",
    "isValidConnection",
    "selectNodesOnDrag",
    "nodeDragThreshold",
    "connectionDragThreshold",
    "onBeforeDelete",
    "debug",
    "autoPanSpeed",
    "ariaLabelConfig",
    "zIndexMode"
  ], J$ = [...Lve, "rfId"], Fve = (e) => ({
    setNodes: e.setNodes,
    setEdges: e.setEdges,
    setMinZoom: e.setMinZoom,
    setMaxZoom: e.setMaxZoom,
    setTranslateExtent: e.setTranslateExtent,
    setNodeExtent: e.setNodeExtent,
    reset: e.reset,
    setDefaultNodesAndEdges: e.setDefaultNodesAndEdges
  }), Q$ = {
    /*
     * these are values that are also passed directly to other components
     * than the StoreUpdater. We can reduce the number of setStore calls
     * by setting the same values here as prev fields.
     */
    translateExtent: lm,
    nodeOrigin: n7,
    minZoom: 0.5,
    maxZoom: 2,
    elementsSelectable: !0,
    noPanClassName: "nopan",
    rfId: "1"
  };
  function Tve(e) {
    const { setNodes: t, setEdges: n, setMinZoom: r, setMaxZoom: o, setTranslateExtent: a, setNodeExtent: i, reset: s, setDefaultNodesAndEdges: u } = Rt(Fve, kn), c = _n();
    C.useEffect(() => (u(e.defaultNodes, e.defaultEdges), () => {
      f.current = Q$, s();
    }), []);
    const f = C.useRef(Q$);
    return C.useEffect(
      () => {
        for (const p of J$) {
          const g = e[p], h = f.current[p];
          g !== h && (typeof e[p] > "u" || (p === "nodes" ? t(g) : p === "edges" ? n(g) : p === "minZoom" ? r(g) : p === "maxZoom" ? o(g) : p === "translateExtent" ? a(g) : p === "nodeExtent" ? i(g) : p === "ariaLabelConfig" ? c.setState({ ariaLabelConfig: Mge(g) }) : p === "fitView" ? c.setState({ fitViewQueued: g }) : p === "fitViewOptions" ? c.setState({ fitViewOptions: g }) : c.setState({ [p]: g })));
        }
        f.current = e;
      },
      // Only re-run the effect if one of the fields we track changes
      J$.map((p) => e[p])
    ), null;
  }
  function Z$() {
    return typeof window > "u" || !window.matchMedia ? null : window.matchMedia("(prefers-color-scheme: dark)");
  }
  function zve(e) {
    const [t, n] = C.useState(e === "system" ? null : e);
    return C.useEffect(() => {
      if (e !== "system") {
        n(e);
        return;
      }
      const r = Z$(), o = () => n(r?.matches ? "dark" : "light");
      return o(), r?.addEventListener("change", o), () => {
        r?.removeEventListener("change", o);
      };
    }, [e]), t !== null ? t : Z$()?.matches ? "dark" : "light";
  }
  const e3 = typeof document < "u" ? document : null;
  function Li(e = null, t = { target: e3, actInsideInputWithModifier: !0 }) {
    const [n, r] = C.useState(!1), o = C.useRef(!1), a = C.useRef(/* @__PURE__ */ new Set([])), [i, s] = C.useMemo(() => {
      if (e !== null) {
        const u = (Array.isArray(e) ? e : [e]).filter((f) => typeof f == "string").map((f) => f.replace("+", `
`).replace(`

`, `
+`).split(`
`)), c = u.reduce((f, p) => f.concat(...p), []);
        return [u, c];
      }
      return [[], []];
    }, [e]);
    return C.useEffect(() => {
      const u = t?.target ?? e3, c = t?.actInsideInputWithModifier ?? !0;
      if (e !== null) {
        const f = (h) => {
          if (o.current = h.ctrlKey || h.metaKey || h.shiftKey || h.altKey, (!o.current || o.current && !c) && DB(h))
            return !1;
          const y = n3(h.code, s);
          if (a.current.add(h[y]), t3(i, a.current, !1)) {
            const b = h.composedPath?.()?.[0] || h.target, v = b?.nodeName === "BUTTON" || b?.nodeName === "A";
            t.preventDefault !== !1 && (o.current || !v) && h.preventDefault(), r(!0);
          }
        }, p = (h) => {
          const y = n3(h.code, s);
          t3(i, a.current, !0) ? (r(!1), a.current.clear()) : a.current.delete(h[y]), h.key === "Meta" && a.current.clear(), o.current = !1;
        }, g = () => {
          a.current.clear(), r(!1);
        };
        return u?.addEventListener("keydown", f), u?.addEventListener("keyup", p), window.addEventListener("blur", g), window.addEventListener("contextmenu", g), () => {
          u?.removeEventListener("keydown", f), u?.removeEventListener("keyup", p), window.removeEventListener("blur", g), window.removeEventListener("contextmenu", g);
        };
      }
    }, [e, r]), n;
  }
  function t3(e, t, n) {
    return e.filter((r) => n || r.length === t.size).some((r) => r.every((o) => t.has(o)));
  }
  function n3(e, t) {
    return t.includes(e) ? "code" : "key";
  }
  const Bve = () => {
    const e = _n();
    return C.useMemo(() => ({
      zoomIn: (t) => {
        const { panZoom: n } = e.getState();
        return n ? n.scaleBy(1.2, { duration: t?.duration }) : Promise.resolve(!1);
      },
      zoomOut: (t) => {
        const { panZoom: n } = e.getState();
        return n ? n.scaleBy(1 / 1.2, { duration: t?.duration }) : Promise.resolve(!1);
      },
      zoomTo: (t, n) => {
        const { panZoom: r } = e.getState();
        return r ? r.scaleTo(t, { duration: n?.duration }) : Promise.resolve(!1);
      },
      getZoom: () => e.getState().transform[2],
      setViewport: async (t, n) => {
        const { transform: [r, o, a], panZoom: i } = e.getState();
        return i ? (await i.setViewport({
          x: t.x ?? r,
          y: t.y ?? o,
          zoom: t.zoom ?? a
        }, n), Promise.resolve(!0)) : Promise.resolve(!1);
      },
      getViewport: () => {
        const [t, n, r] = e.getState().transform;
        return { x: t, y: n, zoom: r };
      },
      setCenter: async (t, n, r) => e.getState().setCenter(t, n, r),
      fitBounds: async (t, n) => {
        const { width: r, height: o, minZoom: a, maxZoom: i, panZoom: s } = e.getState(), u = yP(t, r, o, a, i, n?.padding ?? 0.1);
        return s ? (await s.setViewport(u, {
          duration: n?.duration,
          ease: n?.ease,
          interpolate: n?.interpolate
        }), Promise.resolve(!0)) : Promise.resolve(!1);
      },
      screenToFlowPosition: (t, n = {}) => {
        const { transform: r, snapGrid: o, snapToGrid: a, domNode: i } = e.getState();
        if (!i)
          return t;
        const { x: s, y: u } = i.getBoundingClientRect(), c = {
          x: t.x - s,
          y: t.y - u
        }, f = n.snapGrid ?? o, p = n.snapToGrid ?? a;
        return oh(c, r, p, f);
      },
      flowToScreenPosition: (t) => {
        const { transform: n, domNode: r } = e.getState();
        if (!r)
          return t;
        const { x: o, y: a } = r.getBoundingClientRect(), i = Nb(t, n);
        return {
          x: i.x + o,
          y: i.y + a
        };
      }
    }), []);
  };
  function r7(e, t) {
    const n = [], r = /* @__PURE__ */ new Map(), o = [];
    for (const a of e)
      if (a.type === "add") {
        o.push(a);
        continue;
      } else if (a.type === "remove" || a.type === "replace")
        r.set(a.id, [a]);
      else {
        const i = r.get(a.id);
        i ? i.push(a) : r.set(a.id, [a]);
      }
    for (const a of t) {
      const i = r.get(a.id);
      if (!i) {
        n.push(a);
        continue;
      }
      if (i[0].type === "remove")
        continue;
      if (i[0].type === "replace") {
        n.push({ ...i[0].item });
        continue;
      }
      const s = { ...a };
      for (const u of i)
        Vve(u, s);
      n.push(s);
    }
    return o.length && o.forEach((a) => {
      a.index !== void 0 ? n.splice(a.index, 0, { ...a.item }) : n.push({ ...a.item });
    }), n;
  }
  function Vve(e, t) {
    switch (e.type) {
      case "select": {
        t.selected = e.selected;
        break;
      }
      case "position": {
        typeof e.position < "u" && (t.position = e.position), typeof e.dragging < "u" && (t.dragging = e.dragging);
        break;
      }
      case "dimensions": {
        typeof e.dimensions < "u" && (t.measured = {
          ...e.dimensions
        }, e.setAttributes && ((e.setAttributes === !0 || e.setAttributes === "width") && (t.width = e.dimensions.width), (e.setAttributes === !0 || e.setAttributes === "height") && (t.height = e.dimensions.height))), typeof e.resizing == "boolean" && (t.resizing = e.resizing);
        break;
      }
    }
  }
  function CP(e, t) {
    return r7(e, t);
  }
  function o7(e, t) {
    return r7(e, t);
  }
  function Xl(e, t) {
    return {
      id: e,
      type: "select",
      selected: t
    };
  }
  function Gc(e, t = /* @__PURE__ */ new Set(), n = !1) {
    const r = [];
    for (const [o, a] of e) {
      const i = t.has(o);
      !(a.selected === void 0 && !i) && a.selected !== i && (n && (a.selected = i), r.push(Xl(a.id, i)));
    }
    return r;
  }
  function r3({ items: e = [], lookup: t }) {
    const n = [], r = new Map(e.map((o) => [o.id, o]));
    for (const [o, a] of e.entries()) {
      const i = t.get(a.id), s = i?.internals?.userNode ?? i;
      s !== void 0 && s !== a && n.push({ id: a.id, item: a, type: "replace" }), s === void 0 && n.push({ item: a, type: "add", index: o });
    }
    for (const [o] of t)
      r.get(o) === void 0 && n.push({ id: o, type: "remove" });
    return n;
  }
  function o3(e) {
    return {
      id: e.id,
      type: "remove"
    };
  }
  const a3 = (e) => wge(e), Uve = (e) => OB(e);
  function a7(e) {
    return C.forwardRef(e);
  }
  const Hve = typeof window < "u" ? C.useLayoutEffect : C.useEffect;
  function i3(e) {
    const [t, n] = C.useState(BigInt(0)), [r] = C.useState(() => Wve(() => n((o) => o + BigInt(1))));
    return Hve(() => {
      const o = r.get();
      o.length && (e(o), r.reset());
    }, [t]), r;
  }
  function Wve(e) {
    let t = [];
    return {
      get: () => t,
      reset: () => {
        t = [];
      },
      push: (n) => {
        t.push(n), e();
      }
    };
  }
  const i7 = C.createContext(null);
  function qve({ children: e }) {
    const t = _n(), n = C.useCallback((s) => {
      const { nodes: u = [], setNodes: c, hasDefaultNodes: f, onNodesChange: p, nodeLookup: g, fitViewQueued: h, onNodesChangeMiddlewareMap: y } = t.getState();
      let b = u;
      for (const w of s)
        b = typeof w == "function" ? w(b) : w;
      let v = r3({
        items: b,
        lookup: g
      });
      for (const w of y.values())
        v = w(v);
      f && c(b), v.length > 0 ? p?.(v) : h && window.requestAnimationFrame(() => {
        const { fitViewQueued: w, nodes: _, setNodes: k } = t.getState();
        w && k(_);
      });
    }, []), r = i3(n), o = C.useCallback((s) => {
      const { edges: u = [], setEdges: c, hasDefaultEdges: f, onEdgesChange: p, edgeLookup: g } = t.getState();
      let h = u;
      for (const y of s)
        h = typeof y == "function" ? y(h) : y;
      f ? c(h) : p && p(r3({
        items: h,
        lookup: g
      }));
    }, []), a = i3(o), i = C.useMemo(() => ({ nodeQueue: r, edgeQueue: a }), []);
    return S.jsx(i7.Provider, { value: i, children: e });
  }
  function Kve() {
    const e = C.useContext(i7);
    if (!e)
      throw new Error("useBatchContext must be used within a BatchProvider");
    return e;
  }
  const Gve = (e) => !!e.panZoom;
  function ku() {
    const e = Bve(), t = _n(), n = Kve(), r = Rt(Gve), o = C.useMemo(() => {
      const a = (p) => t.getState().nodeLookup.get(p), i = (p) => {
        n.nodeQueue.push(p);
      }, s = (p) => {
        n.edgeQueue.push(p);
      }, u = (p) => {
        const { nodeLookup: g, nodeOrigin: h } = t.getState(), y = a3(p) ? p : g.get(p.id), b = y.parentId ? AB(y.position, y.measured, y.parentId, g, h) : y.position, v = {
          ...y,
          position: b,
          width: y.measured?.width ?? y.width,
          height: y.measured?.height ?? y.height
        };
        return kd(v);
      }, c = (p, g, h = { replace: !1 }) => {
        i((y) => y.map((b) => {
          if (b.id === p) {
            const v = typeof g == "function" ? g(b) : g;
            return h.replace && a3(v) ? v : { ...b, ...v };
          }
          return b;
        }));
      }, f = (p, g, h = { replace: !1 }) => {
        s((y) => y.map((b) => {
          if (b.id === p) {
            const v = typeof g == "function" ? g(b) : g;
            return h.replace && Uve(v) ? v : { ...b, ...v };
          }
          return b;
        }));
      };
      return {
        getNodes: () => t.getState().nodes.map((p) => ({ ...p })),
        getNode: (p) => a(p)?.internals.userNode,
        getInternalNode: a,
        getEdges: () => {
          const { edges: p = [] } = t.getState();
          return p.map((g) => ({ ...g }));
        },
        getEdge: (p) => t.getState().edgeLookup.get(p),
        setNodes: i,
        setEdges: s,
        addNodes: (p) => {
          const g = Array.isArray(p) ? p : [p];
          n.nodeQueue.push((h) => [...h, ...g]);
        },
        addEdges: (p) => {
          const g = Array.isArray(p) ? p : [p];
          n.edgeQueue.push((h) => [...h, ...g]);
        },
        toObject: () => {
          const { nodes: p = [], edges: g = [], transform: h } = t.getState(), [y, b, v] = h;
          return {
            nodes: p.map((w) => ({ ...w })),
            edges: g.map((w) => ({ ...w })),
            viewport: {
              x: y,
              y: b,
              zoom: v
            }
          };
        },
        deleteElements: async ({ nodes: p = [], edges: g = [] }) => {
          const { nodes: h, edges: y, onNodesDelete: b, onEdgesDelete: v, triggerNodeChanges: w, triggerEdgeChanges: _, onDelete: k, onBeforeDelete: E } = t.getState(), { nodes: P, edges: O } = await Ege({
            nodesToRemove: p,
            edgesToRemove: g,
            nodes: h,
            edges: y,
            onBeforeDelete: E
          }), M = O.length > 0, I = P.length > 0;
          if (M) {
            const A = O.map(o3);
            v?.(O), _(A);
          }
          if (I) {
            const A = P.map(o3);
            b?.(P), w(A);
          }
          return (I || M) && k?.({ nodes: P, edges: O }), { deletedNodes: P, deletedEdges: O };
        },
        /**
         * Partial is defined as "the 2 nodes/areas are intersecting partially".
         * If a is contained in b or b is contained in a, they are both
         * considered fully intersecting.
         */
        getIntersectingNodes: (p, g = !0, h) => {
          const y = D$(p), b = y ? p : u(p), v = h !== void 0;
          return b ? (h || t.getState().nodes).filter((w) => {
            const _ = t.getState().nodeLookup.get(w.id);
            if (_ && !y && (w.id === p.id || !_.internals.positionAbsolute))
              return !1;
            const k = kd(v ? w : _), E = cm(k, b);
            return g && E > 0 || E >= k.width * k.height || E >= b.width * b.height;
          }) : [];
        },
        isNodeIntersecting: (p, g, h = !0) => {
          const y = D$(p) ? p : u(p);
          if (!y)
            return !1;
          const b = cm(y, g);
          return h && b > 0 || b >= g.width * g.height || b >= y.width * y.height;
        },
        updateNode: c,
        updateNodeData: (p, g, h = { replace: !1 }) => {
          c(p, (y) => {
            const b = typeof g == "function" ? g(y) : g;
            return h.replace ? { ...y, data: b } : { ...y, data: { ...y.data, ...b } };
          }, h);
        },
        updateEdge: f,
        updateEdgeData: (p, g, h = { replace: !1 }) => {
          f(p, (y) => {
            const b = typeof g == "function" ? g(y) : g;
            return h.replace ? { ...y, data: b } : { ...y, data: { ...y.data, ...b } };
          }, h);
        },
        getNodesBounds: (p) => {
          const { nodeLookup: g, nodeOrigin: h } = t.getState();
          return xge(p, { nodeLookup: g, nodeOrigin: h });
        },
        getHandleConnections: ({ type: p, id: g, nodeId: h }) => Array.from(t.getState().connectionLookup.get(`${h}-${p}${g ? `-${g}` : ""}`)?.values() ?? []),
        getNodeConnections: ({ type: p, handleId: g, nodeId: h }) => Array.from(t.getState().connectionLookup.get(`${h}${p ? g ? `-${p}-${g}` : `-${p}` : ""}`)?.values() ?? []),
        fitView: async (p) => {
          const g = t.getState().fitViewResolver ?? Nge();
          return t.setState({ fitViewQueued: !0, fitViewOptions: p, fitViewResolver: g }), n.nodeQueue.push((h) => [...h]), g.promise;
        }
      };
    }, []);
    return C.useMemo(() => ({
      ...o,
      ...e,
      viewportInitialized: r
    }), [r]);
  }
  const s3 = (e) => e.selected, Xve = typeof window < "u" ? window : void 0;
  function Yve({ deleteKeyCode: e, multiSelectionKeyCode: t }) {
    const n = _n(), { deleteElements: r } = ku(), o = Li(e, { actInsideInputWithModifier: !1 }), a = Li(t, { target: Xve });
    C.useEffect(() => {
      if (o) {
        const { edges: i, nodes: s } = n.getState();
        r({ nodes: s.filter(s3), edges: i.filter(s3) }), n.setState({ nodesSelectionActive: !1 });
      }
    }, [o]), C.useEffect(() => {
      n.setState({ multiSelectionActive: a });
    }, [a]);
  }
  function Jve(e) {
    const t = _n();
    C.useEffect(() => {
      const n = () => {
        if (!e.current || !(e.current.checkVisibility?.() ?? !0))
          return !1;
        const r = bP(e.current);
        (r.height === 0 || r.width === 0) && t.getState().onError?.("004", Ka.error004()), t.setState({ width: r.width || 500, height: r.height || 500 });
      };
      if (e.current) {
        n(), window.addEventListener("resize", n);
        const r = new ResizeObserver(() => n());
        return r.observe(e.current), () => {
          window.removeEventListener("resize", n), r && e.current && r.unobserve(e.current);
        };
      }
    }, []);
  }
  const tx = {
    position: "absolute",
    width: "100%",
    height: "100%",
    top: 0,
    left: 0
  }, Qve = (e) => ({
    userSelectionActive: e.userSelectionActive,
    lib: e.lib,
    connectionInProgress: e.connection.inProgress
  });
  function Zve({ onPaneContextMenu: e, zoomOnScroll: t = !0, zoomOnPinch: n = !0, panOnScroll: r = !1, panOnScrollSpeed: o = 0.5, panOnScrollMode: a = au.Free, zoomOnDoubleClick: i = !0, panOnDrag: s = !0, defaultViewport: u, translateExtent: c, minZoom: f, maxZoom: p, zoomActivationKeyCode: g, preventScrolling: h = !0, children: y, noWheelClassName: b, noPanClassName: v, onViewportChange: w, isControlledViewport: _, paneClickDistance: k, selectionOnDrag: E }) {
    const P = _n(), O = C.useRef(null), { userSelectionActive: M, lib: I, connectionInProgress: A } = Rt(Qve, kn), D = Li(g), F = C.useRef();
    Jve(O);
    const j = C.useCallback((U) => {
      w?.({ x: U[0], y: U[1], zoom: U[2] }), _ || P.setState({ transform: U });
    }, [w, _]);
    return C.useEffect(() => {
      if (O.current) {
        F.current = fve({
          domNode: O.current,
          minZoom: f,
          maxZoom: p,
          translateExtent: c,
          viewport: u,
          onDraggingChange: (B) => P.setState({ paneDragging: B }),
          onPanZoomStart: (B, G) => {
            const { onViewportChangeStart: W, onMoveStart: Y } = P.getState();
            Y?.(B, G), W?.(G);
          },
          onPanZoom: (B, G) => {
            const { onViewportChange: W, onMove: Y } = P.getState();
            Y?.(B, G), W?.(G);
          },
          onPanZoomEnd: (B, G) => {
            const { onViewportChangeEnd: W, onMoveEnd: Y } = P.getState();
            Y?.(B, G), W?.(G);
          }
        });
        const { x: U, y: $, zoom: q } = F.current.getViewport();
        return P.setState({
          panZoom: F.current,
          transform: [U, $, q],
          domNode: O.current.closest(".react-flow")
        }), () => {
          F.current?.destroy();
        };
      }
    }, []), C.useEffect(() => {
      F.current?.update({
        onPaneContextMenu: e,
        zoomOnScroll: t,
        zoomOnPinch: n,
        panOnScroll: r,
        panOnScrollSpeed: o,
        panOnScrollMode: a,
        zoomOnDoubleClick: i,
        panOnDrag: s,
        zoomActivationKeyPressed: D,
        preventScrolling: h,
        noPanClassName: v,
        userSelectionActive: M,
        noWheelClassName: b,
        lib: I,
        onTransformChange: j,
        connectionInProgress: A,
        selectionOnDrag: E,
        paneClickDistance: k
      });
    }, [
      e,
      t,
      n,
      r,
      o,
      a,
      i,
      s,
      D,
      h,
      v,
      M,
      b,
      I,
      j,
      A,
      E,
      k
    ]), S.jsx("div", { className: "react-flow__renderer", ref: O, style: tx, children: y });
  }
  const eye = (e) => ({
    userSelectionActive: e.userSelectionActive,
    userSelectionRect: e.userSelectionRect
  });
  function tye() {
    const { userSelectionActive: e, userSelectionRect: t } = Rt(eye, kn);
    return e && t ? S.jsx("div", { className: "react-flow__selection react-flow__container", style: {
      width: t.width,
      height: t.height,
      transform: `translate(${t.x}px, ${t.y}px)`
    } }) : null;
  }
  const Q_ = (e, t) => (n) => {
    n.target === t.current && e?.(n);
  }, nye = (e) => ({
    userSelectionActive: e.userSelectionActive,
    elementsSelectable: e.elementsSelectable,
    connectionInProgress: e.connection.inProgress,
    dragging: e.paneDragging
  });
  function rye({ isSelecting: e, selectionKeyPressed: t, selectionMode: n = um.Full, panOnDrag: r, paneClickDistance: o, selectionOnDrag: a, onSelectionStart: i, onSelectionEnd: s, onPaneClick: u, onPaneContextMenu: c, onPaneScroll: f, onPaneMouseEnter: p, onPaneMouseMove: g, onPaneMouseLeave: h, children: y }) {
    const b = _n(), { userSelectionActive: v, elementsSelectable: w, dragging: _, connectionInProgress: k } = Rt(nye, kn), E = w && (e || v), P = C.useRef(null), O = C.useRef(), M = C.useRef(/* @__PURE__ */ new Set()), I = C.useRef(/* @__PURE__ */ new Set()), A = C.useRef(!1), D = (W) => {
      if (A.current || k) {
        A.current = !1;
        return;
      }
      u?.(W), b.getState().resetSelectedElements(), b.setState({ nodesSelectionActive: !1 });
    }, F = (W) => {
      if (Array.isArray(r) && r?.includes(2)) {
        W.preventDefault();
        return;
      }
      c?.(W);
    }, j = f ? (W) => f(W) : void 0, U = (W) => {
      A.current && (W.stopPropagation(), A.current = !1);
    }, $ = (W) => {
      const { domNode: Y } = b.getState();
      if (O.current = Y?.getBoundingClientRect(), !O.current)
        return;
      const z = W.target === P.current;
      if (!z && W.target.closest(".nokey") || !e || !(a && z || t) || W.button !== 0 || !W.isPrimary)
        return;
      W.target?.setPointerCapture?.(W.pointerId), A.current = !1;
      const { x: L, y: K } = Qo(W.nativeEvent, O.current);
      b.setState({
        userSelectionRect: {
          width: 0,
          height: 0,
          startX: L,
          startY: K,
          x: L,
          y: K
        }
      }), z || (W.stopPropagation(), W.preventDefault());
    }, q = (W) => {
      const { userSelectionRect: Y, transform: z, nodeLookup: L, edgeLookup: K, connectionLookup: T, triggerNodeChanges: V, triggerEdgeChanges: X, defaultEdgeOptions: Q, resetSelectedElements: ne } = b.getState();
      if (!O.current || !Y)
        return;
      const { x: te, y: ae } = Qo(W.nativeEvent, O.current), { startX: ce, startY: Z } = Y;
      if (!A.current) {
        const ke = t ? 0 : o;
        if (Math.hypot(te - ce, ae - Z) <= ke)
          return;
        ne(), i?.(W);
      }
      A.current = !0;
      const ee = {
        startX: ce,
        startY: Z,
        x: te < ce ? te : ce,
        y: ae < Z ? ae : Z,
        width: Math.abs(te - ce),
        height: Math.abs(ae - Z)
      }, oe = M.current, le = I.current;
      M.current = new Set(vP(L, ee, z, n === um.Partial, !0).map((ke) => ke.id)), I.current = /* @__PURE__ */ new Set();
      const be = Q?.selectable ?? !0;
      for (const ke of M.current) {
        const De = T.get(ke);
        if (De)
          for (const { edgeId: ze } of De.values()) {
            const Ue = K.get(ze);
            Ue && (Ue.selectable ?? be) && I.current.add(ze);
          }
      }
      if (!L$(oe, M.current)) {
        const ke = Gc(L, M.current, !0);
        V(ke);
      }
      if (!L$(le, I.current)) {
        const ke = Gc(K, I.current);
        X(ke);
      }
      b.setState({
        userSelectionRect: ee,
        userSelectionActive: !0,
        nodesSelectionActive: !1
      });
    }, B = (W) => {
      W.button === 0 && (W.target?.releasePointerCapture?.(W.pointerId), !v && W.target === P.current && b.getState().userSelectionRect && D?.(W), b.setState({
        userSelectionActive: !1,
        userSelectionRect: null
      }), A.current && (s?.(W), b.setState({
        nodesSelectionActive: M.current.size > 0
      })));
    }, G = r === !0 || Array.isArray(r) && r.includes(0);
    return S.jsxs("div", { className: Wn(["react-flow__pane", { draggable: G, dragging: _, selection: e }]), onClick: E ? void 0 : Q_(D, P), onContextMenu: Q_(F, P), onWheel: Q_(j, P), onPointerEnter: E ? void 0 : p, onPointerMove: E ? q : g, onPointerUp: E ? B : void 0, onPointerDownCapture: E ? $ : void 0, onClickCapture: E ? U : void 0, onPointerLeave: h, ref: P, style: tx, children: [y, S.jsx(tye, {})] });
  }
  function eE({ id: e, store: t, unselect: n = !1, nodeRef: r }) {
    const { addSelectedNodes: o, unselectNodesAndEdges: a, multiSelectionActive: i, nodeLookup: s, onError: u } = t.getState(), c = s.get(e);
    if (!c) {
      u?.("012", Ka.error012(e));
      return;
    }
    t.setState({ nodesSelectionActive: !1 }), c.selected ? (n || c.selected && i) && (a({ nodes: [c], edges: [] }), requestAnimationFrame(() => r?.current?.blur())) : o([e]);
  }
  function s7({ nodeRef: e, disabled: t = !1, noDragClassName: n, handleSelector: r, nodeId: o, isSelectable: a, nodeClickDistance: i }) {
    const s = _n(), [u, c] = C.useState(!1), f = C.useRef();
    return C.useEffect(() => {
      f.current = Qge({
        getStoreItems: () => s.getState(),
        onNodeMouseDown: (p) => {
          eE({
            id: p,
            store: s,
            nodeRef: e
          });
        },
        onDragStart: () => {
          c(!0);
        },
        onDragStop: () => {
          c(!1);
        }
      });
    }, []), C.useEffect(() => {
      if (t)
        f.current?.destroy();
      else if (e.current)
        return f.current?.update({
          noDragClassName: n,
          handleSelector: r,
          domNode: e.current,
          isSelectable: a,
          nodeId: o,
          nodeClickDistance: i
        }), () => {
          f.current?.destroy();
        };
    }, [n, r, t, a, e, o]), u;
  }
  const oye = (e) => (t) => t.selected && (t.draggable || e && typeof t.draggable > "u");
  function l7() {
    const e = _n();
    return C.useCallback((t) => {
      const { nodeExtent: n, snapToGrid: r, snapGrid: o, nodesDraggable: a, onError: i, updateNodePositions: s, nodeLookup: u, nodeOrigin: c } = e.getState(), f = /* @__PURE__ */ new Map(), p = oye(a), g = r ? o[0] : 5, h = r ? o[1] : 5, y = t.direction.x * g * t.factor, b = t.direction.y * h * t.factor;
      for (const [, v] of u) {
        if (!p(v))
          continue;
        let w = {
          x: v.internals.positionAbsolute.x + y,
          y: v.internals.positionAbsolute.y + b
        };
        r && (w = rh(w, o));
        const { position: _, positionAbsolute: k } = NB({
          nodeId: v.id,
          nextPosition: w,
          nodeLookup: u,
          nodeExtent: n,
          nodeOrigin: c,
          onError: i
        });
        v.position = _, v.internals.positionAbsolute = k, f.set(v.id, v);
      }
      s(f);
    }, []);
  }
  const PP = C.createContext(null), aye = PP.Provider;
  PP.Consumer;
  const u7 = () => C.useContext(PP), iye = (e) => ({
    connectOnClick: e.connectOnClick,
    noPanClassName: e.noPanClassName,
    rfId: e.rfId
  }), sye = (e, t, n) => (r) => {
    const { connectionClickStartHandle: o, connectionMode: a, connection: i } = r, { fromHandle: s, toHandle: u, isValid: c } = i, f = u?.nodeId === e && u?.id === t && u?.type === n;
    return {
      connectingFrom: s?.nodeId === e && s?.id === t && s?.type === n,
      connectingTo: f,
      clickConnecting: o?.nodeId === e && o?.id === t && o?.type === n,
      isPossibleEndHandle: a === wd.Strict ? s?.type !== n : e !== s?.nodeId || t !== s?.id,
      connectionInProcess: !!s,
      clickConnectionInProcess: !!o,
      valid: f && c
    };
  };
  function lye({ type: e = "source", position: t = Ve.Top, isValidConnection: n, isConnectable: r = !0, isConnectableStart: o = !0, isConnectableEnd: a = !0, id: i, onConnect: s, children: u, className: c, onMouseDown: f, onTouchStart: p, ...g }, h) {
    const y = i || null, b = e === "target", v = _n(), w = u7(), { connectOnClick: _, noPanClassName: k, rfId: E } = Rt(iye, kn), { connectingFrom: P, connectingTo: O, clickConnecting: M, isPossibleEndHandle: I, connectionInProcess: A, clickConnectionInProcess: D, valid: F } = Rt(sye(w, y, e), kn);
    w || v.getState().onError?.("010", Ka.error010());
    const j = (q) => {
      const { defaultEdgeOptions: B, onConnect: G, hasDefaultEdges: W } = v.getState(), Y = {
        ...B,
        ...q
      };
      if (W) {
        const { edges: z, setEdges: L } = v.getState();
        L(Dge(Y, z));
      }
      G?.(Y), s?.(Y);
    }, U = (q) => {
      if (!w)
        return;
      const B = LB(q.nativeEvent);
      if (o && (B && q.button === 0 || !B)) {
        const G = v.getState();
        Z2.onPointerDown(q.nativeEvent, {
          handleDomNode: q.currentTarget,
          autoPanOnConnect: G.autoPanOnConnect,
          connectionMode: G.connectionMode,
          connectionRadius: G.connectionRadius,
          domNode: G.domNode,
          nodeLookup: G.nodeLookup,
          lib: G.lib,
          isTarget: b,
          handleId: y,
          nodeId: w,
          flowId: G.rfId,
          panBy: G.panBy,
          cancelConnection: G.cancelConnection,
          onConnectStart: G.onConnectStart,
          onConnectEnd: G.onConnectEnd,
          updateConnection: G.updateConnection,
          onConnect: j,
          isValidConnection: n || G.isValidConnection,
          getTransform: () => v.getState().transform,
          getFromHandle: () => v.getState().connection.fromHandle,
          autoPanSpeed: G.autoPanSpeed,
          dragThreshold: G.connectionDragThreshold
        });
      }
      B ? f?.(q) : p?.(q);
    }, $ = (q) => {
      const { onClickConnectStart: B, onClickConnectEnd: G, connectionClickStartHandle: W, connectionMode: Y, isValidConnection: z, lib: L, rfId: K, nodeLookup: T, connection: V } = v.getState();
      if (!w || !W && !o)
        return;
      if (!W) {
        B?.(q.nativeEvent, { nodeId: w, handleId: y, handleType: e }), v.setState({ connectionClickStartHandle: { nodeId: w, type: e, id: y } });
        return;
      }
      const X = $B(q.target), Q = n || z, { connection: ne, isValid: te } = Z2.isValid(q.nativeEvent, {
        handle: {
          nodeId: w,
          id: y,
          type: e
        },
        connectionMode: Y,
        fromNodeId: W.nodeId,
        fromHandleId: W.id || null,
        fromType: W.type,
        isValidConnection: Q,
        flowId: K,
        doc: X,
        lib: L,
        nodeLookup: T
      });
      te && ne && j(ne);
      const ae = structuredClone(V);
      delete ae.inProgress, ae.toPosition = ae.toHandle ? ae.toHandle.position : null, G?.(q, ae), v.setState({ connectionClickStartHandle: null });
    };
    return S.jsx("div", { "data-handleid": y, "data-nodeid": w, "data-handlepos": t, "data-id": `${E}-${w}-${y}-${e}`, className: Wn([
      "react-flow__handle",
      `react-flow__handle-${t}`,
      "nodrag",
      k,
      c,
      {
        source: !b,
        target: b,
        connectable: r,
        connectablestart: o,
        connectableend: a,
        clickconnecting: M,
        connectingfrom: P,
        connectingto: O,
        valid: F,
        /*
         * shows where you can start a connection from
         * and where you can end it while connecting
         */
        connectionindicator: r && (!A || I) && (A || D ? a : o)
      }
    ]), onMouseDown: U, onTouchStart: U, onClick: _ ? $ : void 0, ref: h, ...g, children: u });
  }
  const fm = C.memo(a7(lye));
  function uye({ data: e, isConnectable: t, sourcePosition: n = Ve.Bottom }) {
    return S.jsxs(S.Fragment, { children: [e?.label, S.jsx(fm, { type: "source", position: n, isConnectable: t })] });
  }
  function cye({ data: e, isConnectable: t, targetPosition: n = Ve.Top, sourcePosition: r = Ve.Bottom }) {
    return S.jsxs(S.Fragment, { children: [S.jsx(fm, { type: "target", position: n, isConnectable: t }), e?.label, S.jsx(fm, { type: "source", position: r, isConnectable: t })] });
  }
  function dye() {
    return null;
  }
  function fye({ data: e, isConnectable: t, targetPosition: n = Ve.Top }) {
    return S.jsxs(S.Fragment, { children: [S.jsx(fm, { type: "target", position: n, isConnectable: t }), e?.label] });
  }
  const Mb = {
    ArrowUp: { x: 0, y: -1 },
    ArrowDown: { x: 0, y: 1 },
    ArrowLeft: { x: -1, y: 0 },
    ArrowRight: { x: 1, y: 0 }
  }, l3 = {
    input: uye,
    default: cye,
    output: fye,
    group: dye
  };
  function pye(e) {
    return e.internals.handleBounds === void 0 ? {
      width: e.width ?? e.initialWidth ?? e.style?.width,
      height: e.height ?? e.initialHeight ?? e.style?.height
    } : {
      width: e.width ?? e.style?.width,
      height: e.height ?? e.style?.height
    };
  }
  const mye = (e) => {
    const { width: t, height: n, x: r, y: o } = nh(e.nodeLookup, {
      filter: (a) => !!a.selected
    });
    return {
      width: Jo(t) ? t : null,
      height: Jo(n) ? n : null,
      userSelectionActive: e.userSelectionActive,
      transformString: `translate(${e.transform[0]}px,${e.transform[1]}px) scale(${e.transform[2]}) translate(${r}px,${o}px)`
    };
  };
  function hye({ onSelectionContextMenu: e, noPanClassName: t, disableKeyboardA11y: n }) {
    const r = _n(), { width: o, height: a, transformString: i, userSelectionActive: s } = Rt(mye, kn), u = l7(), c = C.useRef(null);
    if (C.useEffect(() => {
      n || c.current?.focus({
        preventScroll: !0
      });
    }, [n]), s7({
      nodeRef: c
    }), s || !o || !a)
      return null;
    const f = e ? (g) => {
      const h = r.getState().nodes.filter((y) => y.selected);
      e(g, h);
    } : void 0, p = (g) => {
      Object.prototype.hasOwnProperty.call(Mb, g.key) && (g.preventDefault(), u({
        direction: Mb[g.key],
        factor: g.shiftKey ? 4 : 1
      }));
    };
    return S.jsx("div", { className: Wn(["react-flow__nodesselection", "react-flow__container", t]), style: {
      transform: i
    }, children: S.jsx("div", { ref: c, className: "react-flow__nodesselection-rect", onContextMenu: f, tabIndex: n ? void 0 : -1, onKeyDown: n ? void 0 : p, style: {
      width: o,
      height: a
    } }) });
  }
  const u3 = typeof window < "u" ? window : void 0, gye = (e) => ({ nodesSelectionActive: e.nodesSelectionActive, userSelectionActive: e.userSelectionActive });
  function c7({ children: e, onPaneClick: t, onPaneMouseEnter: n, onPaneMouseMove: r, onPaneMouseLeave: o, onPaneContextMenu: a, onPaneScroll: i, paneClickDistance: s, deleteKeyCode: u, selectionKeyCode: c, selectionOnDrag: f, selectionMode: p, onSelectionStart: g, onSelectionEnd: h, multiSelectionKeyCode: y, panActivationKeyCode: b, zoomActivationKeyCode: v, elementsSelectable: w, zoomOnScroll: _, zoomOnPinch: k, panOnScroll: E, panOnScrollSpeed: P, panOnScrollMode: O, zoomOnDoubleClick: M, panOnDrag: I, defaultViewport: A, translateExtent: D, minZoom: F, maxZoom: j, preventScrolling: U, onSelectionContextMenu: $, noWheelClassName: q, noPanClassName: B, disableKeyboardA11y: G, onViewportChange: W, isControlledViewport: Y }) {
    const { nodesSelectionActive: z, userSelectionActive: L } = Rt(gye, kn), K = Li(c, { target: u3 }), T = Li(b, { target: u3 }), V = T || I, X = T || E, Q = f && V !== !0, ne = K || L || Q;
    return Yve({ deleteKeyCode: u, multiSelectionKeyCode: y }), S.jsx(Zve, { onPaneContextMenu: a, elementsSelectable: w, zoomOnScroll: _, zoomOnPinch: k, panOnScroll: X, panOnScrollSpeed: P, panOnScrollMode: O, zoomOnDoubleClick: M, panOnDrag: !K && V, defaultViewport: A, translateExtent: D, minZoom: F, maxZoom: j, zoomActivationKeyCode: v, preventScrolling: U, noWheelClassName: q, noPanClassName: B, onViewportChange: W, isControlledViewport: Y, paneClickDistance: s, selectionOnDrag: Q, children: S.jsxs(rye, { onSelectionStart: g, onSelectionEnd: h, onPaneClick: t, onPaneMouseEnter: n, onPaneMouseMove: r, onPaneMouseLeave: o, onPaneContextMenu: a, onPaneScroll: i, panOnDrag: V, isSelecting: !!ne, selectionMode: p, selectionKeyPressed: K, paneClickDistance: s, selectionOnDrag: Q, children: [e, z && S.jsx(hye, { onSelectionContextMenu: $, noPanClassName: B, disableKeyboardA11y: G })] }) });
  }
  c7.displayName = "FlowRenderer";
  const vye = C.memo(c7), yye = (e) => (t) => e ? vP(t.nodeLookup, { x: 0, y: 0, width: t.width, height: t.height }, t.transform, !0).map((n) => n.id) : Array.from(t.nodeLookup.keys());
  function bye(e) {
    return Rt(C.useCallback(yye(e), [e]), kn);
  }
  const wye = (e) => e.updateNodeInternals;
  function xye() {
    const e = Rt(wye), [t] = C.useState(() => typeof ResizeObserver > "u" ? null : new ResizeObserver((n) => {
      const r = /* @__PURE__ */ new Map();
      n.forEach((o) => {
        const a = o.target.getAttribute("data-id");
        r.set(a, {
          id: a,
          nodeElement: o.target,
          force: !0
        });
      }), e(r);
    }));
    return C.useEffect(() => () => {
      t?.disconnect();
    }, [t]), t;
  }
  function kye({ node: e, nodeType: t, hasDimensions: n, resizeObserver: r }) {
    const o = _n(), a = C.useRef(null), i = C.useRef(null), s = C.useRef(e.sourcePosition), u = C.useRef(e.targetPosition), c = C.useRef(t), f = n && !!e.internals.handleBounds;
    return C.useEffect(() => {
      a.current && !e.hidden && (!f || i.current !== a.current) && (i.current && r?.unobserve(i.current), r?.observe(a.current), i.current = a.current);
    }, [f, e.hidden]), C.useEffect(() => () => {
      i.current && (r?.unobserve(i.current), i.current = null);
    }, []), C.useEffect(() => {
      if (a.current) {
        const p = c.current !== t, g = s.current !== e.sourcePosition, h = u.current !== e.targetPosition;
        (p || g || h) && (c.current = t, s.current = e.sourcePosition, u.current = e.targetPosition, o.getState().updateNodeInternals(/* @__PURE__ */ new Map([[e.id, { id: e.id, nodeElement: a.current, force: !0 }]])));
      }
    }, [e.id, t, e.sourcePosition, e.targetPosition]), a;
  }
  function Sye({ id: e, onClick: t, onMouseEnter: n, onMouseMove: r, onMouseLeave: o, onContextMenu: a, onDoubleClick: i, nodesDraggable: s, elementsSelectable: u, nodesConnectable: c, nodesFocusable: f, resizeObserver: p, noDragClassName: g, noPanClassName: h, disableKeyboardA11y: y, rfId: b, nodeTypes: v, nodeClickDistance: w, onError: _ }) {
    const { node: k, internals: E, isParent: P } = Rt((te) => {
      const ae = te.nodeLookup.get(e), ce = te.parentLookup.has(e);
      return {
        node: ae,
        internals: ae.internals,
        isParent: ce
      };
    }, kn);
    let O = k.type || "default", M = v?.[O] || l3[O];
    M === void 0 && (_?.("003", Ka.error003(O)), O = "default", M = v?.default || l3.default);
    const I = !!(k.draggable || s && typeof k.draggable > "u"), A = !!(k.selectable || u && typeof k.selectable > "u"), D = !!(k.connectable || c && typeof k.connectable > "u"), F = !!(k.focusable || f && typeof k.focusable > "u"), j = _n(), U = IB(k), $ = kye({ node: k, nodeType: O, hasDimensions: U, resizeObserver: p }), q = s7({
      nodeRef: $,
      disabled: k.hidden || !I,
      noDragClassName: g,
      handleSelector: k.dragHandle,
      nodeId: e,
      isSelectable: A,
      nodeClickDistance: w
    }), B = l7();
    if (k.hidden)
      return null;
    const G = ns(k), W = pye(k), Y = A || I || t || n || r || o, z = n ? (te) => n(te, { ...E.userNode }) : void 0, L = r ? (te) => r(te, { ...E.userNode }) : void 0, K = o ? (te) => o(te, { ...E.userNode }) : void 0, T = a ? (te) => a(te, { ...E.userNode }) : void 0, V = i ? (te) => i(te, { ...E.userNode }) : void 0, X = (te) => {
      const { selectNodesOnDrag: ae, nodeDragThreshold: ce } = j.getState();
      A && (!ae || !I || ce > 0) && eE({
        id: e,
        store: j,
        nodeRef: $
      }), t && t(te, { ...E.userNode });
    }, Q = (te) => {
      if (!(DB(te.nativeEvent) || y)) {
        if (_B.includes(te.key) && A) {
          const ae = te.key === "Escape";
          eE({
            id: e,
            store: j,
            unselect: ae,
            nodeRef: $
          });
        } else if (I && k.selected && Object.prototype.hasOwnProperty.call(Mb, te.key)) {
          te.preventDefault();
          const { ariaLabelConfig: ae } = j.getState();
          j.setState({
            ariaLiveMessage: ae["node.a11yDescription.ariaLiveMessage"]({
              direction: te.key.replace("Arrow", "").toLowerCase(),
              x: ~~E.positionAbsolute.x,
              y: ~~E.positionAbsolute.y
            })
          }), B({
            direction: Mb[te.key],
            factor: te.shiftKey ? 4 : 1
          });
        }
      }
    }, ne = () => {
      if (y || !$.current?.matches(":focus-visible"))
        return;
      const { transform: te, width: ae, height: ce, autoPanOnNodeFocus: Z, setCenter: ee } = j.getState();
      Z && (vP(/* @__PURE__ */ new Map([[e, k]]), { x: 0, y: 0, width: ae, height: ce }, te, !0).length > 0 || ee(k.position.x + G.width / 2, k.position.y + G.height / 2, {
        zoom: te[2]
      }));
    };
    return S.jsx("div", { className: Wn([
      "react-flow__node",
      `react-flow__node-${O}`,
      {
        // this is overwritable by passing `nopan` as a class name
        [h]: I
      },
      k.className,
      {
        selected: k.selected,
        selectable: A,
        parent: P,
        draggable: I,
        dragging: q
      }
    ]), ref: $, style: {
      zIndex: E.z,
      transform: `translate(${E.positionAbsolute.x}px,${E.positionAbsolute.y}px)`,
      pointerEvents: Y ? "all" : "none",
      visibility: U ? "visible" : "hidden",
      ...k.style,
      ...W
    }, "data-id": e, "data-testid": `rf__node-${e}`, onMouseEnter: z, onMouseMove: L, onMouseLeave: K, onContextMenu: T, onClick: X, onDoubleClick: V, onKeyDown: F ? Q : void 0, tabIndex: F ? 0 : void 0, onFocus: F ? ne : void 0, role: k.ariaRole ?? (F ? "group" : void 0), "aria-roledescription": "node", "aria-describedby": y ? void 0 : `${e7}-${b}`, "aria-label": k.ariaLabel, ...k.domAttributes, children: S.jsx(aye, { value: e, children: S.jsx(M, { id: e, data: k.data, type: O, positionAbsoluteX: E.positionAbsolute.x, positionAbsoluteY: E.positionAbsolute.y, selected: k.selected ?? !1, selectable: A, draggable: I, deletable: k.deletable ?? !0, isConnectable: D, sourcePosition: k.sourcePosition, targetPosition: k.targetPosition, dragging: q, dragHandle: k.dragHandle, zIndex: E.z, parentId: k.parentId, ...G }) }) });
  }
  var _ye = C.memo(Sye);
  const Eye = (e) => ({
    nodesDraggable: e.nodesDraggable,
    nodesConnectable: e.nodesConnectable,
    nodesFocusable: e.nodesFocusable,
    elementsSelectable: e.elementsSelectable,
    onError: e.onError
  });
  function d7(e) {
    const { nodesDraggable: t, nodesConnectable: n, nodesFocusable: r, elementsSelectable: o, onError: a } = Rt(Eye, kn), i = bye(e.onlyRenderVisibleElements), s = xye();
    return S.jsx("div", { className: "react-flow__nodes", style: tx, children: i.map((u) => (
      /*
       * The split of responsibilities between NodeRenderer and
       * NodeComponentWrapper may appear weird. However, its designed to
       * minimize the cost of updates when individual nodes change.
       *
       * For example, when youre dragging a single node, that node gets
       * updated multiple times per second. If `NodeRenderer` were to update
       * every time, it would have to re-run the `nodes.map()` loop every
       * time. This gets pricey with hundreds of nodes, especially if every
       * loop cycle does more than just rendering a JSX element!
       *
       * As a result of this choice, we took the following implementation
       * decisions:
       * - NodeRenderer subscribes *only* to node IDs  and therefore
       *   rerender *only* when visible nodes are added or removed.
       * - NodeRenderer performs all operations the result of which can be
       *   shared between nodes (such as creating the `ResizeObserver`
       *   instance, or subscribing to `selector`). This means extra prop
       *   drilling into `NodeComponentWrapper`, but it means we need to run
       *   these operations only once  instead of once per node.
       * - Any operations that youd normally write inside `nodes.map` are
       *   moved into `NodeComponentWrapper`. This ensures they are
       *   memorized  so if `NodeRenderer` *has* to rerender, it only
       *   needs to regenerate the list of nodes, nothing else.
       */
      S.jsx(_ye, { id: u, nodeTypes: e.nodeTypes, nodeExtent: e.nodeExtent, onClick: e.onNodeClick, onMouseEnter: e.onNodeMouseEnter, onMouseMove: e.onNodeMouseMove, onMouseLeave: e.onNodeMouseLeave, onContextMenu: e.onNodeContextMenu, onDoubleClick: e.onNodeDoubleClick, noDragClassName: e.noDragClassName, noPanClassName: e.noPanClassName, rfId: e.rfId, disableKeyboardA11y: e.disableKeyboardA11y, resizeObserver: s, nodesDraggable: t, nodesConnectable: n, nodesFocusable: r, elementsSelectable: o, nodeClickDistance: e.nodeClickDistance, onError: a }, u)
    )) });
  }
  d7.displayName = "NodeRenderer";
  const Cye = C.memo(d7);
  function Pye(e) {
    return Rt(C.useCallback((t) => {
      if (!e)
        return t.edges.map((r) => r.id);
      const n = [];
      if (t.width && t.height)
        for (const r of t.edges) {
          const o = t.nodeLookup.get(r.source), a = t.nodeLookup.get(r.target);
          o && a && Ige({
            sourceNode: o,
            targetNode: a,
            width: t.width,
            height: t.height,
            transform: t.transform
          }) && n.push(r.id);
        }
      return n;
    }, [e]), kn);
  }
  const Oye = ({ color: e = "none", strokeWidth: t = 1 }) => {
    const n = {
      strokeWidth: t,
      ...e && { stroke: e }
    };
    return S.jsx("polyline", { className: "arrow", style: n, strokeLinecap: "round", fill: "none", strokeLinejoin: "round", points: "-5,-4 0,0 -5,4" });
  }, Nye = ({ color: e = "none", strokeWidth: t = 1 }) => {
    const n = {
      strokeWidth: t,
      ...e && { stroke: e, fill: e }
    };
    return S.jsx("polyline", { className: "arrowclosed", style: n, strokeLinecap: "round", strokeLinejoin: "round", points: "-5,-4 0,0 -5,4 -5,-4" });
  }, c3 = {
    [Pb.Arrow]: Oye,
    [Pb.ArrowClosed]: Nye
  };
  function Mye(e) {
    const t = _n();
    return C.useMemo(() => Object.prototype.hasOwnProperty.call(c3, e) ? c3[e] : (t.getState().onError?.("009", Ka.error009(e)), null), [e]);
  }
  const Rye = ({ id: e, type: t, color: n, width: r = 12.5, height: o = 12.5, markerUnits: a = "strokeWidth", strokeWidth: i, orient: s = "auto-start-reverse" }) => {
    const u = Mye(t);
    return u ? S.jsx("marker", { className: "react-flow__arrowhead", id: e, markerWidth: `${r}`, markerHeight: `${o}`, viewBox: "-10 -10 20 20", markerUnits: a, orient: s, refX: "0", refY: "0", children: S.jsx(u, { color: n, strokeWidth: i }) }) : null;
  }, f7 = ({ defaultColor: e, rfId: t }) => {
    const n = Rt((a) => a.edges), r = Rt((a) => a.defaultEdgeOptions), o = C.useMemo(() => Bge(n, {
      id: t,
      defaultColor: e,
      defaultMarkerStart: r?.markerStart,
      defaultMarkerEnd: r?.markerEnd
    }), [n, r, t, e]);
    return o.length ? S.jsx("svg", { className: "react-flow__marker", "aria-hidden": "true", children: S.jsx("defs", { children: o.map((a) => S.jsx(Rye, { id: a.id, type: a.type, color: a.color, width: a.width, height: a.height, markerUnits: a.markerUnits, strokeWidth: a.strokeWidth, orient: a.orient }, a.id)) }) }) : null;
  };
  f7.displayName = "MarkerDefinitions";
  var jye = C.memo(f7);
  function p7({ x: e, y: t, label: n, labelStyle: r, labelShowBg: o = !0, labelBgStyle: a, labelBgPadding: i = [2, 4], labelBgBorderRadius: s = 2, children: u, className: c, ...f }) {
    const [p, g] = C.useState({ x: 1, y: 0, width: 0, height: 0 }), h = Wn(["react-flow__edge-textwrapper", c]), y = C.useRef(null);
    return C.useEffect(() => {
      if (y.current) {
        const b = y.current.getBBox();
        g({
          x: b.x,
          y: b.y,
          width: b.width,
          height: b.height
        });
      }
    }, [n]), n ? S.jsxs("g", { transform: `translate(${e - p.width / 2} ${t - p.height / 2})`, className: h, visibility: p.width ? "visible" : "hidden", ...f, children: [o && S.jsx("rect", { width: p.width + 2 * i[0], x: -i[0], y: -i[1], height: p.height + 2 * i[1], className: "react-flow__edge-textbg", style: a, rx: s, ry: s }), S.jsx("text", { className: "react-flow__edge-text", y: p.height / 2, dy: "0.3em", ref: y, style: r, children: n }), u] }) : null;
  }
  p7.displayName = "EdgeText";
  const Iye = C.memo(p7);
  function ah({ path: e, labelX: t, labelY: n, label: r, labelStyle: o, labelShowBg: a, labelBgStyle: i, labelBgPadding: s, labelBgBorderRadius: u, interactionWidth: c = 20, ...f }) {
    return S.jsxs(S.Fragment, { children: [S.jsx("path", { ...f, d: e, fill: "none", className: Wn(["react-flow__edge-path", f.className]) }), c ? S.jsx("path", { d: e, fill: "none", strokeOpacity: 0, strokeWidth: c, className: "react-flow__edge-interaction" }) : null, r && Jo(t) && Jo(n) ? S.jsx(Iye, { x: t, y: n, label: r, labelStyle: o, labelShowBg: a, labelBgStyle: i, labelBgPadding: s, labelBgBorderRadius: u }) : null] });
  }
  function d3({ pos: e, x1: t, y1: n, x2: r, y2: o }) {
    return e === Ve.Left || e === Ve.Right ? [0.5 * (t + r), n] : [t, 0.5 * (n + o)];
  }
  function m7({ sourceX: e, sourceY: t, sourcePosition: n = Ve.Bottom, targetX: r, targetY: o, targetPosition: a = Ve.Top }) {
    const [i, s] = d3({
      pos: n,
      x1: e,
      y1: t,
      x2: r,
      y2: o
    }), [u, c] = d3({
      pos: a,
      x1: r,
      y1: o,
      x2: e,
      y2: t
    }), [f, p, g, h] = FB({
      sourceX: e,
      sourceY: t,
      targetX: r,
      targetY: o,
      sourceControlX: i,
      sourceControlY: s,
      targetControlX: u,
      targetControlY: c
    });
    return [
      `M${e},${t} C${i},${s} ${u},${c} ${r},${o}`,
      f,
      p,
      g,
      h
    ];
  }
  function h7(e) {
    return C.memo(({ id: t, sourceX: n, sourceY: r, targetX: o, targetY: a, sourcePosition: i, targetPosition: s, label: u, labelStyle: c, labelShowBg: f, labelBgStyle: p, labelBgPadding: g, labelBgBorderRadius: h, style: y, markerEnd: b, markerStart: v, interactionWidth: w }) => {
      const [_, k, E] = m7({
        sourceX: n,
        sourceY: r,
        sourcePosition: i,
        targetX: o,
        targetY: a,
        targetPosition: s
      }), P = e.isInternal ? void 0 : t;
      return S.jsx(ah, { id: P, path: _, labelX: k, labelY: E, label: u, labelStyle: c, labelShowBg: f, labelBgStyle: p, labelBgPadding: g, labelBgBorderRadius: h, style: y, markerEnd: b, markerStart: v, interactionWidth: w });
    });
  }
  const Aye = h7({ isInternal: !1 }), g7 = h7({ isInternal: !0 });
  Aye.displayName = "SimpleBezierEdge";
  g7.displayName = "SimpleBezierEdgeInternal";
  function v7(e) {
    return C.memo(({ id: t, sourceX: n, sourceY: r, targetX: o, targetY: a, label: i, labelStyle: s, labelShowBg: u, labelBgStyle: c, labelBgPadding: f, labelBgBorderRadius: p, style: g, sourcePosition: h = Ve.Bottom, targetPosition: y = Ve.Top, markerEnd: b, markerStart: v, pathOptions: w, interactionWidth: _ }) => {
      const [k, E, P] = Y2({
        sourceX: n,
        sourceY: r,
        sourcePosition: h,
        targetX: o,
        targetY: a,
        targetPosition: y,
        borderRadius: w?.borderRadius,
        offset: w?.offset,
        stepPosition: w?.stepPosition
      }), O = e.isInternal ? void 0 : t;
      return S.jsx(ah, { id: O, path: k, labelX: E, labelY: P, label: i, labelStyle: s, labelShowBg: u, labelBgStyle: c, labelBgPadding: f, labelBgBorderRadius: p, style: g, markerEnd: b, markerStart: v, interactionWidth: _ });
    });
  }
  const y7 = v7({ isInternal: !1 }), b7 = v7({ isInternal: !0 });
  y7.displayName = "SmoothStepEdge";
  b7.displayName = "SmoothStepEdgeInternal";
  function w7(e) {
    return C.memo(({ id: t, ...n }) => {
      const r = e.isInternal ? void 0 : t;
      return S.jsx(y7, { ...n, id: r, pathOptions: C.useMemo(() => ({ borderRadius: 0, offset: n.pathOptions?.offset }), [n.pathOptions?.offset]) });
    });
  }
  const $ye = w7({ isInternal: !1 }), x7 = w7({ isInternal: !0 });
  $ye.displayName = "StepEdge";
  x7.displayName = "StepEdgeInternal";
  function k7(e) {
    return C.memo(({ id: t, sourceX: n, sourceY: r, targetX: o, targetY: a, label: i, labelStyle: s, labelShowBg: u, labelBgStyle: c, labelBgPadding: f, labelBgBorderRadius: p, style: g, markerEnd: h, markerStart: y, interactionWidth: b }) => {
      const [v, w, _] = zB({ sourceX: n, sourceY: r, targetX: o, targetY: a }), k = e.isInternal ? void 0 : t;
      return S.jsx(ah, { id: k, path: v, labelX: w, labelY: _, label: i, labelStyle: s, labelShowBg: u, labelBgStyle: c, labelBgPadding: f, labelBgBorderRadius: p, style: g, markerEnd: h, markerStart: y, interactionWidth: b });
    });
  }
  const Dye = k7({ isInternal: !1 }), S7 = k7({ isInternal: !0 });
  Dye.displayName = "StraightEdge";
  S7.displayName = "StraightEdgeInternal";
  function _7(e) {
    return C.memo(({ id: t, sourceX: n, sourceY: r, targetX: o, targetY: a, sourcePosition: i = Ve.Bottom, targetPosition: s = Ve.Top, label: u, labelStyle: c, labelShowBg: f, labelBgStyle: p, labelBgPadding: g, labelBgBorderRadius: h, style: y, markerEnd: b, markerStart: v, pathOptions: w, interactionWidth: _ }) => {
      const [k, E, P] = wP({
        sourceX: n,
        sourceY: r,
        sourcePosition: i,
        targetX: o,
        targetY: a,
        targetPosition: s,
        curvature: w?.curvature
      }), O = e.isInternal ? void 0 : t;
      return S.jsx(ah, { id: O, path: k, labelX: E, labelY: P, label: u, labelStyle: c, labelShowBg: f, labelBgStyle: p, labelBgPadding: g, labelBgBorderRadius: h, style: y, markerEnd: b, markerStart: v, interactionWidth: _ });
    });
  }
  const Lye = _7({ isInternal: !1 }), E7 = _7({ isInternal: !0 });
  Lye.displayName = "BezierEdge";
  E7.displayName = "BezierEdgeInternal";
  const f3 = {
    default: E7,
    straight: S7,
    step: x7,
    smoothstep: b7,
    simplebezier: g7
  }, p3 = {
    sourceX: null,
    sourceY: null,
    targetX: null,
    targetY: null,
    sourcePosition: null,
    targetPosition: null
  }, Fye = (e, t, n) => n === Ve.Left ? e - t : n === Ve.Right ? e + t : e, Tye = (e, t, n) => n === Ve.Top ? e - t : n === Ve.Bottom ? e + t : e, m3 = "react-flow__edgeupdater";
  function h3({ position: e, centerX: t, centerY: n, radius: r = 10, onMouseDown: o, onMouseEnter: a, onMouseOut: i, type: s }) {
    return S.jsx("circle", { onMouseDown: o, onMouseEnter: a, onMouseOut: i, className: Wn([m3, `${m3}-${s}`]), cx: Fye(t, r, e), cy: Tye(n, r, e), r, stroke: "transparent", fill: "transparent" });
  }
  function zye({ isReconnectable: e, reconnectRadius: t, edge: n, sourceX: r, sourceY: o, targetX: a, targetY: i, sourcePosition: s, targetPosition: u, onReconnect: c, onReconnectStart: f, onReconnectEnd: p, setReconnecting: g, setUpdateHover: h }) {
    const y = _n(), b = (E, P) => {
      if (E.button !== 0)
        return;
      const { autoPanOnConnect: O, domNode: M, isValidConnection: I, connectionMode: A, connectionRadius: D, lib: F, onConnectStart: j, onConnectEnd: U, cancelConnection: $, nodeLookup: q, rfId: B, panBy: G, updateConnection: W } = y.getState(), Y = P.type === "target", z = (T, V) => {
        g(!1), p?.(T, n, P.type, V);
      }, L = (T) => c?.(n, T), K = (T, V) => {
        g(!0), f?.(E, n, P.type), j?.(T, V);
      };
      Z2.onPointerDown(E.nativeEvent, {
        autoPanOnConnect: O,
        connectionMode: A,
        connectionRadius: D,
        domNode: M,
        handleId: P.id,
        nodeId: P.nodeId,
        nodeLookup: q,
        isTarget: Y,
        edgeUpdaterType: P.type,
        lib: F,
        flowId: B,
        cancelConnection: $,
        panBy: G,
        isValidConnection: I,
        onConnect: L,
        onConnectStart: K,
        onConnectEnd: U,
        onReconnectEnd: z,
        updateConnection: W,
        getTransform: () => y.getState().transform,
        getFromHandle: () => y.getState().connection.fromHandle,
        dragThreshold: y.getState().connectionDragThreshold,
        handleDomNode: E.currentTarget
      });
    }, v = (E) => b(E, { nodeId: n.target, id: n.targetHandle ?? null, type: "target" }), w = (E) => b(E, { nodeId: n.source, id: n.sourceHandle ?? null, type: "source" }), _ = () => h(!0), k = () => h(!1);
    return S.jsxs(S.Fragment, { children: [(e === !0 || e === "source") && S.jsx(h3, { position: s, centerX: r, centerY: o, radius: t, onMouseDown: v, onMouseEnter: _, onMouseOut: k, type: "source" }), (e === !0 || e === "target") && S.jsx(h3, { position: u, centerX: a, centerY: i, radius: t, onMouseDown: w, onMouseEnter: _, onMouseOut: k, type: "target" })] });
  }
  function Bye({ id: e, edgesFocusable: t, edgesReconnectable: n, elementsSelectable: r, onClick: o, onDoubleClick: a, onContextMenu: i, onMouseEnter: s, onMouseMove: u, onMouseLeave: c, reconnectRadius: f, onReconnect: p, onReconnectStart: g, onReconnectEnd: h, rfId: y, edgeTypes: b, noPanClassName: v, onError: w, disableKeyboardA11y: _ }) {
    let k = Rt((ee) => ee.edgeLookup.get(e));
    const E = Rt((ee) => ee.defaultEdgeOptions);
    k = E ? { ...E, ...k } : k;
    let P = k.type || "default", O = b?.[P] || f3[P];
    O === void 0 && (w?.("011", Ka.error011(P)), P = "default", O = b?.default || f3.default);
    const M = !!(k.focusable || t && typeof k.focusable > "u"), I = typeof p < "u" && (k.reconnectable || n && typeof k.reconnectable > "u"), A = !!(k.selectable || r && typeof k.selectable > "u"), D = C.useRef(null), [F, j] = C.useState(!1), [U, $] = C.useState(!1), q = _n(), { zIndex: B, sourceX: G, sourceY: W, targetX: Y, targetY: z, sourcePosition: L, targetPosition: K } = Rt(C.useCallback((ee) => {
      const oe = ee.nodeLookup.get(k.source), le = ee.nodeLookup.get(k.target);
      if (!oe || !le)
        return {
          zIndex: k.zIndex,
          ...p3
        };
      const be = zge({
        id: e,
        sourceNode: oe,
        targetNode: le,
        sourceHandle: k.sourceHandle || null,
        targetHandle: k.targetHandle || null,
        connectionMode: ee.connectionMode,
        onError: w
      });
      return {
        zIndex: jge({
          selected: k.selected,
          zIndex: k.zIndex,
          sourceNode: oe,
          targetNode: le,
          elevateOnSelect: ee.elevateEdgesOnSelect,
          zIndexMode: ee.zIndexMode
        }),
        ...be || p3
      };
    }, [k.source, k.target, k.sourceHandle, k.targetHandle, k.selected, k.zIndex]), kn), T = C.useMemo(() => k.markerStart ? `url('#${J2(k.markerStart, y)}')` : void 0, [k.markerStart, y]), V = C.useMemo(() => k.markerEnd ? `url('#${J2(k.markerEnd, y)}')` : void 0, [k.markerEnd, y]);
    if (k.hidden || G === null || W === null || Y === null || z === null)
      return null;
    const X = (ee) => {
      const { addSelectedEdges: oe, unselectNodesAndEdges: le, multiSelectionActive: be } = q.getState();
      A && (q.setState({ nodesSelectionActive: !1 }), k.selected && be ? (le({ nodes: [], edges: [k] }), D.current?.blur()) : oe([e])), o && o(ee, k);
    }, Q = a ? (ee) => {
      a(ee, { ...k });
    } : void 0, ne = i ? (ee) => {
      i(ee, { ...k });
    } : void 0, te = s ? (ee) => {
      s(ee, { ...k });
    } : void 0, ae = u ? (ee) => {
      u(ee, { ...k });
    } : void 0, ce = c ? (ee) => {
      c(ee, { ...k });
    } : void 0, Z = (ee) => {
      if (!_ && _B.includes(ee.key) && A) {
        const { unselectNodesAndEdges: oe, addSelectedEdges: le } = q.getState();
        ee.key === "Escape" ? (D.current?.blur(), oe({ edges: [k] })) : le([e]);
      }
    };
    return S.jsx("svg", { style: { zIndex: B }, children: S.jsxs("g", { className: Wn([
      "react-flow__edge",
      `react-flow__edge-${P}`,
      k.className,
      v,
      {
        selected: k.selected,
        animated: k.animated,
        inactive: !A && !o,
        updating: F,
        selectable: A
      }
    ]), onClick: X, onDoubleClick: Q, onContextMenu: ne, onMouseEnter: te, onMouseMove: ae, onMouseLeave: ce, onKeyDown: M ? Z : void 0, tabIndex: M ? 0 : void 0, role: k.ariaRole ?? (M ? "group" : "img"), "aria-roledescription": "edge", "data-id": e, "data-testid": `rf__edge-${e}`, "aria-label": k.ariaLabel === null ? void 0 : k.ariaLabel || `Edge from ${k.source} to ${k.target}`, "aria-describedby": M ? `${t7}-${y}` : void 0, ref: D, ...k.domAttributes, children: [!U && S.jsx(O, { id: e, source: k.source, target: k.target, type: k.type, selected: k.selected, animated: k.animated, selectable: A, deletable: k.deletable ?? !0, label: k.label, labelStyle: k.labelStyle, labelShowBg: k.labelShowBg, labelBgStyle: k.labelBgStyle, labelBgPadding: k.labelBgPadding, labelBgBorderRadius: k.labelBgBorderRadius, sourceX: G, sourceY: W, targetX: Y, targetY: z, sourcePosition: L, targetPosition: K, data: k.data, style: k.style, sourceHandleId: k.sourceHandle, targetHandleId: k.targetHandle, markerStart: T, markerEnd: V, pathOptions: "pathOptions" in k ? k.pathOptions : void 0, interactionWidth: k.interactionWidth }), I && S.jsx(zye, { edge: k, isReconnectable: I, reconnectRadius: f, onReconnect: p, onReconnectStart: g, onReconnectEnd: h, sourceX: G, sourceY: W, targetX: Y, targetY: z, sourcePosition: L, targetPosition: K, setUpdateHover: j, setReconnecting: $ })] }) });
  }
  var Vye = C.memo(Bye);
  const Uye = (e) => ({
    edgesFocusable: e.edgesFocusable,
    edgesReconnectable: e.edgesReconnectable,
    elementsSelectable: e.elementsSelectable,
    connectionMode: e.connectionMode,
    onError: e.onError
  });
  function C7({ defaultMarkerColor: e, onlyRenderVisibleElements: t, rfId: n, edgeTypes: r, noPanClassName: o, onReconnect: a, onEdgeContextMenu: i, onEdgeMouseEnter: s, onEdgeMouseMove: u, onEdgeMouseLeave: c, onEdgeClick: f, reconnectRadius: p, onEdgeDoubleClick: g, onReconnectStart: h, onReconnectEnd: y, disableKeyboardA11y: b }) {
    const { edgesFocusable: v, edgesReconnectable: w, elementsSelectable: _, onError: k } = Rt(Uye, kn), E = Pye(t);
    return S.jsxs("div", { className: "react-flow__edges", children: [S.jsx(jye, { defaultColor: e, rfId: n }), E.map((P) => S.jsx(Vye, { id: P, edgesFocusable: v, edgesReconnectable: w, elementsSelectable: _, noPanClassName: o, onReconnect: a, onContextMenu: i, onMouseEnter: s, onMouseMove: u, onMouseLeave: c, onClick: f, reconnectRadius: p, onDoubleClick: g, onReconnectStart: h, onReconnectEnd: y, rfId: n, onError: k, edgeTypes: r, disableKeyboardA11y: b }, P))] });
  }
  C7.displayName = "EdgeRenderer";
  const Hye = C.memo(C7), Wye = (e) => `translate(${e.transform[0]}px,${e.transform[1]}px) scale(${e.transform[2]})`;
  function qye({ children: e }) {
    const t = Rt(Wye);
    return S.jsx("div", { className: "react-flow__viewport xyflow__viewport react-flow__container", style: { transform: t }, children: e });
  }
  function Kye(e) {
    const t = ku(), n = C.useRef(!1);
    C.useEffect(() => {
      !n.current && t.viewportInitialized && e && (setTimeout(() => e(t), 1), n.current = !0);
    }, [e, t.viewportInitialized]);
  }
  const Gye = (e) => e.panZoom?.syncViewport;
  function Xye(e) {
    const t = Rt(Gye), n = _n();
    return C.useEffect(() => {
      e && (t?.(e), n.setState({ transform: [e.x, e.y, e.zoom] }));
    }, [e, t]), null;
  }
  function Yye(e) {
    return e.connection.inProgress ? { ...e.connection, to: oh(e.connection.to, e.transform) } : { ...e.connection };
  }
  function Jye(e) {
    return Yye;
  }
  function Qye(e) {
    const t = Jye();
    return Rt(t, kn);
  }
  const Zye = (e) => ({
    nodesConnectable: e.nodesConnectable,
    isValid: e.connection.isValid,
    inProgress: e.connection.inProgress,
    width: e.width,
    height: e.height
  });
  function ebe({ containerStyle: e, style: t, type: n, component: r }) {
    const { nodesConnectable: o, width: a, height: i, isValid: s, inProgress: u } = Rt(Zye, kn);
    return a && o && u ? S.jsx("svg", { style: e, width: a, height: i, className: "react-flow__connectionline react-flow__container", children: S.jsx("g", { className: Wn(["react-flow__connection", PB(s)]), children: S.jsx(P7, { style: t, type: n, CustomComponent: r, isValid: s }) }) }) : null;
  }
  const P7 = ({ style: e, type: t = Ws.Bezier, CustomComponent: n, isValid: r }) => {
    const { inProgress: o, from: a, fromNode: i, fromHandle: s, fromPosition: u, to: c, toNode: f, toHandle: p, toPosition: g, pointer: h } = Qye();
    if (!o)
      return;
    if (n)
      return S.jsx(n, { connectionLineType: t, connectionLineStyle: e, fromNode: i, fromHandle: s, fromX: a.x, fromY: a.y, toX: c.x, toY: c.y, fromPosition: u, toPosition: g, connectionStatus: PB(r), toNode: f, toHandle: p, pointer: h });
    let y = "";
    const b = {
      sourceX: a.x,
      sourceY: a.y,
      sourcePosition: u,
      targetX: c.x,
      targetY: c.y,
      targetPosition: g
    };
    switch (t) {
      case Ws.Bezier:
        [y] = wP(b);
        break;
      case Ws.SimpleBezier:
        [y] = m7(b);
        break;
      case Ws.Step:
        [y] = Y2({
          ...b,
          borderRadius: 0
        });
        break;
      case Ws.SmoothStep:
        [y] = Y2(b);
        break;
      default:
        [y] = zB(b);
    }
    return S.jsx("path", { d: y, fill: "none", className: "react-flow__connection-path", style: e });
  };
  P7.displayName = "ConnectionLine";
  const tbe = {};
  function g3(e = tbe) {
    C.useRef(e), _n(), C.useEffect(() => {
    }, [e]);
  }
  function nbe() {
    _n(), C.useRef(!1), C.useEffect(() => {
    }, []);
  }
  function O7({ nodeTypes: e, edgeTypes: t, onInit: n, onNodeClick: r, onEdgeClick: o, onNodeDoubleClick: a, onEdgeDoubleClick: i, onNodeMouseEnter: s, onNodeMouseMove: u, onNodeMouseLeave: c, onNodeContextMenu: f, onSelectionContextMenu: p, onSelectionStart: g, onSelectionEnd: h, connectionLineType: y, connectionLineStyle: b, connectionLineComponent: v, connectionLineContainerStyle: w, selectionKeyCode: _, selectionOnDrag: k, selectionMode: E, multiSelectionKeyCode: P, panActivationKeyCode: O, zoomActivationKeyCode: M, deleteKeyCode: I, onlyRenderVisibleElements: A, elementsSelectable: D, defaultViewport: F, translateExtent: j, minZoom: U, maxZoom: $, preventScrolling: q, defaultMarkerColor: B, zoomOnScroll: G, zoomOnPinch: W, panOnScroll: Y, panOnScrollSpeed: z, panOnScrollMode: L, zoomOnDoubleClick: K, panOnDrag: T, onPaneClick: V, onPaneMouseEnter: X, onPaneMouseMove: Q, onPaneMouseLeave: ne, onPaneScroll: te, onPaneContextMenu: ae, paneClickDistance: ce, nodeClickDistance: Z, onEdgeContextMenu: ee, onEdgeMouseEnter: oe, onEdgeMouseMove: le, onEdgeMouseLeave: be, reconnectRadius: ke, onReconnect: De, onReconnectStart: ze, onReconnectEnd: Ue, noDragClassName: He, noWheelClassName: Pe, noPanClassName: It, disableKeyboardA11y: Xe, nodeExtent: Ee, rfId: _e, viewport: ie, onViewportChange: me }) {
    return g3(e), g3(t), nbe(), Kye(n), Xye(ie), S.jsx(vye, { onPaneClick: V, onPaneMouseEnter: X, onPaneMouseMove: Q, onPaneMouseLeave: ne, onPaneContextMenu: ae, onPaneScroll: te, paneClickDistance: ce, deleteKeyCode: I, selectionKeyCode: _, selectionOnDrag: k, selectionMode: E, onSelectionStart: g, onSelectionEnd: h, multiSelectionKeyCode: P, panActivationKeyCode: O, zoomActivationKeyCode: M, elementsSelectable: D, zoomOnScroll: G, zoomOnPinch: W, zoomOnDoubleClick: K, panOnScroll: Y, panOnScrollSpeed: z, panOnScrollMode: L, panOnDrag: T, defaultViewport: F, translateExtent: j, minZoom: U, maxZoom: $, onSelectionContextMenu: p, preventScrolling: q, noDragClassName: He, noWheelClassName: Pe, noPanClassName: It, disableKeyboardA11y: Xe, onViewportChange: me, isControlledViewport: !!ie, children: S.jsxs(qye, { children: [S.jsx(Hye, { edgeTypes: t, onEdgeClick: o, onEdgeDoubleClick: i, onReconnect: De, onReconnectStart: ze, onReconnectEnd: Ue, onlyRenderVisibleElements: A, onEdgeContextMenu: ee, onEdgeMouseEnter: oe, onEdgeMouseMove: le, onEdgeMouseLeave: be, reconnectRadius: ke, defaultMarkerColor: B, noPanClassName: It, disableKeyboardA11y: Xe, rfId: _e }), S.jsx(ebe, { style: b, type: y, component: v, containerStyle: w }), S.jsx("div", { className: "react-flow__edgelabel-renderer" }), S.jsx(Cye, { nodeTypes: e, onNodeClick: r, onNodeDoubleClick: a, onNodeMouseEnter: s, onNodeMouseMove: u, onNodeMouseLeave: c, onNodeContextMenu: f, nodeClickDistance: Z, onlyRenderVisibleElements: A, noPanClassName: It, noDragClassName: He, disableKeyboardA11y: Xe, nodeExtent: Ee, rfId: _e }), S.jsx("div", { className: "react-flow__viewport-portal" })] }) });
  }
  O7.displayName = "GraphView";
  const rbe = C.memo(O7), v3 = ({ nodes: e, edges: t, defaultNodes: n, defaultEdges: r, width: o, height: a, fitView: i, fitViewOptions: s, minZoom: u = 0.5, maxZoom: c = 2, nodeOrigin: f, nodeExtent: p, zIndexMode: g = "basic" } = {}) => {
    const h = /* @__PURE__ */ new Map(), y = /* @__PURE__ */ new Map(), b = /* @__PURE__ */ new Map(), v = /* @__PURE__ */ new Map(), w = r ?? t ?? [], _ = n ?? e ?? [], k = f ?? [0, 0], E = p ?? lm;
    UB(b, v, w);
    const P = Q2(_, h, y, {
      nodeOrigin: k,
      nodeExtent: E,
      zIndexMode: g
    });
    let O = [0, 0, 1];
    if (i && o && a) {
      const M = nh(h, {
        filter: (F) => !!((F.width || F.initialWidth) && (F.height || F.initialHeight))
      }), { x: I, y: A, zoom: D } = yP(M, o, a, u, c, s?.padding ?? 0.1);
      O = [I, A, D];
    }
    return {
      rfId: "1",
      width: o ?? 0,
      height: a ?? 0,
      transform: O,
      nodes: _,
      nodesInitialized: P,
      nodeLookup: h,
      parentLookup: y,
      edges: w,
      edgeLookup: v,
      connectionLookup: b,
      onNodesChange: null,
      onEdgesChange: null,
      hasDefaultNodes: n !== void 0,
      hasDefaultEdges: r !== void 0,
      panZoom: null,
      minZoom: u,
      maxZoom: c,
      translateExtent: lm,
      nodeExtent: E,
      nodesSelectionActive: !1,
      userSelectionActive: !1,
      userSelectionRect: null,
      connectionMode: wd.Strict,
      domNode: null,
      paneDragging: !1,
      noPanClassName: "nopan",
      nodeOrigin: k,
      nodeDragThreshold: 1,
      connectionDragThreshold: 1,
      snapGrid: [15, 15],
      snapToGrid: !1,
      nodesDraggable: !0,
      nodesConnectable: !0,
      nodesFocusable: !0,
      edgesFocusable: !0,
      edgesReconnectable: !0,
      elementsSelectable: !0,
      elevateNodesOnSelect: !0,
      elevateEdgesOnSelect: !0,
      selectNodesOnDrag: !0,
      multiSelectionActive: !1,
      fitViewQueued: i ?? !1,
      fitViewOptions: s,
      fitViewResolver: null,
      connection: { ...CB },
      connectionClickStartHandle: null,
      connectOnClick: !0,
      ariaLiveMessage: "",
      autoPanOnConnect: !0,
      autoPanOnNodeDrag: !0,
      autoPanOnNodeFocus: !0,
      autoPanSpeed: 15,
      connectionRadius: 20,
      onError: Cge,
      isValidConnection: void 0,
      onSelectionChangeHandlers: [],
      lib: "react",
      debug: !1,
      ariaLabelConfig: EB,
      zIndexMode: g,
      onNodesChangeMiddlewareMap: /* @__PURE__ */ new Map(),
      onEdgesChangeMiddlewareMap: /* @__PURE__ */ new Map()
    };
  }, obe = ({ nodes: e, edges: t, defaultNodes: n, defaultEdges: r, width: o, height: a, fitView: i, fitViewOptions: s, minZoom: u, maxZoom: c, nodeOrigin: f, nodeExtent: p, zIndexMode: g }) => kve((h, y) => {
    async function b() {
      const { nodeLookup: v, panZoom: w, fitViewOptions: _, fitViewResolver: k, width: E, height: P, minZoom: O, maxZoom: M } = y();
      w && (await _ge({
        nodes: v,
        width: E,
        height: P,
        panZoom: w,
        minZoom: O,
        maxZoom: M
      }, _), k?.resolve(!0), h({ fitViewResolver: null }));
    }
    return {
      ...v3({
        nodes: e,
        edges: t,
        width: o,
        height: a,
        fitView: i,
        fitViewOptions: s,
        minZoom: u,
        maxZoom: c,
        nodeOrigin: f,
        nodeExtent: p,
        defaultNodes: n,
        defaultEdges: r,
        zIndexMode: g
      }),
      setNodes: (v) => {
        const { nodeLookup: w, parentLookup: _, nodeOrigin: k, elevateNodesOnSelect: E, fitViewQueued: P, zIndexMode: O } = y(), M = Q2(v, w, _, {
          nodeOrigin: k,
          nodeExtent: p,
          elevateNodesOnSelect: E,
          checkEquality: !0,
          zIndexMode: O
        });
        P && M ? (b(), h({ nodes: v, nodesInitialized: M, fitViewQueued: !1, fitViewOptions: void 0 })) : h({ nodes: v, nodesInitialized: M });
      },
      setEdges: (v) => {
        const { connectionLookup: w, edgeLookup: _ } = y();
        UB(w, _, v), h({ edges: v });
      },
      setDefaultNodesAndEdges: (v, w) => {
        if (v) {
          const { setNodes: _ } = y();
          _(v), h({ hasDefaultNodes: !0 });
        }
        if (w) {
          const { setEdges: _ } = y();
          _(w), h({ hasDefaultEdges: !0 });
        }
      },
      /*
       * Every node gets registerd at a ResizeObserver. Whenever a node
       * changes its dimensions, this function is called to measure the
       * new dimensions and update the nodes.
       */
      updateNodeInternals: (v) => {
        const { triggerNodeChanges: w, nodeLookup: _, parentLookup: k, domNode: E, nodeOrigin: P, nodeExtent: O, debug: M, fitViewQueued: I, zIndexMode: A } = y(), { changes: D, updatedInternals: F } = Gge(v, _, k, E, P, O, A);
        F && (Hge(_, k, { nodeOrigin: P, nodeExtent: O, zIndexMode: A }), I ? (b(), h({ fitViewQueued: !1, fitViewOptions: void 0 })) : h({}), D?.length > 0 && (M && console.log("React Flow: trigger node changes", D), w?.(D)));
      },
      updateNodePositions: (v, w = !1) => {
        const _ = [];
        let k = [];
        const { nodeLookup: E, triggerNodeChanges: P, connection: O, updateConnection: M, onNodesChangeMiddlewareMap: I } = y();
        for (const [A, D] of v) {
          const F = E.get(A), j = !!(F?.expandParent && F?.parentId && D?.position), U = {
            id: A,
            type: "position",
            position: j ? {
              x: Math.max(0, D.position.x),
              y: Math.max(0, D.position.y)
            } : D.position,
            dragging: w
          };
          if (F && O.inProgress && O.fromNode.id === F.id) {
            const $ = hu(F, O.fromHandle, Ve.Left, !0);
            M({ ...O, from: $ });
          }
          j && F.parentId && _.push({
            id: A,
            parentId: F.parentId,
            rect: {
              ...D.internals.positionAbsolute,
              width: D.measured.width ?? 0,
              height: D.measured.height ?? 0
            }
          }), k.push(U);
        }
        if (_.length > 0) {
          const { parentLookup: A, nodeOrigin: D } = y(), F = EP(_, E, A, D);
          k.push(...F);
        }
        for (const A of I.values())
          k = A(k);
        P(k);
      },
      triggerNodeChanges: (v) => {
        const { onNodesChange: w, setNodes: _, nodes: k, hasDefaultNodes: E, debug: P } = y();
        if (v?.length) {
          if (E) {
            const O = CP(v, k);
            _(O);
          }
          P && console.log("React Flow: trigger node changes", v), w?.(v);
        }
      },
      triggerEdgeChanges: (v) => {
        const { onEdgesChange: w, setEdges: _, edges: k, hasDefaultEdges: E, debug: P } = y();
        if (v?.length) {
          if (E) {
            const O = o7(v, k);
            _(O);
          }
          P && console.log("React Flow: trigger edge changes", v), w?.(v);
        }
      },
      addSelectedNodes: (v) => {
        const { multiSelectionActive: w, edgeLookup: _, nodeLookup: k, triggerNodeChanges: E, triggerEdgeChanges: P } = y();
        if (w) {
          const O = v.map((M) => Xl(M, !0));
          E(O);
          return;
        }
        E(Gc(k, /* @__PURE__ */ new Set([...v]), !0)), P(Gc(_));
      },
      addSelectedEdges: (v) => {
        const { multiSelectionActive: w, edgeLookup: _, nodeLookup: k, triggerNodeChanges: E, triggerEdgeChanges: P } = y();
        if (w) {
          const O = v.map((M) => Xl(M, !0));
          P(O);
          return;
        }
        P(Gc(_, /* @__PURE__ */ new Set([...v]))), E(Gc(k, /* @__PURE__ */ new Set(), !0));
      },
      unselectNodesAndEdges: ({ nodes: v, edges: w } = {}) => {
        const { edges: _, nodes: k, nodeLookup: E, triggerNodeChanges: P, triggerEdgeChanges: O } = y(), M = v || k, I = w || _, A = M.map((F) => {
          const j = E.get(F.id);
          return j && (j.selected = !1), Xl(F.id, !1);
        }), D = I.map((F) => Xl(F.id, !1));
        P(A), O(D);
      },
      setMinZoom: (v) => {
        const { panZoom: w, maxZoom: _ } = y();
        w?.setScaleExtent([v, _]), h({ minZoom: v });
      },
      setMaxZoom: (v) => {
        const { panZoom: w, minZoom: _ } = y();
        w?.setScaleExtent([_, v]), h({ maxZoom: v });
      },
      setTranslateExtent: (v) => {
        y().panZoom?.setTranslateExtent(v), h({ translateExtent: v });
      },
      resetSelectedElements: () => {
        const { edges: v, nodes: w, triggerNodeChanges: _, triggerEdgeChanges: k, elementsSelectable: E } = y();
        if (!E)
          return;
        const P = w.reduce((M, I) => I.selected ? [...M, Xl(I.id, !1)] : M, []), O = v.reduce((M, I) => I.selected ? [...M, Xl(I.id, !1)] : M, []);
        _(P), k(O);
      },
      setNodeExtent: (v) => {
        const { nodes: w, nodeLookup: _, parentLookup: k, nodeOrigin: E, elevateNodesOnSelect: P, nodeExtent: O, zIndexMode: M } = y();
        v[0][0] === O[0][0] && v[0][1] === O[0][1] && v[1][0] === O[1][0] && v[1][1] === O[1][1] || (Q2(w, _, k, {
          nodeOrigin: E,
          nodeExtent: v,
          elevateNodesOnSelect: P,
          checkEquality: !1,
          zIndexMode: M
        }), h({ nodeExtent: v }));
      },
      panBy: (v) => {
        const { transform: w, width: _, height: k, panZoom: E, translateExtent: P } = y();
        return Xge({ delta: v, panZoom: E, transform: w, translateExtent: P, width: _, height: k });
      },
      setCenter: async (v, w, _) => {
        const { width: k, height: E, maxZoom: P, panZoom: O } = y();
        if (!O)
          return Promise.resolve(!1);
        const M = typeof _?.zoom < "u" ? _.zoom : P;
        return await O.setViewport({
          x: k / 2 - v * M,
          y: E / 2 - w * M,
          zoom: M
        }, { duration: _?.duration, ease: _?.ease, interpolate: _?.interpolate }), Promise.resolve(!0);
      },
      cancelConnection: () => {
        h({
          connection: { ...CB }
        });
      },
      updateConnection: (v) => {
        h({ connection: v });
      },
      reset: () => h({ ...v3() })
    };
  }, Object.is);
  function abe({ initialNodes: e, initialEdges: t, defaultNodes: n, defaultEdges: r, initialWidth: o, initialHeight: a, initialMinZoom: i, initialMaxZoom: s, initialFitViewOptions: u, fitView: c, nodeOrigin: f, nodeExtent: p, zIndexMode: g, children: h }) {
    const [y] = C.useState(() => obe({
      nodes: e,
      edges: t,
      defaultNodes: n,
      defaultEdges: r,
      width: o,
      height: a,
      fitView: c,
      minZoom: i,
      maxZoom: s,
      fitViewOptions: u,
      nodeOrigin: f,
      nodeExtent: p,
      zIndexMode: g
    }));
    return S.jsx(Sve, { value: y, children: S.jsx(qve, { children: h }) });
  }
  function ibe({ children: e, nodes: t, edges: n, defaultNodes: r, defaultEdges: o, width: a, height: i, fitView: s, fitViewOptions: u, minZoom: c, maxZoom: f, nodeOrigin: p, nodeExtent: g, zIndexMode: h }) {
    return C.useContext(Zw) ? S.jsx(S.Fragment, { children: e }) : S.jsx(abe, { initialNodes: t, initialEdges: n, defaultNodes: r, defaultEdges: o, initialWidth: a, initialHeight: i, fitView: s, initialFitViewOptions: u, initialMinZoom: c, initialMaxZoom: f, nodeOrigin: p, nodeExtent: g, zIndexMode: h, children: e });
  }
  const sbe = {
    width: "100%",
    height: "100%",
    overflow: "hidden",
    position: "relative",
    zIndex: 0
  };
  function lbe({ nodes: e, edges: t, defaultNodes: n, defaultEdges: r, className: o, nodeTypes: a, edgeTypes: i, onNodeClick: s, onEdgeClick: u, onInit: c, onMove: f, onMoveStart: p, onMoveEnd: g, onConnect: h, onConnectStart: y, onConnectEnd: b, onClickConnectStart: v, onClickConnectEnd: w, onNodeMouseEnter: _, onNodeMouseMove: k, onNodeMouseLeave: E, onNodeContextMenu: P, onNodeDoubleClick: O, onNodeDragStart: M, onNodeDrag: I, onNodeDragStop: A, onNodesDelete: D, onEdgesDelete: F, onDelete: j, onSelectionChange: U, onSelectionDragStart: $, onSelectionDrag: q, onSelectionDragStop: B, onSelectionContextMenu: G, onSelectionStart: W, onSelectionEnd: Y, onBeforeDelete: z, connectionMode: L, connectionLineType: K = Ws.Bezier, connectionLineStyle: T, connectionLineComponent: V, connectionLineContainerStyle: X, deleteKeyCode: Q = "Backspace", selectionKeyCode: ne = "Shift", selectionOnDrag: te = !1, selectionMode: ae = um.Full, panActivationKeyCode: ce = "Space", multiSelectionKeyCode: Z = dm() ? "Meta" : "Control", zoomActivationKeyCode: ee = dm() ? "Meta" : "Control", snapToGrid: oe, snapGrid: le, onlyRenderVisibleElements: be = !1, selectNodesOnDrag: ke, nodesDraggable: De, autoPanOnNodeFocus: ze, nodesConnectable: Ue, nodesFocusable: He, nodeOrigin: Pe = n7, edgesFocusable: It, edgesReconnectable: Xe, elementsSelectable: Ee = !0, defaultViewport: _e = Dve, minZoom: ie = 0.5, maxZoom: me = 2, translateExtent: Se = lm, preventScrolling: je = !0, nodeExtent: Ae, defaultMarkerColor: vt = "#b1b1b7", zoomOnScroll: yt = !0, zoomOnPinch: At = !0, panOnScroll: qt = !1, panOnScrollSpeed: Mn = 0.5, panOnScrollMode: Re = au.Free, zoomOnDoubleClick: bt = !0, panOnDrag: Ct = !0, onPaneClick: Rr, onPaneMouseEnter: Fo, onPaneMouseMove: on, onPaneMouseLeave: bn, onPaneScroll: Kr, onPaneContextMenu: To, paneClickDistance: tr = 1, nodeClickDistance: Ux = 0, children: Eh, onReconnect: Yd, onReconnectStart: bl, onReconnectEnd: Hx, onEdgeContextMenu: Ch, onEdgeDoubleClick: Ph, onEdgeMouseEnter: Oh, onEdgeMouseMove: Jd, onEdgeMouseLeave: Qd, reconnectRadius: Nh = 10, onNodesChange: Mh, onEdgesChange: da, noDragClassName: qn = "nodrag", noWheelClassName: pr = "nowheel", noPanClassName: oi = "nopan", fitView: Du, fitViewOptions: Rh, connectOnClick: Wx, attributionPosition: jh, proOptions: wl, defaultEdgeOptions: Zd, elevateNodesOnSelect: ls = !0, elevateEdgesOnSelect: us = !1, disableKeyboardA11y: cs = !1, autoPanOnConnect: ds, autoPanOnNodeDrag: $n, autoPanSpeed: Ih, connectionRadius: Ah, isValidConnection: ai, onError: fs, style: qx, id: ef, nodeDragThreshold: $h, connectionDragThreshold: Kx, viewport: Lu, onViewportChange: Fu, width: zo, height: jr, colorMode: Dh = "light", debug: Gx, onScroll: Tu, ariaLabelConfig: Lh, zIndexMode: xl = "basic", ...Xx }, Gr) {
    const kl = ef || "1", Fh = zve(Dh), tf = C.useCallback((ii) => {
      ii.currentTarget.scrollTo({ top: 0, left: 0, behavior: "instant" }), Tu?.(ii);
    }, [Tu]);
    return S.jsx("div", { "data-testid": "rf__wrapper", ...Xx, onScroll: tf, style: { ...qx, ...sbe }, ref: Gr, className: Wn(["react-flow", o, Fh]), id: ef, role: "application", children: S.jsxs(ibe, { nodes: e, edges: t, width: zo, height: jr, fitView: Du, fitViewOptions: Rh, minZoom: ie, maxZoom: me, nodeOrigin: Pe, nodeExtent: Ae, zIndexMode: xl, children: [S.jsx(rbe, { onInit: c, onNodeClick: s, onEdgeClick: u, onNodeMouseEnter: _, onNodeMouseMove: k, onNodeMouseLeave: E, onNodeContextMenu: P, onNodeDoubleClick: O, nodeTypes: a, edgeTypes: i, connectionLineType: K, connectionLineStyle: T, connectionLineComponent: V, connectionLineContainerStyle: X, selectionKeyCode: ne, selectionOnDrag: te, selectionMode: ae, deleteKeyCode: Q, multiSelectionKeyCode: Z, panActivationKeyCode: ce, zoomActivationKeyCode: ee, onlyRenderVisibleElements: be, defaultViewport: _e, translateExtent: Se, minZoom: ie, maxZoom: me, preventScrolling: je, zoomOnScroll: yt, zoomOnPinch: At, zoomOnDoubleClick: bt, panOnScroll: qt, panOnScrollSpeed: Mn, panOnScrollMode: Re, panOnDrag: Ct, onPaneClick: Rr, onPaneMouseEnter: Fo, onPaneMouseMove: on, onPaneMouseLeave: bn, onPaneScroll: Kr, onPaneContextMenu: To, paneClickDistance: tr, nodeClickDistance: Ux, onSelectionContextMenu: G, onSelectionStart: W, onSelectionEnd: Y, onReconnect: Yd, onReconnectStart: bl, onReconnectEnd: Hx, onEdgeContextMenu: Ch, onEdgeDoubleClick: Ph, onEdgeMouseEnter: Oh, onEdgeMouseMove: Jd, onEdgeMouseLeave: Qd, reconnectRadius: Nh, defaultMarkerColor: vt, noDragClassName: qn, noWheelClassName: pr, noPanClassName: oi, rfId: kl, disableKeyboardA11y: cs, nodeExtent: Ae, viewport: Lu, onViewportChange: Fu }), S.jsx(Tve, { nodes: e, edges: t, defaultNodes: n, defaultEdges: r, onConnect: h, onConnectStart: y, onConnectEnd: b, onClickConnectStart: v, onClickConnectEnd: w, nodesDraggable: De, autoPanOnNodeFocus: ze, nodesConnectable: Ue, nodesFocusable: He, edgesFocusable: It, edgesReconnectable: Xe, elementsSelectable: Ee, elevateNodesOnSelect: ls, elevateEdgesOnSelect: us, minZoom: ie, maxZoom: me, nodeExtent: Ae, onNodesChange: Mh, onEdgesChange: da, snapToGrid: oe, snapGrid: le, connectionMode: L, translateExtent: Se, connectOnClick: Wx, defaultEdgeOptions: Zd, fitView: Du, fitViewOptions: Rh, onNodesDelete: D, onEdgesDelete: F, onDelete: j, onNodeDragStart: M, onNodeDrag: I, onNodeDragStop: A, onSelectionDrag: q, onSelectionDragStart: $, onSelectionDragStop: B, onMove: f, onMoveStart: p, onMoveEnd: g, noPanClassName: oi, nodeOrigin: Pe, rfId: kl, autoPanOnConnect: ds, autoPanOnNodeDrag: $n, autoPanSpeed: Ih, onError: fs, connectionRadius: Ah, isValidConnection: ai, selectNodesOnDrag: ke, nodeDragThreshold: $h, connectionDragThreshold: Kx, onBeforeDelete: z, debug: Gx, ariaLabelConfig: Lh, zIndexMode: xl }), S.jsx($ve, { onSelectionChange: U }), Eh, S.jsx(Mve, { proOptions: wl, position: jh }), S.jsx(Nve, { rfId: kl, disableKeyboardA11y: cs })] }) });
  }
  var ube = a7(lbe);
  function cbe({ dimensions: e, lineWidth: t, variant: n, className: r }) {
    return S.jsx("path", { strokeWidth: t, d: `M${e[0] / 2} 0 V${e[1]} M0 ${e[1] / 2} H${e[0]}`, className: Wn(["react-flow__background-pattern", n, r]) });
  }
  function dbe({ radius: e, className: t }) {
    return S.jsx("circle", { cx: e, cy: e, r: e, className: Wn(["react-flow__background-pattern", "dots", t]) });
  }
  var Cr;
  (function(e) {
    e.Lines = "lines", e.Dots = "dots", e.Cross = "cross";
  })(Cr || (Cr = {}));
  const fbe = {
    [Cr.Dots]: 1,
    [Cr.Lines]: 1,
    [Cr.Cross]: 6
  }, pbe = (e) => ({ transform: e.transform, patternId: `pattern-${e.rfId}` });
  function N7({
    id: e,
    variant: t = Cr.Dots,
    // only used for dots and cross
    gap: n = 20,
    // only used for lines and cross
    size: r,
    lineWidth: o = 1,
    offset: a = 0,
    color: i,
    bgColor: s,
    style: u,
    className: c,
    patternClassName: f
  }) {
    const p = C.useRef(null), { transform: g, patternId: h } = Rt(pbe, kn), y = r || fbe[t], b = t === Cr.Dots, v = t === Cr.Cross, w = Array.isArray(n) ? n : [n, n], _ = [w[0] * g[2] || 1, w[1] * g[2] || 1], k = y * g[2], E = Array.isArray(a) ? a : [a, a], P = v ? [k, k] : _, O = [
      E[0] * g[2] || 1 + P[0] / 2,
      E[1] * g[2] || 1 + P[1] / 2
    ], M = `${h}${e || ""}`;
    return S.jsxs("svg", { className: Wn(["react-flow__background", c]), style: {
      ...u,
      ...tx,
      "--xy-background-color-props": s,
      "--xy-background-pattern-color-props": i
    }, ref: p, "data-testid": "rf__background", children: [S.jsx("pattern", { id: M, x: g[0] % _[0], y: g[1] % _[1], width: _[0], height: _[1], patternUnits: "userSpaceOnUse", patternTransform: `translate(-${O[0]},-${O[1]})`, children: b ? S.jsx(dbe, { radius: k / 2, className: f }) : S.jsx(cbe, { dimensions: P, lineWidth: o, variant: t, className: f }) }), S.jsx("rect", { x: "0", y: "0", width: "100%", height: "100%", fill: `url(#${M})` })] });
  }
  N7.displayName = "Background";
  const mbe = C.memo(N7);
  function hbe() {
    return S.jsx("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 32 32", children: S.jsx("path", { d: "M32 18.133H18.133V32h-4.266V18.133H0v-4.266h13.867V0h4.266v13.867H32z" }) });
  }
  function gbe() {
    return S.jsx("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 32 5", children: S.jsx("path", { d: "M0 0h32v4.2H0z" }) });
  }
  function vbe() {
    return S.jsx("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 32 30", children: S.jsx("path", { d: "M3.692 4.63c0-.53.4-.938.939-.938h5.215V0H4.708C2.13 0 0 2.054 0 4.63v5.216h3.692V4.631zM27.354 0h-5.2v3.692h5.17c.53 0 .984.4.984.939v5.215H32V4.631A4.624 4.624 0 0027.354 0zm.954 24.83c0 .532-.4.94-.939.94h-5.215v3.768h5.215c2.577 0 4.631-2.13 4.631-4.707v-5.139h-3.692v5.139zm-23.677.94c-.531 0-.939-.4-.939-.94v-5.138H0v5.139c0 2.577 2.13 4.707 4.708 4.707h5.138V25.77H4.631z" }) });
  }
  function ybe() {
    return S.jsx("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 25 32", children: S.jsx("path", { d: "M21.333 10.667H19.81V7.619C19.81 3.429 16.38 0 12.19 0 8 0 4.571 3.429 4.571 7.619v3.048H3.048A3.056 3.056 0 000 13.714v15.238A3.056 3.056 0 003.048 32h18.285a3.056 3.056 0 003.048-3.048V13.714a3.056 3.056 0 00-3.048-3.047zM12.19 24.533a3.056 3.056 0 01-3.047-3.047 3.056 3.056 0 013.047-3.048 3.056 3.056 0 013.048 3.048 3.056 3.056 0 01-3.048 3.047zm4.724-13.866H7.467V7.619c0-2.59 2.133-4.724 4.723-4.724 2.591 0 4.724 2.133 4.724 4.724v3.048z" }) });
  }
  function bbe() {
    return S.jsx("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 25 32", children: S.jsx("path", { d: "M21.333 10.667H19.81V7.619C19.81 3.429 16.38 0 12.19 0c-4.114 1.828-1.37 2.133.305 2.438 1.676.305 4.42 2.59 4.42 5.181v3.048H3.047A3.056 3.056 0 000 13.714v15.238A3.056 3.056 0 003.048 32h18.285a3.056 3.056 0 003.048-3.048V13.714a3.056 3.056 0 00-3.048-3.047zM12.19 24.533a3.056 3.056 0 01-3.047-3.047 3.056 3.056 0 013.047-3.048 3.056 3.056 0 013.048 3.048 3.056 3.056 0 01-3.048 3.047z" }) });
  }
  function Sv({ children: e, className: t, ...n }) {
    return S.jsx("button", { type: "button", className: Wn(["react-flow__controls-button", t]), ...n, children: e });
  }
  const wbe = (e) => ({
    isInteractive: e.nodesDraggable || e.nodesConnectable || e.elementsSelectable,
    minZoomReached: e.transform[2] <= e.minZoom,
    maxZoomReached: e.transform[2] >= e.maxZoom,
    ariaLabelConfig: e.ariaLabelConfig
  });
  function M7({ style: e, showZoom: t = !0, showFitView: n = !0, showInteractive: r = !0, fitViewOptions: o, onZoomIn: a, onZoomOut: i, onFitView: s, onInteractiveChange: u, className: c, children: f, position: p = "bottom-left", orientation: g = "vertical", "aria-label": h }) {
    const y = _n(), { isInteractive: b, minZoomReached: v, maxZoomReached: w, ariaLabelConfig: _ } = Rt(wbe, kn), { zoomIn: k, zoomOut: E, fitView: P } = ku(), O = () => {
      k(), a?.();
    }, M = () => {
      E(), i?.();
    }, I = () => {
      P(o), s?.();
    }, A = () => {
      y.setState({
        nodesDraggable: !b,
        nodesConnectable: !b,
        elementsSelectable: !b
      }), u?.(!b);
    }, D = g === "horizontal" ? "horizontal" : "vertical";
    return S.jsxs(ex, { className: Wn(["react-flow__controls", D, c]), position: p, style: e, "data-testid": "rf__controls", "aria-label": h ?? _["controls.ariaLabel"], children: [t && S.jsxs(S.Fragment, { children: [S.jsx(Sv, { onClick: O, className: "react-flow__controls-zoomin", title: _["controls.zoomIn.ariaLabel"], "aria-label": _["controls.zoomIn.ariaLabel"], disabled: w, children: S.jsx(hbe, {}) }), S.jsx(Sv, { onClick: M, className: "react-flow__controls-zoomout", title: _["controls.zoomOut.ariaLabel"], "aria-label": _["controls.zoomOut.ariaLabel"], disabled: v, children: S.jsx(gbe, {}) })] }), n && S.jsx(Sv, { className: "react-flow__controls-fitview", onClick: I, title: _["controls.fitView.ariaLabel"], "aria-label": _["controls.fitView.ariaLabel"], children: S.jsx(vbe, {}) }), r && S.jsx(Sv, { className: "react-flow__controls-interactive", onClick: A, title: _["controls.interactive.ariaLabel"], "aria-label": _["controls.interactive.ariaLabel"], children: b ? S.jsx(bbe, {}) : S.jsx(ybe, {}) }), f] });
  }
  M7.displayName = "Controls";
  C.memo(M7);
  function xbe({ id: e, x: t, y: n, width: r, height: o, style: a, color: i, strokeColor: s, strokeWidth: u, className: c, borderRadius: f, shapeRendering: p, selected: g, onClick: h }) {
    const { background: y, backgroundColor: b } = a || {}, v = i || y || b;
    return S.jsx("rect", { className: Wn(["react-flow__minimap-node", { selected: g }, c]), x: t, y: n, rx: f, ry: f, width: r, height: o, style: {
      fill: v,
      stroke: s,
      strokeWidth: u
    }, shapeRendering: p, onClick: h ? (w) => h(w, e) : void 0 });
  }
  const kbe = C.memo(xbe), Sbe = (e) => e.nodes.map((t) => t.id), Z_ = (e) => e instanceof Function ? e : () => e;
  function _be({
    nodeStrokeColor: e,
    nodeColor: t,
    nodeClassName: n = "",
    nodeBorderRadius: r = 5,
    nodeStrokeWidth: o,
    /*
     * We need to rename the prop to be `CapitalCase` so that JSX will render it as
     * a component properly.
     */
    nodeComponent: a = kbe,
    onClick: i
  }) {
    const s = Rt(Sbe, kn), u = Z_(t), c = Z_(e), f = Z_(n), p = typeof window > "u" || window.chrome ? "crispEdges" : "geometricPrecision";
    return S.jsx(S.Fragment, { children: s.map((g) => (
      /*
       * The split of responsibilities between MiniMapNodes and
       * NodeComponentWrapper may appear weird. However, its designed to
       * minimize the cost of updates when individual nodes change.
       *
       * For more details, see a similar commit in `NodeRenderer/index.tsx`.
       */
      S.jsx(Cbe, { id: g, nodeColorFunc: u, nodeStrokeColorFunc: c, nodeClassNameFunc: f, nodeBorderRadius: r, nodeStrokeWidth: o, NodeComponent: a, onClick: i, shapeRendering: p }, g)
    )) });
  }
  function Ebe({ id: e, nodeColorFunc: t, nodeStrokeColorFunc: n, nodeClassNameFunc: r, nodeBorderRadius: o, nodeStrokeWidth: a, shapeRendering: i, NodeComponent: s, onClick: u }) {
    const { node: c, x: f, y: p, width: g, height: h } = Rt((y) => {
      const { internals: b } = y.nodeLookup.get(e), v = b.userNode, { x: w, y: _ } = b.positionAbsolute, { width: k, height: E } = ns(v);
      return {
        node: v,
        x: w,
        y: _,
        width: k,
        height: E
      };
    }, kn);
    return !c || c.hidden || !IB(c) ? null : S.jsx(s, { x: f, y: p, width: g, height: h, style: c.style, selected: !!c.selected, className: r(c), color: t(c), borderRadius: o, strokeColor: n(c), strokeWidth: a, shapeRendering: i, onClick: u, id: c.id });
  }
  const Cbe = C.memo(Ebe);
  var Pbe = C.memo(_be);
  const Obe = 200, Nbe = 150, Mbe = (e) => !e.hidden, Rbe = (e) => {
    const t = {
      x: -e.transform[0] / e.transform[2],
      y: -e.transform[1] / e.transform[2],
      width: e.width / e.transform[2],
      height: e.height / e.transform[2]
    };
    return {
      viewBB: t,
      boundingRect: e.nodeLookup.size > 0 ? jB(nh(e.nodeLookup, { filter: Mbe }), t) : t,
      rfId: e.rfId,
      panZoom: e.panZoom,
      translateExtent: e.translateExtent,
      flowWidth: e.width,
      flowHeight: e.height,
      ariaLabelConfig: e.ariaLabelConfig
    };
  }, jbe = "react-flow__minimap-desc";
  function R7({
    style: e,
    className: t,
    nodeStrokeColor: n,
    nodeColor: r,
    nodeClassName: o = "",
    nodeBorderRadius: a = 5,
    nodeStrokeWidth: i,
    /*
     * We need to rename the prop to be `CapitalCase` so that JSX will render it as
     * a component properly.
     */
    nodeComponent: s,
    bgColor: u,
    maskColor: c,
    maskStrokeColor: f,
    maskStrokeWidth: p,
    position: g = "bottom-right",
    onClick: h,
    onNodeClick: y,
    pannable: b = !1,
    zoomable: v = !1,
    ariaLabel: w,
    inversePan: _,
    zoomStep: k = 1,
    offsetScale: E = 5
  }) {
    const P = _n(), O = C.useRef(null), { boundingRect: M, viewBB: I, rfId: A, panZoom: D, translateExtent: F, flowWidth: j, flowHeight: U, ariaLabelConfig: $ } = Rt(Rbe, kn), q = e?.width ?? Obe, B = e?.height ?? Nbe, G = M.width / q, W = M.height / B, Y = Math.max(G, W), z = Y * q, L = Y * B, K = E * Y, T = M.x - (z - M.width) / 2 - K, V = M.y - (L - M.height) / 2 - K, X = z + K * 2, Q = L + K * 2, ne = `${jbe}-${A}`, te = C.useRef(0), ae = C.useRef();
    te.current = Y, C.useEffect(() => {
      if (O.current && D)
        return ae.current = ove({
          domNode: O.current,
          panZoom: D,
          getTransform: () => P.getState().transform,
          getViewScale: () => te.current
        }), () => {
          ae.current?.destroy();
        };
    }, [D]), C.useEffect(() => {
      ae.current?.update({
        translateExtent: F,
        width: j,
        height: U,
        inversePan: _,
        pannable: b,
        zoomStep: k,
        zoomable: v
      });
    }, [b, v, _, k, F, j, U]);
    const ce = h ? (oe) => {
      const [le, be] = ae.current?.pointer(oe) || [0, 0];
      h(oe, { x: le, y: be });
    } : void 0, Z = y ? C.useCallback((oe, le) => {
      const be = P.getState().nodeLookup.get(le).internals.userNode;
      y(oe, be);
    }, []) : void 0, ee = w ?? $["minimap.ariaLabel"];
    return S.jsx(ex, { position: g, style: {
      ...e,
      "--xy-minimap-background-color-props": typeof u == "string" ? u : void 0,
      "--xy-minimap-mask-background-color-props": typeof c == "string" ? c : void 0,
      "--xy-minimap-mask-stroke-color-props": typeof f == "string" ? f : void 0,
      "--xy-minimap-mask-stroke-width-props": typeof p == "number" ? p * Y : void 0,
      "--xy-minimap-node-background-color-props": typeof r == "string" ? r : void 0,
      "--xy-minimap-node-stroke-color-props": typeof n == "string" ? n : void 0,
      "--xy-minimap-node-stroke-width-props": typeof i == "number" ? i : void 0
    }, className: Wn(["react-flow__minimap", t]), "data-testid": "rf__minimap", children: S.jsxs("svg", { width: q, height: B, viewBox: `${T} ${V} ${X} ${Q}`, className: "react-flow__minimap-svg", role: "img", "aria-labelledby": ne, ref: O, onClick: ce, children: [ee && S.jsx("title", { id: ne, children: ee }), S.jsx(Pbe, { onClick: Z, nodeColor: r, nodeStrokeColor: n, nodeBorderRadius: a, nodeClassName: o, nodeStrokeWidth: i, nodeComponent: s }), S.jsx("path", { className: "react-flow__minimap-mask", d: `M${T - K},${V - K}h${X + K * 2}v${Q + K * 2}h${-X - K * 2}z
        M${I.x},${I.y}h${I.width}v${I.height}h${-I.width}z`, fillRule: "evenodd", pointerEvents: "none" })] }) });
  }
  R7.displayName = "MiniMap";
  const Ibe = C.memo(R7), Abe = (e) => (t) => e ? `${Math.max(1 / t.transform[2], 1)}` : void 0, $be = {
    [_d.Line]: "right",
    [_d.Handle]: "bottom-right"
  };
  function Dbe({ nodeId: e, position: t, variant: n = _d.Handle, className: r, style: o = void 0, children: a, color: i, minWidth: s = 10, minHeight: u = 10, maxWidth: c = Number.MAX_VALUE, maxHeight: f = Number.MAX_VALUE, keepAspectRatio: p = !1, resizeDirection: g, autoScale: h = !0, shouldResize: y, onResizeStart: b, onResize: v, onResizeEnd: w }) {
    const _ = u7(), k = typeof e == "string" ? e : _, E = _n(), P = C.useRef(null), O = n === _d.Handle, M = Rt(C.useCallback(Abe(O && h), [O, h]), kn), I = C.useRef(null), A = t ?? $be[n];
    C.useEffect(() => {
      if (!(!P.current || !k))
        return I.current || (I.current = yve({
          domNode: P.current,
          nodeId: k,
          getStoreItems: () => {
            const { nodeLookup: F, transform: j, snapGrid: U, snapToGrid: $, nodeOrigin: q, domNode: B } = E.getState();
            return {
              nodeLookup: F,
              transform: j,
              snapGrid: U,
              snapToGrid: $,
              nodeOrigin: q,
              paneDomNode: B
            };
          },
          onChange: (F, j) => {
            const { triggerNodeChanges: U, nodeLookup: $, parentLookup: q, nodeOrigin: B } = E.getState(), G = [], W = { x: F.x, y: F.y }, Y = $.get(k);
            if (Y && Y.expandParent && Y.parentId) {
              const z = Y.origin ?? B, L = F.width ?? Y.measured.width ?? 0, K = F.height ?? Y.measured.height ?? 0, T = {
                id: Y.id,
                parentId: Y.parentId,
                rect: {
                  width: L,
                  height: K,
                  ...AB({
                    x: F.x ?? Y.position.x,
                    y: F.y ?? Y.position.y
                  }, { width: L, height: K }, Y.parentId, $, z)
                }
              }, V = EP([T], $, q, B);
              G.push(...V), W.x = F.x ? Math.max(z[0] * L, F.x) : void 0, W.y = F.y ? Math.max(z[1] * K, F.y) : void 0;
            }
            if (W.x !== void 0 && W.y !== void 0) {
              const z = {
                id: k,
                type: "position",
                position: { ...W }
              };
              G.push(z);
            }
            if (F.width !== void 0 && F.height !== void 0) {
              const z = {
                id: k,
                type: "dimensions",
                resizing: !0,
                setAttributes: g ? g === "horizontal" ? "width" : "height" : !0,
                dimensions: {
                  width: F.width,
                  height: F.height
                }
              };
              G.push(z);
            }
            for (const z of j) {
              const L = {
                ...z,
                type: "position"
              };
              G.push(L);
            }
            U(G);
          },
          onEnd: ({ width: F, height: j }) => {
            const U = {
              id: k,
              type: "dimensions",
              resizing: !1,
              dimensions: {
                width: F,
                height: j
              }
            };
            E.getState().triggerNodeChanges([U]);
          }
        })), I.current.update({
          controlPosition: A,
          boundaries: {
            minWidth: s,
            minHeight: u,
            maxWidth: c,
            maxHeight: f
          },
          keepAspectRatio: p,
          resizeDirection: g,
          onResizeStart: b,
          onResize: v,
          onResizeEnd: w,
          shouldResize: y
        }), () => {
          I.current?.destroy();
        };
    }, [
      A,
      s,
      u,
      c,
      f,
      p,
      b,
      v,
      w,
      y
    ]);
    const D = A.split("-");
    return S.jsx("div", { className: Wn(["react-flow__resize-control", "nodrag", ...D, n, r]), ref: P, style: {
      ...o,
      scale: M,
      ...i && { [O ? "backgroundColor" : "borderColor"]: i }
    }, children: a });
  }
  C.memo(Dbe);
  function Lbe(e, t) {
    if (Object.is(e, t))
      return !0;
    if (typeof e != "object" || e === null || typeof t != "object" || t === null)
      return !1;
    if (e instanceof Map && t instanceof Map) {
      if (e.size !== t.size) return !1;
      for (const [r, o] of e)
        if (!Object.is(o, t.get(r)))
          return !1;
      return !0;
    }
    if (e instanceof Set && t instanceof Set) {
      if (e.size !== t.size) return !1;
      for (const r of e)
        if (!t.has(r))
          return !1;
      return !0;
    }
    const n = Object.keys(e);
    if (n.length !== Object.keys(t).length)
      return !1;
    for (const r of n)
      if (!Object.prototype.hasOwnProperty.call(t, r) || !Object.is(e[r], t[r]))
        return !1;
    return !0;
  }
  const { useRef: Fbe } = gn;
  function OP(e) {
    const t = Fbe();
    return (n) => {
      const r = e(n);
      return Lbe(t.current, r) ? t.current : t.current = r;
    };
  }
  const Tbe = () => {
    const { group: e } = Nr();
    return async (t, n) => {
      if (e)
        return await e.group_nodes(t, n);
    };
  }, zbe = () => {
    const { group: e } = Nr();
    return async (t) => {
      if (e)
        for (const n of t)
          await e.remove_group(n);
    };
  }, Bbe = ({ data: e }) => {
    const t = e?.group?.id || e?.id, n = zbe(), r = C.useCallback(
      (o) => {
        o.stopPropagation(), t && n([t]);
      },
      [t, n]
    );
    return /* @__PURE__ */ S.jsxs("div", { className: "fn-group", children: [
      /* @__PURE__ */ S.jsx(
        "button",
        {
          className: "fn-group-remove",
          title: "Remove group",
          onClick: r,
          children: /* @__PURE__ */ S.jsx(Mw, {})
        }
      ),
      "Group"
    ] });
  }, j7 = (e, t) => {
    if (typeof e == "string")
      return e in t ? [t[e], e] : [e, e];
    if ("allOf" in e && e.allOf !== void 0)
      return [void 0, void 0];
    if ("anyOf" in e && e.anyOf !== void 0) {
      const n = e.anyOf.map(
        (r) => j7(r || "any", t)
      );
      for (const r of n)
        switch (r[0]) {
          case "bool":
            return ["bool", r[1]];
          case "enum":
            return ["enum", r[1]];
          case "float":
            return ["float", r[1]];
          case "int":
            return ["int", r[1]];
          case "string":
            return ["string", r[1]];
          case "str":
            return ["string", r[1]];
        }
      return [void 0, void 0];
    }
    return !("type" in e) || e.type === void 0 ? [void 0, void 0] : e.type === "enum" ? ["enum", "enum"] : [void 0, void 0];
  }, Su = (e, t) => j7(e.render_options?.type ?? "any", t), NP = C.memo(
    ({ value: e }) => {
      const t = e?.toString() ?? "", n = Math.round(3 * t.length / 4);
      return /* @__PURE__ */ S.jsx("div", { children: /* @__PURE__ */ S.jsxs("pre", { children: [
        "Bytes(",
        n,
        ")"
      ] }) });
    }
  ), I7 = C.memo(
    ({ value: e }) => typeof e != "string" ? /* @__PURE__ */ S.jsx("div", { children: "Invalid SVG" }) : /* @__PURE__ */ S.jsx(nce, { value: e })
  ), A7 = ({
    value: e,
    preValue: t,
    onLoaded: n
  }) => {
    const [r, o] = C.useState(
      t?.toString() || e?.toString()
    );
    return C.useEffect(() => {
      if (e === t || e == null) return;
      const a = new Image(), i = e.toString();
      return a.onload = () => {
        n?.(), o(i);
      }, a.src = i, () => {
        a.onload = null;
      };
    }, [e, t, n]), r === void 0 ? /* @__PURE__ */ S.jsx(S.Fragment, {}) : typeof r != "string" ? (console.error("ImageRenderer: value is not a string", r), /* @__PURE__ */ S.jsx(S.Fragment, {})) : r.startsWith("data:") || r.startsWith("blob:") ? /* @__PURE__ */ S.jsx(rce, { src: r }) : /* @__PURE__ */ S.jsx(tce, { value: r, format: "jpeg" });
  }, Vbe = C.memo(
    ({ value: e }) => {
      let t = "";
      try {
        t = JSON.stringify(e);
      } catch {
      }
      return /* @__PURE__ */ S.jsx("div", { children: /* @__PURE__ */ S.jsx("pre", { children: t }) });
    }
  ), nx = ({
    value: e
  }) => /* @__PURE__ */ S.jsx(Tue, { data: e }), $7 = C.memo(
    ({ value: e }) => {
      if (typeof e != "object" || e == null)
        return /* @__PURE__ */ S.jsx("div", { children: "Invalid Table" });
      if (!("columns" in e && "index" in e && "data" in e))
        return /* @__PURE__ */ S.jsx("div", { children: "Invalid Table" });
      if (!Array.isArray(e.columns) || !Array.isArray(e.index) || !Array.isArray(e.data) || !e.data.every((n) => Array.isArray(n)))
        return /* @__PURE__ */ S.jsx("div", { children: "Invalid Table" });
      const t = {
        columns: e.columns || [],
        index: e.index || [],
        data: e.data || []
      };
      return /* @__PURE__ */ S.jsx(qT, { tabledata: t });
    }
  ), Rb = (e) => /* @__PURE__ */ S.jsx(Vbe, { ...e }), jb = nx, MP = {
    string: Rb,
    str: Rb,
    table: $7,
    image: A7,
    svg: I7,
    dict: nx,
    bytes: NP
  }, rx = C.createContext({}), go = () => C.useContext(rx), ul = C.createContext(void 0);
  function Sn(e) {
    if (e)
      return go().io_stores.get(e);
    {
      const t = C.useContext(ul);
      if (!t)
        throw new Error("IOContext not set");
      return t;
    }
  }
  const Ube = () => {
    const e = Sn(), { full: t, preview: n } = e.valuestore(), r = JSON.stringify(t?.value || n?.value) || "";
    return `Bytes(${Math.round(3 * r.length / 4)})`;
  }, Hbe = {
    bytes: Ube
  }, ox = (e) => ({ value: t, preValue: n, onLoaded: r }) => /* @__PURE__ */ S.jsx(e, { value: t, preValue: n, onLoaded: r }), zr = (e, t = void 0, n = {}) => ({}) => {
    const r = Sn(), { full: o, preview: a } = r.valuestore(), i = (o === void 0 ? a : o)?.value || t;
    return /* @__PURE__ */ S.jsx(e, { value: i, ...n });
  }, D7 = (e) => ({}) => /* @__PURE__ */ S.jsx(e, {}), L7 = (e, t = void 0) => ({}) => {
    const n = Sn(), { full: r, preview: o } = n.valuestore(), a = (r === void 0 ? o : r)?.value || t;
    return /* @__PURE__ */ S.jsx(e, { value: a });
  }, Wbe = {
    ...Object.fromEntries(
      Object.entries(MP).map(([e, t]) => [
        e,
        t ? ox(t) : void 0
      ])
    )
  }, y3 = ox(nx), F7 = {
    ...Object.fromEntries(
      Object.entries(MP).map(([e, t]) => [
        e,
        t ? zr(t) : void 0
      ])
    ),
    string: zr(Rb),
    str: zr(Rb),
    table: zr($7, void 0, {
      pageSize: 10
    }),
    image: zr(A7),
    svg: zr(I7, ""),
    dict: zr(nx, "{}"),
    bytes: zr(NP, "")
  }, qbe = {
    ...Object.fromEntries(
      Object.entries(F7).map(([e, t]) => [
        e,
        t ? D7(t) : void 0
      ])
    )
  }, Kbe = () => {
    const e = Sn(), { preview: t, full: n } = e.valuestore();
    let r = (JSON.stringify(n || t) || "").replace(/\\n/g, `
`);
    return r.length > 63 && (r = r.slice(0, 60) + "..."), /* @__PURE__ */ S.jsx("div", { children: r });
  }, Gbe = {};
  function _u(e) {
    const { node: t } = Nr();
    if (e || (e = Sn().use()), typeof e == "string" && (e = Sn(e)?.use(), !e))
      throw new Error(`No IO found for ${e}`);
    if (!e)
      throw new Error("No IO found");
    return C.useCallback(
      (n, r) => {
        t?.set_io_value({
          nid: e.node,
          ioid: e.id,
          value: n,
          set_default: r ?? e.render_options.set_default
        });
      },
      [e, t]
    );
  }
  function Xbe(e) {
    const { node: t } = Nr();
    let n, r;
    if (!e) {
      const o = Sn().useShallow((a) => ({
        io_id: a.id,
        node_id: a.node
      }));
      n = o.io_id, r = o.node_id;
    }
    if (typeof e == "string") {
      const o = Sn(e);
      if (!o)
        throw new Error(`No IO found for ${e}`);
      const a = o.useShallow((i) => ({
        io_id: i.id,
        node_id: i.node
      }));
      n = a.io_id, r = a.node_id;
    } else {
      if (!e)
        throw new Error("No IO found");
      n = e.id, r = e.node;
    }
    return C.useCallback(
      (o) => {
        t?.set_io_value_options({
          nid: r,
          ioid: n,
          values: o.values ?? o.keys,
          keys: o.keys,
          nullable: o.nullable ?? !1
        });
      },
      [t, n, r]
    );
  }
  function Ybe(e) {
    return Sn(e)?.valuestore();
  }
  function ih(e) {
    const t = Sn(e);
    if (!t) return;
    const { node: n, id: r } = t.useShallow((a) => ({
      node: a.node,
      id: a.id
    })), { node: o } = Nr();
    return C.useCallback(async () => {
      const a = await o?.get_io_full_value({ nid: n, ioid: r });
      return t.updateValueStore({ full: a }), a;
    }, [o, n, r]);
  }
  function RP(e) {
    const t = Sn(e);
    if (!t) return;
    const { node: n, id: r } = t.useShallow((a) => ({
      node: a.node,
      id: a.id
    })), { node: o } = Nr();
    return C.useCallback(
      (a) => {
        o?.update_io_options({
          nid: n,
          ioid: r,
          options: { hidden: a }
        });
      },
      [o, n, r]
    );
  }
  const Jbe = ({ inputconverter: e }) => {
    const t = Sn(), { preview: n } = t.valuestore(), r = t.use(), o = n?.value === void 0, a = C.useRef(null), i = _u(r);
    C.useEffect(() => {
      a.current && (a.current.indeterminate = o);
    }, [a, o]);
    const s = C.useCallback(
      (u) => {
        let c = u.target.checked;
        try {
          c = e[0](u.target.checked);
        } catch {
        }
        i(c);
      },
      [i, e]
    );
    return /* @__PURE__ */ S.jsx(
      "input",
      {
        ref: a,
        type: "checkbox",
        className: "styledcheckbox booleaninput",
        checked: !!e[1](n?.value),
        onChange: s,
        disabled: r.connected
      }
    );
  }, Qbe = ({}) => {
    const e = Sn(), t = Vt(), n = e.use(), { preview: r, full: o } = e.valuestore(), a = o === void 0 ? r?.value : o.value, i = _u(n), s = typeof a == "string" || Array.isArray(a) && a.every((g) => typeof g == "number") ? a : void 0, u = n.value_options?.colorspace || "hex", c = C.useCallback(
      (g) => {
        let h = "<NoValue>";
        g && (g[u] ? h = g[u]() : h = g.hex()), g === null && (h = null);
        try {
          h = h;
        } catch {
        }
        i(h);
      },
      [i, u]
    );
    let f = !1;
    typeof n.type != "string" && "anyOf" in n.type && n.type.anyOf !== void 0 && (f = n.type.anyOf.some((g) => g === "None"));
    const p = t.local_state(() => t.reactflowRef);
    return /* @__PURE__ */ S.jsx(
      Uie,
      {
        onChange: c,
        inicolordata: s,
        allow_null: f,
        inicolorspace: u,
        portalContainer: p
      }
    );
  };
  function T7(e, [t, n]) {
    return Math.min(n, Math.max(t, e));
  }
  var Zbe = C.createContext(void 0);
  function ax(e) {
    const t = C.useContext(Zbe);
    return e || t || "ltr";
  }
  function ewe(e) {
    const t = C.useRef({ value: e, previous: e });
    return C.useMemo(() => (t.current.value !== e && (t.current.previous = t.current.value, t.current.value = e), t.current.previous), [e]);
  }
  var z7 = ["PageUp", "PageDown"], B7 = ["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight"], V7 = {
    "from-left": ["Home", "PageDown", "ArrowDown", "ArrowLeft"],
    "from-right": ["Home", "PageDown", "ArrowDown", "ArrowRight"],
    "from-bottom": ["Home", "PageDown", "ArrowDown", "ArrowLeft"],
    "from-top": ["Home", "PageDown", "ArrowUp", "ArrowLeft"]
  }, Vd = "Slider", [tE, twe, nwe] = Lw(Vd), [U7] = Ja(Vd, [
    nwe
  ]), [rwe, ix] = U7(Vd), H7 = C.forwardRef(
    (e, t) => {
      const {
        name: n,
        min: r = 0,
        max: o = 100,
        step: a = 1,
        orientation: i = "horizontal",
        disabled: s = !1,
        minStepsBetweenThumbs: u = 0,
        defaultValue: c = [r],
        value: f,
        onValueChange: p = () => {
        },
        onValueCommit: g = () => {
        },
        inverted: h = !1,
        form: y,
        ...b
      } = e, v = C.useRef(/* @__PURE__ */ new Set()), w = C.useRef(0), _ = i === "horizontal" ? owe : awe, [k = [], E] = ml({
        prop: f,
        defaultProp: c,
        onChange: (D) => {
          [...v.current][w.current]?.focus(), p(D);
        }
      }), P = C.useRef(k);
      function O(D) {
        const F = cwe(k, D);
        A(D, F);
      }
      function M(D) {
        A(D, w.current);
      }
      function I() {
        const D = P.current[w.current];
        k[w.current] !== D && g(k);
      }
      function A(D, F, { commit: j } = { commit: !1 }) {
        const U = mwe(a), $ = hwe(Math.round((D - r) / a) * a + r, U), q = T7($, [r, o]);
        E((B = []) => {
          const G = lwe(B, q, F);
          if (pwe(G, u * a)) {
            w.current = G.indexOf(q);
            const W = String(G) !== String(B);
            return W && j && g(G), W ? G : B;
          } else
            return B;
        });
      }
      return /* @__PURE__ */ S.jsx(
        rwe,
        {
          scope: e.__scopeSlider,
          name: n,
          disabled: s,
          min: r,
          max: o,
          valueIndexToChangeRef: w,
          thumbs: v.current,
          values: k,
          orientation: i,
          form: y,
          children: /* @__PURE__ */ S.jsx(tE.Provider, { scope: e.__scopeSlider, children: /* @__PURE__ */ S.jsx(tE.Slot, { scope: e.__scopeSlider, children: /* @__PURE__ */ S.jsx(
            _,
            {
              "aria-disabled": s,
              "data-disabled": s ? "" : void 0,
              ...b,
              ref: t,
              onPointerDown: Te(b.onPointerDown, () => {
                s || (P.current = k);
              }),
              min: r,
              max: o,
              inverted: h,
              onSlideStart: s ? void 0 : O,
              onSlideMove: s ? void 0 : M,
              onSlideEnd: s ? void 0 : I,
              onHomeKeyDown: () => !s && A(r, 0, { commit: !0 }),
              onEndKeyDown: () => !s && A(o, k.length - 1, { commit: !0 }),
              onStepKeyDown: ({ event: D, direction: F }) => {
                if (!s) {
                  const j = z7.includes(D.key) || D.shiftKey && B7.includes(D.key) ? 10 : 1, U = w.current, $ = k[U], q = a * j * F;
                  A($ + q, U, { commit: !0 });
                }
              }
            }
          ) }) })
        }
      );
    }
  );
  H7.displayName = Vd;
  var [W7, q7] = U7(Vd, {
    startEdge: "left",
    endEdge: "right",
    size: "width",
    direction: 1
  }), owe = C.forwardRef(
    (e, t) => {
      const {
        min: n,
        max: r,
        dir: o,
        inverted: a,
        onSlideStart: i,
        onSlideMove: s,
        onSlideEnd: u,
        onStepKeyDown: c,
        ...f
      } = e, [p, g] = C.useState(null), h = un(t, (k) => g(k)), y = C.useRef(void 0), b = ax(o), v = b === "ltr", w = v && !a || !v && a;
      function _(k) {
        const E = y.current || p.getBoundingClientRect(), P = [0, E.width], O = jP(P, w ? [n, r] : [r, n]);
        return y.current = E, O(k - E.left);
      }
      return /* @__PURE__ */ S.jsx(
        W7,
        {
          scope: e.__scopeSlider,
          startEdge: w ? "left" : "right",
          endEdge: w ? "right" : "left",
          direction: w ? 1 : -1,
          size: "width",
          children: /* @__PURE__ */ S.jsx(
            K7,
            {
              dir: b,
              "data-orientation": "horizontal",
              ...f,
              ref: h,
              style: {
                ...f.style,
                "--radix-slider-thumb-transform": "translateX(-50%)"
              },
              onSlideStart: (k) => {
                const E = _(k.clientX);
                i?.(E);
              },
              onSlideMove: (k) => {
                const E = _(k.clientX);
                s?.(E);
              },
              onSlideEnd: () => {
                y.current = void 0, u?.();
              },
              onStepKeyDown: (k) => {
                const E = V7[w ? "from-left" : "from-right"].includes(k.key);
                c?.({ event: k, direction: E ? -1 : 1 });
              }
            }
          )
        }
      );
    }
  ), awe = C.forwardRef(
    (e, t) => {
      const {
        min: n,
        max: r,
        inverted: o,
        onSlideStart: a,
        onSlideMove: i,
        onSlideEnd: s,
        onStepKeyDown: u,
        ...c
      } = e, f = C.useRef(null), p = un(t, f), g = C.useRef(void 0), h = !o;
      function y(b) {
        const v = g.current || f.current.getBoundingClientRect(), w = [0, v.height], _ = jP(w, h ? [r, n] : [n, r]);
        return g.current = v, _(b - v.top);
      }
      return /* @__PURE__ */ S.jsx(
        W7,
        {
          scope: e.__scopeSlider,
          startEdge: h ? "bottom" : "top",
          endEdge: h ? "top" : "bottom",
          size: "height",
          direction: h ? 1 : -1,
          children: /* @__PURE__ */ S.jsx(
            K7,
            {
              "data-orientation": "vertical",
              ...c,
              ref: p,
              style: {
                ...c.style,
                "--radix-slider-thumb-transform": "translateY(50%)"
              },
              onSlideStart: (b) => {
                const v = y(b.clientY);
                a?.(v);
              },
              onSlideMove: (b) => {
                const v = y(b.clientY);
                i?.(v);
              },
              onSlideEnd: () => {
                g.current = void 0, s?.();
              },
              onStepKeyDown: (b) => {
                const v = V7[h ? "from-bottom" : "from-top"].includes(b.key);
                u?.({ event: b, direction: v ? -1 : 1 });
              }
            }
          )
        }
      );
    }
  ), K7 = C.forwardRef(
    (e, t) => {
      const {
        __scopeSlider: n,
        onSlideStart: r,
        onSlideMove: o,
        onSlideEnd: a,
        onHomeKeyDown: i,
        onEndKeyDown: s,
        onStepKeyDown: u,
        ...c
      } = e, f = ix(Vd, n);
      return /* @__PURE__ */ S.jsx(
        gt.span,
        {
          ...c,
          ref: t,
          onKeyDown: Te(e.onKeyDown, (p) => {
            p.key === "Home" ? (i(p), p.preventDefault()) : p.key === "End" ? (s(p), p.preventDefault()) : z7.concat(B7).includes(p.key) && (u(p), p.preventDefault());
          }),
          onPointerDown: Te(e.onPointerDown, (p) => {
            const g = p.target;
            g.setPointerCapture(p.pointerId), p.preventDefault(), f.thumbs.has(g) ? g.focus() : r(p);
          }),
          onPointerMove: Te(e.onPointerMove, (p) => {
            p.target.hasPointerCapture(p.pointerId) && o(p);
          }),
          onPointerUp: Te(e.onPointerUp, (p) => {
            const g = p.target;
            g.hasPointerCapture(p.pointerId) && (g.releasePointerCapture(p.pointerId), a(p));
          })
        }
      );
    }
  ), G7 = "SliderTrack", X7 = C.forwardRef(
    (e, t) => {
      const { __scopeSlider: n, ...r } = e, o = ix(G7, n);
      return /* @__PURE__ */ S.jsx(
        gt.span,
        {
          "data-disabled": o.disabled ? "" : void 0,
          "data-orientation": o.orientation,
          ...r,
          ref: t
        }
      );
    }
  );
  X7.displayName = G7;
  var nE = "SliderRange", Y7 = C.forwardRef(
    (e, t) => {
      const { __scopeSlider: n, ...r } = e, o = ix(nE, n), a = q7(nE, n), i = C.useRef(null), s = un(t, i), u = o.values.length, c = o.values.map(
        (g) => Z7(g, o.min, o.max)
      ), f = u > 1 ? Math.min(...c) : 0, p = 100 - Math.max(...c);
      return /* @__PURE__ */ S.jsx(
        gt.span,
        {
          "data-orientation": o.orientation,
          "data-disabled": o.disabled ? "" : void 0,
          ...r,
          ref: s,
          style: {
            ...e.style,
            [a.startEdge]: f + "%",
            [a.endEdge]: p + "%"
          }
        }
      );
    }
  );
  Y7.displayName = nE;
  var rE = "SliderThumb", J7 = C.forwardRef(
    (e, t) => {
      const n = twe(e.__scopeSlider), [r, o] = C.useState(null), a = un(t, (s) => o(s)), i = C.useMemo(
        () => r ? n().findIndex((s) => s.ref.current === r) : -1,
        [n, r]
      );
      return /* @__PURE__ */ S.jsx(iwe, { ...e, ref: a, index: i });
    }
  ), iwe = C.forwardRef(
    (e, t) => {
      const { __scopeSlider: n, index: r, name: o, ...a } = e, i = ix(rE, n), s = q7(rE, n), [u, c] = C.useState(null), f = un(t, (_) => c(_)), p = u ? i.form || !!u.closest("form") : !0, g = Kz(u), h = i.values[r], y = h === void 0 ? 0 : Z7(h, i.min, i.max), b = uwe(r, i.values.length), v = g?.[s.size], w = v ? dwe(v, y, s.direction) : 0;
      return C.useEffect(() => {
        if (u)
          return i.thumbs.add(u), () => {
            i.thumbs.delete(u);
          };
      }, [u, i.thumbs]), /* @__PURE__ */ S.jsxs(
        "span",
        {
          style: {
            transform: "var(--radix-slider-thumb-transform)",
            position: "absolute",
            [s.startEdge]: `calc(${y}% + ${w}px)`
          },
          children: [
            /* @__PURE__ */ S.jsx(tE.ItemSlot, { scope: e.__scopeSlider, children: /* @__PURE__ */ S.jsx(
              gt.span,
              {
                role: "slider",
                "aria-label": e["aria-label"] || b,
                "aria-valuemin": i.min,
                "aria-valuenow": h,
                "aria-valuemax": i.max,
                "aria-orientation": i.orientation,
                "data-orientation": i.orientation,
                "data-disabled": i.disabled ? "" : void 0,
                tabIndex: i.disabled ? void 0 : 0,
                ...a,
                ref: f,
                style: h === void 0 ? { display: "none" } : e.style,
                onFocus: Te(e.onFocus, () => {
                  i.valueIndexToChangeRef.current = r;
                })
              }
            ) }),
            p && /* @__PURE__ */ S.jsx(
              Q7,
              {
                name: o ?? (i.name ? i.name + (i.values.length > 1 ? "[]" : "") : void 0),
                form: i.form,
                value: h
              },
              r
            )
          ]
        }
      );
    }
  );
  J7.displayName = rE;
  var swe = "RadioBubbleInput", Q7 = C.forwardRef(
    ({ __scopeSlider: e, value: t, ...n }, r) => {
      const o = C.useRef(null), a = un(o, r), i = ewe(t);
      return C.useEffect(() => {
        const s = o.current;
        if (!s) return;
        const u = window.HTMLInputElement.prototype, c = Object.getOwnPropertyDescriptor(u, "value").set;
        if (i !== t && c) {
          const f = new Event("input", { bubbles: !0 });
          c.call(s, t), s.dispatchEvent(f);
        }
      }, [i, t]), /* @__PURE__ */ S.jsx(
        gt.input,
        {
          style: { display: "none" },
          ...n,
          ref: a,
          defaultValue: t
        }
      );
    }
  );
  Q7.displayName = swe;
  function lwe(e = [], t, n) {
    const r = [...e];
    return r[n] = t, r.sort((o, a) => o - a);
  }
  function Z7(e, t, n) {
    const r = 100 / (n - t) * (e - t);
    return T7(r, [0, 100]);
  }
  function uwe(e, t) {
    return t > 2 ? `Value ${e + 1} of ${t}` : t === 2 ? ["Minimum", "Maximum"][e] : void 0;
  }
  function cwe(e, t) {
    if (e.length === 1) return 0;
    const n = e.map((o) => Math.abs(o - t)), r = Math.min(...n);
    return n.indexOf(r);
  }
  function dwe(e, t, n) {
    const r = e / 2, o = jP([0, 50], [0, r]);
    return (r - o(t) * n) * n;
  }
  function fwe(e) {
    return e.slice(0, -1).map((t, n) => e[n + 1] - t);
  }
  function pwe(e, t) {
    if (t > 0) {
      const n = fwe(e);
      return Math.min(...n) >= t;
    }
    return !0;
  }
  function jP(e, t) {
    return (n) => {
      if (e[0] === e[1] || t[0] === t[1]) return t[0];
      const r = (t[1] - t[0]) / (e[1] - e[0]);
      return t[0] + r * (n - e[0]);
    };
  }
  function mwe(e) {
    return (String(e).split(".")[1] || "").length;
  }
  function hwe(e, t) {
    const n = Math.pow(10, t);
    return Math.round(e * n) / n;
  }
  var gwe = H7, vwe = X7, ywe = Y7, bwe = J7;
  function wwe(e) {
    return e === 0 ? 0 : Math.abs(e) < 1e-12 ? e : Number(e.toPrecision(12));
  }
  const eV = ({
    inputconverter: e,
    parser: t = (n) => parseFloat(n)
  }) => {
    const n = Sn(), { preview: r } = n.valuestore(), o = n.use(), a = _u(o), [i, s] = C.useState(
      e[1](r?.value)
    );
    C.useEffect(() => {
      s(e[1](r?.value));
    }, [r]);
    const u = C.useCallback(
      (h) => {
        h = t(
          parseFloat(h.toString()).toString()
          // parse float first for e notation
        ), isNaN(h) ? (h = "<NoValue>", s("")) : (o.value_options?.min !== void 0 && h < o.value_options.min && (h = o.value_options.min), o.value_options?.max !== void 0 && h > o.value_options.max && (h = o.value_options.max), h = wwe(h), s(h.toString()));
        try {
          h = e[0](h);
        } catch {
        }
        h !== r?.value && a(h);
      },
      [o, e, a]
    ), c = C.useCallback(
      (h) => {
        u(h.target.value);
      },
      [u]
    );
    let f = o.connected ? e[1](r?.value) : i;
    f === void 0 && (f = o.value_options?.min), f === void 0 && (f = o.value_options?.max), f === void 0 && (f = ""), f === null && (f = "");
    let p = null, g = 1;
    return o.value_options?.step !== void 0 ? g = o.value_options.step : o.value_options?.max !== void 0 && o.value_options?.min !== void 0 && (g = (o.value_options?.max - o.value_options?.min) / 1e3), o.value_options?.max !== void 0 && o.value_options?.min !== void 0 && !o.connected && (p = /* @__PURE__ */ S.jsx("div", { style: { minWidth: "6.25rem" }, className: "SliderContainer", children: /* @__PURE__ */ S.jsxs(
      gwe,
      {
        className: "SliderRoot",
        value: [f === void 0 ? o.value_options?.min : f],
        min: o.value_options?.min,
        max: o.value_options?.max,
        step: g,
        disabled: o.connected,
        onValueCommit: (h) => {
          isNaN(h[0]) || u(h[0]);
        },
        onValueChange: (h) => {
          isNaN(h[0]) || s(h[0].toString());
        },
        onKeyDown: (h) => {
          ["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight"].includes(
            h.key
          ) && h.stopPropagation();
        },
        children: [
          /* @__PURE__ */ S.jsx(vwe, { className: "SliderTrack", children: /* @__PURE__ */ S.jsx(ywe, { className: "SliderRange" }) }),
          /* @__PURE__ */ S.jsx(bwe, { className: "SliderThumb" })
        ]
      }
    ) })), /* @__PURE__ */ S.jsxs(S.Fragment, { children: [
      p,
      /* @__PURE__ */ S.jsx(
        "input",
        {
          type: "text",
          className: "nodedatainput styledinput numberinput",
          value: f,
          onChange: (h) => s(h.target.value),
          onBlur: c,
          step: g,
          onKeyDown: (h) => {
            if (!(h.ctrlKey || h.metaKey)) {
              if (h.key === "ArrowUp") {
                h.shiftKey && (g *= 10);
                let y = (parseFloat(f) || 0) + g;
                u(y);
                return;
              }
              if (h.key === "ArrowDown") {
                h.shiftKey && (g *= 10);
                let y = (parseFloat(f) || 0) - g;
                u(y);
                return;
              }
              !/^[0-9.eE+-]$/.test(h.key) && !["Backspace", "ArrowLeft", "ArrowRight", "Delete", "Tab"].includes(
                h.key
              ) && h.preventDefault();
            }
          },
          disabled: o.connected,
          min: o.value_options?.min,
          max: o.value_options?.max
        }
      )
    ] });
  }, xwe = ({ inputconverter: e }) => eV({ inputconverter: e, parser: parseFloat }), kwe = ({ inputconverter: e }) => eV({ inputconverter: e, parser: parseInt }), Swe = (e) => e, _we = (e) => parseFloat(e), Ewe = (e) => !!e, Cwe = (e) => e === "null" ? null : e, Pwe = (e) => e === "nuinputconvertermber" ? _we : e === "boolean" ? Ewe : e === "undefined" ? Cwe : Swe, pm = ({
    inputconverter: e,
    parser: t
  }) => {
    const n = Sn(), r = n.use(), { preview: o, full: a } = n.valuestore(), i = a === void 0 ? o?.value : a.value, s = _u(r);
    let u = r.value_options?.options || [];
    Array.isArray(u) && (u = {
      type: "enum",
      values: u,
      keys: u.map((b) => b === null ? "None" : b.toString()),
      nullable: !1
    }), u.type !== "enum" && (u = {
      type: "enum",
      values: Object.values(u),
      keys: Object.keys(u),
      nullable: !1
    }), u = u, u.nullable && !u.values.includes(null) && !u.keys.includes("None") && (u.values.unshift(null), u.keys.unshift("None"));
    const c = [];
    for (let b = 0; b < u.values.length; b++) {
      const v = u.values[b] === null || u.values[b] === void 0 ? "undefined" : typeof u.values[b];
      let w = u.values[b];
      w === null && (w = "null"), w === void 0 && (w = "undefined"), c.push([u.keys[b], w.toString(), v]);
    }
    const f = C.useCallback(
      ({
        value: b,
        // label
        datatype: v
      }) => {
        let w = (t || Pwe(v))(b);
        try {
          w = e[0](b);
        } catch {
        }
        s(w);
      },
      [r, e, s]
    );
    let p = i;
    p === null && (p = "null"), p === void 0 && (p = "undefined");
    const g = c.find((b) => b[1] === p.toString());
    let h;
    g !== void 0 && (h = {
      value: g[1],
      label: g[0],
      datatype: g[2]
    });
    const y = c.map(
      (b) => ({
        value: b[1],
        label: b[0],
        datatype: b[2]
      })
    );
    return (
      // <Suspense fallback={<select disabled={true}></select>}>
      /* @__PURE__ */ S.jsx(
        kue,
        {
          className: "nodedatainput styleddropdown",
          options: y,
          defaultValue: h,
          onChange: (b) => {
            if (b === null) {
              f({
                value: "<NoValue>",
                datatype: "string"
              });
              return;
            }
            f(b);
          }
        }
      )
    );
  }, b3 = ({ inputconverter: e }) => {
    const t = Sn(), { preview: n, full: r } = t.valuestore(), o = t.use(), a = r === void 0 ? n?.value : r?.value, i = _u(o), [s, u] = C.useState(e[1](a));
    C.useEffect(() => {
      u(e[1](a));
    }, [a]);
    const c = C.useCallback(
      (h) => {
        let y = h.target.value;
        y || (y = "<NoValue>");
        try {
          y = e[0](y);
        } catch {
        }
        y !== a && i(y);
      },
      [i, e, a]
    );
    let f = o.connected ? e[1](a) : s;
    f == null && (f = ""), f = f.toString();
    const p = (f.toString().match(/\n/g) || []).length, g = Math.max(...f.split(`
`).map((h) => h.length), 0);
    return /* @__PURE__ */ S.jsx(
      "textarea",
      {
        className: "nodedatainput styledinput stringinput",
        value: f,
        onChange: (h) => u(h.target.value),
        onBlur: (h) => {
          c(h);
        },
        disabled: o.connected,
        rows: p + 1,
        cols: g + 1
      }
    );
  };
  function Ot(e) {
    return typeof e != "object" || e === null || typeof e.lastModified == "number" && typeof File < "u" && e instanceof File || typeof e.getMonth == "function" && typeof Date < "u" && e instanceof Date ? !1 : !Array.isArray(e);
  }
  function Owe(e) {
    return e.additionalItems === !0 && console.warn("additionalItems=true is currently not supported"), Ot(e.additionalItems);
  }
  function w3(e) {
    if (e === "")
      return;
    if (e === null)
      return null;
    if (/\.$/.test(e) || /\.0$/.test(e) || /\.\d*0$/.test(e))
      return e;
    const t = Number(e);
    return typeof t == "number" && !Number.isNaN(t) ? t : e;
  }
  const zi = "__additional_property", Ib = "additionalProperties", cl = "allOf", Nt = "anyOf", Io = "const", sx = "default", IP = "dependencies", Nwe = "enum", cr = "__errors", rn = "$id", Mwe = "if", Ed = "items", Rwe = "_$junk_option_schema_id$_", Vy = "$name", pt = "oneOf", oE = "patternProperties", Lt = "properties", e0 = "readonly", tV = "required", Ab = "submitButtonOptions", yn = "$ref", xp = "$schema", nV = "root", rV = "_", jwe = ["discriminator", "propertyName"], x3 = "formContext", Iwe = "layoutGridLookupMap", AP = "__rjsf_additionalProperties", oV = "__rjsf_rootSchema", Awe = "ui:field", $P = "ui:widget", Js = "ui:options", aE = "ui:globalOptions", $we = "https://json-schema.org/draft/2019-09/schema", Uy = "https://json-schema.org/draft/2020-12/schema";
  function Qe(e = {}, t = {}) {
    return e ? Object.keys(e).filter((n) => n.indexOf("ui:") === 0).reduce((n, r) => {
      const o = e[r];
      return r === $P && Ot(o) ? (console.error("Setting options via ui:widget object is no longer supported, use ui:options instead"), n) : r === Js && Ot(o) ? { ...n, ...o } : { ...n, [r.substring(3)]: o };
    }, { ...t }) : { ...t };
  }
  function aV(e, t = {}, n) {
    if (!(e.additionalProperties || e.patternProperties))
      return !1;
    const { expandable: r = !0 } = Qe(t);
    return r === !1 ? r : e.maxProperties !== void 0 && n ? Object.keys(n).length < e.maxProperties : !0;
  }
  var iV = typeof pp == "object" && pp && pp.Object === Object && pp, Dwe = typeof self == "object" && self && self.Object === Object && self, ti = iV || Dwe || Function("return this")(), Ao = ti.Symbol, sV = Object.prototype, Lwe = sV.hasOwnProperty, Fwe = sV.toString, Qf = Ao ? Ao.toStringTag : void 0;
  function Twe(e) {
    var t = Lwe.call(e, Qf), n = e[Qf];
    try {
      e[Qf] = void 0;
      var r = !0;
    } catch {
    }
    var o = Fwe.call(e);
    return r && (t ? e[Qf] = n : delete e[Qf]), o;
  }
  var zwe = Object.prototype, Bwe = zwe.toString;
  function Vwe(e) {
    return Bwe.call(e);
  }
  var Uwe = "[object Null]", Hwe = "[object Undefined]", k3 = Ao ? Ao.toStringTag : void 0;
  function rs(e) {
    return e == null ? e === void 0 ? Hwe : Uwe : k3 && k3 in Object(e) ? Twe(e) : Vwe(e);
  }
  function lV(e, t) {
    return function(n) {
      return e(t(n));
    };
  }
  var lx = lV(Object.getPrototypeOf, Object);
  function $o(e) {
    return e != null && typeof e == "object";
  }
  var Wwe = "[object Object]", qwe = Function.prototype, Kwe = Object.prototype, uV = qwe.toString, Gwe = Kwe.hasOwnProperty, Xwe = uV.call(Object);
  function dl(e) {
    if (!$o(e) || rs(e) != Wwe)
      return !1;
    var t = lx(e);
    if (t === null)
      return !0;
    var n = Gwe.call(t, "constructor") && t.constructor;
    return typeof n == "function" && n instanceof n && uV.call(n) == Xwe;
  }
  function iE(e) {
    const t = {
      // We store the list of errors for this node in a property named __errors
      // to avoid name collision with a possible sub schema field named
      // 'errors' (see `utils.toErrorSchema`).
      [cr]: [],
      addError(n) {
        this[cr].push(n);
      }
    };
    if (Array.isArray(e))
      return e.reduce((n, r, o) => ({ ...n, [o]: iE(r) }), t);
    if (dl(e)) {
      const n = e;
      return Object.keys(n).reduce((r, o) => ({ ...r, [o]: iE(n[o]) }), t);
    }
    return t;
  }
  function Ywe() {
    this.__data__ = [], this.size = 0;
  }
  function sh(e, t) {
    return e === t || e !== e && t !== t;
  }
  function ux(e, t) {
    for (var n = e.length; n--; )
      if (sh(e[n][0], t))
        return n;
    return -1;
  }
  var Jwe = Array.prototype, Qwe = Jwe.splice;
  function Zwe(e) {
    var t = this.__data__, n = ux(t, e);
    if (n < 0)
      return !1;
    var r = t.length - 1;
    return n == r ? t.pop() : Qwe.call(t, n, 1), --this.size, !0;
  }
  function exe(e) {
    var t = this.__data__, n = ux(t, e);
    return n < 0 ? void 0 : t[n][1];
  }
  function txe(e) {
    return ux(this.__data__, e) > -1;
  }
  function nxe(e, t) {
    var n = this.__data__, r = ux(n, e);
    return r < 0 ? (++this.size, n.push([e, t])) : n[r][1] = t, this;
  }
  function os(e) {
    var t = -1, n = e == null ? 0 : e.length;
    for (this.clear(); ++t < n; ) {
      var r = e[t];
      this.set(r[0], r[1]);
    }
  }
  os.prototype.clear = Ywe;
  os.prototype.delete = Zwe;
  os.prototype.get = exe;
  os.prototype.has = txe;
  os.prototype.set = nxe;
  function rxe() {
    this.__data__ = new os(), this.size = 0;
  }
  function oxe(e) {
    var t = this.__data__, n = t.delete(e);
    return this.size = t.size, n;
  }
  function axe(e) {
    return this.__data__.get(e);
  }
  function ixe(e) {
    return this.__data__.has(e);
  }
  function jt(e) {
    var t = typeof e;
    return e != null && (t == "object" || t == "function");
  }
  var sxe = "[object AsyncFunction]", lxe = "[object Function]", uxe = "[object GeneratorFunction]", cxe = "[object Proxy]";
  function lh(e) {
    if (!jt(e))
      return !1;
    var t = rs(e);
    return t == lxe || t == uxe || t == sxe || t == cxe;
  }
  var t0 = ti["__core-js_shared__"], S3 = (function() {
    var e = /[^.]+$/.exec(t0 && t0.keys && t0.keys.IE_PROTO || "");
    return e ? "Symbol(src)_1." + e : "";
  })();
  function dxe(e) {
    return !!S3 && S3 in e;
  }
  var fxe = Function.prototype, pxe = fxe.toString;
  function Eu(e) {
    if (e != null) {
      try {
        return pxe.call(e);
      } catch {
      }
      try {
        return e + "";
      } catch {
      }
    }
    return "";
  }
  var mxe = /[\\^$.*+?()[\]{}|]/g, hxe = /^\[object .+?Constructor\]$/, gxe = Function.prototype, vxe = Object.prototype, yxe = gxe.toString, bxe = vxe.hasOwnProperty, wxe = RegExp(
    "^" + yxe.call(bxe).replace(mxe, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
  );
  function xxe(e) {
    if (!jt(e) || dxe(e))
      return !1;
    var t = lh(e) ? wxe : hxe;
    return t.test(Eu(e));
  }
  function kxe(e, t) {
    return e?.[t];
  }
  function Cu(e, t) {
    var n = kxe(e, t);
    return xxe(n) ? n : void 0;
  }
  var mm = Cu(ti, "Map"), hm = Cu(Object, "create");
  function Sxe() {
    this.__data__ = hm ? hm(null) : {}, this.size = 0;
  }
  function _xe(e) {
    var t = this.has(e) && delete this.__data__[e];
    return this.size -= t ? 1 : 0, t;
  }
  var Exe = "__lodash_hash_undefined__", Cxe = Object.prototype, Pxe = Cxe.hasOwnProperty;
  function Oxe(e) {
    var t = this.__data__;
    if (hm) {
      var n = t[e];
      return n === Exe ? void 0 : n;
    }
    return Pxe.call(t, e) ? t[e] : void 0;
  }
  var Nxe = Object.prototype, Mxe = Nxe.hasOwnProperty;
  function Rxe(e) {
    var t = this.__data__;
    return hm ? t[e] !== void 0 : Mxe.call(t, e);
  }
  var jxe = "__lodash_hash_undefined__";
  function Ixe(e, t) {
    var n = this.__data__;
    return this.size += this.has(e) ? 0 : 1, n[e] = hm && t === void 0 ? jxe : t, this;
  }
  function gu(e) {
    var t = -1, n = e == null ? 0 : e.length;
    for (this.clear(); ++t < n; ) {
      var r = e[t];
      this.set(r[0], r[1]);
    }
  }
  gu.prototype.clear = Sxe;
  gu.prototype.delete = _xe;
  gu.prototype.get = Oxe;
  gu.prototype.has = Rxe;
  gu.prototype.set = Ixe;
  function Axe() {
    this.size = 0, this.__data__ = {
      hash: new gu(),
      map: new (mm || os)(),
      string: new gu()
    };
  }
  function $xe(e) {
    var t = typeof e;
    return t == "string" || t == "number" || t == "symbol" || t == "boolean" ? e !== "__proto__" : e === null;
  }
  function cx(e, t) {
    var n = e.__data__;
    return $xe(t) ? n[typeof t == "string" ? "string" : "hash"] : n.map;
  }
  function Dxe(e) {
    var t = cx(this, e).delete(e);
    return this.size -= t ? 1 : 0, t;
  }
  function Lxe(e) {
    return cx(this, e).get(e);
  }
  function Fxe(e) {
    return cx(this, e).has(e);
  }
  function Txe(e, t) {
    var n = cx(this, e), r = n.size;
    return n.set(e, t), this.size += n.size == r ? 0 : 1, this;
  }
  function as(e) {
    var t = -1, n = e == null ? 0 : e.length;
    for (this.clear(); ++t < n; ) {
      var r = e[t];
      this.set(r[0], r[1]);
    }
  }
  as.prototype.clear = Axe;
  as.prototype.delete = Dxe;
  as.prototype.get = Lxe;
  as.prototype.has = Fxe;
  as.prototype.set = Txe;
  var zxe = 200;
  function Bxe(e, t) {
    var n = this.__data__;
    if (n instanceof os) {
      var r = n.__data__;
      if (!mm || r.length < zxe - 1)
        return r.push([e, t]), this.size = ++n.size, this;
      n = this.__data__ = new as(r);
    }
    return n.set(e, t), this.size = n.size, this;
  }
  function Zo(e) {
    var t = this.__data__ = new os(e);
    this.size = t.size;
  }
  Zo.prototype.clear = rxe;
  Zo.prototype.delete = oxe;
  Zo.prototype.get = axe;
  Zo.prototype.has = ixe;
  Zo.prototype.set = Bxe;
  var Vxe = "__lodash_hash_undefined__";
  function Uxe(e) {
    return this.__data__.set(e, Vxe), this;
  }
  function Hxe(e) {
    return this.__data__.has(e);
  }
  function vu(e) {
    var t = -1, n = e == null ? 0 : e.length;
    for (this.__data__ = new as(); ++t < n; )
      this.add(e[t]);
  }
  vu.prototype.add = vu.prototype.push = Uxe;
  vu.prototype.has = Hxe;
  function Wxe(e, t) {
    for (var n = -1, r = e == null ? 0 : e.length; ++n < r; )
      if (t(e[n], n, e))
        return !0;
    return !1;
  }
  function gm(e, t) {
    return e.has(t);
  }
  var qxe = 1, Kxe = 2;
  function cV(e, t, n, r, o, a) {
    var i = n & qxe, s = e.length, u = t.length;
    if (s != u && !(i && u > s))
      return !1;
    var c = a.get(e), f = a.get(t);
    if (c && f)
      return c == t && f == e;
    var p = -1, g = !0, h = n & Kxe ? new vu() : void 0;
    for (a.set(e, t), a.set(t, e); ++p < s; ) {
      var y = e[p], b = t[p];
      if (r)
        var v = i ? r(b, y, p, t, e, a) : r(y, b, p, e, t, a);
      if (v !== void 0) {
        if (v)
          continue;
        g = !1;
        break;
      }
      if (h) {
        if (!Wxe(t, function(w, _) {
          if (!gm(h, _) && (y === w || o(y, w, n, r, a)))
            return h.push(_);
        })) {
          g = !1;
          break;
        }
      } else if (!(y === b || o(y, b, n, r, a))) {
        g = !1;
        break;
      }
    }
    return a.delete(e), a.delete(t), g;
  }
  var $b = ti.Uint8Array;
  function Gxe(e) {
    var t = -1, n = Array(e.size);
    return e.forEach(function(r, o) {
      n[++t] = [o, r];
    }), n;
  }
  function DP(e) {
    var t = -1, n = Array(e.size);
    return e.forEach(function(r) {
      n[++t] = r;
    }), n;
  }
  var Xxe = 1, Yxe = 2, Jxe = "[object Boolean]", Qxe = "[object Date]", Zxe = "[object Error]", eke = "[object Map]", tke = "[object Number]", nke = "[object RegExp]", rke = "[object Set]", oke = "[object String]", ake = "[object Symbol]", ike = "[object ArrayBuffer]", ske = "[object DataView]", _3 = Ao ? Ao.prototype : void 0, n0 = _3 ? _3.valueOf : void 0;
  function lke(e, t, n, r, o, a, i) {
    switch (n) {
      case ske:
        if (e.byteLength != t.byteLength || e.byteOffset != t.byteOffset)
          return !1;
        e = e.buffer, t = t.buffer;
      case ike:
        return !(e.byteLength != t.byteLength || !a(new $b(e), new $b(t)));
      case Jxe:
      case Qxe:
      case tke:
        return sh(+e, +t);
      case Zxe:
        return e.name == t.name && e.message == t.message;
      case nke:
      case oke:
        return e == t + "";
      case eke:
        var s = Gxe;
      case rke:
        var u = r & Xxe;
        if (s || (s = DP), e.size != t.size && !u)
          return !1;
        var c = i.get(e);
        if (c)
          return c == t;
        r |= Yxe, i.set(e, t);
        var f = cV(s(e), s(t), r, o, a, i);
        return i.delete(e), f;
      case ake:
        if (n0)
          return n0.call(e) == n0.call(t);
    }
    return !1;
  }
  function LP(e, t) {
    for (var n = -1, r = t.length, o = e.length; ++n < r; )
      e[o + n] = t[n];
    return e;
  }
  var Yn = Array.isArray;
  function dV(e, t, n) {
    var r = t(e);
    return Yn(e) ? r : LP(r, n(e));
  }
  function uke(e, t) {
    for (var n = -1, r = e == null ? 0 : e.length, o = 0, a = []; ++n < r; ) {
      var i = e[n];
      t(i, n, e) && (a[o++] = i);
    }
    return a;
  }
  function fV() {
    return [];
  }
  var cke = Object.prototype, dke = cke.propertyIsEnumerable, E3 = Object.getOwnPropertySymbols, FP = E3 ? function(e) {
    return e == null ? [] : (e = Object(e), uke(E3(e), function(t) {
      return dke.call(e, t);
    }));
  } : fV;
  function pV(e, t) {
    for (var n = -1, r = Array(e); ++n < e; )
      r[n] = t(n);
    return r;
  }
  var fke = "[object Arguments]";
  function C3(e) {
    return $o(e) && rs(e) == fke;
  }
  var mV = Object.prototype, pke = mV.hasOwnProperty, mke = mV.propertyIsEnumerable, Cd = C3(/* @__PURE__ */ (function() {
    return arguments;
  })()) ? C3 : function(e) {
    return $o(e) && pke.call(e, "callee") && !mke.call(e, "callee");
  };
  function hke() {
    return !1;
  }
  var hV = typeof so == "object" && so && !so.nodeType && so, P3 = hV && typeof lo == "object" && lo && !lo.nodeType && lo, gke = P3 && P3.exports === hV, O3 = gke ? ti.Buffer : void 0, vke = O3 ? O3.isBuffer : void 0, yu = vke || hke, yke = 9007199254740991, bke = /^(?:0|[1-9]\d*)$/;
  function dx(e, t) {
    var n = typeof e;
    return t = t ?? yke, !!t && (n == "number" || n != "symbol" && bke.test(e)) && e > -1 && e % 1 == 0 && e < t;
  }
  var wke = 9007199254740991;
  function TP(e) {
    return typeof e == "number" && e > -1 && e % 1 == 0 && e <= wke;
  }
  var xke = "[object Arguments]", kke = "[object Array]", Ske = "[object Boolean]", _ke = "[object Date]", Eke = "[object Error]", Cke = "[object Function]", Pke = "[object Map]", Oke = "[object Number]", Nke = "[object Object]", Mke = "[object RegExp]", Rke = "[object Set]", jke = "[object String]", Ike = "[object WeakMap]", Ake = "[object ArrayBuffer]", $ke = "[object DataView]", Dke = "[object Float32Array]", Lke = "[object Float64Array]", Fke = "[object Int8Array]", Tke = "[object Int16Array]", zke = "[object Int32Array]", Bke = "[object Uint8Array]", Vke = "[object Uint8ClampedArray]", Uke = "[object Uint16Array]", Hke = "[object Uint32Array]", hn = {};
  hn[Dke] = hn[Lke] = hn[Fke] = hn[Tke] = hn[zke] = hn[Bke] = hn[Vke] = hn[Uke] = hn[Hke] = !0;
  hn[xke] = hn[kke] = hn[Ake] = hn[Ske] = hn[$ke] = hn[_ke] = hn[Eke] = hn[Cke] = hn[Pke] = hn[Oke] = hn[Nke] = hn[Mke] = hn[Rke] = hn[jke] = hn[Ike] = !1;
  function Wke(e) {
    return $o(e) && TP(e.length) && !!hn[rs(e)];
  }
  function zP(e) {
    return function(t) {
      return e(t);
    };
  }
  var gV = typeof so == "object" && so && !so.nodeType && so, $p = gV && typeof lo == "object" && lo && !lo.nodeType && lo, qke = $p && $p.exports === gV, r0 = qke && iV.process, Pd = (function() {
    try {
      var e = $p && $p.require && $p.require("util").types;
      return e || r0 && r0.binding && r0.binding("util");
    } catch {
    }
  })(), N3 = Pd && Pd.isTypedArray, uh = N3 ? zP(N3) : Wke, Kke = Object.prototype, Gke = Kke.hasOwnProperty;
  function vV(e, t) {
    var n = Yn(e), r = !n && Cd(e), o = !n && !r && yu(e), a = !n && !r && !o && uh(e), i = n || r || o || a, s = i ? pV(e.length, String) : [], u = s.length;
    for (var c in e)
      (t || Gke.call(e, c)) && !(i && // Safari 9 has enumerable `arguments.length` in strict mode.
      (c == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
      o && (c == "offset" || c == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
      a && (c == "buffer" || c == "byteLength" || c == "byteOffset") || // Skip index properties.
      dx(c, u))) && s.push(c);
    return s;
  }
  var Xke = Object.prototype;
  function fx(e) {
    var t = e && e.constructor, n = typeof t == "function" && t.prototype || Xke;
    return e === n;
  }
  var Yke = lV(Object.keys, Object), Jke = Object.prototype, Qke = Jke.hasOwnProperty;
  function yV(e) {
    if (!fx(e))
      return Yke(e);
    var t = [];
    for (var n in Object(e))
      Qke.call(e, n) && n != "constructor" && t.push(n);
    return t;
  }
  function Pu(e) {
    return e != null && TP(e.length) && !lh(e);
  }
  function Xo(e) {
    return Pu(e) ? vV(e) : yV(e);
  }
  function sE(e) {
    return dV(e, Xo, FP);
  }
  var Zke = 1, eSe = Object.prototype, tSe = eSe.hasOwnProperty;
  function nSe(e, t, n, r, o, a) {
    var i = n & Zke, s = sE(e), u = s.length, c = sE(t), f = c.length;
    if (u != f && !i)
      return !1;
    for (var p = u; p--; ) {
      var g = s[p];
      if (!(i ? g in t : tSe.call(t, g)))
        return !1;
    }
    var h = a.get(e), y = a.get(t);
    if (h && y)
      return h == t && y == e;
    var b = !0;
    a.set(e, t), a.set(t, e);
    for (var v = i; ++p < u; ) {
      g = s[p];
      var w = e[g], _ = t[g];
      if (r)
        var k = i ? r(_, w, g, t, e, a) : r(w, _, g, e, t, a);
      if (!(k === void 0 ? w === _ || o(w, _, n, r, a) : k)) {
        b = !1;
        break;
      }
      v || (v = g == "constructor");
    }
    if (b && !v) {
      var E = e.constructor, P = t.constructor;
      E != P && "constructor" in e && "constructor" in t && !(typeof E == "function" && E instanceof E && typeof P == "function" && P instanceof P) && (b = !1);
    }
    return a.delete(e), a.delete(t), b;
  }
  var lE = Cu(ti, "DataView"), uE = Cu(ti, "Promise"), ld = Cu(ti, "Set"), cE = Cu(ti, "WeakMap"), M3 = "[object Map]", rSe = "[object Object]", R3 = "[object Promise]", j3 = "[object Set]", I3 = "[object WeakMap]", A3 = "[object DataView]", oSe = Eu(lE), aSe = Eu(mm), iSe = Eu(uE), sSe = Eu(ld), lSe = Eu(cE), Oo = rs;
  (lE && Oo(new lE(new ArrayBuffer(1))) != A3 || mm && Oo(new mm()) != M3 || uE && Oo(uE.resolve()) != R3 || ld && Oo(new ld()) != j3 || cE && Oo(new cE()) != I3) && (Oo = function(e) {
    var t = rs(e), n = t == rSe ? e.constructor : void 0, r = n ? Eu(n) : "";
    if (r)
      switch (r) {
        case oSe:
          return A3;
        case aSe:
          return M3;
        case iSe:
          return R3;
        case sSe:
          return j3;
        case lSe:
          return I3;
      }
    return t;
  });
  var uSe = 1, $3 = "[object Arguments]", D3 = "[object Array]", _v = "[object Object]", cSe = Object.prototype, L3 = cSe.hasOwnProperty;
  function dSe(e, t, n, r, o, a) {
    var i = Yn(e), s = Yn(t), u = i ? D3 : Oo(e), c = s ? D3 : Oo(t);
    u = u == $3 ? _v : u, c = c == $3 ? _v : c;
    var f = u == _v, p = c == _v, g = u == c;
    if (g && yu(e)) {
      if (!yu(t))
        return !1;
      i = !0, f = !1;
    }
    if (g && !f)
      return a || (a = new Zo()), i || uh(e) ? cV(e, t, n, r, o, a) : lke(e, t, u, n, r, o, a);
    if (!(n & uSe)) {
      var h = f && L3.call(e, "__wrapped__"), y = p && L3.call(t, "__wrapped__");
      if (h || y) {
        var b = h ? e.value() : e, v = y ? t.value() : t;
        return a || (a = new Zo()), o(b, v, n, r, a);
      }
    }
    return g ? (a || (a = new Zo()), nSe(e, t, n, r, o, a)) : !1;
  }
  function ch(e, t, n, r, o) {
    return e === t ? !0 : e == null || t == null || !$o(e) && !$o(t) ? e !== e && t !== t : dSe(e, t, n, r, ch, o);
  }
  function fSe(e, t, n) {
    n = typeof n == "function" ? n : void 0;
    var r = n ? n(e, t) : void 0;
    return r === void 0 ? ch(e, t, void 0, n) : !!r;
  }
  function fn(e, t) {
    return fSe(e, t, (n, r) => {
      if (typeof n == "function" && typeof r == "function")
        return !0;
    });
  }
  var pSe = "[object Symbol]";
  function dh(e) {
    return typeof e == "symbol" || $o(e) && rs(e) == pSe;
  }
  var mSe = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, hSe = /^\w*$/;
  function BP(e, t) {
    if (Yn(e))
      return !1;
    var n = typeof e;
    return n == "number" || n == "symbol" || n == "boolean" || e == null || dh(e) ? !0 : hSe.test(e) || !mSe.test(e) || t != null && e in Object(t);
  }
  var gSe = "Expected a function";
  function VP(e, t) {
    if (typeof e != "function" || t != null && typeof t != "function")
      throw new TypeError(gSe);
    var n = function() {
      var r = arguments, o = t ? t.apply(this, r) : r[0], a = n.cache;
      if (a.has(o))
        return a.get(o);
      var i = e.apply(this, r);
      return n.cache = a.set(o, i) || a, i;
    };
    return n.cache = new (VP.Cache || as)(), n;
  }
  VP.Cache = as;
  var vSe = 500;
  function ySe(e) {
    var t = VP(e, function(r) {
      return n.size === vSe && n.clear(), r;
    }), n = t.cache;
    return t;
  }
  var bSe = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g, wSe = /\\(\\)?/g, bV = ySe(function(e) {
    var t = [];
    return e.charCodeAt(0) === 46 && t.push(""), e.replace(bSe, function(n, r, o, a) {
      t.push(o ? a.replace(wSe, "$1") : r || n);
    }), t;
  });
  function Ud(e, t) {
    for (var n = -1, r = e == null ? 0 : e.length, o = Array(r); ++n < r; )
      o[n] = t(e[n], n, e);
    return o;
  }
  var F3 = Ao ? Ao.prototype : void 0, T3 = F3 ? F3.toString : void 0;
  function wV(e) {
    if (typeof e == "string")
      return e;
    if (Yn(e))
      return Ud(e, wV) + "";
    if (dh(e))
      return T3 ? T3.call(e) : "";
    var t = e + "";
    return t == "0" && 1 / e == -1 / 0 ? "-0" : t;
  }
  function UP(e) {
    return e == null ? "" : wV(e);
  }
  function Hd(e, t) {
    return Yn(e) ? e : BP(e, t) ? [e] : bV(UP(e));
  }
  function Ou(e) {
    if (typeof e == "string" || dh(e))
      return e;
    var t = e + "";
    return t == "0" && 1 / e == -1 / 0 ? "-0" : t;
  }
  function px(e, t) {
    t = Hd(t, e);
    for (var n = 0, r = t.length; e != null && n < r; )
      e = e[Ou(t[n++])];
    return n && n == r ? e : void 0;
  }
  function Ce(e, t, n) {
    var r = e == null ? void 0 : px(e, t);
    return r === void 0 ? n : r;
  }
  var xSe = Object.prototype, kSe = xSe.hasOwnProperty;
  function SSe(e, t) {
    return e != null && kSe.call(e, t);
  }
  function xV(e, t, n) {
    t = Hd(t, e);
    for (var r = -1, o = t.length, a = !1; ++r < o; ) {
      var i = Ou(t[r]);
      if (!(a = e != null && n(e, i)))
        break;
      e = e[i];
    }
    return a || ++r != o ? a : (o = e == null ? 0 : e.length, !!o && TP(o) && dx(i, o) && (Yn(e) || Cd(e)));
  }
  function Et(e, t) {
    return e != null && xV(e, t, SSe);
  }
  function vm(e, t) {
    return ch(e, t);
  }
  var Db = (function() {
    try {
      var e = Cu(Object, "defineProperty");
      return e({}, "", {}), e;
    } catch {
    }
  })();
  function HP(e, t, n) {
    t == "__proto__" && Db ? Db(e, t, {
      configurable: !0,
      enumerable: !0,
      value: n,
      writable: !0
    }) : e[t] = n;
  }
  var _Se = Object.prototype, ESe = _Se.hasOwnProperty;
  function WP(e, t, n) {
    var r = e[t];
    (!(ESe.call(e, t) && sh(r, n)) || n === void 0 && !(t in e)) && HP(e, t, n);
  }
  function qP(e, t, n, r) {
    if (!jt(e))
      return e;
    t = Hd(t, e);
    for (var o = -1, a = t.length, i = a - 1, s = e; s != null && ++o < a; ) {
      var u = Ou(t[o]), c = n;
      if (u === "__proto__" || u === "constructor" || u === "prototype")
        return e;
      if (o != i) {
        var f = s[u];
        c = r ? r(f, u, s) : void 0, c === void 0 && (c = jt(f) ? f : dx(t[o + 1]) ? [] : {});
      }
      WP(s, u, c), s = s[u];
    }
    return e;
  }
  function Qt(e, t, n) {
    return e == null ? e : qP(e, t, n);
  }
  function mx(e) {
    return e;
  }
  function kV(e) {
    return typeof e == "function" ? e : mx;
  }
  var CSe = /\s/;
  function PSe(e) {
    for (var t = e.length; t-- && CSe.test(e.charAt(t)); )
      ;
    return t;
  }
  var OSe = /^\s+/;
  function NSe(e) {
    return e && e.slice(0, PSe(e) + 1).replace(OSe, "");
  }
  var z3 = NaN, MSe = /^[-+]0x[0-9a-f]+$/i, RSe = /^0b[01]+$/i, jSe = /^0o[0-7]+$/i, ISe = parseInt;
  function ASe(e) {
    if (typeof e == "number")
      return e;
    if (dh(e))
      return z3;
    if (jt(e)) {
      var t = typeof e.valueOf == "function" ? e.valueOf() : e;
      e = jt(t) ? t + "" : t;
    }
    if (typeof e != "string")
      return e === 0 ? e : +e;
    e = NSe(e);
    var n = RSe.test(e);
    return n || jSe.test(e) ? ISe(e.slice(2), n ? 2 : 8) : MSe.test(e) ? z3 : +e;
  }
  var B3 = 1 / 0, $Se = 17976931348623157e292;
  function DSe(e) {
    if (!e)
      return e === 0 ? e : 0;
    if (e = ASe(e), e === B3 || e === -B3) {
      var t = e < 0 ? -1 : 1;
      return t * $Se;
    }
    return e === e ? e : 0;
  }
  function SV(e) {
    var t = DSe(e), n = t % 1;
    return t === t ? n ? t - n : t : 0;
  }
  var LSe = 9007199254740991, o0 = 4294967295, FSe = Math.min;
  function _V(e, t) {
    if (e = SV(e), e < 1 || e > LSe)
      return [];
    var n = o0, r = FSe(e, o0);
    t = kV(t), e -= o0;
    for (var o = pV(r, t); ++n < e; )
      t(n);
    return o;
  }
  function KP(e, t) {
    for (var n = -1, r = e == null ? 0 : e.length; ++n < r && t(e[n], n, e) !== !1; )
      ;
    return e;
  }
  var V3 = Object.create, EV = /* @__PURE__ */ (function() {
    function e() {
    }
    return function(t) {
      if (!jt(t))
        return {};
      if (V3)
        return V3(t);
      e.prototype = t;
      var n = new e();
      return e.prototype = void 0, n;
    };
  })();
  function TSe(e) {
    return function(t, n, r) {
      for (var o = -1, a = Object(t), i = r(t), s = i.length; s--; ) {
        var u = i[++o];
        if (n(a[u], u, a) === !1)
          break;
      }
      return t;
    };
  }
  var CV = TSe();
  function PV(e, t) {
    return e && CV(e, t, Xo);
  }
  var zSe = 1, BSe = 2;
  function VSe(e, t, n, r) {
    var o = n.length, a = o;
    if (e == null)
      return !a;
    for (e = Object(e); o--; ) {
      var i = n[o];
      if (i[2] ? i[1] !== e[i[0]] : !(i[0] in e))
        return !1;
    }
    for (; ++o < a; ) {
      i = n[o];
      var s = i[0], u = e[s], c = i[1];
      if (i[2]) {
        if (u === void 0 && !(s in e))
          return !1;
      } else {
        var f = new Zo(), p;
        if (!(p === void 0 ? ch(c, u, zSe | BSe, r, f) : p))
          return !1;
      }
    }
    return !0;
  }
  function OV(e) {
    return e === e && !jt(e);
  }
  function USe(e) {
    for (var t = Xo(e), n = t.length; n--; ) {
      var r = t[n], o = e[r];
      t[n] = [r, o, OV(o)];
    }
    return t;
  }
  function NV(e, t) {
    return function(n) {
      return n == null ? !1 : n[e] === t && (t !== void 0 || e in Object(n));
    };
  }
  function HSe(e) {
    var t = USe(e);
    return t.length == 1 && t[0][2] ? NV(t[0][0], t[0][1]) : function(n) {
      return n === e || VSe(n, e, t);
    };
  }
  function WSe(e, t) {
    return e != null && t in Object(e);
  }
  function MV(e, t) {
    return e != null && xV(e, t, WSe);
  }
  var qSe = 1, KSe = 2;
  function GSe(e, t) {
    return BP(e) && OV(t) ? NV(Ou(e), t) : function(n) {
      var r = Ce(n, e);
      return r === void 0 && r === t ? MV(n, e) : ch(t, r, qSe | KSe);
    };
  }
  function XSe(e) {
    return function(t) {
      return t?.[e];
    };
  }
  function YSe(e) {
    return function(t) {
      return px(t, e);
    };
  }
  function JSe(e) {
    return BP(e) ? XSe(Ou(e)) : YSe(e);
  }
  function GP(e) {
    return typeof e == "function" ? e : e == null ? mx : typeof e == "object" ? Yn(e) ? GSe(e[0], e[1]) : HSe(e) : JSe(e);
  }
  function QSe(e, t, n) {
    var r = Yn(e), o = r || yu(e) || uh(e);
    if (t = GP(t), n == null) {
      var a = e && e.constructor;
      o ? n = r ? new a() : [] : jt(e) ? n = lh(a) ? EV(lx(e)) : {} : n = {};
    }
    return (o ? KP : PV)(e, function(i, s, u) {
      return t(n, i, s, u);
    }), n;
  }
  function dE(e, t, n) {
    (n !== void 0 && !sh(e[t], n) || n === void 0 && !(t in e)) && HP(e, t, n);
  }
  var RV = typeof so == "object" && so && !so.nodeType && so, U3 = RV && typeof lo == "object" && lo && !lo.nodeType && lo, ZSe = U3 && U3.exports === RV, H3 = ZSe ? ti.Buffer : void 0, W3 = H3 ? H3.allocUnsafe : void 0;
  function jV(e, t) {
    if (t)
      return e.slice();
    var n = e.length, r = W3 ? W3(n) : new e.constructor(n);
    return e.copy(r), r;
  }
  function XP(e) {
    var t = new e.constructor(e.byteLength);
    return new $b(t).set(new $b(e)), t;
  }
  function IV(e, t) {
    var n = t ? XP(e.buffer) : e.buffer;
    return new e.constructor(n, e.byteOffset, e.length);
  }
  function YP(e, t) {
    var n = -1, r = e.length;
    for (t || (t = Array(r)); ++n < r; )
      t[n] = e[n];
    return t;
  }
  function AV(e) {
    return typeof e.constructor == "function" && !fx(e) ? EV(lx(e)) : {};
  }
  function ym(e) {
    return $o(e) && Pu(e);
  }
  function fE(e, t) {
    if (!(t === "constructor" && typeof e[t] == "function") && t != "__proto__")
      return e[t];
  }
  function Wd(e, t, n, r) {
    var o = !n;
    n || (n = {});
    for (var a = -1, i = t.length; ++a < i; ) {
      var s = t[a], u = void 0;
      u === void 0 && (u = e[s]), o ? HP(n, s, u) : WP(n, s, u);
    }
    return n;
  }
  function e_e(e) {
    var t = [];
    if (e != null)
      for (var n in Object(e))
        t.push(n);
    return t;
  }
  var t_e = Object.prototype, n_e = t_e.hasOwnProperty;
  function r_e(e) {
    if (!jt(e))
      return e_e(e);
    var t = fx(e), n = [];
    for (var r in e)
      r == "constructor" && (t || !n_e.call(e, r)) || n.push(r);
    return n;
  }
  function fh(e) {
    return Pu(e) ? vV(e, !0) : r_e(e);
  }
  function o_e(e) {
    return Wd(e, fh(e));
  }
  function a_e(e, t, n, r, o, a, i) {
    var s = fE(e, n), u = fE(t, n), c = i.get(u);
    if (c) {
      dE(e, n, c);
      return;
    }
    var f = a ? a(s, u, n + "", e, t, i) : void 0, p = f === void 0;
    if (p) {
      var g = Yn(u), h = !g && yu(u), y = !g && !h && uh(u);
      f = u, g || h || y ? Yn(s) ? f = s : ym(s) ? f = YP(s) : h ? (p = !1, f = jV(u, !0)) : y ? (p = !1, f = IV(u, !0)) : f = [] : dl(u) || Cd(u) ? (f = s, Cd(s) ? f = o_e(s) : (!jt(s) || lh(s)) && (f = AV(u))) : p = !1;
    }
    p && (i.set(u, f), o(f, u, r, a, i), i.delete(u)), dE(e, n, f);
  }
  function $V(e, t, n, r, o) {
    e !== t && CV(t, function(a, i) {
      if (o || (o = new Zo()), jt(a))
        a_e(e, t, i, n, $V, r, o);
      else {
        var s = r ? r(fE(e, i), a, i + "", e, t, o) : void 0;
        s === void 0 && (s = a), dE(e, i, s);
      }
    }, fh);
  }
  function i_e(e, t, n) {
    switch (n.length) {
      case 0:
        return e.call(t);
      case 1:
        return e.call(t, n[0]);
      case 2:
        return e.call(t, n[0], n[1]);
      case 3:
        return e.call(t, n[0], n[1], n[2]);
    }
    return e.apply(t, n);
  }
  var q3 = Math.max;
  function DV(e, t, n) {
    return t = q3(t === void 0 ? e.length - 1 : t, 0), function() {
      for (var r = arguments, o = -1, a = q3(r.length - t, 0), i = Array(a); ++o < a; )
        i[o] = r[t + o];
      o = -1;
      for (var s = Array(t + 1); ++o < t; )
        s[o] = r[o];
      return s[t] = n(i), i_e(e, this, s);
    };
  }
  function s_e(e) {
    return function() {
      return e;
    };
  }
  var l_e = Db ? function(e, t) {
    return Db(e, "toString", {
      configurable: !0,
      enumerable: !1,
      value: s_e(t),
      writable: !0
    });
  } : mx, u_e = 800, c_e = 16, d_e = Date.now;
  function f_e(e) {
    var t = 0, n = 0;
    return function() {
      var r = d_e(), o = c_e - (r - n);
      if (n = r, o > 0) {
        if (++t >= u_e)
          return arguments[0];
      } else
        t = 0;
      return e.apply(void 0, arguments);
    };
  }
  var LV = f_e(l_e);
  function hx(e, t) {
    return LV(DV(e, t, mx), e + "");
  }
  function p_e(e, t, n) {
    if (!jt(n))
      return !1;
    var r = typeof t;
    return (r == "number" ? Pu(n) && dx(t, n.length) : r == "string" && t in n) ? sh(n[t], e) : !1;
  }
  function m_e(e) {
    return hx(function(t, n) {
      var r = -1, o = n.length, a = o > 1 ? n[o - 1] : void 0, i = o > 2 ? n[2] : void 0;
      for (a = e.length > 3 && typeof a == "function" ? (o--, a) : void 0, i && p_e(n[0], n[1], i) && (a = o < 3 ? void 0 : a, o = 1), t = Object(t); ++r < o; ) {
        var s = n[r];
        s && e(t, s, r, a);
      }
      return t;
    });
  }
  var h_e = m_e(function(e, t, n) {
    $V(e, t, n);
  }), K3 = Ao ? Ao.isConcatSpreadable : void 0;
  function g_e(e) {
    return Yn(e) || Cd(e) || !!(K3 && e && e[K3]);
  }
  function ph(e, t, n, r, o) {
    var a = -1, i = e.length;
    for (n || (n = g_e), o || (o = []); ++a < i; ) {
      var s = e[a];
      t > 0 && n(s) ? t > 1 ? ph(s, t - 1, n, r, o) : LP(o, s) : r || (o[o.length] = s);
    }
    return o;
  }
  var v_e = 1 / 0;
  function y_e(e) {
    var t = e == null ? 0 : e.length;
    return t ? ph(e, v_e) : [];
  }
  function b_e(e, t, n, r) {
    for (var o = e.length, a = n + -1; ++a < o; )
      if (t(e[a], a, e))
        return a;
    return -1;
  }
  function w_e(e) {
    return e !== e;
  }
  function x_e(e, t, n) {
    for (var r = n - 1, o = e.length; ++r < o; )
      if (e[r] === t)
        return r;
    return -1;
  }
  function FV(e, t, n) {
    return t === t ? x_e(e, t, n) : b_e(e, w_e, n);
  }
  function JP(e, t) {
    var n = e == null ? 0 : e.length;
    return !!n && FV(e, t, 0) > -1;
  }
  function Hy() {
  }
  var k_e = 1 / 0, S_e = ld && 1 / DP(new ld([, -0]))[1] == k_e ? function(e) {
    return new ld(e);
  } : Hy, __e = 200;
  function TV(e, t, n) {
    var r = -1, o = JP, a = e.length, i = !0, s = [], u = s;
    if (a >= __e) {
      var c = S_e(e);
      if (c)
        return DP(c);
      i = !1, o = gm, u = new vu();
    } else
      u = s;
    e:
      for (; ++r < a; ) {
        var f = e[r], p = f;
        if (f = f !== 0 ? f : 0, i && p === p) {
          for (var g = u.length; g--; )
            if (u[g] === p)
              continue e;
          s.push(f);
        } else o(u, p, n) || (u !== s && u.push(p), s.push(f));
      }
    return s;
  }
  function zV(e) {
    return e && e.length ? TV(e) : [];
  }
  var E_e = "[object Map]", C_e = "[object Set]", P_e = Object.prototype, O_e = P_e.hasOwnProperty;
  function Hn(e) {
    if (e == null)
      return !0;
    if (Pu(e) && (Yn(e) || typeof e == "string" || typeof e.splice == "function" || yu(e) || uh(e) || Cd(e)))
      return !e.length;
    var t = Oo(e);
    if (t == E_e || t == C_e)
      return !e.size;
    if (fx(e))
      return !yV(e).length;
    for (var n in e)
      if (O_e.call(e, n))
        return !1;
    return !0;
  }
  const N_e = Object.prototype;
  function kp(e) {
    for (const t in e)
      if (N_e.hasOwnProperty.call(e, t))
        return !1;
    return !0;
  }
  const M_e = [
    "array",
    "boolean",
    "integer",
    "null",
    "number",
    "object",
    "string"
  ];
  new Set(M_e);
  const R_e = [
    "$defs",
    "definitions",
    "properties",
    "patternProperties",
    "dependencies"
  ];
  new Set(R_e);
  const j_e = [
    "items",
    "allOf",
    "oneOf",
    "anyOf"
  ];
  new Set(j_e);
  const I_e = [
    "items",
    "additionalItems",
    "additionalProperties",
    "propertyNames",
    "contains",
    "if",
    "then",
    "else",
    "not"
  ];
  new Set(I_e);
  function Wy(e) {
    return typeof e == "object";
  }
  function _a(e) {
    return Wy(e) ? kp(e) : e === !0;
  }
  function Xc(e, t) {
    return e < t ? -1 : e > t ? 1 : 0;
  }
  function a0(e, t) {
    const n = e.length;
    if (n === 0)
      return t;
    let r = t.length;
    if (r === 0)
      return e;
    if (n < r) {
      const a = e;
      e = t, t = a, r = n;
    }
    const o = new Set(e);
    for (let a = 0; a < r; a++)
      o.add(t[a]);
    return Array.from(o);
  }
  function A_e(e, t) {
    const n = [];
    if (e.length === 0 || t.length === 0)
      return n;
    if (e.length > t.length) {
      const o = e;
      e = t, t = o;
    }
    const r = new Set(t);
    for (let o = 0; o < e.length && r.size > 0; o++) {
      const a = e[o];
      r.delete(a) && n.push(a);
    }
    return n;
  }
  function G3(e) {
    return e.length === 0;
  }
  function i0(e) {
    return (t, n) => {
      const r = t.length - n.length;
      if (r !== 0)
        return r;
      for (let o = 0; o < t.length; o++)
        if (t[o] !== n[o]) {
          const a = e(t[o], n[o]);
          if (a !== 0)
            return a;
        }
      return 0;
    };
  }
  function BV(e, { threshold: t = 12 } = {}) {
    return (n) => {
      const r = n.length;
      if (r === 0)
        return n;
      if (r <= t) {
        const i = [];
        let s = 0;
        e: for (let u = 0; u < r; u++) {
          const c = n[u];
          for (let f = 0; f < s; f++)
            if (e(c, i[f]) === 0)
              continue e;
          s = i.push(c);
        }
        return i;
      }
      const o = n.slice().sort(e);
      let a = 0;
      for (let i = 1; i < r; i++)
        e(o[a], o[i]) !== 0 && ++a !== i && (o[a] = o[i]);
      return o.length = a + 1, o;
    };
  }
  function $_e(e) {
    return (t, n) => {
      const r = [];
      let o = t.length, a = n.length;
      if (o === 0 || a === 0)
        return r;
      if (o > a) {
        const f = t;
        t = n, n = f;
        const p = o;
        o = a, a = p;
      }
      const i = [...t].sort(e), s = [...n].sort(e);
      let u = 0, c = 0;
      for (; u < o && c < a; ) {
        const f = e(i[u], s[c]);
        f === 0 ? ((r.length === 0 || e(r[r.length - 1], i[u]) !== 0) && r.push(i[u]), u++, c++) : f < 0 ? u++ : c++;
      }
      return r;
    };
  }
  function D_e(e, t) {
    return (n) => {
      if (e.has(n))
        return e.get(n);
      const r = t(n);
      return e.set(n, r), r;
    };
  }
  const X3 = D_e, VV = () => 0, L_e = (e) => e === void 0, F_e = (e) => typeof e != "object", Y3 = {
    boolean: 0,
    number: 1,
    string: 2
  };
  function T_e(e, t) {
    const n = typeof e, r = typeof t;
    return n === r ? Xc(e, t) : Y3[n] - Y3[r];
  }
  function z_e(e, t) {
    const n = e.length;
    if (n === 0)
      return t;
    const r = t.length;
    if (r === 0)
      return e;
    if (r > n) {
      const i = e;
      e = t, t = i;
    }
    const o = new Set(e), a = t.length;
    for (let i = 0; i < a; i++) {
      const s = t[i];
      o.has(s) || e.push(s);
    }
    return e;
  }
  function gx(e, t, n = VV) {
    return (r, o) => e(r) ? e(o) ? n(r, o) : -1 : e(o) ? 1 : t(r, o);
  }
  function Vc(e) {
    return gx(L_e, e);
  }
  function Vs(e, t) {
    return gx((n) => n === void 0 || e(n), t);
  }
  function s0(e, t) {
    return gx(Array.isArray, e, t);
  }
  const zn = Vc(Xc), l0 = Vs((e) => e === 0, (e, t) => e - t);
  function B_e({ deduplicationCache: e = /* @__PURE__ */ new WeakMap(), sortedKeysCache: t = /* @__PURE__ */ new WeakMap() } = {}) {
    const n = X3(t, (b) => Object.keys(b).sort());
    function r(b) {
      return (v, w) => {
        const _ = n(v), k = n(w), E = Math.min(_.length, k.length);
        for (let P = 0; P < E; P++) {
          const O = Xc(_[P], k[P]);
          if (O !== 0)
            return O;
        }
        if (_.length !== k.length)
          return _.length - k.length;
        for (let P = 0; P < E; P++) {
          const O = _[P], M = b(v[O], w[O]);
          if (M !== 0)
            return M;
        }
        return 0;
      };
    }
    function o(b) {
      const v = i0(b), w = X3(
        e,
        // NOTE: Always sort output
        BV(b, { threshold: 0 })
      );
      return (_, k) => v(w(_), w(k));
    }
    const a = o(Xc);
    function i(b, v) {
      if (Wy(b)) {
        if (Wy(v)) {
          const w = Object.keys(b), _ = Object.keys(v), k = z_e(w, _), E = k.length;
          for (let P = 0; P < E; P++) {
            const O = k[P];
            if (b[O] === v[O])
              continue;
            const M = (y[O] ?? s)(b[O], v[O]);
            if (M !== 0)
              return M;
          }
          return 0;
        }
        return v === !0 && kp(b) ? 0 : 1;
      }
      return Wy(v) ? b === !0 && kp(v) ? 0 : -1 : Xc(b, v);
    }
    const s = Vc(c), u = gx(F_e, s0(r(s), i0(c)), T_e);
    function c(b, v) {
      return b === null ? -1 : v === null ? 1 : u(b, v);
    }
    const f = Vc(i), p = Vs(kp, r(f)), g = Vc(o(i)), h = Vs(_a, i), y = {
      $id: zn,
      $comment: zn,
      $defs: p,
      $ref: zn,
      $schema: zn,
      const: s,
      contains: f,
      contentEncoding: zn,
      contentMediaType: zn,
      default: s,
      definitions: p,
      description: zn,
      else: f,
      examples: s,
      exclusiveMaximum: zn,
      exclusiveMinimum: zn,
      format: zn,
      if: f,
      maximum: zn,
      maxItems: zn,
      maxLength: zn,
      maxProperties: zn,
      minimum: zn,
      multipleOf: zn,
      not: f,
      pattern: zn,
      propertyNames: f,
      readOnly: zn,
      then: f,
      title: zn,
      writeOnly: zn,
      uniqueItems: Vs((b) => b === !1, VV),
      minLength: l0,
      minItems: l0,
      minProperties: l0,
      required: Vs(G3, a),
      enum: Vs(G3, o(c)),
      type: Vc((b, v) => {
        const w = Array.isArray(b), _ = Array.isArray(v);
        return !w && !_ ? Xc(b, v) : a(w ? b : [b], _ ? v : [v]);
      }),
      items: Vs((b) => !Array.isArray(b) && _a(b), s0(i, i0(i))),
      anyOf: g,
      allOf: g,
      oneOf: g,
      properties: p,
      patternProperties: p,
      additionalProperties: h,
      additionalItems: h,
      dependencies: Vs(kp, r(Vc(s0(i, a))))
    };
    return {
      compareSchemaValues: c,
      compareSchemaDefinitions: i
    };
  }
  function J3(e) {
    return e;
  }
  const UV = (e, t) => e ? UV(t % e, e) : t, V_e = (e, t) => Math.abs(e * t) / UV(e, t);
  function U_e(e, t) {
    return e === t ? e : `^(?=.*(?:${e}))(?=.*(?:${t})).*$`;
  }
  function* u0(e, t, n) {
    const r = e.length, o = t.length;
    if (r > 0 && o > 0)
      for (let a = 0; a < r; a++) {
        const i = e[a];
        for (let s = 0; s < o; s++)
          yield n(i, t[s]);
      }
  }
  function c0(e, t) {
    return e || t;
  }
  function Q3(e) {
    return (t, n) => {
      const r = { ...t }, o = Object.keys(n), a = o.length;
      for (let i = 0; i < a; i++) {
        const s = o[i];
        r[s] = t[s] === void 0 ? n[s] : e(t[s], n[s]);
      }
      return r;
    };
  }
  function H_e(e) {
    const t = /* @__PURE__ */ new Map();
    for (const n of e)
      for (const r of n[0])
        t.set(r, n[1]);
    return t;
  }
  function zl(e, t, n) {
    n === void 0 || _a(n) ? delete e[t] : e[t] = n;
  }
  const W_e = [
    "properties",
    "patternProperties",
    "additionalProperties"
  ];
  function Z3(e) {
    const t = Object.keys(e), n = t.length, r = [];
    for (let o = 0; o < n; o++) {
      const a = t[o];
      r.push({
        regExp: new RegExp(a),
        schema: e[a]
      });
    }
    return [r, t];
  }
  const e4 = [[], []];
  function t4(e, t, n) {
    const r = n.length;
    for (let o = 0; o < r; o++) {
      const a = n[o];
      if (!a.regExp.test(t))
        continue;
      const i = a.schema;
      if (i === !1)
        return !0;
      e.push(i);
    }
    return !1;
  }
  const q_e = [
    "items",
    "additionalItems"
  ], K_e = [
    "if",
    "then",
    "else"
  ];
  function n4(e, t) {
    return t.if !== void 0 && (e.if = t.if), t.then !== void 0 && (e.then = t.then), t.else !== void 0 && (e.else = t.else), e;
  }
  function d0(e, t) {
    if (e === t)
      return e;
    switch (e) {
      case "number":
        if (t === "integer")
          return "integer";
      // eslint-disable-next-line no-fallthrough
      case "integer":
        if (t === "number")
          return "integer";
      // eslint-disable-next-line no-fallthrough
      default:
        return;
    }
  }
  function Bl(e, t, n) {
    return [e, t, n];
  }
  function G_e(e) {
    const t = /* @__PURE__ */ new Map();
    for (const [n, r, o] of e) {
      const a = (i) => {
        if (!o(i))
          throw new Error(`Schema keys '${n}' and '${r}' are conflicting (${n}: ${JSON.stringify(i[n])}, ${r}: ${JSON.stringify(i[r])})`);
      };
      for (const i of [
        [n, r],
        [r, n]
      ]) {
        let s = t.get(i[0]);
        s === void 0 && (s = [], t.set(i[0], s)), s.push({ oppositeKey: i[1], check: a });
      }
    }
    return t;
  }
  const X_e = [
    Bl("minimum", "maximum", (e) => e.maximum >= e.minimum),
    Bl("exclusiveMinimum", "maximum", (e) => e.maximum > e.exclusiveMinimum),
    Bl("minimum", "exclusiveMaximum", (e) => e.exclusiveMaximum > e.minimum),
    Bl("exclusiveMinimum", "exclusiveMaximum", (e) => e.exclusiveMaximum > e.exclusiveMinimum),
    Bl("minLength", "maxLength", (e) => e.maxLength >= e.minLength),
    Bl("minItems", "maxItems", (e) => e.maxItems >= e.minItems),
    Bl("minProperties", "maxProperties", (e) => e.maxProperties >= e.minProperties)
  ];
  function Y_e({ mergePatterns: e = U_e, isSubRegExp: t = Object.is, intersectJson: n = A_e, deduplicateJsonSchemaDef: r = J3, defaultMerger: o = J3, assigners: a = [], checks: i = X_e, mergers: s } = {}) {
    function u(E) {
      const P = E.length;
      let O = E[0];
      for (let M = 1; M < P; M++) {
        const I = w(O, E[M]);
        if (I === !1)
          return !1;
        _a(I) || (O = I);
      }
      return O;
    }
    function c(E, P, O, M, I, A, D) {
      if (E.length = 0, O === !1)
        return !1;
      if (E.push(O), I !== void 0) {
        if (I === !1)
          return !1;
        E.push(I);
      }
      if (t4(E, P, A))
        return !1;
      const F = E.length < 2;
      if (D === !1) {
        if (F)
          return;
        if (t4(E, P, M))
          return !1;
      } else F && D !== void 0 && E.push(D);
      return E.length === 1 ? E[0] : u(E);
    }
    function f(E, P, O, M, I, A) {
      const D = O.length;
      if (D > 0 && I !== !1)
        if (A)
          Object.assign(E, P);
        else
          for (let F = 0; F < D; F++) {
            const j = O[F];
            M.has(j) || (E[j] = w(P[j], I));
          }
      return E;
    }
    const p = (E, { properties: P = {}, patternProperties: O, additionalProperties: M = !0 }, { properties: I = {}, patternProperties: A, additionalProperties: D = !0 }) => {
      const F = _a(M), j = _a(D);
      if (F && j)
        return zl(E, "properties", _(P, I)), zl(E, "patternProperties", O && A ? _(O, A) : O ?? A), delete E.additionalProperties, E;
      const U = w(M, D);
      zl(E, "additionalProperties", U);
      const $ = {}, q = Object.keys(P), B = q.length, [G, W] = O ? Z3(O) : e4, [Y, z] = A ? Z3(A) : e4, L = [], K = /* @__PURE__ */ new Set(), T = j ? void 0 : D;
      for (let ae = 0; ae < B; ae++) {
        const ce = q[ae];
        K.add(ce);
        const Z = c(L, ce, P[ce], G, I[ce], Y, T);
        Z !== void 0 && ($[ce] = Z);
      }
      const V = Object.keys(I), X = V.length, Q = F ? void 0 : M;
      for (let ae = 0; ae < X; ae++) {
        const ce = V[ae];
        if (K.has(ce))
          continue;
        const Z = c(L, ce, I[ce], Y, void 0, G, Q);
        Z !== void 0 && ($[ce] = Z);
      }
      zl(E, "properties", $);
      let ne = {};
      const te = /* @__PURE__ */ new Set();
      if (W.length > 0 && z.length > 0) {
        const ae = u0(W, z, (ce, Z) => {
          t(ce, Z) && te.add(ce), t(Z, ce) && te.add(Z), ne[e(ce, Z)] = w(O[ce], A[Z]);
        });
        for (; !ae.next().done; )
          ;
      }
      return ne = f(ne, O, W, te, D, j), ne = f(ne, A, z, te, M, F), zl(E, "patternProperties", ne), E;
    }, g = (E, { items: P = [], additionalItems: O }, { items: M = [], additionalItems: I }) => {
      const A = Array.isArray(P), D = Array.isArray(M), F = [];
      if (E.items = F, A && D) {
        const [j, U, $] = P.length < M.length ? [P.length, O, M] : [M.length, I, P];
        let q = 0;
        for (; q < j; q++)
          F.push(w(P[q], M[q]));
        if (U === !1)
          E.additionalItems = !1;
        else {
          const B = U === void 0 || _a(U);
          for (; q < $.length; q++)
            F.push(B ? $[q] : w($[q], U));
          zl(E, "additionalItems", O !== void 0 && I !== void 0 ? w(O, I) : O ?? I);
        }
      } else if (A || D) {
        const [j, U, $] = A ? [P, M, O] : [M, P, I];
        zl(E, "additionalItems", $ && w($, U));
        for (let q = 0; q < j.length; q++)
          F.push(w(j[q], U));
      } else
        delete E.additionalItems, E.items = w(P, M);
      return E;
    }, h = (E, P, O) => {
      n4(E, P);
      const M = n4({}, O);
      return E.allOf === void 0 ? E.allOf = [M] : E.allOf = E.allOf.concat(M), E;
    };
    function y(E, P) {
      return r(Array.from(u0(E, P, w)));
    }
    const b = H_e([
      [W_e, p],
      [q_e, g],
      [K_e, h],
      ...a
    ]), v = G_e(i);
    function w(E, P) {
      if (E === !1 || P === !1)
        return !1;
      if (_a(E))
        return _a(P) ? !0 : P;
      if (_a(P))
        return E;
      let O = { ...E };
      const M = /* @__PURE__ */ new Set(), I = /* @__PURE__ */ new Set(), A = Object.keys(P), D = A.length;
      for (let F = 0; F < D; F++) {
        const j = A[F], U = P[j];
        if (U === void 0)
          continue;
        const $ = v.get(j);
        if ($ !== void 0) {
          const W = $.length;
          for (let Y = 0; Y < W; Y++) {
            const z = $[Y];
            E[z.oppositeKey] !== void 0 && I.add(z.check);
          }
        }
        const q = E[j];
        if (q === void 0) {
          O[j] = U;
          continue;
        }
        const B = b.get(j);
        if (B) {
          M.add(B);
          continue;
        }
        const G = k[j] ?? o;
        O[j] = G(q, U);
      }
      for (const F of M)
        O = F(O, E, P);
      for (const F of I)
        F(O);
      return O;
    }
    const _ = Q3(w), k = {
      $id: o,
      $ref: o,
      $schema: o,
      $comment: o,
      $defs: _,
      definitions: _,
      type: (E, P) => {
        if (E === P)
          return E;
        const O = Array.isArray(E), M = Array.isArray(P);
        if (!O && !M) {
          const I = d0(E, P);
          if (I !== void 0)
            return I;
        } else if (O || M) {
          const I = /* @__PURE__ */ new Set();
          if (O && M)
            for (const D of u0(E, P, d0))
              D !== void 0 && I.add(D);
          else {
            const D = O ? E : P, F = O ? P : E, j = D.length;
            for (let U = 0; U < j; U++) {
              const $ = d0(F, D[U]);
              $ !== void 0 && I.add($);
            }
          }
          const A = I.size;
          if (A === 1)
            return I.values().next().value;
          if (A > 1)
            return Array.from(I);
        }
        throw new Error(`It is not possible to create an intersection of the following incompatible types: ${E.toString()}, ${P.toString()}`);
      },
      default: o,
      description: o,
      title: o,
      const: o,
      format: o,
      contentEncoding: o,
      contentMediaType: o,
      not: (E, P) => {
        const O = r([E, P]);
        return O.length === 1 ? O[0] : { anyOf: O };
      },
      pattern: e,
      readOnly: c0,
      writeOnly: c0,
      enum: (E, P) => {
        const O = n(E, P);
        if (O.length === 0)
          throw new Error(`Intersection of the following enums is empty: "${JSON.stringify(E)}", "${JSON.stringify(P)}"`);
        return O;
      },
      anyOf: y,
      oneOf: y,
      allOf: (E, P) => r(E.concat(P)),
      propertyNames: w,
      contains: w,
      dependencies: Q3((E, P) => Array.isArray(E) ? Array.isArray(P) ? a0(E, P) : w(P, { required: E }) : Array.isArray(P) ? w(E, { required: P }) : w(E, P)),
      examples: (E, P) => {
        if (!Array.isArray(E) || !Array.isArray(P))
          throw new Error(`Value of the 'examples' field should be an array, but got "${JSON.stringify(E)}" and "${JSON.stringify(P)}"`);
        return a0(E, P);
      },
      multipleOf: (E, P) => {
        let O = 1;
        for (; !Number.isInteger(E) || !Number.isInteger(P); )
          O *= 10, E *= 10, P *= 10;
        return V_e(E, P) / O;
      },
      exclusiveMaximum: Math.min,
      maximum: Math.min,
      maxItems: Math.min,
      maxLength: Math.min,
      maxProperties: Math.min,
      exclusiveMinimum: Math.max,
      minimum: Math.max,
      minItems: Math.max,
      minLength: Math.max,
      minProperties: Math.max,
      uniqueItems: c0,
      required: a0,
      ...s
    };
    return {
      mergeSchemaDefinitions: w,
      mergeArrayOfSchemaDefinitions: u
    };
  }
  function J_e(e) {
    const t = [], n = [e];
    for (; n.length > 0; ) {
      const r = n.pop();
      if (typeof r == "boolean" || r.allOf === void 0) {
        t.push(r);
        continue;
      }
      const { allOf: o, ...a } = r;
      t.push(a);
      for (let i = o.length - 1; i >= 0; i--)
        n.push(o[i]);
    }
    return t;
  }
  function Q_e(e) {
    return (t) => e(J_e(t));
  }
  var Zf = {}, r4;
  function Z_e() {
    if (r4) return Zf;
    r4 = 1;
    var e = /~/, t = /~[01]/g;
    function n(c) {
      switch (c) {
        case "~1":
          return "/";
        case "~0":
          return "~";
      }
      throw new Error("Invalid tilde escape: " + c);
    }
    function r(c) {
      return e.test(c) ? c.replace(t, n) : c;
    }
    function o(c, f, p) {
      for (var g, h, y = 1, b = f.length; y < b; ) {
        if (f[y] === "constructor" || f[y] === "prototype" || f[y] === "__proto__") return c;
        if (g = r(f[y++]), h = b > y, typeof c[g] > "u" && (Array.isArray(c) && g === "-" && (g = c.length), h && (f[y] !== "" && f[y] < 1 / 0 || f[y] === "-" ? c[g] = [] : c[g] = {})), !h) break;
        c = c[g];
      }
      var v = c[g];
      return p === void 0 ? delete c[g] : c[g] = p, v;
    }
    function a(c) {
      if (typeof c == "string") {
        if (c = c.split("/"), c[0] === "") return c;
        throw new Error("Invalid JSON pointer.");
      } else if (Array.isArray(c)) {
        for (const f of c)
          if (typeof f != "string" && typeof f != "number")
            throw new Error("Invalid JSON pointer. Must be of type string or number.");
        return c;
      }
      throw new Error("Invalid JSON pointer.");
    }
    function i(c, f) {
      if (typeof c != "object") throw new Error("Invalid input object.");
      f = a(f);
      var p = f.length;
      if (p === 1) return c;
      for (var g = 1; g < p; ) {
        if (c = c[r(f[g++])], p === g) return c;
        if (typeof c != "object" || c === null) return;
      }
    }
    function s(c, f, p) {
      if (typeof c != "object") throw new Error("Invalid input object.");
      if (f = a(f), f.length === 0) throw new Error("Invalid JSON pointer for set.");
      return o(c, f, p);
    }
    function u(c) {
      var f = a(c);
      return {
        get: function(p) {
          return i(p, f);
        },
        set: function(p, g) {
          return s(p, f, g);
        }
      };
    }
    return Zf.get = i, Zf.set = s, Zf.compile = u, Zf;
  }
  var e0e = Z_e();
  const f0 = /* @__PURE__ */ Qi(e0e);
  function t0e(e, t) {
    return e && Wd(t, Xo(t), e);
  }
  function n0e(e, t) {
    return e && Wd(t, fh(t), e);
  }
  function r0e(e, t) {
    return Wd(e, FP(e), t);
  }
  var o0e = Object.getOwnPropertySymbols, HV = o0e ? function(e) {
    for (var t = []; e; )
      LP(t, FP(e)), e = lx(e);
    return t;
  } : fV;
  function a0e(e, t) {
    return Wd(e, HV(e), t);
  }
  function QP(e) {
    return dV(e, fh, HV);
  }
  var i0e = Object.prototype, s0e = i0e.hasOwnProperty;
  function l0e(e) {
    var t = e.length, n = new e.constructor(t);
    return t && typeof e[0] == "string" && s0e.call(e, "index") && (n.index = e.index, n.input = e.input), n;
  }
  function u0e(e, t) {
    var n = t ? XP(e.buffer) : e.buffer;
    return new e.constructor(n, e.byteOffset, e.byteLength);
  }
  var c0e = /\w*$/;
  function d0e(e) {
    var t = new e.constructor(e.source, c0e.exec(e));
    return t.lastIndex = e.lastIndex, t;
  }
  var o4 = Ao ? Ao.prototype : void 0, a4 = o4 ? o4.valueOf : void 0;
  function f0e(e) {
    return a4 ? Object(a4.call(e)) : {};
  }
  var p0e = "[object Boolean]", m0e = "[object Date]", h0e = "[object Map]", g0e = "[object Number]", v0e = "[object RegExp]", y0e = "[object Set]", b0e = "[object String]", w0e = "[object Symbol]", x0e = "[object ArrayBuffer]", k0e = "[object DataView]", S0e = "[object Float32Array]", _0e = "[object Float64Array]", E0e = "[object Int8Array]", C0e = "[object Int16Array]", P0e = "[object Int32Array]", O0e = "[object Uint8Array]", N0e = "[object Uint8ClampedArray]", M0e = "[object Uint16Array]", R0e = "[object Uint32Array]";
  function j0e(e, t, n) {
    var r = e.constructor;
    switch (t) {
      case x0e:
        return XP(e);
      case p0e:
      case m0e:
        return new r(+e);
      case k0e:
        return u0e(e, n);
      case S0e:
      case _0e:
      case E0e:
      case C0e:
      case P0e:
      case O0e:
      case N0e:
      case M0e:
      case R0e:
        return IV(e, n);
      case h0e:
        return new r();
      case g0e:
      case b0e:
        return new r(e);
      case v0e:
        return d0e(e);
      case y0e:
        return new r();
      case w0e:
        return f0e(e);
    }
  }
  var I0e = "[object Map]";
  function A0e(e) {
    return $o(e) && Oo(e) == I0e;
  }
  var i4 = Pd && Pd.isMap, $0e = i4 ? zP(i4) : A0e, D0e = "[object Set]";
  function L0e(e) {
    return $o(e) && Oo(e) == D0e;
  }
  var s4 = Pd && Pd.isSet, F0e = s4 ? zP(s4) : L0e, T0e = 1, z0e = 2, B0e = 4, WV = "[object Arguments]", V0e = "[object Array]", U0e = "[object Boolean]", H0e = "[object Date]", W0e = "[object Error]", qV = "[object Function]", q0e = "[object GeneratorFunction]", K0e = "[object Map]", G0e = "[object Number]", KV = "[object Object]", X0e = "[object RegExp]", Y0e = "[object Set]", J0e = "[object String]", Q0e = "[object Symbol]", Z0e = "[object WeakMap]", e2e = "[object ArrayBuffer]", t2e = "[object DataView]", n2e = "[object Float32Array]", r2e = "[object Float64Array]", o2e = "[object Int8Array]", a2e = "[object Int16Array]", i2e = "[object Int32Array]", s2e = "[object Uint8Array]", l2e = "[object Uint8ClampedArray]", u2e = "[object Uint16Array]", c2e = "[object Uint32Array]", cn = {};
  cn[WV] = cn[V0e] = cn[e2e] = cn[t2e] = cn[U0e] = cn[H0e] = cn[n2e] = cn[r2e] = cn[o2e] = cn[a2e] = cn[i2e] = cn[K0e] = cn[G0e] = cn[KV] = cn[X0e] = cn[Y0e] = cn[J0e] = cn[Q0e] = cn[s2e] = cn[l2e] = cn[u2e] = cn[c2e] = !0;
  cn[W0e] = cn[qV] = cn[Z0e] = !1;
  function Dp(e, t, n, r, o, a) {
    var i, s = t & T0e, u = t & z0e, c = t & B0e;
    if (n && (i = o ? n(e, r, o, a) : n(e)), i !== void 0)
      return i;
    if (!jt(e))
      return e;
    var f = Yn(e);
    if (f) {
      if (i = l0e(e), !s)
        return YP(e, i);
    } else {
      var p = Oo(e), g = p == qV || p == q0e;
      if (yu(e))
        return jV(e, s);
      if (p == KV || p == WV || g && !o) {
        if (i = u || g ? {} : AV(e), !s)
          return u ? a0e(e, n0e(i, e)) : r0e(e, t0e(i, e));
      } else {
        if (!cn[p])
          return o ? e : {};
        i = j0e(e, p, s);
      }
    }
    a || (a = new Zo());
    var h = a.get(e);
    if (h)
      return h;
    a.set(e, i), F0e(e) ? e.forEach(function(v) {
      i.add(Dp(v, t, n, v, e, a));
    }) : $0e(e) && e.forEach(function(v, w) {
      i.set(w, Dp(v, t, n, w, e, a));
    });
    var y = c ? u ? QP : sE : u ? fh : Xo, b = f ? void 0 : y(e);
    return KP(b || e, function(v, w) {
      b && (w = v, v = e[w]), WP(i, w, Dp(v, t, n, w, e, a));
    }), i;
  }
  function GV(e) {
    var t = e == null ? 0 : e.length;
    return t ? e[t - 1] : void 0;
  }
  function d2e(e, t, n) {
    var r = -1, o = e.length;
    t < 0 && (t = -t > o ? 0 : o + t), n = n > o ? o : n, n < 0 && (n += o), o = t > n ? 0 : n - t >>> 0, t >>>= 0;
    for (var a = Array(o); ++r < o; )
      a[r] = e[r + t];
    return a;
  }
  function f2e(e, t) {
    return t.length < 2 ? e : px(e, d2e(t, 0, -1));
  }
  function XV(e, t) {
    return t = Hd(t, e), e = f2e(e, t), e == null || delete e[Ou(GV(t))];
  }
  function p2e(e) {
    return dl(e) ? void 0 : e;
  }
  function pE(e) {
    var t = e == null ? 0 : e.length;
    return t ? ph(e, 1) : [];
  }
  function YV(e) {
    return LV(DV(e, void 0, pE), e + "");
  }
  var m2e = 1, h2e = 2, g2e = 4, bm = YV(function(e, t) {
    var n = {};
    if (e == null)
      return n;
    var r = !1;
    t = Ud(t, function(a) {
      return a = Hd(a, e), r || (r = a.length > 1), a;
    }), Wd(e, QP(e), n), r && (n = Dp(n, m2e | h2e | g2e, p2e));
    for (var o = t.length; o--; )
      XV(n, t[o]);
    return n;
  }), ep = { exports: {} }, p0, l4;
  function JV() {
    if (l4) return p0;
    l4 = 1;
    const e = RegExp.prototype.test.bind(/^[\da-f]{8}-[\da-f]{4}-[\da-f]{4}-[\da-f]{4}-[\da-f]{12}$/iu), t = RegExp.prototype.test.bind(/^(?:(?:25[0-5]|2[0-4]\d|1\d{2}|[1-9]\d|\d)\.){3}(?:25[0-5]|2[0-4]\d|1\d{2}|[1-9]\d|\d)$/u);
    function n(g) {
      let h = "", y = 0, b = 0;
      for (b = 0; b < g.length; b++)
        if (y = g[b].charCodeAt(0), y !== 48) {
          if (!(y >= 48 && y <= 57 || y >= 65 && y <= 70 || y >= 97 && y <= 102))
            return "";
          h += g[b];
          break;
        }
      for (b += 1; b < g.length; b++) {
        if (y = g[b].charCodeAt(0), !(y >= 48 && y <= 57 || y >= 65 && y <= 70 || y >= 97 && y <= 102))
          return "";
        h += g[b];
      }
      return h;
    }
    const r = RegExp.prototype.test.bind(/[^!"$&'()*+,\-.;=_`a-z{}~]/u);
    function o(g) {
      return g.length = 0, !0;
    }
    function a(g, h, y) {
      if (g.length) {
        const b = n(g);
        if (b !== "")
          h.push(b);
        else
          return y.error = !0, !1;
        g.length = 0;
      }
      return !0;
    }
    function i(g) {
      let h = 0;
      const y = { error: !1, address: "", zone: "" }, b = [], v = [];
      let w = !1, _ = !1, k = a;
      for (let E = 0; E < g.length; E++) {
        const P = g[E];
        if (!(P === "[" || P === "]"))
          if (P === ":") {
            if (w === !0 && (_ = !0), !k(v, b, y))
              break;
            if (++h > 7) {
              y.error = !0;
              break;
            }
            E > 0 && g[E - 1] === ":" && (w = !0), b.push(":");
            continue;
          } else if (P === "%") {
            if (!k(v, b, y))
              break;
            k = o;
          } else {
            v.push(P);
            continue;
          }
      }
      return v.length && (k === o ? y.zone = v.join("") : _ ? b.push(v.join("")) : b.push(n(v))), y.address = b.join(""), y;
    }
    function s(g) {
      if (u(g, ":") < 2)
        return { host: g, isIPV6: !1 };
      const h = i(g);
      if (h.error)
        return { host: g, isIPV6: !1 };
      {
        let y = h.address, b = h.address;
        return h.zone && (y += "%" + h.zone, b += "%25" + h.zone), { host: y, isIPV6: !0, escapedHost: b };
      }
    }
    function u(g, h) {
      let y = 0;
      for (let b = 0; b < g.length; b++)
        g[b] === h && y++;
      return y;
    }
    function c(g) {
      let h = g;
      const y = [];
      let b = -1, v = 0;
      for (; v = h.length; ) {
        if (v === 1) {
          if (h === ".")
            break;
          if (h === "/") {
            y.push("/");
            break;
          } else {
            y.push(h);
            break;
          }
        } else if (v === 2) {
          if (h[0] === ".") {
            if (h[1] === ".")
              break;
            if (h[1] === "/") {
              h = h.slice(2);
              continue;
            }
          } else if (h[0] === "/" && (h[1] === "." || h[1] === "/")) {
            y.push("/");
            break;
          }
        } else if (v === 3 && h === "/..") {
          y.length !== 0 && y.pop(), y.push("/");
          break;
        }
        if (h[0] === ".") {
          if (h[1] === ".") {
            if (h[2] === "/") {
              h = h.slice(3);
              continue;
            }
          } else if (h[1] === "/") {
            h = h.slice(2);
            continue;
          }
        } else if (h[0] === "/" && h[1] === ".") {
          if (h[2] === "/") {
            h = h.slice(2);
            continue;
          } else if (h[2] === "." && h[3] === "/") {
            h = h.slice(3), y.length !== 0 && y.pop();
            continue;
          }
        }
        if ((b = h.indexOf("/", 1)) === -1) {
          y.push(h);
          break;
        } else
          y.push(h.slice(0, b)), h = h.slice(b);
      }
      return y.join("");
    }
    function f(g, h) {
      const y = h !== !0 ? escape : unescape;
      return g.scheme !== void 0 && (g.scheme = y(g.scheme)), g.userinfo !== void 0 && (g.userinfo = y(g.userinfo)), g.host !== void 0 && (g.host = y(g.host)), g.path !== void 0 && (g.path = y(g.path)), g.query !== void 0 && (g.query = y(g.query)), g.fragment !== void 0 && (g.fragment = y(g.fragment)), g;
    }
    function p(g) {
      const h = [];
      if (g.userinfo !== void 0 && (h.push(g.userinfo), h.push("@")), g.host !== void 0) {
        let y = unescape(g.host);
        if (!t(y)) {
          const b = s(y);
          b.isIPV6 === !0 ? y = `[${b.escapedHost}]` : y = g.host;
        }
        h.push(y);
      }
      return (typeof g.port == "number" || typeof g.port == "string") && (h.push(":"), h.push(String(g.port))), h.length ? h.join("") : void 0;
    }
    return p0 = {
      nonSimpleDomain: r,
      recomposeAuthority: p,
      normalizeComponentEncoding: f,
      removeDotSegments: c,
      isIPv4: t,
      isUUID: e,
      normalizeIPv6: s,
      stringArrayToHexStripped: n
    }, p0;
  }
  var m0, u4;
  function v2e() {
    if (u4) return m0;
    u4 = 1;
    const { isUUID: e } = JV(), t = /([\da-z][\d\-a-z]{0,31}):((?:[\w!$'()*+,\-.:;=@]|%[\da-f]{2})+)/iu, n = (
      /** @type {const} */
      [
        "http",
        "https",
        "ws",
        "wss",
        "urn",
        "urn:uuid"
      ]
    );
    function r(k) {
      return n.indexOf(
        /** @type {*} */
        k
      ) !== -1;
    }
    function o(k) {
      return k.secure === !0 ? !0 : k.secure === !1 ? !1 : k.scheme ? k.scheme.length === 3 && (k.scheme[0] === "w" || k.scheme[0] === "W") && (k.scheme[1] === "s" || k.scheme[1] === "S") && (k.scheme[2] === "s" || k.scheme[2] === "S") : !1;
    }
    function a(k) {
      return k.host || (k.error = k.error || "HTTP URIs must have a host."), k;
    }
    function i(k) {
      const E = String(k.scheme).toLowerCase() === "https";
      return (k.port === (E ? 443 : 80) || k.port === "") && (k.port = void 0), k.path || (k.path = "/"), k;
    }
    function s(k) {
      return k.secure = o(k), k.resourceName = (k.path || "/") + (k.query ? "?" + k.query : ""), k.path = void 0, k.query = void 0, k;
    }
    function u(k) {
      if ((k.port === (o(k) ? 443 : 80) || k.port === "") && (k.port = void 0), typeof k.secure == "boolean" && (k.scheme = k.secure ? "wss" : "ws", k.secure = void 0), k.resourceName) {
        const [E, P] = k.resourceName.split("?");
        k.path = E && E !== "/" ? E : void 0, k.query = P, k.resourceName = void 0;
      }
      return k.fragment = void 0, k;
    }
    function c(k, E) {
      if (!k.path)
        return k.error = "URN can not be parsed", k;
      const P = k.path.match(t);
      if (P) {
        const O = E.scheme || k.scheme || "urn";
        k.nid = P[1].toLowerCase(), k.nss = P[2];
        const M = `${O}:${E.nid || k.nid}`, I = _(M);
        k.path = void 0, I && (k = I.parse(k, E));
      } else
        k.error = k.error || "URN can not be parsed.";
      return k;
    }
    function f(k, E) {
      if (k.nid === void 0)
        throw new Error("URN without nid cannot be serialized");
      const P = E.scheme || k.scheme || "urn", O = k.nid.toLowerCase(), M = `${P}:${E.nid || O}`, I = _(M);
      I && (k = I.serialize(k, E));
      const A = k, D = k.nss;
      return A.path = `${O || E.nid}:${D}`, E.skipEscape = !0, A;
    }
    function p(k, E) {
      const P = k;
      return P.uuid = P.nss, P.nss = void 0, !E.tolerant && (!P.uuid || !e(P.uuid)) && (P.error = P.error || "UUID is not valid."), P;
    }
    function g(k) {
      const E = k;
      return E.nss = (k.uuid || "").toLowerCase(), E;
    }
    const h = (
      /** @type {SchemeHandler} */
      {
        scheme: "http",
        domainHost: !0,
        parse: a,
        serialize: i
      }
    ), y = (
      /** @type {SchemeHandler} */
      {
        scheme: "https",
        domainHost: h.domainHost,
        parse: a,
        serialize: i
      }
    ), b = (
      /** @type {SchemeHandler} */
      {
        scheme: "ws",
        domainHost: !0,
        parse: s,
        serialize: u
      }
    ), v = (
      /** @type {SchemeHandler} */
      {
        scheme: "wss",
        domainHost: b.domainHost,
        parse: b.parse,
        serialize: b.serialize
      }
    ), w = (
      /** @type {Record<SchemeName, SchemeHandler>} */
      {
        http: h,
        https: y,
        ws: b,
        wss: v,
        urn: (
          /** @type {SchemeHandler} */
          {
            scheme: "urn",
            parse: c,
            serialize: f,
            skipNormalize: !0
          }
        ),
        "urn:uuid": (
          /** @type {SchemeHandler} */
          {
            scheme: "urn:uuid",
            parse: p,
            serialize: g,
            skipNormalize: !0
          }
        )
      }
    );
    Object.setPrototypeOf(w, null);
    function _(k) {
      return k && (w[
        /** @type {SchemeName} */
        k
      ] || w[
        /** @type {SchemeName} */
        k.toLowerCase()
      ]) || void 0;
    }
    return m0 = {
      wsIsSecure: o,
      SCHEMES: w,
      isValidSchemeName: r,
      getSchemeHandler: _
    }, m0;
  }
  var c4;
  function y2e() {
    if (c4) return ep.exports;
    c4 = 1;
    const { normalizeIPv6: e, removeDotSegments: t, recomposeAuthority: n, normalizeComponentEncoding: r, isIPv4: o, nonSimpleDomain: a } = JV(), { SCHEMES: i, getSchemeHandler: s } = v2e();
    function u(v, w) {
      return typeof v == "string" ? v = /** @type {T} */
      g(y(v, w), w) : typeof v == "object" && (v = /** @type {T} */
      y(g(v, w), w)), v;
    }
    function c(v, w, _) {
      const k = _ ? Object.assign({ scheme: "null" }, _) : { scheme: "null" }, E = f(y(v, k), y(w, k), k, !0);
      return k.skipEscape = !0, g(E, k);
    }
    function f(v, w, _, k) {
      const E = {};
      return k || (v = y(g(v, _), _), w = y(g(w, _), _)), _ = _ || {}, !_.tolerant && w.scheme ? (E.scheme = w.scheme, E.userinfo = w.userinfo, E.host = w.host, E.port = w.port, E.path = t(w.path || ""), E.query = w.query) : (w.userinfo !== void 0 || w.host !== void 0 || w.port !== void 0 ? (E.userinfo = w.userinfo, E.host = w.host, E.port = w.port, E.path = t(w.path || ""), E.query = w.query) : (w.path ? (w.path[0] === "/" ? E.path = t(w.path) : ((v.userinfo !== void 0 || v.host !== void 0 || v.port !== void 0) && !v.path ? E.path = "/" + w.path : v.path ? E.path = v.path.slice(0, v.path.lastIndexOf("/") + 1) + w.path : E.path = w.path, E.path = t(E.path)), E.query = w.query) : (E.path = v.path, w.query !== void 0 ? E.query = w.query : E.query = v.query), E.userinfo = v.userinfo, E.host = v.host, E.port = v.port), E.scheme = v.scheme), E.fragment = w.fragment, E;
    }
    function p(v, w, _) {
      return typeof v == "string" ? (v = unescape(v), v = g(r(y(v, _), !0), { ..._, skipEscape: !0 })) : typeof v == "object" && (v = g(r(v, !0), { ..._, skipEscape: !0 })), typeof w == "string" ? (w = unescape(w), w = g(r(y(w, _), !0), { ..._, skipEscape: !0 })) : typeof w == "object" && (w = g(r(w, !0), { ..._, skipEscape: !0 })), v.toLowerCase() === w.toLowerCase();
    }
    function g(v, w) {
      const _ = {
        host: v.host,
        scheme: v.scheme,
        userinfo: v.userinfo,
        port: v.port,
        path: v.path,
        query: v.query,
        nid: v.nid,
        nss: v.nss,
        uuid: v.uuid,
        fragment: v.fragment,
        reference: v.reference,
        resourceName: v.resourceName,
        secure: v.secure,
        error: ""
      }, k = Object.assign({}, w), E = [], P = s(k.scheme || _.scheme);
      P && P.serialize && P.serialize(_, k), _.path !== void 0 && (k.skipEscape ? _.path = unescape(_.path) : (_.path = escape(_.path), _.scheme !== void 0 && (_.path = _.path.split("%3A").join(":")))), k.reference !== "suffix" && _.scheme && E.push(_.scheme, ":");
      const O = n(_);
      if (O !== void 0 && (k.reference !== "suffix" && E.push("//"), E.push(O), _.path && _.path[0] !== "/" && E.push("/")), _.path !== void 0) {
        let M = _.path;
        !k.absolutePath && (!P || !P.absolutePath) && (M = t(M)), O === void 0 && M[0] === "/" && M[1] === "/" && (M = "/%2F" + M.slice(2)), E.push(M);
      }
      return _.query !== void 0 && E.push("?", _.query), _.fragment !== void 0 && E.push("#", _.fragment), E.join("");
    }
    const h = /^(?:([^#/:?]+):)?(?:\/\/((?:([^#/?@]*)@)?(\[[^#/?\]]+\]|[^#/:?]*)(?::(\d*))?))?([^#?]*)(?:\?([^#]*))?(?:#((?:.|[\n\r])*))?/u;
    function y(v, w) {
      const _ = Object.assign({}, w), k = {
        scheme: void 0,
        userinfo: void 0,
        host: "",
        port: void 0,
        path: "",
        query: void 0,
        fragment: void 0
      };
      let E = !1;
      _.reference === "suffix" && (_.scheme ? v = _.scheme + ":" + v : v = "//" + v);
      const P = v.match(h);
      if (P) {
        if (k.scheme = P[1], k.userinfo = P[3], k.host = P[4], k.port = parseInt(P[5], 10), k.path = P[6] || "", k.query = P[7], k.fragment = P[8], isNaN(k.port) && (k.port = P[5]), k.host)
          if (o(k.host) === !1) {
            const M = e(k.host);
            k.host = M.host.toLowerCase(), E = M.isIPV6;
          } else
            E = !0;
        k.scheme === void 0 && k.userinfo === void 0 && k.host === void 0 && k.port === void 0 && k.query === void 0 && !k.path ? k.reference = "same-document" : k.scheme === void 0 ? k.reference = "relative" : k.fragment === void 0 ? k.reference = "absolute" : k.reference = "uri", _.reference && _.reference !== "suffix" && _.reference !== k.reference && (k.error = k.error || "URI is not a " + _.reference + " reference.");
        const O = s(_.scheme || k.scheme);
        if (!_.unicodeSupport && (!O || !O.unicodeSupport) && k.host && (_.domainHost || O && O.domainHost) && E === !1 && a(k.host))
          try {
            k.host = URL.domainToASCII(k.host.toLowerCase());
          } catch (M) {
            k.error = k.error || "Host's domain name can not be converted to ASCII: " + M;
          }
        (!O || O && !O.skipNormalize) && (v.indexOf("%") !== -1 && (k.scheme !== void 0 && (k.scheme = unescape(k.scheme)), k.host !== void 0 && (k.host = unescape(k.host))), k.path && (k.path = escape(unescape(k.path))), k.fragment && (k.fragment = encodeURI(decodeURIComponent(k.fragment)))), O && O.parse && O.parse(k, _);
      } else
        k.error = k.error || "URI can not be parsed.";
      return k;
    }
    const b = {
      SCHEMES: i,
      normalize: u,
      resolve: c,
      resolveComponent: f,
      equal: p,
      serialize: g,
      parse: y
    };
    return ep.exports = b, ep.exports.default = b, ep.exports.fastUri = b, ep.exports;
  }
  var b2e = y2e();
  const ZP = /* @__PURE__ */ Qi(b2e);
  function Lb(e, t) {
    if (rn in e && ZP.equal(e[rn], t))
      return e;
    for (const n of Object.values(e))
      if (Array.isArray(n)) {
        for (const r of n)
          if (jt(r)) {
            const o = Lb(r, t);
            if (o !== void 0)
              return o;
          }
      } else if (jt(n)) {
        const r = Lb(n, t);
        if (r !== void 0)
          return r;
      }
  }
  function mE(e, t) {
    const n = Ce(e, rn, t);
    yn in e && (e = { ...e, [yn]: ZP.resolve(n, e[yn]) });
    for (const [r, o] of Object.entries(e))
      Array.isArray(o) ? e = {
        ...e,
        [r]: o.map((a) => jt(a) ? mE(a, n) : a)
      } : jt(o) && (e = { ...e, [r]: mE(o, n) });
    return e;
  }
  function eO(e, t) {
    const n = t[e];
    return [bm(t, [e]), n];
  }
  function QV(e, t = {}, n = [], r = Ce(t, [rn])) {
    const o = e || "";
    let a;
    if (o.startsWith("#")) {
      const s = decodeURIComponent(o.substring(1));
      r === void 0 || rn in t && t[rn] === r ? a = f0.get(t, s) : t[xp] === Uy && (a = Lb(t, r.replace(/\/$/, "")), a !== void 0 && (a = f0.get(a, s)));
    } else if (t[xp] === Uy) {
      const s = r ? ZP.resolve(r, o) : o, [u, ...c] = s.replace(/#\/?$/, "").split("#");
      a = Lb(t, u.replace(/\/$/, "")), a !== void 0 && (r = a[rn], Hn(c) || (a = f0.get(a, decodeURIComponent(c.join("#")))));
    }
    if (a === void 0)
      throw new Error(`Could not find a definition for ${e}.`);
    const i = a[yn];
    if (i) {
      if (n.includes(i)) {
        if (n.length === 1)
          throw new Error(`Definition for ${e} is a circular reference`);
        const [f, ...p] = n, g = [...p, o, f].join(" -> ");
        throw new Error(`Definition for ${f} contains a circular reference through ${g}`);
      }
      const [s, u] = eO(yn, a), c = QV(u, t, [...n, o], r);
      return Object.keys(s).length > 0 ? t[xp] === $we || t[xp] === Uy ? { [cl]: [s, c] } : { ...s, ...c } : c;
    }
    return a;
  }
  function ZV(e, t = {}, n = Ce(t, [rn])) {
    return QV(e, t, [], n);
  }
  var w2e = "[object String]";
  function fl(e) {
    return typeof e == "string" || !Yn(e) && $o(e) && rs(e) == w2e;
  }
  function Ga(e) {
    let t;
    const n = Ce(e, jwe);
    return fl(n) ? t = n : n !== void 0 && console.warn(`Expecting discriminator to be a string, got "${typeof n}" instead`), t;
  }
  function wm(e) {
    return Array.isArray(e) ? "array" : typeof e == "string" ? "string" : e == null ? "null" : typeof e == "boolean" ? "boolean" : isNaN(e) ? typeof e == "object" ? "object" : "string" : "number";
  }
  var x2e = hx(function(e) {
    return TV(ph(e, 1, ym, !0));
  });
  function aa(e) {
    let { type: t } = e;
    return !t && e.const ? wm(e.const) : !t && e.enum ? "string" : !t && (e.properties || e.additionalProperties || e.patternProperties) ? "object" : (Array.isArray(t) && (t.length === 2 && t.includes("null") ? t = t.find((n) => n !== "null") : t = t[0]), t);
  }
  function Yi(e, t) {
    const n = Object.assign({}, e);
    return Object.keys(t).reduce((r, o) => {
      const a = e ? e[o] : {}, i = t[o];
      return e && o in e && Ot(i) ? r[o] = Yi(a, i) : e && t && (aa(e) === "object" || aa(t) === "object") && o === tV && Array.isArray(a) && Array.isArray(i) ? r[o] = x2e(a, i) : r[o] = i, r;
    }, n);
  }
  var k2e = "[object Number]";
  function e1(e) {
    return typeof e == "number" || $o(e) && rs(e) == k2e;
  }
  function t1(e, t, n) {
    var r;
    if (e && n) {
      const o = Ce(e, n);
      if (o === void 0)
        return;
      for (let a = 0; a < t.length; a++) {
        const i = t[a], s = Ce(i, [Lt, n], {});
        if (!(s.type === "object" || s.type === "array") && (s.const === o || !((r = s.enum) === null || r === void 0) && r.includes(o)))
          return a;
      }
    }
  }
  function tO(e, t, n, r, o) {
    if (t === void 0)
      return 0;
    const a = t1(t, n, o);
    if (e1(a))
      return a;
    for (let i = 0; i < n.length; i++) {
      const s = n[i];
      if (o && Et(s, [Lt, o])) {
        const u = Ce(t, o), c = Ce(s, [Lt, o], {});
        if (e.isValid(c, u, r))
          return i;
      } else if (s[Lt]) {
        const u = {
          anyOf: Object.keys(s[Lt]).map((f) => ({
            required: [f]
          }))
        };
        let c;
        if (s.anyOf) {
          const { ...f } = s;
          f.allOf ? f.allOf = f.allOf.slice() : f.allOf = [], f.allOf.push(u), c = f;
        } else
          c = Object.assign({}, s, u);
        if (delete c.required, e.isValid(c, t, r))
          return i;
      } else if (e.isValid(s, t, r))
        return i;
    }
    return 0;
  }
  function yr(e, t, n = {}, r, o, a = !1) {
    return Aa(e, t, n, r, void 0, void 0, o, a)[0];
  }
  function S2e(e, t, n, r, o, a, i) {
    const { if: s, then: u, else: c, ...f } = t, p = e.isValid(s, a || {}, n);
    let g = [f], h = [];
    if (r)
      u && typeof u != "boolean" && (h = h.concat(Aa(e, u, n, a, r, o, i))), c && typeof c != "boolean" && (h = h.concat(Aa(e, c, n, a, r, o, i)));
    else {
      const y = p ? u : c;
      y && typeof y != "boolean" && (h = h.concat(Aa(e, y, n, a, r, o, i)));
    }
    return h.length && (g = h.map((y) => Yi(f, y))), g.flatMap((y) => Aa(e, y, n, a, r, o, i));
  }
  function n1(e) {
    return e.reduce((t, n) => n.length > 1 ? n.flatMap((r) => _V(t.length, (o) => [...t[o]].concat(r))) : (t.forEach((r) => r.push(n[0])), t), [[]]);
  }
  function r1(e, t) {
    return Object.keys(e.patternProperties).filter((n) => RegExp(n).test(t)).reduce((n, r) => (Qt(n, [r], e.patternProperties[r]), n), {});
  }
  function _2e(e, t, n, r, o, a, i, s) {
    const u = o1(e, t, n, r, o, a, i, s);
    if (u.length > 1 || u[0] !== t)
      return u;
    if (IP in t)
      return a1(e, t, n, r, o, a, i).flatMap((c) => Aa(e, c, n, a, r, o, i));
    if (cl in t && Array.isArray(t[cl])) {
      const c = t.allOf.map((f) => Aa(e, f, n, a, r, o, i));
      return n1(c).map((f) => ({
        ...t,
        allOf: f
      }));
    }
    return [t];
  }
  function o1(e, t, n, r, o, a, i, s) {
    const u = ud(t, n, o, void 0, s);
    return u !== t ? Aa(e, u, n, a, r, o, i, s) : [t];
  }
  function ud(e, t, n, r, o) {
    if (!Ot(e))
      return e;
    let a = e;
    if (yn in a) {
      const { $ref: i, ...s } = a;
      if (n.includes(i))
        return a;
      n.push(i), a = { ...ZV(i, t, r), ...s }, rn in a && (r = a[rn]);
    }
    if (Lt in a) {
      const i = [], s = QSe(a[Lt], (u, c, f) => {
        const p = [...n];
        u[f] = ud(c, t, p, r, o), i.push(p);
      }, {});
      h_e(n, zV(y_e(i))), a = { ...a, [Lt]: s };
    }
    if (Ed in a && !Array.isArray(a.items) && typeof a.items != "boolean" && (a = {
      ...a,
      items: ud(a.items, t, n, r, o)
    }), o) {
      let i, s;
      Nt in e && Array.isArray(e[Nt]) ? (i = Nt, s = a[Nt]) : pt in e && Array.isArray(e[pt]) && (i = pt, s = a[pt]), i && s && (a = {
        ...a,
        [i]: s.map((u) => ud(u, t, n, r, o))
      });
    }
    return fn(e, a) ? e : a;
  }
  function E2e(e, t, n, r, o) {
    const a = {
      ...t,
      properties: { ...t.properties }
    }, i = r && Ot(r) ? r : {};
    return Object.keys(i).forEach((s) => {
      if (!(s in a.properties)) {
        if (oE in a) {
          const u = r1(a, s);
          if (!Hn(u)) {
            a.properties[s] = yr(e, { [cl]: Object.values(u) }, n, Ce(i, [s]), o), Qt(a.properties, [s, zi], !0);
            return;
          }
        }
        if (Ib in a && a.additionalProperties !== !1) {
          let u;
          typeof a.additionalProperties != "boolean" ? yn in a.additionalProperties ? u = yr(e, { [yn]: Ce(a.additionalProperties, [yn]) }, n, i, o) : "type" in a.additionalProperties ? u = { ...a.additionalProperties } : Nt in a.additionalProperties || pt in a.additionalProperties ? u = {
            type: "object",
            ...a.additionalProperties
          } : u = { type: wm(Ce(i, [s])) } : u = { type: wm(Ce(i, [s])) }, a.properties[s] = u, Qt(a.properties, [s, zi], !0);
        } else
          a.properties[s] = { type: "null" }, Qt(a.properties, [s, zi], !0);
      }
    }), a;
  }
  const { compareSchemaDefinitions: C2e, compareSchemaValues: P2e } = B_e(), { mergeArrayOfSchemaDefinitions: O2e } = Y_e({
    intersectJson: $_e(P2e),
    deduplicateJsonSchemaDef: BV(C2e)
  }), N2e = Q_e(O2e);
  function M2e(e) {
    return N2e(e);
  }
  function Aa(e, t, n, r, o = !1, a = [], i, s) {
    return Ot(t) ? _2e(e, t, n, o, a, r, i, s).flatMap((u) => {
      var c;
      let f = u;
      if (Mwe in f)
        return S2e(e, f, n, o, a, r, i);
      if (cl in f) {
        if (o) {
          const { allOf: p, ...g } = f;
          return [...p, g];
        }
        try {
          const p = [], g = [];
          (c = f.allOf) === null || c === void 0 || c.forEach((h) => {
            typeof h == "object" && h.contains ? p.push(h) : g.push(h);
          }), p.length && (f = { ...f, allOf: g }), f = i ? i(f) : M2e(f), p.length && (f.allOf = p);
        } catch (p) {
          console.warn(`could not merge subschemas in allOf:
`, p);
          const { allOf: g, ...h } = f;
          return h;
        }
      }
      return Lt in f && oE in f && (f = Object.keys(f.properties).reduce((p, g) => {
        const h = r1(p, g);
        return Hn(h) || (p.properties[g] = yr(e, { allOf: [p.properties[g], ...Object.values(h)] }, n, Ce(r, [g]), i)), p;
      }, {
        ...f,
        properties: { ...f.properties }
      })), oE in f || Ib in f && f.additionalProperties !== !1 ? E2e(e, f, n, r, i) : f;
    }) : [{}];
  }
  function R2e(e, t, n, r, o) {
    let a;
    const { oneOf: i, anyOf: s, ...u } = t;
    if (Array.isArray(i) ? a = i : Array.isArray(s) && (a = s), a) {
      const c = o === void 0 && r ? {} : o, f = Ga(t);
      a = a.map((g) => ud(g, n, []));
      const p = tO(e, c, a, n, f);
      if (r)
        return a.map((g) => Yi(u, g));
      t = Yi(u, a[p]);
    }
    return [t];
  }
  function a1(e, t, n, r, o, a, i) {
    const { dependencies: s, ...u } = t;
    return R2e(e, u, n, r, a).flatMap((c) => i1(e, s, c, n, r, o, a, i));
  }
  function i1(e, t, n, r, o, a, i, s) {
    let u = [n];
    for (const c in t) {
      if (!o && Ce(i, [c]) === void 0 || n.properties && !(c in n.properties))
        continue;
      const [f, p] = eO(c, t);
      return Array.isArray(p) ? u[0] = j2e(n, p) : Ot(p) && (u = I2e(e, n, r, c, p, o, a, i, s)), u.flatMap((g) => i1(e, f, g, r, o, a, i, s));
    }
    return u;
  }
  function j2e(e, t) {
    if (!t)
      return e;
    const n = Array.isArray(e.required) ? Array.from(/* @__PURE__ */ new Set([...e.required, ...t])) : t;
    return { ...e, required: n };
  }
  function I2e(e, t, n, r, o, a, i, s, u) {
    return Aa(e, o, n, s, a, i, u).flatMap((c) => {
      const { oneOf: f, ...p } = c;
      if (t = Yi(t, p), f === void 0)
        return t;
      const g = f.map((h) => typeof h == "boolean" || !(yn in h) ? [h] : o1(e, h, n, a, i, s));
      return n1(g).flatMap((h) => A2e(e, t, n, r, h, a, i, s, u));
    });
  }
  function A2e(e, t, n, r, o, a, i, s, u) {
    const c = o.filter((f) => {
      if (typeof f == "boolean" || !f || !f.properties)
        return !1;
      const { [r]: p } = f.properties;
      if (p) {
        const g = {
          type: "object",
          properties: {
            [r]: p
          }
        };
        return e.isValid(g, s, n) || a;
      }
      return !1;
    });
    return !a && c.length !== 1 ? (console.warn("ignoring oneOf in dependencies because there isn't exactly one subschema that is valid"), [t]) : c.flatMap((f) => {
      const p = f, [g] = eO(r, p.properties), h = { ...p, properties: g };
      return Aa(e, h, n, s, a, i, u).map((y) => Yi(t, y));
    });
  }
  function Sp(e, t, n, r, o, a = {}, i) {
    if (Array.isArray(n[o])) {
      const s = Ga(n) || r, u = n[o].map((f) => yr(e, f, t, a, i)), c = Ce(a, s);
      if (c !== void 0)
        return u.find((f) => vm(Ce(f, [Lt, s, sx], Ce(f, [Lt, s, Io])), c));
    }
  }
  function s1(e, t, n, r, o) {
    let a = n;
    if (Et(n, yn) && (a = yr(e, n, t, void 0, o)), Hn(r))
      return a;
    const i = Array.isArray(r) ? r : r.split("."), [s, ...u] = i;
    if (s && Et(a, s))
      return a = Ce(a, s), s1(e, t, a, u, o);
  }
  function qy(e, t, n, r, o, a) {
    const i = s1(e, t, n, r, a);
    return i === void 0 ? o : i;
  }
  const d4 = { title: "!@#$_UNKNOWN_$#@!" };
  function $2e(e, t, n, r, o = {}, a) {
    const i = Array.isArray(r) ? [...r] : r.split(".");
    let s = n;
    const u = i.pop();
    i.length && i.forEach((g) => {
      s = qy(e, t, s, [Lt, g], {}, a), Et(s, pt) ? s = Sp(e, t, s, u, pt, Ce(o, g), a) : Et(s, Nt) && (s = Sp(e, t, s, u, Nt, Ce(o, g), a));
    }), Et(s, pt) ? s = Sp(e, t, s, u, pt, o, a) : Et(s, Nt) && (s = Sp(e, t, s, u, Nt, o, a));
    let c = qy(e, t, s, [Lt, u], d4, a);
    c === d4 && (c = void 0);
    const f = qy(e, t, s, tV, [], a);
    let p;
    return c && Array.isArray(f) && (p = f.includes(u)), { field: c, isRequired: p };
  }
  function D2e(e, t, n, r) {
    var o = -1, a = e == null ? 0 : e.length;
    for (r && a && (n = e[++o]); ++o < a; )
      n = t(n, e[o], o, e);
    return n;
  }
  function L2e(e, t) {
    return function(n, r) {
      if (n == null)
        return n;
      if (!Pu(n))
        return e(n, r);
      for (var o = n.length, a = -1, i = Object(n); ++a < o && r(i[a], a, i) !== !1; )
        ;
      return n;
    };
  }
  var l1 = L2e(PV);
  function F2e(e, t, n, r, o) {
    return o(e, function(a, i, s) {
      n = r ? (r = !1, a) : t(n, a, i, s);
    }), n;
  }
  function T2e(e, t, n) {
    var r = Yn(e) ? D2e : F2e, o = arguments.length < 3;
    return r(e, GP(t), n, o, l1);
  }
  const z2e = {
    type: "object",
    $id: Rwe,
    properties: {
      __not_really_there__: {
        type: "number"
      }
    }
  };
  function hE(e, t, n, r, o) {
    let a = 0;
    return n && (jt(n.properties) ? a += T2e(n.properties, (i, s, u) => {
      const c = Ce(r, u);
      if (typeof s == "boolean")
        return i;
      if (Et(s, yn)) {
        const f = yr(e, s, t, c, o);
        return i + hE(e, t, f, c || {}, o);
      }
      if ((Et(s, pt) || Et(s, Nt)) && c) {
        const f = Et(s, pt) ? pt : Nt, p = Ga(s);
        return i + xm(e, t, c, Ce(s, f), -1, p, o);
      }
      if (s.type === "object")
        return jt(c) && (i += 1), i + hE(e, t, s, c, o);
      if (s.type === wm(c)) {
        let f = i + 1;
        return s.default ? f += c === s.default ? 1 : -1 : s.const && (f += c === s.const ? 1 : -1), f;
      }
      return i;
    }, 0) : fl(n.type) && n.type === wm(r) && (a += 1)), a;
  }
  function xm(e, t, n, r, o = -1, a, i) {
    const s = r.map((g) => ud(g, t, [])), u = t1(n, r, a);
    if (e1(u))
      return u;
    const c = s.reduce((g, h, y) => (tO(e, n, [z2e, h], t, a) === 1 && g.push(y), g), []);
    if (c.length === 1)
      return c[0];
    c.length || _V(s.length, (g) => c.push(g));
    const f = /* @__PURE__ */ new Set(), { bestIndex: p } = c.reduce((g, h) => {
      const { bestScore: y } = g, b = s[h], v = hE(e, t, b, n, i);
      return f.add(v), v > y ? { bestIndex: h, bestScore: v } : g;
    }, { bestIndex: o, bestScore: 0 });
    return f.size === 1 && o >= 0 ? o : p;
  }
  function nO(e) {
    return Array.isArray(e.items) && e.items.length > 0 && e.items.every((t) => Ot(t));
  }
  function Fb(e) {
    return e == null;
  }
  function km(e, t, n = !1, r = !1, o = !1) {
    if (Array.isArray(t)) {
      const a = Array.isArray(e) ? e : [], i = o ? a : t, s = o ? t : a, u = i.map((c, f) => s[f] !== void 0 ? km(a[f], t[f], n, r, o) : c);
      return (n || o) && u.length < s.length && u.push(...s.slice(u.length)), u;
    }
    if (Ot(t)) {
      const a = Object.assign({}, e);
      return Object.keys(t).reduce((i, s) => {
        var u;
        const c = Ce(t, s), f = Ot(e) && s in e, p = s in t, g = (u = Ce(e, s)) !== null && u !== void 0 ? u : {}, h = f && Object.entries(g).some(([, v]) => Ot(v)), y = f && Ot(Ce(e, s)), b = p && Ot(c);
        return y && b && !h ? (i[s] = {
          ...Ce(e, s),
          ...c
        }, i) : (i[s] = km(
          Ce(e, s),
          c,
          n,
          r,
          // overrideFormDataWithDefaults can be true only when the key value exists in defaults
          // Or if the key value doesn't exist in formData
          o && (f || !p)
        ), i);
      }, a);
    }
    return r && (e !== void 0 && Fb(t) || typeof t == "number" && isNaN(t)) || o && !Fb(t) ? e : t;
  }
  function Sm(e, t, n = !1) {
    return Object.keys(t).reduce((r, o) => {
      const a = e ? e[o] : {}, i = t[o];
      if (e && o in e && Ot(i))
        r[o] = Sm(a, i, n);
      else if (n && Array.isArray(a) && Array.isArray(i)) {
        let s = i;
        n === "preventDuplicates" && (s = i.reduce((u, c) => (a.includes(c) || u.push(c), u), [])), r[o] = a.concat(s);
      } else
        r[o] = i;
      return r;
    }, Object.assign({}, e));
  }
  function u1(e) {
    return Array.isArray(e.enum) && e.enum.length === 1 || Io in e;
  }
  function rO(e, t, n = {}, r) {
    const o = yr(e, t, n, void 0, r), a = o.oneOf || o.anyOf;
    return Array.isArray(o.enum) ? !0 : Array.isArray(a) ? a.every((i) => typeof i != "boolean" && u1(i)) : !1;
  }
  function oO(e, t, n, r) {
    return !t.uniqueItems || !t.items || typeof t.items == "boolean" ? !1 : rO(e, t.items, n, r);
  }
  function c1(e) {
    const t = e[Io], n = aa(e);
    return Ot(t) && fl(t?.$data) && n !== "object" && n !== "array";
  }
  function B2e(e) {
    if (Nwe in e && Array.isArray(e.enum) && e.enum.length === 1)
      return e.enum[0];
    if (Io in e)
      return e.const;
    throw new Error("schema cannot be inferred as a constant");
  }
  function Od(e, t) {
    if (e.enum) {
      let a;
      if (t) {
        const { enumNames: i } = Qe(t);
        a = i;
      }
      return e.enum.map((i, s) => ({ label: a?.[s] || String(i), value: i }));
    }
    let n, r;
    e.anyOf ? (n = e.anyOf, r = t?.anyOf) : e.oneOf && (n = e.oneOf, r = t?.oneOf);
    let o = Ga(e);
    if (t) {
      const { optionsSchemaSelector: a = o } = Qe(t);
      o = a;
    }
    return n && n.map((a, i) => {
      const { title: s } = Qe(r?.[i]), u = a;
      let c, f = s;
      if (o) {
        const p = Ce(u, [Lt, o], {});
        c = Ce(p, sx, Ce(p, Io)), f = f || p?.title || u.title || String(c);
      } else
        c = B2e(u), f = f || u.title || String(c);
      return {
        schema: u,
        label: f,
        value: c
      };
    });
  }
  const V2e = ["string", "number", "integer", "boolean", "null"];
  var Nd;
  (function(e) {
    e[e.Ignore = 0] = "Ignore", e[e.Invert = 1] = "Invert", e[e.Fallback = 2] = "Fallback";
  })(Nd || (Nd = {}));
  function h0(e, t = Nd.Ignore, n = -1) {
    if (n >= 0) {
      if (Array.isArray(e.items) && n < e.items.length) {
        const r = e.items[n];
        if (typeof r != "boolean")
          return r;
      }
    } else if (e.items && !Array.isArray(e.items) && typeof e.items != "boolean")
      return e.items;
    return t !== Nd.Ignore && Ot(e.additionalItems) ? e.additionalItems : {};
  }
  function d1(e, t) {
    const { default: n, type: r } = e;
    return Array.isArray(r) && r.includes("null") && Hn(t) && n === null ? null : t;
  }
  function f4(e, t, n, r, o, a = [], i = {}, s = !1, u = !1) {
    const { emptyObjectFields: c = "populateAllDefaults" } = i;
    if (r === !0 || s)
      e[t] = n;
    else if (r === "excludeObjectChildren")
      (u && n !== void 0 || !Ot(n) || !Hn(n)) && (e[t] = n);
    else if (c !== "skipDefaults") {
      const f = o === void 0 ? a.includes(t) : o;
      Ot(n) ? c === "skipEmptyDefaults" ? Hn(n) || (e[t] = n) : (!Hn(n) || a.includes(t)) && (f || c !== "populateRequiredDefaults") && (e[t] = n) : (
        // Store computedDefault if it's a defined primitive (e.g., true) and satisfies certain conditions
        // Condition 1: computedDefault is not undefined
        // Condition 2: If emptyObjectFields is 'populateAllDefaults' or 'skipEmptyDefaults)
        // Or if isSelfOrParentRequired is 'true' and the key is a required field
        n !== void 0 && (c === "populateAllDefaults" || c === "skipEmptyDefaults" || f && a.includes(t)) && (e[t] = n)
      );
    }
  }
  function Qs(e, t, n = {}) {
    const { parentDefaults: r, rawFormData: o, rootSchema: a = {}, includeUndefinedValues: i = !1, _recurseList: s = [], experimental_defaultFormStateBehavior: u = void 0, experimental_customMergeAllOf: c = void 0, required: f, shouldMergeDefaultsIntoFormData: p = !1, initialDefaultsGenerated: g } = n;
    let h = Ot(o) ? o : {};
    const y = Ot(t) ? t : {};
    let b = r, v = null, w = u, _ = s;
    if (y[Io] !== void 0 && u?.constAsDefaults !== "never" && !c1(y))
      b = y[Io];
    else if (Ot(b) && Ot(y.default))
      b = Sm(b, y.default);
    else if (sx in y && !y[Nt] && !y[pt] && !y[yn])
      b = y.default;
    else if (yn in y) {
      const P = y[yn];
      s.includes(P) || (_ = s.concat(P), v = ZV(P, a)), v && !b && (b = y.default), p && v && !Ot(o) && (h = o);
    } else if (IP in y) {
      const P = {
        ...p4(e, y, n, b),
        ...h
      };
      v = a1(e, y, a, !1, [], P, c)[0];
    } else if (nO(y))
      b = y.items.map((P, O) => Qs(e, P, {
        rootSchema: a,
        includeUndefinedValues: i,
        _recurseList: s,
        experimental_defaultFormStateBehavior: u,
        experimental_customMergeAllOf: c,
        parentDefaults: Array.isArray(r) ? r[O] : void 0,
        rawFormData: h,
        required: f,
        shouldMergeDefaultsIntoFormData: p
      }));
    else if (pt in y) {
      const { oneOf: P, ...O } = y;
      if (P.length === 0)
        return;
      const M = Ga(y), { type: I = "null" } = O;
      !Array.isArray(I) && V2e.includes(I) && w?.constAsDefaults === "skipOneOf" && (w = {
        ...w,
        constAsDefaults: "never"
      }), v = P[xm(e, a, o ?? y.default, P, 0, M, c)], v = Yi(O, v);
    } else if (Nt in y) {
      const { anyOf: P, ...O } = y;
      if (P.length === 0)
        return;
      const M = Ga(y);
      v = P[xm(e, a, o ?? y.default, P, 0, M, c)], v = Yi(O, v);
    }
    if (v)
      return Qs(e, v, {
        rootSchema: a,
        includeUndefinedValues: i,
        _recurseList: _,
        experimental_defaultFormStateBehavior: w,
        experimental_customMergeAllOf: c,
        parentDefaults: b,
        rawFormData: o ?? h,
        required: f,
        shouldMergeDefaultsIntoFormData: p,
        initialDefaultsGenerated: g
      });
    b === void 0 && (b = y.default);
    let E = p4(e, y, n, b) ?? b;
    if (p) {
      const { arrayMinItems: P = {} } = u || {}, { mergeExtraDefaults: O } = P, M = U2e(e, y, a, o, u, c);
      (!Ot(o) || cl in y) && (E = km(E, M, O, !0));
    }
    return E;
  }
  function U2e(e, t, n, r, o, a) {
    const i = !u1(t) && rO(e, t, n, a);
    let s = r;
    return i && (s = Od(t)?.some((c) => fn(c.value, r)) ? r : void 0), t[Io] && o?.constAsDefaults === "always" && (s = t.const), s;
  }
  function H2e(e, t, { rawFormData: n, rootSchema: r = {}, includeUndefinedValues: o = !1, _recurseList: a = [], experimental_defaultFormStateBehavior: i = void 0, experimental_customMergeAllOf: s = void 0, required: u, shouldMergeDefaultsIntoFormData: c, initialDefaultsGenerated: f } = {}, p) {
    {
      const g = Ot(n) ? n : {}, h = t, y = i?.allOf === "populateDefaults" && cl in h ? yr(e, h, r, g, s) : h, b = y[Io], v = Object.keys(y.properties || {}).reduce((w, _) => {
        var k;
        const E = Ce(y, [Lt, _], {}), P = Ot(b) && b[_] !== void 0, O = (Ot(E) && Io in E || P) && i?.constAsDefaults !== "never" && !c1(E), M = Qs(e, E, {
          rootSchema: r,
          _recurseList: a,
          experimental_defaultFormStateBehavior: i,
          experimental_customMergeAllOf: s,
          includeUndefinedValues: o === !0,
          parentDefaults: Ce(p, [_]),
          rawFormData: Ce(g, [_]),
          required: (k = y.required) === null || k === void 0 ? void 0 : k.includes(_),
          shouldMergeDefaultsIntoFormData: c,
          initialDefaultsGenerated: f
        });
        return f4(w, _, M, o, u, y.required, i, O, E?.type === "null"), w;
      }, {});
      if (y.additionalProperties && !f) {
        const w = Ot(y.additionalProperties) ? y.additionalProperties : {}, _ = /* @__PURE__ */ new Set();
        Ot(p) && Object.keys(p).filter((E) => !y.properties || !y.properties[E]).forEach((E) => _.add(E));
        const k = [];
        Object.keys(g).filter((E) => !y.properties || !y.properties[E]).forEach((E) => {
          _.add(E), k.push(E);
        }), _.forEach((E) => {
          var P;
          const O = Qs(e, w, {
            rootSchema: r,
            _recurseList: a,
            experimental_defaultFormStateBehavior: i,
            experimental_customMergeAllOf: s,
            includeUndefinedValues: o === !0,
            parentDefaults: Ce(p, [E]),
            rawFormData: Ce(g, [E]),
            required: (P = y.required) === null || P === void 0 ? void 0 : P.includes(E),
            shouldMergeDefaultsIntoFormData: c,
            initialDefaultsGenerated: f
          });
          f4(v, E, O, o, u, k);
        });
      }
      return d1(t, v);
    }
  }
  function W2e(e, t, { rawFormData: n, rootSchema: r = {}, _recurseList: o = [], experimental_defaultFormStateBehavior: a = void 0, experimental_customMergeAllOf: i = void 0, required: s, requiredAsRoot: u = !1, shouldMergeDefaultsIntoFormData: c, initialDefaultsGenerated: f } = {}, p) {
    var g, h;
    const y = t, b = (g = a?.arrayMinItems) !== null && g !== void 0 ? g : {}, { populate: v, mergeExtraDefaults: w } = b, _ = v === "never", k = v === "requiredOnly", E = v === "all" || !_ && !k, P = (h = b?.computeSkipPopulate) !== null && h !== void 0 ? h : (() => !1), O = a?.emptyObjectFields === "skipEmptyDefaults" ? void 0 : [];
    if (Array.isArray(p) && (p = p.map((A, D) => {
      const F = h0(y, Nd.Fallback, D);
      return Qs(e, F, {
        rootSchema: r,
        _recurseList: o,
        experimental_defaultFormStateBehavior: a,
        experimental_customMergeAllOf: i,
        parentDefaults: A,
        required: s,
        shouldMergeDefaultsIntoFormData: c,
        initialDefaultsGenerated: f
      });
    })), Array.isArray(n)) {
      const A = h0(y);
      if (_)
        p = n;
      else {
        const D = n.map((F, j) => Qs(e, A, {
          rootSchema: r,
          _recurseList: o,
          experimental_defaultFormStateBehavior: a,
          experimental_customMergeAllOf: i,
          rawFormData: F,
          parentDefaults: Ce(p, [j]),
          required: s,
          shouldMergeDefaultsIntoFormData: c,
          initialDefaultsGenerated: f
        }));
        p = km(p, D, (k && s || E) && w);
      }
    }
    if ((Ot(y) && Io in y && a?.constAsDefaults !== "never") === !1) {
      if (_)
        return p ?? O;
      if (k && !s)
        return p || void 0;
    }
    let M;
    const I = Array.isArray(p) ? p.length : 0;
    if (!y.minItems || oO(e, y, r, i) || P(e, y, r) || y.minItems <= I)
      M = p || !s && !u ? p : O;
    else {
      const A = p || [], D = h0(y, Nd.Invert), F = D.default, j = Array.from({ length: y.minItems - I }, () => Qs(e, D, {
        parentDefaults: F,
        rootSchema: r,
        _recurseList: o,
        experimental_defaultFormStateBehavior: a,
        experimental_customMergeAllOf: i,
        required: s,
        shouldMergeDefaultsIntoFormData: c
      }));
      M = A.concat(j);
    }
    return d1(t, M);
  }
  function p4(e, t, n = {}, r) {
    switch (aa(t)) {
      // We need to recurse for object schema inner default values.
      case "object":
        return H2e(e, t, n, r);
      case "array":
        return W2e(e, t, n, r);
    }
  }
  function f1(e, t, n, r, o = !1, a, i, s) {
    if (!Ot(t))
      throw new Error("Invalid schema: " + t);
    const u = yr(e, t, r, n, i), c = Qs(e, u, {
      rootSchema: r,
      includeUndefinedValues: o,
      experimental_defaultFormStateBehavior: a,
      experimental_customMergeAllOf: i,
      rawFormData: n,
      shouldMergeDefaultsIntoFormData: !0,
      initialDefaultsGenerated: s,
      requiredAsRoot: !0
    });
    if (u.type !== "object" && Ot(u.default))
      return {
        ...c,
        ...n
      };
    if (Ot(n) || Array.isArray(n)) {
      const { mergeDefaultsIntoFormData: f } = a || {};
      return km(
        c,
        n,
        !0,
        f === "useDefaultIfFormDataUndefined",
        !0
      );
    }
    return c;
  }
  function p1(e = {}) {
    return (
      // TODO: Remove the `&& uiSchema['ui:widget'] !== 'hidden'` once we support hidden widgets for arrays.
      // https://rjsf-team.github.io/react-jsonschema-form/docs/usage/widgets/#hidden-widgets
      "widget" in Qe(e) && Qe(e).widget !== "hidden"
    );
  }
  function m1(e, t, n = {}, r, o) {
    if (n[$P] === "files")
      return !0;
    if (t.items) {
      const a = yr(e, t.items, r, void 0, o);
      return a.type === "string" && a.format === "data-url";
    }
    return !1;
  }
  function q2e(e, t, n = {}, r, o, a) {
    const i = Qe(n, o), { label: s = !0 } = i;
    let u = !!s;
    if (u) {
      const c = aa(t), f = Ce(t, zi, !1);
      c === "array" && (u = f || oO(e, t, r, a) || m1(e, t, n, r, a) || p1(n)), c === "object" && (u = f), c === "boolean" && n && !n[$P] && (u = !1), n && n[Awe] && (u = !1);
    }
    return u;
  }
  const Rc = /* @__PURE__ */ Symbol("no Value");
  function gE(e, t, n, r, o = {}, a) {
    let i;
    if (Et(n, Lt)) {
      const s = {};
      if (Et(r, Lt)) {
        const f = Ce(r, Lt, {});
        Object.keys(f).forEach((p) => {
          Et(o, p) && (s[p] = void 0);
        });
      }
      const u = Object.keys(Ce(n, Lt, {})), c = {};
      u.forEach((f) => {
        const p = Ce(o, f);
        let g = Ce(r, [Lt, f], {}), h = Ce(n, [Lt, f], {});
        Et(g, yn) && (g = yr(e, g, t, p, a)), Et(h, yn) && (h = yr(e, h, t, p, a));
        const y = Ce(g, "type"), b = Ce(h, "type");
        if (!y || y === b)
          if (Et(s, f) && delete s[f], b === "object" || b === "array" && Array.isArray(p)) {
            const v = gE(e, t, h, g, p, a);
            (v !== void 0 || b === "array") && (c[f] = v);
          } else {
            const v = Ce(h, "default", Rc), w = Ce(g, "default", Rc);
            v !== Rc && v !== p && (w === p ? s[f] = v : Ce(h, "readOnly") === !0 && (s[f] = void 0));
            const _ = Ce(h, "const", Rc), k = Ce(g, "const", Rc);
            _ !== Rc && _ !== p && (s[f] = k === p ? _ : void 0);
          }
      }), i = {
        ...typeof o == "string" || Array.isArray(o) ? void 0 : o,
        ...s,
        ...c
      };
    } else if (Ce(r, "type") === "array" && Ce(n, "type") === "array" && Array.isArray(o)) {
      let s = Ce(r, "items"), u = Ce(n, "items");
      if (typeof s == "object" && typeof u == "object" && !Array.isArray(s) && !Array.isArray(u)) {
        Et(s, yn) && (s = yr(e, s, t, o, a)), Et(u, yn) && (u = yr(e, u, t, o, a));
        const c = Ce(s, "type"), f = Ce(u, "type");
        if (!c || c === f) {
          const p = Ce(n, "maxItems", -1);
          f === "object" ? i = o.reduce((g, h) => {
            const y = gE(e, t, u, s, h, a);
            return y !== void 0 && (p < 0 || g.length < p) && g.push(y), g;
          }, []) : i = p > 0 && o.length > p ? o.slice(0, p) : o;
        }
      } else typeof s == "boolean" && typeof u == "boolean" && s === u && (i = o);
    }
    return i;
  }
  function Yl(e, t, n, r, o, a = [], i) {
    if (yn in t || IP in t || cl in t) {
      const u = yr(e, t, r, o, i);
      if (a.findIndex((c) => fn(c, u)) === -1)
        return Yl(e, u, n, r, o, a.concat(u), i);
    }
    let s = {
      [Vy]: n.replace(/^\./, "")
    };
    if (pt in t || Nt in t) {
      const u = pt in t ? t.oneOf : t.anyOf, c = Ga(t), f = xm(e, r, o, u, 0, c, i), p = u[f];
      s = {
        ...s,
        ...Yl(e, p, n, r, o, a, i)
      };
    }
    if (Ib in t && t[Ib] !== !1 && Qt(s, AP, !0), Ed in t && Array.isArray(o)) {
      const { items: u, additionalItems: c } = t;
      Array.isArray(u) ? o.forEach((f, p) => {
        u[p] ? s[p] = Yl(e, u[p], `${n}.${p}`, r, f, a, i) : c ? s[p] = Yl(e, c, `${n}.${p}`, r, f, a, i) : console.warn(`Unable to generate path schema for "${n}.${p}". No schema defined for it`);
      }) : o.forEach((f, p) => {
        s[p] = Yl(e, u, `${n}.${p}`, r, f, a, i);
      });
    } else if (Lt in t)
      for (const u in t.properties) {
        const c = Ce(t, [Lt, u], {});
        s[u] = Yl(
          e,
          c,
          `${n}.${u}`,
          r,
          // It's possible that formData is not an object -- this can happen if an
          // array item has just been added, but not populated with data yet
          Ce(o, [u]),
          a,
          i
        );
      }
    return s;
  }
  function K2e(e, t, n = "", r, o, a) {
    return Yl(e, t, n, r, o, void 0, a);
  }
  class G2e {
    /** Constructs the `SchemaUtils` instance with the given `validator` and `rootSchema` stored as instance variables
     *
     * @param validator - An implementation of the `ValidatorType` interface that will be forwarded to all the APIs
     * @param rootSchema - The root schema that will be forwarded to all the APIs
     * @param experimental_defaultFormStateBehavior - Configuration flags to allow users to override default form state behavior
     * @param [experimental_customMergeAllOf] - Optional function that allows for custom merging of `allOf` schemas
     */
    constructor(t, n, r, o) {
      n && n[xp] === Uy ? this.rootSchema = mE(n, Ce(n, rn, "#")) : this.rootSchema = n, this.validator = t, this.experimental_defaultFormStateBehavior = r, this.experimental_customMergeAllOf = o;
    }
    /** Returns the `rootSchema` in the `SchemaUtilsType`
     *
     * @returns - The `rootSchema`
     */
    getRootSchema() {
      return this.rootSchema;
    }
    /** Returns the `ValidatorType` in the `SchemaUtilsType`
     *
     * @returns - The `ValidatorType`
     */
    getValidator() {
      return this.validator;
    }
    /** Determines whether either the `validator` and `rootSchema` differ from the ones associated with this instance of
     * the `SchemaUtilsType`. If either `validator` or `rootSchema` are falsy, then return false to prevent the creation
     * of a new `SchemaUtilsType` with incomplete properties.
     *
     * @param validator - An implementation of the `ValidatorType` interface that will be compared against the current one
     * @param rootSchema - The root schema that will be compared against the current one
     * @param [experimental_defaultFormStateBehavior] Optional configuration object, if provided, allows users to override default form state behavior
     * @param [experimental_customMergeAllOf] - Optional function that allows for custom merging of `allOf` schemas
     * @returns - True if the `SchemaUtilsType` differs from the given `validator` or `rootSchema`
     */
    doesSchemaUtilsDiffer(t, n, r = {}, o) {
      return !t || !n ? !1 : this.validator !== t || !fn(this.rootSchema, n) || !fn(this.experimental_defaultFormStateBehavior, r) || this.experimental_customMergeAllOf !== o;
    }
    /** Finds the field specified by the `path` within the root or recursed `schema`. If there is no field for the specified
     * `path`, then the default `{ field: undefined, isRequired: undefined }` is returned. It determines whether a leaf
     * field is in the `required` list for its parent and if so, it is marked as required on return.
     *
     * @param schema - The current node within the JSON schema
     * @param path - The remaining keys in the path to the desired field
     * @param [formData] - The form data that is used to determine which oneOf option
     * @returns - An object that contains the field and its required state. If no field can be found then
     *            `{ field: undefined, isRequired: undefined }` is returned.
     */
    findFieldInSchema(t, n, r) {
      return $2e(this.validator, this.rootSchema, t, n, r, this.experimental_customMergeAllOf);
    }
    /** Finds the oneOf option inside the `schema['any/oneOf']` list which has the `properties[selectorField].default` that
     * matches the `formData[selectorField]` value. For the purposes of this function, `selectorField` is either
     * `schema.discriminator.propertyName` or `fallbackField`.
     *
     * @param schema - The schema element in which to search for the selected oneOf option
     * @param fallbackField - The field to use as a backup selector field if the schema does not have a required field
     * @param xxx - Either `oneOf` or `anyOf`, defines which value is being sought
     * @param [formData={}] - The form data that is used to determine which oneOf option
     * @returns - The anyOf/oneOf option that matches the selector field in the schema or undefined if nothing is selected
     */
    findSelectedOptionInXxxOf(t, n, r, o) {
      return Sp(this.validator, this.rootSchema, t, n, r, o, this.experimental_customMergeAllOf);
    }
    /** Returns the superset of `formData` that includes the given set updated to include any missing fields that have
     * computed to have defaults provided in the `schema`.
     *
     * @param schema - The schema for which the default state is desired
     * @param [formData] - The current formData, if any, onto which to provide any missing defaults
     * @param [includeUndefinedValues=false] - Optional flag, if true, cause undefined values to be added as defaults.
     *          If "excludeObjectChildren", pass `includeUndefinedValues` as false when computing defaults for any nested
     *          object properties.
     * @param initialDefaultsGenerated - Indicates whether or not initial defaults have been generated
     * @returns - The resulting `formData` with all the defaults provided
     */
    getDefaultFormState(t, n, r = !1, o) {
      return f1(this.validator, t, n, this.rootSchema, r, this.experimental_defaultFormStateBehavior, this.experimental_customMergeAllOf, o);
    }
    /** Determines whether the combination of `schema` and `uiSchema` properties indicates that the label for the `schema`
     * should be displayed in a UI.
     *
     * @param schema - The schema for which the display label flag is desired
     * @param [uiSchema] - The UI schema from which to derive potentially displayable information
     * @param [globalOptions={}] - The optional Global UI Schema from which to get any fallback `xxx` options
     * @returns - True if the label should be displayed or false if it should not
     */
    getDisplayLabel(t, n, r) {
      return q2e(this.validator, t, n, this.rootSchema, r, this.experimental_customMergeAllOf);
    }
    /** Determines which of the given `options` provided most closely matches the `formData`.
     * Returns the index of the option that is valid and is the closest match, or 0 if there is no match.
     *
     * The closest match is determined using the number of matching properties, and more heavily favors options with
     * matching readOnly, default, or const values.
     *
     * @param formData - The form data associated with the schema
     * @param options - The list of options that can be selected from
     * @param [selectedOption] - The index of the currently selected option, defaulted to -1 if not specified
     * @param [discriminatorField] - The optional name of the field within the options object whose value is used to
     *          determine which option is selected
     * @returns - The index of the option that is the closest match to the `formData` or the `selectedOption` if no match
     */
    getClosestMatchingOption(t, n, r, o) {
      return xm(this.validator, this.rootSchema, t, n, r, o, this.experimental_customMergeAllOf);
    }
    /** Given the `formData` and list of `options`, attempts to find the index of the first option that matches the data.
     * Always returns the first option if there is nothing that matches.
     *
     * @param formData - The current formData, if any, used to figure out a match
     * @param options - The list of options to find a matching options from
     * @param [discriminatorField] - The optional name of the field within the options object whose value is used to
     *          determine which option is selected
     * @returns - The firstindex of the matched option or 0 if none is available
     */
    getFirstMatchingOption(t, n, r) {
      return tO(this.validator, t, n, this.rootSchema, r);
    }
    getFromSchema(t, n, r) {
      return qy(
        this.validator,
        this.rootSchema,
        t,
        n,
        // @ts-expect-error TS2769: No overload matches this call
        r,
        this.experimental_customMergeAllOf
      );
    }
    /** Checks to see if the `schema` and `uiSchema` combination represents an array of files
     *
     * @param schema - The schema for which check for array of files flag is desired
     * @param [uiSchema] - The UI schema from which to check the widget
     * @returns - True if schema/uiSchema contains an array of files, otherwise false
     */
    isFilesArray(t, n) {
      return m1(this.validator, t, n, this.rootSchema, this.experimental_customMergeAllOf);
    }
    /** Checks to see if the `schema` combination represents a multi-select
     *
     * @param schema - The schema for which check for a multi-select flag is desired
     * @returns - True if schema contains a multi-select, otherwise false
     */
    isMultiSelect(t) {
      return oO(this.validator, t, this.rootSchema, this.experimental_customMergeAllOf);
    }
    /** Checks to see if the `schema` combination represents a select
     *
     * @param schema - The schema for which check for a select flag is desired
     * @returns - True if schema contains a select, otherwise false
     */
    isSelect(t) {
      return rO(this.validator, t, this.rootSchema, this.experimental_customMergeAllOf);
    }
    /** Retrieves an expanded schema that has had all of its conditions, additional properties, references and
     * dependencies resolved and merged into the `schema` given a `rawFormData` that is used to do the potentially
     * recursive resolution.
     *
     * @param schema - The schema for which retrieving a schema is desired
     * @param [rawFormData] - The current formData, if any, to assist retrieving a schema
     * @param [resolveAnyOfOrOneOfRefs] - Optional flag indicating whether to resolved refs in anyOf/oneOf lists
     * @returns - The schema having its conditions, additional properties, references and dependencies resolved
     */
    retrieveSchema(t, n, r) {
      return yr(this.validator, t, this.rootSchema, n, this.experimental_customMergeAllOf, r);
    }
    /** Sanitize the `data` associated with the `oldSchema` so it is considered appropriate for the `newSchema`. If the
     * new schema does not contain any properties, then `undefined` is returned to clear all the form data. Due to the
     * nature of schemas, this sanitization happens recursively for nested objects of data. Also, any properties in the
     * old schemas that are non-existent in the new schema are set to `undefined`.
     *
     * @param [newSchema] - The new schema for which the data is being sanitized
     * @param [oldSchema] - The old schema from which the data originated
     * @param [data={}] - The form data associated with the schema, defaulting to an empty object when undefined
     * @returns - The new form data, with all the fields uniquely associated with the old schema set
     *      to `undefined`. Will return `undefined` if the new schema is not an object containing properties.
     */
    sanitizeDataForNewSchema(t, n, r) {
      return gE(this.validator, this.rootSchema, t, n, r, this.experimental_customMergeAllOf);
    }
    /** Generates an `PathSchema` object for the `schema`, recursively
     *
     * @param schema - The schema for which the display label flag is desired
     * @param [name] - The base name for the schema
     * @param [formData] - The current formData, if any, onto which to provide any missing defaults
     * @returns - The `PathSchema` object for the `schema`
     */
    toPathSchema(t, n, r) {
      return K2e(this.validator, t, n, this.rootSchema, r, this.experimental_customMergeAllOf);
    }
  }
  function X2e(e, t, n = {}, r) {
    return new G2e(e, t, n, r);
  }
  function Y2e(e) {
    var t;
    if (e.indexOf("data:") === -1)
      throw new Error("File is invalid: URI must be a dataURI");
    const n = e.slice(5).split(";base64,");
    if (n.length !== 2)
      throw new Error("File is invalid: dataURI must be base64");
    const [r, o] = n, [a, ...i] = r.split(";"), s = a || "", u = decodeURI(
      // parse the parameters into key-value pairs, find a key, and extract a value
      // if no key is found, then the name is unknown
      ((t = i.map((c) => c.split("=")).find(([c]) => c === "name")) === null || t === void 0 ? void 0 : t[1]) || "unknown"
    );
    try {
      const c = atob(o), f = new Array(c.length);
      for (let p = 0; p < c.length; p++)
        f[p] = c.charCodeAt(p);
      return { blob: new window.Blob([new Uint8Array(f)], { type: s }), name: u };
    } catch (c) {
      throw new Error("File is invalid: " + c.message);
    }
  }
  function Us(e, t) {
    let n = String(e);
    for (; n.length < t; )
      n = "0" + n;
    return n;
  }
  function h1(e, t) {
    if (e <= 0 && t <= 0)
      e = (/* @__PURE__ */ new Date()).getFullYear() + e, t = (/* @__PURE__ */ new Date()).getFullYear() + t;
    else if (e < 0 || t < 0)
      throw new Error(`Both start (${e}) and stop (${t}) must both be <= 0 or > 0, got one of each`);
    if (e > t)
      return h1(t, e).reverse();
    const n = [];
    for (let r = e; r <= t; r++)
      n.push({ value: r, label: Us(r, 2) });
    return n;
  }
  function m4(e, t) {
    if (Object.is(e, t))
      return !0;
    if (e == null || t == null || typeof e != "object" || typeof t != "object")
      return !1;
    const n = Object.keys(e), r = Object.keys(t);
    if (n.length !== r.length)
      return !1;
    for (let o = 0; o < n.length; o++) {
      const a = n[o];
      if (!Object.prototype.hasOwnProperty.call(t, a) || !Object.is(e[a], t[a]))
        return !1;
    }
    return !0;
  }
  function J2e(e, t) {
    let n = e;
    if (Array.isArray(t)) {
      const r = n.split(/(%\d)/);
      t.forEach((o, a) => {
        const i = r.findIndex((s) => s === `%${a + 1}`);
        i >= 0 && (r[i] = o);
      }), n = r.join("");
    }
    return n;
  }
  function Q2e(e, t) {
    return J2e(e, t);
  }
  function Qn(e, t = [], n) {
    if (Array.isArray(e))
      return e.map((a) => Qn(a, t)).filter((a) => a !== n);
    const r = e === "" || e === null ? -1 : Number(e), o = t[r];
    return o ? o.value : n;
  }
  function g1(e, t, n = []) {
    const r = Qn(e, n);
    return Array.isArray(t) ? t.filter((o) => !fn(o, r)) : fn(r, t) ? void 0 : t;
  }
  function vx(e, t) {
    return Array.isArray(t) ? t.some((n) => fn(n, e)) : fn(t, e);
  }
  function aO(e, t = [], n = !1) {
    const r = t.map((o, a) => vx(o.value, e) ? String(a) : void 0).filter((o) => typeof o < "u");
    return n ? r : r[0];
  }
  function v1(e, t, n = []) {
    const r = Qn(e, n);
    if (!Fb(r)) {
      const o = n.findIndex((i) => r === i.value), a = n.map(({ value: i }) => i);
      return t.slice(0, o).concat(r, t.slice(o)).sort((i, s) => +(a.indexOf(i) > a.indexOf(s)));
    }
    return t;
  }
  var Z2e = 1, eEe = 4;
  function iO(e) {
    return Dp(e, Z2e | eEe);
  }
  function tEe(e, t, n, r) {
    return r = typeof r == "function" ? r : void 0, e == null ? e : qP(e, t, n, r);
  }
  class y1 {
    /** Construct an `ErrorSchemaBuilder` with an optional initial set of errors in an `ErrorSchema`.
     *
     * @param [initialSchema] - The optional set of initial errors, that will be cloned into the class
     */
    constructor(t) {
      this.errorSchema = {}, this.resetAllErrors(t);
    }
    /** Returns the `ErrorSchema` that has been updated by the methods of the `ErrorSchemaBuilder`
     */
    get ErrorSchema() {
      return this.errorSchema;
    }
    /** Will get an existing `ErrorSchema` at the specified `pathOfError` or create and return one.
     *
     * @param [pathOfError] - The optional path into the `ErrorSchema` at which to add the error(s)
     * @returns - The error block for the given `pathOfError` or the root if not provided
     * @private
     */
    getOrCreateErrorBlock(t) {
      let n = Array.isArray(t) && t.length > 0 || typeof t == "string" ? Ce(this.errorSchema, t) : this.errorSchema;
      return !n && t && (n = {}, tEe(this.errorSchema, t, n, Object)), n;
    }
    /** Resets all errors in the `ErrorSchemaBuilder` back to the `initialSchema` if provided, otherwise an empty set.
     *
     * @param [initialSchema] - The optional set of initial errors, that will be cloned into the class
     * @returns - The `ErrorSchemaBuilder` object for chaining purposes
     */
    resetAllErrors(t) {
      return this.errorSchema = t ? iO(t) : {}, this;
    }
    /** Adds the `errorOrList` to the list of errors in the `ErrorSchema` at either the root level or the location within
     * the schema described by the `pathOfError`. For more information about how to specify the path see the
     * [eslint lodash plugin docs](https://github.com/wix/eslint-plugin-lodash/blob/master/docs/rules/path-style.md).
     *
     * @param errorOrList - The error or list of errors to add into the `ErrorSchema`
     * @param [pathOfError] - The optional path into the `ErrorSchema` at which to add the error(s)
     * @returns - The `ErrorSchemaBuilder` object for chaining purposes
     */
    addErrors(t, n) {
      const r = this.getOrCreateErrorBlock(n);
      let o = Ce(r, cr);
      return Array.isArray(o) || (o = [], r[cr] = o), Array.isArray(t) ? Qt(r, cr, [.../* @__PURE__ */ new Set([...o, ...t])]) : Qt(r, cr, [.../* @__PURE__ */ new Set([...o, t])]), this;
    }
    /** Sets/replaces the `errorOrList` as the error(s) in the `ErrorSchema` at either the root level or the location
     * within the schema described by the `pathOfError`. For more information about how to specify the path see the
     * [eslint lodash plugin docs](https://github.com/wix/eslint-plugin-lodash/blob/master/docs/rules/path-style.md).
     *
     * @param errorOrList - The error or list of errors to set into the `ErrorSchema`
     * @param [pathOfError] - The optional path into the `ErrorSchema` at which to set the error(s)
     * @returns - The `ErrorSchemaBuilder` object for chaining purposes
     */
    setErrors(t, n) {
      const r = this.getOrCreateErrorBlock(n), o = Array.isArray(t) ? [.../* @__PURE__ */ new Set([...t])] : [t];
      return Qt(r, cr, o), this;
    }
    /** Clears the error(s) in the `ErrorSchema` at either the root level or the location within the schema described by
     * the `pathOfError`. For more information about how to specify the path see the
     * [eslint lodash plugin docs](https://github.com/wix/eslint-plugin-lodash/blob/master/docs/rules/path-style.md).
     *
     * @param [pathOfError] - The optional path into the `ErrorSchema` at which to clear the error(s)
     * @returns - The `ErrorSchemaBuilder` object for chaining purposes
     */
    clearErrors(t) {
      const n = this.getOrCreateErrorBlock(t);
      return Qt(n, cr, []), this;
    }
  }
  function b1(e, t, n) {
    for (var r = -1, o = t.length, a = {}; ++r < o; ) {
      var i = t[r], s = px(e, i);
      n(s, i) && qP(a, Hd(i, e), s);
    }
    return a;
  }
  function nEe(e, t) {
    if (e == null)
      return {};
    var n = Ud(QP(e), function(r) {
      return [r];
    });
    return t = GP(t), b1(e, n, function(r, o) {
      return t(r, o[0]);
    });
  }
  var rEe = 200;
  function oEe(e, t, n, r) {
    var o = -1, a = JP, i = !0, s = e.length, u = [], c = t.length;
    if (!s)
      return u;
    t.length >= rEe && (a = gm, i = !1, t = new vu(t));
    e:
      for (; ++o < s; ) {
        var f = e[o], p = f;
        if (f = f !== 0 ? f : 0, i && p === p) {
          for (var g = c; g--; )
            if (t[g] === p)
              continue e;
          u.push(f);
        } else a(t, p, r) || u.push(f);
      }
    return u;
  }
  var aEe = hx(function(e, t) {
    return ym(e) ? oEe(e, ph(t, 1, ym, !0)) : [];
  });
  function h4(e, t) {
    const n = dl(e), r = dl(t);
    if (e === t || !n && !r)
      return [];
    if (n && !r)
      return Xo(e);
    if (!n && r)
      return Xo(t);
    {
      const o = Xo(nEe(e, (i, s) => !fn(i, Ce(t, s)))), a = aEe(Xo(t), Xo(e));
      return [...o, ...a];
    }
  }
  function iEe(e, t, n = [1900, (/* @__PURE__ */ new Date()).getFullYear() + 2], r = "YMD") {
    const { day: o, month: a, year: i, hour: s, minute: u, second: c } = e, f = { type: "day", range: [1, 31], value: o }, p = { type: "month", range: [1, 12], value: a }, g = { type: "year", range: n, value: i }, h = [];
    switch (r) {
      case "MDY":
        h.push(p, f, g);
        break;
      case "DMY":
        h.push(f, p, g);
        break;
      default:
        h.push(g, p, f);
    }
    return t && h.push({ type: "hour", range: [0, 23], value: s }, { type: "minute", range: [0, 59], value: u }, { type: "second", range: [0, 59], value: c }), h;
  }
  function w1(e) {
    const t = {};
    return e.multipleOf && (t.step = e.multipleOf), (e.minimum || e.minimum === 0) && (t.min = e.minimum), (e.maximum || e.maximum === 0) && (t.max = e.maximum), t;
  }
  function x1(e, t, n = {}, r = !0) {
    const o = {
      type: t || "text",
      ...w1(e)
    };
    return n.inputType ? o.type = n.inputType : t || (e.type === "number" ? (o.type = "number", r && o.step === void 0 && (o.step = "any")) : e.type === "integer" && (o.type = "number", o.step === void 0 && (o.step = 1))), n.autocomplete && (o.autoComplete = n.autocomplete), n.accept && (o.accept = n.accept), o;
  }
  const g4 = {
    props: {
      disabled: !1
    },
    submitText: "Submit",
    norender: !1
  };
  function k1(e = {}) {
    const t = Qe(e);
    if (t && t[Ab]) {
      const n = t[Ab];
      return { ...g4, ...n };
    }
    return g4;
  }
  function et(e, t, n = {}) {
    const { templates: r } = t;
    if (e === "ButtonTemplates")
      return r[e];
    if (Object.hasOwn(n, e) && typeof n[e] == "string" && Object.hasOwn(r, n[e])) {
      const o = n[e];
      return r[o];
    }
    return (
      // Evaluating uiOptions[name] results in TS2590: Expression produces a union type that is too complex to represent
      // To avoid that, we cast uiOptions to `any` before accessing the name field
      n[e] || r[e]
    );
  }
  var sEe = 0;
  function S1(e) {
    var t = ++sEe;
    return UP(e) + t;
  }
  function sO() {
    if (typeof process > "u" || Ce(process, "env.NODE_ENV") !== "test")
      return {};
    const e = /* @__PURE__ */ new Map();
    return new Proxy({}, {
      get(t, n) {
        return e.has(n) || e.set(n, S1("test-id-")), e.get(n);
      }
    });
  }
  var v4 = { exports: {} }, Ht = {}, y4;
  function lEe() {
    if (y4) return Ht;
    y4 = 1;
    var e = /* @__PURE__ */ Symbol.for("react.element"), t = /* @__PURE__ */ Symbol.for("react.portal"), n = /* @__PURE__ */ Symbol.for("react.fragment"), r = /* @__PURE__ */ Symbol.for("react.strict_mode"), o = /* @__PURE__ */ Symbol.for("react.profiler"), a = /* @__PURE__ */ Symbol.for("react.provider"), i = /* @__PURE__ */ Symbol.for("react.context"), s = /* @__PURE__ */ Symbol.for("react.server_context"), u = /* @__PURE__ */ Symbol.for("react.forward_ref"), c = /* @__PURE__ */ Symbol.for("react.suspense"), f = /* @__PURE__ */ Symbol.for("react.suspense_list"), p = /* @__PURE__ */ Symbol.for("react.memo"), g = /* @__PURE__ */ Symbol.for("react.lazy"), h = /* @__PURE__ */ Symbol.for("react.offscreen"), y;
    y = /* @__PURE__ */ Symbol.for("react.module.reference");
    function b(v) {
      if (typeof v == "object" && v !== null) {
        var w = v.$$typeof;
        switch (w) {
          case e:
            switch (v = v.type, v) {
              case n:
              case o:
              case r:
              case c:
              case f:
                return v;
              default:
                switch (v = v && v.$$typeof, v) {
                  case s:
                  case i:
                  case u:
                  case g:
                  case p:
                  case a:
                    return v;
                  default:
                    return w;
                }
            }
          case t:
            return w;
        }
      }
    }
    return Ht.ContextConsumer = i, Ht.ContextProvider = a, Ht.Element = e, Ht.ForwardRef = u, Ht.Fragment = n, Ht.Lazy = g, Ht.Memo = p, Ht.Portal = t, Ht.Profiler = o, Ht.StrictMode = r, Ht.Suspense = c, Ht.SuspenseList = f, Ht.isAsyncMode = function() {
      return !1;
    }, Ht.isConcurrentMode = function() {
      return !1;
    }, Ht.isContextConsumer = function(v) {
      return b(v) === i;
    }, Ht.isContextProvider = function(v) {
      return b(v) === a;
    }, Ht.isElement = function(v) {
      return typeof v == "object" && v !== null && v.$$typeof === e;
    }, Ht.isForwardRef = function(v) {
      return b(v) === u;
    }, Ht.isFragment = function(v) {
      return b(v) === n;
    }, Ht.isLazy = function(v) {
      return b(v) === g;
    }, Ht.isMemo = function(v) {
      return b(v) === p;
    }, Ht.isPortal = function(v) {
      return b(v) === t;
    }, Ht.isProfiler = function(v) {
      return b(v) === o;
    }, Ht.isStrictMode = function(v) {
      return b(v) === r;
    }, Ht.isSuspense = function(v) {
      return b(v) === c;
    }, Ht.isSuspenseList = function(v) {
      return b(v) === f;
    }, Ht.isValidElementType = function(v) {
      return typeof v == "string" || typeof v == "function" || v === n || v === o || v === r || v === c || v === f || v === h || typeof v == "object" && v !== null && (v.$$typeof === g || v.$$typeof === p || v.$$typeof === a || v.$$typeof === i || v.$$typeof === u || v.$$typeof === y || v.getModuleId !== void 0);
    }, Ht.typeOf = b, Ht;
  }
  var b4;
  function uEe() {
    return b4 || (b4 = 1, v4.exports = lEe()), v4.exports;
  }
  var cEe = uEe();
  const w4 = /* @__PURE__ */ Qi(cEe), g0 = {
    boolean: {
      checkbox: "CheckboxWidget",
      radio: "RadioWidget",
      select: "SelectWidget",
      hidden: "HiddenWidget"
    },
    string: {
      text: "TextWidget",
      password: "PasswordWidget",
      email: "EmailWidget",
      hostname: "TextWidget",
      ipv4: "TextWidget",
      ipv6: "TextWidget",
      uri: "URLWidget",
      "data-url": "FileWidget",
      radio: "RadioWidget",
      select: "SelectWidget",
      textarea: "TextareaWidget",
      hidden: "HiddenWidget",
      date: "DateWidget",
      datetime: "DateTimeWidget",
      "date-time": "DateTimeWidget",
      "alt-date": "AltDateWidget",
      "alt-datetime": "AltDateTimeWidget",
      time: "TimeWidget",
      color: "ColorWidget",
      file: "FileWidget"
    },
    number: {
      text: "TextWidget",
      select: "SelectWidget",
      updown: "UpDownWidget",
      range: "RangeWidget",
      radio: "RadioWidget",
      hidden: "HiddenWidget"
    },
    integer: {
      text: "TextWidget",
      select: "SelectWidget",
      updown: "UpDownWidget",
      range: "RangeWidget",
      radio: "RadioWidget",
      hidden: "HiddenWidget"
    },
    array: {
      select: "SelectWidget",
      checkboxes: "CheckboxesWidget",
      files: "FileWidget",
      hidden: "HiddenWidget"
    }
  };
  function dEe(e) {
    let t = Ce(e, "MergedWidget");
    if (!t) {
      const n = e.defaultProps && e.defaultProps.options || {};
      t = ({ options: r, ...o }) => S.jsx(e, { options: { ...n, ...r }, ...o }), Qt(e, "MergedWidget", t);
    }
    return t;
  }
  function Xa(e, t, n = {}) {
    const r = aa(e);
    if (typeof t == "function" || t && w4.isForwardRef(C.createElement(t)) || w4.isMemo(t))
      return dEe(t);
    if (typeof t != "string")
      throw new Error(`Unsupported widget definition: ${typeof t} in schema: ${JSON.stringify(e)}`);
    if (t in n) {
      const o = n[t];
      return Xa(e, o, n);
    }
    if (typeof r == "string") {
      if (!(r in g0))
        throw new Error(`No widget for type '${r}' in schema: ${JSON.stringify(e)}`);
      if (t in g0[r]) {
        const o = n[g0[r][t]];
        return Xa(e, o, n);
      }
    }
    throw new Error(`No widget '${t}' for type '${r}' in schema: ${JSON.stringify(e)}`);
  }
  function fEe(e) {
    let t = 0;
    for (let n = 0; n < e.length; n += 1) {
      const r = e.charCodeAt(n);
      t = (t << 5) - t + r, t = t & t;
    }
    return t.toString(16);
  }
  function pEe(e) {
    const t = /* @__PURE__ */ new Set();
    return JSON.stringify(e, (n, r) => (t.add(n), r)), JSON.stringify(e, Array.from(t).sort());
  }
  function $a(e) {
    return fEe(pEe(e));
  }
  function mEe(e) {
    return $a(e);
  }
  function hEe(e, t, n = {}) {
    try {
      return Xa(e, t, n), !0;
    } catch (r) {
      const o = r;
      if (o.message && (o.message.startsWith("No widget") || o.message.startsWith("Unsupported widget")))
        return !1;
      throw r;
    }
  }
  function Nu(e, t) {
    return `${fl(e) ? e : e[rn]}__${t}`;
  }
  function Mu(e) {
    return Nu(e, "description");
  }
  function lO(e) {
    return Nu(e, "error");
  }
  function _m(e) {
    return Nu(e, "examples");
  }
  function uO(e) {
    return Nu(e, "help");
  }
  function yx(e) {
    return Nu(e, "title");
  }
  function vo(e, t = !1) {
    const n = t ? ` ${_m(e)}` : "";
    return `${lO(e)} ${Mu(e)} ${uO(e)}${n}`;
  }
  function bx(e, t) {
    return `${e}-${t}`;
  }
  function Da(e, t) {
    return Nu(e, t);
  }
  function v0(e, t) {
    return Nu(e, `optional${t}`);
  }
  function qd(e) {
    return !Fb(e) && (!jt(e) || Array.isArray(e) || !Hn(e));
  }
  function gEe(e, t) {
    const { rootSchema: n, schemaUtils: r } = e;
    if (vm(t, n))
      return !0;
    if (yn in n) {
      const o = r.retrieveSchema(n);
      return vm(t, o);
    }
    return !1;
  }
  function Ru(e, t, n) {
    return t ? n : e;
  }
  function vEe(e) {
    return e ? new Date(e).toJSON() : void 0;
  }
  function cO(e, t, n) {
    const r = [Iwe];
    return Et(e, x3) && r.unshift(x3), Ce(e, [...r, t], n);
  }
  function yEe(e, t) {
    if (!Array.isArray(t))
      return e;
    const n = (f) => f.reduce((p, g) => (p[g] = !0, p), {}), r = (f) => f.length > 1 ? `properties '${f.join("', '")}'` : `property '${f[0]}'`, o = n(e), a = t.filter((f) => f === "*" || o[f]), i = n(a), s = e.filter((f) => !i[f]), u = a.indexOf("*");
    if (u === -1) {
      if (s.length)
        throw new Error(`uiSchema order list does not contain ${r(s)}`);
      return a;
    }
    if (u !== a.lastIndexOf("*"))
      throw new Error("uiSchema order list contains more than one wildcard item");
    const c = [...a];
    return c.splice(u, 1, ...s), c;
  }
  function y0(e, t = !0) {
    if (!e)
      return {
        year: -1,
        month: -1,
        day: -1,
        hour: t ? -1 : 0,
        minute: t ? -1 : 0,
        second: t ? -1 : 0
      };
    const n = new Date(e);
    if (Number.isNaN(n.getTime()))
      throw new Error("Unable to parse date " + e);
    return {
      year: n.getUTCFullYear(),
      month: n.getUTCMonth() + 1,
      // oh you, javascript.
      day: n.getUTCDate(),
      hour: t ? n.getUTCHours() : 0,
      minute: t ? n.getUTCMinutes() : 0,
      second: t ? n.getUTCSeconds() : 0
    };
  }
  function Lp(e) {
    if (e.const || e.enum && e.enum.length === 1 && e.enum[0] === !0)
      return !0;
    if (e.anyOf && e.anyOf.length === 1)
      return Lp(e.anyOf[0]);
    if (e.oneOf && e.oneOf.length === 1)
      return Lp(e.oneOf[0]);
    if (e.allOf) {
      const t = (n) => Lp(n);
      return e.allOf.some(t);
    }
    return !1;
  }
  function _1(e, t, n, r = "customDeep") {
    if (r === "always")
      return !0;
    if (r === "shallow") {
      const { props: i, state: s } = e;
      return !m4(i, t) || !m4(s, n);
    }
    const { props: o, state: a } = e;
    return !fn(o, t) || !fn(a, n);
  }
  function x4(e) {
    const t = zV(e.map((n) => jt(n) ? aa(n) : void 0).flat().filter((n) => n !== void 0));
    return t.length === 1 ? t[0] : t;
  }
  function mh(e, t, n, r) {
    const { enableOptionalDataFieldForType: o = [] } = Qe(r, e.globalUiOptions);
    let a;
    return Nt in t && Array.isArray(t[Nt]) ? a = x4(t[Nt]) : pt in t && Array.isArray(t[pt]) ? a = x4(t[pt]) : a = aa(t), !gEe(e, t) && !n && !!a && !Array.isArray(a) && !!o.find((i) => i === a);
  }
  function k4(e, t = !0) {
    const { year: n, month: r, day: o, hour: a = 0, minute: i = 0, second: s = 0 } = e, u = Date.UTC(n, r - 1, o, a, i, s), c = new Date(u).toJSON();
    return t ? c : c.slice(0, 10);
  }
  function dO(e, t = []) {
    if (!e)
      return [];
    let n = [];
    return cr in e && (n = n.concat(e[cr].map((r) => {
      const o = `.${t.join(".")}`;
      return {
        property: o,
        message: r,
        stack: `${o} ${r}`
      };
    }))), Object.keys(e).reduce((r, o) => {
      if (o !== cr) {
        const a = e[o];
        dl(a) && (r = r.concat(dO(a, [...t, o])));
      }
      return r;
    }, n);
  }
  function E1(e) {
    return Yn(e) ? Ud(e, Ou) : dh(e) ? [e] : YP(bV(UP(e)));
  }
  function bEe(e) {
    const t = new y1();
    return e.length && e.forEach((n) => {
      const { property: r, message: o } = n, a = r === "." ? [] : E1(r);
      a.length > 0 && a[0] === "" && a.splice(0, 1), o && t.addErrors(o, a);
    }), t.ErrorSchema;
  }
  function Do(e, t, n, r) {
    const o = Array.isArray(n) ? n : n?.path, a = e === "" ? [] : [e], i = o ? o.concat(...a) : a, s = [t.idPrefix, ...i].join(t.idSeparator);
    let u;
    return t.nameGenerator && i.length > 0 && (u = t.nameGenerator(i, t.idPrefix, r)), { path: i, [rn]: s, ...u !== void 0 && { name: u } };
  }
  function C1(e) {
    return Object.keys(e).reduce((t, n) => {
      if (n === "addError")
        return t;
      {
        const r = e[n];
        return dl(r) ? {
          ...t,
          [n]: C1(r)
        } : { ...t, [n]: r };
      }
    }, {});
  }
  function wEe(e) {
    return Object.values(e).every((t) => t !== -1);
  }
  function xEe(e) {
    const { className: t = "form-control", type: n, range: r, value: o, select: a, rootId: i, name: s, disabled: u, readonly: c, autofocus: f, registry: p, onBlur: g, onFocus: h } = e, y = `${i}_${n}`, { SelectWidget: b } = p.widgets, v = C.useCallback((w) => a(n, w), [a, n]);
    return S.jsx(b, { schema: { type: "integer" }, id: y, name: s, className: t, options: { enumOptions: h1(r[0], r[1]) }, placeholder: n, value: o, disabled: u, readonly: c, autofocus: f, onChange: v, onBlur: g, onFocus: h, registry: p, label: "", "aria-describedby": vo(i) });
  }
  function kEe(e) {
    const { time: t = !1, disabled: n = !1, readonly: r = !1, options: o, onChange: a, value: i } = e, [s, u] = C.useState(y0(i, t));
    C.useEffect(() => {
      u(y0(i, t));
    }, [t, i]);
    const c = C.useCallback((g, h) => {
      const y = {
        ...s,
        [g]: typeof h > "u" ? -1 : h
      };
      wEe(y) ? a(k4(y, t)) : u(y);
    }, [s, a, t]), f = C.useCallback((g) => {
      g.preventDefault(), !(n || r) && a(void 0);
    }, [n, r, a]), p = C.useCallback((g) => {
      if (g.preventDefault(), n || r)
        return;
      const h = y0((/* @__PURE__ */ new Date()).toJSON(), t);
      a(k4(h, t));
    }, [n, r, t, a]);
    return { elements: C.useMemo(() => iEe(s, t, o.yearsRange, o.format), [s, t, o.yearsRange, o.format]), handleChange: c, handleClear: f, handleSetNow: p };
  }
  function ju(e) {
    const t = C.useRef(e);
    return vm(e, t.current) || (t.current = e), t.current;
  }
  function SEe(e, t) {
    return e.replace(";base64", `;name=${encodeURIComponent(t)};base64`);
  }
  function _Ee(e) {
    const { name: t, size: n, type: r } = e;
    return new Promise((o, a) => {
      const i = new window.FileReader();
      i.onerror = a, i.onload = (s) => {
        var u;
        typeof ((u = s.target) === null || u === void 0 ? void 0 : u.result) == "string" ? o({
          dataURL: SEe(s.target.result, t),
          name: t,
          size: n,
          type: r
        }) : o({
          dataURL: null,
          name: t,
          size: n,
          type: r
        });
      }, i.readAsDataURL(e);
    });
  }
  function EEe(e) {
    return Promise.all(Array.from(e).map(_Ee));
  }
  function S4(e) {
    return e.reduce((t, n) => {
      if (!n)
        return t;
      try {
        const { blob: r, name: o } = Y2e(n);
        return [
          ...t,
          {
            dataURL: n,
            name: o,
            size: r.size,
            type: r.type
          }
        ];
      } catch {
        return t;
      }
    }, []);
  }
  function CEe(e, t, n = !1) {
    const r = C.useMemo(() => n && e ? Array.isArray(e) ? e : [e] : [], [e, n]), o = C.useMemo(() => Array.isArray(e) ? S4(e) : S4([e || ""]), [e]), a = C.useCallback((s) => {
      EEe(s).then((u) => {
        const c = u.map((f) => f.dataURL || null);
        t(n ? r.concat(...c) : c[0]);
      });
    }, [r, n, t]), i = C.useCallback((s) => {
      if (n) {
        const u = r.filter((c, f) => f !== s);
        t(u);
      } else
        t(void 0);
    }, [r, n, t]);
    return { filesInfo: o, handleChange: a, handleRemove: i };
  }
  function PEe(e) {
    if (!e)
      return "";
    const t = new Date(e), n = Us(t.getFullYear(), 4), r = Us(t.getMonth() + 1, 2), o = Us(t.getDate(), 2), a = Us(t.getHours(), 2), i = Us(t.getMinutes(), 2), s = Us(t.getSeconds(), 2), u = Us(t.getMilliseconds(), 3);
    return `${n}-${r}-${o}T${a}:${i}:${s}.${u}`;
  }
  function Ky(e, t, n = !1) {
    if (!t)
      return e;
    const { errors: r, errorSchema: o } = e;
    let a = dO(t), i = t;
    return Hn(o) || (i = Sm(o, t, n ? "preventDuplicates" : !0), a = [...r].concat(a)), { errorSchema: i, errors: a };
  }
  function OEe(e) {
    for (const t in e) {
      const n = e, r = n[t];
      t === yn && typeof r == "string" && r.startsWith("#") ? n[t] = oV + r : n[t] = fO(r);
    }
    return e;
  }
  function NEe(e) {
    for (let t = 0; t < e.length; t++)
      e[t] = fO(e[t]);
    return e;
  }
  function fO(e) {
    return Array.isArray(e) ? NEe([...e]) : jt(e) ? OEe({ ...e }) : e;
  }
  var ht;
  (function(e) {
    e.ArrayItemTitle = "Item", e.MissingItems = "Missing items definition", e.EmptyArray = "No items yet. Use the button below to add some.", e.YesLabel = "Yes", e.NoLabel = "No", e.CloseLabel = "Close", e.ErrorsLabel = "Errors", e.NewStringDefault = "New Value", e.AddButton = "Add", e.AddItemButton = "Add Item", e.CopyButton = "Copy", e.MoveDownButton = "Move down", e.MoveUpButton = "Move up", e.RemoveButton = "Remove", e.NowLabel = "Now", e.ClearLabel = "Clear", e.AriaDateLabel = "Select a date", e.PreviewLabel = "Preview", e.DecrementAriaLabel = "Decrease value by 1", e.IncrementAriaLabel = "Increase value by 1", e.OptionalObjectAdd = "Add data for optional field", e.OptionalObjectRemove = "Remove data for optional field", e.OptionalObjectEmptyMsg = "No data for optional field", e.Type = "Type", e.Value = "Value", e.UnknownFieldType = "Unknown field type %1", e.OptionPrefix = "Option %1", e.TitleOptionPrefix = "%1 option %2", e.KeyLabel = "%1 Key", e.InvalidObjectField = 'Invalid "%1" object field configuration: _%2_.', e.UnsupportedField = "Unsupported field schema.", e.UnsupportedFieldWithId = "Unsupported field schema for field `%1`.", e.UnsupportedFieldWithReason = "Unsupported field schema: _%1_.", e.UnsupportedFieldWithIdAndReason = "Unsupported field schema for field `%1`: _%2_.", e.FilesInfo = "**%1** (%2, %3 bytes)";
  })(ht || (ht = {}));
  function MEe(e, t) {
    var n = Yn(e) ? KP : l1;
    return n(e, kV(t));
  }
  var b0 = { exports: {} }, _4 = {}, Ni = {}, Vl = {}, E4 = {}, C4 = {}, P4 = {}, O4;
  function Tb() {
    return O4 || (O4 = 1, (function(e) {
      Object.defineProperty(e, "__esModule", { value: !0 }), e.regexpCode = e.getEsmExportName = e.getProperty = e.safeStringify = e.stringify = e.strConcat = e.addCodeArg = e.str = e._ = e.nil = e._Code = e.Name = e.IDENTIFIER = e._CodeOrName = void 0;
      class t {
      }
      e._CodeOrName = t, e.IDENTIFIER = /^[a-z$_][a-z$_0-9]*$/i;
      class n extends t {
        constructor(_) {
          if (super(), !e.IDENTIFIER.test(_))
            throw new Error("CodeGen: name must be a valid identifier");
          this.str = _;
        }
        toString() {
          return this.str;
        }
        emptyStr() {
          return !1;
        }
        get names() {
          return { [this.str]: 1 };
        }
      }
      e.Name = n;
      class r extends t {
        constructor(_) {
          super(), this._items = typeof _ == "string" ? [_] : _;
        }
        toString() {
          return this.str;
        }
        emptyStr() {
          if (this._items.length > 1)
            return !1;
          const _ = this._items[0];
          return _ === "" || _ === '""';
        }
        get str() {
          var _;
          return (_ = this._str) !== null && _ !== void 0 ? _ : this._str = this._items.reduce((k, E) => `${k}${E}`, "");
        }
        get names() {
          var _;
          return (_ = this._names) !== null && _ !== void 0 ? _ : this._names = this._items.reduce((k, E) => (E instanceof n && (k[E.str] = (k[E.str] || 0) + 1), k), {});
        }
      }
      e._Code = r, e.nil = new r("");
      function o(w, ..._) {
        const k = [w[0]];
        let E = 0;
        for (; E < _.length; )
          s(k, _[E]), k.push(w[++E]);
        return new r(k);
      }
      e._ = o;
      const a = new r("+");
      function i(w, ..._) {
        const k = [h(w[0])];
        let E = 0;
        for (; E < _.length; )
          k.push(a), s(k, _[E]), k.push(a, h(w[++E]));
        return u(k), new r(k);
      }
      e.str = i;
      function s(w, _) {
        _ instanceof r ? w.push(..._._items) : _ instanceof n ? w.push(_) : w.push(p(_));
      }
      e.addCodeArg = s;
      function u(w) {
        let _ = 1;
        for (; _ < w.length - 1; ) {
          if (w[_] === a) {
            const k = c(w[_ - 1], w[_ + 1]);
            if (k !== void 0) {
              w.splice(_ - 1, 3, k);
              continue;
            }
            w[_++] = "+";
          }
          _++;
        }
      }
      function c(w, _) {
        if (_ === '""')
          return w;
        if (w === '""')
          return _;
        if (typeof w == "string")
          return _ instanceof n || w[w.length - 1] !== '"' ? void 0 : typeof _ != "string" ? `${w.slice(0, -1)}${_}"` : _[0] === '"' ? w.slice(0, -1) + _.slice(1) : void 0;
        if (typeof _ == "string" && _[0] === '"' && !(w instanceof n))
          return `"${w}${_.slice(1)}`;
      }
      function f(w, _) {
        return _.emptyStr() ? w : w.emptyStr() ? _ : i`${w}${_}`;
      }
      e.strConcat = f;
      function p(w) {
        return typeof w == "number" || typeof w == "boolean" || w === null ? w : h(Array.isArray(w) ? w.join(",") : w);
      }
      function g(w) {
        return new r(h(w));
      }
      e.stringify = g;
      function h(w) {
        return JSON.stringify(w).replace(/\u2028/g, "\\u2028").replace(/\u2029/g, "\\u2029");
      }
      e.safeStringify = h;
      function y(w) {
        return typeof w == "string" && e.IDENTIFIER.test(w) ? new r(`.${w}`) : o`[${w}]`;
      }
      e.getProperty = y;
      function b(w) {
        if (typeof w == "string" && e.IDENTIFIER.test(w))
          return new r(`${w}`);
        throw new Error(`CodeGen: invalid export name: ${w}, use explicit $id name mapping`);
      }
      e.getEsmExportName = b;
      function v(w) {
        return new r(w.toString());
      }
      e.regexpCode = v;
    })(P4)), P4;
  }
  var N4 = {}, M4;
  function R4() {
    return M4 || (M4 = 1, (function(e) {
      Object.defineProperty(e, "__esModule", { value: !0 }), e.ValueScope = e.ValueScopeName = e.Scope = e.varKinds = e.UsedValueState = void 0;
      const t = Tb();
      class n extends Error {
        constructor(c) {
          super(`CodeGen: "code" for ${c} not defined`), this.value = c.value;
        }
      }
      var r;
      (function(u) {
        u[u.Started = 0] = "Started", u[u.Completed = 1] = "Completed";
      })(r || (e.UsedValueState = r = {})), e.varKinds = {
        const: new t.Name("const"),
        let: new t.Name("let"),
        var: new t.Name("var")
      };
      class o {
        constructor({ prefixes: c, parent: f } = {}) {
          this._names = {}, this._prefixes = c, this._parent = f;
        }
        toName(c) {
          return c instanceof t.Name ? c : this.name(c);
        }
        name(c) {
          return new t.Name(this._newName(c));
        }
        _newName(c) {
          const f = this._names[c] || this._nameGroup(c);
          return `${c}${f.index++}`;
        }
        _nameGroup(c) {
          var f, p;
          if (!((p = (f = this._parent) === null || f === void 0 ? void 0 : f._prefixes) === null || p === void 0) && p.has(c) || this._prefixes && !this._prefixes.has(c))
            throw new Error(`CodeGen: prefix "${c}" is not allowed in this scope`);
          return this._names[c] = { prefix: c, index: 0 };
        }
      }
      e.Scope = o;
      class a extends t.Name {
        constructor(c, f) {
          super(f), this.prefix = c;
        }
        setValue(c, { property: f, itemIndex: p }) {
          this.value = c, this.scopePath = (0, t._)`.${new t.Name(f)}[${p}]`;
        }
      }
      e.ValueScopeName = a;
      const i = (0, t._)`\n`;
      class s extends o {
        constructor(c) {
          super(c), this._values = {}, this._scope = c.scope, this.opts = { ...c, _n: c.lines ? i : t.nil };
        }
        get() {
          return this._scope;
        }
        name(c) {
          return new a(c, this._newName(c));
        }
        value(c, f) {
          var p;
          if (f.ref === void 0)
            throw new Error("CodeGen: ref must be passed in value");
          const g = this.toName(c), { prefix: h } = g, y = (p = f.key) !== null && p !== void 0 ? p : f.ref;
          let b = this._values[h];
          if (b) {
            const _ = b.get(y);
            if (_)
              return _;
          } else
            b = this._values[h] = /* @__PURE__ */ new Map();
          b.set(y, g);
          const v = this._scope[h] || (this._scope[h] = []), w = v.length;
          return v[w] = f.ref, g.setValue(f, { property: h, itemIndex: w }), g;
        }
        getValue(c, f) {
          const p = this._values[c];
          if (p)
            return p.get(f);
        }
        scopeRefs(c, f = this._values) {
          return this._reduceValues(f, (p) => {
            if (p.scopePath === void 0)
              throw new Error(`CodeGen: name "${p}" has no value`);
            return (0, t._)`${c}${p.scopePath}`;
          });
        }
        scopeCode(c = this._values, f, p) {
          return this._reduceValues(c, (g) => {
            if (g.value === void 0)
              throw new Error(`CodeGen: name "${g}" has no value`);
            return g.value.code;
          }, f, p);
        }
        _reduceValues(c, f, p = {}, g) {
          let h = t.nil;
          for (const y in c) {
            const b = c[y];
            if (!b)
              continue;
            const v = p[y] = p[y] || /* @__PURE__ */ new Map();
            b.forEach((w) => {
              if (v.has(w))
                return;
              v.set(w, r.Started);
              let _ = f(w);
              if (_) {
                const k = this.opts.es5 ? e.varKinds.var : e.varKinds.const;
                h = (0, t._)`${h}${k} ${w} = ${_};${this.opts._n}`;
              } else if (_ = g?.(w))
                h = (0, t._)`${h}${_}${this.opts._n}`;
              else
                throw new n(w);
              v.set(w, r.Completed);
            });
          }
          return h;
        }
      }
      e.ValueScope = s;
    })(N4)), N4;
  }
  var j4;
  function mt() {
    return j4 || (j4 = 1, (function(e) {
      Object.defineProperty(e, "__esModule", { value: !0 }), e.or = e.and = e.not = e.CodeGen = e.operators = e.varKinds = e.ValueScopeName = e.ValueScope = e.Scope = e.Name = e.regexpCode = e.stringify = e.getProperty = e.nil = e.strConcat = e.str = e._ = void 0;
      const t = Tb(), n = R4();
      var r = Tb();
      Object.defineProperty(e, "_", { enumerable: !0, get: function() {
        return r._;
      } }), Object.defineProperty(e, "str", { enumerable: !0, get: function() {
        return r.str;
      } }), Object.defineProperty(e, "strConcat", { enumerable: !0, get: function() {
        return r.strConcat;
      } }), Object.defineProperty(e, "nil", { enumerable: !0, get: function() {
        return r.nil;
      } }), Object.defineProperty(e, "getProperty", { enumerable: !0, get: function() {
        return r.getProperty;
      } }), Object.defineProperty(e, "stringify", { enumerable: !0, get: function() {
        return r.stringify;
      } }), Object.defineProperty(e, "regexpCode", { enumerable: !0, get: function() {
        return r.regexpCode;
      } }), Object.defineProperty(e, "Name", { enumerable: !0, get: function() {
        return r.Name;
      } });
      var o = R4();
      Object.defineProperty(e, "Scope", { enumerable: !0, get: function() {
        return o.Scope;
      } }), Object.defineProperty(e, "ValueScope", { enumerable: !0, get: function() {
        return o.ValueScope;
      } }), Object.defineProperty(e, "ValueScopeName", { enumerable: !0, get: function() {
        return o.ValueScopeName;
      } }), Object.defineProperty(e, "varKinds", { enumerable: !0, get: function() {
        return o.varKinds;
      } }), e.operators = {
        GT: new t._Code(">"),
        GTE: new t._Code(">="),
        LT: new t._Code("<"),
        LTE: new t._Code("<="),
        EQ: new t._Code("==="),
        NEQ: new t._Code("!=="),
        NOT: new t._Code("!"),
        OR: new t._Code("||"),
        AND: new t._Code("&&"),
        ADD: new t._Code("+")
      };
      class a {
        optimizeNodes() {
          return this;
        }
        optimizeNames(V, X) {
          return this;
        }
      }
      class i extends a {
        constructor(V, X, Q) {
          super(), this.varKind = V, this.name = X, this.rhs = Q;
        }
        render({ es5: V, _n: X }) {
          const Q = V ? n.varKinds.var : this.varKind, ne = this.rhs === void 0 ? "" : ` = ${this.rhs}`;
          return `${Q} ${this.name}${ne};` + X;
        }
        optimizeNames(V, X) {
          if (V[this.name.str])
            return this.rhs && (this.rhs = $(this.rhs, V, X)), this;
        }
        get names() {
          return this.rhs instanceof t._CodeOrName ? this.rhs.names : {};
        }
      }
      class s extends a {
        constructor(V, X, Q) {
          super(), this.lhs = V, this.rhs = X, this.sideEffects = Q;
        }
        render({ _n: V }) {
          return `${this.lhs} = ${this.rhs};` + V;
        }
        optimizeNames(V, X) {
          if (!(this.lhs instanceof t.Name && !V[this.lhs.str] && !this.sideEffects))
            return this.rhs = $(this.rhs, V, X), this;
        }
        get names() {
          const V = this.lhs instanceof t.Name ? {} : { ...this.lhs.names };
          return U(V, this.rhs);
        }
      }
      class u extends s {
        constructor(V, X, Q, ne) {
          super(V, Q, ne), this.op = X;
        }
        render({ _n: V }) {
          return `${this.lhs} ${this.op}= ${this.rhs};` + V;
        }
      }
      class c extends a {
        constructor(V) {
          super(), this.label = V, this.names = {};
        }
        render({ _n: V }) {
          return `${this.label}:` + V;
        }
      }
      class f extends a {
        constructor(V) {
          super(), this.label = V, this.names = {};
        }
        render({ _n: V }) {
          return `break${this.label ? ` ${this.label}` : ""};` + V;
        }
      }
      class p extends a {
        constructor(V) {
          super(), this.error = V;
        }
        render({ _n: V }) {
          return `throw ${this.error};` + V;
        }
        get names() {
          return this.error.names;
        }
      }
      class g extends a {
        constructor(V) {
          super(), this.code = V;
        }
        render({ _n: V }) {
          return `${this.code};` + V;
        }
        optimizeNodes() {
          return `${this.code}` ? this : void 0;
        }
        optimizeNames(V, X) {
          return this.code = $(this.code, V, X), this;
        }
        get names() {
          return this.code instanceof t._CodeOrName ? this.code.names : {};
        }
      }
      class h extends a {
        constructor(V = []) {
          super(), this.nodes = V;
        }
        render(V) {
          return this.nodes.reduce((X, Q) => X + Q.render(V), "");
        }
        optimizeNodes() {
          const { nodes: V } = this;
          let X = V.length;
          for (; X--; ) {
            const Q = V[X].optimizeNodes();
            Array.isArray(Q) ? V.splice(X, 1, ...Q) : Q ? V[X] = Q : V.splice(X, 1);
          }
          return V.length > 0 ? this : void 0;
        }
        optimizeNames(V, X) {
          const { nodes: Q } = this;
          let ne = Q.length;
          for (; ne--; ) {
            const te = Q[ne];
            te.optimizeNames(V, X) || (q(V, te.names), Q.splice(ne, 1));
          }
          return Q.length > 0 ? this : void 0;
        }
        get names() {
          return this.nodes.reduce((V, X) => j(V, X.names), {});
        }
      }
      class y extends h {
        render(V) {
          return "{" + V._n + super.render(V) + "}" + V._n;
        }
      }
      class b extends h {
      }
      class v extends y {
      }
      v.kind = "else";
      class w extends y {
        constructor(V, X) {
          super(X), this.condition = V;
        }
        render(V) {
          let X = `if(${this.condition})` + super.render(V);
          return this.else && (X += "else " + this.else.render(V)), X;
        }
        optimizeNodes() {
          super.optimizeNodes();
          const V = this.condition;
          if (V === !0)
            return this.nodes;
          let X = this.else;
          if (X) {
            const Q = X.optimizeNodes();
            X = this.else = Array.isArray(Q) ? new v(Q) : Q;
          }
          if (X)
            return V === !1 ? X instanceof w ? X : X.nodes : this.nodes.length ? this : new w(B(V), X instanceof w ? [X] : X.nodes);
          if (!(V === !1 || !this.nodes.length))
            return this;
        }
        optimizeNames(V, X) {
          var Q;
          if (this.else = (Q = this.else) === null || Q === void 0 ? void 0 : Q.optimizeNames(V, X), !!(super.optimizeNames(V, X) || this.else))
            return this.condition = $(this.condition, V, X), this;
        }
        get names() {
          const V = super.names;
          return U(V, this.condition), this.else && j(V, this.else.names), V;
        }
      }
      w.kind = "if";
      class _ extends y {
      }
      _.kind = "for";
      class k extends _ {
        constructor(V) {
          super(), this.iteration = V;
        }
        render(V) {
          return `for(${this.iteration})` + super.render(V);
        }
        optimizeNames(V, X) {
          if (super.optimizeNames(V, X))
            return this.iteration = $(this.iteration, V, X), this;
        }
        get names() {
          return j(super.names, this.iteration.names);
        }
      }
      class E extends _ {
        constructor(V, X, Q, ne) {
          super(), this.varKind = V, this.name = X, this.from = Q, this.to = ne;
        }
        render(V) {
          const X = V.es5 ? n.varKinds.var : this.varKind, { name: Q, from: ne, to: te } = this;
          return `for(${X} ${Q}=${ne}; ${Q}<${te}; ${Q}++)` + super.render(V);
        }
        get names() {
          const V = U(super.names, this.from);
          return U(V, this.to);
        }
      }
      class P extends _ {
        constructor(V, X, Q, ne) {
          super(), this.loop = V, this.varKind = X, this.name = Q, this.iterable = ne;
        }
        render(V) {
          return `for(${this.varKind} ${this.name} ${this.loop} ${this.iterable})` + super.render(V);
        }
        optimizeNames(V, X) {
          if (super.optimizeNames(V, X))
            return this.iterable = $(this.iterable, V, X), this;
        }
        get names() {
          return j(super.names, this.iterable.names);
        }
      }
      class O extends y {
        constructor(V, X, Q) {
          super(), this.name = V, this.args = X, this.async = Q;
        }
        render(V) {
          return `${this.async ? "async " : ""}function ${this.name}(${this.args})` + super.render(V);
        }
      }
      O.kind = "func";
      class M extends h {
        render(V) {
          return "return " + super.render(V);
        }
      }
      M.kind = "return";
      class I extends y {
        render(V) {
          let X = "try" + super.render(V);
          return this.catch && (X += this.catch.render(V)), this.finally && (X += this.finally.render(V)), X;
        }
        optimizeNodes() {
          var V, X;
          return super.optimizeNodes(), (V = this.catch) === null || V === void 0 || V.optimizeNodes(), (X = this.finally) === null || X === void 0 || X.optimizeNodes(), this;
        }
        optimizeNames(V, X) {
          var Q, ne;
          return super.optimizeNames(V, X), (Q = this.catch) === null || Q === void 0 || Q.optimizeNames(V, X), (ne = this.finally) === null || ne === void 0 || ne.optimizeNames(V, X), this;
        }
        get names() {
          const V = super.names;
          return this.catch && j(V, this.catch.names), this.finally && j(V, this.finally.names), V;
        }
      }
      class A extends y {
        constructor(V) {
          super(), this.error = V;
        }
        render(V) {
          return `catch(${this.error})` + super.render(V);
        }
      }
      A.kind = "catch";
      class D extends y {
        render(V) {
          return "finally" + super.render(V);
        }
      }
      D.kind = "finally";
      class F {
        constructor(V, X = {}) {
          this._values = {}, this._blockStarts = [], this._constants = {}, this.opts = { ...X, _n: X.lines ? `
` : "" }, this._extScope = V, this._scope = new n.Scope({ parent: V }), this._nodes = [new b()];
        }
        toString() {
          return this._root.render(this.opts);
        }
        // returns unique name in the internal scope
        name(V) {
          return this._scope.name(V);
        }
        // reserves unique name in the external scope
        scopeName(V) {
          return this._extScope.name(V);
        }
        // reserves unique name in the external scope and assigns value to it
        scopeValue(V, X) {
          const Q = this._extScope.value(V, X);
          return (this._values[Q.prefix] || (this._values[Q.prefix] = /* @__PURE__ */ new Set())).add(Q), Q;
        }
        getScopeValue(V, X) {
          return this._extScope.getValue(V, X);
        }
        // return code that assigns values in the external scope to the names that are used internally
        // (same names that were returned by gen.scopeName or gen.scopeValue)
        scopeRefs(V) {
          return this._extScope.scopeRefs(V, this._values);
        }
        scopeCode() {
          return this._extScope.scopeCode(this._values);
        }
        _def(V, X, Q, ne) {
          const te = this._scope.toName(X);
          return Q !== void 0 && ne && (this._constants[te.str] = Q), this._leafNode(new i(V, te, Q)), te;
        }
        // `const` declaration (`var` in es5 mode)
        const(V, X, Q) {
          return this._def(n.varKinds.const, V, X, Q);
        }
        // `let` declaration with optional assignment (`var` in es5 mode)
        let(V, X, Q) {
          return this._def(n.varKinds.let, V, X, Q);
        }
        // `var` declaration with optional assignment
        var(V, X, Q) {
          return this._def(n.varKinds.var, V, X, Q);
        }
        // assignment code
        assign(V, X, Q) {
          return this._leafNode(new s(V, X, Q));
        }
        // `+=` code
        add(V, X) {
          return this._leafNode(new u(V, e.operators.ADD, X));
        }
        // appends passed SafeExpr to code or executes Block
        code(V) {
          return typeof V == "function" ? V() : V !== t.nil && this._leafNode(new g(V)), this;
        }
        // returns code for object literal for the passed argument list of key-value pairs
        object(...V) {
          const X = ["{"];
          for (const [Q, ne] of V)
            X.length > 1 && X.push(","), X.push(Q), (Q !== ne || this.opts.es5) && (X.push(":"), (0, t.addCodeArg)(X, ne));
          return X.push("}"), new t._Code(X);
        }
        // `if` clause (or statement if `thenBody` and, optionally, `elseBody` are passed)
        if(V, X, Q) {
          if (this._blockNode(new w(V)), X && Q)
            this.code(X).else().code(Q).endIf();
          else if (X)
            this.code(X).endIf();
          else if (Q)
            throw new Error('CodeGen: "else" body without "then" body');
          return this;
        }
        // `else if` clause - invalid without `if` or after `else` clauses
        elseIf(V) {
          return this._elseNode(new w(V));
        }
        // `else` clause - only valid after `if` or `else if` clauses
        else() {
          return this._elseNode(new v());
        }
        // end `if` statement (needed if gen.if was used only with condition)
        endIf() {
          return this._endBlockNode(w, v);
        }
        _for(V, X) {
          return this._blockNode(V), X && this.code(X).endFor(), this;
        }
        // a generic `for` clause (or statement if `forBody` is passed)
        for(V, X) {
          return this._for(new k(V), X);
        }
        // `for` statement for a range of values
        forRange(V, X, Q, ne, te = this.opts.es5 ? n.varKinds.var : n.varKinds.let) {
          const ae = this._scope.toName(V);
          return this._for(new E(te, ae, X, Q), () => ne(ae));
        }
        // `for-of` statement (in es5 mode replace with a normal for loop)
        forOf(V, X, Q, ne = n.varKinds.const) {
          const te = this._scope.toName(V);
          if (this.opts.es5) {
            const ae = X instanceof t.Name ? X : this.var("_arr", X);
            return this.forRange("_i", 0, (0, t._)`${ae}.length`, (ce) => {
              this.var(te, (0, t._)`${ae}[${ce}]`), Q(te);
            });
          }
          return this._for(new P("of", ne, te, X), () => Q(te));
        }
        // `for-in` statement.
        // With option `ownProperties` replaced with a `for-of` loop for object keys
        forIn(V, X, Q, ne = this.opts.es5 ? n.varKinds.var : n.varKinds.const) {
          if (this.opts.ownProperties)
            return this.forOf(V, (0, t._)`Object.keys(${X})`, Q);
          const te = this._scope.toName(V);
          return this._for(new P("in", ne, te, X), () => Q(te));
        }
        // end `for` loop
        endFor() {
          return this._endBlockNode(_);
        }
        // `label` statement
        label(V) {
          return this._leafNode(new c(V));
        }
        // `break` statement
        break(V) {
          return this._leafNode(new f(V));
        }
        // `return` statement
        return(V) {
          const X = new M();
          if (this._blockNode(X), this.code(V), X.nodes.length !== 1)
            throw new Error('CodeGen: "return" should have one node');
          return this._endBlockNode(M);
        }
        // `try` statement
        try(V, X, Q) {
          if (!X && !Q)
            throw new Error('CodeGen: "try" without "catch" and "finally"');
          const ne = new I();
          if (this._blockNode(ne), this.code(V), X) {
            const te = this.name("e");
            this._currNode = ne.catch = new A(te), X(te);
          }
          return Q && (this._currNode = ne.finally = new D(), this.code(Q)), this._endBlockNode(A, D);
        }
        // `throw` statement
        throw(V) {
          return this._leafNode(new p(V));
        }
        // start self-balancing block
        block(V, X) {
          return this._blockStarts.push(this._nodes.length), V && this.code(V).endBlock(X), this;
        }
        // end the current self-balancing block
        endBlock(V) {
          const X = this._blockStarts.pop();
          if (X === void 0)
            throw new Error("CodeGen: not in self-balancing block");
          const Q = this._nodes.length - X;
          if (Q < 0 || V !== void 0 && Q !== V)
            throw new Error(`CodeGen: wrong number of nodes: ${Q} vs ${V} expected`);
          return this._nodes.length = X, this;
        }
        // `function` heading (or definition if funcBody is passed)
        func(V, X = t.nil, Q, ne) {
          return this._blockNode(new O(V, X, Q)), ne && this.code(ne).endFunc(), this;
        }
        // end function definition
        endFunc() {
          return this._endBlockNode(O);
        }
        optimize(V = 1) {
          for (; V-- > 0; )
            this._root.optimizeNodes(), this._root.optimizeNames(this._root.names, this._constants);
        }
        _leafNode(V) {
          return this._currNode.nodes.push(V), this;
        }
        _blockNode(V) {
          this._currNode.nodes.push(V), this._nodes.push(V);
        }
        _endBlockNode(V, X) {
          const Q = this._currNode;
          if (Q instanceof V || X && Q instanceof X)
            return this._nodes.pop(), this;
          throw new Error(`CodeGen: not in block "${X ? `${V.kind}/${X.kind}` : V.kind}"`);
        }
        _elseNode(V) {
          const X = this._currNode;
          if (!(X instanceof w))
            throw new Error('CodeGen: "else" without "if"');
          return this._currNode = X.else = V, this;
        }
        get _root() {
          return this._nodes[0];
        }
        get _currNode() {
          const V = this._nodes;
          return V[V.length - 1];
        }
        set _currNode(V) {
          const X = this._nodes;
          X[X.length - 1] = V;
        }
      }
      e.CodeGen = F;
      function j(T, V) {
        for (const X in V)
          T[X] = (T[X] || 0) + (V[X] || 0);
        return T;
      }
      function U(T, V) {
        return V instanceof t._CodeOrName ? j(T, V.names) : T;
      }
      function $(T, V, X) {
        if (T instanceof t.Name)
          return Q(T);
        if (!ne(T))
          return T;
        return new t._Code(T._items.reduce((te, ae) => (ae instanceof t.Name && (ae = Q(ae)), ae instanceof t._Code ? te.push(...ae._items) : te.push(ae), te), []));
        function Q(te) {
          const ae = X[te.str];
          return ae === void 0 || V[te.str] !== 1 ? te : (delete V[te.str], ae);
        }
        function ne(te) {
          return te instanceof t._Code && te._items.some((ae) => ae instanceof t.Name && V[ae.str] === 1 && X[ae.str] !== void 0);
        }
      }
      function q(T, V) {
        for (const X in V)
          T[X] = (T[X] || 0) - (V[X] || 0);
      }
      function B(T) {
        return typeof T == "boolean" || typeof T == "number" || T === null ? !T : (0, t._)`!${K(T)}`;
      }
      e.not = B;
      const G = L(e.operators.AND);
      function W(...T) {
        return T.reduce(G);
      }
      e.and = W;
      const Y = L(e.operators.OR);
      function z(...T) {
        return T.reduce(Y);
      }
      e.or = z;
      function L(T) {
        return (V, X) => V === t.nil ? X : X === t.nil ? V : (0, t._)`${K(V)} ${T} ${K(X)}`;
      }
      function K(T) {
        return T instanceof t.Name ? T : (0, t._)`(${T})`;
      }
    })(C4)), C4;
  }
  var ft = {}, I4;
  function Ft() {
    if (I4) return ft;
    I4 = 1, Object.defineProperty(ft, "__esModule", { value: !0 }), ft.checkStrictMode = ft.getErrorPath = ft.Type = ft.useFunc = ft.setEvaluated = ft.evaluatedPropsToName = ft.mergeEvaluated = ft.eachItem = ft.unescapeJsonPointer = ft.escapeJsonPointer = ft.escapeFragment = ft.unescapeFragment = ft.schemaRefOrVal = ft.schemaHasRulesButRef = ft.schemaHasRules = ft.checkUnknownRules = ft.alwaysValidSchema = ft.toHash = void 0;
    const e = mt(), t = Tb();
    function n(P) {
      const O = {};
      for (const M of P)
        O[M] = !0;
      return O;
    }
    ft.toHash = n;
    function r(P, O) {
      return typeof O == "boolean" ? O : Object.keys(O).length === 0 ? !0 : (o(P, O), !a(O, P.self.RULES.all));
    }
    ft.alwaysValidSchema = r;
    function o(P, O = P.schema) {
      const { opts: M, self: I } = P;
      if (!M.strictSchema || typeof O == "boolean")
        return;
      const A = I.RULES.keywords;
      for (const D in O)
        A[D] || E(P, `unknown keyword: "${D}"`);
    }
    ft.checkUnknownRules = o;
    function a(P, O) {
      if (typeof P == "boolean")
        return !P;
      for (const M in P)
        if (O[M])
          return !0;
      return !1;
    }
    ft.schemaHasRules = a;
    function i(P, O) {
      if (typeof P == "boolean")
        return !P;
      for (const M in P)
        if (M !== "$ref" && O.all[M])
          return !0;
      return !1;
    }
    ft.schemaHasRulesButRef = i;
    function s({ topSchemaRef: P, schemaPath: O }, M, I, A) {
      if (!A) {
        if (typeof M == "number" || typeof M == "boolean")
          return M;
        if (typeof M == "string")
          return (0, e._)`${M}`;
      }
      return (0, e._)`${P}${O}${(0, e.getProperty)(I)}`;
    }
    ft.schemaRefOrVal = s;
    function u(P) {
      return p(decodeURIComponent(P));
    }
    ft.unescapeFragment = u;
    function c(P) {
      return encodeURIComponent(f(P));
    }
    ft.escapeFragment = c;
    function f(P) {
      return typeof P == "number" ? `${P}` : P.replace(/~/g, "~0").replace(/\//g, "~1");
    }
    ft.escapeJsonPointer = f;
    function p(P) {
      return P.replace(/~1/g, "/").replace(/~0/g, "~");
    }
    ft.unescapeJsonPointer = p;
    function g(P, O) {
      if (Array.isArray(P))
        for (const M of P)
          O(M);
      else
        O(P);
    }
    ft.eachItem = g;
    function h({ mergeNames: P, mergeToName: O, mergeValues: M, resultToName: I }) {
      return (A, D, F, j) => {
        const U = F === void 0 ? D : F instanceof e.Name ? (D instanceof e.Name ? P(A, D, F) : O(A, D, F), F) : D instanceof e.Name ? (O(A, F, D), D) : M(D, F);
        return j === e.Name && !(U instanceof e.Name) ? I(A, U) : U;
      };
    }
    ft.mergeEvaluated = {
      props: h({
        mergeNames: (P, O, M) => P.if((0, e._)`${M} !== true && ${O} !== undefined`, () => {
          P.if((0, e._)`${O} === true`, () => P.assign(M, !0), () => P.assign(M, (0, e._)`${M} || {}`).code((0, e._)`Object.assign(${M}, ${O})`));
        }),
        mergeToName: (P, O, M) => P.if((0, e._)`${M} !== true`, () => {
          O === !0 ? P.assign(M, !0) : (P.assign(M, (0, e._)`${M} || {}`), b(P, M, O));
        }),
        mergeValues: (P, O) => P === !0 ? !0 : { ...P, ...O },
        resultToName: y
      }),
      items: h({
        mergeNames: (P, O, M) => P.if((0, e._)`${M} !== true && ${O} !== undefined`, () => P.assign(M, (0, e._)`${O} === true ? true : ${M} > ${O} ? ${M} : ${O}`)),
        mergeToName: (P, O, M) => P.if((0, e._)`${M} !== true`, () => P.assign(M, O === !0 ? !0 : (0, e._)`${M} > ${O} ? ${M} : ${O}`)),
        mergeValues: (P, O) => P === !0 ? !0 : Math.max(P, O),
        resultToName: (P, O) => P.var("items", O)
      })
    };
    function y(P, O) {
      if (O === !0)
        return P.var("props", !0);
      const M = P.var("props", (0, e._)`{}`);
      return O !== void 0 && b(P, M, O), M;
    }
    ft.evaluatedPropsToName = y;
    function b(P, O, M) {
      Object.keys(M).forEach((I) => P.assign((0, e._)`${O}${(0, e.getProperty)(I)}`, !0));
    }
    ft.setEvaluated = b;
    const v = {};
    function w(P, O) {
      return P.scopeValue("func", {
        ref: O,
        code: v[O.code] || (v[O.code] = new t._Code(O.code))
      });
    }
    ft.useFunc = w;
    var _;
    (function(P) {
      P[P.Num = 0] = "Num", P[P.Str = 1] = "Str";
    })(_ || (ft.Type = _ = {}));
    function k(P, O, M) {
      if (P instanceof e.Name) {
        const I = O === _.Num;
        return M ? I ? (0, e._)`"[" + ${P} + "]"` : (0, e._)`"['" + ${P} + "']"` : I ? (0, e._)`"/" + ${P}` : (0, e._)`"/" + ${P}.replace(/~/g, "~0").replace(/\\//g, "~1")`;
      }
      return M ? (0, e.getProperty)(P).toString() : "/" + f(P);
    }
    ft.getErrorPath = k;
    function E(P, O, M = P.opts.strictSchema) {
      if (M) {
        if (O = `strict mode: ${O}`, M === !0)
          throw new Error(O);
        P.self.logger.warn(O);
      }
    }
    return ft.checkStrictMode = E, ft;
  }
  var Ev = {}, A4;
  function gl() {
    if (A4) return Ev;
    A4 = 1, Object.defineProperty(Ev, "__esModule", { value: !0 });
    const e = mt(), t = {
      // validation function arguments
      data: new e.Name("data"),
      // data passed to validation function
      // args passed from referencing schema
      valCxt: new e.Name("valCxt"),
      // validation/data context - should not be used directly, it is destructured to the names below
      instancePath: new e.Name("instancePath"),
      parentData: new e.Name("parentData"),
      parentDataProperty: new e.Name("parentDataProperty"),
      rootData: new e.Name("rootData"),
      // root data - same as the data passed to the first/top validation function
      dynamicAnchors: new e.Name("dynamicAnchors"),
      // used to support recursiveRef and dynamicRef
      // function scoped variables
      vErrors: new e.Name("vErrors"),
      // null or array of validation errors
      errors: new e.Name("errors"),
      // counter of validation errors
      this: new e.Name("this"),
      // "globals"
      self: new e.Name("self"),
      scope: new e.Name("scope"),
      // JTD serialize/parse name for JSON string and position
      json: new e.Name("json"),
      jsonPos: new e.Name("jsonPos"),
      jsonLen: new e.Name("jsonLen"),
      jsonPart: new e.Name("jsonPart")
    };
    return Ev.default = t, Ev;
  }
  var $4;
  function wx() {
    return $4 || ($4 = 1, (function(e) {
      Object.defineProperty(e, "__esModule", { value: !0 }), e.extendErrors = e.resetErrorsCount = e.reportExtraError = e.reportError = e.keyword$DataError = e.keywordError = void 0;
      const t = mt(), n = Ft(), r = gl();
      e.keywordError = {
        message: ({ keyword: v }) => (0, t.str)`must pass "${v}" keyword validation`
      }, e.keyword$DataError = {
        message: ({ keyword: v, schemaType: w }) => w ? (0, t.str)`"${v}" keyword must be ${w} ($data)` : (0, t.str)`"${v}" keyword is invalid ($data)`
      };
      function o(v, w = e.keywordError, _, k) {
        const { it: E } = v, { gen: P, compositeRule: O, allErrors: M } = E, I = p(v, w, _);
        k ?? (O || M) ? u(P, I) : c(E, (0, t._)`[${I}]`);
      }
      e.reportError = o;
      function a(v, w = e.keywordError, _) {
        const { it: k } = v, { gen: E, compositeRule: P, allErrors: O } = k, M = p(v, w, _);
        u(E, M), P || O || c(k, r.default.vErrors);
      }
      e.reportExtraError = a;
      function i(v, w) {
        v.assign(r.default.errors, w), v.if((0, t._)`${r.default.vErrors} !== null`, () => v.if(w, () => v.assign((0, t._)`${r.default.vErrors}.length`, w), () => v.assign(r.default.vErrors, null)));
      }
      e.resetErrorsCount = i;
      function s({ gen: v, keyword: w, schemaValue: _, data: k, errsCount: E, it: P }) {
        if (E === void 0)
          throw new Error("ajv implementation error");
        const O = v.name("err");
        v.forRange("i", E, r.default.errors, (M) => {
          v.const(O, (0, t._)`${r.default.vErrors}[${M}]`), v.if((0, t._)`${O}.instancePath === undefined`, () => v.assign((0, t._)`${O}.instancePath`, (0, t.strConcat)(r.default.instancePath, P.errorPath))), v.assign((0, t._)`${O}.schemaPath`, (0, t.str)`${P.errSchemaPath}/${w}`), P.opts.verbose && (v.assign((0, t._)`${O}.schema`, _), v.assign((0, t._)`${O}.data`, k));
        });
      }
      e.extendErrors = s;
      function u(v, w) {
        const _ = v.const("err", w);
        v.if((0, t._)`${r.default.vErrors} === null`, () => v.assign(r.default.vErrors, (0, t._)`[${_}]`), (0, t._)`${r.default.vErrors}.push(${_})`), v.code((0, t._)`${r.default.errors}++`);
      }
      function c(v, w) {
        const { gen: _, validateName: k, schemaEnv: E } = v;
        E.$async ? _.throw((0, t._)`new ${v.ValidationError}(${w})`) : (_.assign((0, t._)`${k}.errors`, w), _.return(!1));
      }
      const f = {
        keyword: new t.Name("keyword"),
        schemaPath: new t.Name("schemaPath"),
        // also used in JTD errors
        params: new t.Name("params"),
        propertyName: new t.Name("propertyName"),
        message: new t.Name("message"),
        schema: new t.Name("schema"),
        parentSchema: new t.Name("parentSchema")
      };
      function p(v, w, _) {
        const { createErrors: k } = v.it;
        return k === !1 ? (0, t._)`{}` : g(v, w, _);
      }
      function g(v, w, _ = {}) {
        const { gen: k, it: E } = v, P = [
          h(E, _),
          y(v, _)
        ];
        return b(v, w, P), k.object(...P);
      }
      function h({ errorPath: v }, { instancePath: w }) {
        const _ = w ? (0, t.str)`${v}${(0, n.getErrorPath)(w, n.Type.Str)}` : v;
        return [r.default.instancePath, (0, t.strConcat)(r.default.instancePath, _)];
      }
      function y({ keyword: v, it: { errSchemaPath: w } }, { schemaPath: _, parentSchema: k }) {
        let E = k ? w : (0, t.str)`${w}/${v}`;
        return _ && (E = (0, t.str)`${E}${(0, n.getErrorPath)(_, n.Type.Str)}`), [f.schemaPath, E];
      }
      function b(v, { params: w, message: _ }, k) {
        const { keyword: E, data: P, schemaValue: O, it: M } = v, { opts: I, propertyName: A, topSchemaRef: D, schemaPath: F } = M;
        k.push([f.keyword, E], [f.params, typeof w == "function" ? w(v) : w || (0, t._)`{}`]), I.messages && k.push([f.message, typeof _ == "function" ? _(v) : _]), I.verbose && k.push([f.schema, O], [f.parentSchema, (0, t._)`${D}${F}`], [r.default.data, P]), A && k.push([f.propertyName, A]);
      }
    })(E4)), E4;
  }
  var D4;
  function REe() {
    if (D4) return Vl;
    D4 = 1, Object.defineProperty(Vl, "__esModule", { value: !0 }), Vl.boolOrEmptySchema = Vl.topBoolOrEmptySchema = void 0;
    const e = wx(), t = mt(), n = gl(), r = {
      message: "boolean schema is false"
    };
    function o(s) {
      const { gen: u, schema: c, validateName: f } = s;
      c === !1 ? i(s, !1) : typeof c == "object" && c.$async === !0 ? u.return(n.default.data) : (u.assign((0, t._)`${f}.errors`, null), u.return(!0));
    }
    Vl.topBoolOrEmptySchema = o;
    function a(s, u) {
      const { gen: c, schema: f } = s;
      f === !1 ? (c.var(u, !1), i(s)) : c.var(u, !0);
    }
    Vl.boolOrEmptySchema = a;
    function i(s, u) {
      const { gen: c, data: f } = s, p = {
        gen: c,
        keyword: "false schema",
        data: f,
        schema: !1,
        schemaCode: !1,
        schemaValue: !1,
        params: {},
        it: s
      };
      (0, e.reportError)(p, r, void 0, u);
    }
    return Vl;
  }
  var ir = {}, Ul = {}, L4;
  function P1() {
    if (L4) return Ul;
    L4 = 1, Object.defineProperty(Ul, "__esModule", { value: !0 }), Ul.getRules = Ul.isJSONType = void 0;
    const e = ["string", "number", "integer", "boolean", "null", "object", "array"], t = new Set(e);
    function n(o) {
      return typeof o == "string" && t.has(o);
    }
    Ul.isJSONType = n;
    function r() {
      const o = {
        number: { type: "number", rules: [] },
        string: { type: "string", rules: [] },
        array: { type: "array", rules: [] },
        object: { type: "object", rules: [] }
      };
      return {
        types: { ...o, integer: !0, boolean: !0, null: !0 },
        rules: [{ rules: [] }, o.number, o.string, o.array, o.object],
        post: { rules: [] },
        all: {},
        keywords: {}
      };
    }
    return Ul.getRules = r, Ul;
  }
  var Mi = {}, F4;
  function O1() {
    if (F4) return Mi;
    F4 = 1, Object.defineProperty(Mi, "__esModule", { value: !0 }), Mi.shouldUseRule = Mi.shouldUseGroup = Mi.schemaHasRulesForType = void 0;
    function e({ schema: r, self: o }, a) {
      const i = o.RULES.types[a];
      return i && i !== !0 && t(r, i);
    }
    Mi.schemaHasRulesForType = e;
    function t(r, o) {
      return o.rules.some((a) => n(r, a));
    }
    Mi.shouldUseGroup = t;
    function n(r, o) {
      var a;
      return r[o.keyword] !== void 0 || ((a = o.definition.implements) === null || a === void 0 ? void 0 : a.some((i) => r[i] !== void 0));
    }
    return Mi.shouldUseRule = n, Mi;
  }
  var T4;
  function zb() {
    if (T4) return ir;
    T4 = 1, Object.defineProperty(ir, "__esModule", { value: !0 }), ir.reportTypeError = ir.checkDataTypes = ir.checkDataType = ir.coerceAndCheckDataType = ir.getJSONTypes = ir.getSchemaTypes = ir.DataType = void 0;
    const e = P1(), t = O1(), n = wx(), r = mt(), o = Ft();
    var a;
    (function(_) {
      _[_.Correct = 0] = "Correct", _[_.Wrong = 1] = "Wrong";
    })(a || (ir.DataType = a = {}));
    function i(_) {
      const k = s(_.type);
      if (k.includes("null")) {
        if (_.nullable === !1)
          throw new Error("type: null contradicts nullable: false");
      } else {
        if (!k.length && _.nullable !== void 0)
          throw new Error('"nullable" cannot be used without "type"');
        _.nullable === !0 && k.push("null");
      }
      return k;
    }
    ir.getSchemaTypes = i;
    function s(_) {
      const k = Array.isArray(_) ? _ : _ ? [_] : [];
      if (k.every(e.isJSONType))
        return k;
      throw new Error("type must be JSONType or JSONType[]: " + k.join(","));
    }
    ir.getJSONTypes = s;
    function u(_, k) {
      const { gen: E, data: P, opts: O } = _, M = f(k, O.coerceTypes), I = k.length > 0 && !(M.length === 0 && k.length === 1 && (0, t.schemaHasRulesForType)(_, k[0]));
      if (I) {
        const A = y(k, P, O.strictNumbers, a.Wrong);
        E.if(A, () => {
          M.length ? p(_, k, M) : v(_);
        });
      }
      return I;
    }
    ir.coerceAndCheckDataType = u;
    const c = /* @__PURE__ */ new Set(["string", "number", "integer", "boolean", "null"]);
    function f(_, k) {
      return k ? _.filter((E) => c.has(E) || k === "array" && E === "array") : [];
    }
    function p(_, k, E) {
      const { gen: P, data: O, opts: M } = _, I = P.let("dataType", (0, r._)`typeof ${O}`), A = P.let("coerced", (0, r._)`undefined`);
      M.coerceTypes === "array" && P.if((0, r._)`${I} == 'object' && Array.isArray(${O}) && ${O}.length == 1`, () => P.assign(O, (0, r._)`${O}[0]`).assign(I, (0, r._)`typeof ${O}`).if(y(k, O, M.strictNumbers), () => P.assign(A, O))), P.if((0, r._)`${A} !== undefined`);
      for (const F of E)
        (c.has(F) || F === "array" && M.coerceTypes === "array") && D(F);
      P.else(), v(_), P.endIf(), P.if((0, r._)`${A} !== undefined`, () => {
        P.assign(O, A), g(_, A);
      });
      function D(F) {
        switch (F) {
          case "string":
            P.elseIf((0, r._)`${I} == "number" || ${I} == "boolean"`).assign(A, (0, r._)`"" + ${O}`).elseIf((0, r._)`${O} === null`).assign(A, (0, r._)`""`);
            return;
          case "number":
            P.elseIf((0, r._)`${I} == "boolean" || ${O} === null
              || (${I} == "string" && ${O} && ${O} == +${O})`).assign(A, (0, r._)`+${O}`);
            return;
          case "integer":
            P.elseIf((0, r._)`${I} === "boolean" || ${O} === null
              || (${I} === "string" && ${O} && ${O} == +${O} && !(${O} % 1))`).assign(A, (0, r._)`+${O}`);
            return;
          case "boolean":
            P.elseIf((0, r._)`${O} === "false" || ${O} === 0 || ${O} === null`).assign(A, !1).elseIf((0, r._)`${O} === "true" || ${O} === 1`).assign(A, !0);
            return;
          case "null":
            P.elseIf((0, r._)`${O} === "" || ${O} === 0 || ${O} === false`), P.assign(A, null);
            return;
          case "array":
            P.elseIf((0, r._)`${I} === "string" || ${I} === "number"
              || ${I} === "boolean" || ${O} === null`).assign(A, (0, r._)`[${O}]`);
        }
      }
    }
    function g({ gen: _, parentData: k, parentDataProperty: E }, P) {
      _.if((0, r._)`${k} !== undefined`, () => _.assign((0, r._)`${k}[${E}]`, P));
    }
    function h(_, k, E, P = a.Correct) {
      const O = P === a.Correct ? r.operators.EQ : r.operators.NEQ;
      let M;
      switch (_) {
        case "null":
          return (0, r._)`${k} ${O} null`;
        case "array":
          M = (0, r._)`Array.isArray(${k})`;
          break;
        case "object":
          M = (0, r._)`${k} && typeof ${k} == "object" && !Array.isArray(${k})`;
          break;
        case "integer":
          M = I((0, r._)`!(${k} % 1) && !isNaN(${k})`);
          break;
        case "number":
          M = I();
          break;
        default:
          return (0, r._)`typeof ${k} ${O} ${_}`;
      }
      return P === a.Correct ? M : (0, r.not)(M);
      function I(A = r.nil) {
        return (0, r.and)((0, r._)`typeof ${k} == "number"`, A, E ? (0, r._)`isFinite(${k})` : r.nil);
      }
    }
    ir.checkDataType = h;
    function y(_, k, E, P) {
      if (_.length === 1)
        return h(_[0], k, E, P);
      let O;
      const M = (0, o.toHash)(_);
      if (M.array && M.object) {
        const I = (0, r._)`typeof ${k} != "object"`;
        O = M.null ? I : (0, r._)`!${k} || ${I}`, delete M.null, delete M.array, delete M.object;
      } else
        O = r.nil;
      M.number && delete M.integer;
      for (const I in M)
        O = (0, r.and)(O, h(I, k, E, P));
      return O;
    }
    ir.checkDataTypes = y;
    const b = {
      message: ({ schema: _ }) => `must be ${_}`,
      params: ({ schema: _, schemaValue: k }) => typeof _ == "string" ? (0, r._)`{type: ${_}}` : (0, r._)`{type: ${k}}`
    };
    function v(_) {
      const k = w(_);
      (0, n.reportError)(k, b);
    }
    ir.reportTypeError = v;
    function w(_) {
      const { gen: k, data: E, schema: P } = _, O = (0, o.schemaRefOrVal)(_, P, "type");
      return {
        gen: k,
        keyword: "type",
        data: E,
        schema: P.type,
        schemaCode: O,
        schemaValue: O,
        parentSchema: P,
        params: {},
        it: _
      };
    }
    return ir;
  }
  var tp = {}, z4;
  function jEe() {
    if (z4) return tp;
    z4 = 1, Object.defineProperty(tp, "__esModule", { value: !0 }), tp.assignDefaults = void 0;
    const e = mt(), t = Ft();
    function n(o, a) {
      const { properties: i, items: s } = o.schema;
      if (a === "object" && i)
        for (const u in i)
          r(o, u, i[u].default);
      else a === "array" && Array.isArray(s) && s.forEach((u, c) => r(o, c, u.default));
    }
    tp.assignDefaults = n;
    function r(o, a, i) {
      const { gen: s, compositeRule: u, data: c, opts: f } = o;
      if (i === void 0)
        return;
      const p = (0, e._)`${c}${(0, e.getProperty)(a)}`;
      if (u) {
        (0, t.checkStrictMode)(o, `default is ignored for: ${p}`);
        return;
      }
      let g = (0, e._)`${p} === undefined`;
      f.useDefaults === "empty" && (g = (0, e._)`${g} || ${p} === null || ${p} === ""`), s.if(g, (0, e._)`${p} = ${(0, e.stringify)(i)}`);
    }
    return tp;
  }
  var Wo = {}, Jt = {}, B4;
  function ca() {
    if (B4) return Jt;
    B4 = 1, Object.defineProperty(Jt, "__esModule", { value: !0 }), Jt.validateUnion = Jt.validateArray = Jt.usePattern = Jt.callValidateCode = Jt.schemaProperties = Jt.allSchemaProperties = Jt.noPropertyInData = Jt.propertyInData = Jt.isOwnProperty = Jt.hasPropFunc = Jt.reportMissingProp = Jt.checkMissingProp = Jt.checkReportMissingProp = void 0;
    const e = mt(), t = Ft(), n = gl(), r = Ft();
    function o(_, k) {
      const { gen: E, data: P, it: O } = _;
      E.if(f(E, P, k, O.opts.ownProperties), () => {
        _.setParams({ missingProperty: (0, e._)`${k}` }, !0), _.error();
      });
    }
    Jt.checkReportMissingProp = o;
    function a({ gen: _, data: k, it: { opts: E } }, P, O) {
      return (0, e.or)(...P.map((M) => (0, e.and)(f(_, k, M, E.ownProperties), (0, e._)`${O} = ${M}`)));
    }
    Jt.checkMissingProp = a;
    function i(_, k) {
      _.setParams({ missingProperty: k }, !0), _.error();
    }
    Jt.reportMissingProp = i;
    function s(_) {
      return _.scopeValue("func", {
        // eslint-disable-next-line @typescript-eslint/unbound-method
        ref: Object.prototype.hasOwnProperty,
        code: (0, e._)`Object.prototype.hasOwnProperty`
      });
    }
    Jt.hasPropFunc = s;
    function u(_, k, E) {
      return (0, e._)`${s(_)}.call(${k}, ${E})`;
    }
    Jt.isOwnProperty = u;
    function c(_, k, E, P) {
      const O = (0, e._)`${k}${(0, e.getProperty)(E)} !== undefined`;
      return P ? (0, e._)`${O} && ${u(_, k, E)}` : O;
    }
    Jt.propertyInData = c;
    function f(_, k, E, P) {
      const O = (0, e._)`${k}${(0, e.getProperty)(E)} === undefined`;
      return P ? (0, e.or)(O, (0, e.not)(u(_, k, E))) : O;
    }
    Jt.noPropertyInData = f;
    function p(_) {
      return _ ? Object.keys(_).filter((k) => k !== "__proto__") : [];
    }
    Jt.allSchemaProperties = p;
    function g(_, k) {
      return p(k).filter((E) => !(0, t.alwaysValidSchema)(_, k[E]));
    }
    Jt.schemaProperties = g;
    function h({ schemaCode: _, data: k, it: { gen: E, topSchemaRef: P, schemaPath: O, errorPath: M }, it: I }, A, D, F) {
      const j = F ? (0, e._)`${_}, ${k}, ${P}${O}` : k, U = [
        [n.default.instancePath, (0, e.strConcat)(n.default.instancePath, M)],
        [n.default.parentData, I.parentData],
        [n.default.parentDataProperty, I.parentDataProperty],
        [n.default.rootData, n.default.rootData]
      ];
      I.opts.dynamicRef && U.push([n.default.dynamicAnchors, n.default.dynamicAnchors]);
      const $ = (0, e._)`${j}, ${E.object(...U)}`;
      return D !== e.nil ? (0, e._)`${A}.call(${D}, ${$})` : (0, e._)`${A}(${$})`;
    }
    Jt.callValidateCode = h;
    const y = (0, e._)`new RegExp`;
    function b({ gen: _, it: { opts: k } }, E) {
      const P = k.unicodeRegExp ? "u" : "", { regExp: O } = k.code, M = O(E, P);
      return _.scopeValue("pattern", {
        key: M.toString(),
        ref: M,
        code: (0, e._)`${O.code === "new RegExp" ? y : (0, r.useFunc)(_, O)}(${E}, ${P})`
      });
    }
    Jt.usePattern = b;
    function v(_) {
      const { gen: k, data: E, keyword: P, it: O } = _, M = k.name("valid");
      if (O.allErrors) {
        const A = k.let("valid", !0);
        return I(() => k.assign(A, !1)), A;
      }
      return k.var(M, !0), I(() => k.break()), M;
      function I(A) {
        const D = k.const("len", (0, e._)`${E}.length`);
        k.forRange("i", 0, D, (F) => {
          _.subschema({
            keyword: P,
            dataProp: F,
            dataPropType: t.Type.Num
          }, M), k.if((0, e.not)(M), A);
        });
      }
    }
    Jt.validateArray = v;
    function w(_) {
      const { gen: k, schema: E, keyword: P, it: O } = _;
      if (!Array.isArray(E))
        throw new Error("ajv implementation error");
      if (E.some((A) => (0, t.alwaysValidSchema)(O, A)) && !O.opts.unevaluated)
        return;
      const M = k.let("valid", !1), I = k.name("_valid");
      k.block(() => E.forEach((A, D) => {
        const F = _.subschema({
          keyword: P,
          schemaProp: D,
          compositeRule: !0
        }, I);
        k.assign(M, (0, e._)`${M} || ${I}`), _.mergeValidEvaluated(F, I) || k.if((0, e.not)(M));
      })), _.result(M, () => _.reset(), () => _.error(!0));
    }
    return Jt.validateUnion = w, Jt;
  }
  var V4;
  function IEe() {
    if (V4) return Wo;
    V4 = 1, Object.defineProperty(Wo, "__esModule", { value: !0 }), Wo.validateKeywordUsage = Wo.validSchemaType = Wo.funcKeywordCode = Wo.macroKeywordCode = void 0;
    const e = mt(), t = gl(), n = ca(), r = wx();
    function o(g, h) {
      const { gen: y, keyword: b, schema: v, parentSchema: w, it: _ } = g, k = h.macro.call(_.self, v, w, _), E = c(y, b, k);
      _.opts.validateSchema !== !1 && _.self.validateSchema(k, !0);
      const P = y.name("valid");
      g.subschema({
        schema: k,
        schemaPath: e.nil,
        errSchemaPath: `${_.errSchemaPath}/${b}`,
        topSchemaRef: E,
        compositeRule: !0
      }, P), g.pass(P, () => g.error(!0));
    }
    Wo.macroKeywordCode = o;
    function a(g, h) {
      var y;
      const { gen: b, keyword: v, schema: w, parentSchema: _, $data: k, it: E } = g;
      u(E, h);
      const P = !k && h.compile ? h.compile.call(E.self, w, _, E) : h.validate, O = c(b, v, P), M = b.let("valid");
      g.block$data(M, I), g.ok((y = h.valid) !== null && y !== void 0 ? y : M);
      function I() {
        if (h.errors === !1)
          F(), h.modifying && i(g), j(() => g.error());
        else {
          const U = h.async ? A() : D();
          h.modifying && i(g), j(() => s(g, U));
        }
      }
      function A() {
        const U = b.let("ruleErrs", null);
        return b.try(() => F((0, e._)`await `), ($) => b.assign(M, !1).if((0, e._)`${$} instanceof ${E.ValidationError}`, () => b.assign(U, (0, e._)`${$}.errors`), () => b.throw($))), U;
      }
      function D() {
        const U = (0, e._)`${O}.errors`;
        return b.assign(U, null), F(e.nil), U;
      }
      function F(U = h.async ? (0, e._)`await ` : e.nil) {
        const $ = E.opts.passContext ? t.default.this : t.default.self, q = !("compile" in h && !k || h.schema === !1);
        b.assign(M, (0, e._)`${U}${(0, n.callValidateCode)(g, O, $, q)}`, h.modifying);
      }
      function j(U) {
        var $;
        b.if((0, e.not)(($ = h.valid) !== null && $ !== void 0 ? $ : M), U);
      }
    }
    Wo.funcKeywordCode = a;
    function i(g) {
      const { gen: h, data: y, it: b } = g;
      h.if(b.parentData, () => h.assign(y, (0, e._)`${b.parentData}[${b.parentDataProperty}]`));
    }
    function s(g, h) {
      const { gen: y } = g;
      y.if((0, e._)`Array.isArray(${h})`, () => {
        y.assign(t.default.vErrors, (0, e._)`${t.default.vErrors} === null ? ${h} : ${t.default.vErrors}.concat(${h})`).assign(t.default.errors, (0, e._)`${t.default.vErrors}.length`), (0, r.extendErrors)(g);
      }, () => g.error());
    }
    function u({ schemaEnv: g }, h) {
      if (h.async && !g.$async)
        throw new Error("async keyword in sync schema");
    }
    function c(g, h, y) {
      if (y === void 0)
        throw new Error(`keyword "${h}" failed to compile`);
      return g.scopeValue("keyword", typeof y == "function" ? { ref: y } : { ref: y, code: (0, e.stringify)(y) });
    }
    function f(g, h, y = !1) {
      return !h.length || h.some((b) => b === "array" ? Array.isArray(g) : b === "object" ? g && typeof g == "object" && !Array.isArray(g) : typeof g == b || y && typeof g > "u");
    }
    Wo.validSchemaType = f;
    function p({ schema: g, opts: h, self: y, errSchemaPath: b }, v, w) {
      if (Array.isArray(v.keyword) ? !v.keyword.includes(w) : v.keyword !== w)
        throw new Error("ajv implementation error");
      const _ = v.dependencies;
      if (_?.some((k) => !Object.prototype.hasOwnProperty.call(g, k)))
        throw new Error(`parent schema must have dependencies of ${w}: ${_.join(",")}`);
      if (v.validateSchema && !v.validateSchema(g[w])) {
        const k = `keyword "${w}" value is invalid at path "${b}": ` + y.errorsText(v.validateSchema.errors);
        if (h.validateSchema === "log")
          y.logger.error(k);
        else
          throw new Error(k);
      }
    }
    return Wo.validateKeywordUsage = p, Wo;
  }
  var Ri = {}, U4;
  function AEe() {
    if (U4) return Ri;
    U4 = 1, Object.defineProperty(Ri, "__esModule", { value: !0 }), Ri.extendSubschemaMode = Ri.extendSubschemaData = Ri.getSubschema = void 0;
    const e = mt(), t = Ft();
    function n(a, { keyword: i, schemaProp: s, schema: u, schemaPath: c, errSchemaPath: f, topSchemaRef: p }) {
      if (i !== void 0 && u !== void 0)
        throw new Error('both "keyword" and "schema" passed, only one allowed');
      if (i !== void 0) {
        const g = a.schema[i];
        return s === void 0 ? {
          schema: g,
          schemaPath: (0, e._)`${a.schemaPath}${(0, e.getProperty)(i)}`,
          errSchemaPath: `${a.errSchemaPath}/${i}`
        } : {
          schema: g[s],
          schemaPath: (0, e._)`${a.schemaPath}${(0, e.getProperty)(i)}${(0, e.getProperty)(s)}`,
          errSchemaPath: `${a.errSchemaPath}/${i}/${(0, t.escapeFragment)(s)}`
        };
      }
      if (u !== void 0) {
        if (c === void 0 || f === void 0 || p === void 0)
          throw new Error('"schemaPath", "errSchemaPath" and "topSchemaRef" are required with "schema"');
        return {
          schema: u,
          schemaPath: c,
          topSchemaRef: p,
          errSchemaPath: f
        };
      }
      throw new Error('either "keyword" or "schema" must be passed');
    }
    Ri.getSubschema = n;
    function r(a, i, { dataProp: s, dataPropType: u, data: c, dataTypes: f, propertyName: p }) {
      if (c !== void 0 && s !== void 0)
        throw new Error('both "data" and "dataProp" passed, only one allowed');
      const { gen: g } = i;
      if (s !== void 0) {
        const { errorPath: y, dataPathArr: b, opts: v } = i, w = g.let("data", (0, e._)`${i.data}${(0, e.getProperty)(s)}`, !0);
        h(w), a.errorPath = (0, e.str)`${y}${(0, t.getErrorPath)(s, u, v.jsPropertySyntax)}`, a.parentDataProperty = (0, e._)`${s}`, a.dataPathArr = [...b, a.parentDataProperty];
      }
      if (c !== void 0) {
        const y = c instanceof e.Name ? c : g.let("data", c, !0);
        h(y), p !== void 0 && (a.propertyName = p);
      }
      f && (a.dataTypes = f);
      function h(y) {
        a.data = y, a.dataLevel = i.dataLevel + 1, a.dataTypes = [], i.definedProperties = /* @__PURE__ */ new Set(), a.parentData = i.data, a.dataNames = [...i.dataNames, y];
      }
    }
    Ri.extendSubschemaData = r;
    function o(a, { jtdDiscriminator: i, jtdMetadata: s, compositeRule: u, createErrors: c, allErrors: f }) {
      u !== void 0 && (a.compositeRule = u), c !== void 0 && (a.createErrors = c), f !== void 0 && (a.allErrors = f), a.jtdDiscriminator = i, a.jtdMetadata = s;
    }
    return Ri.extendSubschemaMode = o, Ri;
  }
  var Er = {}, H4, W4;
  function N1() {
    return W4 || (W4 = 1, H4 = function e(t, n) {
      if (t === n) return !0;
      if (t && n && typeof t == "object" && typeof n == "object") {
        if (t.constructor !== n.constructor) return !1;
        var r, o, a;
        if (Array.isArray(t)) {
          if (r = t.length, r != n.length) return !1;
          for (o = r; o-- !== 0; )
            if (!e(t[o], n[o])) return !1;
          return !0;
        }
        if (t.constructor === RegExp) return t.source === n.source && t.flags === n.flags;
        if (t.valueOf !== Object.prototype.valueOf) return t.valueOf() === n.valueOf();
        if (t.toString !== Object.prototype.toString) return t.toString() === n.toString();
        if (a = Object.keys(t), r = a.length, r !== Object.keys(n).length) return !1;
        for (o = r; o-- !== 0; )
          if (!Object.prototype.hasOwnProperty.call(n, a[o])) return !1;
        for (o = r; o-- !== 0; ) {
          var i = a[o];
          if (!e(t[i], n[i])) return !1;
        }
        return !0;
      }
      return t !== t && n !== n;
    }), H4;
  }
  var w0 = { exports: {} }, q4;
  function $Ee() {
    if (q4) return w0.exports;
    q4 = 1;
    var e = w0.exports = function(r, o, a) {
      typeof o == "function" && (a = o, o = {}), a = o.cb || a;
      var i = typeof a == "function" ? a : a.pre || function() {
      }, s = a.post || function() {
      };
      t(o, i, s, r, "", r);
    };
    e.keywords = {
      additionalItems: !0,
      items: !0,
      contains: !0,
      additionalProperties: !0,
      propertyNames: !0,
      not: !0,
      if: !0,
      then: !0,
      else: !0
    }, e.arrayKeywords = {
      items: !0,
      allOf: !0,
      anyOf: !0,
      oneOf: !0
    }, e.propsKeywords = {
      $defs: !0,
      definitions: !0,
      properties: !0,
      patternProperties: !0,
      dependencies: !0
    }, e.skipKeywords = {
      default: !0,
      enum: !0,
      const: !0,
      required: !0,
      maximum: !0,
      minimum: !0,
      exclusiveMaximum: !0,
      exclusiveMinimum: !0,
      multipleOf: !0,
      maxLength: !0,
      minLength: !0,
      pattern: !0,
      format: !0,
      maxItems: !0,
      minItems: !0,
      uniqueItems: !0,
      maxProperties: !0,
      minProperties: !0
    };
    function t(r, o, a, i, s, u, c, f, p, g) {
      if (i && typeof i == "object" && !Array.isArray(i)) {
        o(i, s, u, c, f, p, g);
        for (var h in i) {
          var y = i[h];
          if (Array.isArray(y)) {
            if (h in e.arrayKeywords)
              for (var b = 0; b < y.length; b++)
                t(r, o, a, y[b], s + "/" + h + "/" + b, u, s, h, i, b);
          } else if (h in e.propsKeywords) {
            if (y && typeof y == "object")
              for (var v in y)
                t(r, o, a, y[v], s + "/" + h + "/" + n(v), u, s, h, i, v);
          } else (h in e.keywords || r.allKeys && !(h in e.skipKeywords)) && t(r, o, a, y, s + "/" + h, u, s, h, i);
        }
        a(i, s, u, c, f, p, g);
      }
    }
    function n(r) {
      return r.replace(/~/g, "~0").replace(/\//g, "~1");
    }
    return w0.exports;
  }
  var K4;
  function xx() {
    if (K4) return Er;
    K4 = 1, Object.defineProperty(Er, "__esModule", { value: !0 }), Er.getSchemaRefs = Er.resolveUrl = Er.normalizeId = Er._getFullPath = Er.getFullPath = Er.inlineRef = void 0;
    const e = Ft(), t = N1(), n = $Ee(), r = /* @__PURE__ */ new Set([
      "type",
      "format",
      "pattern",
      "maxLength",
      "minLength",
      "maxProperties",
      "minProperties",
      "maxItems",
      "minItems",
      "maximum",
      "minimum",
      "uniqueItems",
      "multipleOf",
      "required",
      "enum",
      "const"
    ]);
    function o(b, v = !0) {
      return typeof b == "boolean" ? !0 : v === !0 ? !i(b) : v ? s(b) <= v : !1;
    }
    Er.inlineRef = o;
    const a = /* @__PURE__ */ new Set([
      "$ref",
      "$recursiveRef",
      "$recursiveAnchor",
      "$dynamicRef",
      "$dynamicAnchor"
    ]);
    function i(b) {
      for (const v in b) {
        if (a.has(v))
          return !0;
        const w = b[v];
        if (Array.isArray(w) && w.some(i) || typeof w == "object" && i(w))
          return !0;
      }
      return !1;
    }
    function s(b) {
      let v = 0;
      for (const w in b)
        if (w === "$ref" || (v++, !r.has(w) && (typeof b[w] == "object" && (0, e.eachItem)(b[w], (_) => v += s(_)), v === 1 / 0)))
          return 1 / 0;
      return v;
    }
    function u(b, v = "", w) {
      w !== !1 && (v = p(v));
      const _ = b.parse(v);
      return c(b, _);
    }
    Er.getFullPath = u;
    function c(b, v) {
      return b.serialize(v).split("#")[0] + "#";
    }
    Er._getFullPath = c;
    const f = /#\/?$/;
    function p(b) {
      return b ? b.replace(f, "") : "";
    }
    Er.normalizeId = p;
    function g(b, v, w) {
      return w = p(w), b.resolve(v, w);
    }
    Er.resolveUrl = g;
    const h = /^[a-z_][-a-z0-9._]*$/i;
    function y(b, v) {
      if (typeof b == "boolean")
        return {};
      const { schemaId: w, uriResolver: _ } = this.opts, k = p(b[w] || v), E = { "": k }, P = u(_, k, !1), O = {}, M = /* @__PURE__ */ new Set();
      return n(b, { allKeys: !0 }, (D, F, j, U) => {
        if (U === void 0)
          return;
        const $ = P + F;
        let q = E[U];
        typeof D[w] == "string" && (q = B.call(this, D[w])), G.call(this, D.$anchor), G.call(this, D.$dynamicAnchor), E[F] = q;
        function B(W) {
          const Y = this.opts.uriResolver.resolve;
          if (W = p(q ? Y(q, W) : W), M.has(W))
            throw A(W);
          M.add(W);
          let z = this.refs[W];
          return typeof z == "string" && (z = this.refs[z]), typeof z == "object" ? I(D, z.schema, W) : W !== p($) && (W[0] === "#" ? (I(D, O[W], W), O[W] = D) : this.refs[W] = $), W;
        }
        function G(W) {
          if (typeof W == "string") {
            if (!h.test(W))
              throw new Error(`invalid anchor "${W}"`);
            B.call(this, `#${W}`);
          }
        }
      }), O;
      function I(D, F, j) {
        if (F !== void 0 && !t(D, F))
          throw A(j);
      }
      function A(D) {
        return new Error(`reference "${D}" resolves to more than one schema`);
      }
    }
    return Er.getSchemaRefs = y, Er;
  }
  var G4;
  function kx() {
    if (G4) return Ni;
    G4 = 1, Object.defineProperty(Ni, "__esModule", { value: !0 }), Ni.getData = Ni.KeywordCxt = Ni.validateFunctionCode = void 0;
    const e = REe(), t = zb(), n = O1(), r = zb(), o = jEe(), a = IEe(), i = AEe(), s = mt(), u = gl(), c = xx(), f = Ft(), p = wx();
    function g(Z) {
      if (P(Z) && (M(Z), E(Z))) {
        v(Z);
        return;
      }
      h(Z, () => (0, e.topBoolOrEmptySchema)(Z));
    }
    Ni.validateFunctionCode = g;
    function h({ gen: Z, validateName: ee, schema: oe, schemaEnv: le, opts: be }, ke) {
      be.code.es5 ? Z.func(ee, (0, s._)`${u.default.data}, ${u.default.valCxt}`, le.$async, () => {
        Z.code((0, s._)`"use strict"; ${_(oe, be)}`), b(Z, be), Z.code(ke);
      }) : Z.func(ee, (0, s._)`${u.default.data}, ${y(be)}`, le.$async, () => Z.code(_(oe, be)).code(ke));
    }
    function y(Z) {
      return (0, s._)`{${u.default.instancePath}="", ${u.default.parentData}, ${u.default.parentDataProperty}, ${u.default.rootData}=${u.default.data}${Z.dynamicRef ? (0, s._)`, ${u.default.dynamicAnchors}={}` : s.nil}}={}`;
    }
    function b(Z, ee) {
      Z.if(u.default.valCxt, () => {
        Z.var(u.default.instancePath, (0, s._)`${u.default.valCxt}.${u.default.instancePath}`), Z.var(u.default.parentData, (0, s._)`${u.default.valCxt}.${u.default.parentData}`), Z.var(u.default.parentDataProperty, (0, s._)`${u.default.valCxt}.${u.default.parentDataProperty}`), Z.var(u.default.rootData, (0, s._)`${u.default.valCxt}.${u.default.rootData}`), ee.dynamicRef && Z.var(u.default.dynamicAnchors, (0, s._)`${u.default.valCxt}.${u.default.dynamicAnchors}`);
      }, () => {
        Z.var(u.default.instancePath, (0, s._)`""`), Z.var(u.default.parentData, (0, s._)`undefined`), Z.var(u.default.parentDataProperty, (0, s._)`undefined`), Z.var(u.default.rootData, u.default.data), ee.dynamicRef && Z.var(u.default.dynamicAnchors, (0, s._)`{}`);
      });
    }
    function v(Z) {
      const { schema: ee, opts: oe, gen: le } = Z;
      h(Z, () => {
        oe.$comment && ee.$comment && U(Z), D(Z), le.let(u.default.vErrors, null), le.let(u.default.errors, 0), oe.unevaluated && w(Z), I(Z), $(Z);
      });
    }
    function w(Z) {
      const { gen: ee, validateName: oe } = Z;
      Z.evaluated = ee.const("evaluated", (0, s._)`${oe}.evaluated`), ee.if((0, s._)`${Z.evaluated}.dynamicProps`, () => ee.assign((0, s._)`${Z.evaluated}.props`, (0, s._)`undefined`)), ee.if((0, s._)`${Z.evaluated}.dynamicItems`, () => ee.assign((0, s._)`${Z.evaluated}.items`, (0, s._)`undefined`));
    }
    function _(Z, ee) {
      const oe = typeof Z == "object" && Z[ee.schemaId];
      return oe && (ee.code.source || ee.code.process) ? (0, s._)`/*# sourceURL=${oe} */` : s.nil;
    }
    function k(Z, ee) {
      if (P(Z) && (M(Z), E(Z))) {
        O(Z, ee);
        return;
      }
      (0, e.boolOrEmptySchema)(Z, ee);
    }
    function E({ schema: Z, self: ee }) {
      if (typeof Z == "boolean")
        return !Z;
      for (const oe in Z)
        if (ee.RULES.all[oe])
          return !0;
      return !1;
    }
    function P(Z) {
      return typeof Z.schema != "boolean";
    }
    function O(Z, ee) {
      const { schema: oe, gen: le, opts: be } = Z;
      be.$comment && oe.$comment && U(Z), F(Z), j(Z);
      const ke = le.const("_errs", u.default.errors);
      I(Z, ke), le.var(ee, (0, s._)`${ke} === ${u.default.errors}`);
    }
    function M(Z) {
      (0, f.checkUnknownRules)(Z), A(Z);
    }
    function I(Z, ee) {
      if (Z.opts.jtd)
        return B(Z, [], !1, ee);
      const oe = (0, t.getSchemaTypes)(Z.schema), le = (0, t.coerceAndCheckDataType)(Z, oe);
      B(Z, oe, !le, ee);
    }
    function A(Z) {
      const { schema: ee, errSchemaPath: oe, opts: le, self: be } = Z;
      ee.$ref && le.ignoreKeywordsWithRef && (0, f.schemaHasRulesButRef)(ee, be.RULES) && be.logger.warn(`$ref: keywords ignored in schema at path "${oe}"`);
    }
    function D(Z) {
      const { schema: ee, opts: oe } = Z;
      ee.default !== void 0 && oe.useDefaults && oe.strictSchema && (0, f.checkStrictMode)(Z, "default is ignored in the schema root");
    }
    function F(Z) {
      const ee = Z.schema[Z.opts.schemaId];
      ee && (Z.baseId = (0, c.resolveUrl)(Z.opts.uriResolver, Z.baseId, ee));
    }
    function j(Z) {
      if (Z.schema.$async && !Z.schemaEnv.$async)
        throw new Error("async schema in sync schema");
    }
    function U({ gen: Z, schemaEnv: ee, schema: oe, errSchemaPath: le, opts: be }) {
      const ke = oe.$comment;
      if (be.$comment === !0)
        Z.code((0, s._)`${u.default.self}.logger.log(${ke})`);
      else if (typeof be.$comment == "function") {
        const De = (0, s.str)`${le}/$comment`, ze = Z.scopeValue("root", { ref: ee.root });
        Z.code((0, s._)`${u.default.self}.opts.$comment(${ke}, ${De}, ${ze}.schema)`);
      }
    }
    function $(Z) {
      const { gen: ee, schemaEnv: oe, validateName: le, ValidationError: be, opts: ke } = Z;
      oe.$async ? ee.if((0, s._)`${u.default.errors} === 0`, () => ee.return(u.default.data), () => ee.throw((0, s._)`new ${be}(${u.default.vErrors})`)) : (ee.assign((0, s._)`${le}.errors`, u.default.vErrors), ke.unevaluated && q(Z), ee.return((0, s._)`${u.default.errors} === 0`));
    }
    function q({ gen: Z, evaluated: ee, props: oe, items: le }) {
      oe instanceof s.Name && Z.assign((0, s._)`${ee}.props`, oe), le instanceof s.Name && Z.assign((0, s._)`${ee}.items`, le);
    }
    function B(Z, ee, oe, le) {
      const { gen: be, schema: ke, data: De, allErrors: ze, opts: Ue, self: He } = Z, { RULES: Pe } = He;
      if (ke.$ref && (Ue.ignoreKeywordsWithRef || !(0, f.schemaHasRulesButRef)(ke, Pe))) {
        be.block(() => ne(Z, "$ref", Pe.all.$ref.definition));
        return;
      }
      Ue.jtd || W(Z, ee), be.block(() => {
        for (const Xe of Pe.rules)
          It(Xe);
        It(Pe.post);
      });
      function It(Xe) {
        (0, n.shouldUseGroup)(ke, Xe) && (Xe.type ? (be.if((0, r.checkDataType)(Xe.type, De, Ue.strictNumbers)), G(Z, Xe), ee.length === 1 && ee[0] === Xe.type && oe && (be.else(), (0, r.reportTypeError)(Z)), be.endIf()) : G(Z, Xe), ze || be.if((0, s._)`${u.default.errors} === ${le || 0}`));
      }
    }
    function G(Z, ee) {
      const { gen: oe, schema: le, opts: { useDefaults: be } } = Z;
      be && (0, o.assignDefaults)(Z, ee.type), oe.block(() => {
        for (const ke of ee.rules)
          (0, n.shouldUseRule)(le, ke) && ne(Z, ke.keyword, ke.definition, ee.type);
      });
    }
    function W(Z, ee) {
      Z.schemaEnv.meta || !Z.opts.strictTypes || (Y(Z, ee), Z.opts.allowUnionTypes || z(Z, ee), L(Z, Z.dataTypes));
    }
    function Y(Z, ee) {
      if (ee.length) {
        if (!Z.dataTypes.length) {
          Z.dataTypes = ee;
          return;
        }
        ee.forEach((oe) => {
          T(Z.dataTypes, oe) || X(Z, `type "${oe}" not allowed by context "${Z.dataTypes.join(",")}"`);
        }), V(Z, ee);
      }
    }
    function z(Z, ee) {
      ee.length > 1 && !(ee.length === 2 && ee.includes("null")) && X(Z, "use allowUnionTypes to allow union type keyword");
    }
    function L(Z, ee) {
      const oe = Z.self.RULES.all;
      for (const le in oe) {
        const be = oe[le];
        if (typeof be == "object" && (0, n.shouldUseRule)(Z.schema, be)) {
          const { type: ke } = be.definition;
          ke.length && !ke.some((De) => K(ee, De)) && X(Z, `missing type "${ke.join(",")}" for keyword "${le}"`);
        }
      }
    }
    function K(Z, ee) {
      return Z.includes(ee) || ee === "number" && Z.includes("integer");
    }
    function T(Z, ee) {
      return Z.includes(ee) || ee === "integer" && Z.includes("number");
    }
    function V(Z, ee) {
      const oe = [];
      for (const le of Z.dataTypes)
        T(ee, le) ? oe.push(le) : ee.includes("integer") && le === "number" && oe.push("integer");
      Z.dataTypes = oe;
    }
    function X(Z, ee) {
      const oe = Z.schemaEnv.baseId + Z.errSchemaPath;
      ee += ` at "${oe}" (strictTypes)`, (0, f.checkStrictMode)(Z, ee, Z.opts.strictTypes);
    }
    class Q {
      constructor(ee, oe, le) {
        if ((0, a.validateKeywordUsage)(ee, oe, le), this.gen = ee.gen, this.allErrors = ee.allErrors, this.keyword = le, this.data = ee.data, this.schema = ee.schema[le], this.$data = oe.$data && ee.opts.$data && this.schema && this.schema.$data, this.schemaValue = (0, f.schemaRefOrVal)(ee, this.schema, le, this.$data), this.schemaType = oe.schemaType, this.parentSchema = ee.schema, this.params = {}, this.it = ee, this.def = oe, this.$data)
          this.schemaCode = ee.gen.const("vSchema", ce(this.$data, ee));
        else if (this.schemaCode = this.schemaValue, !(0, a.validSchemaType)(this.schema, oe.schemaType, oe.allowUndefined))
          throw new Error(`${le} value must be ${JSON.stringify(oe.schemaType)}`);
        ("code" in oe ? oe.trackErrors : oe.errors !== !1) && (this.errsCount = ee.gen.const("_errs", u.default.errors));
      }
      result(ee, oe, le) {
        this.failResult((0, s.not)(ee), oe, le);
      }
      failResult(ee, oe, le) {
        this.gen.if(ee), le ? le() : this.error(), oe ? (this.gen.else(), oe(), this.allErrors && this.gen.endIf()) : this.allErrors ? this.gen.endIf() : this.gen.else();
      }
      pass(ee, oe) {
        this.failResult((0, s.not)(ee), void 0, oe);
      }
      fail(ee) {
        if (ee === void 0) {
          this.error(), this.allErrors || this.gen.if(!1);
          return;
        }
        this.gen.if(ee), this.error(), this.allErrors ? this.gen.endIf() : this.gen.else();
      }
      fail$data(ee) {
        if (!this.$data)
          return this.fail(ee);
        const { schemaCode: oe } = this;
        this.fail((0, s._)`${oe} !== undefined && (${(0, s.or)(this.invalid$data(), ee)})`);
      }
      error(ee, oe, le) {
        if (oe) {
          this.setParams(oe), this._error(ee, le), this.setParams({});
          return;
        }
        this._error(ee, le);
      }
      _error(ee, oe) {
        (ee ? p.reportExtraError : p.reportError)(this, this.def.error, oe);
      }
      $dataError() {
        (0, p.reportError)(this, this.def.$dataError || p.keyword$DataError);
      }
      reset() {
        if (this.errsCount === void 0)
          throw new Error('add "trackErrors" to keyword definition');
        (0, p.resetErrorsCount)(this.gen, this.errsCount);
      }
      ok(ee) {
        this.allErrors || this.gen.if(ee);
      }
      setParams(ee, oe) {
        oe ? Object.assign(this.params, ee) : this.params = ee;
      }
      block$data(ee, oe, le = s.nil) {
        this.gen.block(() => {
          this.check$data(ee, le), oe();
        });
      }
      check$data(ee = s.nil, oe = s.nil) {
        if (!this.$data)
          return;
        const { gen: le, schemaCode: be, schemaType: ke, def: De } = this;
        le.if((0, s.or)((0, s._)`${be} === undefined`, oe)), ee !== s.nil && le.assign(ee, !0), (ke.length || De.validateSchema) && (le.elseIf(this.invalid$data()), this.$dataError(), ee !== s.nil && le.assign(ee, !1)), le.else();
      }
      invalid$data() {
        const { gen: ee, schemaCode: oe, schemaType: le, def: be, it: ke } = this;
        return (0, s.or)(De(), ze());
        function De() {
          if (le.length) {
            if (!(oe instanceof s.Name))
              throw new Error("ajv implementation error");
            const Ue = Array.isArray(le) ? le : [le];
            return (0, s._)`${(0, r.checkDataTypes)(Ue, oe, ke.opts.strictNumbers, r.DataType.Wrong)}`;
          }
          return s.nil;
        }
        function ze() {
          if (be.validateSchema) {
            const Ue = ee.scopeValue("validate$data", { ref: be.validateSchema });
            return (0, s._)`!${Ue}(${oe})`;
          }
          return s.nil;
        }
      }
      subschema(ee, oe) {
        const le = (0, i.getSubschema)(this.it, ee);
        (0, i.extendSubschemaData)(le, this.it, ee), (0, i.extendSubschemaMode)(le, ee);
        const be = { ...this.it, ...le, items: void 0, props: void 0 };
        return k(be, oe), be;
      }
      mergeEvaluated(ee, oe) {
        const { it: le, gen: be } = this;
        le.opts.unevaluated && (le.props !== !0 && ee.props !== void 0 && (le.props = f.mergeEvaluated.props(be, ee.props, le.props, oe)), le.items !== !0 && ee.items !== void 0 && (le.items = f.mergeEvaluated.items(be, ee.items, le.items, oe)));
      }
      mergeValidEvaluated(ee, oe) {
        const { it: le, gen: be } = this;
        if (le.opts.unevaluated && (le.props !== !0 || le.items !== !0))
          return be.if(oe, () => this.mergeEvaluated(ee, s.Name)), !0;
      }
    }
    Ni.KeywordCxt = Q;
    function ne(Z, ee, oe, le) {
      const be = new Q(Z, oe, ee);
      "code" in oe ? oe.code(be, le) : be.$data && oe.validate ? (0, a.funcKeywordCode)(be, oe) : "macro" in oe ? (0, a.macroKeywordCode)(be, oe) : (oe.compile || oe.validate) && (0, a.funcKeywordCode)(be, oe);
    }
    const te = /^\/(?:[^~]|~0|~1)*$/, ae = /^([0-9]+)(#|\/(?:[^~]|~0|~1)*)?$/;
    function ce(Z, { dataLevel: ee, dataNames: oe, dataPathArr: le }) {
      let be, ke;
      if (Z === "")
        return u.default.rootData;
      if (Z[0] === "/") {
        if (!te.test(Z))
          throw new Error(`Invalid JSON-pointer: ${Z}`);
        be = Z, ke = u.default.rootData;
      } else {
        const He = ae.exec(Z);
        if (!He)
          throw new Error(`Invalid JSON-pointer: ${Z}`);
        const Pe = +He[1];
        if (be = He[2], be === "#") {
          if (Pe >= ee)
            throw new Error(Ue("property/index", Pe));
          return le[ee - Pe];
        }
        if (Pe > ee)
          throw new Error(Ue("data", Pe));
        if (ke = oe[ee - Pe], !be)
          return ke;
      }
      let De = ke;
      const ze = be.split("/");
      for (const He of ze)
        He && (ke = (0, s._)`${ke}${(0, s.getProperty)((0, f.unescapeJsonPointer)(He))}`, De = (0, s._)`${De} && ${ke}`);
      return De;
      function Ue(He, Pe) {
        return `Cannot access ${He} ${Pe} levels up, current level is ${ee}`;
      }
    }
    return Ni.getData = ce, Ni;
  }
  var Cv = {}, X4;
  function pO() {
    if (X4) return Cv;
    X4 = 1, Object.defineProperty(Cv, "__esModule", { value: !0 });
    class e extends Error {
      constructor(n) {
        super("validation failed"), this.errors = n, this.ajv = this.validation = !0;
      }
    }
    return Cv.default = e, Cv;
  }
  var Pv = {}, Y4;
  function Sx() {
    if (Y4) return Pv;
    Y4 = 1, Object.defineProperty(Pv, "__esModule", { value: !0 });
    const e = xx();
    class t extends Error {
      constructor(r, o, a, i) {
        super(i || `can't resolve reference ${a} from id ${o}`), this.missingRef = (0, e.resolveUrl)(r, o, a), this.missingSchema = (0, e.normalizeId)((0, e.getFullPath)(r, this.missingRef));
      }
    }
    return Pv.default = t, Pv;
  }
  var no = {}, J4;
  function mO() {
    if (J4) return no;
    J4 = 1, Object.defineProperty(no, "__esModule", { value: !0 }), no.resolveSchema = no.getCompilingSchema = no.resolveRef = no.compileSchema = no.SchemaEnv = void 0;
    const e = mt(), t = pO(), n = gl(), r = xx(), o = Ft(), a = kx();
    class i {
      constructor(w) {
        var _;
        this.refs = {}, this.dynamicAnchors = {};
        let k;
        typeof w.schema == "object" && (k = w.schema), this.schema = w.schema, this.schemaId = w.schemaId, this.root = w.root || this, this.baseId = (_ = w.baseId) !== null && _ !== void 0 ? _ : (0, r.normalizeId)(k?.[w.schemaId || "$id"]), this.schemaPath = w.schemaPath, this.localRefs = w.localRefs, this.meta = w.meta, this.$async = k?.$async, this.refs = {};
      }
    }
    no.SchemaEnv = i;
    function s(v) {
      const w = f.call(this, v);
      if (w)
        return w;
      const _ = (0, r.getFullPath)(this.opts.uriResolver, v.root.baseId), { es5: k, lines: E } = this.opts.code, { ownProperties: P } = this.opts, O = new e.CodeGen(this.scope, { es5: k, lines: E, ownProperties: P });
      let M;
      v.$async && (M = O.scopeValue("Error", {
        ref: t.default,
        code: (0, e._)`require("ajv/dist/runtime/validation_error").default`
      }));
      const I = O.scopeName("validate");
      v.validateName = I;
      const A = {
        gen: O,
        allErrors: this.opts.allErrors,
        data: n.default.data,
        parentData: n.default.parentData,
        parentDataProperty: n.default.parentDataProperty,
        dataNames: [n.default.data],
        dataPathArr: [e.nil],
        // TODO can its length be used as dataLevel if nil is removed?
        dataLevel: 0,
        dataTypes: [],
        definedProperties: /* @__PURE__ */ new Set(),
        topSchemaRef: O.scopeValue("schema", this.opts.code.source === !0 ? { ref: v.schema, code: (0, e.stringify)(v.schema) } : { ref: v.schema }),
        validateName: I,
        ValidationError: M,
        schema: v.schema,
        schemaEnv: v,
        rootId: _,
        baseId: v.baseId || _,
        schemaPath: e.nil,
        errSchemaPath: v.schemaPath || (this.opts.jtd ? "" : "#"),
        errorPath: (0, e._)`""`,
        opts: this.opts,
        self: this
      };
      let D;
      try {
        this._compilations.add(v), (0, a.validateFunctionCode)(A), O.optimize(this.opts.code.optimize);
        const F = O.toString();
        D = `${O.scopeRefs(n.default.scope)}return ${F}`, this.opts.code.process && (D = this.opts.code.process(D, v));
        const j = new Function(`${n.default.self}`, `${n.default.scope}`, D)(this, this.scope.get());
        if (this.scope.value(I, { ref: j }), j.errors = null, j.schema = v.schema, j.schemaEnv = v, v.$async && (j.$async = !0), this.opts.code.source === !0 && (j.source = { validateName: I, validateCode: F, scopeValues: O._values }), this.opts.unevaluated) {
          const { props: U, items: $ } = A;
          j.evaluated = {
            props: U instanceof e.Name ? void 0 : U,
            items: $ instanceof e.Name ? void 0 : $,
            dynamicProps: U instanceof e.Name,
            dynamicItems: $ instanceof e.Name
          }, j.source && (j.source.evaluated = (0, e.stringify)(j.evaluated));
        }
        return v.validate = j, v;
      } catch (F) {
        throw delete v.validate, delete v.validateName, D && this.logger.error("Error compiling schema, function code:", D), F;
      } finally {
        this._compilations.delete(v);
      }
    }
    no.compileSchema = s;
    function u(v, w, _) {
      var k;
      _ = (0, r.resolveUrl)(this.opts.uriResolver, w, _);
      const E = v.refs[_];
      if (E)
        return E;
      let P = g.call(this, v, _);
      if (P === void 0) {
        const O = (k = v.localRefs) === null || k === void 0 ? void 0 : k[_], { schemaId: M } = this.opts;
        O && (P = new i({ schema: O, schemaId: M, root: v, baseId: w }));
      }
      if (P !== void 0)
        return v.refs[_] = c.call(this, P);
    }
    no.resolveRef = u;
    function c(v) {
      return (0, r.inlineRef)(v.schema, this.opts.inlineRefs) ? v.schema : v.validate ? v : s.call(this, v);
    }
    function f(v) {
      for (const w of this._compilations)
        if (p(w, v))
          return w;
    }
    no.getCompilingSchema = f;
    function p(v, w) {
      return v.schema === w.schema && v.root === w.root && v.baseId === w.baseId;
    }
    function g(v, w) {
      let _;
      for (; typeof (_ = this.refs[w]) == "string"; )
        w = _;
      return _ || this.schemas[w] || h.call(this, v, w);
    }
    function h(v, w) {
      const _ = this.opts.uriResolver.parse(w), k = (0, r._getFullPath)(this.opts.uriResolver, _);
      let E = (0, r.getFullPath)(this.opts.uriResolver, v.baseId, void 0);
      if (Object.keys(v.schema).length > 0 && k === E)
        return b.call(this, _, v);
      const P = (0, r.normalizeId)(k), O = this.refs[P] || this.schemas[P];
      if (typeof O == "string") {
        const M = h.call(this, v, O);
        return typeof M?.schema != "object" ? void 0 : b.call(this, _, M);
      }
      if (typeof O?.schema == "object") {
        if (O.validate || s.call(this, O), P === (0, r.normalizeId)(w)) {
          const { schema: M } = O, { schemaId: I } = this.opts, A = M[I];
          return A && (E = (0, r.resolveUrl)(this.opts.uriResolver, E, A)), new i({ schema: M, schemaId: I, root: v, baseId: E });
        }
        return b.call(this, _, O);
      }
    }
    no.resolveSchema = h;
    const y = /* @__PURE__ */ new Set([
      "properties",
      "patternProperties",
      "enum",
      "dependencies",
      "definitions"
    ]);
    function b(v, { baseId: w, schema: _, root: k }) {
      var E;
      if (((E = v.fragment) === null || E === void 0 ? void 0 : E[0]) !== "/")
        return;
      for (const M of v.fragment.slice(1).split("/")) {
        if (typeof _ == "boolean")
          return;
        const I = _[(0, o.unescapeFragment)(M)];
        if (I === void 0)
          return;
        _ = I;
        const A = typeof _ == "object" && _[this.opts.schemaId];
        !y.has(M) && A && (w = (0, r.resolveUrl)(this.opts.uriResolver, w, A));
      }
      let P;
      if (typeof _ != "boolean" && _.$ref && !(0, o.schemaHasRulesButRef)(_, this.RULES)) {
        const M = (0, r.resolveUrl)(this.opts.uriResolver, w, _.$ref);
        P = h.call(this, k, M);
      }
      const { schemaId: O } = this.opts;
      if (P = P || new i({ schema: _, schemaId: O, root: k, baseId: w }), P.schema !== P.root.schema)
        return P;
    }
    return no;
  }
  const DEe = "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#", LEe = "Meta-schema for $data reference (JSON AnySchema extension proposal)", FEe = "object", TEe = ["$data"], zEe = { $data: { type: "string", anyOf: [{ format: "relative-json-pointer" }, { format: "json-pointer" }] } }, BEe = !1, VEe = {
    $id: DEe,
    description: LEe,
    type: FEe,
    required: TEe,
    properties: zEe,
    additionalProperties: BEe
  };
  var Ov = {}, np = { exports: {} }, Q4, Z4;
  function UEe() {
    return Z4 || (Z4 = 1, Q4 = {
      HEX: {
        0: 0,
        1: 1,
        2: 2,
        3: 3,
        4: 4,
        5: 5,
        6: 6,
        7: 7,
        8: 8,
        9: 9,
        a: 10,
        A: 10,
        b: 11,
        B: 11,
        c: 12,
        C: 12,
        d: 13,
        D: 13,
        e: 14,
        E: 14,
        f: 15,
        F: 15
      }
    }), Q4;
  }
  var x0, eD;
  function HEe() {
    if (eD) return x0;
    eD = 1;
    const { HEX: e } = UEe(), t = /^(?:(?:25[0-5]|2[0-4]\d|1\d{2}|[1-9]\d|\d)\.){3}(?:25[0-5]|2[0-4]\d|1\d{2}|[1-9]\d|\d)$/u;
    function n(b) {
      if (s(b, ".") < 3)
        return { host: b, isIPV4: !1 };
      const v = b.match(t) || [], [w] = v;
      return w ? { host: i(w, "."), isIPV4: !0 } : { host: b, isIPV4: !1 };
    }
    function r(b, v = !1) {
      let w = "", _ = !0;
      for (const k of b) {
        if (e[k] === void 0) return;
        k !== "0" && _ === !0 && (_ = !1), _ || (w += k);
      }
      return v && w.length === 0 && (w = "0"), w;
    }
    function o(b) {
      let v = 0;
      const w = { error: !1, address: "", zone: "" }, _ = [], k = [];
      let E = !1, P = !1, O = !1;
      function M() {
        if (k.length) {
          if (E === !1) {
            const I = r(k);
            if (I !== void 0)
              _.push(I);
            else
              return w.error = !0, !1;
          }
          k.length = 0;
        }
        return !0;
      }
      for (let I = 0; I < b.length; I++) {
        const A = b[I];
        if (!(A === "[" || A === "]"))
          if (A === ":") {
            if (P === !0 && (O = !0), !M())
              break;
            if (v++, _.push(":"), v > 7) {
              w.error = !0;
              break;
            }
            I - 1 >= 0 && b[I - 1] === ":" && (P = !0);
            continue;
          } else if (A === "%") {
            if (!M())
              break;
            E = !0;
          } else {
            k.push(A);
            continue;
          }
      }
      return k.length && (E ? w.zone = k.join("") : O ? _.push(k.join("")) : _.push(r(k))), w.address = _.join(""), w;
    }
    function a(b) {
      if (s(b, ":") < 2)
        return { host: b, isIPV6: !1 };
      const v = o(b);
      if (v.error)
        return { host: b, isIPV6: !1 };
      {
        let w = v.address, _ = v.address;
        return v.zone && (w += "%" + v.zone, _ += "%25" + v.zone), { host: w, escapedHost: _, isIPV6: !0 };
      }
    }
    function i(b, v) {
      let w = "", _ = !0;
      const k = b.length;
      for (let E = 0; E < k; E++) {
        const P = b[E];
        P === "0" && _ ? (E + 1 <= k && b[E + 1] === v || E + 1 === k) && (w += P, _ = !1) : (P === v ? _ = !0 : _ = !1, w += P);
      }
      return w;
    }
    function s(b, v) {
      let w = 0;
      for (let _ = 0; _ < b.length; _++)
        b[_] === v && w++;
      return w;
    }
    const u = /^\.\.?\//u, c = /^\/\.(?:\/|$)/u, f = /^\/\.\.(?:\/|$)/u, p = /^\/?(?:.|\n)*?(?=\/|$)/u;
    function g(b) {
      const v = [];
      for (; b.length; )
        if (b.match(u))
          b = b.replace(u, "");
        else if (b.match(c))
          b = b.replace(c, "/");
        else if (b.match(f))
          b = b.replace(f, "/"), v.pop();
        else if (b === "." || b === "..")
          b = "";
        else {
          const w = b.match(p);
          if (w) {
            const _ = w[0];
            b = b.slice(_.length), v.push(_);
          } else
            throw new Error("Unexpected dot segment condition");
        }
      return v.join("");
    }
    function h(b, v) {
      const w = v !== !0 ? escape : unescape;
      return b.scheme !== void 0 && (b.scheme = w(b.scheme)), b.userinfo !== void 0 && (b.userinfo = w(b.userinfo)), b.host !== void 0 && (b.host = w(b.host)), b.path !== void 0 && (b.path = w(b.path)), b.query !== void 0 && (b.query = w(b.query)), b.fragment !== void 0 && (b.fragment = w(b.fragment)), b;
    }
    function y(b) {
      const v = [];
      if (b.userinfo !== void 0 && (v.push(b.userinfo), v.push("@")), b.host !== void 0) {
        let w = unescape(b.host);
        const _ = n(w);
        if (_.isIPV4)
          w = _.host;
        else {
          const k = a(_.host);
          k.isIPV6 === !0 ? w = `[${k.escapedHost}]` : w = b.host;
        }
        v.push(w);
      }
      return (typeof b.port == "number" || typeof b.port == "string") && (v.push(":"), v.push(String(b.port))), v.length ? v.join("") : void 0;
    }
    return x0 = {
      recomposeAuthority: y,
      normalizeComponentEncoding: h,
      removeDotSegments: g,
      normalizeIPv4: n,
      normalizeIPv6: a,
      stringArrayToHexStripped: r
    }, x0;
  }
  var k0, tD;
  function WEe() {
    if (tD) return k0;
    tD = 1;
    const e = /^[\da-f]{8}-[\da-f]{4}-[\da-f]{4}-[\da-f]{4}-[\da-f]{12}$/iu, t = /([\da-z][\d\-a-z]{0,31}):((?:[\w!$'()*+,\-.:;=@]|%[\da-f]{2})+)/iu;
    function n(v) {
      return typeof v.secure == "boolean" ? v.secure : String(v.scheme).toLowerCase() === "wss";
    }
    function r(v) {
      return v.host || (v.error = v.error || "HTTP URIs must have a host."), v;
    }
    function o(v) {
      const w = String(v.scheme).toLowerCase() === "https";
      return (v.port === (w ? 443 : 80) || v.port === "") && (v.port = void 0), v.path || (v.path = "/"), v;
    }
    function a(v) {
      return v.secure = n(v), v.resourceName = (v.path || "/") + (v.query ? "?" + v.query : ""), v.path = void 0, v.query = void 0, v;
    }
    function i(v) {
      if ((v.port === (n(v) ? 443 : 80) || v.port === "") && (v.port = void 0), typeof v.secure == "boolean" && (v.scheme = v.secure ? "wss" : "ws", v.secure = void 0), v.resourceName) {
        const [w, _] = v.resourceName.split("?");
        v.path = w && w !== "/" ? w : void 0, v.query = _, v.resourceName = void 0;
      }
      return v.fragment = void 0, v;
    }
    function s(v, w) {
      if (!v.path)
        return v.error = "URN can not be parsed", v;
      const _ = v.path.match(t);
      if (_) {
        const k = w.scheme || v.scheme || "urn";
        v.nid = _[1].toLowerCase(), v.nss = _[2];
        const E = `${k}:${w.nid || v.nid}`, P = b[E];
        v.path = void 0, P && (v = P.parse(v, w));
      } else
        v.error = v.error || "URN can not be parsed.";
      return v;
    }
    function u(v, w) {
      const _ = w.scheme || v.scheme || "urn", k = v.nid.toLowerCase(), E = `${_}:${w.nid || k}`, P = b[E];
      P && (v = P.serialize(v, w));
      const O = v, M = v.nss;
      return O.path = `${k || w.nid}:${M}`, w.skipEscape = !0, O;
    }
    function c(v, w) {
      const _ = v;
      return _.uuid = _.nss, _.nss = void 0, !w.tolerant && (!_.uuid || !e.test(_.uuid)) && (_.error = _.error || "UUID is not valid."), _;
    }
    function f(v) {
      const w = v;
      return w.nss = (v.uuid || "").toLowerCase(), w;
    }
    const p = {
      scheme: "http",
      domainHost: !0,
      parse: r,
      serialize: o
    }, g = {
      scheme: "https",
      domainHost: p.domainHost,
      parse: r,
      serialize: o
    }, h = {
      scheme: "ws",
      domainHost: !0,
      parse: a,
      serialize: i
    }, y = {
      scheme: "wss",
      domainHost: h.domainHost,
      parse: h.parse,
      serialize: h.serialize
    }, b = {
      http: p,
      https: g,
      ws: h,
      wss: y,
      urn: {
        scheme: "urn",
        parse: s,
        serialize: u,
        skipNormalize: !0
      },
      "urn:uuid": {
        scheme: "urn:uuid",
        parse: c,
        serialize: f,
        skipNormalize: !0
      }
    };
    return k0 = b, k0;
  }
  var nD;
  function qEe() {
    if (nD) return np.exports;
    nD = 1;
    const { normalizeIPv6: e, normalizeIPv4: t, removeDotSegments: n, recomposeAuthority: r, normalizeComponentEncoding: o } = HEe(), a = WEe();
    function i(v, w) {
      return typeof v == "string" ? v = f(y(v, w), w) : typeof v == "object" && (v = y(f(v, w), w)), v;
    }
    function s(v, w, _) {
      const k = Object.assign({ scheme: "null" }, _), E = u(y(v, k), y(w, k), k, !0);
      return f(E, { ...k, skipEscape: !0 });
    }
    function u(v, w, _, k) {
      const E = {};
      return k || (v = y(f(v, _), _), w = y(f(w, _), _)), _ = _ || {}, !_.tolerant && w.scheme ? (E.scheme = w.scheme, E.userinfo = w.userinfo, E.host = w.host, E.port = w.port, E.path = n(w.path || ""), E.query = w.query) : (w.userinfo !== void 0 || w.host !== void 0 || w.port !== void 0 ? (E.userinfo = w.userinfo, E.host = w.host, E.port = w.port, E.path = n(w.path || ""), E.query = w.query) : (w.path ? (w.path.charAt(0) === "/" ? E.path = n(w.path) : ((v.userinfo !== void 0 || v.host !== void 0 || v.port !== void 0) && !v.path ? E.path = "/" + w.path : v.path ? E.path = v.path.slice(0, v.path.lastIndexOf("/") + 1) + w.path : E.path = w.path, E.path = n(E.path)), E.query = w.query) : (E.path = v.path, w.query !== void 0 ? E.query = w.query : E.query = v.query), E.userinfo = v.userinfo, E.host = v.host, E.port = v.port), E.scheme = v.scheme), E.fragment = w.fragment, E;
    }
    function c(v, w, _) {
      return typeof v == "string" ? (v = unescape(v), v = f(o(y(v, _), !0), { ..._, skipEscape: !0 })) : typeof v == "object" && (v = f(o(v, !0), { ..._, skipEscape: !0 })), typeof w == "string" ? (w = unescape(w), w = f(o(y(w, _), !0), { ..._, skipEscape: !0 })) : typeof w == "object" && (w = f(o(w, !0), { ..._, skipEscape: !0 })), v.toLowerCase() === w.toLowerCase();
    }
    function f(v, w) {
      const _ = {
        host: v.host,
        scheme: v.scheme,
        userinfo: v.userinfo,
        port: v.port,
        path: v.path,
        query: v.query,
        nid: v.nid,
        nss: v.nss,
        uuid: v.uuid,
        fragment: v.fragment,
        reference: v.reference,
        resourceName: v.resourceName,
        secure: v.secure,
        error: ""
      }, k = Object.assign({}, w), E = [], P = a[(k.scheme || _.scheme || "").toLowerCase()];
      P && P.serialize && P.serialize(_, k), _.path !== void 0 && (k.skipEscape ? _.path = unescape(_.path) : (_.path = escape(_.path), _.scheme !== void 0 && (_.path = _.path.split("%3A").join(":")))), k.reference !== "suffix" && _.scheme && E.push(_.scheme, ":");
      const O = r(_);
      if (O !== void 0 && (k.reference !== "suffix" && E.push("//"), E.push(O), _.path && _.path.charAt(0) !== "/" && E.push("/")), _.path !== void 0) {
        let M = _.path;
        !k.absolutePath && (!P || !P.absolutePath) && (M = n(M)), O === void 0 && (M = M.replace(/^\/\//u, "/%2F")), E.push(M);
      }
      return _.query !== void 0 && E.push("?", _.query), _.fragment !== void 0 && E.push("#", _.fragment), E.join("");
    }
    const p = Array.from({ length: 127 }, (v, w) => /[^!"$&'()*+,\-.;=_`a-z{}~]/u.test(String.fromCharCode(w)));
    function g(v) {
      let w = 0;
      for (let _ = 0, k = v.length; _ < k; ++_)
        if (w = v.charCodeAt(_), w > 126 || p[w])
          return !0;
      return !1;
    }
    const h = /^(?:([^#/:?]+):)?(?:\/\/((?:([^#/?@]*)@)?(\[[^#/?\]]+\]|[^#/:?]*)(?::(\d*))?))?([^#?]*)(?:\?([^#]*))?(?:#((?:.|[\n\r])*))?/u;
    function y(v, w) {
      const _ = Object.assign({}, w), k = {
        scheme: void 0,
        userinfo: void 0,
        host: "",
        port: void 0,
        path: "",
        query: void 0,
        fragment: void 0
      }, E = v.indexOf("%") !== -1;
      let P = !1;
      _.reference === "suffix" && (v = (_.scheme ? _.scheme + ":" : "") + "//" + v);
      const O = v.match(h);
      if (O) {
        if (k.scheme = O[1], k.userinfo = O[3], k.host = O[4], k.port = parseInt(O[5], 10), k.path = O[6] || "", k.query = O[7], k.fragment = O[8], isNaN(k.port) && (k.port = O[5]), k.host) {
          const I = t(k.host);
          if (I.isIPV4 === !1) {
            const A = e(I.host);
            k.host = A.host.toLowerCase(), P = A.isIPV6;
          } else
            k.host = I.host, P = !0;
        }
        k.scheme === void 0 && k.userinfo === void 0 && k.host === void 0 && k.port === void 0 && k.query === void 0 && !k.path ? k.reference = "same-document" : k.scheme === void 0 ? k.reference = "relative" : k.fragment === void 0 ? k.reference = "absolute" : k.reference = "uri", _.reference && _.reference !== "suffix" && _.reference !== k.reference && (k.error = k.error || "URI is not a " + _.reference + " reference.");
        const M = a[(_.scheme || k.scheme || "").toLowerCase()];
        if (!_.unicodeSupport && (!M || !M.unicodeSupport) && k.host && (_.domainHost || M && M.domainHost) && P === !1 && g(k.host))
          try {
            k.host = URL.domainToASCII(k.host.toLowerCase());
          } catch (I) {
            k.error = k.error || "Host's domain name can not be converted to ASCII: " + I;
          }
        (!M || M && !M.skipNormalize) && (E && k.scheme !== void 0 && (k.scheme = unescape(k.scheme)), E && k.host !== void 0 && (k.host = unescape(k.host)), k.path && (k.path = escape(unescape(k.path))), k.fragment && (k.fragment = encodeURI(decodeURIComponent(k.fragment)))), M && M.parse && M.parse(k, _);
      } else
        k.error = k.error || "URI can not be parsed.";
      return k;
    }
    const b = {
      SCHEMES: a,
      normalize: i,
      resolve: s,
      resolveComponents: u,
      equal: c,
      serialize: f,
      parse: y
    };
    return np.exports = b, np.exports.default = b, np.exports.fastUri = b, np.exports;
  }
  var rD;
  function KEe() {
    if (rD) return Ov;
    rD = 1, Object.defineProperty(Ov, "__esModule", { value: !0 });
    const e = qEe();
    return e.code = 'require("ajv/dist/runtime/uri").default', Ov.default = e, Ov;
  }
  var oD;
  function GEe() {
    return oD || (oD = 1, (function(e) {
      Object.defineProperty(e, "__esModule", { value: !0 }), e.CodeGen = e.Name = e.nil = e.stringify = e.str = e._ = e.KeywordCxt = void 0;
      var t = kx();
      Object.defineProperty(e, "KeywordCxt", { enumerable: !0, get: function() {
        return t.KeywordCxt;
      } });
      var n = mt();
      Object.defineProperty(e, "_", { enumerable: !0, get: function() {
        return n._;
      } }), Object.defineProperty(e, "str", { enumerable: !0, get: function() {
        return n.str;
      } }), Object.defineProperty(e, "stringify", { enumerable: !0, get: function() {
        return n.stringify;
      } }), Object.defineProperty(e, "nil", { enumerable: !0, get: function() {
        return n.nil;
      } }), Object.defineProperty(e, "Name", { enumerable: !0, get: function() {
        return n.Name;
      } }), Object.defineProperty(e, "CodeGen", { enumerable: !0, get: function() {
        return n.CodeGen;
      } });
      const r = pO(), o = Sx(), a = P1(), i = mO(), s = mt(), u = xx(), c = zb(), f = Ft(), p = VEe, g = KEe(), h = (z, L) => new RegExp(z, L);
      h.code = "new RegExp";
      const y = ["removeAdditional", "useDefaults", "coerceTypes"], b = /* @__PURE__ */ new Set([
        "validate",
        "serialize",
        "parse",
        "wrapper",
        "root",
        "schema",
        "keyword",
        "pattern",
        "formats",
        "validate$data",
        "func",
        "obj",
        "Error"
      ]), v = {
        errorDataPath: "",
        format: "`validateFormats: false` can be used instead.",
        nullable: '"nullable" keyword is supported by default.',
        jsonPointers: "Deprecated jsPropertySyntax can be used instead.",
        extendRefs: "Deprecated ignoreKeywordsWithRef can be used instead.",
        missingRefs: "Pass empty schema with $id that should be ignored to ajv.addSchema.",
        processCode: "Use option `code: {process: (code, schemaEnv: object) => string}`",
        sourceCode: "Use option `code: {source: true}`",
        strictDefaults: "It is default now, see option `strict`.",
        strictKeywords: "It is default now, see option `strict`.",
        uniqueItems: '"uniqueItems" keyword is always validated.',
        unknownFormats: "Disable strict mode or pass `true` to `ajv.addFormat` (or `formats` option).",
        cache: "Map is used as cache, schema object as key.",
        serialize: "Map is used as cache, schema object as key.",
        ajvErrors: "It is default now."
      }, w = {
        ignoreKeywordsWithRef: "",
        jsPropertySyntax: "",
        unicode: '"minLength"/"maxLength" account for unicode characters by default.'
      }, _ = 200;
      function k(z) {
        var L, K, T, V, X, Q, ne, te, ae, ce, Z, ee, oe, le, be, ke, De, ze, Ue, He, Pe, It, Xe, Ee, _e;
        const ie = z.strict, me = (L = z.code) === null || L === void 0 ? void 0 : L.optimize, Se = me === !0 || me === void 0 ? 1 : me || 0, je = (T = (K = z.code) === null || K === void 0 ? void 0 : K.regExp) !== null && T !== void 0 ? T : h, Ae = (V = z.uriResolver) !== null && V !== void 0 ? V : g.default;
        return {
          strictSchema: (Q = (X = z.strictSchema) !== null && X !== void 0 ? X : ie) !== null && Q !== void 0 ? Q : !0,
          strictNumbers: (te = (ne = z.strictNumbers) !== null && ne !== void 0 ? ne : ie) !== null && te !== void 0 ? te : !0,
          strictTypes: (ce = (ae = z.strictTypes) !== null && ae !== void 0 ? ae : ie) !== null && ce !== void 0 ? ce : "log",
          strictTuples: (ee = (Z = z.strictTuples) !== null && Z !== void 0 ? Z : ie) !== null && ee !== void 0 ? ee : "log",
          strictRequired: (le = (oe = z.strictRequired) !== null && oe !== void 0 ? oe : ie) !== null && le !== void 0 ? le : !1,
          code: z.code ? { ...z.code, optimize: Se, regExp: je } : { optimize: Se, regExp: je },
          loopRequired: (be = z.loopRequired) !== null && be !== void 0 ? be : _,
          loopEnum: (ke = z.loopEnum) !== null && ke !== void 0 ? ke : _,
          meta: (De = z.meta) !== null && De !== void 0 ? De : !0,
          messages: (ze = z.messages) !== null && ze !== void 0 ? ze : !0,
          inlineRefs: (Ue = z.inlineRefs) !== null && Ue !== void 0 ? Ue : !0,
          schemaId: (He = z.schemaId) !== null && He !== void 0 ? He : "$id",
          addUsedSchema: (Pe = z.addUsedSchema) !== null && Pe !== void 0 ? Pe : !0,
          validateSchema: (It = z.validateSchema) !== null && It !== void 0 ? It : !0,
          validateFormats: (Xe = z.validateFormats) !== null && Xe !== void 0 ? Xe : !0,
          unicodeRegExp: (Ee = z.unicodeRegExp) !== null && Ee !== void 0 ? Ee : !0,
          int32range: (_e = z.int32range) !== null && _e !== void 0 ? _e : !0,
          uriResolver: Ae
        };
      }
      class E {
        constructor(L = {}) {
          this.schemas = {}, this.refs = {}, this.formats = {}, this._compilations = /* @__PURE__ */ new Set(), this._loading = {}, this._cache = /* @__PURE__ */ new Map(), L = this.opts = { ...L, ...k(L) };
          const { es5: K, lines: T } = this.opts.code;
          this.scope = new s.ValueScope({ scope: {}, prefixes: b, es5: K, lines: T }), this.logger = j(L.logger);
          const V = L.validateFormats;
          L.validateFormats = !1, this.RULES = (0, a.getRules)(), P.call(this, v, L, "NOT SUPPORTED"), P.call(this, w, L, "DEPRECATED", "warn"), this._metaOpts = D.call(this), L.formats && I.call(this), this._addVocabularies(), this._addDefaultMetaSchema(), L.keywords && A.call(this, L.keywords), typeof L.meta == "object" && this.addMetaSchema(L.meta), M.call(this), L.validateFormats = V;
        }
        _addVocabularies() {
          this.addKeyword("$async");
        }
        _addDefaultMetaSchema() {
          const { $data: L, meta: K, schemaId: T } = this.opts;
          let V = p;
          T === "id" && (V = { ...p }, V.id = V.$id, delete V.$id), K && L && this.addMetaSchema(V, V[T], !1);
        }
        defaultMeta() {
          const { meta: L, schemaId: K } = this.opts;
          return this.opts.defaultMeta = typeof L == "object" ? L[K] || L : void 0;
        }
        validate(L, K) {
          let T;
          if (typeof L == "string") {
            if (T = this.getSchema(L), !T)
              throw new Error(`no schema with key or ref "${L}"`);
          } else
            T = this.compile(L);
          const V = T(K);
          return "$async" in T || (this.errors = T.errors), V;
        }
        compile(L, K) {
          const T = this._addSchema(L, K);
          return T.validate || this._compileSchemaEnv(T);
        }
        compileAsync(L, K) {
          if (typeof this.opts.loadSchema != "function")
            throw new Error("options.loadSchema should be a function");
          const { loadSchema: T } = this.opts;
          return V.call(this, L, K);
          async function V(ce, Z) {
            await X.call(this, ce.$schema);
            const ee = this._addSchema(ce, Z);
            return ee.validate || Q.call(this, ee);
          }
          async function X(ce) {
            ce && !this.getSchema(ce) && await V.call(this, { $ref: ce }, !0);
          }
          async function Q(ce) {
            try {
              return this._compileSchemaEnv(ce);
            } catch (Z) {
              if (!(Z instanceof o.default))
                throw Z;
              return ne.call(this, Z), await te.call(this, Z.missingSchema), Q.call(this, ce);
            }
          }
          function ne({ missingSchema: ce, missingRef: Z }) {
            if (this.refs[ce])
              throw new Error(`AnySchema ${ce} is loaded but ${Z} cannot be resolved`);
          }
          async function te(ce) {
            const Z = await ae.call(this, ce);
            this.refs[ce] || await X.call(this, Z.$schema), this.refs[ce] || this.addSchema(Z, ce, K);
          }
          async function ae(ce) {
            const Z = this._loading[ce];
            if (Z)
              return Z;
            try {
              return await (this._loading[ce] = T(ce));
            } finally {
              delete this._loading[ce];
            }
          }
        }
        // Adds schema to the instance
        addSchema(L, K, T, V = this.opts.validateSchema) {
          if (Array.isArray(L)) {
            for (const Q of L)
              this.addSchema(Q, void 0, T, V);
            return this;
          }
          let X;
          if (typeof L == "object") {
            const { schemaId: Q } = this.opts;
            if (X = L[Q], X !== void 0 && typeof X != "string")
              throw new Error(`schema ${Q} must be string`);
          }
          return K = (0, u.normalizeId)(K || X), this._checkUnique(K), this.schemas[K] = this._addSchema(L, T, K, V, !0), this;
        }
        // Add schema that will be used to validate other schemas
        // options in META_IGNORE_OPTIONS are alway set to false
        addMetaSchema(L, K, T = this.opts.validateSchema) {
          return this.addSchema(L, K, !0, T), this;
        }
        //  Validate schema against its meta-schema
        validateSchema(L, K) {
          if (typeof L == "boolean")
            return !0;
          let T;
          if (T = L.$schema, T !== void 0 && typeof T != "string")
            throw new Error("$schema must be a string");
          if (T = T || this.opts.defaultMeta || this.defaultMeta(), !T)
            return this.logger.warn("meta-schema not available"), this.errors = null, !0;
          const V = this.validate(T, L);
          if (!V && K) {
            const X = "schema is invalid: " + this.errorsText();
            if (this.opts.validateSchema === "log")
              this.logger.error(X);
            else
              throw new Error(X);
          }
          return V;
        }
        // Get compiled schema by `key` or `ref`.
        // (`key` that was passed to `addSchema` or full schema reference - `schema.$id` or resolved id)
        getSchema(L) {
          let K;
          for (; typeof (K = O.call(this, L)) == "string"; )
            L = K;
          if (K === void 0) {
            const { schemaId: T } = this.opts, V = new i.SchemaEnv({ schema: {}, schemaId: T });
            if (K = i.resolveSchema.call(this, V, L), !K)
              return;
            this.refs[L] = K;
          }
          return K.validate || this._compileSchemaEnv(K);
        }
        // Remove cached schema(s).
        // If no parameter is passed all schemas but meta-schemas are removed.
        // If RegExp is passed all schemas with key/id matching pattern but meta-schemas are removed.
        // Even if schema is referenced by other schemas it still can be removed as other schemas have local references.
        removeSchema(L) {
          if (L instanceof RegExp)
            return this._removeAllSchemas(this.schemas, L), this._removeAllSchemas(this.refs, L), this;
          switch (typeof L) {
            case "undefined":
              return this._removeAllSchemas(this.schemas), this._removeAllSchemas(this.refs), this._cache.clear(), this;
            case "string": {
              const K = O.call(this, L);
              return typeof K == "object" && this._cache.delete(K.schema), delete this.schemas[L], delete this.refs[L], this;
            }
            case "object": {
              const K = L;
              this._cache.delete(K);
              let T = L[this.opts.schemaId];
              return T && (T = (0, u.normalizeId)(T), delete this.schemas[T], delete this.refs[T]), this;
            }
            default:
              throw new Error("ajv.removeSchema: invalid parameter");
          }
        }
        // add "vocabulary" - a collection of keywords
        addVocabulary(L) {
          for (const K of L)
            this.addKeyword(K);
          return this;
        }
        addKeyword(L, K) {
          let T;
          if (typeof L == "string")
            T = L, typeof K == "object" && (this.logger.warn("these parameters are deprecated, see docs for addKeyword"), K.keyword = T);
          else if (typeof L == "object" && K === void 0) {
            if (K = L, T = K.keyword, Array.isArray(T) && !T.length)
              throw new Error("addKeywords: keyword must be string or non-empty array");
          } else
            throw new Error("invalid addKeywords parameters");
          if ($.call(this, T, K), !K)
            return (0, f.eachItem)(T, (X) => q.call(this, X)), this;
          G.call(this, K);
          const V = {
            ...K,
            type: (0, c.getJSONTypes)(K.type),
            schemaType: (0, c.getJSONTypes)(K.schemaType)
          };
          return (0, f.eachItem)(T, V.type.length === 0 ? (X) => q.call(this, X, V) : (X) => V.type.forEach((Q) => q.call(this, X, V, Q))), this;
        }
        getKeyword(L) {
          const K = this.RULES.all[L];
          return typeof K == "object" ? K.definition : !!K;
        }
        // Remove keyword
        removeKeyword(L) {
          const { RULES: K } = this;
          delete K.keywords[L], delete K.all[L];
          for (const T of K.rules) {
            const V = T.rules.findIndex((X) => X.keyword === L);
            V >= 0 && T.rules.splice(V, 1);
          }
          return this;
        }
        // Add format
        addFormat(L, K) {
          return typeof K == "string" && (K = new RegExp(K)), this.formats[L] = K, this;
        }
        errorsText(L = this.errors, { separator: K = ", ", dataVar: T = "data" } = {}) {
          return !L || L.length === 0 ? "No errors" : L.map((V) => `${T}${V.instancePath} ${V.message}`).reduce((V, X) => V + K + X);
        }
        $dataMetaSchema(L, K) {
          const T = this.RULES.all;
          L = JSON.parse(JSON.stringify(L));
          for (const V of K) {
            const X = V.split("/").slice(1);
            let Q = L;
            for (const ne of X)
              Q = Q[ne];
            for (const ne in T) {
              const te = T[ne];
              if (typeof te != "object")
                continue;
              const { $data: ae } = te.definition, ce = Q[ne];
              ae && ce && (Q[ne] = Y(ce));
            }
          }
          return L;
        }
        _removeAllSchemas(L, K) {
          for (const T in L) {
            const V = L[T];
            (!K || K.test(T)) && (typeof V == "string" ? delete L[T] : V && !V.meta && (this._cache.delete(V.schema), delete L[T]));
          }
        }
        _addSchema(L, K, T, V = this.opts.validateSchema, X = this.opts.addUsedSchema) {
          let Q;
          const { schemaId: ne } = this.opts;
          if (typeof L == "object")
            Q = L[ne];
          else {
            if (this.opts.jtd)
              throw new Error("schema must be object");
            if (typeof L != "boolean")
              throw new Error("schema must be object or boolean");
          }
          let te = this._cache.get(L);
          if (te !== void 0)
            return te;
          T = (0, u.normalizeId)(Q || T);
          const ae = u.getSchemaRefs.call(this, L, T);
          return te = new i.SchemaEnv({ schema: L, schemaId: ne, meta: K, baseId: T, localRefs: ae }), this._cache.set(te.schema, te), X && !T.startsWith("#") && (T && this._checkUnique(T), this.refs[T] = te), V && this.validateSchema(L, !0), te;
        }
        _checkUnique(L) {
          if (this.schemas[L] || this.refs[L])
            throw new Error(`schema with key or id "${L}" already exists`);
        }
        _compileSchemaEnv(L) {
          if (L.meta ? this._compileMetaSchema(L) : i.compileSchema.call(this, L), !L.validate)
            throw new Error("ajv implementation error");
          return L.validate;
        }
        _compileMetaSchema(L) {
          const K = this.opts;
          this.opts = this._metaOpts;
          try {
            i.compileSchema.call(this, L);
          } finally {
            this.opts = K;
          }
        }
      }
      E.ValidationError = r.default, E.MissingRefError = o.default, e.default = E;
      function P(z, L, K, T = "error") {
        for (const V in z) {
          const X = V;
          X in L && this.logger[T](`${K}: option ${V}. ${z[X]}`);
        }
      }
      function O(z) {
        return z = (0, u.normalizeId)(z), this.schemas[z] || this.refs[z];
      }
      function M() {
        const z = this.opts.schemas;
        if (z)
          if (Array.isArray(z))
            this.addSchema(z);
          else
            for (const L in z)
              this.addSchema(z[L], L);
      }
      function I() {
        for (const z in this.opts.formats) {
          const L = this.opts.formats[z];
          L && this.addFormat(z, L);
        }
      }
      function A(z) {
        if (Array.isArray(z)) {
          this.addVocabulary(z);
          return;
        }
        this.logger.warn("keywords option as map is deprecated, pass array");
        for (const L in z) {
          const K = z[L];
          K.keyword || (K.keyword = L), this.addKeyword(K);
        }
      }
      function D() {
        const z = { ...this.opts };
        for (const L of y)
          delete z[L];
        return z;
      }
      const F = { log() {
      }, warn() {
      }, error() {
      } };
      function j(z) {
        if (z === !1)
          return F;
        if (z === void 0)
          return console;
        if (z.log && z.warn && z.error)
          return z;
        throw new Error("logger must implement log, warn and error methods");
      }
      const U = /^[a-z_$][a-z0-9_$:-]*$/i;
      function $(z, L) {
        const { RULES: K } = this;
        if ((0, f.eachItem)(z, (T) => {
          if (K.keywords[T])
            throw new Error(`Keyword ${T} is already defined`);
          if (!U.test(T))
            throw new Error(`Keyword ${T} has invalid name`);
        }), !!L && L.$data && !("code" in L || "validate" in L))
          throw new Error('$data keyword must have "code" or "validate" function');
      }
      function q(z, L, K) {
        var T;
        const V = L?.post;
        if (K && V)
          throw new Error('keyword with "post" flag cannot have "type"');
        const { RULES: X } = this;
        let Q = V ? X.post : X.rules.find(({ type: te }) => te === K);
        if (Q || (Q = { type: K, rules: [] }, X.rules.push(Q)), X.keywords[z] = !0, !L)
          return;
        const ne = {
          keyword: z,
          definition: {
            ...L,
            type: (0, c.getJSONTypes)(L.type),
            schemaType: (0, c.getJSONTypes)(L.schemaType)
          }
        };
        L.before ? B.call(this, Q, ne, L.before) : Q.rules.push(ne), X.all[z] = ne, (T = L.implements) === null || T === void 0 || T.forEach((te) => this.addKeyword(te));
      }
      function B(z, L, K) {
        const T = z.rules.findIndex((V) => V.keyword === K);
        T >= 0 ? z.rules.splice(T, 0, L) : (z.rules.push(L), this.logger.warn(`rule ${K} is not defined`));
      }
      function G(z) {
        let { metaSchema: L } = z;
        L !== void 0 && (z.$data && this.opts.$data && (L = Y(L)), z.validateSchema = this.compile(L, !0));
      }
      const W = {
        $ref: "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#"
      };
      function Y(z) {
        return { anyOf: [z, W] };
      }
    })(_4)), _4;
  }
  var Nv = {}, Mv = {}, Rv = {}, aD;
  function XEe() {
    if (aD) return Rv;
    aD = 1, Object.defineProperty(Rv, "__esModule", { value: !0 });
    const e = {
      keyword: "id",
      code() {
        throw new Error('NOT SUPPORTED: keyword "id", use "$id" for schema ID');
      }
    };
    return Rv.default = e, Rv;
  }
  var Fs = {}, iD;
  function YEe() {
    if (iD) return Fs;
    iD = 1, Object.defineProperty(Fs, "__esModule", { value: !0 }), Fs.callRef = Fs.getValidate = void 0;
    const e = Sx(), t = ca(), n = mt(), r = gl(), o = mO(), a = Ft(), i = {
      keyword: "$ref",
      schemaType: "string",
      code(c) {
        const { gen: f, schema: p, it: g } = c, { baseId: h, schemaEnv: y, validateName: b, opts: v, self: w } = g, { root: _ } = y;
        if ((p === "#" || p === "#/") && h === _.baseId)
          return E();
        const k = o.resolveRef.call(w, _, h, p);
        if (k === void 0)
          throw new e.default(g.opts.uriResolver, h, p);
        if (k instanceof o.SchemaEnv)
          return P(k);
        return O(k);
        function E() {
          if (y === _)
            return u(c, b, y, y.$async);
          const M = f.scopeValue("root", { ref: _ });
          return u(c, (0, n._)`${M}.validate`, _, _.$async);
        }
        function P(M) {
          const I = s(c, M);
          u(c, I, M, M.$async);
        }
        function O(M) {
          const I = f.scopeValue("schema", v.code.source === !0 ? { ref: M, code: (0, n.stringify)(M) } : { ref: M }), A = f.name("valid"), D = c.subschema({
            schema: M,
            dataTypes: [],
            schemaPath: n.nil,
            topSchemaRef: I,
            errSchemaPath: p
          }, A);
          c.mergeEvaluated(D), c.ok(A);
        }
      }
    };
    function s(c, f) {
      const { gen: p } = c;
      return f.validate ? p.scopeValue("validate", { ref: f.validate }) : (0, n._)`${p.scopeValue("wrapper", { ref: f })}.validate`;
    }
    Fs.getValidate = s;
    function u(c, f, p, g) {
      const { gen: h, it: y } = c, { allErrors: b, schemaEnv: v, opts: w } = y, _ = w.passContext ? r.default.this : n.nil;
      g ? k() : E();
      function k() {
        if (!v.$async)
          throw new Error("async schema referenced by sync schema");
        const M = h.let("valid");
        h.try(() => {
          h.code((0, n._)`await ${(0, t.callValidateCode)(c, f, _)}`), O(f), b || h.assign(M, !0);
        }, (I) => {
          h.if((0, n._)`!(${I} instanceof ${y.ValidationError})`, () => h.throw(I)), P(I), b || h.assign(M, !1);
        }), c.ok(M);
      }
      function E() {
        c.result((0, t.callValidateCode)(c, f, _), () => O(f), () => P(f));
      }
      function P(M) {
        const I = (0, n._)`${M}.errors`;
        h.assign(r.default.vErrors, (0, n._)`${r.default.vErrors} === null ? ${I} : ${r.default.vErrors}.concat(${I})`), h.assign(r.default.errors, (0, n._)`${r.default.vErrors}.length`);
      }
      function O(M) {
        var I;
        if (!y.opts.unevaluated)
          return;
        const A = (I = p?.validate) === null || I === void 0 ? void 0 : I.evaluated;
        if (y.props !== !0)
          if (A && !A.dynamicProps)
            A.props !== void 0 && (y.props = a.mergeEvaluated.props(h, A.props, y.props));
          else {
            const D = h.var("props", (0, n._)`${M}.evaluated.props`);
            y.props = a.mergeEvaluated.props(h, D, y.props, n.Name);
          }
        if (y.items !== !0)
          if (A && !A.dynamicItems)
            A.items !== void 0 && (y.items = a.mergeEvaluated.items(h, A.items, y.items));
          else {
            const D = h.var("items", (0, n._)`${M}.evaluated.items`);
            y.items = a.mergeEvaluated.items(h, D, y.items, n.Name);
          }
      }
    }
    return Fs.callRef = u, Fs.default = i, Fs;
  }
  var sD;
  function JEe() {
    if (sD) return Mv;
    sD = 1, Object.defineProperty(Mv, "__esModule", { value: !0 });
    const e = XEe(), t = YEe(), n = [
      "$schema",
      "$id",
      "$defs",
      "$vocabulary",
      { keyword: "$comment" },
      "definitions",
      e.default,
      t.default
    ];
    return Mv.default = n, Mv;
  }
  var jv = {}, Iv = {}, lD;
  function QEe() {
    if (lD) return Iv;
    lD = 1, Object.defineProperty(Iv, "__esModule", { value: !0 });
    const e = mt(), t = e.operators, n = {
      maximum: { okStr: "<=", ok: t.LTE, fail: t.GT },
      minimum: { okStr: ">=", ok: t.GTE, fail: t.LT },
      exclusiveMaximum: { okStr: "<", ok: t.LT, fail: t.GTE },
      exclusiveMinimum: { okStr: ">", ok: t.GT, fail: t.LTE }
    }, r = {
      message: ({ keyword: a, schemaCode: i }) => (0, e.str)`must be ${n[a].okStr} ${i}`,
      params: ({ keyword: a, schemaCode: i }) => (0, e._)`{comparison: ${n[a].okStr}, limit: ${i}}`
    }, o = {
      keyword: Object.keys(n),
      type: "number",
      schemaType: "number",
      $data: !0,
      error: r,
      code(a) {
        const { keyword: i, data: s, schemaCode: u } = a;
        a.fail$data((0, e._)`${s} ${n[i].fail} ${u} || isNaN(${s})`);
      }
    };
    return Iv.default = o, Iv;
  }
  var Av = {}, uD;
  function ZEe() {
    if (uD) return Av;
    uD = 1, Object.defineProperty(Av, "__esModule", { value: !0 });
    const e = mt(), t = {
      keyword: "multipleOf",
      type: "number",
      schemaType: "number",
      $data: !0,
      error: {
        message: ({ schemaCode: n }) => (0, e.str)`must be multiple of ${n}`,
        params: ({ schemaCode: n }) => (0, e._)`{multipleOf: ${n}}`
      },
      code(n) {
        const { gen: r, data: o, schemaCode: a, it: i } = n, s = i.opts.multipleOfPrecision, u = r.let("res"), c = s ? (0, e._)`Math.abs(Math.round(${u}) - ${u}) > 1e-${s}` : (0, e._)`${u} !== parseInt(${u})`;
        n.fail$data((0, e._)`(${a} === 0 || (${u} = ${o}/${a}, ${c}))`);
      }
    };
    return Av.default = t, Av;
  }
  var $v = {}, Dv = {}, cD;
  function eCe() {
    if (cD) return Dv;
    cD = 1, Object.defineProperty(Dv, "__esModule", { value: !0 });
    function e(t) {
      const n = t.length;
      let r = 0, o = 0, a;
      for (; o < n; )
        r++, a = t.charCodeAt(o++), a >= 55296 && a <= 56319 && o < n && (a = t.charCodeAt(o), (a & 64512) === 56320 && o++);
      return r;
    }
    return Dv.default = e, e.code = 'require("ajv/dist/runtime/ucs2length").default', Dv;
  }
  var dD;
  function tCe() {
    if (dD) return $v;
    dD = 1, Object.defineProperty($v, "__esModule", { value: !0 });
    const e = mt(), t = Ft(), n = eCe(), r = {
      keyword: ["maxLength", "minLength"],
      type: "string",
      schemaType: "number",
      $data: !0,
      error: {
        message({ keyword: o, schemaCode: a }) {
          const i = o === "maxLength" ? "more" : "fewer";
          return (0, e.str)`must NOT have ${i} than ${a} characters`;
        },
        params: ({ schemaCode: o }) => (0, e._)`{limit: ${o}}`
      },
      code(o) {
        const { keyword: a, data: i, schemaCode: s, it: u } = o, c = a === "maxLength" ? e.operators.GT : e.operators.LT, f = u.opts.unicode === !1 ? (0, e._)`${i}.length` : (0, e._)`${(0, t.useFunc)(o.gen, n.default)}(${i})`;
        o.fail$data((0, e._)`${f} ${c} ${s}`);
      }
    };
    return $v.default = r, $v;
  }
  var Lv = {}, fD;
  function nCe() {
    if (fD) return Lv;
    fD = 1, Object.defineProperty(Lv, "__esModule", { value: !0 });
    const e = ca(), t = mt(), n = {
      keyword: "pattern",
      type: "string",
      schemaType: "string",
      $data: !0,
      error: {
        message: ({ schemaCode: r }) => (0, t.str)`must match pattern "${r}"`,
        params: ({ schemaCode: r }) => (0, t._)`{pattern: ${r}}`
      },
      code(r) {
        const { data: o, $data: a, schema: i, schemaCode: s, it: u } = r, c = u.opts.unicodeRegExp ? "u" : "", f = a ? (0, t._)`(new RegExp(${s}, ${c}))` : (0, e.usePattern)(r, i);
        r.fail$data((0, t._)`!${f}.test(${o})`);
      }
    };
    return Lv.default = n, Lv;
  }
  var Fv = {}, pD;
  function rCe() {
    if (pD) return Fv;
    pD = 1, Object.defineProperty(Fv, "__esModule", { value: !0 });
    const e = mt(), t = {
      keyword: ["maxProperties", "minProperties"],
      type: "object",
      schemaType: "number",
      $data: !0,
      error: {
        message({ keyword: n, schemaCode: r }) {
          const o = n === "maxProperties" ? "more" : "fewer";
          return (0, e.str)`must NOT have ${o} than ${r} properties`;
        },
        params: ({ schemaCode: n }) => (0, e._)`{limit: ${n}}`
      },
      code(n) {
        const { keyword: r, data: o, schemaCode: a } = n, i = r === "maxProperties" ? e.operators.GT : e.operators.LT;
        n.fail$data((0, e._)`Object.keys(${o}).length ${i} ${a}`);
      }
    };
    return Fv.default = t, Fv;
  }
  var Tv = {}, mD;
  function oCe() {
    if (mD) return Tv;
    mD = 1, Object.defineProperty(Tv, "__esModule", { value: !0 });
    const e = ca(), t = mt(), n = Ft(), r = {
      keyword: "required",
      type: "object",
      schemaType: "array",
      $data: !0,
      error: {
        message: ({ params: { missingProperty: o } }) => (0, t.str)`must have required property '${o}'`,
        params: ({ params: { missingProperty: o } }) => (0, t._)`{missingProperty: ${o}}`
      },
      code(o) {
        const { gen: a, schema: i, schemaCode: s, data: u, $data: c, it: f } = o, { opts: p } = f;
        if (!c && i.length === 0)
          return;
        const g = i.length >= p.loopRequired;
        if (f.allErrors ? h() : y(), p.strictRequired) {
          const w = o.parentSchema.properties, { definedProperties: _ } = o.it;
          for (const k of i)
            if (w?.[k] === void 0 && !_.has(k)) {
              const E = f.schemaEnv.baseId + f.errSchemaPath, P = `required property "${k}" is not defined at "${E}" (strictRequired)`;
              (0, n.checkStrictMode)(f, P, f.opts.strictRequired);
            }
        }
        function h() {
          if (g || c)
            o.block$data(t.nil, b);
          else
            for (const w of i)
              (0, e.checkReportMissingProp)(o, w);
        }
        function y() {
          const w = a.let("missing");
          if (g || c) {
            const _ = a.let("valid", !0);
            o.block$data(_, () => v(w, _)), o.ok(_);
          } else
            a.if((0, e.checkMissingProp)(o, i, w)), (0, e.reportMissingProp)(o, w), a.else();
        }
        function b() {
          a.forOf("prop", s, (w) => {
            o.setParams({ missingProperty: w }), a.if((0, e.noPropertyInData)(a, u, w, p.ownProperties), () => o.error());
          });
        }
        function v(w, _) {
          o.setParams({ missingProperty: w }), a.forOf(w, s, () => {
            a.assign(_, (0, e.propertyInData)(a, u, w, p.ownProperties)), a.if((0, t.not)(_), () => {
              o.error(), a.break();
            });
          }, t.nil);
        }
      }
    };
    return Tv.default = r, Tv;
  }
  var zv = {}, hD;
  function aCe() {
    if (hD) return zv;
    hD = 1, Object.defineProperty(zv, "__esModule", { value: !0 });
    const e = mt(), t = {
      keyword: ["maxItems", "minItems"],
      type: "array",
      schemaType: "number",
      $data: !0,
      error: {
        message({ keyword: n, schemaCode: r }) {
          const o = n === "maxItems" ? "more" : "fewer";
          return (0, e.str)`must NOT have ${o} than ${r} items`;
        },
        params: ({ schemaCode: n }) => (0, e._)`{limit: ${n}}`
      },
      code(n) {
        const { keyword: r, data: o, schemaCode: a } = n, i = r === "maxItems" ? e.operators.GT : e.operators.LT;
        n.fail$data((0, e._)`${o}.length ${i} ${a}`);
      }
    };
    return zv.default = t, zv;
  }
  var Bv = {}, Vv = {}, gD;
  function hO() {
    if (gD) return Vv;
    gD = 1, Object.defineProperty(Vv, "__esModule", { value: !0 });
    const e = N1();
    return e.code = 'require("ajv/dist/runtime/equal").default', Vv.default = e, Vv;
  }
  var vD;
  function iCe() {
    if (vD) return Bv;
    vD = 1, Object.defineProperty(Bv, "__esModule", { value: !0 });
    const e = zb(), t = mt(), n = Ft(), r = hO(), o = {
      keyword: "uniqueItems",
      type: "array",
      schemaType: "boolean",
      $data: !0,
      error: {
        message: ({ params: { i: a, j: i } }) => (0, t.str)`must NOT have duplicate items (items ## ${i} and ${a} are identical)`,
        params: ({ params: { i: a, j: i } }) => (0, t._)`{i: ${a}, j: ${i}}`
      },
      code(a) {
        const { gen: i, data: s, $data: u, schema: c, parentSchema: f, schemaCode: p, it: g } = a;
        if (!u && !c)
          return;
        const h = i.let("valid"), y = f.items ? (0, e.getSchemaTypes)(f.items) : [];
        a.block$data(h, b, (0, t._)`${p} === false`), a.ok(h);
        function b() {
          const k = i.let("i", (0, t._)`${s}.length`), E = i.let("j");
          a.setParams({ i: k, j: E }), i.assign(h, !0), i.if((0, t._)`${k} > 1`, () => (v() ? w : _)(k, E));
        }
        function v() {
          return y.length > 0 && !y.some((k) => k === "object" || k === "array");
        }
        function w(k, E) {
          const P = i.name("item"), O = (0, e.checkDataTypes)(y, P, g.opts.strictNumbers, e.DataType.Wrong), M = i.const("indices", (0, t._)`{}`);
          i.for((0, t._)`;${k}--;`, () => {
            i.let(P, (0, t._)`${s}[${k}]`), i.if(O, (0, t._)`continue`), y.length > 1 && i.if((0, t._)`typeof ${P} == "string"`, (0, t._)`${P} += "_"`), i.if((0, t._)`typeof ${M}[${P}] == "number"`, () => {
              i.assign(E, (0, t._)`${M}[${P}]`), a.error(), i.assign(h, !1).break();
            }).code((0, t._)`${M}[${P}] = ${k}`);
          });
        }
        function _(k, E) {
          const P = (0, n.useFunc)(i, r.default), O = i.name("outer");
          i.label(O).for((0, t._)`;${k}--;`, () => i.for((0, t._)`${E} = ${k}; ${E}--;`, () => i.if((0, t._)`${P}(${s}[${k}], ${s}[${E}])`, () => {
            a.error(), i.assign(h, !1).break(O);
          })));
        }
      }
    };
    return Bv.default = o, Bv;
  }
  var Uv = {}, yD;
  function sCe() {
    if (yD) return Uv;
    yD = 1, Object.defineProperty(Uv, "__esModule", { value: !0 });
    const e = mt(), t = Ft(), n = hO(), r = {
      keyword: "const",
      $data: !0,
      error: {
        message: "must be equal to constant",
        params: ({ schemaCode: o }) => (0, e._)`{allowedValue: ${o}}`
      },
      code(o) {
        const { gen: a, data: i, $data: s, schemaCode: u, schema: c } = o;
        s || c && typeof c == "object" ? o.fail$data((0, e._)`!${(0, t.useFunc)(a, n.default)}(${i}, ${u})`) : o.fail((0, e._)`${c} !== ${i}`);
      }
    };
    return Uv.default = r, Uv;
  }
  var Hv = {}, bD;
  function lCe() {
    if (bD) return Hv;
    bD = 1, Object.defineProperty(Hv, "__esModule", { value: !0 });
    const e = mt(), t = Ft(), n = hO(), r = {
      keyword: "enum",
      schemaType: "array",
      $data: !0,
      error: {
        message: "must be equal to one of the allowed values",
        params: ({ schemaCode: o }) => (0, e._)`{allowedValues: ${o}}`
      },
      code(o) {
        const { gen: a, data: i, $data: s, schema: u, schemaCode: c, it: f } = o;
        if (!s && u.length === 0)
          throw new Error("enum must have non-empty array");
        const p = u.length >= f.opts.loopEnum;
        let g;
        const h = () => g ?? (g = (0, t.useFunc)(a, n.default));
        let y;
        if (p || s)
          y = a.let("valid"), o.block$data(y, b);
        else {
          if (!Array.isArray(u))
            throw new Error("ajv implementation error");
          const w = a.const("vSchema", c);
          y = (0, e.or)(...u.map((_, k) => v(w, k)));
        }
        o.pass(y);
        function b() {
          a.assign(y, !1), a.forOf("v", c, (w) => a.if((0, e._)`${h()}(${i}, ${w})`, () => a.assign(y, !0).break()));
        }
        function v(w, _) {
          const k = u[_];
          return typeof k == "object" && k !== null ? (0, e._)`${h()}(${i}, ${w}[${_}])` : (0, e._)`${i} === ${k}`;
        }
      }
    };
    return Hv.default = r, Hv;
  }
  var wD;
  function uCe() {
    if (wD) return jv;
    wD = 1, Object.defineProperty(jv, "__esModule", { value: !0 });
    const e = QEe(), t = ZEe(), n = tCe(), r = nCe(), o = rCe(), a = oCe(), i = aCe(), s = iCe(), u = sCe(), c = lCe(), f = [
      // number
      e.default,
      t.default,
      // string
      n.default,
      r.default,
      // object
      o.default,
      a.default,
      // array
      i.default,
      s.default,
      // any
      { keyword: "type", schemaType: ["string", "array"] },
      { keyword: "nullable", schemaType: "boolean" },
      u.default,
      c.default
    ];
    return jv.default = f, jv;
  }
  var Wv = {}, jc = {}, xD;
  function M1() {
    if (xD) return jc;
    xD = 1, Object.defineProperty(jc, "__esModule", { value: !0 }), jc.validateAdditionalItems = void 0;
    const e = mt(), t = Ft(), n = {
      keyword: "additionalItems",
      type: "array",
      schemaType: ["boolean", "object"],
      before: "uniqueItems",
      error: {
        message: ({ params: { len: o } }) => (0, e.str)`must NOT have more than ${o} items`,
        params: ({ params: { len: o } }) => (0, e._)`{limit: ${o}}`
      },
      code(o) {
        const { parentSchema: a, it: i } = o, { items: s } = a;
        if (!Array.isArray(s)) {
          (0, t.checkStrictMode)(i, '"additionalItems" is ignored when "items" is not an array of schemas');
          return;
        }
        r(o, s);
      }
    };
    function r(o, a) {
      const { gen: i, schema: s, data: u, keyword: c, it: f } = o;
      f.items = !0;
      const p = i.const("len", (0, e._)`${u}.length`);
      if (s === !1)
        o.setParams({ len: a.length }), o.pass((0, e._)`${p} <= ${a.length}`);
      else if (typeof s == "object" && !(0, t.alwaysValidSchema)(f, s)) {
        const h = i.var("valid", (0, e._)`${p} <= ${a.length}`);
        i.if((0, e.not)(h), () => g(h)), o.ok(h);
      }
      function g(h) {
        i.forRange("i", a.length, p, (y) => {
          o.subschema({ keyword: c, dataProp: y, dataPropType: t.Type.Num }, h), f.allErrors || i.if((0, e.not)(h), () => i.break());
        });
      }
    }
    return jc.validateAdditionalItems = r, jc.default = n, jc;
  }
  var qv = {}, Ic = {}, kD;
  function R1() {
    if (kD) return Ic;
    kD = 1, Object.defineProperty(Ic, "__esModule", { value: !0 }), Ic.validateTuple = void 0;
    const e = mt(), t = Ft(), n = ca(), r = {
      keyword: "items",
      type: "array",
      schemaType: ["object", "array", "boolean"],
      before: "uniqueItems",
      code(a) {
        const { schema: i, it: s } = a;
        if (Array.isArray(i))
          return o(a, "additionalItems", i);
        s.items = !0, !(0, t.alwaysValidSchema)(s, i) && a.ok((0, n.validateArray)(a));
      }
    };
    function o(a, i, s = a.schema) {
      const { gen: u, parentSchema: c, data: f, keyword: p, it: g } = a;
      b(c), g.opts.unevaluated && s.length && g.items !== !0 && (g.items = t.mergeEvaluated.items(u, s.length, g.items));
      const h = u.name("valid"), y = u.const("len", (0, e._)`${f}.length`);
      s.forEach((v, w) => {
        (0, t.alwaysValidSchema)(g, v) || (u.if((0, e._)`${y} > ${w}`, () => a.subschema({
          keyword: p,
          schemaProp: w,
          dataProp: w
        }, h)), a.ok(h));
      });
      function b(v) {
        const { opts: w, errSchemaPath: _ } = g, k = s.length, E = k === v.minItems && (k === v.maxItems || v[i] === !1);
        if (w.strictTuples && !E) {
          const P = `"${p}" is ${k}-tuple, but minItems or maxItems/${i} are not specified or different at path "${_}"`;
          (0, t.checkStrictMode)(g, P, w.strictTuples);
        }
      }
    }
    return Ic.validateTuple = o, Ic.default = r, Ic;
  }
  var SD;
  function cCe() {
    if (SD) return qv;
    SD = 1, Object.defineProperty(qv, "__esModule", { value: !0 });
    const e = R1(), t = {
      keyword: "prefixItems",
      type: "array",
      schemaType: ["array"],
      before: "uniqueItems",
      code: (n) => (0, e.validateTuple)(n, "items")
    };
    return qv.default = t, qv;
  }
  var Kv = {}, _D;
  function dCe() {
    if (_D) return Kv;
    _D = 1, Object.defineProperty(Kv, "__esModule", { value: !0 });
    const e = mt(), t = Ft(), n = ca(), r = M1(), o = {
      keyword: "items",
      type: "array",
      schemaType: ["object", "boolean"],
      before: "uniqueItems",
      error: {
        message: ({ params: { len: a } }) => (0, e.str)`must NOT have more than ${a} items`,
        params: ({ params: { len: a } }) => (0, e._)`{limit: ${a}}`
      },
      code(a) {
        const { schema: i, parentSchema: s, it: u } = a, { prefixItems: c } = s;
        u.items = !0, !(0, t.alwaysValidSchema)(u, i) && (c ? (0, r.validateAdditionalItems)(a, c) : a.ok((0, n.validateArray)(a)));
      }
    };
    return Kv.default = o, Kv;
  }
  var Gv = {}, ED;
  function fCe() {
    if (ED) return Gv;
    ED = 1, Object.defineProperty(Gv, "__esModule", { value: !0 });
    const e = mt(), t = Ft(), n = {
      keyword: "contains",
      type: "array",
      schemaType: ["object", "boolean"],
      before: "uniqueItems",
      trackErrors: !0,
      error: {
        message: ({ params: { min: r, max: o } }) => o === void 0 ? (0, e.str)`must contain at least ${r} valid item(s)` : (0, e.str)`must contain at least ${r} and no more than ${o} valid item(s)`,
        params: ({ params: { min: r, max: o } }) => o === void 0 ? (0, e._)`{minContains: ${r}}` : (0, e._)`{minContains: ${r}, maxContains: ${o}}`
      },
      code(r) {
        const { gen: o, schema: a, parentSchema: i, data: s, it: u } = r;
        let c, f;
        const { minContains: p, maxContains: g } = i;
        u.opts.next ? (c = p === void 0 ? 1 : p, f = g) : c = 1;
        const h = o.const("len", (0, e._)`${s}.length`);
        if (r.setParams({ min: c, max: f }), f === void 0 && c === 0) {
          (0, t.checkStrictMode)(u, '"minContains" == 0 without "maxContains": "contains" keyword ignored');
          return;
        }
        if (f !== void 0 && c > f) {
          (0, t.checkStrictMode)(u, '"minContains" > "maxContains" is always invalid'), r.fail();
          return;
        }
        if ((0, t.alwaysValidSchema)(u, a)) {
          let _ = (0, e._)`${h} >= ${c}`;
          f !== void 0 && (_ = (0, e._)`${_} && ${h} <= ${f}`), r.pass(_);
          return;
        }
        u.items = !0;
        const y = o.name("valid");
        f === void 0 && c === 1 ? v(y, () => o.if(y, () => o.break())) : c === 0 ? (o.let(y, !0), f !== void 0 && o.if((0, e._)`${s}.length > 0`, b)) : (o.let(y, !1), b()), r.result(y, () => r.reset());
        function b() {
          const _ = o.name("_valid"), k = o.let("count", 0);
          v(_, () => o.if(_, () => w(k)));
        }
        function v(_, k) {
          o.forRange("i", 0, h, (E) => {
            r.subschema({
              keyword: "contains",
              dataProp: E,
              dataPropType: t.Type.Num,
              compositeRule: !0
            }, _), k();
          });
        }
        function w(_) {
          o.code((0, e._)`${_}++`), f === void 0 ? o.if((0, e._)`${_} >= ${c}`, () => o.assign(y, !0).break()) : (o.if((0, e._)`${_} > ${f}`, () => o.assign(y, !1).break()), c === 1 ? o.assign(y, !0) : o.if((0, e._)`${_} >= ${c}`, () => o.assign(y, !0)));
        }
      }
    };
    return Gv.default = n, Gv;
  }
  var CD = {}, PD;
  function pCe() {
    return PD || (PD = 1, (function(e) {
      Object.defineProperty(e, "__esModule", { value: !0 }), e.validateSchemaDeps = e.validatePropertyDeps = e.error = void 0;
      const t = mt(), n = Ft(), r = ca();
      e.error = {
        message: ({ params: { property: u, depsCount: c, deps: f } }) => {
          const p = c === 1 ? "property" : "properties";
          return (0, t.str)`must have ${p} ${f} when property ${u} is present`;
        },
        params: ({ params: { property: u, depsCount: c, deps: f, missingProperty: p } }) => (0, t._)`{property: ${u},
    missingProperty: ${p},
    depsCount: ${c},
    deps: ${f}}`
        // TODO change to reference
      };
      const o = {
        keyword: "dependencies",
        type: "object",
        schemaType: "object",
        error: e.error,
        code(u) {
          const [c, f] = a(u);
          i(u, c), s(u, f);
        }
      };
      function a({ schema: u }) {
        const c = {}, f = {};
        for (const p in u) {
          if (p === "__proto__")
            continue;
          const g = Array.isArray(u[p]) ? c : f;
          g[p] = u[p];
        }
        return [c, f];
      }
      function i(u, c = u.schema) {
        const { gen: f, data: p, it: g } = u;
        if (Object.keys(c).length === 0)
          return;
        const h = f.let("missing");
        for (const y in c) {
          const b = c[y];
          if (b.length === 0)
            continue;
          const v = (0, r.propertyInData)(f, p, y, g.opts.ownProperties);
          u.setParams({
            property: y,
            depsCount: b.length,
            deps: b.join(", ")
          }), g.allErrors ? f.if(v, () => {
            for (const w of b)
              (0, r.checkReportMissingProp)(u, w);
          }) : (f.if((0, t._)`${v} && (${(0, r.checkMissingProp)(u, b, h)})`), (0, r.reportMissingProp)(u, h), f.else());
        }
      }
      e.validatePropertyDeps = i;
      function s(u, c = u.schema) {
        const { gen: f, data: p, keyword: g, it: h } = u, y = f.name("valid");
        for (const b in c)
          (0, n.alwaysValidSchema)(h, c[b]) || (f.if(
            (0, r.propertyInData)(f, p, b, h.opts.ownProperties),
            () => {
              const v = u.subschema({ keyword: g, schemaProp: b }, y);
              u.mergeValidEvaluated(v, y);
            },
            () => f.var(y, !0)
            // TODO var
          ), u.ok(y));
      }
      e.validateSchemaDeps = s, e.default = o;
    })(CD)), CD;
  }
  var Xv = {}, OD;
  function mCe() {
    if (OD) return Xv;
    OD = 1, Object.defineProperty(Xv, "__esModule", { value: !0 });
    const e = mt(), t = Ft(), n = {
      keyword: "propertyNames",
      type: "object",
      schemaType: ["object", "boolean"],
      error: {
        message: "property name must be valid",
        params: ({ params: r }) => (0, e._)`{propertyName: ${r.propertyName}}`
      },
      code(r) {
        const { gen: o, schema: a, data: i, it: s } = r;
        if ((0, t.alwaysValidSchema)(s, a))
          return;
        const u = o.name("valid");
        o.forIn("key", i, (c) => {
          r.setParams({ propertyName: c }), r.subschema({
            keyword: "propertyNames",
            data: c,
            dataTypes: ["string"],
            propertyName: c,
            compositeRule: !0
          }, u), o.if((0, e.not)(u), () => {
            r.error(!0), s.allErrors || o.break();
          });
        }), r.ok(u);
      }
    };
    return Xv.default = n, Xv;
  }
  var Yv = {}, ND;
  function j1() {
    if (ND) return Yv;
    ND = 1, Object.defineProperty(Yv, "__esModule", { value: !0 });
    const e = ca(), t = mt(), n = gl(), r = Ft(), o = {
      keyword: "additionalProperties",
      type: ["object"],
      schemaType: ["boolean", "object"],
      allowUndefined: !0,
      trackErrors: !0,
      error: {
        message: "must NOT have additional properties",
        params: ({ params: a }) => (0, t._)`{additionalProperty: ${a.additionalProperty}}`
      },
      code(a) {
        const { gen: i, schema: s, parentSchema: u, data: c, errsCount: f, it: p } = a;
        if (!f)
          throw new Error("ajv implementation error");
        const { allErrors: g, opts: h } = p;
        if (p.props = !0, h.removeAdditional !== "all" && (0, r.alwaysValidSchema)(p, s))
          return;
        const y = (0, e.allSchemaProperties)(u.properties), b = (0, e.allSchemaProperties)(u.patternProperties);
        v(), a.ok((0, t._)`${f} === ${n.default.errors}`);
        function v() {
          i.forIn("key", c, (P) => {
            !y.length && !b.length ? k(P) : i.if(w(P), () => k(P));
          });
        }
        function w(P) {
          let O;
          if (y.length > 8) {
            const M = (0, r.schemaRefOrVal)(p, u.properties, "properties");
            O = (0, e.isOwnProperty)(i, M, P);
          } else y.length ? O = (0, t.or)(...y.map((M) => (0, t._)`${P} === ${M}`)) : O = t.nil;
          return b.length && (O = (0, t.or)(O, ...b.map((M) => (0, t._)`${(0, e.usePattern)(a, M)}.test(${P})`))), (0, t.not)(O);
        }
        function _(P) {
          i.code((0, t._)`delete ${c}[${P}]`);
        }
        function k(P) {
          if (h.removeAdditional === "all" || h.removeAdditional && s === !1) {
            _(P);
            return;
          }
          if (s === !1) {
            a.setParams({ additionalProperty: P }), a.error(), g || i.break();
            return;
          }
          if (typeof s == "object" && !(0, r.alwaysValidSchema)(p, s)) {
            const O = i.name("valid");
            h.removeAdditional === "failing" ? (E(P, O, !1), i.if((0, t.not)(O), () => {
              a.reset(), _(P);
            })) : (E(P, O), g || i.if((0, t.not)(O), () => i.break()));
          }
        }
        function E(P, O, M) {
          const I = {
            keyword: "additionalProperties",
            dataProp: P,
            dataPropType: r.Type.Str
          };
          M === !1 && Object.assign(I, {
            compositeRule: !0,
            createErrors: !1,
            allErrors: !1
          }), a.subschema(I, O);
        }
      }
    };
    return Yv.default = o, Yv;
  }
  var Jv = {}, MD;
  function hCe() {
    if (MD) return Jv;
    MD = 1, Object.defineProperty(Jv, "__esModule", { value: !0 });
    const e = kx(), t = ca(), n = Ft(), r = j1(), o = {
      keyword: "properties",
      type: "object",
      schemaType: "object",
      code(a) {
        const { gen: i, schema: s, parentSchema: u, data: c, it: f } = a;
        f.opts.removeAdditional === "all" && u.additionalProperties === void 0 && r.default.code(new e.KeywordCxt(f, r.default, "additionalProperties"));
        const p = (0, t.allSchemaProperties)(s);
        for (const v of p)
          f.definedProperties.add(v);
        f.opts.unevaluated && p.length && f.props !== !0 && (f.props = n.mergeEvaluated.props(i, (0, n.toHash)(p), f.props));
        const g = p.filter((v) => !(0, n.alwaysValidSchema)(f, s[v]));
        if (g.length === 0)
          return;
        const h = i.name("valid");
        for (const v of g)
          y(v) ? b(v) : (i.if((0, t.propertyInData)(i, c, v, f.opts.ownProperties)), b(v), f.allErrors || i.else().var(h, !0), i.endIf()), a.it.definedProperties.add(v), a.ok(h);
        function y(v) {
          return f.opts.useDefaults && !f.compositeRule && s[v].default !== void 0;
        }
        function b(v) {
          a.subschema({
            keyword: "properties",
            schemaProp: v,
            dataProp: v
          }, h);
        }
      }
    };
    return Jv.default = o, Jv;
  }
  var Qv = {}, RD;
  function gCe() {
    if (RD) return Qv;
    RD = 1, Object.defineProperty(Qv, "__esModule", { value: !0 });
    const e = ca(), t = mt(), n = Ft(), r = Ft(), o = {
      keyword: "patternProperties",
      type: "object",
      schemaType: "object",
      code(a) {
        const { gen: i, schema: s, data: u, parentSchema: c, it: f } = a, { opts: p } = f, g = (0, e.allSchemaProperties)(s), h = g.filter((E) => (0, n.alwaysValidSchema)(f, s[E]));
        if (g.length === 0 || h.length === g.length && (!f.opts.unevaluated || f.props === !0))
          return;
        const y = p.strictSchema && !p.allowMatchingProperties && c.properties, b = i.name("valid");
        f.props !== !0 && !(f.props instanceof t.Name) && (f.props = (0, r.evaluatedPropsToName)(i, f.props));
        const { props: v } = f;
        w();
        function w() {
          for (const E of g)
            y && _(E), f.allErrors ? k(E) : (i.var(b, !0), k(E), i.if(b));
        }
        function _(E) {
          for (const P in y)
            new RegExp(E).test(P) && (0, n.checkStrictMode)(f, `property ${P} matches pattern ${E} (use allowMatchingProperties)`);
        }
        function k(E) {
          i.forIn("key", u, (P) => {
            i.if((0, t._)`${(0, e.usePattern)(a, E)}.test(${P})`, () => {
              const O = h.includes(E);
              O || a.subschema({
                keyword: "patternProperties",
                schemaProp: E,
                dataProp: P,
                dataPropType: r.Type.Str
              }, b), f.opts.unevaluated && v !== !0 ? i.assign((0, t._)`${v}[${P}]`, !0) : !O && !f.allErrors && i.if((0, t.not)(b), () => i.break());
            });
          });
        }
      }
    };
    return Qv.default = o, Qv;
  }
  var Zv = {}, jD;
  function vCe() {
    if (jD) return Zv;
    jD = 1, Object.defineProperty(Zv, "__esModule", { value: !0 });
    const e = Ft(), t = {
      keyword: "not",
      schemaType: ["object", "boolean"],
      trackErrors: !0,
      code(n) {
        const { gen: r, schema: o, it: a } = n;
        if ((0, e.alwaysValidSchema)(a, o)) {
          n.fail();
          return;
        }
        const i = r.name("valid");
        n.subschema({
          keyword: "not",
          compositeRule: !0,
          createErrors: !1,
          allErrors: !1
        }, i), n.failResult(i, () => n.reset(), () => n.error());
      },
      error: { message: "must NOT be valid" }
    };
    return Zv.default = t, Zv;
  }
  var ey = {}, ID;
  function yCe() {
    if (ID) return ey;
    ID = 1, Object.defineProperty(ey, "__esModule", { value: !0 });
    const e = {
      keyword: "anyOf",
      schemaType: "array",
      trackErrors: !0,
      code: ca().validateUnion,
      error: { message: "must match a schema in anyOf" }
    };
    return ey.default = e, ey;
  }
  var ty = {}, AD;
  function bCe() {
    if (AD) return ty;
    AD = 1, Object.defineProperty(ty, "__esModule", { value: !0 });
    const e = mt(), t = Ft(), n = {
      keyword: "oneOf",
      schemaType: "array",
      trackErrors: !0,
      error: {
        message: "must match exactly one schema in oneOf",
        params: ({ params: r }) => (0, e._)`{passingSchemas: ${r.passing}}`
      },
      code(r) {
        const { gen: o, schema: a, parentSchema: i, it: s } = r;
        if (!Array.isArray(a))
          throw new Error("ajv implementation error");
        if (s.opts.discriminator && i.discriminator)
          return;
        const u = a, c = o.let("valid", !1), f = o.let("passing", null), p = o.name("_valid");
        r.setParams({ passing: f }), o.block(g), r.result(c, () => r.reset(), () => r.error(!0));
        function g() {
          u.forEach((h, y) => {
            let b;
            (0, t.alwaysValidSchema)(s, h) ? o.var(p, !0) : b = r.subschema({
              keyword: "oneOf",
              schemaProp: y,
              compositeRule: !0
            }, p), y > 0 && o.if((0, e._)`${p} && ${c}`).assign(c, !1).assign(f, (0, e._)`[${f}, ${y}]`).else(), o.if(p, () => {
              o.assign(c, !0), o.assign(f, y), b && r.mergeEvaluated(b, e.Name);
            });
          });
        }
      }
    };
    return ty.default = n, ty;
  }
  var ny = {}, $D;
  function wCe() {
    if ($D) return ny;
    $D = 1, Object.defineProperty(ny, "__esModule", { value: !0 });
    const e = Ft(), t = {
      keyword: "allOf",
      schemaType: "array",
      code(n) {
        const { gen: r, schema: o, it: a } = n;
        if (!Array.isArray(o))
          throw new Error("ajv implementation error");
        const i = r.name("valid");
        o.forEach((s, u) => {
          if ((0, e.alwaysValidSchema)(a, s))
            return;
          const c = n.subschema({ keyword: "allOf", schemaProp: u }, i);
          n.ok(i), n.mergeEvaluated(c);
        });
      }
    };
    return ny.default = t, ny;
  }
  var ry = {}, DD;
  function xCe() {
    if (DD) return ry;
    DD = 1, Object.defineProperty(ry, "__esModule", { value: !0 });
    const e = mt(), t = Ft(), n = {
      keyword: "if",
      schemaType: ["object", "boolean"],
      trackErrors: !0,
      error: {
        message: ({ params: o }) => (0, e.str)`must match "${o.ifClause}" schema`,
        params: ({ params: o }) => (0, e._)`{failingKeyword: ${o.ifClause}}`
      },
      code(o) {
        const { gen: a, parentSchema: i, it: s } = o;
        i.then === void 0 && i.else === void 0 && (0, t.checkStrictMode)(s, '"if" without "then" and "else" is ignored');
        const u = r(s, "then"), c = r(s, "else");
        if (!u && !c)
          return;
        const f = a.let("valid", !0), p = a.name("_valid");
        if (g(), o.reset(), u && c) {
          const y = a.let("ifClause");
          o.setParams({ ifClause: y }), a.if(p, h("then", y), h("else", y));
        } else u ? a.if(p, h("then")) : a.if((0, e.not)(p), h("else"));
        o.pass(f, () => o.error(!0));
        function g() {
          const y = o.subschema({
            keyword: "if",
            compositeRule: !0,
            createErrors: !1,
            allErrors: !1
          }, p);
          o.mergeEvaluated(y);
        }
        function h(y, b) {
          return () => {
            const v = o.subschema({ keyword: y }, p);
            a.assign(f, p), o.mergeValidEvaluated(v, f), b ? a.assign(b, (0, e._)`${y}`) : o.setParams({ ifClause: y });
          };
        }
      }
    };
    function r(o, a) {
      const i = o.schema[a];
      return i !== void 0 && !(0, t.alwaysValidSchema)(o, i);
    }
    return ry.default = n, ry;
  }
  var oy = {}, LD;
  function kCe() {
    if (LD) return oy;
    LD = 1, Object.defineProperty(oy, "__esModule", { value: !0 });
    const e = Ft(), t = {
      keyword: ["then", "else"],
      schemaType: ["object", "boolean"],
      code({ keyword: n, parentSchema: r, it: o }) {
        r.if === void 0 && (0, e.checkStrictMode)(o, `"${n}" without "if" is ignored`);
      }
    };
    return oy.default = t, oy;
  }
  var FD;
  function SCe() {
    if (FD) return Wv;
    FD = 1, Object.defineProperty(Wv, "__esModule", { value: !0 });
    const e = M1(), t = cCe(), n = R1(), r = dCe(), o = fCe(), a = pCe(), i = mCe(), s = j1(), u = hCe(), c = gCe(), f = vCe(), p = yCe(), g = bCe(), h = wCe(), y = xCe(), b = kCe();
    function v(w = !1) {
      const _ = [
        // any
        f.default,
        p.default,
        g.default,
        h.default,
        y.default,
        b.default,
        // object
        i.default,
        s.default,
        a.default,
        u.default,
        c.default
      ];
      return w ? _.push(t.default, r.default) : _.push(e.default, n.default), _.push(o.default), _;
    }
    return Wv.default = v, Wv;
  }
  var ay = {}, iy = {}, TD;
  function _Ce() {
    if (TD) return iy;
    TD = 1, Object.defineProperty(iy, "__esModule", { value: !0 });
    const e = mt(), t = {
      keyword: "format",
      type: ["number", "string"],
      schemaType: "string",
      $data: !0,
      error: {
        message: ({ schemaCode: n }) => (0, e.str)`must match format "${n}"`,
        params: ({ schemaCode: n }) => (0, e._)`{format: ${n}}`
      },
      code(n, r) {
        const { gen: o, data: a, $data: i, schema: s, schemaCode: u, it: c } = n, { opts: f, errSchemaPath: p, schemaEnv: g, self: h } = c;
        if (!f.validateFormats)
          return;
        i ? y() : b();
        function y() {
          const v = o.scopeValue("formats", {
            ref: h.formats,
            code: f.code.formats
          }), w = o.const("fDef", (0, e._)`${v}[${u}]`), _ = o.let("fType"), k = o.let("format");
          o.if((0, e._)`typeof ${w} == "object" && !(${w} instanceof RegExp)`, () => o.assign(_, (0, e._)`${w}.type || "string"`).assign(k, (0, e._)`${w}.validate`), () => o.assign(_, (0, e._)`"string"`).assign(k, w)), n.fail$data((0, e.or)(E(), P()));
          function E() {
            return f.strictSchema === !1 ? e.nil : (0, e._)`${u} && !${k}`;
          }
          function P() {
            const O = g.$async ? (0, e._)`(${w}.async ? await ${k}(${a}) : ${k}(${a}))` : (0, e._)`${k}(${a})`, M = (0, e._)`(typeof ${k} == "function" ? ${O} : ${k}.test(${a}))`;
            return (0, e._)`${k} && ${k} !== true && ${_} === ${r} && !${M}`;
          }
        }
        function b() {
          const v = h.formats[s];
          if (!v) {
            E();
            return;
          }
          if (v === !0)
            return;
          const [w, _, k] = P(v);
          w === r && n.pass(O());
          function E() {
            if (f.strictSchema === !1) {
              h.logger.warn(M());
              return;
            }
            throw new Error(M());
            function M() {
              return `unknown format "${s}" ignored in schema at path "${p}"`;
            }
          }
          function P(M) {
            const I = M instanceof RegExp ? (0, e.regexpCode)(M) : f.code.formats ? (0, e._)`${f.code.formats}${(0, e.getProperty)(s)}` : void 0, A = o.scopeValue("formats", { key: s, ref: M, code: I });
            return typeof M == "object" && !(M instanceof RegExp) ? [M.type || "string", M.validate, (0, e._)`${A}.validate`] : ["string", M, A];
          }
          function O() {
            if (typeof v == "object" && !(v instanceof RegExp) && v.async) {
              if (!g.$async)
                throw new Error("async format in sync schema");
              return (0, e._)`await ${k}(${a})`;
            }
            return typeof _ == "function" ? (0, e._)`${k}(${a})` : (0, e._)`${k}.test(${a})`;
          }
        }
      }
    };
    return iy.default = t, iy;
  }
  var zD;
  function ECe() {
    if (zD) return ay;
    zD = 1, Object.defineProperty(ay, "__esModule", { value: !0 });
    const e = [_Ce().default];
    return ay.default = e, ay;
  }
  var Ac = {}, BD;
  function CCe() {
    return BD || (BD = 1, Object.defineProperty(Ac, "__esModule", { value: !0 }), Ac.contentVocabulary = Ac.metadataVocabulary = void 0, Ac.metadataVocabulary = [
      "title",
      "description",
      "default",
      "deprecated",
      "readOnly",
      "writeOnly",
      "examples"
    ], Ac.contentVocabulary = [
      "contentMediaType",
      "contentEncoding",
      "contentSchema"
    ]), Ac;
  }
  var VD;
  function PCe() {
    if (VD) return Nv;
    VD = 1, Object.defineProperty(Nv, "__esModule", { value: !0 });
    const e = JEe(), t = uCe(), n = SCe(), r = ECe(), o = CCe(), a = [
      e.default,
      t.default,
      (0, n.default)(),
      r.default,
      o.metadataVocabulary,
      o.contentVocabulary
    ];
    return Nv.default = a, Nv;
  }
  var sy = {}, rp = {}, UD;
  function OCe() {
    if (UD) return rp;
    UD = 1, Object.defineProperty(rp, "__esModule", { value: !0 }), rp.DiscrError = void 0;
    var e;
    return (function(t) {
      t.Tag = "tag", t.Mapping = "mapping";
    })(e || (rp.DiscrError = e = {})), rp;
  }
  var HD;
  function NCe() {
    if (HD) return sy;
    HD = 1, Object.defineProperty(sy, "__esModule", { value: !0 });
    const e = mt(), t = OCe(), n = mO(), r = Sx(), o = Ft(), a = {
      keyword: "discriminator",
      type: "object",
      schemaType: "object",
      error: {
        message: ({ params: { discrError: i, tagName: s } }) => i === t.DiscrError.Tag ? `tag "${s}" must be string` : `value of tag "${s}" must be in oneOf`,
        params: ({ params: { discrError: i, tag: s, tagName: u } }) => (0, e._)`{error: ${i}, tag: ${u}, tagValue: ${s}}`
      },
      code(i) {
        const { gen: s, data: u, schema: c, parentSchema: f, it: p } = i, { oneOf: g } = f;
        if (!p.opts.discriminator)
          throw new Error("discriminator: requires discriminator option");
        const h = c.propertyName;
        if (typeof h != "string")
          throw new Error("discriminator: requires propertyName");
        if (c.mapping)
          throw new Error("discriminator: mapping is not supported");
        if (!g)
          throw new Error("discriminator: requires oneOf keyword");
        const y = s.let("valid", !1), b = s.const("tag", (0, e._)`${u}${(0, e.getProperty)(h)}`);
        s.if((0, e._)`typeof ${b} == "string"`, () => v(), () => i.error(!1, { discrError: t.DiscrError.Tag, tag: b, tagName: h })), i.ok(y);
        function v() {
          const k = _();
          s.if(!1);
          for (const E in k)
            s.elseIf((0, e._)`${b} === ${E}`), s.assign(y, w(k[E]));
          s.else(), i.error(!1, { discrError: t.DiscrError.Mapping, tag: b, tagName: h }), s.endIf();
        }
        function w(k) {
          const E = s.name("valid"), P = i.subschema({ keyword: "oneOf", schemaProp: k }, E);
          return i.mergeEvaluated(P, e.Name), E;
        }
        function _() {
          var k;
          const E = {}, P = M(f);
          let O = !0;
          for (let D = 0; D < g.length; D++) {
            let F = g[D];
            if (F?.$ref && !(0, o.schemaHasRulesButRef)(F, p.self.RULES)) {
              const U = F.$ref;
              if (F = n.resolveRef.call(p.self, p.schemaEnv.root, p.baseId, U), F instanceof n.SchemaEnv && (F = F.schema), F === void 0)
                throw new r.default(p.opts.uriResolver, p.baseId, U);
            }
            const j = (k = F?.properties) === null || k === void 0 ? void 0 : k[h];
            if (typeof j != "object")
              throw new Error(`discriminator: oneOf subschemas (or referenced schemas) must have "properties/${h}"`);
            O = O && (P || M(F)), I(j, D);
          }
          if (!O)
            throw new Error(`discriminator: "${h}" must be required`);
          return E;
          function M({ required: D }) {
            return Array.isArray(D) && D.includes(h);
          }
          function I(D, F) {
            if (D.const)
              A(D.const, F);
            else if (D.enum)
              for (const j of D.enum)
                A(j, F);
            else
              throw new Error(`discriminator: "properties/${h}" must have "const" or "enum"`);
          }
          function A(D, F) {
            if (typeof D != "string" || D in E)
              throw new Error(`discriminator: "${h}" values must be unique strings`);
            E[D] = F;
          }
        }
      }
    };
    return sy.default = a, sy;
  }
  const MCe = "http://json-schema.org/draft-07/schema#", RCe = "http://json-schema.org/draft-07/schema#", jCe = "Core schema meta-schema", ICe = { schemaArray: { type: "array", minItems: 1, items: { $ref: "#" } }, nonNegativeInteger: { type: "integer", minimum: 0 }, nonNegativeIntegerDefault0: { allOf: [{ $ref: "#/definitions/nonNegativeInteger" }, { default: 0 }] }, simpleTypes: { enum: ["array", "boolean", "integer", "null", "number", "object", "string"] }, stringArray: { type: "array", items: { type: "string" }, uniqueItems: !0, default: [] } }, ACe = ["object", "boolean"], $Ce = { $id: { type: "string", format: "uri-reference" }, $schema: { type: "string", format: "uri" }, $ref: { type: "string", format: "uri-reference" }, $comment: { type: "string" }, title: { type: "string" }, description: { type: "string" }, default: !0, readOnly: { type: "boolean", default: !1 }, examples: { type: "array", items: !0 }, multipleOf: { type: "number", exclusiveMinimum: 0 }, maximum: { type: "number" }, exclusiveMaximum: { type: "number" }, minimum: { type: "number" }, exclusiveMinimum: { type: "number" }, maxLength: { $ref: "#/definitions/nonNegativeInteger" }, minLength: { $ref: "#/definitions/nonNegativeIntegerDefault0" }, pattern: { type: "string", format: "regex" }, additionalItems: { $ref: "#" }, items: { anyOf: [{ $ref: "#" }, { $ref: "#/definitions/schemaArray" }], default: !0 }, maxItems: { $ref: "#/definitions/nonNegativeInteger" }, minItems: { $ref: "#/definitions/nonNegativeIntegerDefault0" }, uniqueItems: { type: "boolean", default: !1 }, contains: { $ref: "#" }, maxProperties: { $ref: "#/definitions/nonNegativeInteger" }, minProperties: { $ref: "#/definitions/nonNegativeIntegerDefault0" }, required: { $ref: "#/definitions/stringArray" }, additionalProperties: { $ref: "#" }, definitions: { type: "object", additionalProperties: { $ref: "#" }, default: {} }, properties: { type: "object", additionalProperties: { $ref: "#" }, default: {} }, patternProperties: { type: "object", additionalProperties: { $ref: "#" }, propertyNames: { format: "regex" }, default: {} }, dependencies: { type: "object", additionalProperties: { anyOf: [{ $ref: "#" }, { $ref: "#/definitions/stringArray" }] } }, propertyNames: { $ref: "#" }, const: !0, enum: { type: "array", items: !0, minItems: 1, uniqueItems: !0 }, type: { anyOf: [{ $ref: "#/definitions/simpleTypes" }, { type: "array", items: { $ref: "#/definitions/simpleTypes" }, minItems: 1, uniqueItems: !0 }] }, format: { type: "string" }, contentMediaType: { type: "string" }, contentEncoding: { type: "string" }, if: { $ref: "#" }, then: { $ref: "#" }, else: { $ref: "#" }, allOf: { $ref: "#/definitions/schemaArray" }, anyOf: { $ref: "#/definitions/schemaArray" }, oneOf: { $ref: "#/definitions/schemaArray" }, not: { $ref: "#" } }, DCe = {
    $schema: MCe,
    $id: RCe,
    title: jCe,
    definitions: ICe,
    type: ACe,
    properties: $Ce,
    default: !0
  };
  var WD;
  function I1() {
    return WD || (WD = 1, (function(e, t) {
      Object.defineProperty(t, "__esModule", { value: !0 }), t.MissingRefError = t.ValidationError = t.CodeGen = t.Name = t.nil = t.stringify = t.str = t._ = t.KeywordCxt = t.Ajv = void 0;
      const n = GEe(), r = PCe(), o = NCe(), a = DCe, i = ["/properties"], s = "http://json-schema.org/draft-07/schema";
      class u extends n.default {
        _addVocabularies() {
          super._addVocabularies(), r.default.forEach((y) => this.addVocabulary(y)), this.opts.discriminator && this.addKeyword(o.default);
        }
        _addDefaultMetaSchema() {
          if (super._addDefaultMetaSchema(), !this.opts.meta)
            return;
          const y = this.opts.$data ? this.$dataMetaSchema(a, i) : a;
          this.addMetaSchema(y, s, !1), this.refs["http://json-schema.org/schema"] = s;
        }
        defaultMeta() {
          return this.opts.defaultMeta = super.defaultMeta() || (this.getSchema(s) ? s : void 0);
        }
      }
      t.Ajv = u, e.exports = t = u, e.exports.Ajv = u, Object.defineProperty(t, "__esModule", { value: !0 }), t.default = u;
      var c = kx();
      Object.defineProperty(t, "KeywordCxt", { enumerable: !0, get: function() {
        return c.KeywordCxt;
      } });
      var f = mt();
      Object.defineProperty(t, "_", { enumerable: !0, get: function() {
        return f._;
      } }), Object.defineProperty(t, "str", { enumerable: !0, get: function() {
        return f.str;
      } }), Object.defineProperty(t, "stringify", { enumerable: !0, get: function() {
        return f.stringify;
      } }), Object.defineProperty(t, "nil", { enumerable: !0, get: function() {
        return f.nil;
      } }), Object.defineProperty(t, "Name", { enumerable: !0, get: function() {
        return f.Name;
      } }), Object.defineProperty(t, "CodeGen", { enumerable: !0, get: function() {
        return f.CodeGen;
      } });
      var p = pO();
      Object.defineProperty(t, "ValidationError", { enumerable: !0, get: function() {
        return p.default;
      } });
      var g = Sx();
      Object.defineProperty(t, "MissingRefError", { enumerable: !0, get: function() {
        return g.default;
      } });
    })(b0, b0.exports)), b0.exports;
  }
  var LCe = I1();
  const FCe = /* @__PURE__ */ Qi(LCe);
  var S0 = { exports: {} }, qD = {}, KD;
  function TCe() {
    return KD || (KD = 1, (function(e) {
      Object.defineProperty(e, "__esModule", { value: !0 }), e.formatNames = e.fastFormats = e.fullFormats = void 0;
      function t(A, D) {
        return { validate: A, compare: D };
      }
      e.fullFormats = {
        // date: http://tools.ietf.org/html/rfc3339#section-5.6
        date: t(a, i),
        // date-time: http://tools.ietf.org/html/rfc3339#section-5.6
        time: t(u, c),
        "date-time": t(p, g),
        // duration: https://tools.ietf.org/html/rfc3339#appendix-A
        duration: /^P(?!$)((\d+Y)?(\d+M)?(\d+D)?(T(?=\d)(\d+H)?(\d+M)?(\d+S)?)?|(\d+W)?)$/,
        uri: b,
        "uri-reference": /^(?:[a-z][a-z0-9+\-.]*:)?(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'"()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?(?:\?(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i,
        // uri-template: https://tools.ietf.org/html/rfc6570
        "uri-template": /^(?:(?:[^\x00-\x20"'<>%\\^`{|}]|%[0-9a-f]{2})|\{[+#./;?&=,!@|]?(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?(?:,(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?)*\})*$/i,
        // For the source: https://gist.github.com/dperini/729294
        // For test cases: https://mathiasbynens.be/demo/url-regex
        url: /^(?:https?|ftp):\/\/(?:\S+(?::\S*)?@)?(?:(?!(?:10|127)(?:\.\d{1,3}){3})(?!(?:169\.254|192\.168)(?:\.\d{1,3}){2})(?!172\.(?:1[6-9]|2\d|3[0-1])(?:\.\d{1,3}){2})(?:[1-9]\d?|1\d\d|2[01]\d|22[0-3])(?:\.(?:1?\d{1,2}|2[0-4]\d|25[0-5])){2}(?:\.(?:[1-9]\d?|1\d\d|2[0-4]\d|25[0-4]))|(?:(?:[a-z0-9\u{00a1}-\u{ffff}]+-)*[a-z0-9\u{00a1}-\u{ffff}]+)(?:\.(?:[a-z0-9\u{00a1}-\u{ffff}]+-)*[a-z0-9\u{00a1}-\u{ffff}]+)*(?:\.(?:[a-z\u{00a1}-\u{ffff}]{2,})))(?::\d{2,5})?(?:\/[^\s]*)?$/iu,
        email: /^[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?$/i,
        hostname: /^(?=.{1,253}\.?$)[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[-0-9a-z]{0,61}[0-9a-z])?)*\.?$/i,
        // optimized https://www.safaribooksonline.com/library/view/regular-expressions-cookbook/9780596802837/ch07s16.html
        ipv4: /^(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)$/,
        ipv6: /^((([0-9a-f]{1,4}:){7}([0-9a-f]{1,4}|:))|(([0-9a-f]{1,4}:){6}(:[0-9a-f]{1,4}|((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9a-f]{1,4}:){5}(((:[0-9a-f]{1,4}){1,2})|:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9a-f]{1,4}:){4}(((:[0-9a-f]{1,4}){1,3})|((:[0-9a-f]{1,4})?:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){3}(((:[0-9a-f]{1,4}){1,4})|((:[0-9a-f]{1,4}){0,2}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){2}(((:[0-9a-f]{1,4}){1,5})|((:[0-9a-f]{1,4}){0,3}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){1}(((:[0-9a-f]{1,4}){1,6})|((:[0-9a-f]{1,4}){0,4}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(:(((:[0-9a-f]{1,4}){1,7})|((:[0-9a-f]{1,4}){0,5}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))$/i,
        regex: I,
        // uuid: http://tools.ietf.org/html/rfc4122
        uuid: /^(?:urn:uuid:)?[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12}$/i,
        // JSON-pointer: https://tools.ietf.org/html/rfc6901
        // uri fragment: https://tools.ietf.org/html/rfc3986#appendix-A
        "json-pointer": /^(?:\/(?:[^~/]|~0|~1)*)*$/,
        "json-pointer-uri-fragment": /^#(?:\/(?:[a-z0-9_\-.!$&'()*+,;:=@]|%[0-9a-f]{2}|~0|~1)*)*$/i,
        // relative JSON-pointer: http://tools.ietf.org/html/draft-luff-relative-json-pointer-00
        "relative-json-pointer": /^(?:0|[1-9][0-9]*)(?:#|(?:\/(?:[^~/]|~0|~1)*)*)$/,
        // the following formats are used by the openapi specification: https://spec.openapis.org/oas/v3.0.0#data-types
        // byte: https://github.com/miguelmota/is-base64
        byte: w,
        // signed 32 bit integer
        int32: { type: "number", validate: E },
        // signed 64 bit integer
        int64: { type: "number", validate: P },
        // C-type float
        float: { type: "number", validate: O },
        // C-type double
        double: { type: "number", validate: O },
        // hint to the UI to hide input strings
        password: !0,
        // unchecked string payload
        binary: !0
      }, e.fastFormats = {
        ...e.fullFormats,
        date: t(/^\d\d\d\d-[0-1]\d-[0-3]\d$/, i),
        time: t(/^(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)?$/i, c),
        "date-time": t(/^\d\d\d\d-[0-1]\d-[0-3]\d[t\s](?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)$/i, g),
        // uri: https://github.com/mafintosh/is-my-json-valid/blob/master/formats.js
        uri: /^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/)?[^\s]*$/i,
        "uri-reference": /^(?:(?:[a-z][a-z0-9+\-.]*:)?\/?\/)?(?:[^\\\s#][^\s#]*)?(?:#[^\\\s]*)?$/i,
        // email (sources from jsen validator):
        // http://stackoverflow.com/questions/201323/using-a-regular-expression-to-validate-an-email-address#answer-8829363
        // http://www.w3.org/TR/html5/forms.html#valid-e-mail-address (search for 'wilful violation')
        email: /^[a-z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?)*$/i
      }, e.formatNames = Object.keys(e.fullFormats);
      function n(A) {
        return A % 4 === 0 && (A % 100 !== 0 || A % 400 === 0);
      }
      const r = /^(\d\d\d\d)-(\d\d)-(\d\d)$/, o = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
      function a(A) {
        const D = r.exec(A);
        if (!D)
          return !1;
        const F = +D[1], j = +D[2], U = +D[3];
        return j >= 1 && j <= 12 && U >= 1 && U <= (j === 2 && n(F) ? 29 : o[j]);
      }
      function i(A, D) {
        if (A && D)
          return A > D ? 1 : A < D ? -1 : 0;
      }
      const s = /^(\d\d):(\d\d):(\d\d)(\.\d+)?(z|[+-]\d\d(?::?\d\d)?)?$/i;
      function u(A, D) {
        const F = s.exec(A);
        if (!F)
          return !1;
        const j = +F[1], U = +F[2], $ = +F[3], q = F[5];
        return (j <= 23 && U <= 59 && $ <= 59 || j === 23 && U === 59 && $ === 60) && (!D || q !== "");
      }
      function c(A, D) {
        if (!(A && D))
          return;
        const F = s.exec(A), j = s.exec(D);
        if (F && j)
          return A = F[1] + F[2] + F[3] + (F[4] || ""), D = j[1] + j[2] + j[3] + (j[4] || ""), A > D ? 1 : A < D ? -1 : 0;
      }
      const f = /t|\s/i;
      function p(A) {
        const D = A.split(f);
        return D.length === 2 && a(D[0]) && u(D[1], !0);
      }
      function g(A, D) {
        if (!(A && D))
          return;
        const [F, j] = A.split(f), [U, $] = D.split(f), q = i(F, U);
        if (q !== void 0)
          return q || c(j, $);
      }
      const h = /\/|:/, y = /^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)(?:\?(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i;
      function b(A) {
        return h.test(A) && y.test(A);
      }
      const v = /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/gm;
      function w(A) {
        return v.lastIndex = 0, v.test(A);
      }
      const _ = -2147483648, k = 2 ** 31 - 1;
      function E(A) {
        return Number.isInteger(A) && A <= k && A >= _;
      }
      function P(A) {
        return Number.isInteger(A);
      }
      function O() {
        return !0;
      }
      const M = /[^\\]\\Z/;
      function I(A) {
        if (M.test(A))
          return !1;
        try {
          return new RegExp(A), !0;
        } catch {
          return !1;
        }
      }
    })(qD)), qD;
  }
  var GD = {}, XD;
  function zCe() {
    return XD || (XD = 1, (function(e) {
      Object.defineProperty(e, "__esModule", { value: !0 }), e.formatLimitDefinition = void 0;
      const t = I1(), n = mt(), r = n.operators, o = {
        formatMaximum: { okStr: "<=", ok: r.LTE, fail: r.GT },
        formatMinimum: { okStr: ">=", ok: r.GTE, fail: r.LT },
        formatExclusiveMaximum: { okStr: "<", ok: r.LT, fail: r.GTE },
        formatExclusiveMinimum: { okStr: ">", ok: r.GT, fail: r.LTE }
      }, a = {
        message: ({ keyword: s, schemaCode: u }) => n.str`should be ${o[s].okStr} ${u}`,
        params: ({ keyword: s, schemaCode: u }) => n._`{comparison: ${o[s].okStr}, limit: ${u}}`
      };
      e.formatLimitDefinition = {
        keyword: Object.keys(o),
        type: "string",
        schemaType: "string",
        $data: !0,
        error: a,
        code(s) {
          const { gen: u, data: c, schemaCode: f, keyword: p, it: g } = s, { opts: h, self: y } = g;
          if (!h.validateFormats)
            return;
          const b = new t.KeywordCxt(g, y.RULES.all.format.definition, "format");
          b.$data ? v() : w();
          function v() {
            const k = u.scopeValue("formats", {
              ref: y.formats,
              code: h.code.formats
            }), E = u.const("fmt", n._`${k}[${b.schemaCode}]`);
            s.fail$data(n.or(n._`typeof ${E} != "object"`, n._`${E} instanceof RegExp`, n._`typeof ${E}.compare != "function"`, _(E)));
          }
          function w() {
            const k = b.schema, E = y.formats[k];
            if (!E || E === !0)
              return;
            if (typeof E != "object" || E instanceof RegExp || typeof E.compare != "function")
              throw new Error(`"${p}": format "${k}" does not define "compare" function`);
            const P = u.scopeValue("formats", {
              key: k,
              ref: E,
              code: h.code.formats ? n._`${h.code.formats}${n.getProperty(k)}` : void 0
            });
            s.fail$data(_(P));
          }
          function _(k) {
            return n._`${k}.compare(${c}, ${f}) ${o[p].fail} 0`;
          }
        },
        dependencies: ["format"]
      };
      const i = (s) => (s.addKeyword(e.formatLimitDefinition), s);
      e.default = i;
    })(GD)), GD;
  }
  var YD;
  function BCe() {
    return YD || (YD = 1, (function(e, t) {
      Object.defineProperty(t, "__esModule", { value: !0 });
      const n = TCe(), r = zCe(), o = mt(), a = new o.Name("fullFormats"), i = new o.Name("fastFormats"), s = (c, f = { keywords: !0 }) => {
        if (Array.isArray(f))
          return u(c, f, n.fullFormats, a), c;
        const [p, g] = f.mode === "fast" ? [n.fastFormats, i] : [n.fullFormats, a], h = f.formats || n.formatNames;
        return u(c, h, p, g), f.keywords && r.default(c), c;
      };
      s.get = (c, f = "full") => {
        const p = (f === "fast" ? n.fastFormats : n.fullFormats)[c];
        if (!p)
          throw new Error(`Unknown format "${c}"`);
        return p;
      };
      function u(c, f, p, g) {
        var h, y;
        (h = (y = c.opts.code).formats) !== null && h !== void 0 || (y.formats = o._`require("ajv-formats/dist/formats").${g}`);
        for (const b of f)
          c.addFormat(b, p[b]);
      }
      e.exports = t = s, Object.defineProperty(t, "__esModule", { value: !0 }), t.default = s;
    })(S0, S0.exports)), S0.exports;
  }
  var VCe = BCe();
  const JD = /* @__PURE__ */ Qi(VCe), UCe = {
    allErrors: !0,
    multipleOfPrecision: 8,
    strict: !1,
    verbose: !0,
    discriminator: !1
    // TODO enable this in V6
  }, HCe = /^(#?([0-9A-Fa-f]{3}){1,2}\b|aqua|black|blue|fuchsia|gray|green|lime|maroon|navy|olive|orange|purple|red|silver|teal|white|yellow|(rgb\(\s*\b([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\b\s*,\s*\b([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\b\s*,\s*\b([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\b\s*\))|(rgb\(\s*(\d?\d%|100%)+\s*,\s*(\d?\d%|100%)+\s*,\s*(\d?\d%|100%)+\s*\)))$/, WCe = /^data:([a-z]+\/[a-z0-9-+.]+)?;(?:name=(.*);)?base64,(.*)$/;
  function qCe(e, t, n = {}, r, o = FCe, a) {
    let i = new o({ ...UCe, ...n });
    return r ? JD(i, r) : r !== !1 && JD(i), i.addFormat("data-url", WCe), i.addFormat("color", HCe), i.addKeyword(zi), i.addKeyword(AP), Array.isArray(e) && i.addMetaSchema(e), jt(t) && Object.keys(t).forEach((s) => {
      i.addFormat(s, t[s]);
    }), a && (i = a(i)), i;
  }
  function KCe(e = [], t) {
    return e.map((n) => {
      var r;
      const { instancePath: o, keyword: a, params: i, schemaPath: s, parentSchema: u, ...c } = n;
      let { message: f = "" } = c, p = o.replace(/\//g, "."), g = `${p} ${f}`.trim(), h = "";
      const y = [
        ...((r = i.deps) === null || r === void 0 ? void 0 : r.split(", ")) || [],
        i.missingProperty,
        i.property
      ].filter((b) => b);
      if (y.length > 0)
        y.forEach((b) => {
          const v = p ? `${p}.${b}` : b;
          let w = Qe(Ce(t, `${v.replace(/^\./, "")}`)).title;
          if (w === void 0) {
            const _ = s.replace(/\/properties\//g, "/").split("/").slice(1, -1).concat([b]);
            w = Qe(Ce(t, _)).title;
          }
          if (w)
            f = f.replace(`'${b}'`, `'${w}'`), h = w;
          else {
            const _ = Ce(u, [Lt, b, "title"]);
            _ && (f = f.replace(`'${b}'`, `'${_}'`), h = _);
          }
        }), g = f;
      else {
        const b = Qe(Ce(t, `${p.replace(/^\./, "")}`)).title;
        if (b)
          g = `'${b}' ${f}`.trim(), h = b;
        else {
          const v = u?.title;
          v && (g = `'${v}' ${f}`.trim(), h = v);
        }
      }
      return "missingProperty" in i && (p = p ? `${p}.${i.missingProperty}` : i.missingProperty), {
        name: a,
        property: p,
        message: f,
        params: i,
        // specific to ajv
        stack: g,
        schemaPath: s,
        title: h
      };
    }).reduce((n, r) => {
      const { message: o, schemaPath: a } = r, i = a?.indexOf(`/${Nt}/`), s = a?.indexOf(`/${pt}/`);
      let u;
      return i && i >= 0 ? u = a?.substring(0, i) : s && s >= 0 && (u = a?.substring(0, s)), u && n.find((c) => {
        var f;
        return c.message === o && ((f = c.schemaPath) === null || f === void 0 ? void 0 : f.startsWith(u));
      }) || n.push(r), n;
    }, []);
  }
  function GCe(e, t, n, r, o, a, i) {
    const { validationError: s } = t;
    let u = KCe(t.errors, i);
    s && (u = [...u, { stack: s.message }]), typeof a == "function" && (u = a(u, i));
    let c = bEe(u);
    if (s && (c = {
      ...c,
      $schema: {
        __errors: [s.message]
      }
    }), typeof o != "function")
      return { errors: u, errorSchema: c };
    const f = f1(e, r, n, r, !0), p = o(f, iE(f), i), g = C1(p);
    return Ky({ errors: u, errorSchema: c }, g);
  }
  class XCe {
    /** Constructs an `AJV8Validator` instance using the `options`
     *
     * @param options - The `CustomValidatorOptionsType` options that are used to create the AJV instance
     * @param [localizer] - If provided, is used to localize a list of Ajv `ErrorObject`s
     */
    constructor(t, n) {
      const { additionalMetaSchemas: r, customFormats: o, ajvOptionsOverrides: a, ajvFormatOptions: i, AjvClass: s, extenderFn: u } = t;
      this.ajv = qCe(r, o, a, i, s, u), this.localizer = n;
    }
    /** Resets the internal AJV validator to clear schemas from it. Can be helpful for resetting the validator for tests.
     */
    reset() {
      this.ajv.removeSchema();
    }
    /** Runs the pure validation of the `schema` and `formData` without any of the RJSF functionality. Provided for use
     * by the playground. Returns the `errors` from the validation
     *
     * @param schema - The schema against which to validate the form data   * @param schema
     * @param formData - The form data to validate
     */
    rawValidation(t, n) {
      var r, o;
      let a, i;
      try {
        t[rn] && (i = this.ajv.getSchema(t[rn])), i === void 0 && (i = this.ajv.compile(t)), i(n);
      } catch (u) {
        a = u;
      }
      let s;
      return i && (typeof this.localizer == "function" && (((r = i.errors) !== null && r !== void 0 ? r : []).forEach((u) => {
        var c;
        ["missingProperty", "property"].forEach((f) => {
          var p;
          !((p = u.params) === null || p === void 0) && p[f] && (u.params[f] = `'${u.params[f]}'`);
        }), !((c = u.params) === null || c === void 0) && c.deps && (u.params.deps = u.params.deps.split(", ").map((f) => `'${f}'`).join(", "));
      }), this.localizer(i.errors), ((o = i.errors) !== null && o !== void 0 ? o : []).forEach((u) => {
        var c;
        ["missingProperty", "property"].forEach((f) => {
          var p;
          !((p = u.params) === null || p === void 0) && p[f] && (u.params[f] = u.params[f].slice(1, -1));
        }), !((c = u.params) === null || c === void 0) && c.deps && (u.params.deps = u.params.deps.split(", ").map((f) => f.slice(1, -1)).join(", "));
      })), s = i.errors || void 0, i.errors = null), {
        errors: s,
        validationError: a
      };
    }
    /** This function processes the `formData` with an optional user contributed `customValidate` function, which receives
     * the form data and a `errorHandler` function that will be used to add custom validation errors for each field. Also
     * supports a `transformErrors` function that will take the raw AJV validation errors, prior to custom validation and
     * transform them in what ever way it chooses.
     *
     * @param formData - The form data to validate
     * @param schema - The schema against which to validate the form data
     * @param [customValidate] - An optional function that is used to perform custom validation
     * @param [transformErrors] - An optional function that is used to transform errors after AJV validation
     * @param [uiSchema] - An optional uiSchema that is passed to `transformErrors` and `customValidate`
     */
    validateFormData(t, n, r, o, a) {
      const i = this.rawValidation(n, t);
      return GCe(this, i, t, n, r, o, a);
    }
    /**
     * This function checks if a schema needs to be added and if the root schemas don't match it removes the old root schema from the ajv instance and adds the new one.
     * @param rootSchema - The root schema used to provide $ref resolutions
     */
    handleSchemaUpdate(t) {
      var n, r;
      const o = (n = t[rn]) !== null && n !== void 0 ? n : oV;
      this.ajv.getSchema(o) === void 0 ? this.ajv.addSchema(t, o) : fn(t, (r = this.ajv.getSchema(o)) === null || r === void 0 ? void 0 : r.schema) || (this.ajv.removeSchema(o), this.ajv.addSchema(t, o));
    }
    /** Validates data against a schema, returning true if the data is valid, or
     * false otherwise. If the schema is invalid, then this function will return
     * false.
     *
     * @param schema - The schema against which to validate the form data
     * @param formData - The form data to validate
     * @param rootSchema - The root schema used to provide $ref resolutions
     */
    isValid(t, n, r) {
      var o;
      try {
        this.handleSchemaUpdate(r);
        const a = fO(t), i = (o = a[rn]) !== null && o !== void 0 ? o : mEe(a);
        let s;
        return s = this.ajv.getSchema(i), s === void 0 && (s = this.ajv.addSchema(a, i).getSchema(i) || this.ajv.compile(a)), s(n);
      } catch (a) {
        return console.warn("Error encountered compiling schema:", a), !1;
      }
    }
  }
  function YCe(e = {}, t) {
    return new XCe(e, t);
  }
  const JCe = YCe();
  function QCe(e, t) {
    return b1(e, t, function(n, r) {
      return MV(e, r);
    });
  }
  var A1 = YV(function(e, t) {
    return e == null ? {} : QCe(e, t);
  });
  function ZCe(e, t) {
    return e == null ? !0 : XV(e, t);
  }
  function vE() {
    return S1("rjsf-array-item-");
  }
  function QD(e) {
    return Array.isArray(e) ? e.map((t) => ({
      key: vE(),
      item: t
    })) : [];
  }
  function $1(e) {
    return Array.isArray(e) ? e.map((t) => t.item) : [];
  }
  function ePe(e) {
    return Array.isArray(e.type) ? !e.type.includes("null") : e.type !== "null";
  }
  function D1(e, t, n, r) {
    let { addable: o } = Qe(r, e.globalUiOptions);
    return o !== !1 && (t.maxItems !== void 0 ? o = n.length < t.maxItems : o = !0), o;
  }
  function L1(e, t, n, r) {
    if (typeof e.items == "function")
      try {
        return e.items(t, n, r);
      } catch (o) {
        console.error(`Error executing dynamic uiSchema.items function for item at index ${n}:`, o);
        return;
      }
    else
      return e.items;
  }
  function tPe(e, t) {
    const { schemaUtils: n, globalFormOptions: r } = e;
    let o = t.items;
    return r.useFallbackUiForUnsupportedType && !o ? o = {} : nO(t) && Owe(t) && (o = t.additionalItems), n.getDefaultFormState(o);
  }
  function nPe(e) {
    const { schema: t, fieldPathId: n, uiSchema: r, formData: o = [], disabled: a = !1, readonly: i = !1, autofocus: s = !1, required: u = !1, placeholder: c, onBlur: f, onFocus: p, registry: g, rawErrors: h, name: y, onSelectChange: b } = e, { widgets: v, schemaUtils: w, globalFormOptions: _, globalUiOptions: k } = g, E = w.retrieveSchema(t.items, o), P = Od(E, r), { widget: O = "select", title: M, ...I } = Qe(r, k), A = Xa(t, O, v), D = M ?? t.title ?? y, F = w.getDisplayLabel(t, r, k), j = ju(Do("", _, n, !0));
    return S.jsx(A, { id: j[rn], name: y, multiple: !0, onChange: b, onBlur: f, onFocus: p, options: { ...I, enumOptions: P }, schema: t, uiSchema: r, registry: g, value: o, disabled: a, readonly: i, required: u, label: D, hideLabel: !F, placeholder: c, autofocus: s, rawErrors: h, htmlName: j.name });
  }
  function rPe(e) {
    const { schema: t, fieldPathId: n, uiSchema: r, disabled: o = !1, readonly: a = !1, autofocus: i = !1, required: s = !1, hideError: u, placeholder: c, onBlur: f, onFocus: p, formData: g = [], registry: h, rawErrors: y, name: b, onSelectChange: v } = e, { widgets: w, schemaUtils: _, globalFormOptions: k, globalUiOptions: E } = h, { widget: P, title: O, ...M } = Qe(r, E), I = Xa(t, P, w), A = O ?? t.title ?? b, D = _.getDisplayLabel(t, r, E), F = ju(Do("", k, n, !0));
    return S.jsx(I, { id: F[rn], name: b, multiple: !0, onChange: v, onBlur: f, onFocus: p, options: M, schema: t, uiSchema: r, registry: h, value: g, disabled: o, readonly: a, hideError: u, required: s, label: A, hideLabel: !D, placeholder: c, autofocus: i, rawErrors: y, htmlName: F.name });
  }
  function oPe(e) {
    const { schema: t, uiSchema: n, fieldPathId: r, name: o, disabled: a = !1, readonly: i = !1, autofocus: s = !1, required: u = !1, onBlur: c, onFocus: f, registry: p, formData: g = [], rawErrors: h, onSelectChange: y } = e, { widgets: b, schemaUtils: v, globalFormOptions: w, globalUiOptions: _ } = p, { widget: k = "files", title: E, ...P } = Qe(n, _), O = Xa(t, k, b), M = E ?? t.title ?? o, I = v.getDisplayLabel(t, n, _), A = ju(Do("", w, r, !0));
    return S.jsx(O, { options: P, id: A[rn], name: o, multiple: !0, onChange: y, onBlur: c, onFocus: f, schema: t, uiSchema: n, value: g, disabled: a, readonly: i, required: u, registry: p, autofocus: s, rawErrors: h, label: M, hideLabel: !I, htmlName: A.name });
  }
  function F1(e) {
    const { itemKey: t, index: n, name: r, disabled: o, hideError: a, readonly: i, registry: s, uiOptions: u, parentUiSchema: c, canAdd: f, canRemove: p = !0, canMoveUp: g, canMoveDown: h, itemSchema: y, itemData: b, itemUiSchema: v, itemFieldPathId: w, itemErrorSchema: _, autofocus: k, onBlur: E, onFocus: P, onChange: O, rawErrors: M, totalItems: I, title: A, handleAddItem: D, handleCopyItem: F, handleRemoveItem: j, handleReorderItems: U } = e, { schemaUtils: $, fields: { ArraySchemaField: q, SchemaField: B }, globalUiOptions: G } = s, W = ju(w), Y = q || B, z = et("ArrayFieldItemTemplate", s, u), L = $.getDisplayLabel(y, v, G), { description: K } = Qe(v), T = !!K || !!y.description, { orderable: V = !0, removable: X = !0, copyable: Q = !1 } = u, ne = {
      moveUp: V && g,
      moveDown: V && h,
      copy: Q && f,
      remove: X && p,
      toolbar: !1
    };
    ne.toolbar = Object.keys(ne).some((le) => ne[le]);
    const te = C.useCallback((le) => {
      D(le, n + 1);
    }, [D, n]), ae = C.useCallback((le) => {
      F(le, n);
    }, [F, n]), ce = C.useCallback((le) => {
      j(le, n);
    }, [j, n]), Z = C.useCallback((le) => {
      U(le, n, n - 1);
    }, [U, n]), ee = C.useCallback((le) => {
      U(le, n, n + 1);
    }, [U, n]), oe = {
      children: S.jsx(Y, { name: r, title: A, index: n, schema: y, uiSchema: v, formData: b, errorSchema: _, fieldPathId: W, required: ePe(y), onChange: O, onBlur: E, onFocus: P, registry: s, disabled: o, readonly: i, hideError: a, autofocus: k, rawErrors: M }),
      buttonsProps: {
        fieldPathId: W,
        disabled: o,
        readonly: i,
        canAdd: f,
        hasCopy: ne.copy,
        hasMoveUp: ne.moveUp,
        hasMoveDown: ne.moveDown,
        hasRemove: ne.remove,
        index: n,
        totalItems: I,
        onAddItem: te,
        onCopyItem: ae,
        onRemoveItem: ce,
        onMoveUpItem: Z,
        onMoveDownItem: ee,
        registry: s,
        schema: y,
        uiSchema: v
      },
      itemKey: t,
      className: "rjsf-array-item",
      disabled: o,
      hasToolbar: ne.toolbar,
      index: n,
      totalItems: I,
      readonly: i,
      registry: s,
      schema: y,
      uiSchema: v,
      parentUiSchema: c,
      displayLabel: L,
      hasDescription: T
    };
    return S.jsx(z, { ...oe });
  }
  function aPe(e) {
    const { schema: t, uiSchema: n = {}, errorSchema: r, fieldPathId: o, formData: a, name: i, title: s, disabled: u = !1, readonly: c = !1, autofocus: f = !1, required: p = !1, hideError: g = !1, registry: h, onBlur: y, onFocus: b, rawErrors: v, onChange: w, keyedFormData: _, handleAddItem: k, handleCopyItem: E, handleRemoveItem: P, handleReorderItems: O } = e, M = t.title || s || i, { schemaUtils: I, fields: A, formContext: D, globalFormOptions: F, globalUiOptions: j } = h, { OptionalDataControlsField: U } = A, $ = Qe(n, j), q = jt(t.items) ? t.items : {}, B = I.retrieveSchema(q), G = $1(_), W = mh(h, t, p, n), Y = qd(a), z = D1(h, t, G, n) && (!W || Y), L = Y ? _ : [], K = W ? " rjsf-optional-array-field" : "", T = e.childFieldPathId ?? o, V = W ? S.jsx(U, { ...e, fieldPathId: T }) : void 0, X = {
      canAdd: z,
      items: L.map((ne, te) => {
        const { key: ae, item: ce } = ne, Z = ce, ee = I.retrieveSchema(q, Z), oe = r ? r[te] : void 0, le = Do(te, F, T), be = L1(n, ce, te, D), ke = {
          itemKey: ae,
          index: te,
          name: i && `${i}-${te}`,
          registry: h,
          uiOptions: $,
          hideError: g,
          readonly: c,
          disabled: u,
          required: p,
          title: M ? `${M}-${te + 1}` : void 0,
          canAdd: z,
          canMoveUp: te > 0,
          canMoveDown: te < G.length - 1,
          itemSchema: ee,
          itemFieldPathId: le,
          itemErrorSchema: oe,
          itemData: Z,
          itemUiSchema: be,
          autofocus: f && te === 0,
          onBlur: y,
          onFocus: b,
          rawErrors: v,
          totalItems: _.length,
          handleAddItem: k,
          handleCopyItem: E,
          handleRemoveItem: P,
          handleReorderItems: O,
          onChange: w
        };
        return S.jsx(F1, { ...ke }, ae);
      }),
      className: `rjsf-field rjsf-field-array rjsf-field-array-of-${B.type}${K}`,
      disabled: u,
      fieldPathId: o,
      uiSchema: n,
      onAddClick: k,
      readonly: c,
      required: p,
      schema: t,
      title: M,
      formData: G,
      rawErrors: v,
      registry: h,
      optionalDataControl: V
    }, Q = et("ArrayFieldTemplate", h, $);
    return S.jsx(Q, { ...X });
  }
  function iPe(e) {
    const { schema: t, uiSchema: n = {}, formData: r, errorSchema: o, fieldPathId: a, name: i, title: s, disabled: u = !1, readonly: c = !1, autofocus: f = !1, required: p = !1, hideError: g = !1, registry: h, onBlur: y, onFocus: b, rawErrors: v, keyedFormData: w, onChange: _, handleAddItem: k, handleCopyItem: E, handleRemoveItem: P, handleReorderItems: O } = e;
    let { formData: M = [] } = e;
    const I = t.title || s || i, { schemaUtils: A, fields: D, formContext: F, globalFormOptions: j, globalUiOptions: U } = h, $ = Qe(n, U), { OptionalDataControlsField: q } = D, B = mh(h, t, p, n), G = qd(r), W = (jt(t.items) ? t.items : []).map((ne, te) => A.retrieveSchema(ne, M[te])), Y = jt(t.additionalItems) ? A.retrieveSchema(t.additionalItems, r) : null, z = e.childFieldPathId ?? a;
    M.length < W.length && (M = M.concat(new Array(W.length - M.length)));
    const L = G ? w : [], K = B ? " rjsf-optional-array-field" : "", T = B ? S.jsx(q, { ...e, fieldPathId: z }) : void 0, V = D1(h, t, M, n) && !!Y && (!B || G), X = {
      canAdd: V,
      className: `rjsf-field rjsf-field-array rjsf-field-array-fixed-items${K}`,
      disabled: u,
      fieldPathId: a,
      formData: r,
      items: L.map((ne, te) => {
        const { key: ae, item: ce } = ne, Z = ce, ee = te >= W.length, oe = (ee && jt(t.additionalItems) ? A.retrieveSchema(t.additionalItems, Z) : W[te]) || {}, le = Do(te, j, z);
        let be;
        ee ? be = n.additionalItems : Array.isArray(n.items) ? be = n.items[te] : be = L1(n, ce, te, F);
        const ke = o ? o[te] : void 0, De = {
          index: te,
          itemKey: ae,
          name: i && `${i}-${te}`,
          registry: h,
          uiOptions: $,
          hideError: g,
          readonly: c,
          disabled: u,
          required: p,
          title: I ? `${I}-${te + 1}` : void 0,
          canAdd: V,
          canRemove: ee,
          canMoveUp: te >= W.length + 1,
          canMoveDown: ee && te < M.length - 1,
          itemSchema: oe,
          itemData: Z,
          itemUiSchema: be,
          itemFieldPathId: le,
          itemErrorSchema: ke,
          autofocus: f && te === 0,
          onBlur: y,
          onFocus: b,
          rawErrors: v,
          totalItems: w.length,
          onChange: _,
          handleAddItem: k,
          handleCopyItem: E,
          handleRemoveItem: P,
          handleReorderItems: O
        };
        return S.jsx(F1, { ...De }, ae);
      }),
      onAddClick: k,
      readonly: c,
      required: p,
      registry: h,
      schema: t,
      uiSchema: n,
      title: I,
      errorSchema: o,
      rawErrors: v,
      optionalDataControl: T
    }, Q = et("ArrayFieldTemplate", h, $);
    return S.jsx(Q, { ...X });
  }
  function sPe(e = []) {
    const t = C.useMemo(() => $a(e), [e]), [n, r] = C.useState(() => ({
      formDataHash: t,
      keyedFormData: QD(e)
    }));
    let { keyedFormData: o, formDataHash: a } = n;
    if (t !== a) {
      const s = Array.isArray(e) ? e : [], u = o || [];
      o = s.length === u.length ? u.map((c, f) => ({
        key: c.key,
        item: s[f]
      })) : QD(s), a = t, r({ formDataHash: a, keyedFormData: o });
    }
    const i = C.useCallback((s) => {
      const u = $1(s), c = $a(u);
      return r({ formDataHash: c, keyedFormData: s }), u;
    }, []);
    return { keyedFormData: o, updateKeyedFormData: i };
  }
  function lPe(e) {
    const { schema: t, uiSchema: n, errorSchema: r, fieldPathId: o, registry: a, formData: i, onChange: s } = e, { globalFormOptions: u, schemaUtils: c, translateString: f } = a, { keyedFormData: p, updateKeyedFormData: g } = sPe(i), h = e.childFieldPathId ?? o, y = C.useCallback((O, M) => {
      O && O.preventDefault();
      let I;
      if (r) {
        I = {};
        for (const F in r) {
          const j = parseInt(F);
          M === void 0 || j < M ? Qt(I, [j], r[F]) : j >= M && Qt(I, [j + 1], r[F]);
        }
      }
      const A = {
        key: vE(),
        item: tPe(a, t)
      }, D = [...p];
      M !== void 0 ? D.splice(M, 0, A) : D.push(A), s(g(D), h.path, I);
    }, [p, a, t, s, g, r, h]), b = C.useCallback((O, M) => {
      O && O.preventDefault();
      let I;
      if (r) {
        I = {};
        for (const F in r) {
          const j = parseInt(F);
          j <= M ? Qt(I, [j], r[F]) : j > M && Qt(I, [j + 1], r[F]);
        }
      }
      const A = {
        key: vE(),
        item: iO(p[M].item)
      }, D = [...p];
      M !== void 0 ? D.splice(M + 1, 0, A) : D.push(A), s(g(D), h.path, I);
    }, [p, s, g, r, h]), v = C.useCallback((O, M) => {
      O && O.preventDefault();
      let I;
      if (r) {
        I = {};
        for (const D in r) {
          const F = parseInt(D);
          F < M ? Qt(I, [F], r[D]) : F > M && Qt(I, [F - 1], r[D]);
        }
      }
      const A = p.filter((D, F) => F !== M);
      s(g(A), h.path, I);
    }, [p, s, g, r, h]), w = C.useCallback((O, M, I) => {
      O && (O.preventDefault(), O.currentTarget.blur());
      let A;
      if (r) {
        A = {};
        for (const j in r) {
          const U = parseInt(j);
          U == M ? Qt(A, [I], r[M]) : U == I ? Qt(A, [M], r[I]) : Qt(A, [j], r[U]);
        }
      }
      function D() {
        const j = p.slice();
        return j.splice(M, 1), j.splice(I, 0, p[M]), j;
      }
      const F = D();
      s(g(F), h.path, A);
    }, [p, s, g, r, h]), _ = C.useCallback((O, M, I, A) => {
      s(
        // We need to treat undefined items as nulls to have validation.
        // See https://github.com/tdegrunt/jsonschema/issues/206
        O === void 0 ? null : O,
        M,
        I,
        A
      );
    }, [s]), k = C.useCallback((O) => {
      s(O, h.path, void 0, h?.[rn]);
    }, [s, h]), E = {
      ...e,
      formData: i,
      fieldPathId: h,
      onSelectChange: k
    }, P = {
      ...e,
      handleAddItem: y,
      handleCopyItem: b,
      handleRemoveItem: v,
      handleReorderItems: w,
      keyedFormData: p,
      onChange: _
    };
    if (!(Ed in t)) {
      if (!u.useFallbackUiForUnsupportedType) {
        const M = Qe(n), I = et("UnsupportedFieldTemplate", a, M);
        return S.jsx(I, { schema: t, fieldPathId: o, reason: f(ht.MissingItems), registry: a });
      }
      const O = { ...t, [Ed]: { type: void 0 } };
      E.schema = O, P.schema = O;
    }
    return c.isMultiSelect(E.schema) ? S.jsx(nPe, { ...E }) : p1(n) ? S.jsx(rPe, { ...E }) : nO(E.schema) ? S.jsx(iPe, { ...P }) : c.isFilesArray(E.schema, n) ? S.jsx(oPe, { ...E }) : S.jsx(aPe, { ...P });
  }
  function uPe(e) {
    const { schema: t, name: n, uiSchema: r, fieldPathId: o, formData: a, registry: i, required: s, disabled: u, readonly: c, hideError: f, autofocus: p, title: g, onChange: h, onFocus: y, onBlur: b, rawErrors: v } = e, { title: w } = t, { widgets: _, translateString: k, globalUiOptions: E } = i, {
      widget: P = "checkbox",
      title: O,
      // Unlike the other fields, don't use `getDisplayLabel()` since it always returns false for the boolean type
      label: M = !0,
      enumNames: I,
      ...A
    } = Qe(r, E), D = Xa(t, P, _), F = k(ht.YesLabel), j = k(ht.NoLabel);
    let U;
    const $ = O ?? w ?? g ?? n;
    if (Array.isArray(t.oneOf))
      U = Od({
        oneOf: t.oneOf.map((B) => {
          if (jt(B))
            return {
              ...B,
              title: B.title || (B.const === !0 ? F : j)
            };
        }).filter((B) => B)
        // cast away the error that typescript can't grok is fixed
      }, r);
    else {
      const B = t.enum ?? [!0, !1];
      !I && B.length === 2 && B.every((G) => typeof G == "boolean") ? U = [
        {
          value: B[0],
          label: B[0] ? F : j
        },
        {
          value: B[1],
          label: B[1] ? F : j
        }
      ] : U = Od({ enum: B }, r);
    }
    const q = C.useCallback((B, G, W) => h(B, o.path, G, W), [h, o]);
    return S.jsx(D, { options: { ...A, enumOptions: U }, schema: t, uiSchema: r, id: o.$id, name: n, onChange: q, onFocus: y, onBlur: b, label: $, hideLabel: !M, value: a, required: s, disabled: u, readonly: c, hideError: f, registry: i, autofocus: p, rawErrors: v, htmlName: o.name });
  }
  function cPe(e) {
    return {
      type: "string",
      enum: ["string", "number", "boolean", "object", "array"],
      default: "string",
      title: e
    };
  }
  function dPe(e) {
    const t = typeof e;
    return t === "string" || t === "number" || t === "boolean" ? t : t === "object" ? Array.isArray(e) ? "array" : "object" : "string";
  }
  function fPe(e, t) {
    switch (t) {
      case "string":
        return String(e);
      case "number": {
        const n = Number(e);
        return isNaN(n) ? 0 : n;
      }
      case "boolean":
        return !!e;
      default:
        return e;
    }
  }
  function pPe(e) {
    const { id: t, formData: n, displayLabel: r = !0, schema: o, name: a, uiSchema: i, required: s, disabled: u = !1, readonly: c = !1, onBlur: f, onFocus: p, registry: g, fieldPathId: h, onChange: y, errorSchema: b } = e, { translateString: v, fields: w, globalFormOptions: _ } = g, [k, E] = C.useState(dPe(n)), P = Qe(i), O = ju(Do("__internal_type_selector", _, h)), M = v(ht.Type), I = C.useMemo(() => cPe(M), [M]), A = (j) => {
      j != null && (E(j), y(fPe(n, j), h.path, b, t));
    };
    if (!_.useFallbackUiForUnsupportedType) {
      const { reason: j = v(ht.UnknownFieldType, [String(o.type)]) } = e, U = et("UnsupportedFieldTemplate", g, P);
      return S.jsx(U, { schema: o, fieldPathId: h, reason: j, registry: g });
    }
    const D = et("FallbackFieldTemplate", g, P), { SchemaField: F } = w;
    return S.jsx(D, { schema: o, registry: g, typeSelector: S.jsx(F, { fieldPathId: O, name: `${a}__fallback_type`, schema: I, formData: k, onChange: A, onBlur: f, onFocus: p, registry: g, hideLabel: !r, disabled: u, readonly: c, required: s }, n ? $a(n) : "__empty__"), schemaField: S.jsx(F, { ...e, schema: {
      type: k,
      title: v(ht.Value),
      ...k === "object" && { additionalProperties: !0 }
    } }) });
  }
  function mPe(e, t) {
    return Ud(t, function(n) {
      return e[n];
    });
  }
  function hPe(e) {
    return e == null ? [] : mPe(e, Xo(e));
  }
  var gPe = Math.max;
  function vPe(e, t, n, r) {
    e = Pu(e) ? e : hPe(e), n = n ? SV(n) : 0;
    var o = e.length;
    return n < 0 && (n = gPe(o + n, 0)), fl(e) ? n <= o && e.indexOf(t, n) > -1 : !!o && FV(e, t, n) > -1;
  }
  var yPe = Math.min;
  function bPe(e, t, n) {
    for (var r = JP, o = e[0].length, a = e.length, i = a, s = Array(a), u = 1 / 0, c = []; i--; ) {
      var f = e[i];
      u = yPe(f.length, u), s[i] = o >= 120 && f.length >= 120 ? new vu(i && f) : void 0;
    }
    f = e[0];
    var p = -1, g = s[0];
    e:
      for (; ++p < o && c.length < u; ) {
        var h = f[p], y = h;
        if (h = h !== 0 ? h : 0, !(g ? gm(g, y) : r(c, y))) {
          for (i = a; --i; ) {
            var b = s[i];
            if (!(b ? gm(b, y) : r(e[i], y)))
              continue e;
          }
          g && g.push(y), c.push(h);
        }
      }
    return c;
  }
  function wPe(e) {
    return ym(e) ? e : [];
  }
  var ZD = hx(function(e) {
    var t = Ud(e, wPe);
    return t.length && t[0] === e[0] ? bPe(t) : [];
  });
  function T1(e) {
    return e === void 0;
  }
  var La;
  (function(e) {
    e.ROW = "ui:row", e.COLUMN = "ui:col", e.COLUMNS = "ui:columns", e.CONDITION = "ui:condition";
  })(La || (La = {}));
  var Fp;
  (function(e) {
    e.ALL = "all", e.SOME = "some", e.NONE = "none";
  })(Fp || (Fp = {}));
  const xPe = /^\$lookup=(.+)/, _0 = "layoutGrid";
  function eL(e, t) {
    return e ?? t;
  }
  function kPe(e) {
    return /^\d+?$/.test(e);
  }
  const Zs = sO();
  function SPe(e, t, n, r, o) {
    const a = Ce(n, [aE], {}), i = Ce(n, e), s = { ...Ce(i, [Js], {}), ...t, ...a }, u = { ...i };
    Hn(s) || Qt(u, [Js], s), Hn(a) || Qt(u, [aE], a);
    let { readonly: c } = Qe(u);
    return (o === !0 || T1(c) && r === !0) && (c = !0, Et(s, e0) ? Qt(u, [Js, e0], !0) : Qt(u, `ui:${e0}`, !0)), { fieldUiSchema: u, uiReadonly: c };
  }
  function _Pe(e, t, n = "$0m3tH1nG Un3xP3cT3d") {
    const r = pE([t]).sort(), o = pE([n]).sort();
    switch (e) {
      case Fp.ALL:
        return vm(r, o);
      case Fp.SOME:
        return ZD(r, o).length > 0;
      case Fp.NONE:
        return ZD(r, o).length === 0;
      default:
        return !1;
    }
  }
  function _x(e, t, n) {
    let r = {}, o = e[t];
    if (dl(o)) {
      const { children: a, className: i, ...s } = o;
      if (o = a, i) {
        const u = i.split(" ").map((c) => cO(n, c, c)).join(" ");
        r = { ...s, className: u };
      } else
        r = s;
    }
    if (!Array.isArray(o))
      throw new TypeError(`Expected array for "${t}" in ${JSON.stringify(e)}`);
    return { children: o, gridProps: r };
  }
  function tL(e, t, n) {
    let r;
    if (kPe(n) && e && e?.type === "array" && Et(e, Ed)) {
      const o = Number(n), a = e[Ed];
      Array.isArray(a) ? o > a.length ? r = GV(a) : r = a[o] : r = a, t = {
        [rn]: t[rn],
        path: [...t.path.slice(0, t.path.length - 1), o]
      };
    }
    return { rawSchema: r, fieldPathId: t };
  }
  function EPe(e, t, n, r, o) {
    const { schemaUtils: a, globalFormOptions: i } = e;
    let s = n, u = o;
    const c = t.split("."), f = c.pop();
    let p = a.retrieveSchema(s, r), g = r, h = p.readOnly;
    c.forEach((v) => {
      if (u = Do(v, i, u), Et(p, Lt))
        s = Ce(p, [Lt, v], {});
      else if (p && (Et(p, pt) || Et(p, Nt))) {
        const w = Et(p, pt) ? pt : Nt, _ = a.findSelectedOptionInXxxOf(p, v, w, g);
        s = Ce(_, [Lt, v], {});
      } else {
        const w = tL(p, u, v);
        s = w.rawSchema ?? {}, u = w.fieldPathId;
      }
      g = Ce(g, v, {}), p = a.retrieveSchema(s, g), h = eL(p.readOnly, h);
    });
    let y, b = !1;
    if (Hn(p) && (p = void 0), p && f) {
      if (p && (Et(p, pt) || Et(p, Nt))) {
        const w = Et(p, pt) ? pt : Nt;
        p = a.findSelectedOptionInXxxOf(p, f, w, g);
      }
      u = Do(f, i, u), b = p !== void 0 && Array.isArray(p.required) && vPe(p.required, f);
      const v = tL(p, u, f);
      if (v.rawSchema ? (p = v.rawSchema, u = v.fieldPathId) : (p = Ce(p, [Lt, f]), p = p && a.retrieveSchema(p)), h = eL(p?.readOnly, h), p && (Et(p, pt) || Et(p, Nt))) {
        const w = Et(p, pt) ? pt : Nt, _ = Ga(p);
        y = { options: p[w], hasDiscriminator: !!_ };
      }
    }
    return { schema: p, isRequired: b, isReadonly: h, optionsInfo: y, fieldPathId: u };
  }
  function CPe(e, t) {
    let n = e;
    return fl(n) && (n = cO(t, n)), lh(n) ? n : null;
  }
  function PPe(e, t) {
    let n, r = null, o = {}, a;
    if (fl(t) || T1(t))
      n = t ?? "";
    else {
      const { name: i = "", render: s, ...u } = t;
      n = i, o = u, Hn(o) || MEe(o, (c, f) => {
        if (fl(c)) {
          const p = xPe.exec(c);
          if (Array.isArray(p) && p.length > 1) {
            const g = p[1];
            o[f] = cO(e, g, g);
          }
        }
      }), r = CPe(s, e), !i && r && (a = S.jsx(r, { ...u, "data-testid": Zs.uiComponent }));
    }
    return { name: n, UIComponent: r, uiProps: o, rendered: a };
  }
  function Ex(e) {
    const { childrenLayoutGridSchemaId: t, ...n } = e, { registry: r, schema: o, formData: a } = n, { schemaUtils: i } = r, s = i.retrieveSchema(o, a);
    return t.map((u) => C.createElement(gO, { ...n, key: `layoutGrid-${$a(u)}`, schema: s, layoutGridSchema: u }));
  }
  function OPe(e) {
    const { layoutGridSchema: t, ...n } = e, { formData: r, registry: o } = n, { children: a, gridProps: i } = _x(t, La.CONDITION, o), { operator: s, field: u = "", value: c } = i, f = Ce(r, u, null);
    return _Pe(s, f, c) ? S.jsx(Ex, { ...n, childrenLayoutGridSchemaId: a }) : null;
  }
  function NPe(e) {
    const { layoutGridSchema: t, ...n } = e, { registry: r, uiSchema: o } = n, { children: a, gridProps: i } = _x(t, La.COLUMN, r), s = Qe(o), u = et("GridTemplate", r, s);
    return S.jsx(u, { column: !0, "data-testid": Zs.col, ...i, children: S.jsx(Ex, { ...n, childrenLayoutGridSchemaId: a }) });
  }
  function MPe(e) {
    const { layoutGridSchema: t, ...n } = e, { registry: r, uiSchema: o } = n, { children: a, gridProps: i } = _x(t, La.COLUMNS, r), s = Qe(o), u = et("GridTemplate", r, s);
    return a.map((c) => S.jsx(u, { column: !0, "data-testid": Zs.col, ...i, children: S.jsx(Ex, { ...n, childrenLayoutGridSchemaId: [c] }) }, `column-${$a(c)}`));
  }
  function RPe(e) {
    const { layoutGridSchema: t, ...n } = e, { registry: r, uiSchema: o } = n, { children: a, gridProps: i } = _x(t, La.ROW, r), s = Qe(o), u = et("GridTemplate", r, s);
    return S.jsx(u, { ...i, "data-testid": Zs.row, children: S.jsx(Ex, { ...n, childrenLayoutGridSchemaId: a }) });
  }
  function jPe(e) {
    const {
      gridSchema: t,
      schema: n,
      uiSchema: r,
      errorSchema: o,
      fieldPathId: a,
      onBlur: i,
      onFocus: s,
      formData: u,
      readonly: c,
      registry: f,
      layoutGridSchema: p,
      // Used to pull this out of otherProps since we don't want to pass it through
      ...g
    } = e, { onChange: h } = g, { fields: y } = f, { SchemaField: b, LayoutMultiSchemaField: v } = y, w = PPe(f, t), { name: _, UIComponent: k, uiProps: E } = w, { schema: P, isRequired: O, isReadonly: M, optionsInfo: I, fieldPathId: A } = EPe(f, _, n, u, a), D = ju(A);
    if (w.rendered)
      return w.rendered;
    if (P) {
      const F = I?.hasDiscriminator ? v : b, { fieldUiSchema: j, uiReadonly: U } = SPe(_, E, r, M, c);
      return S.jsx(F, { "data-testid": I?.hasDiscriminator ? Zs.layoutMultiSchemaField : Zs.field, ...g, name: _, required: O, readonly: U, schema: P, uiSchema: j, errorSchema: Ce(o, _), fieldPathId: D, formData: Ce(u, _), onChange: h, onBlur: i, onFocus: s, options: I?.options, registry: f });
    }
    return k ? S.jsx(k, { "data-testid": Zs.uiComponent, ...g, name: _, required: O, formData: u, readOnly: !!M || c, errorSchema: o, uiSchema: r, schema: n, fieldPathId: a, onBlur: i, onFocus: s, registry: f, ...E }) : null;
  }
  function gO(e) {
    const { uiSchema: t } = e;
    let { layoutGridSchema: n } = e;
    const r = Qe(t);
    if (!n && _0 in r && jt(r[_0]) && (n = r[_0]), jt(n)) {
      if (La.ROW in n)
        return S.jsx(RPe, { ...e, layoutGridSchema: n });
      if (La.COLUMN in n)
        return S.jsx(NPe, { ...e, layoutGridSchema: n });
      if (La.COLUMNS in n)
        return S.jsx(MPe, { ...e, layoutGridSchema: n });
      if (La.CONDITION in n)
        return S.jsx(OPe, { ...e, layoutGridSchema: n });
    }
    return S.jsx(jPe, { ...e, gridSchema: n });
  }
  gO.TEST_IDS = Zs;
  function IPe(e) {
    const { fieldPathId: t, title: n, schema: r, uiSchema: o, required: a, registry: i, name: s } = e, u = Qe(o, i.globalUiOptions), { title: c } = u, { title: f } = r, p = c || n || f || s;
    if (!p)
      return null;
    const g = et("TitleFieldTemplate", i, u);
    return S.jsx(g, { id: yx(t), title: p, required: a, schema: r, uiSchema: o, registry: i });
  }
  function E0(e, t, n) {
    const r = "!@#!@$@#$!@$#";
    return e.map(({ schema: o }) => o).find((o) => {
      const a = Ce(o, [Lt, t]);
      return Ce(a, sx, Ce(a, Io, r)) === n;
    });
  }
  function nL(e, t, n, r, o) {
    const a = t.map((u) => n.retrieveSchema(u, o));
    let i = e;
    Et(e, pt) ? i = { ...e, [pt]: a } : Et(e, Nt) && (i = { ...e, [Nt]: a });
    const s = Od(i, r);
    if (!s)
      throw new Error(`No enumOptions were computed from the schema ${JSON.stringify(i)}`);
    return s;
  }
  function APe(e) {
    const { name: t, baseType: n, disabled: r = !1, formData: o, fieldPathId: a, onBlur: i, onChange: s, options: u, onFocus: c, registry: f, uiSchema: p, schema: g, autofocus: h, readonly: y, required: b, errorSchema: v, hideError: w = !1 } = e, { widgets: _, schemaUtils: k, globalUiOptions: E } = f, [P, O] = C.useState(nL(g, u, k, p, o)), M = Ce(a, rn), I = Ga(g), A = et("FieldErrorTemplate", f, u), D = et("FieldTemplate", f, u), F = $a(g), j = $a(u), U = p ? $a(p) : "", $ = o ? $a(o) : "";
    C.useEffect(() => {
      O(nL(g, u, k, p, o));
    }, [F, j, k, U, $]);
    const { widget: q = I ? "radio" : "select", title: B = "", placeholder: G = "", optionsSchemaSelector: W = I, hideError: Y, ...z } = Qe(p);
    if (!W)
      throw new Error("No selector field provided for the LayoutMultiSchemaField");
    const L = Ce(o, W);
    let K = Ce(P[0]?.schema, [Lt, W], {});
    const T = E0(P, W, L);
    K = K?.type ? K : { ...K, type: T?.type || n };
    const V = Xa(K, q, _), X = Y === void 0 ? w : !!Y, Q = Ce(v, [cr], []), ne = bm(v, [cr]), te = k.getDisplayLabel(g, p, E), ae = (ee) => {
      const oe = E0(P, W, ee), le = E0(P, W, L);
      let be = k.sanitizeDataForNewSchema(oe, le, o);
      be && oe && (be = k.getDefaultFormState(oe, be, "excludeObjectChildren")), be && Qt(be, W, ee), s(be, a.path, void 0, M);
    }, ce = { enumOptions: P, ...z }, Z = !X && Q.length > 0 ? S.jsx(A, { fieldPathId: a, schema: g, errors: Q, registry: f }) : void 0;
    return S.jsx(D, { id: M, schema: g, label: (B || g.title) ?? "", disabled: r || Array.isArray(P) && Hn(P), uiSchema: p, required: b, readonly: !!y, registry: f, displayLabel: te, errors: Z, onChange: s, onKeyRename: Hy, onKeyRenameBlur: Hy, onRemoveProperty: Hy, children: S.jsx(V, { id: M, name: t, schema: g, label: (B || g.title) ?? "", disabled: r || Array.isArray(P) && Hn(P), uiSchema: p, autofocus: h, readonly: y, required: b, registry: f, multiple: !1, rawErrors: Q, hideError: X, hideLabel: !te, errorSchema: ne, placeholder: G, onChange: ae, onBlur: i, onFocus: c, value: L, options: ce, htmlName: a.name }) });
  }
  class rL extends C.Component {
    /** Constructs an `AnyOfField` with the given `props` to initialize the initially selected option in state
     *
     * @param props - The `FieldProps` for this template
     */
    constructor(n) {
      super(n);
      /** Callback handler to remember what the currently selected option is. In addition to that the `formData` is updated
       * to remove properties that are not part of the newly selected option schema, and then the updated data is passed to
       * the `onChange` handler.
       *
       * @param option - The new option value being selected
       */
      Gn(this, "onOptionChange", (n) => {
        const { selectedOption: r, retrievedOptions: o } = this.state, { formData: a, onChange: i, registry: s, fieldPathId: u } = this.props, { schemaUtils: c } = s, f = n !== void 0 ? parseInt(n, 10) : -1;
        if (f === r)
          return;
        const p = f >= 0 ? o[f] : void 0, g = r >= 0 ? o[r] : void 0;
        let h = c.sanitizeDataForNewSchema(p, g, a);
        p && (h = c.getDefaultFormState(p, h, "excludeObjectChildren")), this.setState({ selectedOption: f }, () => {
          i(h, u.path, void 0, this.getFieldId());
        });
      });
      const { formData: r, options: o, registry: { schemaUtils: a } } = this.props, i = o.map((s) => a.retrieveSchema(s, r));
      this.state = {
        retrievedOptions: i,
        selectedOption: this.getMatchingOption(0, r, i)
      };
    }
    /** React lifecycle method that is called when the props and/or state for this component is updated. It recomputes the
     * currently selected option based on the overall `formData`
     *
     * @param prevProps - The previous `FieldProps` for this template
     * @param prevState - The previous `AnyOfFieldState` for this template
     */
    componentDidUpdate(n, r) {
      const { formData: o, options: a, fieldPathId: i } = this.props, { selectedOption: s } = this.state;
      let u = this.state;
      if (!fn(n.options, a)) {
        const { registry: { schemaUtils: c } } = this.props, f = a.map((p) => c.retrieveSchema(p, o));
        u = { selectedOption: s, retrievedOptions: f };
      }
      if (!fn(o, n.formData) && i.$id === n.fieldPathId.$id) {
        const { retrievedOptions: c } = u, f = this.getMatchingOption(s, o, c);
        r && f !== s && (u = { selectedOption: f, retrievedOptions: c });
      }
      u !== this.state && this.setState(u);
    }
    /** Determines the best matching option for the given `formData` and `options`.
     *
     * @param formData - The new formData
     * @param options - The list of options to choose from
     * @return - The index of the `option` that best matches the `formData`
     */
    getMatchingOption(n, r, o) {
      const { schema: a, registry: { schemaUtils: i } } = this.props, s = Ga(a);
      return i.getClosestMatchingOption(r, o, n, s);
    }
    getFieldId() {
      const { fieldPathId: n, schema: r } = this.props;
      return `${n.$id}${r.oneOf ? "__oneof_select" : "__anyof_select"}`;
    }
    /** Renders the `AnyOfField` selector along with a `SchemaField` for the value of the `formData`
     */
    render() {
      const { name: n, disabled: r = !1, errorSchema: o = {}, formData: a, onBlur: i, onFocus: s, readonly: u, required: c = !1, registry: f, schema: p, uiSchema: g } = this.props, { widgets: h, fields: y, translateString: b, globalUiOptions: v, schemaUtils: w } = f, { SchemaField: _ } = y, k = et("MultiSchemaFieldTemplate", f, v), E = mh(f, p, c, g), P = qd(a), { selectedOption: O, retrievedOptions: M } = this.state, { widget: I = "select", placeholder: A, autofocus: D, autocomplete: F, title: j = p.title, ...U } = Qe(g, v), $ = Xa({ type: "number" }, I, h), q = Ce(o, cr, []), B = bm(o, [cr]), G = w.getDisplayLabel(p, g, v), W = O >= 0 && M[O] || null;
      let Y;
      if (W) {
        const { required: ne } = p;
        Y = ne ? Yi({ required: ne }, W) : W;
      }
      let z = [];
      pt in p && g && pt in g ? Array.isArray(g[pt]) ? z = g[pt] : console.warn(`uiSchema.oneOf is not an array for "${j || n}"`) : Nt in p && g && Nt in g && (Array.isArray(g[Nt]) ? z = g[Nt] : console.warn(`uiSchema.anyOf is not an array for "${j || n}"`));
      let L = g;
      O >= 0 && z.length > O && (L = z[O]);
      const K = j ? ht.TitleOptionPrefix : ht.OptionPrefix, T = j ? [j] : [], V = M.map((ne, te) => {
        const { title: ae = ne.title } = Qe(z[te]);
        return {
          label: ae || b(K, T.concat(String(te + 1))),
          value: te
        };
      }), X = !E || P ? S.jsx($, { id: this.getFieldId(), name: `${n}${p.oneOf ? "__oneof_select" : "__anyof_select"}`, schema: { type: "number", default: 0 }, onChange: this.onOptionChange, onBlur: i, onFocus: s, disabled: r || Hn(V), multiple: !1, rawErrors: q, errorSchema: B, value: O >= 0 ? O : void 0, options: { enumOptions: V, ...U }, registry: f, placeholder: A, autocomplete: F, autofocus: D, label: j ?? n, hideLabel: !G, readonly: u }) : void 0, Q = Y && Y.type !== "null" && S.jsx(_, { ...this.props, schema: Y, uiSchema: L }) || null;
      return S.jsx(k, { schema: p, registry: f, uiSchema: g, selector: X, optionSchemaField: Q });
    }
  }
  const $Pe = /\.([0-9]*0)*$/, DPe = /[0.]0*$/;
  function LPe(e) {
    const { registry: t, onChange: n, formData: r, value: o } = e, [a, i] = C.useState(o), { StringField: s } = t.fields;
    let u = r;
    const c = C.useCallback((f, p, g, h) => {
      i(f), `${f}`.charAt(0) === "." && (f = `0${f}`);
      const y = typeof f == "string" && f.match($Pe) ? w3(f.replace(DPe, "")) : w3(f);
      n(y, p, g, h);
    }, [n]);
    if (typeof a == "string" && typeof u == "number") {
      const f = new RegExp(`^(${String(u).replace(".", "\\.")})?\\.?0*$`);
      a.match(f) && (u = a);
    }
    return S.jsx(s, { ...e, formData: u, onChange: c });
  }
  function Oa() {
    return Oa = Object.assign ? Object.assign.bind() : function(e) {
      for (var t = 1; t < arguments.length; t++) {
        var n = arguments[t];
        for (var r in n) ({}).hasOwnProperty.call(n, r) && (e[r] = n[r]);
      }
      return e;
    }, Oa.apply(null, arguments);
  }
  const ly = ["strong", "em", "del", "mark"], oL = [["**", ly[0]], ["__", ly[0]], ["~~", ly[2]], ["==", ly[3]], ["*", "em"], ["_", "em"]];
  function FPe(e, t) {
    for (var n = 1, r = t + 1; r < e.length && n > 0; ) e[r] !== "\\" ? (e[r] === "[" && n++, e[r] === "]" && n--, r++) : r += 2;
    if (n === 0 && r < e.length && (e[r] === "(" || e[r] === "[")) {
      var o = e[r] === "(" ? ")" : "]", a = 1;
      for (r++; r < e.length && a > 0; ) e[r] !== "\\" ? (e[r] === "(" && o === ")" && a++, e[r] === o && a--, r++) : r += 2;
      if (a === 0) return r;
    }
    return -1;
  }
  function TPe(e, t) {
    if (!t || !t.inline && !t.simple) return null;
    var n = e[0];
    if (n !== "*" && n !== "_" && n !== "~" && n !== "=") return null;
    for (var r = "", o = 0, a = "", i = 0; i < 6; i++) {
      var s = oL[i][0];
      if (e.startsWith(s) && e.length >= 2 * s.length) {
        r = s, o = s.length, a = oL[i][1];
        break;
      }
    }
    if (!r) return null;
    for (var u = o, c = !1, f = !1, p = "", g = 0, h = "", y = !1, b = ""; u < e.length; ) {
      var v = e[u];
      if (y) h += v, y = !1, b = v, u++;
      else if (v !== "\\") if (v !== "`" || g !== 0) {
        if (v === "[" && !c && g === 0) {
          var w = FPe(e, u);
          if (w !== -1) {
            h += e.slice(u, w), u = w, b = e[w - 1];
            continue;
          }
        }
        if (f) h += v, p ? v === p && (p = "") : v === '"' || v === "'" ? p = v : v === ">" && (f = !1), b = v, u++;
        else if (v !== "<" || c) {
          if (v === `
` && b === `
` && !c && g === 0) return null;
          if (!c && g === 0) {
            for (var _ = 0; u + _ < e.length && e[u + _] === r[0]; ) _++;
            if (_ >= o && (o !== 1 || r !== "*" && r !== "_" || e[u - 1] !== r && e[u + 1] !== r)) {
              var k = [e.slice(0, u + _), a, h + e.slice(u + o, u + _)];
              return k.index = 0, k.input = e, k;
            }
          }
          h += v, b = v, u++;
        } else {
          var E = e[u + 1], P = e.indexOf(">", u);
          if (P !== -1) {
            var O = e.slice(u, P + 1).endsWith("/>");
            E === "/" ? g = Math.max(0, g - 1) : O || g++;
          }
          f = !0, h += v, b = v, u++;
        }
      } else c = !c, h += v, b = v, u++;
      else h += v, y = !0, b = v, u++;
    }
    return null;
  }
  const zPe = ["children", "options"], aL = ["allowFullScreen", "allowTransparency", "autoComplete", "autoFocus", "autoPlay", "cellPadding", "cellSpacing", "charSet", "classId", "colSpan", "contentEditable", "contextMenu", "crossOrigin", "encType", "formAction", "formEncType", "formMethod", "formNoValidate", "formTarget", "frameBorder", "hrefLang", "inputMode", "keyParams", "keyType", "marginHeight", "marginWidth", "maxLength", "mediaGroup", "minLength", "noValidate", "radioGroup", "readOnly", "rowSpan", "spellCheck", "srcDoc", "srcLang", "srcSet", "tabIndex", "useMap"].reduce((e, t) => (e[t.toLowerCase()] = t, e), { class: "className", for: "htmlFor" }), iL = { amp: "&", apos: "'", gt: ">", lt: "<", nbsp: "", quot: "" }, BPe = ["style", "script", "pre"], VPe = ["src", "href", "data", "formAction", "srcDoc", "action"], UPe = /([-A-Z0-9_:]+)(?:\s*=\s*(?:(?:"((?:\\.|[^"])*)")|(?:'((?:\\.|[^'])*)')|(?:\{((?:\\.|{[^}]*?}|[^}])*)\})))?/gi, HPe = /\n{2,}$/, sL = /^(\s*>[\s\S]*?)(?=\n\n|$)/, WPe = /^ *> ?/gm, qPe = /^(?:\[!([^\]]*)\]\n)?([\s\S]*)/, KPe = /^ {2,}\n/, GPe = /^(?:([-*_])( *\1){2,}) *(?:\n *)+\n/, lL = /^(?: {1,3})?(`{3,}|~{3,}) *(\S+)? *([^\n]*?)?\n([\s\S]*?)(?:\1\n?|$)/, uL = /^(?: {4}[^\n]+\n*)+(?:\n *)+\n?/, XPe = /^(`+)((?:\\`|(?!\1)`|[^`])+)\1/, YPe = /^(?:\n *)*\n/, JPe = /\r\n?/g, QPe = /^\[\^([^\]]+)](:(.*)((\n+ {4,}.*)|(\n(?!\[\^).+))*)/, ZPe = /^\[\^([^\]]+)]/, eOe = /\f/g, tOe = /^---[ \t]*\n(.|\n)*\n---[ \t]*\n/, nOe = /^\[(x|\s)\]/, cL = /^(#{1,6}) *([^\n]+?)(?: +#*)?(?:\n *)*(?:\n|$)/, dL = /^ *(#{1,6}) +([^\n]+?)(?: +#*)?(?:\n *)*(?:\n|$)/, fL = /^([^\n]+)\n *(=|-)\2{2,} *\n/, vO = /^<([a-z][^ >/]*) ?((?:[^>]*[^/])?)>/i;
  function rOe(e) {
    const t = vO.exec(e);
    if (!t) return null;
    const n = t[1], r = n.toLowerCase(), o = r.length + 1;
    let a = t[0].length;
    e[a] === `
` && a++;
    const i = a;
    let s = a, u = 1;
    const c = e.length;
    for (; u > 0; ) {
      const p = e.indexOf("<", a);
      if (p === -1) return null;
      let g = -1, h = -1;
      if (e[p + 1] === "/") h = p;
      else if (e[p + 1] === r[0] || e[p + 1] === n[0]) {
        let y = !0;
        for (let b = 0; b < r.length; b++) {
          const v = e[p + 1 + b];
          if (v !== r[b] && v !== n[b]) {
            y = !1;
            break;
          }
        }
        !y || e[p + o] !== " " && e[p + o] !== ">" || (g = p);
      }
      if (g !== -1 || h !== -1) if (g !== -1 && (h === -1 || g < h)) a = g + o + 1, u++;
      else {
        let y = h + 2;
        for (; y < c; ) {
          const v = e[y];
          if (v !== " " && v !== "	" && v !== `
` && v !== "\r") break;
          y++;
        }
        if (y + r.length > c) return null;
        let b = !0;
        for (let v = 0; v < r.length; v++) {
          const w = e[y + v];
          if (w !== r[v] && w !== n[v]) {
            b = !1;
            break;
          }
        }
        if (!b) {
          a = y;
          continue;
        }
        for (y += r.length; y < c; ) {
          const v = e[y];
          if (v !== " " && v !== "	" && v !== `
` && v !== "\r") break;
          y++;
        }
        if (y >= c || e[y] !== ">") {
          a = y;
          continue;
        }
        s = h, a = y + 1, u--;
      }
      else a = p + 1;
    }
    let f = 0;
    for (; a + f < c && e[a + f] === `
`; ) f++;
    return [e.slice(0, a + f), n, t[2], e.slice(i, s)];
  }
  const oOe = /&([a-z0-9]+|#[0-9]{1,6}|#x[0-9a-fA-F]{1,6});/gi, pL = /^<!--[\s\S]*?(?:-->)/, aOe = /^(data|aria|x)-[a-z_][a-z\d_.-]*$/, yE = /^ *<([a-z][a-z0-9:]*)(?:\s+((?:<.*?>|[^>])*))?\/?>(?!<\/\1>)(\s*\n)?/i, iOe = /^\{.*\}$/, sOe = /^(https?:\/\/[^\s<]+[^<.,:;"')\]\s])/, lOe = /^<([^ >]+[:@\/][^ >]+)>/, uOe = /-([a-z])?/gi, mL = /^(\|.*)\n(?: *(\|? *[-:]+ *\|[-| :]*)\n((?:.*\|.*\n)*))?\n?/, cOe = /^[^\n]+(?:  \n|\n{2,})/, dOe = /^\[([^\]]*)\]:\s+<?([^\s>]+)>?\s*("([^"]*)")?/, fOe = /^!\[([^\]]*)\] ?\[([^\]]*)\]/, pOe = /^\[([^\]]*)\] ?\[([^\]]*)\]/, mOe = /(\n|^[-*]\s|^#|^ {2,}|^-{2,}|^>\s)/, hOe = /\t/g, gOe = /(^ *\||\| *$)/g, vOe = /^ *:-+: *$/, yOe = /^ *:-+ *$/, bOe = /^ *-+: *$/, wOe = /^(:[a-zA-Z0-9-_]+:)/, xOe = /^\\([^0-9A-Za-z\s])/, kOe = /\\([^0-9A-Za-z\s])/g, SOe = /^[\s\S](?:(?!  \n|[0-9]\.|http)[^=*_~\-\n:<`\\\[!])*/, _Oe = /^\n+/, EOe = /^([ \t]*)/, COe = /(?:^|\n)( *)$/, yO = "(?:\\d+\\.)", bO = "(?:[*+-])";
  function z1(e) {
    return "( *)(" + (e === 1 ? yO : bO) + ") +";
  }
  const B1 = z1(1), V1 = z1(2);
  function U1(e) {
    return RegExp("^" + (e === 1 ? B1 : V1));
  }
  const POe = U1(1), OOe = U1(2);
  function H1(e) {
    return RegExp("^" + (e === 1 ? B1 : V1) + "[^\\n]*(?:\\n(?!\\1" + (e === 1 ? yO : bO) + " )[^\\n]*)*(\\n|$)", "gm");
  }
  const NOe = H1(1), MOe = H1(2);
  function W1(e) {
    const t = e === 1 ? yO : bO;
    return RegExp("^( *)(" + t + ") [\\s\\S]+?(?:\\n{2,}(?! )(?!\\1" + t + " (?!" + t + " ))\\n*|\\s*\\n*$)");
  }
  const q1 = W1(1), K1 = W1(2);
  function hL(e, t) {
    const n = t === 1, r = n ? q1 : K1, o = n ? NOe : MOe, a = n ? POe : OOe;
    return { t: (i) => a.test(i), o: Xs(function(i, s) {
      const u = COe.exec(s.prevCapture);
      return u && (s.list || !s.inline && !s.simple) ? r.exec(i = u[1] + i) : null;
    }), u: 1, i(i, s, u) {
      const c = n ? +i[2] : void 0, f = i[0].replace(HPe, `
`).match(o), p = a.exec(f[0]), g = RegExp("^ {1," + (p ? p[0].length : 0) + "}", "gm");
      let h = !1;
      return { items: f.map(function(y, b) {
        const v = y.replace(g, "").replace(a, ""), w = b === f.length - 1, _ = wa(v, `

`) || w && h;
        h = _;
        const k = u.inline, E = u.list;
        let P;
        u.list = !0, _ ? (u.inline = !1, P = Tp(v) + `

`) : (u.inline = !0, P = Tp(v));
        const O = s(P, u);
        return u.inline = k, u.list = E, O;
      }), ordered: n, start: c };
    } };
  }
  const ROe = RegExp(`^\\[((?:\\[[^\\[\\]]*(?:\\[[^\\[\\]]*\\][^\\[\\]]*)*\\]|[^\\[\\]])*)\\]\\(\\s*<?((?:\\([^)]*\\)|[^\\s\\\\]|\\\\.)*?)>?(?:\\s+['"]([\\s\\S]*?)['"])?\\s*\\)`), jOe = /^!\[(.*?)\]\( *((?:\([^)]*\)|[^() ])*) *"?([^)"]*)?"?\)/;
  function gL(e) {
    return typeof e == "string";
  }
  function Tp(e) {
    let t = e.length;
    for (; t > 0 && e[t - 1] <= " "; ) t--;
    return e.slice(0, t);
  }
  function bE(e, t) {
    return e.startsWith(t);
  }
  function wa(e, t) {
    return e.indexOf(t) !== -1;
  }
  function IOe(e, t, n) {
    if (Array.isArray(n)) {
      for (let r = 0; r < n.length; r++) if (bE(e, n[r])) return !0;
      return !1;
    }
    return n(e, t);
  }
  function op(e) {
    return e.replace(/[]/g, "a").replace(/[]/g, "c").replace(/[]/g, "d").replace(/[]/g, "e").replace(/[]/g, "i").replace(/[]/g, "n").replace(/[]/g, "o").replace(/[]/g, "u").replace(/[]/g, "y").replace(/[^a-z0-9- ]/gi, "").replace(/ /gi, "-").toLowerCase();
  }
  function AOe(e) {
    return bOe.test(e) ? "right" : vOe.test(e) ? "center" : yOe.test(e) ? "left" : null;
  }
  function vL(e, t, n, r) {
    const o = n.inTable;
    n.inTable = !0;
    let a = [[]], i = "";
    function s() {
      if (!i) return;
      const u = a[a.length - 1];
      u.push.apply(u, t(i, n)), i = "";
    }
    return e.trim().split(/(`[^`]*`|\\\||\|)/).filter(Boolean).forEach((u, c, f) => {
      u.trim() === "|" && (s(), r) ? c !== 0 && c !== f.length - 1 && a.push([]) : i += u;
    }), s(), n.inTable = o, a;
  }
  function $Oe(e, t, n) {
    n.inline = !0;
    const r = e[2] ? e[2].replace(gOe, "").split("|").map(AOe) : [], o = e[3] ? (function(i, s, u) {
      return i.trim().split(`
`).map(function(c) {
        return vL(c, s, u, !0);
      });
    })(e[3], t, n) : [], a = vL(e[1], t, n, !!o.length);
    return n.inline = !1, o.length ? { align: r, cells: o, header: a, type: "25" } : { children: a, type: "21" };
  }
  function yL(e, t) {
    return e.align[t] == null ? {} : { textAlign: e.align[t] };
  }
  function Xs(e) {
    return e.inline = 1, e;
  }
  function Ts(e) {
    return Xs(function(t, n) {
      return n.inline ? e.exec(t) : null;
    });
  }
  function uy(e) {
    return Xs(function(t, n) {
      return n.inline || n.simple ? e.exec(t) : null;
    });
  }
  function ji(e) {
    return function(t, n) {
      return n.inline || n.simple ? null : e.exec(t);
    };
  }
  function bL(e) {
    return Xs(function(t) {
      return e.exec(t);
    });
  }
  const DOe = /(javascript|vbscript|data(?!:image)):/i;
  function LOe(e) {
    try {
      const t = decodeURIComponent(e).replace(/[^A-Za-z0-9/:]/g, "");
      if (DOe.test(t)) return null;
    } catch {
      return null;
    }
    return e;
  }
  function ka(e) {
    return e && e.replace(kOe, "$1");
  }
  function Gy(e, t, n) {
    const r = n.inline || !1, o = n.simple || !1;
    n.inline = !0, n.simple = !0;
    const a = e(t, n);
    return n.inline = r, n.simple = o, a;
  }
  function FOe(e, t, n) {
    const r = n.inline || !1, o = n.simple || !1;
    n.inline = !1, n.simple = !0;
    const a = e(t, n);
    return n.inline = r, n.simple = o, a;
  }
  function TOe(e, t, n) {
    const r = n.inline || !1;
    n.inline = !1;
    const o = e(t, n);
    return n.inline = r, o;
  }
  const zOe = (e, t, n) => ({ children: Gy(t, e[2], n) });
  function C0() {
    return {};
  }
  function BOe(...e) {
    return e.filter(Boolean).join(" ");
  }
  function P0(e, t, n) {
    let r = e;
    const o = t.split(".");
    for (; o.length && (r = r[o[0]], r !== void 0); ) o.shift();
    return r || n;
  }
  function O0(e, t, n, r) {
    if (!t || !t.trim()) return null;
    const o = t.match(UPe);
    return o ? o.reduce(function(a, i) {
      const s = i.indexOf("=");
      if (s !== -1) {
        const u = (function(p) {
          return p.indexOf("-") !== -1 && p.match(aOe) === null && (p = p.replace(uOe, function(g, h) {
            return h.toUpperCase();
          })), p;
        })(i.slice(0, s)).trim(), c = aL[u] || u;
        if (c === "ref") return a;
        const f = a[c] = (function(p, g, h, y) {
          return g === "style" ? (function(b) {
            const v = [];
            if (!b) return v;
            let w = "", _ = 0, k = "";
            for (let P = 0; P < b.length; P++) {
              const O = b[P];
              if (O === '"' || O === "'") k ? O === k && (k = "", _--) : (k = O, _++);
              else if (O === "(" && w.endsWith("url")) _++;
              else if (O === ")" && _ > 0) _--;
              else if (O === ";" && _ === 0) {
                const M = w.indexOf(":");
                M > 0 && v.push([w.slice(0, M).trim(), w.slice(M + 1).trim()]), w = "";
                continue;
              }
              w += O;
            }
            const E = w.indexOf(":");
            return E > 0 && v.push([w.slice(0, E).trim(), w.slice(E + 1).trim()]), v;
          })(h).reduce(function(b, [v, w]) {
            return b[v.replace(/(-[a-z])/g, (_) => _[1].toUpperCase())] = y(w, p, v), b;
          }, {}) : VPe.indexOf(g) !== -1 ? y(ka(h), p, g) : (h.match(iOe) && (h = ka(h.slice(1, h.length - 1))), h === "true" || h !== "false" && h);
        })(e, u, (function(p) {
          const g = p[0];
          return (g === '"' || g === "'") && p.length >= 2 && p[p.length - 1] === g ? p.slice(1, -1) : p;
        })(i.slice(s + 1).trim()), n);
        typeof f == "string" && (vO.test(f) || yE.test(f)) && (a[c] = r(f.trim()));
      } else i !== "style" && (a[aL[i] || i] = !0);
      return a;
    }, {}) : null;
  }
  function wL(e, t) {
    for (let n = 0; n < e.length; n++) if (e[n].test(t)) return !0;
    return !1;
  }
  function VOe(e = "", t = {}) {
    t.overrides = t.overrides || {}, t.namedCodesToUnicode = t.namedCodesToUnicode ? Oa({}, iL, t.namedCodesToUnicode) : iL;
    const n = t.slugify || op, r = t.sanitizer || LOe, o = t.createElement || C.createElement, a = [sL, lL, uL, t.enforceAtxHeadings ? dL : cL, fL, mL, q1, K1], i = [...a, cOe, vO, pL, yE];
    function s(y, b, ...v) {
      const w = P0(t.overrides, y + ".props", {});
      return o((function(_, k) {
        const E = P0(k, _);
        return E ? typeof E == "function" || typeof E == "object" && "render" in E ? E : P0(k, _ + ".component", _) : _;
      })(y, t.overrides), Oa({}, b, w, { className: BOe(b?.className, w.className) || void 0 }), ...v);
    }
    function u(y) {
      y = y.replace(tOe, "");
      let b = !1;
      t.forceInline ? b = !0 : t.forceBlock || (b = mOe.test(y) === !1);
      const v = g(b ? y : Tp(y).replace(_Oe, "") + `

`, { inline: b });
      if (t.ast) return v;
      const w = h(v);
      for (; gL(w[w.length - 1]) && !w[w.length - 1].trim(); ) w.pop();
      if (c.length && w.push(s("footer", { key: "footer" }, c.map(function(E) {
        return s("div", { id: n(E.identifier, op), key: E.identifier }, E.identifier, h(g(E.footnote, { inline: !0 })));
      }))), t.wrapper === null) return w;
      const _ = t.wrapper || (b ? "span" : "div");
      let k;
      if (w.length > 1 || t.forceWrapper) k = w;
      else {
        if (w.length === 1) return k = w[0], typeof k == "string" ? s("span", { key: "outer" }, k) : k;
        k = null;
      }
      return o(_, Oa({ key: "outer" }, t.wrapperProps), k);
    }
    const c = [], f = {}, p = { 0: { t: [">"], o: ji(sL), u: 1, i(y, b, v) {
      const [, w, _] = y[0].replace(WPe, "").match(qPe);
      return { alert: w, children: b(_, v) };
    } }, 1: { t: ["  "], o: Ts(KPe), u: 1, i: C0 }, 2: { t: function(y, b) {
      if (b.inline || b.simple) return !1;
      var v = y[0];
      return v === "-" || v === "*" || v === "_";
    }, o: ji(GPe), u: 1, i: C0 }, 3: { t: ["    "], o: ji(uL), u: 0, i: (y) => ({ lang: void 0, text: ka(Tp(y[0].replace(/^ {4}/gm, ""))) }) }, 4: { t: ["```", "~~~"], o: ji(lL), u: 0, i: (y) => ({ attrs: O0("code", y[3] || "", r, u), lang: y[2] || void 0, text: y[4], type: "3" }) }, 5: { t: ["`"], o: uy(XPe), u: 3, i: (y) => ({ text: ka(y[2]) }) }, 6: { t: ["[^"], o: ji(QPe), u: 0, i: (y) => (c.push({ footnote: y[2], identifier: y[1] }), {}) }, 7: { t: ["[^"], o: Ts(ZPe), u: 1, i: (y) => ({ target: "#" + n(y[1], op), text: y[1] }) }, 8: { t: ["[ ]", "[x]"], o: Ts(nOe), u: 1, i: (y) => ({ completed: y[1].toLowerCase() === "x" }) }, 9: { t: ["#"], o: ji(t.enforceAtxHeadings ? dL : cL), u: 1, i: (y, b, v) => ({ children: Gy(b, y[2], v), id: n(y[2], op), level: y[1].length }) }, 10: { t: (y) => {
      const b = y.indexOf(`
`);
      return b > 0 && b < y.length - 1 && (y[b + 1] === "=" || y[b + 1] === "-");
    }, o: ji(fL), u: 1, i: (y, b, v) => ({ children: Gy(b, y[1], v), level: y[2] === "=" ? 1 : 2, type: "9" }) }, 11: { t: ["<"], o: Xs(rOe), u: 1, i(y, b, v) {
      const [, w] = y[3].match(EOe), _ = RegExp("^" + w, "gm"), k = y[3].replace(_, ""), E = wL(i, k) ? TOe : Gy, P = y[1].toLowerCase(), O = BPe.indexOf(P) !== -1, M = (O ? P : y[1]).trim(), I = { attrs: O0(M, y[2], r, u), noInnerParse: O, tag: M };
      if (v.inAnchor = v.inAnchor || P === "a", O) I.text = y[3];
      else {
        const A = v.inHTML;
        v.inHTML = !0, I.children = E(b, k, v), v.inHTML = A;
      }
      return v.inAnchor = !1, I;
    } }, 13: { t: ["<"], o: bL(yE), u: 1, i(y) {
      const b = y[1].trim();
      return { attrs: O0(b, y[2] || "", r, u), tag: b };
    } }, 12: { t: ["<!--"], o: bL(pL), u: 1, i: () => ({}) }, 14: { t: ["!["], o: uy(jOe), u: 1, i: (y) => ({ alt: ka(y[1]), target: ka(y[2]), title: ka(y[3]) }) }, 15: { t: ["["], o: Ts(ROe), u: 3, i: (y, b, v) => ({ children: FOe(b, y[1], v), target: ka(y[2]), title: ka(y[3]) }) }, 16: { t: function(y, b) {
      return !(!b.inline || b.inAnchor) && y[0] === "<" && (wa(y, ":") || wa(y, "@") || wa(y, "/"));
    }, o: Ts(lOe), u: 0, i(y) {
      let b = y[1], v = !1;
      return wa(b, "@") && !wa(b, "//") && (v = !0, b = b.replace("mailto:", "")), { children: [{ text: b, type: "27" }], target: v ? "mailto:" + b : b, type: "15" };
    } }, 17: { t: (y, b) => !b.inAnchor && !t.disableAutoLink && bE(y, "http"), o: Ts(sOe), u: 0, i: (y) => ({ children: [{ text: y[1], type: "27" }], target: y[1], title: void 0, type: "15" }) }, 20: hL(0, 1), 30: hL(0, 2), 19: { t: [`
`], o: ji(YPe), u: 3, i: C0 }, 21: { t: function(y, b) {
      return !b.inline && !b.simple;
    }, o: Xs(function(y, b) {
      if (b.inline || b.simple || b.inHTML && !wa(y, `

`) && !wa(b.prevCapture, `

`)) return null;
      let v = "", w = 0;
      for (; ; ) {
        const k = y.indexOf(`
`, w), E = y.slice(w, k === -1 ? void 0 : k + 1), P = y[w];
        if ((P === ">" || P === "#" || P === "|" || P === "`" || P === "~" || P === "*" || P === "-" || P === "_" || P === " ") && wL(a, E) || (v += E, k === -1 || !E.trim())) break;
        w = k + 1;
      }
      const _ = Tp(v);
      return _ === "" ? null : [v, , _];
    }), u: 3, i: zOe }, 22: { t: ["["], o: Ts(dOe), u: 0, i: (y) => (f[y[1]] = { target: y[2], title: y[4] }, {}) }, 23: { t: ["!["], o: uy(fOe), u: 0, i: (y) => ({ alt: y[1] ? ka(y[1]) : void 0, ref: y[2] }) }, 24: { t: (y) => y[0] === "[" && !wa(y, "]("), o: Ts(pOe), u: 0, i: (y, b, v) => ({ children: b(y[1], v), fallbackChildren: y[0], ref: y[2] }) }, 25: { t: ["|"], o: ji(mL), u: 1, i: $Oe }, 27: { o: Xs(function(y, b) {
      let v;
      return bE(y, ":") && (v = wOe.exec(y)), v || SOe.exec(y);
    }), u: 4, i(y) {
      const b = y[0];
      return { text: wa(b, "&") ? b.replace(oOe, (v, w) => t.namedCodesToUnicode[w] || v) : b };
    } }, 34: { t: ["*", "_", "~", "="], o: Xs(TPe), u: 2, i: (y, b, v) => ({ children: b(y[2], v), tag: y[1] }) }, 28: { t: ["\\"], o: uy(xOe), u: 1, i: (y) => ({ text: y[1], type: "27" }) } };
    t.disableParsingRawHTML === !0 && (delete p[11], delete p[13]);
    const g = (function(y) {
      var b = Object.keys(y);
      function v(w, _) {
        var k = [];
        if (_.prevCapture = _.prevCapture || "", w.trim()) for (; w; ) for (var E = 0; E < b.length; ) {
          var P = b[E], O = y[P];
          if (!O.t || IOe(w, _, O.t)) {
            var M = O.o(w, _);
            if (M && M[0]) {
              w = w.substring(M[0].length);
              var I = O.i(M, v, _);
              _.prevCapture += M[0], I.type || (I.type = P), k.push(I);
              break;
            }
            E++;
          } else E++;
        }
        return _.prevCapture = "", k;
      }
      return b.sort(function(w, _) {
        return y[w].u - y[_].u || (w < _ ? -1 : 1);
      }), function(w, _) {
        return v((function(k) {
          return k.replace(JPe, `
`).replace(eOe, "").replace(hOe, "    ");
        })(w), _);
      };
    })(p), h = /* @__PURE__ */ (function(y, b, v, w, _) {
      function k(E) {
        return Array.isArray(E) ? E.map((P) => "text" in P ? P.text : "") : "text" in E ? E.text : "";
      }
      return function E(P, O = {}) {
        const M = (O.renderDepth || 0) + 1;
        if (M > 2500) return k(P);
        O.renderDepth = M;
        try {
          if (Array.isArray(P)) {
            const A = O.key, D = [];
            let F = !1;
            for (let j = 0; j < P.length; j++) {
              O.key = j;
              const U = E(P[j], O), $ = gL(U);
              $ && F ? D[D.length - 1] += U : U !== null && D.push(U), F = $;
            }
            return O.key = A, O.renderDepth = M - 1, D;
          }
          const I = (function(A, D, F) {
            const j = () => (function(U, $, q, B, G, W, Y) {
              switch (U.type) {
                case "0": {
                  const z = { key: q.key };
                  return U.alert && (z.className = "markdown-alert-" + W(U.alert.toLowerCase(), op), U.children.unshift({ attrs: {}, children: [{ type: "27", text: U.alert }], noInnerParse: !0, type: "11", tag: "header" })), B("blockquote", z, $(U.children, q));
                }
                case "1":
                  return B("br", { key: q.key });
                case "2":
                  return B("hr", { key: q.key });
                case "3":
                  return B("pre", { key: q.key }, B("code", Oa({}, U.attrs, { className: U.lang ? "lang-" + U.lang : "" }), U.text));
                case "5":
                  return B("code", { key: q.key }, U.text);
                case "7":
                  return B("a", { key: q.key, href: G(U.target, "a", "href") }, B("sup", { key: q.key }, U.text));
                case "8":
                  return B("input", { checked: U.completed, key: q.key, readOnly: !0, type: "checkbox" });
                case "9":
                  return B("h" + U.level, { id: U.id, key: q.key }, $(U.children, q));
                case "11":
                  return B(U.tag, Oa({ key: q.key }, U.attrs), U.text || (U.children ? $(U.children, q) : ""));
                case "13":
                  return B(U.tag, Oa({}, U.attrs, { key: q.key }));
                case "14":
                  return B("img", { key: q.key, alt: U.alt || void 0, title: U.title || void 0, src: G(U.target, "img", "src") });
                case "15":
                  return B("a", { key: q.key, href: G(U.target, "a", "href"), title: U.title }, $(U.children, q));
                case "23":
                  return Y[U.ref] ? B("img", { key: q.key, alt: U.alt, src: G(Y[U.ref].target, "img", "src"), title: Y[U.ref].title }) : null;
                case "24":
                  return Y[U.ref] ? B("a", { key: q.key, href: G(Y[U.ref].target, "a", "href"), title: Y[U.ref].title }, $(U.children, q)) : B("span", { key: q.key }, U.fallbackChildren);
                case "25": {
                  const z = U;
                  return B("table", { key: q.key }, B("thead", null, B("tr", null, z.header.map(function(L, K) {
                    return B("th", { key: K, style: yL(z, K) }, $(L, q));
                  }))), B("tbody", null, z.cells.map(function(L, K) {
                    return B("tr", { key: K }, L.map(function(T, V) {
                      return B("td", { key: V, style: yL(z, V) }, $(T, q));
                    }));
                  })));
                }
                case "27":
                  return U.text;
                case "34":
                  return B(U.tag, { key: q.key }, $(U.children, q));
                case "20":
                case "30":
                  return B(U.ordered ? "ol" : "ul", { key: q.key, start: U.type === "20" ? U.start : void 0 }, U.items.map(function(z, L) {
                    return B("li", { key: L }, $(z, q));
                  }));
                case "19":
                  return `
`;
                case "21":
                  return B("p", { key: q.key }, $(U.children, q));
                default:
                  return null;
              }
            })(A, D, F, b, v, w, _);
            return y ? y(j, A, D, F) : j();
          })(P, E, O);
          return O.renderDepth = M - 1, I;
        } catch (I) {
          if (I instanceof RangeError && I.message.includes("Maximum call stack")) return k(P);
          throw I;
        }
      };
    })(t.renderRule, s, r, n, f);
    return u(e);
  }
  const hh = (e) => {
    let { children: t, options: n } = e, r = (function(o, a) {
      if (o == null) return {};
      var i = {};
      for (var s in o) if ({}.hasOwnProperty.call(o, s)) {
        if (a.indexOf(s) !== -1) continue;
        i[s] = o[s];
      }
      return i;
    })(e, zPe);
    return VOe(t ?? "", Oa({}, n, { wrapperProps: Oa({}, n?.wrapperProps, r) }));
  }, G1 = /* @__PURE__ */ Symbol("remove-this-key"), xL = /* @__PURE__ */ Symbol("reset");
  function UOe(e, t) {
    return Array.isArray(e.required) && e.required.indexOf(t) !== -1;
  }
  function HOe(e, t) {
    switch (t) {
      case "array":
        return [];
      case "boolean":
        return !1;
      case "null":
        return null;
      case "number":
        return 0;
      case "object":
        return {};
      default:
        return e(ht.NewStringDefault);
    }
  }
  function WOe(e) {
    const { fieldPathId: t, schema: n, registry: r, uiSchema: o, errorSchema: a, formData: i, onChange: s, onBlur: u, onFocus: c, disabled: f, readonly: p, required: g, hideError: h, propertyName: y, handleKeyRename: b, handleRemoveProperty: v, addedByAdditionalProperties: w } = e, [_, k] = C.useState(!1), { globalFormOptions: E, fields: P } = r, { SchemaField: O } = P, M = ju(Do(y, E, t.path)), I = C.useCallback((j, U, $, q) => {
      j === void 0 && w && (j = ""), s(j, U, $, q);
    }, [s, w]), A = C.useCallback((j) => {
      y !== j && k(!0), b(y, j);
    }, [y, b]), D = C.useCallback((j) => {
      const { target: { value: U } } = j;
      A(U);
    }, [A]), F = C.useCallback(() => {
      v(y);
    }, [y, v]);
    return S.jsx(O, { name: y, required: g, schema: n, uiSchema: o, errorSchema: a, fieldPathId: M, formData: i, wasPropertyKeyModified: _, onKeyRename: A, onKeyRenameBlur: D, onRemoveProperty: F, onChange: I, onBlur: u, onFocus: c, registry: r, disabled: f, readonly: p, hideError: h });
  }
  function qOe(e) {
    const { schema: t, uiSchema: n = {}, formData: r, errorSchema: o, fieldPathId: a, name: i, required: s = !1, disabled: u, readonly: c, hideError: f, onBlur: p, onFocus: g, onChange: h, registry: y, title: b } = e, { fields: v, schemaUtils: w, translateString: _, globalUiOptions: k } = y, { OptionalDataControlsField: E } = v, P = w.retrieveSchema(t, r, !0), O = Qe(n, k), { properties: M = {} } = P, I = e.childFieldPathId ?? a, A = O.title ?? P.title ?? b ?? i, D = O.description ?? P.description, F = mh(y, P, s, n), j = qd(r);
    let U = [];
    const $ = C.useCallback((L, K) => {
      const { duplicateKeySuffixSeparator: T = "-" } = Qe(n, k);
      let V = 0, X = L;
      for (; Et(K, X); )
        X = `${L}${T}${++V}`;
      return X;
    }, [n, k]), q = C.useCallback(() => {
      if (!(P.additionalProperties || P.patternProperties))
        return;
      const { translateString: L } = y, K = { ...r }, T = $("newKey", K);
      if (P.patternProperties)
        Qt(K, T, null);
      else {
        let V, X, Q;
        if (jt(P.additionalProperties)) {
          V = P.additionalProperties.type, X = P.additionalProperties.const, Q = P.additionalProperties.default;
          let te = P.additionalProperties;
          if (yn in te) {
            const { schemaUtils: ae } = y;
            te = ae.retrieveSchema({ [yn]: te[yn] }, r), V = te.type, X = te.const, Q = te.default;
          }
          !V && (Nt in te || pt in te) && (V = "object");
        }
        const ne = X ?? Q ?? HOe(L, V);
        Qt(K, T, ne);
      }
      h(K, I.path);
    }, [r, h, y, I, $, P]), B = C.useCallback((L, K) => {
      if (L !== K) {
        const T = $(K, r), V = {
          ...r
        }, X = { [L]: T }, Q = Object.keys(V).map((te) => ({ [X[te] || te]: V[te] })), ne = Object.assign({}, ...Q);
        h(ne, I.path);
      }
    }, [r, h, I, $]), G = C.useCallback((L) => {
      h(G1, [...I.path, L]);
    }, [h, I]);
    if (!F || j)
      try {
        const L = Object.keys(M);
        U = yEe(L, O.order);
      } catch (L) {
        return S.jsxs("div", { children: [S.jsx("p", { className: "rjsf-config-error", style: { color: "red" }, children: S.jsx(hh, { options: { disableParsingRawHTML: !0 }, children: _(ht.InvalidObjectField, [i || "root", L.message]) }) }), S.jsx("pre", { children: JSON.stringify(P) })] });
      }
    const W = et("ObjectFieldTemplate", y, O), Y = F ? S.jsx(E, { ...e, fieldPathId: I, schema: P }) : void 0, z = {
      // getDisplayLabel() always returns false for object types, so just check the `uiOptions.label`
      title: O.label === !1 ? "" : A,
      description: O.label === !1 ? void 0 : D,
      properties: U.map((L) => {
        const K = Et(P, [Lt, L, zi]), T = K ? n.additionalProperties : n[L], V = Qe(T).widget === "hidden";
        return {
          content: S.jsx(WOe, { propertyName: L, required: UOe(P, L), schema: Ce(P, [Lt, L], {}), uiSchema: T, errorSchema: Ce(o, [L]), fieldPathId: I, formData: Ce(r, [L]), handleKeyRename: B, handleRemoveProperty: G, addedByAdditionalProperties: K, onChange: h, onBlur: p, onFocus: g, registry: y, disabled: u, readonly: c, hideError: f }, L),
          name: L,
          readonly: c,
          disabled: u,
          required: s,
          hidden: V
        };
      }),
      readonly: c,
      disabled: u,
      required: s,
      fieldPathId: a,
      uiSchema: n,
      errorSchema: o,
      schema: P,
      formData: r,
      registry: y,
      optionalDataControl: Y,
      className: F ? "rjsf-optional-object-field" : void 0
    };
    return S.jsx(W, { ...z, onAddProperty: q });
  }
  function KOe(e) {
    const { schema: t, uiSchema: n = {}, formData: r, disabled: o = !1, readonly: a = !1, onChange: i, errorSchema: s, fieldPathId: u, registry: c } = e, { globalUiOptions: f = {}, schemaUtils: p, translateString: g } = c, h = Qe(n, f), y = et("OptionalDataControlsTemplate", c, h), b = qd(r);
    let v, w, _, k;
    if (o || a)
      v = v0(u, "Msg"), w = b ? void 0 : g(ht.OptionalObjectEmptyMsg);
    else {
      const E = b ? ht.OptionalObjectRemove : ht.OptionalObjectAdd;
      w = g(E), b ? (v = v0(u, "Remove"), k = () => i(void 0, u.path, s)) : (v = v0(u, "Add"), _ = () => {
        let P = p.getDefaultFormState(t, r, "excludeObjectChildren");
        P === void 0 && (P = aa(t) === "array" ? [] : {}), i(P, u.path, s);
      });
    }
    return w && S.jsx(y, { id: v, registry: c, schema: t, uiSchema: n, label: w, onAddClick: _, onRemoveClick: k });
  }
  const GOe = {
    array: "ArrayField",
    boolean: "BooleanField",
    integer: "NumberField",
    number: "NumberField",
    object: "ObjectField",
    string: "StringField",
    null: "NullField"
  };
  function XOe(e, t, n) {
    const r = t.field, { fields: o } = n;
    if (typeof r == "function")
      return r;
    if (typeof r == "string" && r in o)
      return o[r];
    const a = aa(e), i = Array.isArray(a) ? a[0] : a || "", s = e.$id;
    let u = GOe[i];
    return s && s in o && (u = s), !u && (e.anyOf || e.oneOf) ? () => null : u in o ? o[u] : o.FallbackField;
  }
  function YOe(e) {
    const { schema: t, fieldPathId: n, uiSchema: r, formData: o, errorSchema: a, name: i, onChange: s, onKeyRename: u, onKeyRenameBlur: c, onRemoveProperty: f, required: p = !1, registry: g, wasPropertyKeyModified: h = !1 } = e, { schemaUtils: y, globalFormOptions: b, globalUiOptions: v, fields: w } = g, { AnyOfField: _, OneOfField: k } = w, E = Qe(r, v), P = et("FieldTemplate", g, E), O = et("DescriptionFieldTemplate", g, E), M = et("FieldHelpTemplate", g, E), I = et("FieldErrorTemplate", g, E), A = y.retrieveSchema(t, o), D = n[rn], F = C.useCallback((ke, De, ze, Ue) => s(ke, De, ze, Ue || D), [D, s]), j = XOe(A, E, g), U = !!(E.disabled ?? e.disabled), $ = !!(E.readonly ?? (e.readonly || e.schema.readOnly || A.readOnly)), q = E.hideError, B = q === void 0 ? e.hideError : !!q, G = !!(E.autofocus ?? e.autofocus);
    if (Object.keys(A).length === 0)
      return null;
    let W = y.getDisplayLabel(A, r, v);
    const Y = E.field && E.fieldReplacesAnyOrOneOf === !0;
    let z, L, K = { fieldPathId: n };
    if ((Nt in A || pt in A) && !Y && !y.isSelect(A)) {
      A[Nt] ? (z = _, L = A[Nt].map((ze) => y.retrieveSchema(jt(ze) ? ze : {}, o))) : A[pt] && (z = k, L = A[pt].map((ze) => y.retrieveSchema(jt(ze) ? ze : {}, o)));
      const ke = mh(g, A, p, r), De = qd(o);
      W = W && (!ke || De), K = {
        childFieldPathId: n,
        // The main FieldComponent will add `XxxOf` onto the fieldPathId to avoid duplication with the rendering of the
        // same FieldComponent by the `XxxOfField`
        fieldPathId: Do("XxxOf", b, n)
      };
    }
    const { __errors: T, ...V } = a || {}, X = bm(r, ["ui:classNames", "classNames", "ui:style"]);
    Js in X && (X[Js] = bm(X[Js], ["classNames", "style"]));
    const Q = S.jsx(j, { ...e, onChange: F, ...K, schema: A, uiSchema: X, disabled: U, readonly: $, hideError: B, autofocus: G, errorSchema: V, rawErrors: T }), ne = n[rn];
    let te;
    h ? te = i : te = zi in A ? i : E.title || e.schema.title || A.title || e.title || i;
    const ae = E.description || e.schema.description || A.description || "", ce = E.help, Z = E.widget === "hidden", ee = ["rjsf-field", `rjsf-field-${aa(A)}`];
    !B && T && T.length > 0 && ee.push("rjsf-field-error"), E.classNames && ee.push(E.classNames);
    const oe = S.jsx(M, { help: ce, fieldPathId: n, schema: A, uiSchema: r, hasErrors: !B && T && T.length > 0, registry: g }), le = B || z && !y.isSelect(A) ? void 0 : S.jsx(I, { errors: T, errorSchema: a, fieldPathId: n, schema: A, uiSchema: r, registry: g }), be = {
      description: S.jsx(O, { id: Mu(ne), description: ae, schema: A, uiSchema: r, registry: g }),
      rawDescription: ae,
      help: oe,
      rawHelp: typeof ce == "string" ? ce : void 0,
      errors: le,
      rawErrors: B ? void 0 : T,
      id: ne,
      label: te,
      hidden: Z,
      onChange: s,
      onKeyRename: u,
      onKeyRenameBlur: c,
      onRemoveProperty: f,
      required: p,
      disabled: U,
      readonly: $,
      hideError: B,
      displayLabel: W,
      classNames: ee.join(" ").trim(),
      style: E.style,
      formData: o,
      schema: A,
      uiSchema: r,
      registry: g
    };
    return S.jsx(P, { ...be, children: S.jsxs(S.Fragment, { children: [Q, z && S.jsx(z, { name: i, disabled: U, readonly: $, hideError: B, errorSchema: a, formData: o, fieldPathId: n, onBlur: e.onBlur, onChange: e.onChange, onFocus: e.onFocus, options: L, registry: g, required: p, schema: A, uiSchema: r })] }) });
  }
  class JOe extends C.Component {
    shouldComponentUpdate(t) {
      const { registry: { globalFormOptions: n } } = this.props, { experimental_componentUpdateStrategy: r = "customDeep" } = n;
      return _1(this, t, this.state, r);
    }
    render() {
      return S.jsx(YOe, { ...this.props });
    }
  }
  function QOe(e) {
    const { schema: t, name: n, uiSchema: r, fieldPathId: o, formData: a, required: i, disabled: s = !1, readonly: u = !1, autofocus: c = !1, onChange: f, onBlur: p, onFocus: g, registry: h, rawErrors: y, hideError: b, title: v } = e, { title: w, format: _ } = t, { widgets: k, schemaUtils: E, globalUiOptions: P } = h, O = E.isSelect(t) ? Od(t, r) : void 0;
    let M = O ? "select" : "text";
    _ && hEe(t, _, k) && (M = _);
    const { widget: I = M, placeholder: A = "", title: D, ...F } = Qe(r), j = E.getDisplayLabel(t, r, P), U = D ?? v ?? w ?? n, $ = Xa(t, I, k), q = C.useCallback((B, G, W) => f(B, o.path, G, W), [f, o]);
    return S.jsx($, { options: { ...F, enumOptions: O }, schema: t, uiSchema: r, id: o.$id, name: n, label: U, hideLabel: !j, hideError: b, value: a, onChange: q, onBlur: p, onFocus: g, required: i, disabled: s, readonly: u, autofocus: c, registry: h, placeholder: A, rawErrors: y, htmlName: o.name });
  }
  function ZOe(e) {
    const { formData: t, onChange: n, fieldPathId: r } = e;
    return C.useEffect(() => {
      t === void 0 && n(null, r.path);
    }, [r, t, n]), null;
  }
  function eNe() {
    return {
      AnyOfField: rL,
      ArrayField: lPe,
      // ArrayField falls back to SchemaField if ArraySchemaField is not defined, which it isn't by default
      BooleanField: uPe,
      FallbackField: pPe,
      LayoutGridField: gO,
      LayoutHeaderField: IPe,
      LayoutMultiSchemaField: APe,
      NumberField: LPe,
      ObjectField: qOe,
      OneOfField: rL,
      OptionalDataControlsField: KOe,
      SchemaField: JOe,
      StringField: QOe,
      NullField: ZOe
    };
  }
  function tNe(e) {
    const { fieldPathId: t, description: n, registry: r, schema: o, uiSchema: a } = e, i = Qe(a, r.globalUiOptions), { label: s = !0 } = i;
    if (!n || !s)
      return null;
    const u = et("DescriptionFieldTemplate", r, i);
    return S.jsx(u, { id: Mu(t), description: n, schema: o, uiSchema: a, registry: r });
  }
  function nNe(e) {
    const { children: t, className: n, buttonsProps: r, displayLabel: o, hasDescription: a, hasToolbar: i, registry: s, uiSchema: u } = e, c = Qe(u), f = et("ArrayFieldItemButtonsTemplate", s, c), p = {
      flex: 1,
      paddingLeft: 6,
      paddingRight: 6,
      fontWeight: "bold"
    }, g = a ? 31 : 9, h = { display: "flex", alignItems: o ? "center" : "baseline" }, y = { display: "flex", justifyContent: "flex-end", marginTop: o ? `${g}px` : 0 };
    return S.jsxs("div", { className: n, style: h, children: [S.jsx("div", { className: i ? "col-xs-9 col-md-10 col-xl-11" : "col-xs-12", children: t }), i && S.jsx("div", { className: "col-xs-3 col-md-2 col-xl-1 array-item-toolbox", children: S.jsx("div", { className: "btn-group", style: y, children: S.jsx(f, { ...r, style: p }) }) })] });
  }
  function rNe(e) {
    const { disabled: t, hasCopy: n, hasMoveDown: r, hasMoveUp: o, hasRemove: a, fieldPathId: i, onCopyItem: s, onRemoveItem: u, onMoveDownItem: c, onMoveUpItem: f, readonly: p, registry: g, uiSchema: h } = e, { CopyButton: y, MoveDownButton: b, MoveUpButton: v, RemoveButton: w } = g.templates.ButtonTemplates;
    return S.jsxs(S.Fragment, { children: [(o || r) && S.jsx(v, { id: Da(i, "moveUp"), className: "rjsf-array-item-move-up", disabled: t || p || !o, onClick: f, uiSchema: h, registry: g }), (o || r) && S.jsx(b, { id: Da(i, "moveDown"), className: "rjsf-array-item-move-down", disabled: t || p || !r, onClick: c, uiSchema: h, registry: g }), n && S.jsx(y, { id: Da(i, "copy"), className: "rjsf-array-item-copy", disabled: t || p, onClick: s, uiSchema: h, registry: g }), a && S.jsx(w, { id: Da(i, "remove"), className: "rjsf-array-item-remove", disabled: t || p, onClick: u, uiSchema: h, registry: g })] });
  }
  function oNe(e) {
    const { canAdd: t, className: n, disabled: r, fieldPathId: o, uiSchema: a, items: i, optionalDataControl: s, onAddClick: u, readonly: c, registry: f, required: p, schema: g, title: h } = e, y = Qe(a), b = et("ArrayFieldDescriptionTemplate", f, y), v = et("ArrayFieldTitleTemplate", f, y), w = !c && !r, { ButtonTemplates: { AddButton: _ } } = f.templates;
    return S.jsxs("fieldset", { className: n, id: o.$id, children: [S.jsx(v, { fieldPathId: o, title: y.title || h, required: p, schema: g, uiSchema: a, registry: f, optionalDataControl: w ? s : void 0 }), S.jsx(b, { fieldPathId: o, description: y.description || g.description, schema: g, uiSchema: a, registry: f }), w ? void 0 : s, S.jsx("div", { className: "row array-item-list", children: i }), t && S.jsx(_, { id: Da(o, "add"), className: "rjsf-array-item-add", onClick: u, disabled: r || c, uiSchema: a, registry: f })] });
  }
  function aNe(e) {
    const { fieldPathId: t, title: n, schema: r, uiSchema: o, required: a, registry: i, optionalDataControl: s } = e, u = Qe(o, i.globalUiOptions), { label: c = !0 } = u;
    if (!n || !c)
      return null;
    const f = et("TitleFieldTemplate", i, u);
    return S.jsx(f, { id: yx(t), title: n, required: a, schema: r, uiSchema: o, registry: i, optionalDataControl: s });
  }
  function iNe(e) {
    const {
      id: t,
      name: n,
      // remove this from ...rest
      htmlName: r,
      value: o,
      readonly: a,
      disabled: i,
      autofocus: s,
      onBlur: u,
      onFocus: c,
      onChange: f,
      onChangeOverride: p,
      options: g,
      schema: h,
      uiSchema: y,
      registry: b,
      rawErrors: v,
      type: w,
      hideLabel: _,
      // remove this from ...rest
      hideError: k,
      // remove this from ...rest
      ...E
    } = e;
    if (!t)
      throw console.log("No id for", e), new Error(`no id for props ${JSON.stringify(e)}`);
    const P = {
      ...E,
      ...x1(h, w, g)
    };
    let O;
    P.type === "number" || P.type === "integer" ? O = o || o === 0 ? o : "" : O = o ?? "";
    const M = C.useCallback(({ target: { value: D } }) => f(D === "" ? g.emptyValue : D), [f, g]), I = C.useCallback(({ target: D }) => u(t, D && D.value), [u, t]), A = C.useCallback(({ target: D }) => c(t, D && D.value), [c, t]);
    return S.jsxs(S.Fragment, { children: [S.jsx("input", { id: t, name: r || t, className: "form-control", readOnly: a, disabled: i, autoFocus: s, value: O, ...P, list: h.examples ? _m(t) : void 0, onChange: p || M, onBlur: I, onFocus: A, "aria-describedby": vo(t, !!h.examples) }), Array.isArray(h.examples) && S.jsx("datalist", { id: _m(t), children: h.examples.concat(h.default && !h.examples.includes(h.default) ? [h.default] : []).map((D) => S.jsx("option", { value: D }, D)) }, `datalist_${t}`)] });
  }
  function sNe({ uiSchema: e }) {
    const { submitText: t, norender: n, props: r = {} } = k1(e);
    return n ? null : S.jsx("div", { children: S.jsx("button", { type: "submit", ...r, className: `btn btn-info ${r.className || ""}`, children: t }) });
  }
  function bu(e) {
    const { iconType: t = "default", icon: n, className: r, uiSchema: o, registry: a, ...i } = e;
    return S.jsx("button", { type: "button", className: `btn btn-${t} ${r}`, ...i, children: S.jsx("i", { className: `glyphicon glyphicon-${n}` }) });
  }
  function lNe(e) {
    const { registry: { translateString: t } } = e;
    return S.jsx(bu, { title: t(ht.CopyButton), ...e, icon: "copy" });
  }
  function uNe(e) {
    const { registry: { translateString: t } } = e;
    return S.jsx(bu, { title: t(ht.MoveDownButton), ...e, icon: "arrow-down" });
  }
  function cNe(e) {
    const { registry: { translateString: t } } = e;
    return S.jsx(bu, { title: t(ht.MoveUpButton), ...e, icon: "arrow-up" });
  }
  function dNe(e) {
    const { registry: { translateString: t } } = e;
    return S.jsx(bu, { title: t(ht.RemoveButton), ...e, iconType: "danger", icon: "remove" });
  }
  function fNe({ id: e, className: t, onClick: n, disabled: r, registry: o }) {
    const { translateString: a } = o;
    return S.jsx("div", { className: "row", children: S.jsx("p", { className: `col-xs-4 col-sm-2 col-lg-1 col-xs-offset-8 col-sm-offset-10 col-lg-offset-11 text-right ${t}`, children: S.jsx(bu, { id: e, iconType: "info", icon: "plus", className: "btn-add col-xs-12", title: a(ht.AddButton), onClick: n, disabled: r, registry: o }) }) });
  }
  function pNe() {
    return {
      SubmitButton: sNe,
      AddButton: fNe,
      CopyButton: lNe,
      MoveDownButton: uNe,
      MoveUpButton: cNe,
      RemoveButton: dNe
    };
  }
  const X1 = sO();
  function wO({ description: e, registry: t, uiSchema: n = {} }) {
    const { globalUiOptions: r } = t;
    return Qe(n, r).enableMarkdownInDescription && typeof e == "string" ? S.jsx(hh, { options: { disableParsingRawHTML: !0 }, "data-testid": X1.markdown, children: e }) : e;
  }
  wO.TEST_IDS = X1;
  function mNe(e) {
    const { id: t, description: n, registry: r, uiSchema: o } = e;
    return n ? S.jsx("div", { id: t, className: "field-description", children: S.jsx(wO, { description: n, registry: r, uiSchema: o }) }) : null;
  }
  function hNe({ errors: e, registry: t }) {
    const { translateString: n } = t;
    return S.jsxs("div", { className: "panel panel-danger errors", children: [S.jsx("div", { className: "panel-heading", children: S.jsx("h3", { className: "panel-title", children: n(ht.ErrorsLabel) }) }), S.jsx("ul", { className: "list-group", children: e.map((r, o) => S.jsx("li", { className: "list-group-item text-danger", children: r.stack }, o)) })] });
  }
  function gNe(e) {
    const { schema: t, registry: n, typeSelector: r, schemaField: o } = e, a = et("MultiSchemaFieldTemplate", n);
    return S.jsx(a, { selector: r, optionSchemaField: o, schema: t, registry: n });
  }
  const vNe = "*";
  function Y1(e) {
    const { label: t, required: n, id: r } = e;
    return t ? S.jsxs("label", { className: "control-label", htmlFor: r, children: [t, n && S.jsx("span", { className: "required", children: vNe })] }) : null;
  }
  function yNe(e) {
    const { id: t, label: n, children: r, errors: o, help: a, description: i, hidden: s, required: u, displayLabel: c, registry: f, uiSchema: p } = e, g = Qe(p), h = et("WrapIfAdditionalTemplate", f, g);
    if (s)
      return S.jsx("div", { className: "hidden", children: r });
    const y = g.widget === "checkbox";
    return S.jsxs(h, { ...e, children: [c && !y && S.jsx(Y1, { label: n, required: u, id: t }), c && i ? i : null, r, o, a] });
  }
  function bNe(e) {
    const { errors: t = [], fieldPathId: n } = e;
    if (t.length === 0)
      return null;
    const r = lO(n);
    return S.jsx("div", { children: S.jsx("ul", { id: r, className: "error-detail bs-callout bs-callout-info", children: t.filter((o) => !!o).map((o, a) => S.jsx("li", { className: "text-danger", children: o }, a)) }) });
  }
  const J1 = sO();
  function xO({ help: e, registry: t, uiSchema: n = {} }) {
    const { globalUiOptions: r } = t;
    return Qe(n, r).enableMarkdownInHelp && typeof e == "string" ? S.jsx(hh, { options: { disableParsingRawHTML: !0 }, "data-testid": J1.markdown, children: e }) : e;
  }
  xO.TEST_IDS = J1;
  function wNe(e) {
    const { fieldPathId: t, help: n, uiSchema: r, registry: o } = e;
    return n ? S.jsx("div", { id: uO(t), className: "help-block", children: S.jsx(xO, { help: n, registry: o, uiSchema: r }) }) : null;
  }
  function xNe(e) {
    const { children: t, column: n, className: r, ...o } = e;
    return S.jsx("div", { className: r, ...o, children: t });
  }
  function kNe(e) {
    const { selector: t, optionSchemaField: n } = e;
    return S.jsxs("div", { className: "panel panel-default panel-body", children: [S.jsx("div", { className: "form-group", children: t }), n] });
  }
  function SNe(e) {
    const { className: t, description: n, disabled: r, formData: o, fieldPathId: a, onAddProperty: i, optionalDataControl: s, properties: u, readonly: c, registry: f, required: p, schema: g, title: h, uiSchema: y } = e, b = Qe(y), v = et("TitleFieldTemplate", f, b), w = et("DescriptionFieldTemplate", f, b), _ = !c && !r, { ButtonTemplates: { AddButton: k } } = f.templates;
    return S.jsxs("fieldset", { className: t, id: a.$id, children: [h && S.jsx(v, { id: yx(a), title: h, required: p, schema: g, uiSchema: y, registry: f, optionalDataControl: _ ? s : void 0 }), n && S.jsx(w, { id: Mu(a), description: n, schema: g, uiSchema: y, registry: f }), _ ? void 0 : s, u.map((E) => E.content), aV(g, y, o) && S.jsx(k, { id: Da(a, "add"), className: "rjsf-object-property-expand", onClick: i, disabled: r || c, uiSchema: y, registry: f })] });
  }
  function _Ne(e) {
    const { id: t, registry: n, label: r, onAddClick: o, onRemoveClick: a } = e;
    return o ? S.jsx(bu, { id: t, registry: n, icon: "plus", className: "rjsf-add-optional-data btn-sm", onClick: o, title: r }) : a ? S.jsx(bu, { id: t, registry: n, icon: "remove", className: "rjsf-remove-optional-data btn-sm", onClick: a, title: r }) : S.jsx("em", { id: t, children: r });
  }
  const ENe = "*";
  function CNe(e) {
    const { id: t, title: n, required: r, optionalDataControl: o } = e;
    return S.jsxs("legend", { id: t, children: [n, r && S.jsx("span", { className: "required", children: ENe }), o && S.jsx("span", { className: "pull-right", style: { marginBottom: "2px" }, children: o })] });
  }
  function PNe(e) {
    const { schema: t, fieldPathId: n, reason: r, registry: o } = e, { translateString: a } = o;
    let i = ht.UnsupportedField;
    const s = [];
    return n && n.$id && (i = ht.UnsupportedFieldWithId, s.push(n.$id)), r && (i = i === ht.UnsupportedField ? ht.UnsupportedFieldWithReason : ht.UnsupportedFieldWithIdAndReason, s.push(r)), S.jsxs("div", { className: "unsupported-field", children: [S.jsx("p", { children: S.jsx(hh, { options: { disableParsingRawHTML: !0 }, children: a(i, s) }) }), t && S.jsx("pre", { children: JSON.stringify(t, null, 2) })] });
  }
  function ONe(e) {
    const { id: t, classNames: n, style: r, disabled: o, displayLabel: a, label: i, onKeyRenameBlur: s, onRemoveProperty: u, rawDescription: c, readonly: f, required: p, schema: g, hideError: h, rawErrors: y, children: b, uiSchema: v, registry: w } = e, { templates: _, translateString: k } = w, { RemoveButton: E } = _.ButtonTemplates, P = k(ht.KeyLabel, [i]), O = zi in g, M = !!c, I = ["form-group", n];
    !h && y && y.length > 0 && I.push("has-error has-danger");
    const A = I.join(" ").trim();
    if (!O)
      return S.jsx("div", { className: A, style: r, children: b });
    const D = M ? 46 : 26;
    return S.jsx("div", { className: A, style: r, children: S.jsxs("div", { className: "row", children: [S.jsx("div", { className: "col-xs-5 form-additional", children: S.jsxs("div", { className: "form-group", children: [a && S.jsx(Y1, { label: P, required: p, id: `${t}-key` }), a && c && S.jsx("div", { children: "" }), S.jsx("input", { className: "form-control", type: "text", id: `${t}-key`, onBlur: s, defaultValue: i })] }) }), S.jsx("div", { className: "form-additional form-group col-xs-5", children: b }), S.jsx("div", { className: "col-xs-2", style: { marginTop: a ? `${D}px` : void 0 }, children: S.jsx(E, { id: Da(t, "remove"), className: "rjsf-object-property-remove btn-block", style: { border: "0" }, disabled: o || f, onClick: u, uiSchema: v, registry: w }) })] }) });
  }
  function NNe() {
    return {
      ArrayFieldDescriptionTemplate: tNe,
      ArrayFieldItemTemplate: nNe,
      ArrayFieldItemButtonsTemplate: rNe,
      ArrayFieldTemplate: oNe,
      ArrayFieldTitleTemplate: aNe,
      ButtonTemplates: pNe(),
      BaseInputTemplate: iNe,
      DescriptionFieldTemplate: mNe,
      ErrorListTemplate: hNe,
      FallbackFieldTemplate: gNe,
      FieldTemplate: yNe,
      FieldErrorTemplate: bNe,
      FieldHelpTemplate: wNe,
      GridTemplate: xNe,
      MultiSchemaFieldTemplate: kNe,
      ObjectFieldTemplate: SNe,
      OptionalDataControlsTemplate: _Ne,
      TitleFieldTemplate: CNe,
      UnsupportedFieldTemplate: PNe,
      WrapIfAdditionalTemplate: ONe
    };
  }
  function MNe(e) {
    const { disabled: t = !1, readonly: n = !1, autofocus: r = !1, options: o, id: a, name: i, registry: s, onBlur: u, onFocus: c } = e, { translateString: f } = s, { elements: p, handleChange: g, handleClear: h, handleSetNow: y } = kEe(e);
    return S.jsxs("ul", { className: "list-inline", children: [p.map((b, v) => S.jsx("li", { className: "list-inline-item", children: S.jsx(xEe, { rootId: a, name: i, select: g, ...b, disabled: t, readonly: n, registry: s, onBlur: u, onFocus: c, autofocus: r && v === 0 }) }, v)), (o.hideNowButton !== "undefined" ? !o.hideNowButton : !0) && S.jsx("li", { className: "list-inline-item", children: S.jsx("a", { href: "#", className: "btn btn-info btn-now", onClick: y, children: f(ht.NowLabel) }) }), (o.hideClearButton !== "undefined" ? !o.hideClearButton : !0) && S.jsx("li", { className: "list-inline-item", children: S.jsx("a", { href: "#", className: "btn btn-warning btn-clear", onClick: h, children: f(ht.ClearLabel) }) })] });
  }
  function RNe({ time: e = !0, ...t }) {
    const { AltDateWidget: n } = t.registry.widgets;
    return S.jsx(n, { time: e, ...t });
  }
  function jNe({ schema: e, uiSchema: t, options: n, id: r, value: o, disabled: a, readonly: i, label: s, hideLabel: u, autofocus: c = !1, onBlur: f, onFocus: p, onChange: g, registry: h, htmlName: y }) {
    const b = et("DescriptionFieldTemplate", h, n), v = Lp(e), w = C.useCallback((P) => g(P.target.checked), [g]), _ = C.useCallback((P) => f(r, P.target.checked), [f, r]), k = C.useCallback((P) => p(r, P.target.checked), [p, r]), E = Qe(t).widget === "checkbox" ? void 0 : n.description ?? e.description;
    return S.jsxs("div", { className: `checkbox ${a || i ? "disabled" : ""}`, children: [!u && E && S.jsx(b, { id: Mu(r), description: E, schema: e, uiSchema: t, registry: h }), S.jsxs("label", { children: [S.jsx("input", { type: "checkbox", id: r, name: y || r, checked: typeof o > "u" ? !1 : o, required: v, disabled: a || i, autoFocus: c, onChange: w, onBlur: _, onFocus: k, "aria-describedby": vo(r) }), Ru(S.jsx("span", { children: s }), u)] })] });
  }
  function INe({ id: e, disabled: t, options: { inline: n = !1, enumOptions: r, enumDisabled: o, emptyValue: a }, value: i, autofocus: s = !1, readonly: u, onChange: c, onBlur: f, onFocus: p, htmlName: g }) {
    const h = Array.isArray(i) ? i : [i], y = C.useCallback(({ target: v }) => f(e, Qn(v && v.value, r, a)), [f, e, r, a]), b = C.useCallback(({ target: v }) => p(e, Qn(v && v.value, r, a)), [p, e, r, a]);
    return S.jsx("div", { className: "checkboxes", id: e, children: Array.isArray(r) && r.map((v, w) => {
      const _ = vx(v.value, h), k = Array.isArray(o) && o.indexOf(v.value) !== -1, E = t || k || u ? "disabled" : "", P = (M) => {
        M.target.checked ? c(v1(w, h, r)) : c(g1(w, h, r));
      }, O = S.jsxs("span", { children: [S.jsx("input", { type: "checkbox", id: bx(e, w), name: g || e, checked: _, value: String(w), disabled: t || k || u, autoFocus: s && w === 0, onChange: P, onBlur: y, onFocus: b, "aria-describedby": vo(e) }), S.jsx("span", { children: v.label })] });
      return n ? S.jsx("label", { className: `checkbox-inline ${E}`, children: O }, w) : S.jsx("div", { className: `checkbox ${E}`, children: S.jsx("label", { children: O }) }, w);
    }) });
  }
  function ANe(e) {
    const { disabled: t, readonly: n, options: r, registry: o } = e, a = et("BaseInputTemplate", o, r);
    return S.jsx(a, { type: "color", ...e, disabled: t || n });
  }
  function $Ne(e) {
    const { onChange: t, options: n, registry: r } = e, o = et("BaseInputTemplate", r, n), a = C.useCallback((i) => t(i || void 0), [t]);
    return S.jsx(o, { type: "date", ...e, onChange: a });
  }
  function DNe(e) {
    const { onChange: t, value: n, options: r, registry: o } = e, a = et("BaseInputTemplate", o, r);
    return S.jsx(a, { type: "datetime-local", ...e, value: PEe(n), onChange: (i) => t(vEe(i)) });
  }
  function LNe(e) {
    const { options: t, registry: n } = e, r = et("BaseInputTemplate", n, t);
    return S.jsx(r, { type: "email", ...e });
  }
  function FNe({ fileInfo: e, registry: t }) {
    const { translateString: n } = t, { dataURL: r, type: o, name: a } = e;
    return r ? ["image/jpeg", "image/png"].includes(o) ? S.jsx("img", { src: r, style: { maxWidth: "100%" }, className: "file-preview" }) : S.jsxs(S.Fragment, { children: [" ", S.jsx("a", { download: `preview-${a}`, href: r, className: "file-download", children: n(ht.PreviewLabel) })] }) : null;
  }
  function TNe({ filesInfo: e, registry: t, preview: n, onRemove: r, options: o }) {
    if (e.length === 0)
      return null;
    const { translateString: a } = t, { RemoveButton: i } = et("ButtonTemplates", t, o);
    return S.jsx("ul", { className: "file-info", children: e.map((s, u) => {
      const { name: c, size: f, type: p } = s, g = () => r(u);
      return S.jsxs("li", { children: [S.jsx(hh, { children: a(ht.FilesInfo, [c, p, String(f)]) }), n && S.jsx(FNe, { fileInfo: s, registry: t }), S.jsx(i, { onClick: g, registry: t })] }, u);
    }) });
  }
  function zNe(e) {
    const { disabled: t, readonly: n, required: r, multiple: o, onChange: a, value: i, options: s, registry: u } = e, { filesInfo: c, handleChange: f, handleRemove: p } = CEe(i, a, o), g = et("BaseInputTemplate", u, s), h = (y) => {
      y.target.files && f(y.target.files);
    };
    return S.jsxs("div", { children: [S.jsx(g, { ...e, disabled: t || n, type: "file", required: i ? !1 : r, onChangeOverride: h, value: "", accept: s.accept ? String(s.accept) : void 0 }), S.jsx(TNe, { filesInfo: c, onRemove: p, registry: u, preview: s.filePreview, options: s })] });
  }
  function BNe({ id: e, value: t, htmlName: n }) {
    return S.jsx("input", { type: "hidden", id: e, name: n || e, value: typeof t > "u" ? "" : t });
  }
  function VNe(e) {
    const { options: t, registry: n } = e, r = et("BaseInputTemplate", n, t);
    return S.jsx(r, { type: "password", ...e });
  }
  function UNe({ options: e, value: t, required: n, disabled: r, readonly: o, autofocus: a = !1, onBlur: i, onFocus: s, onChange: u, id: c, htmlName: f }) {
    const { enumOptions: p, enumDisabled: g, inline: h, emptyValue: y } = e, b = C.useCallback(({ target: w }) => i(c, Qn(w && w.value, p, y)), [i, p, y, c]), v = C.useCallback(({ target: w }) => s(c, Qn(w && w.value, p, y)), [s, p, y, c]);
    return S.jsx("div", { className: "field-radio-group", id: c, role: "radiogroup", children: Array.isArray(p) && p.map((w, _) => {
      const k = vx(w.value, t), E = Array.isArray(g) && g.indexOf(w.value) !== -1, P = r || E || o ? "disabled" : "", O = () => u(w.value), M = S.jsxs("span", { children: [S.jsx("input", { type: "radio", id: bx(c, _), checked: k, name: f || c, required: n, value: String(_), disabled: r || E || o, autoFocus: a && _ === 0, onChange: O, onBlur: b, onFocus: v, "aria-describedby": vo(c) }), S.jsx("span", { children: w.label })] });
      return h ? S.jsx("label", { className: `radio-inline ${P}`, children: M }, _) : S.jsx("div", { className: `radio ${P}`, children: S.jsx("label", { children: M }) }, _);
    }) });
  }
  function HNe(e) {
    const { value: t, registry: { templates: { BaseInputTemplate: n } } } = e;
    return S.jsxs("div", { className: "field-range-wrapper", children: [S.jsx(n, { type: "range", ...e }), S.jsx("span", { className: "range-view", children: t })] });
  }
  function WNe({ id: e, value: t, required: n, disabled: r, readonly: o, autofocus: a, onChange: i, onFocus: s, onBlur: u, schema: c, options: f, htmlName: p }) {
    const { stars: g = 5, shape: h = "star" } = f, y = c.maximum ? Math.min(c.maximum, 5) : Math.min(Math.max(g, 1), 5), b = c.minimum || 0, v = C.useCallback((E) => {
      !r && !o && i(E);
    }, [i, r, o]), w = C.useCallback((E) => {
      if (s) {
        const P = Number(E.target.dataset.value);
        s(e, P);
      }
    }, [s, e]), _ = C.useCallback((E) => {
      if (u) {
        const P = Number(E.target.dataset.value);
        u(e, P);
      }
    }, [u, e]), k = (E) => h === "heart" ? E ? "" : "" : E ? "" : "";
    return S.jsx(S.Fragment, { children: S.jsxs("div", { className: "rating-widget", style: {
      display: "inline-flex",
      fontSize: "1.5rem",
      cursor: r || o ? "default" : "pointer"
    }, children: [[...Array(y)].map((E, P) => {
      const O = b + P, M = O <= t;
      return S.jsx("span", { onClick: () => v(O), onFocus: w, onBlur: _, "data-value": O, tabIndex: r || o ? -1 : 0, role: "radio", "aria-checked": O === t, "aria-label": `${O} ${h === "heart" ? "heart" : "star"}${O === 1 ? "" : "s"}`, style: {
        color: M ? "#FFD700" : "#ccc",
        padding: "0 0.2rem",
        transition: "color 0.2s",
        userSelect: "none"
      }, children: k(M) }, P);
    }), S.jsx("input", { type: "hidden", id: e, name: p || e, value: t || "", required: n, disabled: r || o, "aria-hidden": "true" })] }) });
  }
  function N0(e, t) {
    return t ? Array.from(e.target.options).slice().filter((n) => n.selected).map((n) => n.value) : e.target.value;
  }
  function qNe({ schema: e, id: t, options: n, value: r, required: o, disabled: a, readonly: i, multiple: s = !1, autofocus: u = !1, onChange: c, onBlur: f, onFocus: p, placeholder: g, htmlName: h }) {
    const { enumOptions: y, enumDisabled: b, emptyValue: v } = n, w = s ? [] : "", _ = C.useCallback((M) => {
      const I = N0(M, s);
      return p(t, Qn(I, y, v));
    }, [p, t, s, y, v]), k = C.useCallback((M) => {
      const I = N0(M, s);
      return f(t, Qn(I, y, v));
    }, [f, t, s, y, v]), E = C.useCallback((M) => {
      const I = N0(M, s);
      return c(Qn(I, y, v));
    }, [c, s, y, v]), P = aO(r, y, s), O = !s && e.default === void 0;
    return S.jsxs("select", { id: t, name: h || t, multiple: s, role: "combobox", className: "form-control", value: typeof P > "u" ? w : P, required: o, disabled: a || i, autoFocus: u, onBlur: k, onFocus: _, onChange: E, "aria-describedby": vo(t), children: [O && S.jsx("option", { value: "", children: g }), Array.isArray(y) && y.map(({ value: M, label: I }, A) => {
      const D = b && b.indexOf(M) !== -1;
      return S.jsx("option", { value: String(A), disabled: D, children: I }, A);
    })] });
  }
  function Q1({ id: e, options: t = {}, placeholder: n, value: r, required: o, disabled: a, readonly: i, autofocus: s = !1, onChange: u, onBlur: c, onFocus: f, htmlName: p }) {
    const g = C.useCallback(({ target: { value: b } }) => u(b === "" ? t.emptyValue : b), [u, t.emptyValue]), h = C.useCallback(({ target: b }) => c(e, b && b.value), [c, e]), y = C.useCallback(({ target: b }) => f(e, b && b.value), [e, f]);
    return S.jsx("textarea", { id: e, name: p || e, className: "form-control", value: r || "", placeholder: n, required: o, disabled: a, readOnly: i, autoFocus: s, rows: t.rows, onBlur: h, onFocus: y, onChange: g, "aria-describedby": vo(e) });
  }
  Q1.defaultProps = {
    autofocus: !1,
    options: {}
  };
  function KNe(e) {
    const { options: t, registry: n } = e, r = et("BaseInputTemplate", n, t);
    return S.jsx(r, { ...e });
  }
  function GNe(e) {
    const { onChange: t, options: n, registry: r } = e, o = et("BaseInputTemplate", r, n), a = C.useCallback((i) => t(i ? `${i}:00` : void 0), [t]);
    return S.jsx(o, { type: "time", ...e, onChange: a });
  }
  function XNe(e) {
    const { options: t, registry: n } = e, r = et("BaseInputTemplate", n, t);
    return S.jsx(r, { type: "url", ...e });
  }
  function YNe(e) {
    const { options: t, registry: n } = e, r = et("BaseInputTemplate", n, t);
    return S.jsx(r, { type: "number", ...e });
  }
  function JNe() {
    return {
      AltDateWidget: MNe,
      AltDateTimeWidget: RNe,
      CheckboxWidget: jNe,
      CheckboxesWidget: INe,
      ColorWidget: ANe,
      DateWidget: $Ne,
      DateTimeWidget: DNe,
      EmailWidget: LNe,
      FileWidget: zNe,
      HiddenWidget: BNe,
      PasswordWidget: VNe,
      RadioWidget: UNe,
      RangeWidget: HNe,
      RatingWidget: WNe,
      SelectWidget: qNe,
      TextWidget: KNe,
      TextareaWidget: Q1,
      TimeWidget: GNe,
      UpDownWidget: YNe,
      URLWidget: XNe
    };
  }
  function QNe() {
    return {
      fields: eNe(),
      templates: NNe(),
      widgets: JNe(),
      rootSchema: {},
      formContext: {},
      translateString: Q2e,
      globalFormOptions: {
        idPrefix: nV,
        idSeparator: rV,
        useFallbackUiForUnsupportedType: !1
      }
    };
  }
  function $c(e, t) {
    return {
      ...A1(e, ["schema", "uiSchema", "fieldPathId", "schemaUtils", "formData", "edit", "errors", "errorSchema"]),
      ...t !== void 0 && { status: t }
    };
  }
  let ZNe = class extends C.Component {
    /** Constructs the `Form` from the `props`. Will setup the initial state from the props. It will also call the
     * `onChange` handler if the initially provided `formData` is modified to add missing default values as part of the
     * state construction.
     *
     * @param props - The initial props for the `Form`
     */
    constructor(t) {
      super(t);
      /** The ref used to hold the `form` element, this needs to be `any` because `tagName` or `_internalFormWrapper` can
       * provide any possible type here
       */
      Gn(this, "formElement");
      /** The list of pending changes
       */
      Gn(this, "pendingChanges", []);
      /** Returns the `formData` with only the elements specified in the `fields` list
       *
       * @param formData - The data for the `Form`
       * @param fields - The fields to keep while filtering
       */
      Gn(this, "getUsedFormData", (t, n) => {
        if (n.length === 0 && typeof t != "object")
          return t;
        const r = A1(t, n);
        return Array.isArray(t) ? Object.keys(r).map((o) => r[o]) : r;
      });
      /** Returns the list of field names from inspecting the `pathSchema` as well as using the `formData`
       *
       * @param pathSchema - The `PathSchema` object for the form
       * @param [formData] - The form data to use while checking for empty objects/arrays
       */
      Gn(this, "getFieldNames", (t, n) => {
        const r = (a, i) => typeof a != "object" || Hn(a) || i && !Hn(a), o = (a, i = [], s = [[]]) => {
          const u = Object.keys(a);
          return u.forEach((c) => {
            const f = a[c];
            if (typeof f == "object") {
              const p = s.map((g) => [...g, c]);
              f[AP] && f[Vy] !== "" ? i.push(f[Vy]) : o(f, i, p);
            } else c === Vy && f !== "" && s.forEach((p) => {
              const g = Ce(n, p), h = u.length === 1;
              (r(g, h) || Array.isArray(g) && g.every((y) => r(y, h))) && i.push(p);
            });
          }), i;
        };
        return o(t);
      });
      /** Returns the `formData` after filtering to remove any extra data not in a form field
       *
       * @param formData - The data for the `Form`
       * @returns The `formData` after omitting extra data
       */
      Gn(this, "omitExtraData", (t) => {
        const { schema: n, schemaUtils: r } = this.state, o = r.retrieveSchema(n, t), a = r.toPathSchema(o, "", t), i = this.getFieldNames(a, t);
        return this.getUsedFormData(t, i);
      });
      /** Allows a user to set a value for the provided `fieldPath`, which must be either a dotted path to the field OR a
       * `FieldPathList`. To set the root element, used either `''` or `[]` for the path. Passing undefined will clear the
       * value in the field.
       *
       * @param fieldPath - Either a dotted path to the field or the `FieldPathList` to the field
       * @param [newValue] - The new value for the field
       */
      Gn(this, "setFieldValue", (t, n) => {
        const { registry: r } = this.state, o = Array.isArray(t) ? t : t.split("."), a = Do("", r.globalFormOptions, o);
        this.onChange(n, o, void 0, a[rn]);
      });
      /** Pushes the given change information into the `pendingChanges` array and then calls `processPendingChanges()` if
       * the array only contains a single pending change.
       *
       * @param newValue - The new form data from a change to a field
       * @param path - The path to the change into which to set the formData
       * @param [newErrorSchema] - The new `ErrorSchema` based on the field change
       * @param [id] - The id of the field that caused the change
       */
      Gn(this, "onChange", (t, n, r, o) => {
        this.pendingChanges.push({ newValue: t, path: n, newErrorSchema: r, id: o }), this.pendingChanges.length === 1 && this.processPendingChange();
      });
      /**
       * Callback function to handle reset form data.
       * - Reset all fields with default values.
       * - Reset validations and errors
       *
       */
      Gn(this, "reset", () => {
        const { formData: t, initialFormData: n = xL, onChange: r } = this.props, o = {
          formData: this.getStateFromProps(this.props, t ?? n, void 0, void 0, void 0, !0).formData,
          errorSchema: {},
          errors: [],
          schemaValidationErrors: [],
          schemaValidationErrorSchema: {},
          initialDefaultsGenerated: !1,
          customErrors: void 0
        };
        this.setState(o, () => r && r($c({ ...this.state, ...o })));
      });
      /** Callback function to handle when a field on the form is blurred. Calls the `onBlur` callback for the `Form` if it
       * was provided. Also runs any live validation and/or live omit operations if the flags indicate they should happen
       * during `onBlur`.
       *
       * @param id - The unique `id` of the field that was blurred
       * @param data - The data associated with the field that was blurred
       */
      Gn(this, "onBlur", (t, n) => {
        const { onBlur: r, omitExtraData: o, liveOmit: a, liveValidate: i } = this.props;
        if (r && r(t, n), o === !0 && a === "onBlur" || i === "onBlur") {
          const { onChange: s, extraErrors: u } = this.props, { formData: c } = this.state;
          let f = c, p = { formData: f };
          if (o === !0 && a === "onBlur" && (f = this.omitExtraData(c), p = { formData: f }), i === "onBlur") {
            const { schema: h, schemaUtils: y, errorSchema: b, customErrors: v, retrievedSchema: w } = this.state, _ = this.liveValidate(h, y, b, f, u, v, w);
            p = { formData: f, ..._, customErrors: v };
          }
          const g = Object.keys(p).filter((h) => !h.startsWith("schemaValidation")).some((h) => {
            const y = Ce(this.state, h), b = Ce(p, h);
            return !fn(y, b);
          });
          this.setState(p, () => {
            s && g && s($c({ ...this.state, ...p }), t);
          });
        }
      });
      /** Callback function to handle when a field on the form is focused. Calls the `onFocus` callback for the `Form` if it
       * was provided.
       *
       * @param id - The unique `id` of the field that was focused
       * @param data - The data associated with the field that was focused
       */
      Gn(this, "onFocus", (t, n) => {
        const { onFocus: r } = this.props;
        r && r(t, n);
      });
      /** Callback function to handle when the form is submitted. First, it prevents the default event behavior. Nothing
       * happens if the target and currentTarget of the event are not the same. It will omit any extra data in the
       * `formData` in the state if `omitExtraData` is true. It will validate the resulting `formData`, reporting errors
       * via the `onError()` callback unless validation is disabled. Finally, it will add in any `extraErrors` and then call
       * back the `onSubmit` callback if it was provided.
       *
       * @param event - The submit HTML form event
       */
      Gn(this, "onSubmit", (t) => {
        if (t.preventDefault(), t.target !== t.currentTarget)
          return;
        t.persist();
        const { omitExtraData: n, extraErrors: r, noValidate: o, onSubmit: a } = this.props;
        let { formData: i } = this.state;
        if (n === !0 && (i = this.omitExtraData(i)), o || this.validateFormWithFormData(i)) {
          const s = r || {}, u = r ? dO(r) : [];
          this.setState({
            formData: i,
            errors: u,
            errorSchema: s,
            schemaValidationErrors: [],
            schemaValidationErrorSchema: {}
          }, () => {
            a && a($c({ ...this.state, formData: i }, "submitted"), t);
          });
        }
      });
      /** Provides a function that can be used to programmatically submit the `Form` */
      Gn(this, "submit", () => {
        if (this.formElement.current) {
          const t = new CustomEvent("submit", {
            cancelable: !0
          });
          t.preventDefault(), this.formElement.current.dispatchEvent(t), this.formElement.current.requestSubmit();
        }
      });
      /** Validates the form using the given `formData`. For use on form submission or on programmatic validation.
       * If `onError` is provided, then it will be called with the list of errors.
       *
       * @param formData - The form data to validate
       * @returns - True if the form is valid, false otherwise.
       */
      Gn(this, "validateFormWithFormData", (t) => {
        const { extraErrors: n, extraErrorsBlockSubmit: r, focusOnFirstError: o, onError: a } = this.props, { errors: i } = this.state, s = this.validate(t);
        let u = s.errors, c = s.errorSchema;
        const f = u, p = c, g = u.length > 0 || n && r;
        if (g) {
          if (n) {
            const h = Ky(s, n);
            c = h.errorSchema, u = h.errors;
          }
          o && (typeof o == "function" ? o(u[0]) : this.focusOnError(u[0])), this.setState({
            errors: u,
            errorSchema: c,
            schemaValidationErrors: f,
            schemaValidationErrorSchema: p
          }, () => {
            a ? a(u) : console.error("Form validation failed", u);
          });
        } else i.length > 0 && this.setState({
          errors: [],
          errorSchema: {},
          schemaValidationErrors: [],
          schemaValidationErrorSchema: {}
        });
        return !g;
      });
      if (!t.validator)
        throw new Error("A validator is required for Form functionality to work");
      const { formData: n, initialFormData: r, onChange: o } = t, a = n ?? r;
      this.state = this.getStateFromProps(t, a, void 0, void 0, void 0, !0), o && !fn(this.state.formData, a) && o($c(this.state)), this.formElement = C.createRef();
    }
    /**
     * `getSnapshotBeforeUpdate` is a React lifecycle method that is invoked right before the most recently rendered
     * output is committed to the DOM. It enables your component to capture current values (e.g., scroll position) before
     * they are potentially changed.
     *
     * In this case, it checks if the props have changed since the last render. If they have, it computes the next state
     * of the component using `getStateFromProps` method and returns it along with a `shouldUpdate` flag set to `true` IF
     * the `nextState` and `prevState` are different, otherwise `false`. This ensures that we have the most up-to-date
     * state ready to be applied in `componentDidUpdate`.
     *
     * If `formData` hasn't changed, it simply returns an object with `shouldUpdate` set to `false`, indicating that a
     * state update is not necessary.
     *
     * @param prevProps - The previous set of props before the update.
     * @param prevState - The previous state before the update.
     * @returns Either an object containing the next state and a flag indicating that an update should occur, or an object
     *        with a flag indicating that an update is not necessary.
     */
    getSnapshotBeforeUpdate(t, n) {
      if (!fn(this.props, t)) {
        const r = h4(this.props.formData, t.formData), o = h4(this.props.formData, this.state.formData), a = !fn(t.schema, this.props.schema), i = r.length > 0 || !fn(t.formData, this.props.formData), s = o.length > 0 || !fn(this.state.formData, this.props.formData), u = this.getStateFromProps(
          this.props,
          this.props.formData,
          // If the `schema` has changed, we need to update the retrieved schema.
          // Or if the `formData` changes, for example in the case of a schema with dependencies that need to
          //  match one of the subSchemas, the retrieved schema must be updated.
          a || i ? void 0 : this.state.retrievedSchema,
          a,
          r,
          // Skip live validation for this request if no form data has changed from the last state
          !s
        ), c = !fn(u, n);
        return { nextState: u, shouldUpdate: c };
      }
      return { shouldUpdate: !1 };
    }
    /**
     * `componentDidUpdate` is a React lifecycle method that is invoked immediately after updating occurs. This method is
     * not called for the initial render.
     *
     * Here, it checks if an update is necessary based on the `shouldUpdate` flag received from `getSnapshotBeforeUpdate`.
     * If an update is required, it applies the next state and, if needed, triggers the `onChange` handler to inform about
     * changes.
     *
     * @param _ - The previous set of props.
     * @param prevState - The previous state of the component before the update.
     * @param snapshot - The value returned from `getSnapshotBeforeUpdate`.
     */
    componentDidUpdate(t, n, r) {
      if (r.shouldUpdate) {
        const { nextState: o } = r;
        !fn(o.formData, this.props.formData) && !fn(o.formData, n.formData) && this.props.onChange && this.props.onChange($c(o)), this.setState(o);
      }
    }
    /** Extracts the updated state from the given `props` and `inputFormData`. As part of this process, the
     * `inputFormData` is first processed to add any missing required defaults. After that, the data is run through the
     * validation process IF required by the `props`.
     *
     * @param props - The props passed to the `Form`
     * @param inputFormData - The new or current data for the `Form`
     * @param retrievedSchema - An expanded schema, if not provided, it will be retrieved from the `schema` and `formData`.
     * @param isSchemaChanged - A flag indicating whether the schema has changed.
     * @param formDataChangedFields - The changed fields of `formData`
     * @param skipLiveValidate - Optional flag, if true, means that we are not running live validation
     * @returns - The new state for the `Form`
     */
    getStateFromProps(t, n, r, o = !1, a = [], i = !1) {
      const s = this.state || {}, u = "schema" in t ? t.schema : this.props.schema, c = "validator" in t ? t.validator : this.props.validator, f = ("uiSchema" in t ? t.uiSchema : this.props.uiSchema) || {}, p = t.formData === void 0 && this.props.formData === void 0, g = typeof n < "u", h = "liveValidate" in t ? t.liveValidate : this.props.liveValidate, y = g && !t.noValidate && h, b = "experimental_defaultFormStateBehavior" in t ? t.experimental_defaultFormStateBehavior : this.props.experimental_defaultFormStateBehavior, v = "experimental_customMergeAllOf" in t ? t.experimental_customMergeAllOf : this.props.experimental_customMergeAllOf;
      let w = s.schemaUtils;
      (!w || w.doesSchemaUtilsDiffer(c, u, b, v)) && (w = X2e(c, u, b, v));
      const _ = w.getRootSchema();
      let k = n;
      n === xL ? k = void 0 : n === void 0 && p && (k = s.formData);
      const E = w.getDefaultFormState(_, k, !1, s.initialDefaultsGenerated), P = this.updateRetrievedSchema(r ?? w.retrieveSchema(_, E)), O = () => t.noValidate || o ? { errors: [], errorSchema: {} } : t.liveValidate ? {
        errors: s.errors || [],
        errorSchema: s.errorSchema || {}
      } : {
        errors: s.schemaValidationErrors || [],
        errorSchema: s.schemaValidationErrorSchema || {}
      };
      let M, I, A = s.schemaValidationErrors, D = s.schemaValidationErrorSchema;
      if (y && !i) {
        const $ = this.liveValidate(
          _,
          w,
          s.errorSchema,
          E,
          void 0,
          s.customErrors,
          r,
          // If retrievedSchema is undefined which means the schema or formData has changed, we do not merge state.
          // Else in the case where it hasn't changed,
          r !== void 0
        );
        M = $.errors, I = $.errorSchema, A = $.schemaValidationErrors, D = $.schemaValidationErrorSchema;
      } else {
        const $ = O();
        if (M = $.errors, I = $.errorSchema, a.length > 0 && !y) {
          const B = a.reduce((G, W) => (G[W] = void 0, G), {});
          I = D = Sm($.errorSchema, B, "preventDuplicates");
        }
        const q = this.mergeErrors({ errorSchema: I, errors: M }, t.extraErrors, s.customErrors);
        M = q.errors, I = q.errorSchema;
      }
      const F = this.getRegistry(t, _, w), j = fn(s.registry, F) ? s.registry : F, U = s.fieldPathId && s.fieldPathId?.[rn] === j.globalFormOptions.idPrefix ? s.fieldPathId : Do("", j.globalFormOptions);
      return {
        schemaUtils: w,
        schema: _,
        uiSchema: f,
        fieldPathId: U,
        formData: E,
        edit: g,
        errors: M,
        errorSchema: I,
        schemaValidationErrors: A,
        schemaValidationErrorSchema: D,
        retrievedSchema: P,
        initialDefaultsGenerated: !0,
        registry: j
      };
    }
    /** React lifecycle method that is used to determine whether component should be updated.
     *
     * @param nextProps - The next version of the props
     * @param nextState - The next version of the state
     * @returns - True if the component should be updated, false otherwise
     */
    shouldComponentUpdate(t, n) {
      const { experimental_componentUpdateStrategy: r = "customDeep" } = this.props;
      return _1(this, t, n, r);
    }
    /** Validates the `formData` against the `schema` using the `altSchemaUtils` (if provided otherwise it uses the
     * `schemaUtils` in the state), returning the results.
     *
     * @param formData - The new form data to validate
     * @param schema - The schema used to validate against
     * @param [altSchemaUtils] - The alternate schemaUtils to use for validation
     * @param [retrievedSchema] - An optionally retrieved schema for per
     */
    validate(t, n = this.state.schema, r, o) {
      const a = r || this.state.schemaUtils, { customValidate: i, transformErrors: s, uiSchema: u } = this.props, c = o ?? a.retrieveSchema(n, t);
      return a.getValidator().validateFormData(t, c, i, s, u);
    }
    /** Renders any errors contained in the `state` in using the `ErrorList`, if not disabled by `showErrorList`. */
    renderErrors(t) {
      const { errors: n, errorSchema: r, schema: o, uiSchema: a } = this.state, i = Qe(a), s = et("ErrorListTemplate", t, i);
      return n && n.length ? S.jsx(s, { errors: n, errorSchema: r || {}, schema: o, uiSchema: a, registry: t }) : null;
    }
    /** Merges any `extraErrors` or `customErrors` into the given `schemaValidation` object, returning the result
     *
     * @param schemaValidation - The `ValidationData` object into which additional errors are merged
     * @param [extraErrors] - The extra errors from the props
     * @param [customErrors] - The customErrors from custom components
     * @return - The `extraErrors` and `customErrors` merged into the `schemaValidation`
     * @private
     */
    mergeErrors(t, n, r) {
      let o = t.errorSchema, a = t.errors;
      if (n) {
        const i = Ky(t, n);
        o = i.errorSchema, a = i.errors;
      }
      if (r) {
        const i = Ky(t, r.ErrorSchema, !0);
        o = i.errorSchema, a = i.errors;
      }
      return { errors: a, errorSchema: o };
    }
    /** Performs live validation and then updates and returns the errors and error schemas by potentially merging in
     * `extraErrors` and `customErrors`.
     *
     * @param rootSchema - The `rootSchema` from the state
     * @param schemaUtils - The `SchemaUtilsType` from the state
     * @param originalErrorSchema - The original `ErrorSchema` from the state
     * @param [formData] - The new form data to validate
     * @param [extraErrors] - The extra errors from the props
     * @param [customErrors] - The customErrors from custom components
     * @param [retrievedSchema] - An expanded schema, if not provided, it will be retrieved from the `schema` and `formData`
     * @param [mergeIntoOriginalErrorSchema=false] - Optional flag indicating whether we merge into original schema
     * @returns - An object containing `errorSchema`, `errors`, `schemaValidationErrors` and `schemaValidationErrorSchema`
     * @private
     */
    liveValidate(t, n, r, o, a, i, s, u = !1) {
      const c = this.validate(o, t, n, s), f = c.errors;
      let p = c.errorSchema;
      u && (p = Sm(r, c.errorSchema, "preventDuplicates"));
      const g = f, h = p;
      return { ...this.mergeErrors({ errorSchema: p, errors: f }, a, i), schemaValidationErrors: g, schemaValidationErrorSchema: h };
    }
    /** Function to handle changes made to a field in the `Form`. This handler gets the first change from the
     * `pendingChanges` list, containing the `newValue` for the `formData` and the `path` at which the `newValue` is to be
     * updated, along with a new, optional `ErrorSchema` for that same `path` and potentially the `id` of the field being
     * changed. It will first update the `formData` with any missing default fields and then, if `omitExtraData` and
     * `liveOmit` are turned on, the `formData` will be filtered to remove any extra data not in a form field. Then, the
     * resulting `formData` will be validated if required. The state will be updated with the new updated (potentially
     * filtered) `formData`, any errors that resulted from validation. Finally the `onChange` callback will be called, if
     * specified, with the updated state and the `processPendingChange()` function is called again.
     */
    processPendingChange() {
      if (this.pendingChanges.length === 0)
        return;
      const { newValue: t, path: n, id: r } = this.pendingChanges[0], { newErrorSchema: o } = this.pendingChanges[0], { extraErrors: a, omitExtraData: i, liveOmit: s, noValidate: u, liveValidate: c, onChange: f } = this.props, { formData: p, schemaUtils: g, schema: h, fieldPathId: y, schemaValidationErrorSchema: b, errors: v } = this.state;
      let { customErrors: w, errorSchema: _ } = this.state;
      const k = y.path[0] || "", E = !n || n.length === 0 || n.length === 1 && n[0] === k;
      let P = this.state.retrievedSchema, O = E ? t : iO(p);
      if (Ot(O) || Array.isArray(O)) {
        t === G1 ? ZCe(O, n) : E || Qt(O, n, t);
        const D = this.getStateFromProps(this.props, O, void 0, void 0, void 0, !0);
        O = D.formData, P = D.retrievedSchema;
      }
      const M = !u && (c === !0 || c === "onChange");
      let I = { formData: O, schema: h }, A = O;
      if (i === !0 && (s === !0 || s === "onChange") && (A = this.omitExtraData(O), I = {
        formData: A
      }), o) {
        const D = E ? b : Ce(b, n);
        if (!Hn(D))
          E ? _ = o : Qt(_, n, o);
        else if (w || (w = new y1()), E) {
          const F = Ce(o, cr);
          F && w.setErrors(F);
        } else
          Qt(w.ErrorSchema, n, o);
      } else w && Ce(w.ErrorSchema, [...n, cr]) && w.clearErrors(n);
      if (M && this.pendingChanges.length === 1) {
        const D = this.liveValidate(h, g, _, A, a, w, P);
        I = { formData: A, ...D, customErrors: w };
      } else if (!u && o) {
        const D = this.mergeErrors({ errorSchema: _, errors: v }, a, w);
        I = {
          formData: A,
          ...D,
          customErrors: w
        };
      }
      this.setState(I, () => {
        f && f($c({ ...this.state, ...I }), r), this.pendingChanges.shift(), this.processPendingChange();
      });
    }
    /**
     * If the retrievedSchema has changed the new retrievedSchema is returned.
     * Otherwise, the old retrievedSchema is returned to persist reference.
     * -  This ensures that AJV retrieves the schema from the cache when it has not changed,
     *    avoiding the performance cost of recompiling the schema.
     *
     * @param retrievedSchema The new retrieved schema.
     * @returns The new retrieved schema if it has changed, else the old retrieved schema.
     */
    updateRetrievedSchema(t) {
      return fn(t, this.state?.retrievedSchema) ? this.state.retrievedSchema : t;
    }
    /** Extracts the `GlobalFormOptions` from the given Form `props`
     *
     * @param props - The form props to extract the global form options from
     * @returns - The `GlobalFormOptions` from the props
     * @private
     */
    getGlobalFormOptions(t) {
      const { uiSchema: n = {}, experimental_componentUpdateStrategy: r, idSeparator: o = rV, idPrefix: a = nV, nameGenerator: i, useFallbackUiForUnsupportedType: s = !1 } = t;
      return {
        idPrefix: n["ui:rootFieldId"] || a,
        idSeparator: o,
        useFallbackUiForUnsupportedType: s,
        ...r !== void 0 && { experimental_componentUpdateStrategy: r },
        ...i !== void 0 && { nameGenerator: i }
      };
    }
    /** Computed the registry for the form using the given `props`, `schema` and `schemaUtils` */
    getRegistry(t, n, r) {
      const { translateString: o, uiSchema: a = {} } = t, { fields: i, templates: s, widgets: u, formContext: c, translateString: f } = QNe();
      return {
        fields: { ...i, ...t.fields },
        templates: {
          ...s,
          ...t.templates,
          ButtonTemplates: {
            ...s.ButtonTemplates,
            ...t.templates?.ButtonTemplates
          }
        },
        widgets: { ...u, ...t.widgets },
        rootSchema: n,
        formContext: t.formContext || c,
        schemaUtils: r,
        translateString: o || f,
        globalUiOptions: a[aE],
        globalFormOptions: this.getGlobalFormOptions(t)
      };
    }
    /** Attempts to focus on the field associated with the `error`. Uses the `property` field to compute path of the error
     * field, then, using the `idPrefix` and `idSeparator` converts that path into an id. Then the input element with that
     * id is attempted to be found using the `formElement` ref. If it is located, then it is focused.
     *
     * @param error - The error on which to focus
     */
    focusOnError(t) {
      const { idPrefix: n = "root", idSeparator: r = "_" } = this.props, { property: o } = t, a = E1(o);
      a[0] === "" ? a[0] = n : a.unshift(n);
      const i = a.join(r);
      let s = this.formElement.current.elements[i];
      s || (s = this.formElement.current.querySelector(`input[id^="${i}"`)), s && s.length && (s = s[0]), s && s.focus();
    }
    /** Programmatically validate the form.  If `omitExtraData` is true, the `formData` will first be filtered to remove
     * any extra data not in a form field. If `onError` is provided, then it will be called with the list of errors the
     * same way as would happen on form submission.
     *
     * @returns - True if the form is valid, false otherwise.
     */
    validateForm() {
      const { omitExtraData: t } = this.props;
      let { formData: n } = this.state;
      return t === !0 && (n = this.omitExtraData(n)), this.validateFormWithFormData(n);
    }
    /** Renders the `Form` fields inside the <form> | `tagName` or `_internalFormWrapper`, rendering any errors if
     * needed along with the submit button or any children of the form.
     */
    render() {
      const { children: t, id: n, className: r = "", tagName: o, name: a, method: i, target: s, action: u, autoComplete: c, enctype: f, acceptCharset: p, noHtml5Validate: g = !1, disabled: h, readonly: y, showErrorList: b = "top", _internalFormWrapper: v } = this.props, { schema: w, uiSchema: _, formData: k, errorSchema: E, fieldPathId: P, registry: O } = this.state, { SchemaField: M } = O.fields, { SubmitButton: I } = O.templates.ButtonTemplates, A = v ? o : void 0, D = v || o || "form";
      let { [Ab]: F = {} } = Qe(_);
      h && (F = { ...F, props: { ...F.props, disabled: !0 } });
      const j = { [Js]: { [Ab]: F } };
      return S.jsxs(D, { className: r || "rjsf", id: n, name: a, method: i, target: s, action: u, autoComplete: c, encType: f, acceptCharset: p, noValidate: g, onSubmit: this.onSubmit, as: A, ref: this.formElement, children: [b === "top" && this.renderErrors(O), S.jsx(M, { name: "", schema: w, uiSchema: _, errorSchema: E, fieldPathId: P, formData: k, onChange: this.onChange, onBlur: this.onBlur, onFocus: this.onFocus, registry: O, disabled: h, readonly: y }), t || S.jsx(I, { uiSchema: j, registry: O }), b === "bottom" && this.renderErrors(O)] });
    }
  };
  function Z1(e) {
    return C.forwardRef(({ fields: t, widgets: n, templates: r, ...o }, a) => (t = { ...e?.fields, ...t }, n = { ...e?.widgets, ...n }, r = {
      ...e?.templates,
      ...r,
      ButtonTemplates: {
        ...e?.templates?.ButtonTemplates,
        ...r?.ButtonTemplates
      }
    }, S.jsx(ZNe, { ...e, ...o, fields: t, widgets: n, templates: r, ref: a })));
  }
  function wE(...e) {
    return e.reduce((t, n) => n == null ? t : function(...r) {
      t.apply(this, r), n.apply(this, r);
    }, () => {
    });
  }
  function eU(e, t = 166) {
    let n;
    function r(...o) {
      const a = () => {
        e.apply(this, o);
      };
      clearTimeout(n), n = setTimeout(a, t);
    }
    return r.clear = () => {
      clearTimeout(n);
    }, r;
  }
  function Or(e) {
    return e && e.ownerDocument || document;
  }
  function Ji(e) {
    return Or(e).defaultView || window;
  }
  function kL(e, t) {
    typeof e == "function" ? e(t) : e && (e.current = t);
  }
  function Em(e) {
    const {
      controlled: t,
      default: n,
      name: r,
      state: o = "value"
    } = e, {
      current: a
    } = C.useRef(t !== void 0), [i, s] = C.useState(n), u = a ? t : i, c = C.useCallback((f) => {
      a || s(f);
    }, []);
    return [u, c];
  }
  function eMe(e, t) {
    const n = e.charCodeAt(2);
    return e[0] === "o" && e[1] === "n" && n >= 65 && n <= 90 && typeof t == "function";
  }
  function tU(e, t) {
    if (!e)
      return t;
    function n(i, s) {
      const u = {};
      return Object.keys(s).forEach((c) => {
        eMe(c, s[c]) && typeof i[c] == "function" && (u[c] = (...f) => {
          i[c](...f), s[c](...f);
        });
      }), u;
    }
    if (typeof e == "function" || typeof t == "function")
      return (i) => {
        const s = typeof t == "function" ? t(i) : t, u = typeof e == "function" ? e({
          ...i,
          ...s
        }) : e, c = Le(i?.className, s?.className, u?.className), f = n(u, s);
        return {
          ...s,
          ...u,
          ...f,
          ...!!c && {
            className: c
          },
          ...s?.style && u?.style && {
            style: {
              ...s.style,
              ...u.style
            }
          },
          ...s?.sx && u?.sx && {
            sx: [...Array.isArray(s.sx) ? s.sx : [s.sx], ...Array.isArray(u.sx) ? u.sx : [u.sx]]
          }
        };
      };
    const r = t, o = n(e, r), a = Le(r?.className, e?.className);
    return {
      ...t,
      ...e,
      ...o,
      ...!!a && {
        className: a
      },
      ...r?.style && e?.style && {
        style: {
          ...r.style,
          ...e.style
        }
      },
      ...r?.sx && e?.sx && {
        sx: [...Array.isArray(r.sx) ? r.sx : [r.sx], ...Array.isArray(e.sx) ? e.sx : [e.sx]]
      }
    };
  }
  const nU = mo(/* @__PURE__ */ S.jsx("path", {
    d: "M19 13h-6v6h-2v-6H5v-2h6V5h2v6h6z"
  }));
  function tMe(e) {
    return typeof e.main == "string";
  }
  function nMe(e, t = []) {
    if (!tMe(e))
      return !1;
    for (const n of t)
      if (!e.hasOwnProperty(n) || typeof e[n] != "string")
        return !1;
    return !0;
  }
  function xr(e = []) {
    return ([, t]) => t && nMe(t, e);
  }
  function rMe(e) {
    return rt("MuiCircularProgress", e);
  }
  tt("MuiCircularProgress", ["root", "determinate", "indeterminate", "colorPrimary", "colorSecondary", "svg", "track", "circle", "circleDeterminate", "circleIndeterminate", "circleDisableShrink"]);
  const qo = 44, xE = Ad`
  0% {
    transform: rotate(0deg);
  }

  100% {
    transform: rotate(360deg);
  }
`, kE = Ad`
  0% {
    stroke-dasharray: 1px, 200px;
    stroke-dashoffset: 0;
  }

  50% {
    stroke-dasharray: 100px, 200px;
    stroke-dashoffset: -15px;
  }

  100% {
    stroke-dasharray: 1px, 200px;
    stroke-dashoffset: -126px;
  }
`, oMe = typeof xE != "string" ? Fm`
        animation: ${xE} 1.4s linear infinite;
      ` : null, aMe = typeof kE != "string" ? Fm`
        animation: ${kE} 1.4s ease-in-out infinite;
      ` : null, iMe = (e) => {
    const {
      classes: t,
      variant: n,
      color: r,
      disableShrink: o
    } = e, a = {
      root: ["root", n, `color${$e(r)}`],
      svg: ["svg"],
      track: ["track"],
      circle: ["circle", `circle${$e(n)}`, o && "circleDisableShrink"]
    };
    return nt(a, rMe, t);
  }, sMe = Me("span", {
    name: "MuiCircularProgress",
    slot: "Root",
    overridesResolver: (e, t) => {
      const {
        ownerState: n
      } = e;
      return [t.root, t[n.variant], t[`color${$e(n.color)}`]];
    }
  })(at(({
    theme: e
  }) => ({
    display: "inline-block",
    variants: [{
      props: {
        variant: "determinate"
      },
      style: {
        transition: e.transitions.create("transform")
      }
    }, {
      props: {
        variant: "indeterminate"
      },
      style: oMe || {
        animation: `${xE} 1.4s linear infinite`
      }
    }, ...Object.entries(e.palette).filter(xr()).map(([t]) => ({
      props: {
        color: t
      },
      style: {
        color: (e.vars || e).palette[t].main
      }
    }))]
  }))), lMe = Me("svg", {
    name: "MuiCircularProgress",
    slot: "Svg"
  })({
    display: "block"
    // Keeps the progress centered
  }), uMe = Me("circle", {
    name: "MuiCircularProgress",
    slot: "Circle",
    overridesResolver: (e, t) => {
      const {
        ownerState: n
      } = e;
      return [t.circle, t[`circle${$e(n.variant)}`], n.disableShrink && t.circleDisableShrink];
    }
  })(at(({
    theme: e
  }) => ({
    stroke: "currentColor",
    variants: [{
      props: {
        variant: "determinate"
      },
      style: {
        transition: e.transitions.create("stroke-dashoffset")
      }
    }, {
      props: {
        variant: "indeterminate"
      },
      style: {
        // Some default value that looks fine waiting for the animation to kicks in.
        strokeDasharray: "80px, 200px",
        strokeDashoffset: 0
        // Add the unit to fix a Edge 16 and below bug.
      }
    }, {
      props: ({
        ownerState: t
      }) => t.variant === "indeterminate" && !t.disableShrink,
      style: aMe || {
        // At runtime for Pigment CSS, `bufferAnimation` will be null and the generated keyframe will be used.
        animation: `${kE} 1.4s ease-in-out infinite`
      }
    }]
  }))), cMe = Me("circle", {
    name: "MuiCircularProgress",
    slot: "Track"
  })(at(({
    theme: e
  }) => ({
    stroke: "currentColor",
    opacity: (e.vars || e).palette.action.activatedOpacity
  }))), rU = /* @__PURE__ */ C.forwardRef(function(e, t) {
    const n = lt({
      props: e,
      name: "MuiCircularProgress"
    }), {
      className: r,
      color: o = "primary",
      disableShrink: a = !1,
      enableTrackSlot: i = !1,
      size: s = 40,
      style: u,
      thickness: c = 3.6,
      value: f = 0,
      variant: p = "indeterminate",
      ...g
    } = n, h = {
      ...n,
      color: o,
      disableShrink: a,
      size: s,
      thickness: c,
      value: f,
      variant: p,
      enableTrackSlot: i
    }, y = iMe(h), b = {}, v = {}, w = {};
    if (p === "determinate") {
      const _ = 2 * Math.PI * ((qo - c) / 2);
      b.strokeDasharray = _.toFixed(3), w["aria-valuenow"] = Math.round(f), b.strokeDashoffset = `${((100 - f) / 100 * _).toFixed(3)}px`, v.transform = "rotate(-90deg)";
    }
    return /* @__PURE__ */ S.jsx(sMe, {
      className: Le(y.root, r),
      style: {
        width: s,
        height: s,
        ...v,
        ...u
      },
      ownerState: h,
      ref: t,
      role: "progressbar",
      ...w,
      ...g,
      children: /* @__PURE__ */ S.jsxs(lMe, {
        className: y.svg,
        ownerState: h,
        viewBox: `${qo / 2} ${qo / 2} ${qo} ${qo}`,
        children: [i ? /* @__PURE__ */ S.jsx(cMe, {
          className: y.track,
          ownerState: h,
          cx: qo,
          cy: qo,
          r: (qo - c) / 2,
          fill: "none",
          strokeWidth: c,
          "aria-hidden": "true"
        }) : null, /* @__PURE__ */ S.jsx(uMe, {
          className: y.circle,
          style: b,
          ownerState: h,
          cx: qo,
          cy: qo,
          r: (qo - c) / 2,
          fill: "none",
          strokeWidth: c
        })]
      })
    });
  });
  function dMe(e) {
    return rt("MuiIconButton", e);
  }
  const SL = tt("MuiIconButton", ["root", "disabled", "colorInherit", "colorPrimary", "colorSecondary", "colorError", "colorInfo", "colorSuccess", "colorWarning", "edgeStart", "edgeEnd", "sizeSmall", "sizeMedium", "sizeLarge", "loading", "loadingIndicator", "loadingWrapper"]), fMe = (e) => {
    const {
      classes: t,
      disabled: n,
      color: r,
      edge: o,
      size: a,
      loading: i
    } = e, s = {
      root: ["root", i && "loading", n && "disabled", r !== "default" && `color${$e(r)}`, o && `edge${$e(o)}`, `size${$e(a)}`],
      loadingIndicator: ["loadingIndicator"],
      loadingWrapper: ["loadingWrapper"]
    };
    return nt(s, dMe, t);
  }, pMe = Me(zm, {
    name: "MuiIconButton",
    slot: "Root",
    overridesResolver: (e, t) => {
      const {
        ownerState: n
      } = e;
      return [t.root, n.loading && t.loading, n.color !== "default" && t[`color${$e(n.color)}`], n.edge && t[`edge${$e(n.edge)}`], t[`size${$e(n.size)}`]];
    }
  })(at(({
    theme: e
  }) => ({
    textAlign: "center",
    flex: "0 0 auto",
    fontSize: e.typography.pxToRem(24),
    padding: 8,
    borderRadius: "50%",
    color: (e.vars || e).palette.action.active,
    transition: e.transitions.create("background-color", {
      duration: e.transitions.duration.shortest
    }),
    variants: [{
      props: (t) => !t.disableRipple,
      style: {
        "--IconButton-hoverBg": e.alpha((e.vars || e).palette.action.active, (e.vars || e).palette.action.hoverOpacity),
        "&:hover": {
          backgroundColor: "var(--IconButton-hoverBg)",
          // Reset on touch devices, it doesn't add specificity
          "@media (hover: none)": {
            backgroundColor: "transparent"
          }
        }
      }
    }, {
      props: {
        edge: "start"
      },
      style: {
        marginLeft: -12
      }
    }, {
      props: {
        edge: "start",
        size: "small"
      },
      style: {
        marginLeft: -3
      }
    }, {
      props: {
        edge: "end"
      },
      style: {
        marginRight: -12
      }
    }, {
      props: {
        edge: "end",
        size: "small"
      },
      style: {
        marginRight: -3
      }
    }]
  })), at(({
    theme: e
  }) => ({
    variants: [{
      props: {
        color: "inherit"
      },
      style: {
        color: "inherit"
      }
    }, ...Object.entries(e.palette).filter(xr()).map(([t]) => ({
      props: {
        color: t
      },
      style: {
        color: (e.vars || e).palette[t].main
      }
    })), ...Object.entries(e.palette).filter(xr()).map(([t]) => ({
      props: {
        color: t
      },
      style: {
        "--IconButton-hoverBg": e.alpha((e.vars || e).palette[t].main, (e.vars || e).palette.action.hoverOpacity)
      }
    })), {
      props: {
        size: "small"
      },
      style: {
        padding: 5,
        fontSize: e.typography.pxToRem(18)
      }
    }, {
      props: {
        size: "large"
      },
      style: {
        padding: 12,
        fontSize: e.typography.pxToRem(28)
      }
    }],
    [`&.${SL.disabled}`]: {
      backgroundColor: "transparent",
      color: (e.vars || e).palette.action.disabled
    },
    [`&.${SL.loading}`]: {
      color: "transparent"
    }
  }))), mMe = Me("span", {
    name: "MuiIconButton",
    slot: "LoadingIndicator"
  })(({
    theme: e
  }) => ({
    display: "none",
    position: "absolute",
    visibility: "visible",
    top: "50%",
    left: "50%",
    transform: "translate(-50%, -50%)",
    color: (e.vars || e).palette.action.disabled,
    variants: [{
      props: {
        loading: !0
      },
      style: {
        display: "flex"
      }
    }]
  })), oU = /* @__PURE__ */ C.forwardRef(function(e, t) {
    const n = lt({
      props: e,
      name: "MuiIconButton"
    }), {
      edge: r = !1,
      children: o,
      className: a,
      color: i = "default",
      disabled: s = !1,
      disableFocusRipple: u = !1,
      size: c = "medium",
      id: f,
      loading: p = null,
      loadingIndicator: g,
      ...h
    } = n, y = $d(f), b = g ?? /* @__PURE__ */ S.jsx(rU, {
      "aria-labelledby": y,
      color: "inherit",
      size: 16
    }), v = {
      ...n,
      edge: r,
      color: i,
      disabled: s,
      disableFocusRipple: u,
      loading: p,
      loadingIndicator: b,
      size: c
    }, w = fMe(v);
    return /* @__PURE__ */ S.jsxs(pMe, {
      id: p ? y : f,
      className: Le(w.root, a),
      centerRipple: !0,
      focusRipple: !u,
      disabled: s || p,
      ref: t,
      ...h,
      ownerState: v,
      children: [typeof p == "boolean" && // use plain HTML span to minimize the runtime overhead
      /* @__PURE__ */ S.jsx("span", {
        className: w.loadingWrapper,
        style: {
          display: "contents"
        },
        children: /* @__PURE__ */ S.jsx(mMe, {
          className: w.loadingIndicator,
          ownerState: v,
          children: p && b
        })
      }), o]
    });
  });
  function hMe({ uiSchema: e, registry: t, ...n }) {
    const { translateString: r } = t;
    return S.jsx(oU, { title: r(ht.AddItemButton), ...n, color: "primary", children: S.jsx(nU, {}) });
  }
  function gMe({
    theme: e,
    ...t
  }) {
    const n = za in e ? e[za] : void 0;
    return /* @__PURE__ */ S.jsx(RT, {
      ...t,
      themeId: n ? za : void 0,
      theme: n || e
    });
  }
  const cy = {
    colorSchemeStorageKey: "mui-color-scheme",
    defaultLightColorScheme: "light",
    defaultDarkColorScheme: "dark",
    modeStorageKey: "mui-mode"
  }, {
    CssVarsProvider: vMe
  } = iJ({
    themeId: za,
    // @ts-ignore ignore module augmentation tests
    theme: () => mw({
      cssVariables: !0
    }),
    colorSchemeStorageKey: cy.colorSchemeStorageKey,
    modeStorageKey: cy.modeStorageKey,
    defaultColorScheme: {
      light: cy.defaultLightColorScheme,
      dark: cy.defaultDarkColorScheme
    },
    resolveTheme: (e) => {
      const t = {
        ...e,
        typography: DT(e.palette, e.typography)
      };
      return t.unstable_sx = function(n) {
        return nl({
          sx: n,
          theme: this
        });
      }, t;
    }
  }), yMe = vMe;
  function bMe({
    theme: e,
    ...t
  }) {
    const n = C.useMemo(() => {
      if (typeof e == "function")
        return e;
      const r = za in e ? e[za] : e;
      return "colorSchemes" in r ? null : "vars" in r ? e : {
        ...e,
        vars: null
      };
    }, [e]);
    return n ? /* @__PURE__ */ S.jsx(gMe, {
      theme: n,
      ...t
    }) : /* @__PURE__ */ S.jsx(yMe, {
      theme: e,
      ...t
    });
  }
  const wMe = tt("MuiBox", ["root"]), xMe = mw(), pl = EY({
    themeId: za,
    defaultTheme: xMe,
    defaultClassName: wMe.root,
    generateClassName: kT.generate
  }), dr = PJ({
    createStyledComponent: Me("div", {
      name: "MuiGrid",
      slot: "Root",
      overridesResolver: (e, t) => {
        const {
          ownerState: n
        } = e;
        return [t.root, n.container && t.container];
      }
    }),
    componentName: "MuiGrid",
    useThemeProps: (e) => lt({
      props: e,
      name: "MuiGrid"
    }),
    useTheme: hw
  });
  function _L() {
    return null;
  }
  _L.isRequired = _L;
  function kMe(e) {
    return rt("MuiPaper", e);
  }
  tt("MuiPaper", ["root", "rounded", "outlined", "elevation", "elevation0", "elevation1", "elevation2", "elevation3", "elevation4", "elevation5", "elevation6", "elevation7", "elevation8", "elevation9", "elevation10", "elevation11", "elevation12", "elevation13", "elevation14", "elevation15", "elevation16", "elevation17", "elevation18", "elevation19", "elevation20", "elevation21", "elevation22", "elevation23", "elevation24"]);
  const SMe = (e) => {
    const {
      square: t,
      elevation: n,
      variant: r,
      classes: o
    } = e, a = {
      root: ["root", r, !t && "rounded", r === "elevation" && `elevation${n}`]
    };
    return nt(a, kMe, o);
  }, _Me = Me("div", {
    name: "MuiPaper",
    slot: "Root",
    overridesResolver: (e, t) => {
      const {
        ownerState: n
      } = e;
      return [t.root, t[n.variant], !n.square && t.rounded, n.variant === "elevation" && t[`elevation${n.elevation}`]];
    }
  })(at(({
    theme: e
  }) => ({
    backgroundColor: (e.vars || e).palette.background.paper,
    color: (e.vars || e).palette.text.primary,
    transition: e.transitions.create("box-shadow"),
    variants: [{
      props: ({
        ownerState: t
      }) => !t.square,
      style: {
        borderRadius: e.shape.borderRadius
      }
    }, {
      props: {
        variant: "outlined"
      },
      style: {
        border: `1px solid ${(e.vars || e).palette.divider}`
      }
    }, {
      props: {
        variant: "elevation"
      },
      style: {
        boxShadow: "var(--Paper-shadow)",
        backgroundImage: "var(--Paper-overlay)"
      }
    }]
  }))), Cx = /* @__PURE__ */ C.forwardRef(function(e, t) {
    const n = lt({
      props: e,
      name: "MuiPaper"
    }), r = hw(), {
      className: o,
      component: a = "div",
      elevation: i = 1,
      square: s = !1,
      variant: u = "elevation",
      ...c
    } = n, f = {
      ...n,
      component: a,
      elevation: i,
      square: s,
      variant: u
    }, p = SMe(f);
    return /* @__PURE__ */ S.jsx(_Me, {
      as: a,
      ownerState: f,
      className: Le(p.root, o),
      ref: t,
      ...c,
      style: {
        ...u === "elevation" && {
          "--Paper-shadow": (r.vars || r).shadows[i],
          ...r.vars && {
            "--Paper-overlay": r.vars.overlays?.[i]
          },
          ...!r.vars && r.palette.mode === "dark" && {
            "--Paper-overlay": `linear-gradient(${Qy("#fff", i2(i))}, ${Qy("#fff", i2(i))})`
          }
        },
        ...c.style
      }
    });
  });
  function EMe(e) {
    const { children: t, buttonsProps: n, hasDescription: r, hasToolbar: o, uiSchema: a, registry: i } = e, s = Qe(a), u = et("ArrayFieldItemButtonsTemplate", i, s), c = {
      flex: 1,
      paddingLeft: 6,
      paddingRight: 6,
      fontWeight: "bold",
      minWidth: 0
    };
    return S.jsxs(dr, { container: !0, alignItems: "center", children: [S.jsx(dr, { size: { xs: 8, sm: 9, md: 10, lg: 11, xl: 11.25 }, style: { overflow: "auto" }, children: S.jsx(pl, { mb: 2, children: S.jsx(Cx, { elevation: 2, children: S.jsx(pl, { p: 2, children: t }) }) }) }), o && S.jsx(dr, { sx: { mt: r ? -5 : -1.5 }, children: S.jsx(u, { ...n, style: c }) })] });
  }
  function CMe(e) {
    const { canAdd: t, disabled: n, fieldPathId: r, uiSchema: o, items: a, optionalDataControl: i, onAddClick: s, readonly: u, registry: c, required: f, schema: p, title: g } = e, h = Qe(o), y = et("ArrayFieldDescriptionTemplate", c, h), b = et("ArrayFieldTitleTemplate", c, h), v = !u && !n, { ButtonTemplates: { AddButton: w } } = c.templates;
    return S.jsx(Cx, { elevation: 2, children: S.jsxs(pl, { p: 2, children: [S.jsx(b, { fieldPathId: r, title: h.title || g, schema: p, uiSchema: o, required: f, registry: c, optionalDataControl: v ? i : void 0 }), S.jsx(y, { fieldPathId: r, description: h.description || p.description, schema: p, uiSchema: o, registry: c }), v ? void 0 : i, a, t && S.jsx(dr, { container: !0, justifyContent: "flex-end", children: S.jsx(dr, { children: S.jsx(pl, { mt: 2, children: S.jsx(w, { id: Da(r, "add"), className: "rjsf-array-item-add", onClick: s, disabled: n || u, uiSchema: o, registry: c }) }) }) })] }) });
  }
  function dy(e) {
    return parseInt(e, 10) || 0;
  }
  const PMe = {
    shadow: {
      // Visibility needed to hide the extra text area on iPads
      visibility: "hidden",
      // Remove from the content flow
      position: "absolute",
      // Ignore the scrollbar width
      overflow: "hidden",
      height: 0,
      top: 0,
      left: 0,
      // Create a new layer, increase the isolation of the computed values
      transform: "translateZ(0)"
    }
  };
  function OMe(e) {
    for (const t in e)
      return !1;
    return !0;
  }
  function EL(e) {
    return OMe(e) || e.outerHeightStyle === 0 && !e.overflowing;
  }
  const NMe = /* @__PURE__ */ C.forwardRef(function(e, t) {
    const {
      onChange: n,
      maxRows: r,
      minRows: o = 1,
      style: a,
      value: i,
      ...s
    } = e, {
      current: u
    } = C.useRef(i != null), c = C.useRef(null), f = Zn(t, c), p = C.useRef(null), g = C.useRef(null), h = C.useCallback(() => {
      const _ = c.current, k = g.current;
      if (!_ || !k)
        return;
      const E = Ji(_).getComputedStyle(_);
      if (E.width === "0px")
        return {
          outerHeightStyle: 0,
          overflowing: !1
        };
      k.style.width = E.width, k.value = _.value || e.placeholder || "x", k.value.slice(-1) === `
` && (k.value += " ");
      const P = E.boxSizing, O = dy(E.paddingBottom) + dy(E.paddingTop), M = dy(E.borderBottomWidth) + dy(E.borderTopWidth), I = k.scrollHeight;
      k.value = "x";
      const A = k.scrollHeight;
      let D = I;
      o && (D = Math.max(Number(o) * A, D)), r && (D = Math.min(Number(r) * A, D)), D = Math.max(D, A);
      const F = D + (P === "border-box" ? O + M : 0), j = Math.abs(D - I) <= 1;
      return {
        outerHeightStyle: F,
        overflowing: j
      };
    }, [r, o, e.placeholder]), y = Ba(() => {
      const _ = c.current, k = h();
      if (!_ || !k || EL(k))
        return !1;
      const E = k.outerHeightStyle;
      return p.current != null && p.current !== E;
    }), b = C.useCallback(() => {
      const _ = c.current, k = h();
      if (!_ || !k || EL(k))
        return;
      const E = k.outerHeightStyle;
      p.current !== E && (p.current = E, _.style.height = `${E}px`), _.style.overflow = k.overflowing ? "hidden" : "";
    }, [h]), v = C.useRef(-1);
    ta(() => {
      const _ = eU(b), k = c?.current;
      if (!k)
        return;
      const E = Ji(k);
      E.addEventListener("resize", _);
      let P;
      return typeof ResizeObserver < "u" && (P = new ResizeObserver(() => {
        y() && (P.unobserve(k), cancelAnimationFrame(v.current), b(), v.current = requestAnimationFrame(() => {
          P.observe(k);
        }));
      }), P.observe(k)), () => {
        _.clear(), cancelAnimationFrame(v.current), E.removeEventListener("resize", _), P && P.disconnect();
      };
    }, [h, b, y]), ta(() => {
      b();
    });
    const w = (_) => {
      u || b();
      const k = _.target, E = k.value.length, P = k.value.endsWith(`
`), O = k.selectionStart === E;
      P && O && k.setSelectionRange(E, E), n && n(_);
    };
    return /* @__PURE__ */ S.jsxs(C.Fragment, {
      children: [/* @__PURE__ */ S.jsx("textarea", {
        value: i,
        onChange: w,
        ref: f,
        rows: o,
        style: a,
        ...s
      }), /* @__PURE__ */ S.jsx("textarea", {
        "aria-hidden": !0,
        className: e.className,
        readOnly: !0,
        ref: g,
        tabIndex: -1,
        style: {
          ...PMe.shadow,
          ...a,
          paddingTop: 0,
          paddingBottom: 0
        }
      })]
    });
  });
  function vl({
    props: e,
    states: t,
    muiFormControl: n
  }) {
    return t.reduce((r, o) => (r[o] = e[o], n && typeof e[o] > "u" && (r[o] = n[o]), r), {});
  }
  const kO = /* @__PURE__ */ C.createContext(void 0);
  function ni() {
    return C.useContext(kO);
  }
  function CL(e) {
    return e != null && !(Array.isArray(e) && e.length === 0);
  }
  function Bb(e, t = !1) {
    return e && (CL(e.value) && e.value !== "" || t && CL(e.defaultValue) && e.defaultValue !== "");
  }
  function MMe(e) {
    return e.startAdornment;
  }
  function RMe(e) {
    return rt("MuiInputBase", e);
  }
  const Md = tt("MuiInputBase", ["root", "formControl", "focused", "disabled", "adornedStart", "adornedEnd", "error", "sizeSmall", "multiline", "colorSecondary", "fullWidth", "hiddenLabel", "readOnly", "input", "inputSizeSmall", "inputMultiline", "inputTypeSearch", "inputAdornedStart", "inputAdornedEnd", "inputHiddenLabel"]);
  var PL;
  const Px = (e, t) => {
    const {
      ownerState: n
    } = e;
    return [t.root, n.formControl && t.formControl, n.startAdornment && t.adornedStart, n.endAdornment && t.adornedEnd, n.error && t.error, n.size === "small" && t.sizeSmall, n.multiline && t.multiline, n.color && t[`color${$e(n.color)}`], n.fullWidth && t.fullWidth, n.hiddenLabel && t.hiddenLabel];
  }, Ox = (e, t) => {
    const {
      ownerState: n
    } = e;
    return [t.input, n.size === "small" && t.inputSizeSmall, n.multiline && t.inputMultiline, n.type === "search" && t.inputTypeSearch, n.startAdornment && t.inputAdornedStart, n.endAdornment && t.inputAdornedEnd, n.hiddenLabel && t.inputHiddenLabel];
  }, jMe = (e) => {
    const {
      classes: t,
      color: n,
      disabled: r,
      error: o,
      endAdornment: a,
      focused: i,
      formControl: s,
      fullWidth: u,
      hiddenLabel: c,
      multiline: f,
      readOnly: p,
      size: g,
      startAdornment: h,
      type: y
    } = e, b = {
      root: ["root", `color${$e(n)}`, r && "disabled", o && "error", u && "fullWidth", i && "focused", s && "formControl", g && g !== "medium" && `size${$e(g)}`, f && "multiline", h && "adornedStart", a && "adornedEnd", c && "hiddenLabel", p && "readOnly"],
      input: ["input", r && "disabled", y === "search" && "inputTypeSearch", f && "inputMultiline", g === "small" && "inputSizeSmall", c && "inputHiddenLabel", h && "inputAdornedStart", a && "inputAdornedEnd", p && "readOnly"]
    };
    return nt(b, RMe, t);
  }, Nx = Me("div", {
    name: "MuiInputBase",
    slot: "Root",
    overridesResolver: Px
  })(at(({
    theme: e
  }) => ({
    ...e.typography.body1,
    color: (e.vars || e).palette.text.primary,
    lineHeight: "1.4375em",
    // 23px
    boxSizing: "border-box",
    // Prevent padding issue with fullWidth.
    position: "relative",
    cursor: "text",
    display: "inline-flex",
    alignItems: "center",
    [`&.${Md.disabled}`]: {
      color: (e.vars || e).palette.text.disabled,
      cursor: "default"
    },
    variants: [{
      props: ({
        ownerState: t
      }) => t.multiline,
      style: {
        padding: "4px 0 5px"
      }
    }, {
      props: ({
        ownerState: t,
        size: n
      }) => t.multiline && n === "small",
      style: {
        paddingTop: 1
      }
    }, {
      props: ({
        ownerState: t
      }) => t.fullWidth,
      style: {
        width: "100%"
      }
    }]
  }))), Mx = Me("input", {
    name: "MuiInputBase",
    slot: "Input",
    overridesResolver: Ox
  })(at(({
    theme: e
  }) => {
    const t = e.palette.mode === "light", n = {
      color: "currentColor",
      ...e.vars ? {
        opacity: e.vars.opacity.inputPlaceholder
      } : {
        opacity: t ? 0.42 : 0.5
      },
      transition: e.transitions.create("opacity", {
        duration: e.transitions.duration.shorter
      })
    }, r = {
      opacity: "0 !important"
    }, o = e.vars ? {
      opacity: e.vars.opacity.inputPlaceholder
    } : {
      opacity: t ? 0.42 : 0.5
    };
    return {
      font: "inherit",
      letterSpacing: "inherit",
      color: "currentColor",
      padding: "4px 0 5px",
      border: 0,
      boxSizing: "content-box",
      background: "none",
      height: "1.4375em",
      // Reset 23pxthe native input line-height
      margin: 0,
      // Reset for Safari
      WebkitTapHighlightColor: "transparent",
      display: "block",
      // Make the flex item shrink with Firefox
      minWidth: 0,
      width: "100%",
      "&::-webkit-input-placeholder": n,
      "&::-moz-placeholder": n,
      // Firefox 19+
      "&::-ms-input-placeholder": n,
      // Edge
      "&:focus": {
        outline: 0
      },
      // Reset Firefox invalid required input style
      "&:invalid": {
        boxShadow: "none"
      },
      "&::-webkit-search-decoration": {
        // Remove the padding when type=search.
        WebkitAppearance: "none"
      },
      // Show and hide the placeholder logic
      [`label[data-shrink=false] + .${Md.formControl} &`]: {
        "&::-webkit-input-placeholder": r,
        "&::-moz-placeholder": r,
        // Firefox 19+
        "&::-ms-input-placeholder": r,
        // Edge
        "&:focus::-webkit-input-placeholder": o,
        "&:focus::-moz-placeholder": o,
        // Firefox 19+
        "&:focus::-ms-input-placeholder": o
        // Edge
      },
      [`&.${Md.disabled}`]: {
        opacity: 1,
        // Reset iOS opacity
        WebkitTextFillColor: (e.vars || e).palette.text.disabled
        // Fix opacity Safari bug
      },
      variants: [{
        props: ({
          ownerState: a
        }) => !a.disableInjectingGlobalStyles,
        style: {
          animationName: "mui-auto-fill-cancel",
          animationDuration: "10ms",
          "&:-webkit-autofill": {
            animationDuration: "5000s",
            animationName: "mui-auto-fill"
          }
        }
      }, {
        props: {
          size: "small"
        },
        style: {
          paddingTop: 1
        }
      }, {
        props: ({
          ownerState: a
        }) => a.multiline,
        style: {
          height: "auto",
          resize: "none",
          padding: 0,
          paddingTop: 0
        }
      }, {
        props: {
          type: "search"
        },
        style: {
          MozAppearance: "textfield"
          // Improve type search style.
        }
      }]
    };
  })), OL = sQ({
    "@keyframes mui-auto-fill": {
      from: {
        display: "block"
      }
    },
    "@keyframes mui-auto-fill-cancel": {
      from: {
        display: "block"
      }
    }
  }), SO = /* @__PURE__ */ C.forwardRef(function(e, t) {
    const n = lt({
      props: e,
      name: "MuiInputBase"
    }), {
      "aria-describedby": r,
      autoComplete: o,
      autoFocus: a,
      className: i,
      color: s,
      components: u = {},
      componentsProps: c = {},
      defaultValue: f,
      disabled: p,
      disableInjectingGlobalStyles: g,
      endAdornment: h,
      error: y,
      fullWidth: b = !1,
      id: v,
      inputComponent: w = "input",
      inputProps: _ = {},
      inputRef: k,
      margin: E,
      maxRows: P,
      minRows: O,
      multiline: M = !1,
      name: I,
      onBlur: A,
      onChange: D,
      onClick: F,
      onFocus: j,
      onKeyDown: U,
      onKeyUp: $,
      placeholder: q,
      readOnly: B,
      renderSuffix: G,
      rows: W,
      size: Y,
      slotProps: z = {},
      slots: L = {},
      startAdornment: K,
      type: T = "text",
      value: V,
      ...X
    } = n, Q = _.value != null ? _.value : V, {
      current: ne
    } = C.useRef(Q != null), te = C.useRef(), ae = C.useCallback((Ae) => {
    }, []), ce = Zn(te, k, _.ref, ae), [Z, ee] = C.useState(!1), oe = ni(), le = vl({
      props: n,
      muiFormControl: oe,
      states: ["color", "disabled", "error", "hiddenLabel", "size", "required", "filled"]
    });
    le.focused = oe ? oe.focused : Z, C.useEffect(() => {
      !oe && p && Z && (ee(!1), A && A());
    }, [oe, p, Z, A]);
    const be = oe && oe.onFilled, ke = oe && oe.onEmpty, De = C.useCallback((Ae) => {
      Bb(Ae) ? be && be() : ke && ke();
    }, [be, ke]);
    ta(() => {
      ne && De({
        value: Q
      });
    }, [Q, De, ne]);
    const ze = (Ae) => {
      j && j(Ae), _.onFocus && _.onFocus(Ae), oe && oe.onFocus ? oe.onFocus(Ae) : ee(!0);
    }, Ue = (Ae) => {
      A && A(Ae), _.onBlur && _.onBlur(Ae), oe && oe.onBlur ? oe.onBlur(Ae) : ee(!1);
    }, He = (Ae, ...vt) => {
      if (!ne) {
        const yt = Ae.target || te.current;
        if (yt == null)
          throw new Error(Vi(1));
        De({
          value: yt.value
        });
      }
      _.onChange && _.onChange(Ae, ...vt), D && D(Ae, ...vt);
    };
    C.useEffect(() => {
      De(te.current);
    }, []);
    const Pe = (Ae) => {
      te.current && Ae.currentTarget === Ae.target && te.current.focus(), F && F(Ae);
    };
    let It = w, Xe = _;
    M && It === "input" && (W ? Xe = {
      type: void 0,
      minRows: W,
      maxRows: W,
      ...Xe
    } : Xe = {
      type: void 0,
      maxRows: P,
      minRows: O,
      ...Xe
    }, It = NMe);
    const Ee = (Ae) => {
      De(Ae.animationName === "mui-auto-fill-cancel" ? te.current : {
        value: "x"
      });
    };
    C.useEffect(() => {
      oe && oe.setAdornedStart(!!K);
    }, [oe, K]);
    const _e = {
      ...n,
      color: le.color || "primary",
      disabled: le.disabled,
      endAdornment: h,
      error: le.error,
      focused: le.focused,
      formControl: oe,
      fullWidth: b,
      hiddenLabel: le.hiddenLabel,
      multiline: M,
      size: le.size,
      startAdornment: K,
      type: T
    }, ie = jMe(_e), me = L.root || u.Root || Nx, Se = z.root || c.root || {}, je = L.input || u.Input || Mx;
    return Xe = {
      ...Xe,
      ...z.input ?? c.input
    }, /* @__PURE__ */ S.jsxs(C.Fragment, {
      children: [!g && typeof OL == "function" && // For Emotion/Styled-components, InputGlobalStyles will be a function
      // For Pigment CSS, this has no effect because the InputGlobalStyles will be null.
      (PL || (PL = /* @__PURE__ */ S.jsx(OL, {}))), /* @__PURE__ */ S.jsxs(me, {
        ...Se,
        ref: t,
        onClick: Pe,
        ...X,
        ...!Va(me) && {
          ownerState: {
            ..._e,
            ...Se.ownerState
          }
        },
        className: Le(ie.root, Se.className, i, B && "MuiInputBase-readOnly"),
        children: [K, /* @__PURE__ */ S.jsx(kO.Provider, {
          value: null,
          children: /* @__PURE__ */ S.jsx(je, {
            "aria-invalid": le.error,
            "aria-describedby": r,
            autoComplete: o,
            autoFocus: a,
            defaultValue: f,
            disabled: le.disabled,
            id: v,
            onAnimationStart: Ee,
            name: I,
            placeholder: q,
            readOnly: B,
            required: le.required,
            rows: W,
            value: Q,
            onKeyDown: U,
            onKeyUp: $,
            type: T,
            ...Xe,
            ...!Va(je) && {
              as: It,
              ownerState: {
                ..._e,
                ...Xe.ownerState
              }
            },
            ref: ce,
            className: Le(ie.input, Xe.className, B && "MuiInputBase-readOnly"),
            onBlur: Ue,
            onChange: He,
            onFocus: ze
          })
        }), h, G ? G({
          ...le,
          startAdornment: K
        }) : null]
      })]
    });
  });
  function IMe(e) {
    return rt("MuiInput", e);
  }
  const ap = {
    ...Md,
    ...tt("MuiInput", ["root", "underline", "input"])
  }, AMe = (e) => {
    const {
      classes: t,
      disableUnderline: n
    } = e, r = nt({
      root: ["root", !n && "underline"],
      input: ["input"]
    }, IMe, t);
    return {
      ...t,
      // forward classes to the InputBase
      ...r
    };
  }, $Me = Me(Nx, {
    shouldForwardProp: (e) => kr(e) || e === "classes",
    name: "MuiInput",
    slot: "Root",
    overridesResolver: (e, t) => {
      const {
        ownerState: n
      } = e;
      return [...Px(e, t), !n.disableUnderline && t.underline];
    }
  })(at(({
    theme: e
  }) => {
    let t = e.palette.mode === "light" ? "rgba(0, 0, 0, 0.42)" : "rgba(255, 255, 255, 0.7)";
    return e.vars && (t = e.alpha(e.vars.palette.common.onBackground, e.vars.opacity.inputUnderline)), {
      position: "relative",
      variants: [{
        props: ({
          ownerState: n
        }) => n.formControl,
        style: {
          "label + &": {
            marginTop: 16
          }
        }
      }, {
        props: ({
          ownerState: n
        }) => !n.disableUnderline,
        style: {
          "&::after": {
            left: 0,
            bottom: 0,
            content: '""',
            position: "absolute",
            right: 0,
            transform: "scaleX(0)",
            transition: e.transitions.create("transform", {
              duration: e.transitions.duration.shorter,
              easing: e.transitions.easing.easeOut
            }),
            pointerEvents: "none"
            // Transparent to the hover style.
          },
          [`&.${ap.focused}:after`]: {
            // translateX(0) is a workaround for Safari transform scale bug
            // See https://github.com/mui/material-ui/issues/31766
            transform: "scaleX(1) translateX(0)"
          },
          [`&.${ap.error}`]: {
            "&::before, &::after": {
              borderBottomColor: (e.vars || e).palette.error.main
            }
          },
          "&::before": {
            borderBottom: `1px solid ${t}`,
            left: 0,
            bottom: 0,
            content: '"\\00a0"',
            position: "absolute",
            right: 0,
            transition: e.transitions.create("border-bottom-color", {
              duration: e.transitions.duration.shorter
            }),
            pointerEvents: "none"
            // Transparent to the hover style.
          },
          [`&:hover:not(.${ap.disabled}, .${ap.error}):before`]: {
            borderBottom: `2px solid ${(e.vars || e).palette.text.primary}`,
            // Reset on touch devices, it doesn't add specificity
            "@media (hover: none)": {
              borderBottom: `1px solid ${t}`
            }
          },
          [`&.${ap.disabled}:before`]: {
            borderBottomStyle: "dotted"
          }
        }
      }, ...Object.entries(e.palette).filter(xr()).map(([n]) => ({
        props: {
          color: n,
          disableUnderline: !1
        },
        style: {
          "&::after": {
            borderBottom: `2px solid ${(e.vars || e).palette[n].main}`
          }
        }
      }))]
    };
  })), DMe = Me(Mx, {
    name: "MuiInput",
    slot: "Input",
    overridesResolver: Ox
  })({}), _O = /* @__PURE__ */ C.forwardRef(function(e, t) {
    const n = lt({
      props: e,
      name: "MuiInput"
    }), {
      disableUnderline: r = !1,
      components: o = {},
      componentsProps: a,
      fullWidth: i = !1,
      inputComponent: s = "input",
      multiline: u = !1,
      slotProps: c,
      slots: f = {},
      type: p = "text",
      ...g
    } = n, h = AMe(n), y = {
      root: {
        ownerState: {
          disableUnderline: r
        }
      }
    }, b = c ?? a ? wr(c ?? a, y) : y, v = f.root ?? o.Root ?? $Me, w = f.input ?? o.Input ?? DMe;
    return /* @__PURE__ */ S.jsx(SO, {
      slots: {
        root: v,
        input: w
      },
      slotProps: b,
      fullWidth: i,
      inputComponent: s,
      multiline: u,
      ref: t,
      type: p,
      ...g,
      classes: h
    });
  });
  _O.muiName = "Input";
  function LMe(e) {
    return rt("MuiFilledInput", e);
  }
  const Hl = {
    ...Md,
    ...tt("MuiFilledInput", ["root", "underline", "input", "adornedStart", "adornedEnd", "sizeSmall", "multiline", "hiddenLabel"])
  }, FMe = (e) => {
    const {
      classes: t,
      disableUnderline: n,
      startAdornment: r,
      endAdornment: o,
      size: a,
      hiddenLabel: i,
      multiline: s
    } = e, u = {
      root: ["root", !n && "underline", r && "adornedStart", o && "adornedEnd", a === "small" && `size${$e(a)}`, i && "hiddenLabel", s && "multiline"],
      input: ["input"]
    }, c = nt(u, LMe, t);
    return {
      ...t,
      // forward classes to the InputBase
      ...c
    };
  }, TMe = Me(Nx, {
    shouldForwardProp: (e) => kr(e) || e === "classes",
    name: "MuiFilledInput",
    slot: "Root",
    overridesResolver: (e, t) => {
      const {
        ownerState: n
      } = e;
      return [...Px(e, t), !n.disableUnderline && t.underline];
    }
  })(at(({
    theme: e
  }) => {
    const t = e.palette.mode === "light", n = t ? "rgba(0, 0, 0, 0.42)" : "rgba(255, 255, 255, 0.7)", r = t ? "rgba(0, 0, 0, 0.06)" : "rgba(255, 255, 255, 0.09)", o = t ? "rgba(0, 0, 0, 0.09)" : "rgba(255, 255, 255, 0.13)", a = t ? "rgba(0, 0, 0, 0.12)" : "rgba(255, 255, 255, 0.12)";
    return {
      position: "relative",
      backgroundColor: e.vars ? e.vars.palette.FilledInput.bg : r,
      borderTopLeftRadius: (e.vars || e).shape.borderRadius,
      borderTopRightRadius: (e.vars || e).shape.borderRadius,
      transition: e.transitions.create("background-color", {
        duration: e.transitions.duration.shorter,
        easing: e.transitions.easing.easeOut
      }),
      "&:hover": {
        backgroundColor: e.vars ? e.vars.palette.FilledInput.hoverBg : o,
        // Reset on touch devices, it doesn't add specificity
        "@media (hover: none)": {
          backgroundColor: e.vars ? e.vars.palette.FilledInput.bg : r
        }
      },
      [`&.${Hl.focused}`]: {
        backgroundColor: e.vars ? e.vars.palette.FilledInput.bg : r
      },
      [`&.${Hl.disabled}`]: {
        backgroundColor: e.vars ? e.vars.palette.FilledInput.disabledBg : a
      },
      variants: [{
        props: ({
          ownerState: i
        }) => !i.disableUnderline,
        style: {
          "&::after": {
            left: 0,
            bottom: 0,
            content: '""',
            position: "absolute",
            right: 0,
            transform: "scaleX(0)",
            transition: e.transitions.create("transform", {
              duration: e.transitions.duration.shorter,
              easing: e.transitions.easing.easeOut
            }),
            pointerEvents: "none"
            // Transparent to the hover style.
          },
          [`&.${Hl.focused}:after`]: {
            // translateX(0) is a workaround for Safari transform scale bug
            // See https://github.com/mui/material-ui/issues/31766
            transform: "scaleX(1) translateX(0)"
          },
          [`&.${Hl.error}`]: {
            "&::before, &::after": {
              borderBottomColor: (e.vars || e).palette.error.main
            }
          },
          "&::before": {
            borderBottom: `1px solid ${e.vars ? e.alpha(e.vars.palette.common.onBackground, e.vars.opacity.inputUnderline) : n}`,
            left: 0,
            bottom: 0,
            content: '"\\00a0"',
            position: "absolute",
            right: 0,
            transition: e.transitions.create("border-bottom-color", {
              duration: e.transitions.duration.shorter
            }),
            pointerEvents: "none"
            // Transparent to the hover style.
          },
          [`&:hover:not(.${Hl.disabled}, .${Hl.error}):before`]: {
            borderBottom: `1px solid ${(e.vars || e).palette.text.primary}`
          },
          [`&.${Hl.disabled}:before`]: {
            borderBottomStyle: "dotted"
          }
        }
      }, ...Object.entries(e.palette).filter(xr()).map(([i]) => ({
        props: {
          disableUnderline: !1,
          color: i
        },
        style: {
          "&::after": {
            borderBottom: `2px solid ${(e.vars || e).palette[i]?.main}`
          }
        }
      })), {
        props: ({
          ownerState: i
        }) => i.startAdornment,
        style: {
          paddingLeft: 12
        }
      }, {
        props: ({
          ownerState: i
        }) => i.endAdornment,
        style: {
          paddingRight: 12
        }
      }, {
        props: ({
          ownerState: i
        }) => i.multiline,
        style: {
          padding: "25px 12px 8px"
        }
      }, {
        props: ({
          ownerState: i,
          size: s
        }) => i.multiline && s === "small",
        style: {
          paddingTop: 21,
          paddingBottom: 4
        }
      }, {
        props: ({
          ownerState: i
        }) => i.multiline && i.hiddenLabel,
        style: {
          paddingTop: 16,
          paddingBottom: 17
        }
      }, {
        props: ({
          ownerState: i
        }) => i.multiline && i.hiddenLabel && i.size === "small",
        style: {
          paddingTop: 8,
          paddingBottom: 9
        }
      }]
    };
  })), zMe = Me(Mx, {
    name: "MuiFilledInput",
    slot: "Input",
    overridesResolver: Ox
  })(at(({
    theme: e
  }) => ({
    paddingTop: 25,
    paddingRight: 12,
    paddingBottom: 8,
    paddingLeft: 12,
    ...!e.vars && {
      "&:-webkit-autofill": {
        WebkitBoxShadow: e.palette.mode === "light" ? null : "0 0 0 100px #266798 inset",
        WebkitTextFillColor: e.palette.mode === "light" ? null : "#fff",
        caretColor: e.palette.mode === "light" ? null : "#fff",
        borderTopLeftRadius: "inherit",
        borderTopRightRadius: "inherit"
      }
    },
    ...e.vars && {
      "&:-webkit-autofill": {
        borderTopLeftRadius: "inherit",
        borderTopRightRadius: "inherit"
      },
      [e.getColorSchemeSelector("dark")]: {
        "&:-webkit-autofill": {
          WebkitBoxShadow: "0 0 0 100px #266798 inset",
          WebkitTextFillColor: "#fff",
          caretColor: "#fff"
        }
      }
    },
    variants: [{
      props: {
        size: "small"
      },
      style: {
        paddingTop: 21,
        paddingBottom: 4
      }
    }, {
      props: ({
        ownerState: t
      }) => t.hiddenLabel,
      style: {
        paddingTop: 16,
        paddingBottom: 17
      }
    }, {
      props: ({
        ownerState: t
      }) => t.startAdornment,
      style: {
        paddingLeft: 0
      }
    }, {
      props: ({
        ownerState: t
      }) => t.endAdornment,
      style: {
        paddingRight: 0
      }
    }, {
      props: ({
        ownerState: t
      }) => t.hiddenLabel && t.size === "small",
      style: {
        paddingTop: 8,
        paddingBottom: 9
      }
    }, {
      props: ({
        ownerState: t
      }) => t.multiline,
      style: {
        paddingTop: 0,
        paddingBottom: 0,
        paddingLeft: 0,
        paddingRight: 0
      }
    }]
  }))), EO = /* @__PURE__ */ C.forwardRef(function(e, t) {
    const n = lt({
      props: e,
      name: "MuiFilledInput"
    }), {
      disableUnderline: r = !1,
      components: o = {},
      componentsProps: a,
      fullWidth: i = !1,
      hiddenLabel: s,
      // declare here to prevent spreading to DOM
      inputComponent: u = "input",
      multiline: c = !1,
      slotProps: f,
      slots: p = {},
      type: g = "text",
      ...h
    } = n, y = {
      ...n,
      disableUnderline: r,
      fullWidth: i,
      inputComponent: u,
      multiline: c,
      type: g
    }, b = FMe(n), v = {
      root: {
        ownerState: y
      },
      input: {
        ownerState: y
      }
    }, w = f ?? a ? wr(v, f ?? a) : v, _ = p.root ?? o.Root ?? TMe, k = p.input ?? o.Input ?? zMe;
    return /* @__PURE__ */ S.jsx(SO, {
      slots: {
        root: _,
        input: k
      },
      slotProps: w,
      fullWidth: i,
      inputComponent: u,
      multiline: c,
      ref: t,
      type: g,
      ...h,
      classes: b
    });
  });
  EO.muiName = "Input";
  var NL;
  const BMe = Me("fieldset", {
    name: "MuiNotchedOutlined",
    shouldForwardProp: kr
  })({
    textAlign: "left",
    position: "absolute",
    bottom: 0,
    right: 0,
    top: -5,
    left: 0,
    margin: 0,
    padding: "0 8px",
    pointerEvents: "none",
    borderRadius: "inherit",
    borderStyle: "solid",
    borderWidth: 1,
    overflow: "hidden",
    minWidth: "0%"
  }), VMe = Me("legend", {
    name: "MuiNotchedOutlined",
    shouldForwardProp: kr
  })(at(({
    theme: e
  }) => ({
    float: "unset",
    // Fix conflict with bootstrap
    width: "auto",
    // Fix conflict with bootstrap
    overflow: "hidden",
    // Fix Horizontal scroll when label too long
    variants: [{
      props: ({
        ownerState: t
      }) => !t.withLabel,
      style: {
        padding: 0,
        lineHeight: "11px",
        // sync with `height` in `legend` styles
        transition: e.transitions.create("width", {
          duration: 150,
          easing: e.transitions.easing.easeOut
        })
      }
    }, {
      props: ({
        ownerState: t
      }) => t.withLabel,
      style: {
        display: "block",
        // Fix conflict with normalize.css and sanitize.css
        padding: 0,
        height: 11,
        // sync with `lineHeight` in `legend` styles
        fontSize: "0.75em",
        visibility: "hidden",
        maxWidth: 0.01,
        transition: e.transitions.create("max-width", {
          duration: 50,
          easing: e.transitions.easing.easeOut
        }),
        whiteSpace: "nowrap",
        "& > span": {
          paddingLeft: 5,
          paddingRight: 5,
          display: "inline-block",
          opacity: 0,
          visibility: "visible"
        }
      }
    }, {
      props: ({
        ownerState: t
      }) => t.withLabel && t.notched,
      style: {
        maxWidth: "100%",
        transition: e.transitions.create("max-width", {
          duration: 100,
          easing: e.transitions.easing.easeOut,
          delay: 50
        })
      }
    }]
  })));
  function UMe(e) {
    const {
      children: t,
      classes: n,
      className: r,
      label: o,
      notched: a,
      ...i
    } = e, s = o != null && o !== "", u = {
      ...e,
      notched: a,
      withLabel: s
    };
    return /* @__PURE__ */ S.jsx(BMe, {
      "aria-hidden": !0,
      className: r,
      ownerState: u,
      ...i,
      children: /* @__PURE__ */ S.jsx(VMe, {
        ownerState: u,
        children: s ? /* @__PURE__ */ S.jsx("span", {
          children: o
        }) : (
          // notranslate needed while Google Translate will not fix zero-width space issue
          NL || (NL = /* @__PURE__ */ S.jsx("span", {
            className: "notranslate",
            "aria-hidden": !0,
            children: ""
          }))
        )
      })
    });
  }
  function HMe(e) {
    return rt("MuiOutlinedInput", e);
  }
  const ba = {
    ...Md,
    ...tt("MuiOutlinedInput", ["root", "notchedOutline", "input"])
  }, WMe = (e) => {
    const {
      classes: t
    } = e, n = nt({
      root: ["root"],
      notchedOutline: ["notchedOutline"],
      input: ["input"]
    }, HMe, t);
    return {
      ...t,
      // forward classes to the InputBase
      ...n
    };
  }, qMe = Me(Nx, {
    shouldForwardProp: (e) => kr(e) || e === "classes",
    name: "MuiOutlinedInput",
    slot: "Root",
    overridesResolver: Px
  })(at(({
    theme: e
  }) => {
    const t = e.palette.mode === "light" ? "rgba(0, 0, 0, 0.23)" : "rgba(255, 255, 255, 0.23)";
    return {
      position: "relative",
      borderRadius: (e.vars || e).shape.borderRadius,
      [`&:hover .${ba.notchedOutline}`]: {
        borderColor: (e.vars || e).palette.text.primary
      },
      // Reset on touch devices, it doesn't add specificity
      "@media (hover: none)": {
        [`&:hover .${ba.notchedOutline}`]: {
          borderColor: e.vars ? e.alpha(e.vars.palette.common.onBackground, 0.23) : t
        }
      },
      [`&.${ba.focused} .${ba.notchedOutline}`]: {
        borderWidth: 2
      },
      variants: [...Object.entries(e.palette).filter(xr()).map(([n]) => ({
        props: {
          color: n
        },
        style: {
          [`&.${ba.focused} .${ba.notchedOutline}`]: {
            borderColor: (e.vars || e).palette[n].main
          }
        }
      })), {
        props: {},
        // to override the above style
        style: {
          [`&.${ba.error} .${ba.notchedOutline}`]: {
            borderColor: (e.vars || e).palette.error.main
          },
          [`&.${ba.disabled} .${ba.notchedOutline}`]: {
            borderColor: (e.vars || e).palette.action.disabled
          }
        }
      }, {
        props: ({
          ownerState: n
        }) => n.startAdornment,
        style: {
          paddingLeft: 14
        }
      }, {
        props: ({
          ownerState: n
        }) => n.endAdornment,
        style: {
          paddingRight: 14
        }
      }, {
        props: ({
          ownerState: n
        }) => n.multiline,
        style: {
          padding: "16.5px 14px"
        }
      }, {
        props: ({
          ownerState: n,
          size: r
        }) => n.multiline && r === "small",
        style: {
          padding: "8.5px 14px"
        }
      }]
    };
  })), KMe = Me(UMe, {
    name: "MuiOutlinedInput",
    slot: "NotchedOutline"
  })(at(({
    theme: e
  }) => {
    const t = e.palette.mode === "light" ? "rgba(0, 0, 0, 0.23)" : "rgba(255, 255, 255, 0.23)";
    return {
      borderColor: e.vars ? e.alpha(e.vars.palette.common.onBackground, 0.23) : t
    };
  })), GMe = Me(Mx, {
    name: "MuiOutlinedInput",
    slot: "Input",
    overridesResolver: Ox
  })(at(({
    theme: e
  }) => ({
    padding: "16.5px 14px",
    ...!e.vars && {
      "&:-webkit-autofill": {
        WebkitBoxShadow: e.palette.mode === "light" ? null : "0 0 0 100px #266798 inset",
        WebkitTextFillColor: e.palette.mode === "light" ? null : "#fff",
        caretColor: e.palette.mode === "light" ? null : "#fff",
        borderRadius: "inherit"
      }
    },
    ...e.vars && {
      "&:-webkit-autofill": {
        borderRadius: "inherit"
      },
      [e.getColorSchemeSelector("dark")]: {
        "&:-webkit-autofill": {
          WebkitBoxShadow: "0 0 0 100px #266798 inset",
          WebkitTextFillColor: "#fff",
          caretColor: "#fff"
        }
      }
    },
    variants: [{
      props: {
        size: "small"
      },
      style: {
        padding: "8.5px 14px"
      }
    }, {
      props: ({
        ownerState: t
      }) => t.multiline,
      style: {
        padding: 0
      }
    }, {
      props: ({
        ownerState: t
      }) => t.startAdornment,
      style: {
        paddingLeft: 0
      }
    }, {
      props: ({
        ownerState: t
      }) => t.endAdornment,
      style: {
        paddingRight: 0
      }
    }]
  }))), CO = /* @__PURE__ */ C.forwardRef(function(e, t) {
    const n = lt({
      props: e,
      name: "MuiOutlinedInput"
    }), {
      components: r = {},
      fullWidth: o = !1,
      inputComponent: a = "input",
      label: i,
      multiline: s = !1,
      notched: u,
      slots: c = {},
      slotProps: f = {},
      type: p = "text",
      ...g
    } = n, h = WMe(n), y = ni(), b = vl({
      props: n,
      muiFormControl: y,
      states: ["color", "disabled", "error", "focused", "hiddenLabel", "size", "required"]
    }), v = {
      ...n,
      color: b.color || "primary",
      disabled: b.disabled,
      error: b.error,
      focused: b.focused,
      formControl: y,
      fullWidth: o,
      hiddenLabel: b.hiddenLabel,
      multiline: s,
      size: b.size,
      type: p
    }, w = c.root ?? r.Root ?? qMe, _ = c.input ?? r.Input ?? GMe, [k, E] = sn("notchedOutline", {
      elementType: KMe,
      className: h.notchedOutline,
      shouldForwardComponentProp: !0,
      ownerState: v,
      externalForwardedProps: {
        slots: c,
        slotProps: f
      },
      additionalProps: {
        label: i != null && i !== "" && b.required ? /* @__PURE__ */ S.jsxs(C.Fragment, {
          children: [i, "", "*"]
        }) : i
      }
    });
    return /* @__PURE__ */ S.jsx(SO, {
      slots: {
        root: w,
        input: _
      },
      slotProps: f,
      renderSuffix: (P) => /* @__PURE__ */ S.jsx(k, {
        ...E,
        notched: typeof u < "u" ? u : !!(P.startAdornment || P.filled || P.focused)
      }),
      fullWidth: o,
      inputComponent: a,
      multiline: s,
      ref: t,
      type: p,
      ...g,
      classes: {
        ...h,
        notchedOutline: null
      }
    });
  });
  CO.muiName = "Input";
  function XMe(e) {
    return rt("MuiFormLabel", e);
  }
  const zp = tt("MuiFormLabel", ["root", "colorSecondary", "focused", "disabled", "error", "filled", "required", "asterisk"]), YMe = (e) => {
    const {
      classes: t,
      color: n,
      focused: r,
      disabled: o,
      error: a,
      filled: i,
      required: s
    } = e, u = {
      root: ["root", `color${$e(n)}`, o && "disabled", a && "error", i && "filled", r && "focused", s && "required"],
      asterisk: ["asterisk", a && "error"]
    };
    return nt(u, XMe, t);
  }, JMe = Me("label", {
    name: "MuiFormLabel",
    slot: "Root",
    overridesResolver: (e, t) => {
      const {
        ownerState: n
      } = e;
      return [t.root, n.color === "secondary" && t.colorSecondary, n.filled && t.filled];
    }
  })(at(({
    theme: e
  }) => ({
    color: (e.vars || e).palette.text.secondary,
    ...e.typography.body1,
    lineHeight: "1.4375em",
    padding: 0,
    position: "relative",
    variants: [...Object.entries(e.palette).filter(xr()).map(([t]) => ({
      props: {
        color: t
      },
      style: {
        [`&.${zp.focused}`]: {
          color: (e.vars || e).palette[t].main
        }
      }
    })), {
      props: {},
      style: {
        [`&.${zp.disabled}`]: {
          color: (e.vars || e).palette.text.disabled
        },
        [`&.${zp.error}`]: {
          color: (e.vars || e).palette.error.main
        }
      }
    }]
  }))), QMe = Me("span", {
    name: "MuiFormLabel",
    slot: "Asterisk"
  })(at(({
    theme: e
  }) => ({
    [`&.${zp.error}`]: {
      color: (e.vars || e).palette.error.main
    }
  }))), Rx = /* @__PURE__ */ C.forwardRef(function(e, t) {
    const n = lt({
      props: e,
      name: "MuiFormLabel"
    }), {
      children: r,
      className: o,
      color: a,
      component: i = "label",
      disabled: s,
      error: u,
      filled: c,
      focused: f,
      required: p,
      ...g
    } = n, h = ni(), y = vl({
      props: n,
      muiFormControl: h,
      states: ["color", "required", "focused", "disabled", "error", "filled"]
    }), b = {
      ...n,
      color: y.color || "primary",
      component: i,
      disabled: y.disabled,
      error: y.error,
      filled: y.filled,
      focused: y.focused,
      required: y.required
    }, v = YMe(b);
    return /* @__PURE__ */ S.jsxs(JMe, {
      as: i,
      ownerState: b,
      className: Le(v.root, o),
      ref: t,
      ...g,
      children: [r, y.required && /* @__PURE__ */ S.jsxs(QMe, {
        ownerState: b,
        "aria-hidden": !0,
        className: v.asterisk,
        children: ["", "*"]
      })]
    });
  });
  function ZMe(e) {
    return rt("MuiInputLabel", e);
  }
  tt("MuiInputLabel", ["root", "focused", "disabled", "error", "required", "asterisk", "formControl", "sizeSmall", "shrink", "animated", "standard", "filled", "outlined"]);
  const eRe = (e) => {
    const {
      classes: t,
      formControl: n,
      size: r,
      shrink: o,
      disableAnimation: a,
      variant: i,
      required: s
    } = e, u = {
      root: ["root", n && "formControl", !a && "animated", o && "shrink", r && r !== "medium" && `size${$e(r)}`, i],
      asterisk: [s && "asterisk"]
    }, c = nt(u, ZMe, t);
    return {
      ...t,
      // forward the focused, disabled, etc. classes to the FormLabel
      ...c
    };
  }, tRe = Me(Rx, {
    shouldForwardProp: (e) => kr(e) || e === "classes",
    name: "MuiInputLabel",
    slot: "Root",
    overridesResolver: (e, t) => {
      const {
        ownerState: n
      } = e;
      return [{
        [`& .${zp.asterisk}`]: t.asterisk
      }, t.root, n.formControl && t.formControl, n.size === "small" && t.sizeSmall, n.shrink && t.shrink, !n.disableAnimation && t.animated, n.focused && t.focused, t[n.variant]];
    }
  })(at(({
    theme: e
  }) => ({
    display: "block",
    transformOrigin: "top left",
    whiteSpace: "nowrap",
    overflow: "hidden",
    textOverflow: "ellipsis",
    maxWidth: "100%",
    variants: [{
      props: ({
        ownerState: t
      }) => t.formControl,
      style: {
        position: "absolute",
        left: 0,
        top: 0,
        // slight alteration to spec spacing to match visual spec result
        transform: "translate(0, 20px) scale(1)"
      }
    }, {
      props: {
        size: "small"
      },
      style: {
        // Compensation for the `Input.inputSizeSmall` style.
        transform: "translate(0, 17px) scale(1)"
      }
    }, {
      props: ({
        ownerState: t
      }) => t.shrink,
      style: {
        transform: "translate(0, -1.5px) scale(0.75)",
        transformOrigin: "top left",
        maxWidth: "133%"
      }
    }, {
      props: ({
        ownerState: t
      }) => !t.disableAnimation,
      style: {
        transition: e.transitions.create(["color", "transform", "max-width"], {
          duration: e.transitions.duration.shorter,
          easing: e.transitions.easing.easeOut
        })
      }
    }, {
      props: {
        variant: "filled"
      },
      style: {
        // Chrome's autofill feature gives the input field a yellow background.
        // Since the input field is behind the label in the HTML tree,
        // the input field is drawn last and hides the label with an opaque background color.
        // zIndex: 1 will raise the label above opaque background-colors of input.
        zIndex: 1,
        pointerEvents: "none",
        transform: "translate(12px, 16px) scale(1)",
        maxWidth: "calc(100% - 24px)"
      }
    }, {
      props: {
        variant: "filled",
        size: "small"
      },
      style: {
        transform: "translate(12px, 13px) scale(1)"
      }
    }, {
      props: ({
        variant: t,
        ownerState: n
      }) => t === "filled" && n.shrink,
      style: {
        userSelect: "none",
        pointerEvents: "auto",
        transform: "translate(12px, 7px) scale(0.75)",
        maxWidth: "calc(133% - 24px)"
      }
    }, {
      props: ({
        variant: t,
        ownerState: n,
        size: r
      }) => t === "filled" && n.shrink && r === "small",
      style: {
        transform: "translate(12px, 4px) scale(0.75)"
      }
    }, {
      props: {
        variant: "outlined"
      },
      style: {
        // see comment above on filled.zIndex
        zIndex: 1,
        pointerEvents: "none",
        transform: "translate(14px, 16px) scale(1)",
        maxWidth: "calc(100% - 24px)"
      }
    }, {
      props: {
        variant: "outlined",
        size: "small"
      },
      style: {
        transform: "translate(14px, 9px) scale(1)"
      }
    }, {
      props: ({
        variant: t,
        ownerState: n
      }) => t === "outlined" && n.shrink,
      style: {
        userSelect: "none",
        pointerEvents: "auto",
        // Theoretically, we should have (8+5)*2/0.75 = 34px
        // but it feels a better when it bleeds a bit on the left, so 32px.
        maxWidth: "calc(133% - 32px)",
        transform: "translate(14px, -9px) scale(0.75)"
      }
    }]
  }))), nRe = /* @__PURE__ */ C.forwardRef(function(e, t) {
    const n = lt({
      name: "MuiInputLabel",
      props: e
    }), {
      disableAnimation: r = !1,
      margin: o,
      shrink: a,
      variant: i,
      className: s,
      ...u
    } = n, c = ni();
    let f = a;
    typeof f > "u" && c && (f = c.filled || c.focused || c.adornedStart);
    const p = vl({
      props: n,
      muiFormControl: c,
      states: ["size", "variant", "required", "focused"]
    }), g = {
      ...n,
      disableAnimation: r,
      formControl: c,
      shrink: f,
      size: p.size,
      variant: p.variant,
      required: p.required,
      focused: p.focused
    }, h = eRe(g);
    return /* @__PURE__ */ S.jsx(tRe, {
      "data-shrink": f,
      ref: t,
      className: Le(h.root, s),
      ...u,
      ownerState: g,
      classes: h
    });
  });
  function rRe(e) {
    return rt("MuiFormControl", e);
  }
  tt("MuiFormControl", ["root", "marginNone", "marginNormal", "marginDense", "fullWidth", "disabled"]);
  const oRe = (e) => {
    const {
      classes: t,
      margin: n,
      fullWidth: r
    } = e, o = {
      root: ["root", n !== "none" && `margin${$e(n)}`, r && "fullWidth"]
    };
    return nt(o, rRe, t);
  }, aRe = Me("div", {
    name: "MuiFormControl",
    slot: "Root",
    overridesResolver: (e, t) => {
      const {
        ownerState: n
      } = e;
      return [t.root, t[`margin${$e(n.margin)}`], n.fullWidth && t.fullWidth];
    }
  })({
    display: "inline-flex",
    flexDirection: "column",
    position: "relative",
    // Reset fieldset default style.
    minWidth: 0,
    padding: 0,
    margin: 0,
    border: 0,
    verticalAlign: "top",
    // Fix alignment issue on Safari.
    variants: [{
      props: {
        margin: "normal"
      },
      style: {
        marginTop: 16,
        marginBottom: 8
      }
    }, {
      props: {
        margin: "dense"
      },
      style: {
        marginTop: 8,
        marginBottom: 4
      }
    }, {
      props: {
        fullWidth: !0
      },
      style: {
        width: "100%"
      }
    }]
  }), PO = /* @__PURE__ */ C.forwardRef(function(e, t) {
    const n = lt({
      props: e,
      name: "MuiFormControl"
    }), {
      children: r,
      className: o,
      color: a = "primary",
      component: i = "div",
      disabled: s = !1,
      error: u = !1,
      focused: c,
      fullWidth: f = !1,
      hiddenLabel: p = !1,
      margin: g = "none",
      required: h = !1,
      size: y = "medium",
      variant: b = "outlined",
      ...v
    } = n, w = {
      ...n,
      color: a,
      component: i,
      disabled: s,
      error: u,
      fullWidth: f,
      hiddenLabel: p,
      margin: g,
      required: h,
      size: y,
      variant: b
    }, _ = oRe(w), [k, E] = C.useState(() => {
      let $ = !1;
      return r && C.Children.forEach(r, (q) => {
        if (!Op(q, ["Input", "Select"]))
          return;
        const B = Op(q, ["Select"]) ? q.props.input : q;
        B && MMe(B.props) && ($ = !0);
      }), $;
    }), [P, O] = C.useState(() => {
      let $ = !1;
      return r && C.Children.forEach(r, (q) => {
        Op(q, ["Input", "Select"]) && (Bb(q.props, !0) || Bb(q.props.inputProps, !0)) && ($ = !0);
      }), $;
    }), [M, I] = C.useState(!1);
    s && M && I(!1);
    const A = c !== void 0 && !s ? c : M;
    let D;
    C.useRef(!1);
    const F = C.useCallback(() => {
      O(!0);
    }, []), j = C.useCallback(() => {
      O(!1);
    }, []), U = C.useMemo(() => ({
      adornedStart: k,
      setAdornedStart: E,
      color: a,
      disabled: s,
      error: u,
      filled: P,
      focused: A,
      fullWidth: f,
      hiddenLabel: p,
      size: y,
      onBlur: () => {
        I(!1);
      },
      onFocus: () => {
        I(!0);
      },
      onEmpty: j,
      onFilled: F,
      registerEffect: D,
      required: h,
      variant: b
    }), [k, a, s, u, P, A, f, p, D, j, F, h, y, b]);
    return /* @__PURE__ */ S.jsx(kO.Provider, {
      value: U,
      children: /* @__PURE__ */ S.jsx(aRe, {
        as: i,
        ownerState: w,
        className: Le(_.root, o),
        ref: t,
        ...v,
        children: r
      })
    });
  });
  function iRe(e) {
    return rt("MuiFormHelperText", e);
  }
  const ML = tt("MuiFormHelperText", ["root", "error", "disabled", "sizeSmall", "sizeMedium", "contained", "focused", "filled", "required"]);
  var RL;
  const sRe = (e) => {
    const {
      classes: t,
      contained: n,
      size: r,
      disabled: o,
      error: a,
      filled: i,
      focused: s,
      required: u
    } = e, c = {
      root: ["root", o && "disabled", a && "error", r && `size${$e(r)}`, n && "contained", s && "focused", i && "filled", u && "required"]
    };
    return nt(c, iRe, t);
  }, lRe = Me("p", {
    name: "MuiFormHelperText",
    slot: "Root",
    overridesResolver: (e, t) => {
      const {
        ownerState: n
      } = e;
      return [t.root, n.size && t[`size${$e(n.size)}`], n.contained && t.contained, n.filled && t.filled];
    }
  })(at(({
    theme: e
  }) => ({
    color: (e.vars || e).palette.text.secondary,
    ...e.typography.caption,
    textAlign: "left",
    marginTop: 3,
    marginRight: 0,
    marginBottom: 0,
    marginLeft: 0,
    [`&.${ML.disabled}`]: {
      color: (e.vars || e).palette.text.disabled
    },
    [`&.${ML.error}`]: {
      color: (e.vars || e).palette.error.main
    },
    variants: [{
      props: {
        size: "small"
      },
      style: {
        marginTop: 4
      }
    }, {
      props: ({
        ownerState: t
      }) => t.contained,
      style: {
        marginLeft: 14,
        marginRight: 14
      }
    }]
  }))), OO = /* @__PURE__ */ C.forwardRef(function(e, t) {
    const n = lt({
      props: e,
      name: "MuiFormHelperText"
    }), {
      children: r,
      className: o,
      component: a = "p",
      disabled: i,
      error: s,
      filled: u,
      focused: c,
      margin: f,
      required: p,
      variant: g,
      ...h
    } = n, y = ni(), b = vl({
      props: n,
      muiFormControl: y,
      states: ["variant", "size", "disabled", "error", "filled", "focused", "required"]
    }), v = {
      ...n,
      component: a,
      contained: b.variant === "filled" || b.variant === "outlined",
      variant: b.variant,
      size: b.size,
      disabled: b.disabled,
      error: b.error,
      filled: b.filled,
      focused: b.focused,
      required: b.required
    };
    delete v.ownerState;
    const w = sRe(v);
    return /* @__PURE__ */ S.jsx(lRe, {
      as: a,
      className: Le(w.root, o),
      ref: t,
      ...h,
      ownerState: v,
      children: r === " " ? (
        // notranslate needed while Google Translate will not fix zero-width space issue
        RL || (RL = /* @__PURE__ */ S.jsx("span", {
          className: "notranslate",
          "aria-hidden": !0,
          children: ""
        }))
      ) : r
    });
  });
  function gh(e) {
    return parseInt(C.version, 10) >= 19 ? e?.props?.ref || null : e?.ref || null;
  }
  function Ii(e) {
    const {
      elementType: t,
      externalSlotProps: n,
      ownerState: r,
      skipResolvingSlotProps: o = !1,
      ...a
    } = e, i = o ? {} : HT(n, r), {
      props: s,
      internalRef: u
    } = WT({
      ...a,
      externalSlotProps: i
    }), c = Zn(u, i?.ref, e.additionalProps?.ref);
    return UT(t, {
      ...s,
      ref: c
    }, r);
  }
  const Bi = /* @__PURE__ */ C.createContext({});
  function uRe(e) {
    return rt("MuiList", e);
  }
  tt("MuiList", ["root", "padding", "dense", "subheader"]);
  const cRe = (e) => {
    const {
      classes: t,
      disablePadding: n,
      dense: r,
      subheader: o
    } = e;
    return nt({
      root: ["root", !n && "padding", r && "dense", o && "subheader"]
    }, uRe, t);
  }, dRe = Me("ul", {
    name: "MuiList",
    slot: "Root",
    overridesResolver: (e, t) => {
      const {
        ownerState: n
      } = e;
      return [t.root, !n.disablePadding && t.padding, n.dense && t.dense, n.subheader && t.subheader];
    }
  })({
    listStyle: "none",
    margin: 0,
    padding: 0,
    position: "relative",
    variants: [{
      props: ({
        ownerState: e
      }) => !e.disablePadding,
      style: {
        paddingTop: 8,
        paddingBottom: 8
      }
    }, {
      props: ({
        ownerState: e
      }) => e.subheader,
      style: {
        paddingTop: 0
      }
    }]
  }), NO = /* @__PURE__ */ C.forwardRef(function(e, t) {
    const n = lt({
      props: e,
      name: "MuiList"
    }), {
      children: r,
      className: o,
      component: a = "ul",
      dense: i = !1,
      disablePadding: s = !1,
      subheader: u,
      ...c
    } = n, f = C.useMemo(() => ({
      dense: i
    }), [i]), p = {
      ...n,
      component: a,
      dense: i,
      disablePadding: s
    }, g = cRe(p);
    return /* @__PURE__ */ S.jsx(Bi.Provider, {
      value: f,
      children: /* @__PURE__ */ S.jsxs(dRe, {
        as: a,
        className: Le(g.root, o),
        ref: t,
        ownerState: p,
        ...c,
        children: [u, r]
      })
    });
  });
  function _p(e) {
    let t = e.activeElement;
    for (; t?.shadowRoot?.activeElement != null; )
      t = t.shadowRoot.activeElement;
    return t;
  }
  function aU(e = window) {
    const t = e.document.documentElement.clientWidth;
    return e.innerWidth - t;
  }
  function M0(e, t, n) {
    return e === t ? e.firstChild : t && t.nextElementSibling ? t.nextElementSibling : n ? null : e.firstChild;
  }
  function jL(e, t, n) {
    return e === t ? n ? e.firstChild : e.lastChild : t && t.previousElementSibling ? t.previousElementSibling : n ? null : e.lastChild;
  }
  function iU(e, t) {
    if (t === void 0)
      return !0;
    let n = e.innerText;
    return n === void 0 && (n = e.textContent), n = n.trim().toLowerCase(), n.length === 0 ? !1 : t.repeating ? n[0] === t.keys[0] : n.startsWith(t.keys.join(""));
  }
  function ip(e, t, n, r, o, a) {
    let i = !1, s = o(e, t, t ? n : !1);
    for (; s; ) {
      if (s === e.firstChild) {
        if (i)
          return !1;
        i = !0;
      }
      const u = r ? !1 : s.disabled || s.getAttribute("aria-disabled") === "true";
      if (!s.hasAttribute("tabindex") || !iU(s, a) || u)
        s = o(e, s, n);
      else
        return s.focus(), !0;
    }
    return !1;
  }
  const fRe = /* @__PURE__ */ C.forwardRef(function(e, t) {
    const {
      // private
      // eslint-disable-next-line react/prop-types
      actions: n,
      autoFocus: r = !1,
      autoFocusItem: o = !1,
      children: a,
      className: i,
      disabledItemsFocusable: s = !1,
      disableListWrap: u = !1,
      onKeyDown: c,
      variant: f = "selectedMenu",
      ...p
    } = e, g = C.useRef(null), h = C.useRef({
      keys: [],
      repeating: !0,
      previousKeyMatched: !0,
      lastTime: null
    });
    ta(() => {
      r && g.current.focus();
    }, [r]), C.useImperativeHandle(n, () => ({
      adjustStyleForScrollbar: (_, {
        direction: k
      }) => {
        const E = !g.current.style.width;
        if (_.clientHeight < g.current.clientHeight && E) {
          const P = `${aU(Ji(_))}px`;
          g.current.style[k === "rtl" ? "paddingLeft" : "paddingRight"] = P, g.current.style.width = `calc(100% + ${P})`;
        }
        return g.current;
      }
    }), []);
    const y = (_) => {
      const k = g.current, E = _.key;
      if (_.ctrlKey || _.metaKey || _.altKey) {
        c && c(_);
        return;
      }
      const P = _p(Or(k));
      if (E === "ArrowDown")
        _.preventDefault(), ip(k, P, u, s, M0);
      else if (E === "ArrowUp")
        _.preventDefault(), ip(k, P, u, s, jL);
      else if (E === "Home")
        _.preventDefault(), ip(k, null, u, s, M0);
      else if (E === "End")
        _.preventDefault(), ip(k, null, u, s, jL);
      else if (E.length === 1) {
        const O = h.current, M = E.toLowerCase(), I = performance.now();
        O.keys.length > 0 && (I - O.lastTime > 500 ? (O.keys = [], O.repeating = !0, O.previousKeyMatched = !0) : O.repeating && M !== O.keys[0] && (O.repeating = !1)), O.lastTime = I, O.keys.push(M);
        const A = P && !O.repeating && iU(P, O);
        O.previousKeyMatched && (A || ip(k, P, !1, s, M0, O)) ? _.preventDefault() : O.previousKeyMatched = !1;
      }
      c && c(_);
    }, b = Zn(g, t);
    let v = -1;
    C.Children.forEach(a, (_, k) => {
      if (!/* @__PURE__ */ C.isValidElement(_)) {
        v === k && (v += 1, v >= a.length && (v = -1));
        return;
      }
      _.props.disabled || (f === "selectedMenu" && _.props.selected || v === -1) && (v = k), v === k && (_.props.disabled || _.props.muiSkipListHighlight || _.type.muiSkipListHighlight) && (v += 1, v >= a.length && (v = -1));
    });
    const w = C.Children.map(a, (_, k) => {
      if (k === v) {
        const E = {};
        return o && (E.autoFocus = !0), _.props.tabIndex === void 0 && f === "selectedMenu" && (E.tabIndex = 0), /* @__PURE__ */ C.cloneElement(_, E);
      }
      return _;
    });
    return /* @__PURE__ */ S.jsx(NO, {
      role: "menu",
      ref: b,
      className: i,
      onKeyDown: y,
      tabIndex: r ? 0 : -1,
      ...p,
      children: w
    });
  }), pRe = dC(Jc.element);
  pRe.isRequired = dC(Jc.element.isRequired);
  const sU = (e) => e.scrollTop;
  function Vb(e, t) {
    const {
      timeout: n,
      easing: r,
      style: o = {}
    } = e;
    return {
      duration: o.transitionDuration ?? (typeof n == "number" ? n : n[t.mode] || 0),
      easing: o.transitionTimingFunction ?? (typeof r == "object" ? r[t.mode] : r),
      delay: o.transitionDelay
    };
  }
  function SE(e) {
    return `scale(${e}, ${e ** 2})`;
  }
  const mRe = {
    entering: {
      opacity: 1,
      transform: SE(1)
    },
    entered: {
      opacity: 1,
      transform: "none"
    }
  }, R0 = typeof navigator < "u" && /^((?!chrome|android).)*(safari|mobile)/i.test(navigator.userAgent) && /(os |version\/)15(.|_)4/i.test(navigator.userAgent), _E = /* @__PURE__ */ C.forwardRef(function(e, t) {
    const {
      addEndListener: n,
      appear: r = !0,
      children: o,
      easing: a,
      in: i,
      onEnter: s,
      onEntered: u,
      onEntering: c,
      onExit: f,
      onExited: p,
      onExiting: g,
      style: h,
      timeout: y = "auto",
      // eslint-disable-next-line react/prop-types
      TransitionComponent: b = Ya,
      ...v
    } = e, w = VT(), _ = C.useRef(), k = hw(), E = C.useRef(null), P = Zn(E, gh(o), t), O = ($) => (q) => {
      if ($) {
        const B = E.current;
        q === void 0 ? $(B) : $(B, q);
      }
    }, M = O(c), I = O(($, q) => {
      sU($);
      const {
        duration: B,
        delay: G,
        easing: W
      } = Vb({
        style: h,
        timeout: y,
        easing: a
      }, {
        mode: "enter"
      });
      let Y;
      y === "auto" ? (Y = k.transitions.getAutoHeightDuration($.clientHeight), _.current = Y) : Y = B, $.style.transition = [k.transitions.create("opacity", {
        duration: Y,
        delay: G
      }), k.transitions.create("transform", {
        duration: R0 ? Y : Y * 0.666,
        delay: G,
        easing: W
      })].join(","), s && s($, q);
    }), A = O(u), D = O(g), F = O(($) => {
      const {
        duration: q,
        delay: B,
        easing: G
      } = Vb({
        style: h,
        timeout: y,
        easing: a
      }, {
        mode: "exit"
      });
      let W;
      y === "auto" ? (W = k.transitions.getAutoHeightDuration($.clientHeight), _.current = W) : W = q, $.style.transition = [k.transitions.create("opacity", {
        duration: W,
        delay: B
      }), k.transitions.create("transform", {
        duration: R0 ? W : W * 0.666,
        delay: R0 ? B : B || W * 0.333,
        easing: G
      })].join(","), $.style.opacity = 0, $.style.transform = SE(0.75), f && f($);
    }), j = O(p), U = ($) => {
      y === "auto" && w.start(_.current || 0, $), n && n(E.current, $);
    };
    return /* @__PURE__ */ S.jsx(b, {
      appear: r,
      in: i,
      nodeRef: E,
      onEnter: I,
      onEntered: A,
      onEntering: M,
      onExit: F,
      onExited: j,
      onExiting: D,
      addEndListener: U,
      timeout: y === "auto" ? null : y,
      ...v,
      children: ($, {
        ownerState: q,
        ...B
      }) => /* @__PURE__ */ C.cloneElement(o, {
        style: {
          opacity: 0,
          transform: SE(0.75),
          visibility: $ === "exited" && !i ? "hidden" : void 0,
          ...mRe[$],
          ...h,
          ...o.props.style
        },
        ref: P,
        ...B
      })
    });
  });
  _E && (_E.muiSupportAuto = !0);
  function hRe(e) {
    const t = Or(e);
    return t.body === e ? Ji(e).innerWidth > t.documentElement.clientWidth : e.scrollHeight > e.clientHeight;
  }
  function Bp(e, t) {
    t ? e.setAttribute("aria-hidden", "true") : e.removeAttribute("aria-hidden");
  }
  function IL(e) {
    return parseInt(Ji(e).getComputedStyle(e).paddingRight, 10) || 0;
  }
  function gRe(e) {
    const t = ["TEMPLATE", "SCRIPT", "STYLE", "LINK", "MAP", "META", "NOSCRIPT", "PICTURE", "COL", "COLGROUP", "PARAM", "SLOT", "SOURCE", "TRACK"].includes(e.tagName), n = e.tagName === "INPUT" && e.getAttribute("type") === "hidden";
    return t || n;
  }
  function AL(e, t, n, r, o) {
    const a = [t, n, ...r];
    [].forEach.call(e.children, (i) => {
      const s = !a.includes(i), u = !gRe(i);
      s && u && Bp(i, o);
    });
  }
  function j0(e, t) {
    let n = -1;
    return e.some((r, o) => t(r) ? (n = o, !0) : !1), n;
  }
  function vRe(e, t) {
    const n = [], r = e.container;
    if (!t.disableScrollLock) {
      if (hRe(r)) {
        const a = aU(Ji(r));
        n.push({
          value: r.style.paddingRight,
          property: "padding-right",
          el: r
        }), r.style.paddingRight = `${IL(r) + a}px`;
        const i = Or(r).querySelectorAll(".mui-fixed");
        [].forEach.call(i, (s) => {
          n.push({
            value: s.style.paddingRight,
            property: "padding-right",
            el: s
          }), s.style.paddingRight = `${IL(s) + a}px`;
        });
      }
      let o;
      if (r.parentNode instanceof DocumentFragment)
        o = Or(r).body;
      else {
        const a = r.parentElement, i = Ji(r);
        o = a?.nodeName === "HTML" && i.getComputedStyle(a).overflowY === "scroll" ? a : r;
      }
      n.push({
        value: o.style.overflow,
        property: "overflow",
        el: o
      }, {
        value: o.style.overflowX,
        property: "overflow-x",
        el: o
      }, {
        value: o.style.overflowY,
        property: "overflow-y",
        el: o
      }), o.style.overflow = "hidden";
    }
    return () => {
      n.forEach(({
        value: o,
        el: a,
        property: i
      }) => {
        o ? a.style.setProperty(i, o) : a.style.removeProperty(i);
      });
    };
  }
  function yRe(e) {
    const t = [];
    return [].forEach.call(e.children, (n) => {
      n.getAttribute("aria-hidden") === "true" && t.push(n);
    }), t;
  }
  class bRe {
    constructor() {
      this.modals = [], this.containers = [];
    }
    add(t, n) {
      let r = this.modals.indexOf(t);
      if (r !== -1)
        return r;
      r = this.modals.length, this.modals.push(t), t.modalRef && Bp(t.modalRef, !1);
      const o = yRe(n);
      AL(n, t.mount, t.modalRef, o, !0);
      const a = j0(this.containers, (i) => i.container === n);
      return a !== -1 ? (this.containers[a].modals.push(t), r) : (this.containers.push({
        modals: [t],
        container: n,
        restore: null,
        hiddenSiblings: o
      }), r);
    }
    mount(t, n) {
      const r = j0(this.containers, (a) => a.modals.includes(t)), o = this.containers[r];
      o.restore || (o.restore = vRe(o, n));
    }
    remove(t, n = !0) {
      const r = this.modals.indexOf(t);
      if (r === -1)
        return r;
      const o = j0(this.containers, (i) => i.modals.includes(t)), a = this.containers[o];
      if (a.modals.splice(a.modals.indexOf(t), 1), this.modals.splice(r, 1), a.modals.length === 0)
        a.restore && a.restore(), t.modalRef && Bp(t.modalRef, n), AL(a.container, t.mount, t.modalRef, a.hiddenSiblings, !1), this.containers.splice(o, 1);
      else {
        const i = a.modals[a.modals.length - 1];
        i.modalRef && Bp(i.modalRef, !1);
      }
      return r;
    }
    isTopModal(t) {
      return this.modals.length > 0 && this.modals[this.modals.length - 1] === t;
    }
  }
  const wRe = ["input", "select", "textarea", "a[href]", "button", "[tabindex]", "audio[controls]", "video[controls]", '[contenteditable]:not([contenteditable="false"])'].join(",");
  function xRe(e) {
    const t = parseInt(e.getAttribute("tabindex") || "", 10);
    return Number.isNaN(t) ? e.contentEditable === "true" || (e.nodeName === "AUDIO" || e.nodeName === "VIDEO" || e.nodeName === "DETAILS") && e.getAttribute("tabindex") === null ? 0 : e.tabIndex : t;
  }
  function kRe(e) {
    if (e.tagName !== "INPUT" || e.type !== "radio" || !e.name)
      return !1;
    const t = (r) => e.ownerDocument.querySelector(`input[type="radio"]${r}`);
    let n = t(`[name="${e.name}"]:checked`);
    return n || (n = t(`[name="${e.name}"]`)), n !== e;
  }
  function SRe(e) {
    return !(e.disabled || e.tagName === "INPUT" && e.type === "hidden" || kRe(e));
  }
  function _Re(e) {
    const t = [], n = [];
    return Array.from(e.querySelectorAll(wRe)).forEach((r, o) => {
      const a = xRe(r);
      a === -1 || !SRe(r) || (a === 0 ? t.push(r) : n.push({
        documentOrder: o,
        tabIndex: a,
        node: r
      }));
    }), n.sort((r, o) => r.tabIndex === o.tabIndex ? r.documentOrder - o.documentOrder : r.tabIndex - o.tabIndex).map((r) => r.node).concat(t);
  }
  function ERe() {
    return !0;
  }
  function CRe(e) {
    const {
      children: t,
      disableAutoFocus: n = !1,
      disableEnforceFocus: r = !1,
      disableRestoreFocus: o = !1,
      getTabbable: a = _Re,
      isEnabled: i = ERe,
      open: s
    } = e, u = C.useRef(!1), c = C.useRef(null), f = C.useRef(null), p = C.useRef(null), g = C.useRef(null), h = C.useRef(!1), y = C.useRef(null), b = Zn(gh(t), y), v = C.useRef(null);
    C.useEffect(() => {
      !s || !y.current || (h.current = !n);
    }, [n, s]), C.useEffect(() => {
      if (!s || !y.current)
        return;
      const k = Or(y.current), E = _p(k);
      return y.current.contains(E) || (y.current.hasAttribute("tabIndex") || y.current.setAttribute("tabIndex", "-1"), h.current && y.current.focus()), () => {
        o || (p.current && p.current.focus && (u.current = !0, p.current.focus()), p.current = null);
      };
    }, [s]), C.useEffect(() => {
      if (!s || !y.current)
        return;
      const k = Or(y.current), E = _p(k), P = (I) => {
        v.current = I, !(r || !i() || I.key !== "Tab") && E === y.current && I.shiftKey && (u.current = !0, f.current && f.current.focus());
      }, O = () => {
        const I = y.current;
        if (I === null)
          return;
        const A = _p(k);
        if (!k.hasFocus() || !i() || u.current) {
          u.current = !1;
          return;
        }
        if (I.contains(A) || r && A !== c.current && A !== f.current)
          return;
        if (A !== g.current)
          g.current = null;
        else if (g.current !== null)
          return;
        if (!h.current)
          return;
        let D = [];
        if ((A === c.current || A === f.current) && (D = a(y.current)), D.length > 0) {
          const F = !!(v.current?.shiftKey && v.current?.key === "Tab"), j = D[0], U = D[D.length - 1];
          typeof j != "string" && typeof U != "string" && (F ? U.focus() : j.focus());
        } else
          I.focus();
      };
      k.addEventListener("focusin", O), k.addEventListener("keydown", P, !0);
      const M = setInterval(() => {
        const I = _p(k);
        I && I.tagName === "BODY" && O();
      }, 50);
      return () => {
        clearInterval(M), k.removeEventListener("focusin", O), k.removeEventListener("keydown", P, !0);
      };
    }, [n, r, o, i, s, a]);
    const w = (k) => {
      p.current === null && (p.current = k.relatedTarget), h.current = !0, g.current = k.target;
      const E = t.props.onFocus;
      E && E(k);
    }, _ = (k) => {
      p.current === null && (p.current = k.relatedTarget), h.current = !0;
    };
    return /* @__PURE__ */ S.jsxs(C.Fragment, {
      children: [/* @__PURE__ */ S.jsx("div", {
        tabIndex: s ? 0 : -1,
        onFocus: _,
        ref: c,
        "data-testid": "sentinelStart"
      }), /* @__PURE__ */ C.cloneElement(t, {
        ref: b,
        onFocus: w
      }), /* @__PURE__ */ S.jsx("div", {
        tabIndex: s ? 0 : -1,
        onFocus: _,
        ref: f,
        "data-testid": "sentinelEnd"
      })]
    });
  }
  function PRe(e) {
    return typeof e == "function" ? e() : e;
  }
  const ORe = /* @__PURE__ */ C.forwardRef(function(e, t) {
    const {
      children: n,
      container: r,
      disablePortal: o = !1
    } = e, [a, i] = C.useState(null), s = Zn(/* @__PURE__ */ C.isValidElement(n) ? gh(n) : null, t);
    if (ta(() => {
      o || i(PRe(r) || document.body);
    }, [r, o]), ta(() => {
      if (a && !o)
        return kL(t, a), () => {
          kL(t, null);
        };
    }, [t, a, o]), o) {
      if (/* @__PURE__ */ C.isValidElement(n)) {
        const u = {
          ref: s
        };
        return /* @__PURE__ */ C.cloneElement(n, u);
      }
      return n;
    }
    return a && /* @__PURE__ */ xu.createPortal(n, a);
  }), NRe = {
    entering: {
      opacity: 1
    },
    entered: {
      opacity: 1
    }
  }, MRe = /* @__PURE__ */ C.forwardRef(function(e, t) {
    const n = hw(), r = {
      enter: n.transitions.duration.enteringScreen,
      exit: n.transitions.duration.leavingScreen
    }, {
      addEndListener: o,
      appear: a = !0,
      children: i,
      easing: s,
      in: u,
      onEnter: c,
      onEntered: f,
      onEntering: p,
      onExit: g,
      onExited: h,
      onExiting: y,
      style: b,
      timeout: v = r,
      // eslint-disable-next-line react/prop-types
      TransitionComponent: w = Ya,
      ..._
    } = e, k = C.useRef(null), E = Zn(k, gh(i), t), P = (U) => ($) => {
      if (U) {
        const q = k.current;
        $ === void 0 ? U(q) : U(q, $);
      }
    }, O = P(p), M = P((U, $) => {
      sU(U);
      const q = Vb({
        style: b,
        timeout: v,
        easing: s
      }, {
        mode: "enter"
      });
      U.style.webkitTransition = n.transitions.create("opacity", q), U.style.transition = n.transitions.create("opacity", q), c && c(U, $);
    }), I = P(f), A = P(y), D = P((U) => {
      const $ = Vb({
        style: b,
        timeout: v,
        easing: s
      }, {
        mode: "exit"
      });
      U.style.webkitTransition = n.transitions.create("opacity", $), U.style.transition = n.transitions.create("opacity", $), g && g(U);
    }), F = P(h), j = (U) => {
      o && o(k.current, U);
    };
    return /* @__PURE__ */ S.jsx(w, {
      appear: a,
      in: u,
      nodeRef: k,
      onEnter: M,
      onEntered: I,
      onEntering: O,
      onExit: D,
      onExited: F,
      onExiting: A,
      addEndListener: j,
      timeout: v,
      ..._,
      children: (U, {
        ownerState: $,
        ...q
      }) => /* @__PURE__ */ C.cloneElement(i, {
        style: {
          opacity: 0,
          visibility: U === "exited" && !u ? "hidden" : void 0,
          ...NRe[U],
          ...b,
          ...i.props.style
        },
        ref: E,
        ...q
      })
    });
  });
  function RRe(e) {
    return rt("MuiBackdrop", e);
  }
  tt("MuiBackdrop", ["root", "invisible"]);
  const jRe = (e) => {
    const {
      classes: t,
      invisible: n
    } = e;
    return nt({
      root: ["root", n && "invisible"]
    }, RRe, t);
  }, IRe = Me("div", {
    name: "MuiBackdrop",
    slot: "Root",
    overridesResolver: (e, t) => {
      const {
        ownerState: n
      } = e;
      return [t.root, n.invisible && t.invisible];
    }
  })({
    position: "fixed",
    display: "flex",
    alignItems: "center",
    justifyContent: "center",
    right: 0,
    bottom: 0,
    top: 0,
    left: 0,
    backgroundColor: "rgba(0, 0, 0, 0.5)",
    WebkitTapHighlightColor: "transparent",
    variants: [{
      props: {
        invisible: !0
      },
      style: {
        backgroundColor: "transparent"
      }
    }]
  }), ARe = /* @__PURE__ */ C.forwardRef(function(e, t) {
    const n = lt({
      props: e,
      name: "MuiBackdrop"
    }), {
      children: r,
      className: o,
      component: a = "div",
      invisible: i = !1,
      open: s,
      components: u = {},
      componentsProps: c = {},
      slotProps: f = {},
      slots: p = {},
      TransitionComponent: g,
      transitionDuration: h,
      ...y
    } = n, b = {
      ...n,
      component: a,
      invisible: i
    }, v = jRe(b), w = {
      transition: g,
      root: u.Root,
      ...p
    }, _ = {
      ...c,
      ...f
    }, k = {
      component: a,
      slots: w,
      slotProps: _
    }, [E, P] = sn("root", {
      elementType: IRe,
      externalForwardedProps: k,
      className: Le(v.root, o),
      ownerState: b
    }), [O, M] = sn("transition", {
      elementType: MRe,
      externalForwardedProps: k,
      ownerState: b
    });
    return /* @__PURE__ */ S.jsx(O, {
      in: s,
      timeout: h,
      ...y,
      ...M,
      children: /* @__PURE__ */ S.jsx(E, {
        "aria-hidden": !0,
        ...P,
        classes: v,
        ref: t,
        children: r
      })
    });
  });
  function $Re(e) {
    return typeof e == "function" ? e() : e;
  }
  function DRe(e) {
    return e ? e.props.hasOwnProperty("in") : !1;
  }
  const $L = () => {
  }, fy = new bRe();
  function LRe(e) {
    const {
      container: t,
      disableEscapeKeyDown: n = !1,
      disableScrollLock: r = !1,
      closeAfterTransition: o = !1,
      onTransitionEnter: a,
      onTransitionExited: i,
      children: s,
      onClose: u,
      open: c,
      rootRef: f
    } = e, p = C.useRef({}), g = C.useRef(null), h = C.useRef(null), y = Zn(h, f), [b, v] = C.useState(!c), w = DRe(s);
    let _ = !0;
    (e["aria-hidden"] === "false" || e["aria-hidden"] === !1) && (_ = !1);
    const k = () => Or(g.current), E = () => (p.current.modalRef = h.current, p.current.mount = g.current, p.current), P = () => {
      fy.mount(E(), {
        disableScrollLock: r
      }), h.current && (h.current.scrollTop = 0);
    }, O = Ba(() => {
      const j = $Re(t) || k().body;
      fy.add(E(), j), h.current && P();
    }), M = () => fy.isTopModal(E()), I = Ba((j) => {
      g.current = j, j && (c && M() ? P() : h.current && Bp(h.current, _));
    }), A = C.useCallback(() => {
      fy.remove(E(), _);
    }, [_]);
    C.useEffect(() => () => {
      A();
    }, [A]), C.useEffect(() => {
      c ? O() : (!w || !o) && A();
    }, [c, A, w, o, O]);
    const D = (j) => (U) => {
      j.onKeyDown?.(U), !(U.key !== "Escape" || U.which === 229 || // Wait until IME is settled.
      !M()) && (n || (U.stopPropagation(), u && u(U, "escapeKeyDown")));
    }, F = (j) => (U) => {
      j.onClick?.(U), U.target === U.currentTarget && u && u(U, "backdropClick");
    };
    return {
      getRootProps: (j = {}) => {
        const U = Np(e);
        delete U.onTransitionEnter, delete U.onTransitionExited;
        const $ = {
          ...U,
          ...j
        };
        return {
          /*
           * Marking an element with the role presentation indicates to assistive technology
           * that this element should be ignored; it exists to support the web application and
           * is not meant for humans to interact with directly.
           * https://github.com/evcohen/eslint-plugin-jsx-a11y/blob/master/docs/rules/no-static-element-interactions.md
           */
          role: "presentation",
          ...$,
          onKeyDown: D($),
          ref: y
        };
      },
      getBackdropProps: (j = {}) => {
        const U = j;
        return {
          "aria-hidden": !0,
          ...U,
          onClick: F(U),
          open: c
        };
      },
      getTransitionProps: () => {
        const j = () => {
          v(!1), a && a();
        }, U = () => {
          v(!0), i && i(), o && A();
        };
        return {
          onEnter: wE(j, s?.props.onEnter ?? $L),
          onExited: wE(U, s?.props.onExited ?? $L)
        };
      },
      rootRef: y,
      portalRef: I,
      isTopModal: M,
      exited: b,
      hasTransition: w
    };
  }
  function FRe(e) {
    return rt("MuiModal", e);
  }
  tt("MuiModal", ["root", "hidden", "backdrop"]);
  const TRe = (e) => {
    const {
      open: t,
      exited: n,
      classes: r
    } = e;
    return nt({
      root: ["root", !t && n && "hidden"],
      backdrop: ["backdrop"]
    }, FRe, r);
  }, zRe = Me("div", {
    name: "MuiModal",
    slot: "Root",
    overridesResolver: (e, t) => {
      const {
        ownerState: n
      } = e;
      return [t.root, !n.open && n.exited && t.hidden];
    }
  })(at(({
    theme: e
  }) => ({
    position: "fixed",
    zIndex: (e.vars || e).zIndex.modal,
    right: 0,
    bottom: 0,
    top: 0,
    left: 0,
    variants: [{
      props: ({
        ownerState: t
      }) => !t.open && t.exited,
      style: {
        visibility: "hidden"
      }
    }]
  }))), BRe = Me(ARe, {
    name: "MuiModal",
    slot: "Backdrop"
  })({
    zIndex: -1
  }), VRe = /* @__PURE__ */ C.forwardRef(function(e, t) {
    const n = lt({
      name: "MuiModal",
      props: e
    }), {
      BackdropComponent: r = BRe,
      BackdropProps: o,
      classes: a,
      className: i,
      closeAfterTransition: s = !1,
      children: u,
      container: c,
      component: f,
      components: p = {},
      componentsProps: g = {},
      disableAutoFocus: h = !1,
      disableEnforceFocus: y = !1,
      disableEscapeKeyDown: b = !1,
      disablePortal: v = !1,
      disableRestoreFocus: w = !1,
      disableScrollLock: _ = !1,
      hideBackdrop: k = !1,
      keepMounted: E = !1,
      onClose: P,
      onTransitionEnter: O,
      onTransitionExited: M,
      open: I,
      slotProps: A = {},
      slots: D = {},
      // eslint-disable-next-line react/prop-types
      theme: F,
      ...j
    } = n, U = {
      ...n,
      closeAfterTransition: s,
      disableAutoFocus: h,
      disableEnforceFocus: y,
      disableEscapeKeyDown: b,
      disablePortal: v,
      disableRestoreFocus: w,
      disableScrollLock: _,
      hideBackdrop: k,
      keepMounted: E
    }, {
      getRootProps: $,
      getBackdropProps: q,
      getTransitionProps: B,
      portalRef: G,
      isTopModal: W,
      exited: Y,
      hasTransition: z
    } = LRe({
      ...U,
      rootRef: t
    }), L = {
      ...U,
      exited: Y
    }, K = TRe(L), T = {};
    if (u.props.tabIndex === void 0 && (T.tabIndex = "-1"), z) {
      const {
        onEnter: ae,
        onExited: ce
      } = B();
      T.onEnter = ae, T.onExited = ce;
    }
    const V = {
      slots: {
        root: p.Root,
        backdrop: p.Backdrop,
        ...D
      },
      slotProps: {
        ...g,
        ...A
      }
    }, [X, Q] = sn("root", {
      ref: t,
      elementType: zRe,
      externalForwardedProps: {
        ...V,
        ...j,
        component: f
      },
      getSlotProps: $,
      ownerState: L,
      className: Le(i, K?.root, !L.open && L.exited && K?.hidden)
    }), [ne, te] = sn("backdrop", {
      ref: o?.ref,
      elementType: r,
      externalForwardedProps: V,
      shouldForwardComponentProp: !0,
      additionalProps: o,
      getSlotProps: (ae) => q({
        ...ae,
        onClick: (ce) => {
          ae?.onClick && ae.onClick(ce);
        }
      }),
      className: Le(o?.className, K?.backdrop),
      ownerState: L
    });
    return !E && !I && (!z || Y) ? null : /* @__PURE__ */ S.jsx(ORe, {
      ref: G,
      container: c,
      disablePortal: v,
      children: /* @__PURE__ */ S.jsxs(X, {
        ...Q,
        children: [!k && r ? /* @__PURE__ */ S.jsx(ne, {
          ...te
        }) : null, /* @__PURE__ */ S.jsx(CRe, {
          disableEnforceFocus: y,
          disableAutoFocus: h,
          disableRestoreFocus: w,
          isEnabled: W,
          open: I,
          children: /* @__PURE__ */ C.cloneElement(u, T)
        })]
      })
    });
  });
  function URe(e) {
    return rt("MuiPopover", e);
  }
  tt("MuiPopover", ["root", "paper"]);
  function DL(e, t) {
    let n = 0;
    return typeof t == "number" ? n = t : t === "center" ? n = e.height / 2 : t === "bottom" && (n = e.height), n;
  }
  function LL(e, t) {
    let n = 0;
    return typeof t == "number" ? n = t : t === "center" ? n = e.width / 2 : t === "right" && (n = e.width), n;
  }
  function FL(e) {
    return [e.horizontal, e.vertical].map((t) => typeof t == "number" ? `${t}px` : t).join(" ");
  }
  function py(e) {
    return typeof e == "function" ? e() : e;
  }
  const HRe = (e) => {
    const {
      classes: t
    } = e;
    return nt({
      root: ["root"],
      paper: ["paper"]
    }, URe, t);
  }, WRe = Me(VRe, {
    name: "MuiPopover",
    slot: "Root"
  })({}), lU = Me(Cx, {
    name: "MuiPopover",
    slot: "Paper"
  })({
    position: "absolute",
    overflowY: "auto",
    overflowX: "hidden",
    // So we see the popover when it's empty.
    // It's most likely on issue on userland.
    minWidth: 16,
    minHeight: 16,
    maxWidth: "calc(100% - 32px)",
    maxHeight: "calc(100% - 32px)",
    // We disable the focus ring for mouse, touch and keyboard users.
    outline: 0
  }), qRe = /* @__PURE__ */ C.forwardRef(function(e, t) {
    const n = lt({
      props: e,
      name: "MuiPopover"
    }), {
      action: r,
      anchorEl: o,
      anchorOrigin: a = {
        vertical: "top",
        horizontal: "left"
      },
      anchorPosition: i,
      anchorReference: s = "anchorEl",
      children: u,
      className: c,
      container: f,
      elevation: p = 8,
      marginThreshold: g = 16,
      open: h,
      PaperProps: y = {},
      // TODO: remove in v7
      slots: b = {},
      slotProps: v = {},
      transformOrigin: w = {
        vertical: "top",
        horizontal: "left"
      },
      TransitionComponent: _,
      // TODO: remove in v7
      transitionDuration: k = "auto",
      TransitionProps: E = {},
      // TODO: remove in v7
      disableScrollLock: P = !1,
      ...O
    } = n, M = C.useRef(), I = {
      ...n,
      anchorOrigin: a,
      anchorReference: s,
      elevation: p,
      marginThreshold: g,
      transformOrigin: w,
      TransitionComponent: _,
      transitionDuration: k,
      TransitionProps: E
    }, A = HRe(I), D = C.useCallback(() => {
      if (s === "anchorPosition")
        return i;
      const ae = py(o), ce = ae && ae.nodeType === 1 ? ae : Or(M.current).body, Z = ce.getBoundingClientRect();
      return {
        top: Z.top + DL(Z, a.vertical),
        left: Z.left + LL(Z, a.horizontal)
      };
    }, [o, a.horizontal, a.vertical, i, s]), F = C.useCallback((ae) => ({
      vertical: DL(ae, w.vertical),
      horizontal: LL(ae, w.horizontal)
    }), [w.horizontal, w.vertical]), j = C.useCallback((ae) => {
      const ce = {
        width: ae.offsetWidth,
        height: ae.offsetHeight
      }, Z = F(ce);
      if (s === "none")
        return {
          top: null,
          left: null,
          transformOrigin: FL(Z)
        };
      const ee = D();
      let oe = ee.top - Z.vertical, le = ee.left - Z.horizontal;
      const be = oe + ce.height, ke = le + ce.width, De = Ji(py(o)), ze = De.innerHeight - g, Ue = De.innerWidth - g;
      if (g !== null && oe < g) {
        const He = oe - g;
        oe -= He, Z.vertical += He;
      } else if (g !== null && be > ze) {
        const He = be - ze;
        oe -= He, Z.vertical += He;
      }
      if (g !== null && le < g) {
        const He = le - g;
        le -= He, Z.horizontal += He;
      } else if (ke > Ue) {
        const He = ke - Ue;
        le -= He, Z.horizontal += He;
      }
      return {
        top: `${Math.round(oe)}px`,
        left: `${Math.round(le)}px`,
        transformOrigin: FL(Z)
      };
    }, [o, s, D, F, g]), [U, $] = C.useState(h), q = C.useCallback(() => {
      const ae = M.current;
      if (!ae)
        return;
      const ce = j(ae);
      ce.top !== null && ae.style.setProperty("top", ce.top), ce.left !== null && (ae.style.left = ce.left), ae.style.transformOrigin = ce.transformOrigin, $(!0);
    }, [j]);
    C.useEffect(() => (P && window.addEventListener("scroll", q), () => window.removeEventListener("scroll", q)), [o, P, q]);
    const B = () => {
      q();
    }, G = () => {
      $(!1);
    };
    C.useEffect(() => {
      h && q();
    }), C.useImperativeHandle(r, () => h ? {
      updatePosition: () => {
        q();
      }
    } : null, [h, q]), C.useEffect(() => {
      if (!h)
        return;
      const ae = eU(() => {
        q();
      }), ce = Ji(py(o));
      return ce.addEventListener("resize", ae), () => {
        ae.clear(), ce.removeEventListener("resize", ae);
      };
    }, [o, h, q]);
    let W = k;
    const Y = {
      slots: {
        transition: _,
        ...b
      },
      slotProps: {
        transition: E,
        paper: y,
        ...v
      }
    }, [z, L] = sn("transition", {
      elementType: _E,
      externalForwardedProps: Y,
      ownerState: I,
      getSlotProps: (ae) => ({
        ...ae,
        onEntering: (ce, Z) => {
          ae.onEntering?.(ce, Z), B();
        },
        onExited: (ce) => {
          ae.onExited?.(ce), G();
        }
      }),
      additionalProps: {
        appear: !0,
        in: h
      }
    });
    k === "auto" && !z.muiSupportAuto && (W = void 0);
    const K = f || (o ? Or(py(o)).body : void 0), [T, {
      slots: V,
      slotProps: X,
      ...Q
    }] = sn("root", {
      ref: t,
      elementType: WRe,
      externalForwardedProps: {
        ...Y,
        ...O
      },
      shouldForwardComponentProp: !0,
      additionalProps: {
        slots: {
          backdrop: b.backdrop
        },
        slotProps: {
          backdrop: tU(typeof v.backdrop == "function" ? v.backdrop(I) : v.backdrop, {
            invisible: !0
          })
        },
        container: K,
        open: h
      },
      ownerState: I,
      className: Le(A.root, c)
    }), [ne, te] = sn("paper", {
      ref: M,
      className: A.paper,
      elementType: lU,
      externalForwardedProps: Y,
      shouldForwardComponentProp: !0,
      additionalProps: {
        elevation: p,
        style: U ? void 0 : {
          opacity: 0
        }
      },
      ownerState: I
    });
    return /* @__PURE__ */ S.jsx(T, {
      ...Q,
      ...!Va(T) && {
        slots: V,
        slotProps: X,
        disableScrollLock: P
      },
      children: /* @__PURE__ */ S.jsx(z, {
        ...L,
        timeout: W,
        children: /* @__PURE__ */ S.jsx(ne, {
          ...te,
          children: u
        })
      })
    });
  });
  function KRe(e) {
    return rt("MuiMenu", e);
  }
  tt("MuiMenu", ["root", "paper", "list"]);
  const GRe = {
    vertical: "top",
    horizontal: "right"
  }, XRe = {
    vertical: "top",
    horizontal: "left"
  }, YRe = (e) => {
    const {
      classes: t
    } = e;
    return nt({
      root: ["root"],
      paper: ["paper"],
      list: ["list"]
    }, KRe, t);
  }, JRe = Me(qRe, {
    shouldForwardProp: (e) => kr(e) || e === "classes",
    name: "MuiMenu",
    slot: "Root"
  })({}), QRe = Me(lU, {
    name: "MuiMenu",
    slot: "Paper"
  })({
    // specZ: The maximum height of a simple menu should be one or more rows less than the view
    // height. This ensures a tappable area outside of the simple menu with which to dismiss
    // the menu.
    maxHeight: "calc(100% - 96px)",
    // Add iOS momentum scrolling for iOS < 13.0
    WebkitOverflowScrolling: "touch"
  }), ZRe = Me(fRe, {
    name: "MuiMenu",
    slot: "List"
  })({
    // We disable the focus ring for mouse, touch and keyboard users.
    outline: 0
  }), eje = /* @__PURE__ */ C.forwardRef(function(e, t) {
    const n = lt({
      props: e,
      name: "MuiMenu"
    }), {
      autoFocus: r = !0,
      children: o,
      className: a,
      disableAutoFocusItem: i = !1,
      MenuListProps: s = {},
      onClose: u,
      open: c,
      PaperProps: f = {},
      PopoverClasses: p,
      transitionDuration: g = "auto",
      TransitionProps: {
        onEntering: h,
        ...y
      } = {},
      variant: b = "selectedMenu",
      slots: v = {},
      slotProps: w = {},
      ..._
    } = n, k = NT(), E = {
      ...n,
      autoFocus: r,
      disableAutoFocusItem: i,
      MenuListProps: s,
      onEntering: h,
      PaperProps: f,
      transitionDuration: g,
      TransitionProps: y,
      variant: b
    }, P = YRe(E), O = r && !i && c, M = C.useRef(null), I = (W, Y) => {
      M.current && M.current.adjustStyleForScrollbar(W, {
        direction: k ? "rtl" : "ltr"
      }), h && h(W, Y);
    }, A = (W) => {
      W.key === "Tab" && (W.preventDefault(), u && u(W, "tabKeyDown"));
    };
    let D = -1;
    C.Children.map(o, (W, Y) => {
      /* @__PURE__ */ C.isValidElement(W) && (W.props.disabled || (b === "selectedMenu" && W.props.selected || D === -1) && (D = Y));
    });
    const F = {
      slots: v,
      slotProps: {
        list: s,
        transition: y,
        paper: f,
        ...w
      }
    }, j = Ii({
      elementType: v.root,
      externalSlotProps: w.root,
      ownerState: E,
      className: [P.root, a]
    }), [U, $] = sn("paper", {
      className: P.paper,
      elementType: QRe,
      externalForwardedProps: F,
      shouldForwardComponentProp: !0,
      ownerState: E
    }), [q, B] = sn("list", {
      className: Le(P.list, s.className),
      elementType: ZRe,
      shouldForwardComponentProp: !0,
      externalForwardedProps: F,
      getSlotProps: (W) => ({
        ...W,
        onKeyDown: (Y) => {
          A(Y), W.onKeyDown?.(Y);
        }
      }),
      ownerState: E
    }), G = typeof F.slotProps.transition == "function" ? F.slotProps.transition(E) : F.slotProps.transition;
    return /* @__PURE__ */ S.jsx(JRe, {
      onClose: u,
      anchorOrigin: {
        vertical: "bottom",
        horizontal: k ? "right" : "left"
      },
      transformOrigin: k ? GRe : XRe,
      slots: {
        root: v.root,
        paper: U,
        backdrop: v.backdrop,
        ...v.transition && {
          // TODO: pass `slots.transition` directly once `TransitionComponent` is removed from Popover
          transition: v.transition
        }
      },
      slotProps: {
        root: j,
        paper: $,
        backdrop: typeof w.backdrop == "function" ? w.backdrop(E) : w.backdrop,
        transition: {
          ...G,
          onEntering: (...W) => {
            I(...W), G?.onEntering?.(...W);
          }
        }
      },
      open: c,
      ref: t,
      transitionDuration: g,
      ownerState: E,
      ..._,
      classes: p,
      children: /* @__PURE__ */ S.jsx(q, {
        actions: M,
        autoFocus: r && (D === -1 || i),
        autoFocusItem: O,
        variant: b,
        ...B,
        children: o
      })
    });
  });
  function tje(e) {
    return rt("MuiNativeSelect", e);
  }
  const MO = tt("MuiNativeSelect", ["root", "select", "multiple", "filled", "outlined", "standard", "disabled", "icon", "iconOpen", "iconFilled", "iconOutlined", "iconStandard", "nativeInput", "error"]), nje = (e) => {
    const {
      classes: t,
      variant: n,
      disabled: r,
      multiple: o,
      open: a,
      error: i
    } = e, s = {
      select: ["select", n, r && "disabled", o && "multiple", i && "error"],
      icon: ["icon", `icon${$e(n)}`, a && "iconOpen", r && "disabled"]
    };
    return nt(s, tje, t);
  }, uU = Me("select", {
    name: "MuiNativeSelect"
  })(({
    theme: e
  }) => ({
    // Reset
    MozAppearance: "none",
    // Reset
    WebkitAppearance: "none",
    // When interacting quickly, the text can end up selected.
    // Native select can't be selected either.
    userSelect: "none",
    // Reset
    borderRadius: 0,
    cursor: "pointer",
    "&:focus": {
      // Reset Chrome style
      borderRadius: 0
    },
    [`&.${MO.disabled}`]: {
      cursor: "default"
    },
    "&[multiple]": {
      height: "auto"
    },
    "&:not([multiple]) option, &:not([multiple]) optgroup": {
      backgroundColor: (e.vars || e).palette.background.paper
    },
    variants: [{
      props: ({
        ownerState: t
      }) => t.variant !== "filled" && t.variant !== "outlined",
      style: {
        // Bump specificity to allow extending custom inputs
        "&&&": {
          paddingRight: 24,
          minWidth: 16
          // So it doesn't collapse.
        }
      }
    }, {
      props: {
        variant: "filled"
      },
      style: {
        "&&&": {
          paddingRight: 32
        }
      }
    }, {
      props: {
        variant: "outlined"
      },
      style: {
        borderRadius: (e.vars || e).shape.borderRadius,
        "&:focus": {
          borderRadius: (e.vars || e).shape.borderRadius
          // Reset the reset for Chrome style
        },
        "&&&": {
          paddingRight: 32
        }
      }
    }]
  })), rje = Me(uU, {
    name: "MuiNativeSelect",
    slot: "Select",
    shouldForwardProp: kr,
    overridesResolver: (e, t) => {
      const {
        ownerState: n
      } = e;
      return [t.select, t[n.variant], n.error && t.error, {
        [`&.${MO.multiple}`]: t.multiple
      }];
    }
  })({}), cU = Me("svg", {
    name: "MuiNativeSelect"
  })(({
    theme: e
  }) => ({
    // We use a position absolute over a flexbox in order to forward the pointer events
    // to the input and to support wrapping tags..
    position: "absolute",
    right: 0,
    // Center vertically, height is 1em
    top: "calc(50% - .5em)",
    // Don't block pointer events on the select under the icon.
    pointerEvents: "none",
    color: (e.vars || e).palette.action.active,
    [`&.${MO.disabled}`]: {
      color: (e.vars || e).palette.action.disabled
    },
    variants: [{
      props: ({
        ownerState: t
      }) => t.open,
      style: {
        transform: "rotate(180deg)"
      }
    }, {
      props: {
        variant: "filled"
      },
      style: {
        right: 7
      }
    }, {
      props: {
        variant: "outlined"
      },
      style: {
        right: 7
      }
    }]
  })), oje = Me(cU, {
    name: "MuiNativeSelect",
    slot: "Icon",
    overridesResolver: (e, t) => {
      const {
        ownerState: n
      } = e;
      return [t.icon, n.variant && t[`icon${$e(n.variant)}`], n.open && t.iconOpen];
    }
  })({}), aje = /* @__PURE__ */ C.forwardRef(function(e, t) {
    const {
      className: n,
      disabled: r,
      error: o,
      IconComponent: a,
      inputRef: i,
      variant: s = "standard",
      ...u
    } = e, c = {
      ...e,
      disabled: r,
      variant: s,
      error: o
    }, f = nje(c);
    return /* @__PURE__ */ S.jsxs(C.Fragment, {
      children: [/* @__PURE__ */ S.jsx(rje, {
        ownerState: c,
        className: Le(f.select, n),
        disabled: r,
        ref: i || t,
        ...u
      }), e.multiple ? null : /* @__PURE__ */ S.jsx(oje, {
        as: a,
        ownerState: c,
        className: f.icon
      })]
    });
  });
  function dU(e) {
    return rt("MuiSelect", e);
  }
  const sp = tt("MuiSelect", ["root", "select", "multiple", "filled", "outlined", "standard", "disabled", "focused", "icon", "iconOpen", "iconFilled", "iconOutlined", "iconStandard", "nativeInput", "error"]);
  var TL;
  const ije = Me(uU, {
    name: "MuiSelect",
    slot: "Select",
    overridesResolver: (e, t) => {
      const {
        ownerState: n
      } = e;
      return [
        // Win specificity over the input base
        {
          [`&.${sp.select}`]: t.select
        },
        {
          [`&.${sp.select}`]: t[n.variant]
        },
        {
          [`&.${sp.error}`]: t.error
        },
        {
          [`&.${sp.multiple}`]: t.multiple
        }
      ];
    }
  })({
    // Win specificity over the input base
    [`&.${sp.select}`]: {
      height: "auto",
      // Resets for multiple select with chips
      minHeight: "1.4375em",
      // Required for select\text-field height consistency
      textOverflow: "ellipsis",
      whiteSpace: "nowrap",
      overflow: "hidden"
    }
  }), sje = Me(cU, {
    name: "MuiSelect",
    slot: "Icon",
    overridesResolver: (e, t) => {
      const {
        ownerState: n
      } = e;
      return [t.icon, n.variant && t[`icon${$e(n.variant)}`], n.open && t.iconOpen];
    }
  })({}), lje = Me("input", {
    shouldForwardProp: (e) => gw(e) && e !== "classes",
    name: "MuiSelect",
    slot: "NativeInput"
  })({
    bottom: 0,
    left: 0,
    position: "absolute",
    opacity: 0,
    pointerEvents: "none",
    width: "100%",
    boxSizing: "border-box"
  });
  function zL(e, t) {
    return typeof t == "object" && t !== null ? e === t : String(e) === String(t);
  }
  function uje(e) {
    return e == null || typeof e == "string" && !e.trim();
  }
  const cje = (e) => {
    const {
      classes: t,
      variant: n,
      disabled: r,
      multiple: o,
      open: a,
      error: i
    } = e, s = {
      select: ["select", n, r && "disabled", o && "multiple", i && "error"],
      icon: ["icon", `icon${$e(n)}`, a && "iconOpen", r && "disabled"],
      nativeInput: ["nativeInput"]
    };
    return nt(s, dU, t);
  }, dje = /* @__PURE__ */ C.forwardRef(function(e, t) {
    const {
      "aria-describedby": n,
      "aria-label": r,
      autoFocus: o,
      autoWidth: a,
      children: i,
      className: s,
      defaultOpen: u,
      defaultValue: c,
      disabled: f,
      displayEmpty: p,
      error: g = !1,
      IconComponent: h,
      inputRef: y,
      labelId: b,
      MenuProps: v = {},
      multiple: w,
      name: _,
      onBlur: k,
      onChange: E,
      onClose: P,
      onFocus: O,
      // eslint-disable-next-line react/prop-types
      onKeyDown: M,
      // eslint-disable-next-line react/prop-types
      onMouseDown: I,
      onOpen: A,
      open: D,
      readOnly: F,
      renderValue: j,
      required: U,
      SelectDisplayProps: $ = {},
      tabIndex: q,
      // catching `type` from Input which makes no sense for SelectInput
      type: B,
      value: G,
      variant: W = "standard",
      ...Y
    } = e, [z, L] = Em({
      controlled: G,
      default: c,
      name: "Select"
    }), [K, T] = Em({
      controlled: D,
      default: u,
      name: "Select"
    }), V = C.useRef(null), X = C.useRef(null), [Q, ne] = C.useState(null), {
      current: te
    } = C.useRef(D != null), [ae, ce] = C.useState(), Z = Zn(t, y), ee = C.useCallback((Re) => {
      X.current = Re, Re && ne(Re);
    }, []), oe = Q?.parentNode;
    C.useImperativeHandle(Z, () => ({
      focus: () => {
        X.current.focus();
      },
      node: V.current,
      value: z
    }), [z]), C.useEffect(() => {
      u && K && Q && !te && (ce(a ? null : oe.clientWidth), X.current.focus());
    }, [Q, a]), C.useEffect(() => {
      o && X.current.focus();
    }, [o]), C.useEffect(() => {
      if (!b)
        return;
      const Re = Or(X.current).getElementById(b);
      if (Re) {
        const bt = () => {
          getSelection().isCollapsed && X.current.focus();
        };
        return Re.addEventListener("click", bt), () => {
          Re.removeEventListener("click", bt);
        };
      }
    }, [b]);
    const le = (Re, bt) => {
      Re ? A && A(bt) : P && P(bt), te || (ce(a ? null : oe.clientWidth), T(Re));
    }, be = (Re) => {
      I?.(Re), Re.button === 0 && (Re.preventDefault(), X.current.focus(), le(!0, Re));
    }, ke = (Re) => {
      le(!1, Re);
    }, De = C.Children.toArray(i), ze = (Re) => {
      const bt = De.find((Ct) => Ct.props.value === Re.target.value);
      bt !== void 0 && (L(bt.props.value), E && E(Re, bt));
    }, Ue = (Re) => (bt) => {
      let Ct;
      if (bt.currentTarget.hasAttribute("tabindex")) {
        if (w) {
          Ct = Array.isArray(z) ? z.slice() : [];
          const Rr = z.indexOf(Re.props.value);
          Rr === -1 ? Ct.push(Re.props.value) : Ct.splice(Rr, 1);
        } else
          Ct = Re.props.value;
        if (Re.props.onClick && Re.props.onClick(bt), z !== Ct && (L(Ct), E)) {
          const Rr = bt.nativeEvent || bt, Fo = new Rr.constructor(Rr.type, Rr);
          Object.defineProperty(Fo, "target", {
            writable: !0,
            value: {
              value: Ct,
              name: _
            }
          }), E(Fo, Re);
        }
        w || le(!1, bt);
      }
    }, He = (Re) => {
      F || ([
        " ",
        "ArrowUp",
        "ArrowDown",
        // The native select doesn't respond to enter on macOS, but it's recommended by
        // https://www.w3.org/WAI/ARIA/apg/patterns/combobox/examples/combobox-select-only/
        "Enter"
      ].includes(Re.key) && (Re.preventDefault(), le(!0, Re)), M?.(Re));
    }, Pe = Q !== null && K, It = (Re) => {
      !Pe && k && (Object.defineProperty(Re, "target", {
        writable: !0,
        value: {
          value: z,
          name: _
        }
      }), k(Re));
    };
    delete Y["aria-invalid"];
    let Xe, Ee;
    const _e = [];
    let ie = !1;
    (Bb({
      value: z
    }) || p) && (j ? Xe = j(z) : ie = !0);
    const me = De.map((Re) => {
      if (!/* @__PURE__ */ C.isValidElement(Re))
        return null;
      let bt;
      if (w) {
        if (!Array.isArray(z))
          throw new Error(Vi(2));
        bt = z.some((Ct) => zL(Ct, Re.props.value)), bt && ie && _e.push(Re.props.children);
      } else
        bt = zL(z, Re.props.value), bt && ie && (Ee = Re.props.children);
      return /* @__PURE__ */ C.cloneElement(Re, {
        "aria-selected": bt ? "true" : "false",
        onClick: Ue(Re),
        onKeyUp: (Ct) => {
          Ct.key === " " && Ct.preventDefault(), Re.props.onKeyUp && Re.props.onKeyUp(Ct);
        },
        role: "option",
        selected: bt,
        value: void 0,
        // The value is most likely not a valid HTML attribute.
        "data-value": Re.props.value
        // Instead, we provide it as a data attribute.
      });
    });
    ie && (w ? _e.length === 0 ? Xe = null : Xe = _e.reduce((Re, bt, Ct) => (Re.push(bt), Ct < _e.length - 1 && Re.push(", "), Re), []) : Xe = Ee);
    let Se = ae;
    !a && te && Q && (Se = oe.clientWidth);
    let je;
    typeof q < "u" ? je = q : je = f ? null : 0;
    const Ae = $.id || (_ ? `mui-component-select-${_}` : void 0), vt = {
      ...e,
      variant: W,
      value: z,
      open: Pe,
      error: g
    }, yt = cje(vt), At = {
      ...v.PaperProps,
      ...typeof v.slotProps?.paper == "function" ? v.slotProps.paper(vt) : v.slotProps?.paper
    }, qt = {
      ...v.MenuListProps,
      ...typeof v.slotProps?.list == "function" ? v.slotProps.list(vt) : v.slotProps?.list
    }, Mn = $d();
    return /* @__PURE__ */ S.jsxs(C.Fragment, {
      children: [/* @__PURE__ */ S.jsx(ije, {
        as: "div",
        ref: ee,
        tabIndex: je,
        role: "combobox",
        "aria-controls": Pe ? Mn : void 0,
        "aria-disabled": f ? "true" : void 0,
        "aria-expanded": Pe ? "true" : "false",
        "aria-haspopup": "listbox",
        "aria-label": r,
        "aria-labelledby": [b, Ae].filter(Boolean).join(" ") || void 0,
        "aria-describedby": n,
        "aria-required": U ? "true" : void 0,
        "aria-invalid": g ? "true" : void 0,
        onKeyDown: He,
        onMouseDown: f || F ? null : be,
        onBlur: It,
        onFocus: O,
        ...$,
        ownerState: vt,
        className: Le($.className, yt.select, s),
        id: Ae,
        children: uje(Xe) ? (
          // notranslate needed while Google Translate will not fix zero-width space issue
          TL || (TL = /* @__PURE__ */ S.jsx("span", {
            className: "notranslate",
            "aria-hidden": !0,
            children: ""
          }))
        ) : Xe
      }), /* @__PURE__ */ S.jsx(lje, {
        "aria-invalid": g,
        value: Array.isArray(z) ? z.join(",") : z,
        name: _,
        ref: V,
        "aria-hidden": !0,
        onChange: ze,
        tabIndex: -1,
        disabled: f,
        className: yt.nativeInput,
        autoFocus: o,
        required: U,
        ...Y,
        ownerState: vt
      }), /* @__PURE__ */ S.jsx(sje, {
        as: h,
        className: yt.icon,
        ownerState: vt
      }), /* @__PURE__ */ S.jsx(eje, {
        id: `menu-${_ || ""}`,
        anchorEl: oe,
        open: Pe,
        onClose: ke,
        anchorOrigin: {
          vertical: "bottom",
          horizontal: "center"
        },
        transformOrigin: {
          vertical: "top",
          horizontal: "center"
        },
        ...v,
        slotProps: {
          ...v.slotProps,
          list: {
            "aria-labelledby": b,
            role: "listbox",
            "aria-multiselectable": w ? "true" : void 0,
            disableListWrap: !0,
            id: Mn,
            ...qt
          },
          paper: {
            ...At,
            style: {
              minWidth: Se,
              ...At != null ? At.style : null
            }
          }
        },
        children: me
      })]
    });
  }), fje = mo(/* @__PURE__ */ S.jsx("path", {
    d: "M7 10l5 5 5-5z"
  })), pje = (e) => {
    const {
      classes: t
    } = e, n = nt({
      root: ["root"]
    }, dU, t);
    return {
      ...t,
      ...n
    };
  }, RO = {
    name: "MuiSelect",
    slot: "Root",
    shouldForwardProp: (e) => kr(e) && e !== "variant"
  }, mje = Me(_O, RO)(""), hje = Me(CO, RO)(""), gje = Me(EO, RO)(""), fU = /* @__PURE__ */ C.forwardRef(function(e, t) {
    const n = lt({
      name: "MuiSelect",
      props: e
    }), {
      autoWidth: r = !1,
      children: o,
      classes: a = {},
      className: i,
      defaultOpen: s = !1,
      displayEmpty: u = !1,
      IconComponent: c = fje,
      id: f,
      input: p,
      inputProps: g,
      label: h,
      labelId: y,
      MenuProps: b,
      multiple: v = !1,
      native: w = !1,
      onClose: _,
      onOpen: k,
      open: E,
      renderValue: P,
      SelectDisplayProps: O,
      variant: M = "outlined",
      ...I
    } = n, A = w ? aje : dje, D = ni(), F = vl({
      props: n,
      muiFormControl: D,
      states: ["variant", "error"]
    }), j = F.variant || M, U = {
      ...n,
      variant: j,
      classes: a
    }, $ = pje(U), {
      root: q,
      ...B
    } = $, G = p || {
      standard: /* @__PURE__ */ S.jsx(mje, {
        ownerState: U
      }),
      outlined: /* @__PURE__ */ S.jsx(hje, {
        label: h,
        ownerState: U
      }),
      filled: /* @__PURE__ */ S.jsx(gje, {
        ownerState: U
      })
    }[j], W = Zn(t, gh(G));
    return /* @__PURE__ */ S.jsx(C.Fragment, {
      children: /* @__PURE__ */ C.cloneElement(G, {
        // Most of the logic is implemented in `SelectInput`.
        // The `Select` component is a simple API wrapper to expose something better to play with.
        inputComponent: A,
        inputProps: {
          children: o,
          error: F.error,
          IconComponent: c,
          variant: j,
          type: void 0,
          // We render a select. We can ignore the type provided by the `Input`.
          multiple: v,
          ...w ? {
            id: f
          } : {
            autoWidth: r,
            defaultOpen: s,
            displayEmpty: u,
            labelId: y,
            MenuProps: b,
            onClose: _,
            onOpen: k,
            open: E,
            renderValue: P,
            SelectDisplayProps: {
              id: f,
              ...O
            }
          },
          ...g,
          classes: g ? wr(B, g.classes) : B,
          ...p ? p.props.inputProps : {}
        },
        ...(v && w || u) && j === "outlined" ? {
          notched: !0
        } : {},
        ref: W,
        className: Le(G.props.className, i, $.root),
        // If a custom input is provided via 'input' prop, do not allow 'variant' to be propagated to it's root element. See https://github.com/mui/material-ui/issues/33894.
        ...!p && {
          variant: j
        },
        ...I
      })
    });
  });
  fU.muiName = "Select";
  function vje(e) {
    return rt("MuiTextField", e);
  }
  tt("MuiTextField", ["root"]);
  const yje = {
    standard: _O,
    filled: EO,
    outlined: CO
  }, bje = (e) => {
    const {
      classes: t
    } = e;
    return nt({
      root: ["root"]
    }, vje, t);
  }, wje = Me(PO, {
    name: "MuiTextField",
    slot: "Root"
  })({}), jO = /* @__PURE__ */ C.forwardRef(function(e, t) {
    const n = lt({
      props: e,
      name: "MuiTextField"
    }), {
      autoComplete: r,
      autoFocus: o = !1,
      children: a,
      className: i,
      color: s = "primary",
      defaultValue: u,
      disabled: c = !1,
      error: f = !1,
      FormHelperTextProps: p,
      fullWidth: g = !1,
      helperText: h,
      id: y,
      InputLabelProps: b,
      inputProps: v,
      InputProps: w,
      inputRef: _,
      label: k,
      maxRows: E,
      minRows: P,
      multiline: O = !1,
      name: M,
      onBlur: I,
      onChange: A,
      onFocus: D,
      placeholder: F,
      required: j = !1,
      rows: U,
      select: $ = !1,
      SelectProps: q,
      slots: B = {},
      slotProps: G = {},
      type: W,
      value: Y,
      variant: z = "outlined",
      ...L
    } = n, K = {
      ...n,
      autoFocus: o,
      color: s,
      disabled: c,
      error: f,
      fullWidth: g,
      multiline: O,
      required: j,
      select: $,
      variant: z
    }, T = bje(K), V = $d(y), X = h && V ? `${V}-helper-text` : void 0, Q = k && V ? `${V}-label` : void 0, ne = yje[z], te = {
      slots: B,
      slotProps: {
        input: w,
        inputLabel: b,
        htmlInput: v,
        formHelperText: p,
        select: q,
        ...G
      }
    }, ae = {}, ce = te.slotProps.inputLabel;
    z === "outlined" && (ce && typeof ce.shrink < "u" && (ae.notched = ce.shrink), ae.label = k), $ && ((!q || !q.native) && (ae.id = void 0), ae["aria-describedby"] = void 0);
    const [Z, ee] = sn("root", {
      elementType: wje,
      shouldForwardComponentProp: !0,
      externalForwardedProps: {
        ...te,
        ...L
      },
      ownerState: K,
      className: Le(T.root, i),
      ref: t,
      additionalProps: {
        disabled: c,
        error: f,
        fullWidth: g,
        required: j,
        color: s,
        variant: z
      }
    }), [oe, le] = sn("input", {
      elementType: ne,
      externalForwardedProps: te,
      additionalProps: ae,
      ownerState: K
    }), [be, ke] = sn("inputLabel", {
      elementType: nRe,
      externalForwardedProps: te,
      ownerState: K
    }), [De, ze] = sn("htmlInput", {
      elementType: "input",
      externalForwardedProps: te,
      ownerState: K
    }), [Ue, He] = sn("formHelperText", {
      elementType: OO,
      externalForwardedProps: te,
      ownerState: K
    }), [Pe, It] = sn("select", {
      elementType: fU,
      externalForwardedProps: te,
      ownerState: K
    }), Xe = /* @__PURE__ */ S.jsx(oe, {
      "aria-describedby": X,
      autoComplete: r,
      autoFocus: o,
      defaultValue: u,
      fullWidth: g,
      multiline: O,
      name: M,
      rows: U,
      maxRows: E,
      minRows: P,
      type: W,
      value: Y,
      id: V,
      inputRef: _,
      onBlur: I,
      onChange: A,
      onFocus: D,
      placeholder: F,
      inputProps: ze,
      slots: {
        input: B.htmlInput ? De : void 0
      },
      ...le
    });
    return /* @__PURE__ */ S.jsxs(Z, {
      ...ee,
      children: [k != null && k !== "" && /* @__PURE__ */ S.jsx(be, {
        htmlFor: V,
        id: Q,
        ...ke,
        children: k
      }), $ ? /* @__PURE__ */ S.jsx(Pe, {
        "aria-describedby": X,
        id: V,
        labelId: Q,
        value: Y,
        input: Xe,
        ...It,
        children: a
      }) : Xe, h && /* @__PURE__ */ S.jsx(Ue, {
        id: X,
        ...He,
        children: h
      })]
    });
  }), xje = ["date", "datetime-local", "file", "time"];
  function kje(e) {
    const {
      id: t,
      name: n,
      // remove this from textFieldProps
      htmlName: r,
      placeholder: o,
      required: a,
      readonly: i,
      disabled: s,
      type: u,
      label: c,
      hideLabel: f,
      hideError: p,
      value: g,
      onChange: h,
      onChangeOverride: y,
      onBlur: b,
      onFocus: v,
      autofocus: w,
      options: _,
      schema: k,
      uiSchema: E,
      rawErrors: P = [],
      errorSchema: O,
      registry: M,
      InputLabelProps: I,
      ...A
    } = e, D = x1(k, u, _), { step: F, min: j, max: U, accept: $, ...q } = D, B = { step: F, min: j, max: U, accept: $, ...k.examples ? { list: _m(t) } : void 0 }, G = ({ target: { value: L } }) => h(L === "" ? _.emptyValue : L), W = ({ target: L }) => b(t, L && L.value), Y = ({ target: L }) => v(t, L && L.value), z = xje.includes(u) ? {
      ...I,
      shrink: !0
    } : I;
    return S.jsxs(S.Fragment, { children: [S.jsx(jO, { id: t, name: r || t, placeholder: o, label: Ru(c || void 0, f, void 0), autoFocus: w, required: a, disabled: s || i, slotProps: { htmlInput: B, inputLabel: z }, ...q, value: g || g === 0 ? g : "", error: P.length > 0, onChange: y || G, onBlur: W, onFocus: Y, ...A, "aria-describedby": vo(t, !!k.examples) }), Array.isArray(k.examples) && S.jsx("datalist", { id: _m(t), children: k.examples.concat(k.default && !k.examples.includes(k.default) ? [k.default] : []).map((L) => S.jsx("option", { value: L }, L)) })] });
  }
  function Sje(e) {
    return rt("MuiTypography", e);
  }
  const BL = tt("MuiTypography", ["root", "h1", "h2", "h3", "h4", "h5", "h6", "subtitle1", "subtitle2", "body1", "body2", "inherit", "button", "caption", "overline", "alignLeft", "alignRight", "alignCenter", "alignJustify", "noWrap", "gutterBottom", "paragraph"]), _je = {
    primary: !0,
    secondary: !0,
    error: !0,
    info: !0,
    success: !0,
    warning: !0,
    textPrimary: !0,
    textSecondary: !0,
    textDisabled: !0
  }, Eje = lQ(), Cje = (e) => {
    const {
      align: t,
      gutterBottom: n,
      noWrap: r,
      paragraph: o,
      variant: a,
      classes: i
    } = e, s = {
      root: ["root", a, e.align !== "inherit" && `align${$e(t)}`, n && "gutterBottom", r && "noWrap", o && "paragraph"]
    };
    return nt(s, Sje, i);
  }, Pje = Me("span", {
    name: "MuiTypography",
    slot: "Root",
    overridesResolver: (e, t) => {
      const {
        ownerState: n
      } = e;
      return [t.root, n.variant && t[n.variant], n.align !== "inherit" && t[`align${$e(n.align)}`], n.noWrap && t.noWrap, n.gutterBottom && t.gutterBottom, n.paragraph && t.paragraph];
    }
  })(at(({
    theme: e
  }) => ({
    margin: 0,
    variants: [{
      props: {
        variant: "inherit"
      },
      style: {
        // Some elements, like <button> on Chrome have default font that doesn't inherit, reset this.
        font: "inherit",
        lineHeight: "inherit",
        letterSpacing: "inherit"
      }
    }, ...Object.entries(e.typography).filter(([t, n]) => t !== "inherit" && n && typeof n == "object").map(([t, n]) => ({
      props: {
        variant: t
      },
      style: n
    })), ...Object.entries(e.palette).filter(xr()).map(([t]) => ({
      props: {
        color: t
      },
      style: {
        color: (e.vars || e).palette[t].main
      }
    })), ...Object.entries(e.palette?.text || {}).filter(([, t]) => typeof t == "string").map(([t]) => ({
      props: {
        color: `text${$e(t)}`
      },
      style: {
        color: (e.vars || e).palette.text[t]
      }
    })), {
      props: ({
        ownerState: t
      }) => t.align !== "inherit",
      style: {
        textAlign: "var(--Typography-textAlign)"
      }
    }, {
      props: ({
        ownerState: t
      }) => t.noWrap,
      style: {
        overflow: "hidden",
        textOverflow: "ellipsis",
        whiteSpace: "nowrap"
      }
    }, {
      props: ({
        ownerState: t
      }) => t.gutterBottom,
      style: {
        marginBottom: "0.35em"
      }
    }, {
      props: ({
        ownerState: t
      }) => t.paragraph,
      style: {
        marginBottom: 16
      }
    }]
  }))), VL = {
    h1: "h1",
    h2: "h2",
    h3: "h3",
    h4: "h4",
    h5: "h5",
    h6: "h6",
    subtitle1: "h6",
    subtitle2: "h6",
    body1: "p",
    body2: "p",
    inherit: "p"
  }, Fa = /* @__PURE__ */ C.forwardRef(function(e, t) {
    const {
      color: n,
      ...r
    } = lt({
      props: e,
      name: "MuiTypography"
    }), o = !_je[n], a = Eje({
      ...r,
      ...o && {
        color: n
      }
    }), {
      align: i = "inherit",
      className: s,
      component: u,
      gutterBottom: c = !1,
      noWrap: f = !1,
      paragraph: p = !1,
      variant: g = "body1",
      variantMapping: h = VL,
      ...y
    } = a, b = {
      ...a,
      align: i,
      color: n,
      className: s,
      component: u,
      gutterBottom: c,
      noWrap: f,
      paragraph: p,
      variant: g,
      variantMapping: h
    }, v = u || (p ? "p" : h[g] || VL[g]) || "span", w = Cje(b);
    return /* @__PURE__ */ S.jsx(Pje, {
      as: v,
      ref: t,
      className: Le(w.root, s),
      ...y,
      ownerState: b,
      style: {
        ...i !== "inherit" && {
          "--Typography-textAlign": i
        },
        ...y.style
      }
    });
  });
  function Oje(e) {
    const { id: t, description: n, registry: r, uiSchema: o } = e;
    return n ? S.jsx(Fa, { id: t, variant: "subtitle2", style: { marginTop: "5px" }, children: S.jsx(wO, { description: n, registry: r, uiSchema: o }) }) : null;
  }
  const Nje = mo(/* @__PURE__ */ S.jsx("path", {
    d: "M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2m1 15h-2v-2h2zm0-4h-2V7h2z"
  }));
  function Mje(e) {
    return rt("MuiListItem", e);
  }
  tt("MuiListItem", ["root", "container", "dense", "alignItemsFlexStart", "divider", "gutters", "padding", "secondaryAction"]);
  const Rje = tt("MuiListItemButton", ["root", "focusVisible", "dense", "alignItemsFlexStart", "disabled", "divider", "gutters", "selected"]);
  function jje(e) {
    return rt("MuiListItemSecondaryAction", e);
  }
  tt("MuiListItemSecondaryAction", ["root", "disableGutters"]);
  const Ije = (e) => {
    const {
      disableGutters: t,
      classes: n
    } = e;
    return nt({
      root: ["root", t && "disableGutters"]
    }, jje, n);
  }, Aje = Me("div", {
    name: "MuiListItemSecondaryAction",
    slot: "Root",
    overridesResolver: (e, t) => {
      const {
        ownerState: n
      } = e;
      return [t.root, n.disableGutters && t.disableGutters];
    }
  })({
    position: "absolute",
    right: 16,
    top: "50%",
    transform: "translateY(-50%)",
    variants: [{
      props: ({
        ownerState: e
      }) => e.disableGutters,
      style: {
        right: 0
      }
    }]
  }), pU = /* @__PURE__ */ C.forwardRef(function(e, t) {
    const n = lt({
      props: e,
      name: "MuiListItemSecondaryAction"
    }), {
      className: r,
      ...o
    } = n, a = C.useContext(Bi), i = {
      ...n,
      disableGutters: a.disableGutters
    }, s = Ije(i);
    return /* @__PURE__ */ S.jsx(Aje, {
      className: Le(s.root, r),
      ownerState: i,
      ref: t,
      ...o
    });
  });
  pU.muiName = "ListItemSecondaryAction";
  const $je = (e, t) => {
    const {
      ownerState: n
    } = e;
    return [t.root, n.dense && t.dense, n.alignItems === "flex-start" && t.alignItemsFlexStart, n.divider && t.divider, !n.disableGutters && t.gutters, !n.disablePadding && t.padding, n.hasSecondaryAction && t.secondaryAction];
  }, Dje = (e) => {
    const {
      alignItems: t,
      classes: n,
      dense: r,
      disableGutters: o,
      disablePadding: a,
      divider: i,
      hasSecondaryAction: s
    } = e;
    return nt({
      root: ["root", r && "dense", !o && "gutters", !a && "padding", i && "divider", t === "flex-start" && "alignItemsFlexStart", s && "secondaryAction"],
      container: ["container"],
      secondaryAction: ["secondaryAction"]
    }, Mje, n);
  }, Lje = Me("div", {
    name: "MuiListItem",
    slot: "Root",
    overridesResolver: $je
  })(at(({
    theme: e
  }) => ({
    display: "flex",
    justifyContent: "flex-start",
    alignItems: "center",
    position: "relative",
    textDecoration: "none",
    width: "100%",
    boxSizing: "border-box",
    textAlign: "left",
    variants: [{
      props: ({
        ownerState: t
      }) => !t.disablePadding,
      style: {
        paddingTop: 8,
        paddingBottom: 8
      }
    }, {
      props: ({
        ownerState: t
      }) => !t.disablePadding && t.dense,
      style: {
        paddingTop: 4,
        paddingBottom: 4
      }
    }, {
      props: ({
        ownerState: t
      }) => !t.disablePadding && !t.disableGutters,
      style: {
        paddingLeft: 16,
        paddingRight: 16
      }
    }, {
      props: ({
        ownerState: t
      }) => !t.disablePadding && !!t.secondaryAction,
      style: {
        // Add some space to avoid collision as `ListItemSecondaryAction`
        // is absolutely positioned.
        paddingRight: 48
      }
    }, {
      props: ({
        ownerState: t
      }) => !!t.secondaryAction,
      style: {
        [`& > .${Rje.root}`]: {
          paddingRight: 48
        }
      }
    }, {
      props: {
        alignItems: "flex-start"
      },
      style: {
        alignItems: "flex-start"
      }
    }, {
      props: ({
        ownerState: t
      }) => t.divider,
      style: {
        borderBottom: `1px solid ${(e.vars || e).palette.divider}`,
        backgroundClip: "padding-box"
      }
    }, {
      props: ({
        ownerState: t
      }) => t.button,
      style: {
        transition: e.transitions.create("background-color", {
          duration: e.transitions.duration.shortest
        }),
        "&:hover": {
          textDecoration: "none",
          backgroundColor: (e.vars || e).palette.action.hover,
          // Reset on touch devices, it doesn't add specificity
          "@media (hover: none)": {
            backgroundColor: "transparent"
          }
        }
      }
    }, {
      props: ({
        ownerState: t
      }) => t.hasSecondaryAction,
      style: {
        // Add some space to avoid collision as `ListItemSecondaryAction`
        // is absolutely positioned.
        paddingRight: 48
      }
    }]
  }))), Fje = Me("li", {
    name: "MuiListItem",
    slot: "Container"
  })({
    position: "relative"
  }), mU = /* @__PURE__ */ C.forwardRef(function(e, t) {
    const n = lt({
      props: e,
      name: "MuiListItem"
    }), {
      alignItems: r = "center",
      children: o,
      className: a,
      component: i,
      components: s = {},
      componentsProps: u = {},
      ContainerComponent: c = "li",
      ContainerProps: {
        className: f,
        ...p
      } = {},
      dense: g = !1,
      disableGutters: h = !1,
      disablePadding: y = !1,
      divider: b = !1,
      secondaryAction: v,
      slotProps: w = {},
      slots: _ = {},
      ...k
    } = n, E = C.useContext(Bi), P = C.useMemo(() => ({
      dense: g || E.dense || !1,
      alignItems: r,
      disableGutters: h
    }), [r, E.dense, g, h]), O = C.useRef(null), M = C.Children.toArray(o), I = M.length && Op(M[M.length - 1], ["ListItemSecondaryAction"]), A = {
      ...n,
      alignItems: r,
      dense: P.dense,
      disableGutters: h,
      disablePadding: y,
      divider: b,
      hasSecondaryAction: I
    }, D = Dje(A), F = Zn(O, t), j = {
      slots: _,
      slotProps: w
    }, [U, $] = sn("secondaryAction", {
      elementType: pU,
      externalForwardedProps: j,
      ownerState: A,
      className: D.secondaryAction
    }), q = _.root || s.Root || Lje, B = w.root || u.root || {}, G = {
      className: Le(D.root, B.className, a),
      ...k
    };
    let W = i || "li";
    return I ? (W = !G.component && !i ? "div" : W, c === "li" && (W === "li" ? W = "div" : G.component === "li" && (G.component = "div")), /* @__PURE__ */ S.jsx(Bi.Provider, {
      value: P,
      children: /* @__PURE__ */ S.jsxs(Fje, {
        as: c,
        className: Le(D.container, f),
        ref: F,
        ownerState: A,
        ...p,
        children: [/* @__PURE__ */ S.jsx(q, {
          ...B,
          ...!Va(q) && {
            as: W,
            ownerState: {
              ...A,
              ...B.ownerState
            }
          },
          ...G,
          children: M
        }), M.pop()]
      })
    })) : /* @__PURE__ */ S.jsx(Bi.Provider, {
      value: P,
      children: /* @__PURE__ */ S.jsxs(q, {
        ...B,
        as: W,
        ref: F,
        ...!Va(q) && {
          ownerState: {
            ...A,
            ...B.ownerState
          }
        },
        ...G,
        children: [M, v && /* @__PURE__ */ S.jsx(U, {
          ...$,
          children: v
        })]
      })
    });
  });
  function Tje(e) {
    return rt("MuiListItemIcon", e);
  }
  const UL = tt("MuiListItemIcon", ["root", "alignItemsFlexStart"]), zje = (e) => {
    const {
      alignItems: t,
      classes: n
    } = e;
    return nt({
      root: ["root", t === "flex-start" && "alignItemsFlexStart"]
    }, Tje, n);
  }, Bje = Me("div", {
    name: "MuiListItemIcon",
    slot: "Root",
    overridesResolver: (e, t) => {
      const {
        ownerState: n
      } = e;
      return [t.root, n.alignItems === "flex-start" && t.alignItemsFlexStart];
    }
  })(at(({
    theme: e
  }) => ({
    minWidth: 56,
    color: (e.vars || e).palette.action.active,
    flexShrink: 0,
    display: "inline-flex",
    variants: [{
      props: {
        alignItems: "flex-start"
      },
      style: {
        marginTop: 8
      }
    }]
  }))), Vje = /* @__PURE__ */ C.forwardRef(function(e, t) {
    const n = lt({
      props: e,
      name: "MuiListItemIcon"
    }), {
      className: r,
      ...o
    } = n, a = C.useContext(Bi), i = {
      ...n,
      alignItems: a.alignItems
    }, s = zje(i);
    return /* @__PURE__ */ S.jsx(Bje, {
      className: Le(s.root, r),
      ownerState: i,
      ref: t,
      ...o
    });
  });
  function Uje(e) {
    return rt("MuiListItemText", e);
  }
  const Yc = tt("MuiListItemText", ["root", "multiline", "dense", "inset", "primary", "secondary"]), Hje = (e) => {
    const {
      classes: t,
      inset: n,
      primary: r,
      secondary: o,
      dense: a
    } = e;
    return nt({
      root: ["root", n && "inset", a && "dense", r && o && "multiline"],
      primary: ["primary"],
      secondary: ["secondary"]
    }, Uje, t);
  }, Wje = Me("div", {
    name: "MuiListItemText",
    slot: "Root",
    overridesResolver: (e, t) => {
      const {
        ownerState: n
      } = e;
      return [{
        [`& .${Yc.primary}`]: t.primary
      }, {
        [`& .${Yc.secondary}`]: t.secondary
      }, t.root, n.inset && t.inset, n.primary && n.secondary && t.multiline, n.dense && t.dense];
    }
  })({
    flex: "1 1 auto",
    minWidth: 0,
    marginTop: 4,
    marginBottom: 4,
    [`.${BL.root}:where(& .${Yc.primary})`]: {
      display: "block"
    },
    [`.${BL.root}:where(& .${Yc.secondary})`]: {
      display: "block"
    },
    variants: [{
      props: ({
        ownerState: e
      }) => e.primary && e.secondary,
      style: {
        marginTop: 6,
        marginBottom: 6
      }
    }, {
      props: ({
        ownerState: e
      }) => e.inset,
      style: {
        paddingLeft: 56
      }
    }]
  }), qje = /* @__PURE__ */ C.forwardRef(function(e, t) {
    const n = lt({
      props: e,
      name: "MuiListItemText"
    }), {
      children: r,
      className: o,
      disableTypography: a = !1,
      inset: i = !1,
      primary: s,
      primaryTypographyProps: u,
      secondary: c,
      secondaryTypographyProps: f,
      slots: p = {},
      slotProps: g = {},
      ...h
    } = n, {
      dense: y
    } = C.useContext(Bi);
    let b = s ?? r, v = c;
    const w = {
      ...n,
      disableTypography: a,
      inset: i,
      primary: !!b,
      secondary: !!v,
      dense: y
    }, _ = Hje(w), k = {
      slots: p,
      slotProps: {
        primary: u,
        secondary: f,
        ...g
      }
    }, [E, P] = sn("root", {
      className: Le(_.root, o),
      elementType: Wje,
      externalForwardedProps: {
        ...k,
        ...h
      },
      ownerState: w,
      ref: t
    }), [O, M] = sn("primary", {
      className: _.primary,
      elementType: Fa,
      externalForwardedProps: k,
      ownerState: w
    }), [I, A] = sn("secondary", {
      className: _.secondary,
      elementType: Fa,
      externalForwardedProps: k,
      ownerState: w
    });
    return b != null && b.type !== Fa && !a && (b = /* @__PURE__ */ S.jsx(O, {
      variant: y ? "body2" : "body1",
      component: M?.variant ? void 0 : "span",
      ...M,
      children: b
    })), v != null && v.type !== Fa && !a && (v = /* @__PURE__ */ S.jsx(I, {
      variant: "body2",
      color: "textSecondary",
      ...A,
      children: v
    })), /* @__PURE__ */ S.jsxs(E, {
      ...P,
      children: [b, v]
    });
  });
  function Kje({ errors: e, registry: t }) {
    const { translateString: n } = t;
    return S.jsx(Cx, { elevation: 2, children: S.jsxs(pl, { mb: 2, p: 2, children: [S.jsx(Fa, { variant: "h6", children: n(ht.ErrorsLabel) }), S.jsx(NO, { dense: !0, children: e.map((r, o) => S.jsxs(mU, { children: [S.jsx(Vje, { children: S.jsx(Nje, { color: "error" }) }), S.jsx(qje, { primary: r.stack })] }, o)) })] }) });
  }
  const Gje = mo(/* @__PURE__ */ S.jsx("path", {
    d: "m20 12-1.41-1.41L13 16.17V4h-2v12.17l-5.58-5.59L4 12l8 8z"
  })), Xje = mo(/* @__PURE__ */ S.jsx("path", {
    d: "m4 12 1.41 1.41L11 7.83V20h2V7.83l5.58 5.59L20 12l-8-8z"
  })), Yje = mo(/* @__PURE__ */ S.jsx("path", {
    d: "M16 1H4c-1.1 0-2 .9-2 2v14h2V3h12zm3 4H8c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h11c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2m0 16H8V7h11z"
  })), Jje = mo(/* @__PURE__ */ S.jsx("path", {
    d: "M19 13H5v-2h14z"
  }));
  function vh(e) {
    const { icon: t, color: n, uiSchema: r, registry: o, ...a } = e;
    return S.jsx(oU, { ...a, size: "small", color: n, children: t });
  }
  function Qje(e) {
    const { registry: { translateString: t } } = e;
    return S.jsx(vh, { title: t(ht.CopyButton), ...e, icon: S.jsx(Yje, { fontSize: "small" }) });
  }
  function Zje(e) {
    const { registry: { translateString: t } } = e;
    return S.jsx(vh, { title: t(ht.MoveDownButton), ...e, icon: S.jsx(Gje, { fontSize: "small" }) });
  }
  function e5e(e) {
    const { registry: { translateString: t } } = e;
    return S.jsx(vh, { title: t(ht.MoveUpButton), ...e, icon: S.jsx(Xje, { fontSize: "small" }) });
  }
  function hU(e) {
    const { iconType: t, ...n } = e, { registry: { translateString: r } } = n;
    return S.jsx(vh, { title: r(ht.RemoveButton), ...n, color: "error", icon: S.jsx(Jje, { fontSize: t === "default" ? void 0 : "small" }) });
  }
  function t5e(e) {
    const { errors: t = [], fieldPathId: n } = e;
    if (t.length === 0)
      return null;
    const r = lO(n);
    return S.jsx(NO, { id: r, dense: !0, disablePadding: !0, children: t.map((o, a) => S.jsx(mU, { disableGutters: !0, children: S.jsx(OO, { component: "div", id: `${r}-${a}`, children: o }) }, a)) });
  }
  function n5e(e) {
    const { fieldPathId: t, help: n, uiSchema: r, registry: o } = e;
    return n ? S.jsx(OO, { component: "div", id: uO(t), style: { marginTop: "5px" }, children: S.jsx(xO, { help: n, registry: o, uiSchema: r }) }) : null;
  }
  function r5e(e) {
    const { id: t, children: n, classNames: r, style: o, disabled: a, displayLabel: i, hidden: s, label: u, onKeyRename: c, onKeyRenameBlur: f, onRemoveProperty: p, readonly: g, required: h, rawErrors: y = [], errors: b, help: v, description: w, rawDescription: _, schema: k, uiSchema: E, registry: P } = e, O = Qe(E), M = et("WrapIfAdditionalTemplate", P, O);
    if (s)
      return S.jsx("div", { style: { display: "none" }, children: n });
    const I = O.widget === "checkbox";
    return S.jsx(M, { classNames: r, style: o, disabled: a, id: t, label: u, displayLabel: i, rawDescription: _, onKeyRename: c, onKeyRenameBlur: f, onRemoveProperty: p, readonly: g, required: h, schema: k, uiSchema: E, registry: P, children: S.jsxs(PO, { fullWidth: !0, error: !!y.length, required: h, children: [n, i && !I && _ ? S.jsx(Fa, { variant: "caption", color: "textSecondary", children: w }) : null, b, v] }) });
  }
  function o5e(e) {
    const { children: t, column: n, ...r } = e;
    return S.jsx(dr, { container: !n, ...r, children: t });
  }
  function a5e(e) {
    const { optionSchemaField: t, selector: n } = e;
    return S.jsxs(pl, { sx: { mb: 2 }, children: [S.jsx(PO, { fullWidth: !0, sx: { mb: 2 }, children: n }), t] });
  }
  function i5e(e) {
    const { description: t, title: n, properties: r, required: o, disabled: a, readonly: i, uiSchema: s, fieldPathId: u, schema: c, formData: f, optionalDataControl: p, onAddProperty: g, registry: h } = e, y = Qe(s), b = et("TitleFieldTemplate", h, y), v = et("DescriptionFieldTemplate", h, y), w = !i && !a, { ButtonTemplates: { AddButton: _ } } = h.templates;
    return S.jsxs(S.Fragment, { children: [n && S.jsx(b, { id: yx(u), title: n, required: o, schema: c, uiSchema: s, registry: h, optionalDataControl: w ? p : void 0 }), t && S.jsx(v, { id: Mu(u), description: t, schema: c, uiSchema: s, registry: h }), S.jsxs(dr, { container: !0, spacing: 2, style: { marginTop: "10px" }, children: [w ? void 0 : p, r.map((k, E) => (
      // Remove the <Grid> if the inner element is hidden as the <Grid>
      // itself would otherwise still take up space.
      k.hidden ? k.content : S.jsx(dr, { size: { xs: 12 }, style: { marginBottom: "10px" }, children: k.content }, E)
    ))] }), aV(c, s, f) && S.jsx(dr, { container: !0, justifyContent: "flex-end", children: S.jsx(dr, { children: S.jsx(_, { id: Da(u, "add"), className: "rjsf-object-property-expand", onClick: g, disabled: a || i, uiSchema: s, registry: h }) }) })] });
  }
  function s5e(e) {
    const { id: t, registry: n, label: r, onAddClick: o, onRemoveClick: a } = e;
    return o ? S.jsx(vh, { id: t, registry: n, className: "rjsf-add-optional-data", onClick: o, title: r, icon: S.jsx(nU, { fontSize: "small" }) }) : a ? S.jsx(hU, { id: t, registry: n, className: "rjsf-remove-optional-data", onClick: a, title: r }) : S.jsx("em", { id: t, children: r });
  }
  function l5e(e) {
    return rt("MuiButton", e);
  }
  const Wl = tt("MuiButton", ["root", "text", "textInherit", "textPrimary", "textSecondary", "textSuccess", "textError", "textInfo", "textWarning", "outlined", "outlinedInherit", "outlinedPrimary", "outlinedSecondary", "outlinedSuccess", "outlinedError", "outlinedInfo", "outlinedWarning", "contained", "containedInherit", "containedPrimary", "containedSecondary", "containedSuccess", "containedError", "containedInfo", "containedWarning", "disableElevation", "focusVisible", "disabled", "colorInherit", "colorPrimary", "colorSecondary", "colorSuccess", "colorError", "colorInfo", "colorWarning", "textSizeSmall", "textSizeMedium", "textSizeLarge", "outlinedSizeSmall", "outlinedSizeMedium", "outlinedSizeLarge", "containedSizeSmall", "containedSizeMedium", "containedSizeLarge", "sizeMedium", "sizeSmall", "sizeLarge", "fullWidth", "startIcon", "endIcon", "icon", "iconSizeSmall", "iconSizeMedium", "iconSizeLarge", "loading", "loadingWrapper", "loadingIconPlaceholder", "loadingIndicator", "loadingPositionCenter", "loadingPositionStart", "loadingPositionEnd"]), u5e = /* @__PURE__ */ C.createContext({}), c5e = /* @__PURE__ */ C.createContext(void 0), d5e = (e) => {
    const {
      color: t,
      disableElevation: n,
      fullWidth: r,
      size: o,
      variant: a,
      loading: i,
      loadingPosition: s,
      classes: u
    } = e, c = {
      root: ["root", i && "loading", a, `${a}${$e(t)}`, `size${$e(o)}`, `${a}Size${$e(o)}`, `color${$e(t)}`, n && "disableElevation", r && "fullWidth", i && `loadingPosition${$e(s)}`],
      startIcon: ["icon", "startIcon", `iconSize${$e(o)}`],
      endIcon: ["icon", "endIcon", `iconSize${$e(o)}`],
      loadingIndicator: ["loadingIndicator"],
      loadingWrapper: ["loadingWrapper"]
    }, f = nt(c, l5e, u);
    return {
      ...u,
      // forward the focused, disabled, etc. classes to the ButtonBase
      ...f
    };
  }, gU = [{
    props: {
      size: "small"
    },
    style: {
      "& > *:nth-of-type(1)": {
        fontSize: 18
      }
    }
  }, {
    props: {
      size: "medium"
    },
    style: {
      "& > *:nth-of-type(1)": {
        fontSize: 20
      }
    }
  }, {
    props: {
      size: "large"
    },
    style: {
      "& > *:nth-of-type(1)": {
        fontSize: 22
      }
    }
  }], f5e = Me(zm, {
    shouldForwardProp: (e) => kr(e) || e === "classes",
    name: "MuiButton",
    slot: "Root",
    overridesResolver: (e, t) => {
      const {
        ownerState: n
      } = e;
      return [t.root, t[n.variant], t[`${n.variant}${$e(n.color)}`], t[`size${$e(n.size)}`], t[`${n.variant}Size${$e(n.size)}`], n.color === "inherit" && t.colorInherit, n.disableElevation && t.disableElevation, n.fullWidth && t.fullWidth, n.loading && t.loading];
    }
  })(at(({
    theme: e
  }) => {
    const t = e.palette.mode === "light" ? e.palette.grey[300] : e.palette.grey[800], n = e.palette.mode === "light" ? e.palette.grey.A100 : e.palette.grey[700];
    return {
      ...e.typography.button,
      minWidth: 64,
      padding: "6px 16px",
      border: 0,
      borderRadius: (e.vars || e).shape.borderRadius,
      transition: e.transitions.create(["background-color", "box-shadow", "border-color", "color"], {
        duration: e.transitions.duration.short
      }),
      "&:hover": {
        textDecoration: "none"
      },
      [`&.${Wl.disabled}`]: {
        color: (e.vars || e).palette.action.disabled
      },
      variants: [{
        props: {
          variant: "contained"
        },
        style: {
          color: "var(--variant-containedColor)",
          backgroundColor: "var(--variant-containedBg)",
          boxShadow: (e.vars || e).shadows[2],
          "&:hover": {
            boxShadow: (e.vars || e).shadows[4],
            // Reset on touch devices, it doesn't add specificity
            "@media (hover: none)": {
              boxShadow: (e.vars || e).shadows[2]
            }
          },
          "&:active": {
            boxShadow: (e.vars || e).shadows[8]
          },
          [`&.${Wl.focusVisible}`]: {
            boxShadow: (e.vars || e).shadows[6]
          },
          [`&.${Wl.disabled}`]: {
            color: (e.vars || e).palette.action.disabled,
            boxShadow: (e.vars || e).shadows[0],
            backgroundColor: (e.vars || e).palette.action.disabledBackground
          }
        }
      }, {
        props: {
          variant: "outlined"
        },
        style: {
          padding: "5px 15px",
          border: "1px solid currentColor",
          borderColor: "var(--variant-outlinedBorder, currentColor)",
          backgroundColor: "var(--variant-outlinedBg)",
          color: "var(--variant-outlinedColor)",
          [`&.${Wl.disabled}`]: {
            border: `1px solid ${(e.vars || e).palette.action.disabledBackground}`
          }
        }
      }, {
        props: {
          variant: "text"
        },
        style: {
          padding: "6px 8px",
          color: "var(--variant-textColor)",
          backgroundColor: "var(--variant-textBg)"
        }
      }, ...Object.entries(e.palette).filter(xr()).map(([r]) => ({
        props: {
          color: r
        },
        style: {
          "--variant-textColor": (e.vars || e).palette[r].main,
          "--variant-outlinedColor": (e.vars || e).palette[r].main,
          "--variant-outlinedBorder": e.alpha((e.vars || e).palette[r].main, 0.5),
          "--variant-containedColor": (e.vars || e).palette[r].contrastText,
          "--variant-containedBg": (e.vars || e).palette[r].main,
          "@media (hover: hover)": {
            "&:hover": {
              "--variant-containedBg": (e.vars || e).palette[r].dark,
              "--variant-textBg": e.alpha((e.vars || e).palette[r].main, (e.vars || e).palette.action.hoverOpacity),
              "--variant-outlinedBorder": (e.vars || e).palette[r].main,
              "--variant-outlinedBg": e.alpha((e.vars || e).palette[r].main, (e.vars || e).palette.action.hoverOpacity)
            }
          }
        }
      })), {
        props: {
          color: "inherit"
        },
        style: {
          color: "inherit",
          borderColor: "currentColor",
          "--variant-containedBg": e.vars ? e.vars.palette.Button.inheritContainedBg : t,
          "@media (hover: hover)": {
            "&:hover": {
              "--variant-containedBg": e.vars ? e.vars.palette.Button.inheritContainedHoverBg : n,
              "--variant-textBg": e.alpha((e.vars || e).palette.text.primary, (e.vars || e).palette.action.hoverOpacity),
              "--variant-outlinedBg": e.alpha((e.vars || e).palette.text.primary, (e.vars || e).palette.action.hoverOpacity)
            }
          }
        }
      }, {
        props: {
          size: "small",
          variant: "text"
        },
        style: {
          padding: "4px 5px",
          fontSize: e.typography.pxToRem(13)
        }
      }, {
        props: {
          size: "large",
          variant: "text"
        },
        style: {
          padding: "8px 11px",
          fontSize: e.typography.pxToRem(15)
        }
      }, {
        props: {
          size: "small",
          variant: "outlined"
        },
        style: {
          padding: "3px 9px",
          fontSize: e.typography.pxToRem(13)
        }
      }, {
        props: {
          size: "large",
          variant: "outlined"
        },
        style: {
          padding: "7px 21px",
          fontSize: e.typography.pxToRem(15)
        }
      }, {
        props: {
          size: "small",
          variant: "contained"
        },
        style: {
          padding: "4px 10px",
          fontSize: e.typography.pxToRem(13)
        }
      }, {
        props: {
          size: "large",
          variant: "contained"
        },
        style: {
          padding: "8px 22px",
          fontSize: e.typography.pxToRem(15)
        }
      }, {
        props: {
          disableElevation: !0
        },
        style: {
          boxShadow: "none",
          "&:hover": {
            boxShadow: "none"
          },
          [`&.${Wl.focusVisible}`]: {
            boxShadow: "none"
          },
          "&:active": {
            boxShadow: "none"
          },
          [`&.${Wl.disabled}`]: {
            boxShadow: "none"
          }
        }
      }, {
        props: {
          fullWidth: !0
        },
        style: {
          width: "100%"
        }
      }, {
        props: {
          loadingPosition: "center"
        },
        style: {
          transition: e.transitions.create(["background-color", "box-shadow", "border-color"], {
            duration: e.transitions.duration.short
          }),
          [`&.${Wl.loading}`]: {
            color: "transparent"
          }
        }
      }]
    };
  })), p5e = Me("span", {
    name: "MuiButton",
    slot: "StartIcon",
    overridesResolver: (e, t) => {
      const {
        ownerState: n
      } = e;
      return [t.startIcon, n.loading && t.startIconLoadingStart, t[`iconSize${$e(n.size)}`]];
    }
  })(({
    theme: e
  }) => ({
    display: "inherit",
    marginRight: 8,
    marginLeft: -4,
    variants: [{
      props: {
        size: "small"
      },
      style: {
        marginLeft: -2
      }
    }, {
      props: {
        loadingPosition: "start",
        loading: !0
      },
      style: {
        transition: e.transitions.create(["opacity"], {
          duration: e.transitions.duration.short
        }),
        opacity: 0
      }
    }, {
      props: {
        loadingPosition: "start",
        loading: !0,
        fullWidth: !0
      },
      style: {
        marginRight: -8
      }
    }, ...gU]
  })), m5e = Me("span", {
    name: "MuiButton",
    slot: "EndIcon",
    overridesResolver: (e, t) => {
      const {
        ownerState: n
      } = e;
      return [t.endIcon, n.loading && t.endIconLoadingEnd, t[`iconSize${$e(n.size)}`]];
    }
  })(({
    theme: e
  }) => ({
    display: "inherit",
    marginRight: -4,
    marginLeft: 8,
    variants: [{
      props: {
        size: "small"
      },
      style: {
        marginRight: -2
      }
    }, {
      props: {
        loadingPosition: "end",
        loading: !0
      },
      style: {
        transition: e.transitions.create(["opacity"], {
          duration: e.transitions.duration.short
        }),
        opacity: 0
      }
    }, {
      props: {
        loadingPosition: "end",
        loading: !0,
        fullWidth: !0
      },
      style: {
        marginLeft: -8
      }
    }, ...gU]
  })), h5e = Me("span", {
    name: "MuiButton",
    slot: "LoadingIndicator"
  })(({
    theme: e
  }) => ({
    display: "none",
    position: "absolute",
    visibility: "visible",
    variants: [{
      props: {
        loading: !0
      },
      style: {
        display: "flex"
      }
    }, {
      props: {
        loadingPosition: "start"
      },
      style: {
        left: 14
      }
    }, {
      props: {
        loadingPosition: "start",
        size: "small"
      },
      style: {
        left: 10
      }
    }, {
      props: {
        variant: "text",
        loadingPosition: "start"
      },
      style: {
        left: 6
      }
    }, {
      props: {
        loadingPosition: "center"
      },
      style: {
        left: "50%",
        transform: "translate(-50%)",
        color: (e.vars || e).palette.action.disabled
      }
    }, {
      props: {
        loadingPosition: "end"
      },
      style: {
        right: 14
      }
    }, {
      props: {
        loadingPosition: "end",
        size: "small"
      },
      style: {
        right: 10
      }
    }, {
      props: {
        variant: "text",
        loadingPosition: "end"
      },
      style: {
        right: 6
      }
    }, {
      props: {
        loadingPosition: "start",
        fullWidth: !0
      },
      style: {
        position: "relative",
        left: -10
      }
    }, {
      props: {
        loadingPosition: "end",
        fullWidth: !0
      },
      style: {
        position: "relative",
        right: -10
      }
    }]
  })), HL = Me("span", {
    name: "MuiButton",
    slot: "LoadingIconPlaceholder"
  })({
    display: "inline-block",
    width: "1em",
    height: "1em"
  }), g5e = /* @__PURE__ */ C.forwardRef(function(e, t) {
    const n = C.useContext(u5e), r = C.useContext(c5e), o = Yp(n, e), a = lt({
      props: o,
      name: "MuiButton"
    }), {
      children: i,
      color: s = "primary",
      component: u = "button",
      className: c,
      disabled: f = !1,
      disableElevation: p = !1,
      disableFocusRipple: g = !1,
      endIcon: h,
      focusVisibleClassName: y,
      fullWidth: b = !1,
      id: v,
      loading: w = null,
      loadingIndicator: _,
      loadingPosition: k = "center",
      size: E = "medium",
      startIcon: P,
      type: O,
      variant: M = "text",
      ...I
    } = a, A = $d(v), D = _ ?? /* @__PURE__ */ S.jsx(rU, {
      "aria-labelledby": A,
      color: "inherit",
      size: 16
    }), F = {
      ...a,
      color: s,
      component: u,
      disabled: f,
      disableElevation: p,
      disableFocusRipple: g,
      fullWidth: b,
      loading: w,
      loadingIndicator: D,
      loadingPosition: k,
      size: E,
      type: O,
      variant: M
    }, j = d5e(F), U = (P || w && k === "start") && /* @__PURE__ */ S.jsx(p5e, {
      className: j.startIcon,
      ownerState: F,
      children: P || /* @__PURE__ */ S.jsx(HL, {
        className: j.loadingIconPlaceholder,
        ownerState: F
      })
    }), $ = (h || w && k === "end") && /* @__PURE__ */ S.jsx(m5e, {
      className: j.endIcon,
      ownerState: F,
      children: h || /* @__PURE__ */ S.jsx(HL, {
        className: j.loadingIconPlaceholder,
        ownerState: F
      })
    }), q = r || "", B = typeof w == "boolean" ? (
      // use plain HTML span to minimize the runtime overhead
      /* @__PURE__ */ S.jsx("span", {
        className: j.loadingWrapper,
        style: {
          display: "contents"
        },
        children: w && /* @__PURE__ */ S.jsx(h5e, {
          className: j.loadingIndicator,
          ownerState: F,
          children: D
        })
      })
    ) : null;
    return /* @__PURE__ */ S.jsxs(f5e, {
      ownerState: F,
      className: Le(n.className, j.root, c, q),
      component: u,
      disabled: f || w,
      focusRipple: !g,
      focusVisibleClassName: Le(j.focusVisible, y),
      ref: t,
      type: O,
      id: w ? A : v,
      ...I,
      classes: j,
      children: [U, k !== "end" && B, i, k === "end" && B, $]
    });
  });
  function v5e({ uiSchema: e }) {
    const { submitText: t, norender: n, props: r = {} } = k1(e);
    return n ? null : S.jsx(pl, { marginTop: 3, children: S.jsx(g5e, { type: "submit", variant: "contained", color: "primary", ...r, children: t }) });
  }
  function y5e(e) {
    return rt("MuiDivider", e);
  }
  const WL = tt("MuiDivider", ["root", "absolute", "fullWidth", "inset", "middle", "flexItem", "light", "vertical", "withChildren", "withChildrenVertical", "textAlignRight", "textAlignLeft", "wrapper", "wrapperVertical"]), b5e = (e) => {
    const {
      absolute: t,
      children: n,
      classes: r,
      flexItem: o,
      light: a,
      orientation: i,
      textAlign: s,
      variant: u
    } = e;
    return nt({
      root: ["root", t && "absolute", u, a && "light", i === "vertical" && "vertical", o && "flexItem", n && "withChildren", n && i === "vertical" && "withChildrenVertical", s === "right" && i !== "vertical" && "textAlignRight", s === "left" && i !== "vertical" && "textAlignLeft"],
      wrapper: ["wrapper", i === "vertical" && "wrapperVertical"]
    }, y5e, r);
  }, w5e = Me("div", {
    name: "MuiDivider",
    slot: "Root",
    overridesResolver: (e, t) => {
      const {
        ownerState: n
      } = e;
      return [t.root, n.absolute && t.absolute, t[n.variant], n.light && t.light, n.orientation === "vertical" && t.vertical, n.flexItem && t.flexItem, n.children && t.withChildren, n.children && n.orientation === "vertical" && t.withChildrenVertical, n.textAlign === "right" && n.orientation !== "vertical" && t.textAlignRight, n.textAlign === "left" && n.orientation !== "vertical" && t.textAlignLeft];
    }
  })(at(({
    theme: e
  }) => ({
    margin: 0,
    // Reset browser default style.
    flexShrink: 0,
    borderWidth: 0,
    borderStyle: "solid",
    borderColor: (e.vars || e).palette.divider,
    borderBottomWidth: "thin",
    variants: [{
      props: {
        absolute: !0
      },
      style: {
        position: "absolute",
        bottom: 0,
        left: 0,
        width: "100%"
      }
    }, {
      props: {
        light: !0
      },
      style: {
        borderColor: e.alpha((e.vars || e).palette.divider, 0.08)
      }
    }, {
      props: {
        variant: "inset"
      },
      style: {
        marginLeft: 72
      }
    }, {
      props: {
        variant: "middle",
        orientation: "horizontal"
      },
      style: {
        marginLeft: e.spacing(2),
        marginRight: e.spacing(2)
      }
    }, {
      props: {
        variant: "middle",
        orientation: "vertical"
      },
      style: {
        marginTop: e.spacing(1),
        marginBottom: e.spacing(1)
      }
    }, {
      props: {
        orientation: "vertical"
      },
      style: {
        height: "100%",
        borderBottomWidth: 0,
        borderRightWidth: "thin"
      }
    }, {
      props: {
        flexItem: !0
      },
      style: {
        alignSelf: "stretch",
        height: "auto"
      }
    }, {
      props: ({
        ownerState: t
      }) => !!t.children,
      style: {
        display: "flex",
        textAlign: "center",
        border: 0,
        borderTopStyle: "solid",
        borderLeftStyle: "solid",
        "&::before, &::after": {
          content: '""',
          alignSelf: "center"
        }
      }
    }, {
      props: ({
        ownerState: t
      }) => t.children && t.orientation !== "vertical",
      style: {
        "&::before, &::after": {
          width: "100%",
          borderTop: `thin solid ${(e.vars || e).palette.divider}`,
          borderTopStyle: "inherit"
        }
      }
    }, {
      props: ({
        ownerState: t
      }) => t.orientation === "vertical" && t.children,
      style: {
        flexDirection: "column",
        "&::before, &::after": {
          height: "100%",
          borderLeft: `thin solid ${(e.vars || e).palette.divider}`,
          borderLeftStyle: "inherit"
        }
      }
    }, {
      props: ({
        ownerState: t
      }) => t.textAlign === "right" && t.orientation !== "vertical",
      style: {
        "&::before": {
          width: "90%"
        },
        "&::after": {
          width: "10%"
        }
      }
    }, {
      props: ({
        ownerState: t
      }) => t.textAlign === "left" && t.orientation !== "vertical",
      style: {
        "&::before": {
          width: "10%"
        },
        "&::after": {
          width: "90%"
        }
      }
    }]
  }))), x5e = Me("span", {
    name: "MuiDivider",
    slot: "Wrapper",
    overridesResolver: (e, t) => {
      const {
        ownerState: n
      } = e;
      return [t.wrapper, n.orientation === "vertical" && t.wrapperVertical];
    }
  })(at(({
    theme: e
  }) => ({
    display: "inline-block",
    paddingLeft: `calc(${e.spacing(1)} * 1.2)`,
    paddingRight: `calc(${e.spacing(1)} * 1.2)`,
    whiteSpace: "nowrap",
    variants: [{
      props: {
        orientation: "vertical"
      },
      style: {
        paddingTop: `calc(${e.spacing(1)} * 1.2)`,
        paddingBottom: `calc(${e.spacing(1)} * 1.2)`
      }
    }]
  }))), EE = /* @__PURE__ */ C.forwardRef(function(e, t) {
    const n = lt({
      props: e,
      name: "MuiDivider"
    }), {
      absolute: r = !1,
      children: o,
      className: a,
      orientation: i = "horizontal",
      component: s = o || i === "vertical" ? "div" : "hr",
      flexItem: u = !1,
      light: c = !1,
      role: f = s !== "hr" ? "separator" : void 0,
      textAlign: p = "center",
      variant: g = "fullWidth",
      ...h
    } = n, y = {
      ...n,
      absolute: r,
      component: s,
      flexItem: u,
      light: c,
      orientation: i,
      role: f,
      textAlign: p,
      variant: g
    }, b = b5e(y);
    return /* @__PURE__ */ S.jsx(w5e, {
      as: s,
      className: Le(b.root, a),
      role: f,
      ref: t,
      ownerState: y,
      "aria-orientation": f === "separator" && (s !== "hr" || i === "vertical") ? i : void 0,
      ...h,
      children: o ? /* @__PURE__ */ S.jsx(x5e, {
        className: b.wrapper,
        ownerState: y,
        children: o
      }) : null
    });
  });
  EE && (EE.muiSkipListHighlight = !0);
  function k5e({ id: e, title: t, optionalDataControl: n }) {
    let r = S.jsx(Fa, { variant: "h5", children: t });
    return n && (r = S.jsxs(dr, { container: !0, spacing: 0, children: [S.jsx(dr, { size: "grow", children: r }), S.jsx(dr, { justifyContent: "flex-end", children: n })] })), S.jsxs(pl, { id: e, mb: 1, mt: 1, children: [r, S.jsx(EE, {})] });
  }
  function S5e(e) {
    const { children: t, classNames: n, style: r, disabled: o, id: a, label: i, displayLabel: s, onKeyRenameBlur: u, onRemoveProperty: c, readonly: f, required: p, schema: g, uiSchema: h, registry: y } = e, { templates: b, translateString: v } = y, { RemoveButton: w } = b.ButtonTemplates, _ = v(ht.KeyLabel, [i]), k = zi in g, E = {
      flex: 1,
      paddingLeft: 6,
      paddingRight: 6,
      fontWeight: "bold"
    };
    return k ? S.jsxs(dr, { container: !0, alignItems: "flex-start", spacing: 2, className: n, style: r, children: [S.jsx(dr, { size: 5.5, children: S.jsx(jO, { fullWidth: !0, required: p, label: s ? _ : void 0, defaultValue: i, disabled: o || f, id: `${a}-key`, name: `${a}-key`, onBlur: f ? void 0 : u, type: "text" }) }), S.jsx(dr, { size: 5.5, children: t }), S.jsx(dr, { sx: { mt: 1.5 }, children: S.jsx(w, { id: Da(a, "remove"), className: "rjsf-object-property-remove", iconType: "default", style: E, disabled: o || f, onClick: c, uiSchema: h, registry: y }) })] }, `${a}-key`) : S.jsx("div", { className: n, style: r, children: t });
  }
  function _5e() {
    return {
      ArrayFieldItemTemplate: EMe,
      ArrayFieldTemplate: CMe,
      BaseInputTemplate: kje,
      ButtonTemplates: {
        AddButton: hMe,
        CopyButton: Qje,
        MoveDownButton: Zje,
        MoveUpButton: e5e,
        RemoveButton: hU,
        SubmitButton: v5e
      },
      DescriptionFieldTemplate: Oje,
      ErrorListTemplate: Kje,
      FieldErrorTemplate: t5e,
      FieldHelpTemplate: n5e,
      FieldTemplate: r5e,
      GridTemplate: o5e,
      MultiSchemaFieldTemplate: a5e,
      ObjectFieldTemplate: i5e,
      OptionalDataControlsTemplate: s5e,
      TitleFieldTemplate: k5e,
      WrapIfAdditionalTemplate: S5e
    };
  }
  function E5e(e) {
    return rt("PrivateSwitchBase", e);
  }
  tt("PrivateSwitchBase", ["root", "checked", "disabled", "input", "edgeStart", "edgeEnd"]);
  const C5e = (e) => {
    const {
      classes: t,
      checked: n,
      disabled: r,
      edge: o
    } = e, a = {
      root: ["root", n && "checked", r && "disabled", o && `edge${$e(o)}`],
      input: ["input"]
    };
    return nt(a, E5e, t);
  }, P5e = Me(zm, {
    name: "MuiSwitchBase"
  })({
    padding: 9,
    borderRadius: "50%",
    variants: [{
      props: {
        edge: "start",
        size: "small"
      },
      style: {
        marginLeft: -3
      }
    }, {
      props: ({
        edge: e,
        ownerState: t
      }) => e === "start" && t.size !== "small",
      style: {
        marginLeft: -12
      }
    }, {
      props: {
        edge: "end",
        size: "small"
      },
      style: {
        marginRight: -3
      }
    }, {
      props: ({
        edge: e,
        ownerState: t
      }) => e === "end" && t.size !== "small",
      style: {
        marginRight: -12
      }
    }]
  }), O5e = Me("input", {
    name: "MuiSwitchBase",
    shouldForwardProp: kr
  })({
    cursor: "inherit",
    position: "absolute",
    opacity: 0,
    width: "100%",
    height: "100%",
    top: 0,
    left: 0,
    margin: 0,
    padding: 0,
    zIndex: 1
  }), vU = /* @__PURE__ */ C.forwardRef(function(e, t) {
    const {
      autoFocus: n,
      checked: r,
      checkedIcon: o,
      defaultChecked: a,
      disabled: i,
      disableFocusRipple: s = !1,
      edge: u = !1,
      icon: c,
      id: f,
      inputProps: p,
      inputRef: g,
      name: h,
      onBlur: y,
      onChange: b,
      onFocus: v,
      readOnly: w,
      required: _ = !1,
      tabIndex: k,
      type: E,
      value: P,
      slots: O = {},
      slotProps: M = {},
      ...I
    } = e, [A, D] = Em({
      controlled: r,
      default: !!a,
      name: "SwitchBase",
      state: "checked"
    }), F = ni(), j = (V) => {
      v && v(V), F && F.onFocus && F.onFocus(V);
    }, U = (V) => {
      y && y(V), F && F.onBlur && F.onBlur(V);
    }, $ = (V) => {
      if (V.nativeEvent.defaultPrevented)
        return;
      const X = V.target.checked;
      D(X), b && b(V, X);
    };
    let q = i;
    F && typeof q > "u" && (q = F.disabled);
    const B = E === "checkbox" || E === "radio", G = {
      ...e,
      checked: A,
      disabled: q,
      disableFocusRipple: s,
      edge: u
    }, W = C5e(G), Y = {
      slots: O,
      slotProps: {
        input: p,
        ...M
      }
    }, [z, L] = sn("root", {
      ref: t,
      elementType: P5e,
      className: W.root,
      shouldForwardComponentProp: !0,
      externalForwardedProps: {
        ...Y,
        component: "span",
        ...I
      },
      getSlotProps: (V) => ({
        ...V,
        onFocus: (X) => {
          V.onFocus?.(X), j(X);
        },
        onBlur: (X) => {
          V.onBlur?.(X), U(X);
        }
      }),
      ownerState: G,
      additionalProps: {
        centerRipple: !0,
        focusRipple: !s,
        disabled: q,
        role: void 0,
        tabIndex: null
      }
    }), [K, T] = sn("input", {
      ref: g,
      elementType: O5e,
      className: W.input,
      externalForwardedProps: Y,
      getSlotProps: (V) => ({
        ...V,
        onChange: (X) => {
          V.onChange?.(X), $(X);
        }
      }),
      ownerState: G,
      additionalProps: {
        autoFocus: n,
        checked: r,
        defaultChecked: a,
        disabled: q,
        id: B ? f : void 0,
        name: h,
        readOnly: w,
        required: _,
        tabIndex: k,
        type: E,
        ...E === "checkbox" && P === void 0 ? {} : {
          value: P
        }
      }
    });
    return /* @__PURE__ */ S.jsxs(z, {
      ...L,
      children: [/* @__PURE__ */ S.jsx(K, {
        ...T
      }), A ? o : c]
    });
  }), N5e = mo(/* @__PURE__ */ S.jsx("path", {
    d: "M19 5v14H5V5h14m0-2H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2z"
  })), M5e = mo(/* @__PURE__ */ S.jsx("path", {
    d: "M19 3H5c-1.11 0-2 .9-2 2v14c0 1.1.89 2 2 2h14c1.11 0 2-.9 2-2V5c0-1.1-.89-2-2-2zm-9 14l-5-5 1.41-1.41L10 14.17l7.59-7.59L19 8l-9 9z"
  })), R5e = mo(/* @__PURE__ */ S.jsx("path", {
    d: "M19 3H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm-2 10H7v-2h10v2z"
  }));
  function j5e(e) {
    return rt("MuiCheckbox", e);
  }
  const I0 = tt("MuiCheckbox", ["root", "checked", "disabled", "indeterminate", "colorPrimary", "colorSecondary", "sizeSmall", "sizeMedium"]), I5e = (e) => {
    const {
      classes: t,
      indeterminate: n,
      color: r,
      size: o
    } = e, a = {
      root: ["root", n && "indeterminate", `color${$e(r)}`, `size${$e(o)}`]
    }, i = nt(a, j5e, t);
    return {
      ...t,
      // forward the disabled and checked classes to the SwitchBase
      ...i
    };
  }, A5e = Me(vU, {
    shouldForwardProp: (e) => kr(e) || e === "classes",
    name: "MuiCheckbox",
    slot: "Root",
    overridesResolver: (e, t) => {
      const {
        ownerState: n
      } = e;
      return [t.root, n.indeterminate && t.indeterminate, t[`size${$e(n.size)}`], n.color !== "default" && t[`color${$e(n.color)}`]];
    }
  })(at(({
    theme: e
  }) => ({
    color: (e.vars || e).palette.text.secondary,
    variants: [{
      props: {
        color: "default",
        disableRipple: !1
      },
      style: {
        "&:hover": {
          backgroundColor: e.alpha((e.vars || e).palette.action.active, (e.vars || e).palette.action.hoverOpacity)
        }
      }
    }, ...Object.entries(e.palette).filter(xr()).map(([t]) => ({
      props: {
        color: t,
        disableRipple: !1
      },
      style: {
        "&:hover": {
          backgroundColor: e.alpha((e.vars || e).palette[t].main, (e.vars || e).palette.action.hoverOpacity)
        }
      }
    })), ...Object.entries(e.palette).filter(xr()).map(([t]) => ({
      props: {
        color: t
      },
      style: {
        [`&.${I0.checked}, &.${I0.indeterminate}`]: {
          color: (e.vars || e).palette[t].main
        },
        [`&.${I0.disabled}`]: {
          color: (e.vars || e).palette.action.disabled
        }
      }
    })), {
      // Should be last to override other colors
      props: {
        disableRipple: !1
      },
      style: {
        // Reset on touch devices, it doesn't add specificity
        "&:hover": {
          "@media (hover: none)": {
            backgroundColor: "transparent"
          }
        }
      }
    }]
  }))), $5e = /* @__PURE__ */ S.jsx(M5e, {}), D5e = /* @__PURE__ */ S.jsx(N5e, {}), L5e = /* @__PURE__ */ S.jsx(R5e, {}), yU = /* @__PURE__ */ C.forwardRef(function(e, t) {
    const n = lt({
      props: e,
      name: "MuiCheckbox"
    }), {
      checkedIcon: r = $5e,
      color: o = "primary",
      icon: a = D5e,
      indeterminate: i = !1,
      indeterminateIcon: s = L5e,
      inputProps: u,
      size: c = "medium",
      disableRipple: f = !1,
      className: p,
      slots: g = {},
      slotProps: h = {},
      ...y
    } = n, b = i ? s : a, v = i ? s : r, w = {
      ...n,
      disableRipple: f,
      color: o,
      indeterminate: i,
      size: c
    }, _ = I5e(w), k = h.input ?? u, [E, P] = sn("root", {
      ref: t,
      elementType: A5e,
      className: Le(_.root, p),
      shouldForwardComponentProp: !0,
      externalForwardedProps: {
        slots: g,
        slotProps: h,
        ...y
      },
      ownerState: w,
      additionalProps: {
        type: "checkbox",
        icon: /* @__PURE__ */ C.cloneElement(b, {
          fontSize: b.props.fontSize ?? c
        }),
        checkedIcon: /* @__PURE__ */ C.cloneElement(v, {
          fontSize: v.props.fontSize ?? c
        }),
        disableRipple: f,
        slots: g,
        slotProps: {
          input: tU(typeof k == "function" ? k(w) : k, {
            "data-indeterminate": i
          })
        }
      }
    });
    return /* @__PURE__ */ S.jsx(E, {
      ...P,
      classes: _
    });
  });
  function F5e(e) {
    return rt("MuiFormControlLabel", e);
  }
  const Ep = tt("MuiFormControlLabel", ["root", "labelPlacementStart", "labelPlacementTop", "labelPlacementBottom", "disabled", "label", "error", "required", "asterisk"]), T5e = (e) => {
    const {
      classes: t,
      disabled: n,
      labelPlacement: r,
      error: o,
      required: a
    } = e, i = {
      root: ["root", n && "disabled", `labelPlacement${$e(r)}`, o && "error", a && "required"],
      label: ["label", n && "disabled"],
      asterisk: ["asterisk", o && "error"]
    };
    return nt(i, F5e, t);
  }, z5e = Me("label", {
    name: "MuiFormControlLabel",
    slot: "Root",
    overridesResolver: (e, t) => {
      const {
        ownerState: n
      } = e;
      return [{
        [`& .${Ep.label}`]: t.label
      }, t.root, t[`labelPlacement${$e(n.labelPlacement)}`]];
    }
  })(at(({
    theme: e
  }) => ({
    display: "inline-flex",
    alignItems: "center",
    cursor: "pointer",
    // For correct alignment with the text.
    verticalAlign: "middle",
    WebkitTapHighlightColor: "transparent",
    marginLeft: -11,
    marginRight: 16,
    // used for row presentation of radio/checkbox
    [`&.${Ep.disabled}`]: {
      cursor: "default"
    },
    [`& .${Ep.label}`]: {
      [`&.${Ep.disabled}`]: {
        color: (e.vars || e).palette.text.disabled
      }
    },
    variants: [{
      props: {
        labelPlacement: "start"
      },
      style: {
        flexDirection: "row-reverse",
        marginRight: -11
      }
    }, {
      props: {
        labelPlacement: "top"
      },
      style: {
        flexDirection: "column-reverse"
      }
    }, {
      props: {
        labelPlacement: "bottom"
      },
      style: {
        flexDirection: "column"
      }
    }, {
      props: ({
        labelPlacement: t
      }) => t === "start" || t === "top" || t === "bottom",
      style: {
        marginLeft: 16
        // used for row presentation of radio/checkbox
      }
    }]
  }))), B5e = Me("span", {
    name: "MuiFormControlLabel",
    slot: "Asterisk"
  })(at(({
    theme: e
  }) => ({
    [`&.${Ep.error}`]: {
      color: (e.vars || e).palette.error.main
    }
  }))), IO = /* @__PURE__ */ C.forwardRef(function(e, t) {
    const n = lt({
      props: e,
      name: "MuiFormControlLabel"
    }), {
      checked: r,
      className: o,
      componentsProps: a = {},
      control: i,
      disabled: s,
      disableTypography: u,
      inputRef: c,
      label: f,
      labelPlacement: p = "end",
      name: g,
      onChange: h,
      required: y,
      slots: b = {},
      slotProps: v = {},
      value: w,
      ..._
    } = n, k = ni(), E = s ?? i.props.disabled ?? k?.disabled, P = y ?? i.props.required, O = {
      disabled: E,
      required: P
    };
    ["checked", "name", "onChange", "value", "inputRef"].forEach(($) => {
      typeof i.props[$] > "u" && typeof n[$] < "u" && (O[$] = n[$]);
    });
    const M = vl({
      props: n,
      muiFormControl: k,
      states: ["error"]
    }), I = {
      ...n,
      disabled: E,
      labelPlacement: p,
      required: P,
      error: M.error
    }, A = T5e(I), D = {
      slots: b,
      slotProps: {
        ...a,
        ...v
      }
    }, [F, j] = sn("typography", {
      elementType: Fa,
      externalForwardedProps: D,
      ownerState: I
    });
    let U = f;
    return U != null && U.type !== Fa && !u && (U = /* @__PURE__ */ S.jsx(F, {
      component: "span",
      ...j,
      className: Le(A.label, j?.className),
      children: U
    })), /* @__PURE__ */ S.jsxs(z5e, {
      className: Le(A.root, o),
      ownerState: I,
      ref: t,
      ..._,
      children: [/* @__PURE__ */ C.cloneElement(i, O), P ? /* @__PURE__ */ S.jsxs("div", {
        children: [U, /* @__PURE__ */ S.jsxs(B5e, {
          ownerState: I,
          "aria-hidden": !0,
          className: A.asterisk,
          children: ["", "*"]
        })]
      }) : U]
    });
  });
  function V5e(e) {
    var t;
    const { schema: n, id: r, htmlName: o, value: a, disabled: i, readonly: s, label: u = "", hideLabel: c, autofocus: f, onChange: p, onBlur: g, onFocus: h, registry: y, options: b, uiSchema: v } = e, w = et("DescriptionFieldTemplate", y, b), _ = Lp(n), k = (M, I) => p(I), E = () => g(r, a), P = () => h(r, a), O = (t = b.description) !== null && t !== void 0 ? t : n.description;
    return S.jsxs(S.Fragment, { children: [!c && O && S.jsx(w, { id: Mu(r), description: O, schema: n, uiSchema: v, registry: y }), S.jsx(IO, { control: S.jsx(yU, { id: r, name: o || r, checked: typeof a > "u" ? !1 : !!a, required: _, disabled: i || s, autoFocus: f, onChange: k, onBlur: E, onFocus: P, "aria-describedby": vo(r) }), label: Ru(u, c, !1) })] });
  }
  function U5e(e) {
    return rt("MuiFormGroup", e);
  }
  tt("MuiFormGroup", ["root", "row", "error"]);
  const H5e = (e) => {
    const {
      classes: t,
      row: n,
      error: r
    } = e;
    return nt({
      root: ["root", n && "row", r && "error"]
    }, U5e, t);
  }, W5e = Me("div", {
    name: "MuiFormGroup",
    slot: "Root",
    overridesResolver: (e, t) => {
      const {
        ownerState: n
      } = e;
      return [t.root, n.row && t.row];
    }
  })({
    display: "flex",
    flexDirection: "column",
    flexWrap: "wrap",
    variants: [{
      props: {
        row: !0
      },
      style: {
        flexDirection: "row"
      }
    }]
  }), bU = /* @__PURE__ */ C.forwardRef(function(e, t) {
    const n = lt({
      props: e,
      name: "MuiFormGroup"
    }), {
      className: r,
      row: o = !1,
      ...a
    } = n, i = ni(), s = vl({
      props: n,
      muiFormControl: i,
      states: ["error"]
    }), u = {
      ...n,
      row: o,
      error: s.error
    }, c = H5e(u);
    return /* @__PURE__ */ S.jsx(W5e, {
      className: Le(c.root, r),
      ownerState: u,
      ref: t,
      ...a
    });
  });
  function q5e({ label: e, hideLabel: t, id: n, htmlName: r, disabled: o, options: a, value: i, autofocus: s, readonly: u, required: c, onChange: f, onBlur: p, onFocus: g }) {
    const { enumOptions: h, enumDisabled: y, inline: b, emptyValue: v } = a, w = Array.isArray(i) ? i : [i], _ = (P) => ({ target: { checked: O } }) => {
      f(O ? v1(P, w, h) : g1(P, w, h));
    }, k = ({ target: P }) => p(n, Qn(P && P.value, h, v)), E = ({ target: P }) => g(n, Qn(P && P.value, h, v));
    return S.jsxs(S.Fragment, { children: [Ru(S.jsx(Rx, { required: c, htmlFor: n, children: e || void 0 }), t), S.jsx(bU, { id: n, row: !!b, children: Array.isArray(h) && h.map((P, O) => {
      const M = vx(P.value, w), I = Array.isArray(y) && y.indexOf(P.value) !== -1, A = S.jsx(yU, { id: bx(n, O), name: r || n, checked: M, disabled: o || I || u, autoFocus: s && O === 0, onChange: _(O), onBlur: k, onFocus: E, "aria-describedby": vo(n) });
      return S.jsx(IO, { control: A, label: P.label }, O);
    }) })] });
  }
  const K5e = mo(/* @__PURE__ */ S.jsx("path", {
    d: "M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.42 0-8-3.58-8-8s3.58-8 8-8 8 3.58 8 8-3.58 8-8 8z"
  })), G5e = mo(/* @__PURE__ */ S.jsx("path", {
    d: "M8.465 8.465C9.37 7.56 10.62 7 12 7C14.76 7 17 9.24 17 12C17 13.38 16.44 14.63 15.535 15.535C14.63 16.44 13.38 17 12 17C9.24 17 7 14.76 7 12C7 10.62 7.56 9.37 8.465 8.465Z"
  })), X5e = Me("span", {
    name: "MuiRadioButtonIcon",
    shouldForwardProp: kr
  })({
    position: "relative",
    display: "flex"
  }), Y5e = Me(K5e, {
    name: "MuiRadioButtonIcon"
  })({
    // Scale applied to prevent dot misalignment in Safari
    transform: "scale(1)"
  }), J5e = Me(G5e, {
    name: "MuiRadioButtonIcon"
  })(at(({
    theme: e
  }) => ({
    left: 0,
    position: "absolute",
    transform: "scale(0)",
    transition: e.transitions.create("transform", {
      easing: e.transitions.easing.easeIn,
      duration: e.transitions.duration.shortest
    }),
    variants: [{
      props: {
        checked: !0
      },
      style: {
        transform: "scale(1)",
        transition: e.transitions.create("transform", {
          easing: e.transitions.easing.easeOut,
          duration: e.transitions.duration.shortest
        })
      }
    }]
  })));
  function wU(e) {
    const {
      checked: t = !1,
      classes: n = {},
      fontSize: r
    } = e, o = {
      ...e,
      checked: t
    };
    return /* @__PURE__ */ S.jsxs(X5e, {
      className: n.root,
      ownerState: o,
      children: [/* @__PURE__ */ S.jsx(Y5e, {
        fontSize: r,
        className: n.background,
        ownerState: o
      }), /* @__PURE__ */ S.jsx(J5e, {
        fontSize: r,
        className: n.dot,
        ownerState: o
      })]
    });
  }
  const xU = /* @__PURE__ */ C.createContext(void 0);
  function Q5e() {
    return C.useContext(xU);
  }
  function Z5e(e) {
    return rt("MuiRadio", e);
  }
  const qL = tt("MuiRadio", ["root", "checked", "disabled", "colorPrimary", "colorSecondary", "sizeSmall"]), eIe = (e) => {
    const {
      classes: t,
      color: n,
      size: r
    } = e, o = {
      root: ["root", `color${$e(n)}`, r !== "medium" && `size${$e(r)}`]
    };
    return {
      ...t,
      ...nt(o, Z5e, t)
    };
  }, tIe = Me(vU, {
    shouldForwardProp: (e) => kr(e) || e === "classes",
    name: "MuiRadio",
    slot: "Root",
    overridesResolver: (e, t) => {
      const {
        ownerState: n
      } = e;
      return [t.root, n.size !== "medium" && t[`size${$e(n.size)}`], t[`color${$e(n.color)}`]];
    }
  })(at(({
    theme: e
  }) => ({
    color: (e.vars || e).palette.text.secondary,
    [`&.${qL.disabled}`]: {
      color: (e.vars || e).palette.action.disabled
    },
    variants: [{
      props: {
        color: "default",
        disabled: !1,
        disableRipple: !1
      },
      style: {
        "&:hover": {
          backgroundColor: e.alpha((e.vars || e).palette.action.active, (e.vars || e).palette.action.hoverOpacity)
        }
      }
    }, ...Object.entries(e.palette).filter(xr()).map(([t]) => ({
      props: {
        color: t,
        disabled: !1,
        disableRipple: !1
      },
      style: {
        "&:hover": {
          backgroundColor: e.alpha((e.vars || e).palette[t].main, (e.vars || e).palette.action.hoverOpacity)
        }
      }
    })), ...Object.entries(e.palette).filter(xr()).map(([t]) => ({
      props: {
        color: t,
        disabled: !1
      },
      style: {
        [`&.${qL.checked}`]: {
          color: (e.vars || e).palette[t].main
        }
      }
    })), {
      // Should be last to override other colors
      props: {
        disableRipple: !1
      },
      style: {
        // Reset on touch devices, it doesn't add specificity
        "&:hover": {
          "@media (hover: none)": {
            backgroundColor: "transparent"
          }
        }
      }
    }]
  })));
  function nIe(e, t) {
    return typeof t == "object" && t !== null ? e === t : String(e) === String(t);
  }
  const rIe = /* @__PURE__ */ S.jsx(wU, {
    checked: !0
  }), oIe = /* @__PURE__ */ S.jsx(wU, {}), aIe = /* @__PURE__ */ C.forwardRef(function(e, t) {
    const n = lt({
      props: e,
      name: "MuiRadio"
    }), {
      checked: r,
      checkedIcon: o = rIe,
      color: a = "primary",
      icon: i = oIe,
      name: s,
      onChange: u,
      size: c = "medium",
      className: f,
      disabled: p,
      disableRipple: g = !1,
      slots: h = {},
      slotProps: y = {},
      inputProps: b,
      ...v
    } = n, w = ni();
    let _ = p;
    w && typeof _ > "u" && (_ = w.disabled), _ ?? (_ = !1);
    const k = {
      ...n,
      disabled: _,
      disableRipple: g,
      color: a,
      size: c
    }, E = eIe(k), P = Q5e();
    let O = r;
    const M = wE(u, P && P.onChange);
    let I = s;
    P && (typeof O > "u" && (O = nIe(P.value, n.value)), typeof I > "u" && (I = P.name));
    const A = y.input ?? b, [D, F] = sn("root", {
      ref: t,
      elementType: tIe,
      className: Le(E.root, f),
      shouldForwardComponentProp: !0,
      externalForwardedProps: {
        slots: h,
        slotProps: y,
        ...v
      },
      getSlotProps: (j) => ({
        ...j,
        onChange: (U, ...$) => {
          j.onChange?.(U, ...$), M(U, ...$);
        }
      }),
      ownerState: k,
      additionalProps: {
        type: "radio",
        icon: /* @__PURE__ */ C.cloneElement(i, {
          fontSize: i.props.fontSize ?? c
        }),
        checkedIcon: /* @__PURE__ */ C.cloneElement(o, {
          fontSize: o.props.fontSize ?? c
        }),
        disabled: _,
        name: I,
        checked: O,
        slots: h,
        slotProps: {
          // Do not forward `slotProps.root` again because it's already handled by the `RootSlot` in this file.
          input: typeof A == "function" ? A(k) : A
        }
      }
    });
    return /* @__PURE__ */ S.jsx(D, {
      ...F,
      classes: E
    });
  });
  function iIe(e) {
    return rt("MuiRadioGroup", e);
  }
  tt("MuiRadioGroup", ["root", "row", "error"]);
  const sIe = (e) => {
    const {
      classes: t,
      row: n,
      error: r
    } = e;
    return nt({
      root: ["root", n && "row", r && "error"]
    }, iIe, t);
  }, lIe = /* @__PURE__ */ C.forwardRef(function(e, t) {
    const {
      // private
      // eslint-disable-next-line react/prop-types
      actions: n,
      children: r,
      className: o,
      defaultValue: a,
      name: i,
      onChange: s,
      value: u,
      ...c
    } = e, f = C.useRef(null), p = sIe(e), [g, h] = Em({
      controlled: u,
      default: a,
      name: "RadioGroup"
    });
    C.useImperativeHandle(n, () => ({
      focus: () => {
        let w = f.current.querySelector("input:not(:disabled):checked");
        w || (w = f.current.querySelector("input:not(:disabled)")), w && w.focus();
      }
    }), []);
    const y = Zn(t, f), b = $d(i), v = C.useMemo(() => ({
      name: b,
      onChange(w) {
        h(w.target.value), s && s(w, w.target.value);
      },
      value: g
    }), [b, s, h, g]);
    return /* @__PURE__ */ S.jsx(xU.Provider, {
      value: v,
      children: /* @__PURE__ */ S.jsx(bU, {
        role: "radiogroup",
        ref: y,
        className: Le(p.root, o),
        ...c,
        children: r
      })
    });
  });
  function uIe({ id: e, htmlName: t, options: n, value: r, required: o, disabled: a, readonly: i, label: s, hideLabel: u, onChange: c, onBlur: f, onFocus: p }) {
    var g;
    const { enumOptions: h, enumDisabled: y, emptyValue: b } = n, v = (P, O) => c(Qn(O, h, b)), w = ({ target: P }) => f(e, Qn(P && P.value, h, b)), _ = ({ target: P }) => p(e, Qn(P && P.value, h, b)), k = n ? n.inline : !1, E = (g = aO(r, h)) !== null && g !== void 0 ? g : null;
    return S.jsxs(S.Fragment, { children: [Ru(S.jsx(Rx, { required: o, htmlFor: e, children: s || void 0 }), u), S.jsx(lIe, { id: e, name: t || e, value: E, row: k, onChange: v, onBlur: w, onFocus: _, "aria-describedby": vo(e), children: Array.isArray(h) && h.map((P, O) => {
      const M = Array.isArray(y) && y.indexOf(P.value) !== -1;
      return S.jsx(IO, { control: S.jsx(aIe, { name: t || e, id: bx(e, O), color: "primary" }), label: P.label, value: String(O), disabled: a || M || i }, O);
    }) })] });
  }
  const cIe = {
    border: 0,
    clip: "rect(0 0 0 0)",
    height: "1px",
    margin: "-1px",
    overflow: "hidden",
    padding: 0,
    position: "absolute",
    whiteSpace: "nowrap",
    width: "1px"
  };
  function dIe(e, t, n = (r, o) => r === o) {
    return e.length === t.length && e.every((r, o) => n(r, t[o]));
  }
  const fIe = 2;
  function Dc(e, t, n, r, o) {
    return n === 1 ? Math.min(e + t, o) : Math.max(e - t, r);
  }
  function kU(e, t) {
    return e - t;
  }
  function KL(e, t) {
    const {
      index: n
    } = e.reduce((r, o, a) => {
      const i = Math.abs(t - o);
      return r === null || i < r.distance || i === r.distance ? {
        distance: i,
        index: a
      } : r;
    }, null) ?? {};
    return n;
  }
  function my(e, t) {
    if (t.current !== void 0 && e.changedTouches) {
      const n = e;
      for (let r = 0; r < n.changedTouches.length; r += 1) {
        const o = n.changedTouches[r];
        if (o.identifier === t.current)
          return {
            x: o.clientX,
            y: o.clientY
          };
      }
      return !1;
    }
    return {
      x: e.clientX,
      y: e.clientY
    };
  }
  function Ub(e, t, n) {
    return (e - t) * 100 / (n - t);
  }
  function pIe(e, t, n) {
    return (n - t) * e + t;
  }
  function mIe(e) {
    if (Math.abs(e) < 1) {
      const n = e.toExponential().split("e-"), r = n[0].split(".")[1];
      return (r ? r.length : 0) + parseInt(n[1], 10);
    }
    const t = e.toString().split(".")[1];
    return t ? t.length : 0;
  }
  function hIe(e, t, n) {
    const r = Math.round((e - n) / t) * t + n;
    return Number(r.toFixed(mIe(t)));
  }
  function GL({
    values: e,
    newValue: t,
    index: n
  }) {
    const r = e.slice();
    return r[n] = t, r.sort(kU);
  }
  function hy({
    sliderRef: e,
    activeIndex: t,
    setActive: n
  }) {
    const r = Or(e.current);
    (!e.current?.contains(r.activeElement) || Number(r?.activeElement?.getAttribute("data-index")) !== t) && e.current?.querySelector(`[type="range"][data-index="${t}"]`).focus(), n && n(t);
  }
  function gy(e, t) {
    return typeof e == "number" && typeof t == "number" ? e === t : typeof e == "object" && typeof t == "object" ? dIe(e, t) : !1;
  }
  const gIe = {
    horizontal: {
      offset: (e) => ({
        left: `${e}%`
      }),
      leap: (e) => ({
        width: `${e}%`
      })
    },
    "horizontal-reverse": {
      offset: (e) => ({
        right: `${e}%`
      }),
      leap: (e) => ({
        width: `${e}%`
      })
    },
    vertical: {
      offset: (e) => ({
        bottom: `${e}%`
      }),
      leap: (e) => ({
        height: `${e}%`
      })
    }
  }, vIe = (e) => e;
  let vy;
  function XL() {
    return vy === void 0 && (typeof CSS < "u" && typeof CSS.supports == "function" ? vy = CSS.supports("touch-action", "none") : vy = !0), vy;
  }
  function yIe(e) {
    const {
      "aria-labelledby": t,
      defaultValue: n,
      disabled: r = !1,
      disableSwap: o = !1,
      isRtl: a = !1,
      marks: i = !1,
      max: s = 100,
      min: u = 0,
      name: c,
      onChange: f,
      onChangeCommitted: p,
      orientation: g = "horizontal",
      rootRef: h,
      scale: y = vIe,
      step: b = 1,
      shiftStep: v = 10,
      tabIndex: w,
      value: _
    } = e, k = C.useRef(void 0), [E, P] = C.useState(-1), [O, M] = C.useState(-1), [I, A] = C.useState(!1), D = C.useRef(0), F = C.useRef(null), [j, U] = Em({
      controlled: _,
      default: n ?? u,
      name: "Slider"
    }), $ = f && ((Ee, _e, ie) => {
      const me = Ee.nativeEvent || Ee, Se = new me.constructor(me.type, me);
      Object.defineProperty(Se, "target", {
        writable: !0,
        value: {
          value: _e,
          name: c
        }
      }), F.current = _e, f(Se, _e, ie);
    }), q = Array.isArray(j);
    let B = q ? j.slice().sort(kU) : [j];
    B = B.map((Ee) => Ee == null ? u : Tc(Ee, u, s));
    const G = i === !0 && b !== null ? [...Array(Math.floor((s - u) / b) + 1)].map((Ee, _e) => ({
      value: u + b * _e
    })) : i || [], W = G.map((Ee) => Ee.value), [Y, z] = C.useState(-1), L = C.useRef(null), K = Zn(h, L), T = (Ee) => (_e) => {
      const ie = Number(_e.currentTarget.getAttribute("data-index"));
      eb(_e.target) && z(ie), M(ie), Ee?.onFocus?.(_e);
    }, V = (Ee) => (_e) => {
      eb(_e.target) || z(-1), M(-1), Ee?.onBlur?.(_e);
    }, X = (Ee, _e) => {
      const ie = Number(Ee.currentTarget.getAttribute("data-index")), me = B[ie], Se = W.indexOf(me);
      let je = _e;
      if (G && b == null) {
        const Ae = W[W.length - 1];
        je >= Ae ? je = Ae : je <= W[0] ? je = W[0] : je = je < me ? W[Se - 1] : W[Se + 1];
      }
      if (je = Tc(je, u, s), q) {
        o && (je = Tc(je, B[ie - 1] || -1 / 0, B[ie + 1] || 1 / 0));
        const Ae = je;
        je = GL({
          values: B,
          newValue: je,
          index: ie
        });
        let vt = ie;
        o || (vt = je.indexOf(Ae)), hy({
          sliderRef: L,
          activeIndex: vt
        });
      }
      U(je), z(ie), $ && !gy(je, j) && $(Ee, je, ie), p && p(Ee, F.current ?? je);
    }, Q = (Ee) => (_e) => {
      if (["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight", "PageUp", "PageDown", "Home", "End"].includes(_e.key)) {
        _e.preventDefault();
        const ie = Number(_e.currentTarget.getAttribute("data-index")), me = B[ie];
        let Se = null;
        if (b != null) {
          const je = _e.shiftKey ? v : b;
          switch (_e.key) {
            case "ArrowUp":
              Se = Dc(me, je, 1, u, s);
              break;
            case "ArrowRight":
              Se = Dc(me, je, a ? -1 : 1, u, s);
              break;
            case "ArrowDown":
              Se = Dc(me, je, -1, u, s);
              break;
            case "ArrowLeft":
              Se = Dc(me, je, a ? 1 : -1, u, s);
              break;
            case "PageUp":
              Se = Dc(me, v, 1, u, s);
              break;
            case "PageDown":
              Se = Dc(me, v, -1, u, s);
              break;
            case "Home":
              Se = u;
              break;
            case "End":
              Se = s;
              break;
          }
        } else if (G) {
          const je = W[W.length - 1], Ae = W.indexOf(me), vt = [a ? "ArrowRight" : "ArrowLeft", "ArrowDown", "PageDown", "Home"], yt = [a ? "ArrowLeft" : "ArrowRight", "ArrowUp", "PageUp", "End"];
          vt.includes(_e.key) ? Ae === 0 ? Se = W[0] : Se = W[Ae - 1] : yt.includes(_e.key) && (Ae === W.length - 1 ? Se = je : Se = W[Ae + 1]);
        }
        Se != null && X(_e, Se);
      }
      Ee?.onKeyDown?.(_e);
    };
    ta(() => {
      r && L.current.contains(document.activeElement) && document.activeElement?.blur();
    }, [r]), r && E !== -1 && P(-1), r && Y !== -1 && z(-1);
    const ne = (Ee) => (_e) => {
      Ee.onChange?.(_e), X(_e, _e.target.valueAsNumber);
    }, te = C.useRef(void 0);
    let ae = g;
    a && g === "horizontal" && (ae += "-reverse");
    const ce = ({
      finger: Ee,
      move: _e = !1
    }) => {
      const {
        current: ie
      } = L, {
        width: me,
        height: Se,
        bottom: je,
        left: Ae
      } = ie.getBoundingClientRect();
      let vt;
      ae.startsWith("vertical") ? vt = (je - Ee.y) / Se : vt = (Ee.x - Ae) / me, ae.includes("-reverse") && (vt = 1 - vt);
      let yt;
      if (yt = pIe(vt, u, s), b)
        yt = hIe(yt, b, u);
      else {
        const qt = KL(W, yt);
        yt = W[qt];
      }
      yt = Tc(yt, u, s);
      let At = 0;
      if (q) {
        _e ? At = te.current : At = KL(B, yt), o && (yt = Tc(yt, B[At - 1] || -1 / 0, B[At + 1] || 1 / 0));
        const qt = yt;
        yt = GL({
          values: B,
          newValue: yt,
          index: At
        }), o && _e || (At = yt.indexOf(qt), te.current = At);
      }
      return {
        newValue: yt,
        activeIndex: At
      };
    }, Z = Ba((Ee) => {
      const _e = my(Ee, k);
      if (!_e)
        return;
      if (D.current += 1, Ee.type === "mousemove" && Ee.buttons === 0) {
        ee(Ee);
        return;
      }
      const {
        newValue: ie,
        activeIndex: me
      } = ce({
        finger: _e,
        move: !0
      });
      hy({
        sliderRef: L,
        activeIndex: me,
        setActive: P
      }), U(ie), !I && D.current > fIe && A(!0), $ && !gy(ie, j) && $(Ee, ie, me);
    }), ee = Ba((Ee) => {
      const _e = my(Ee, k);
      if (A(!1), !_e)
        return;
      const {
        newValue: ie
      } = ce({
        finger: _e,
        move: !0
      });
      P(-1), Ee.type === "touchend" && M(-1), p && p(Ee, F.current ?? ie), k.current = void 0, le();
    }), oe = Ba((Ee) => {
      if (r)
        return;
      XL() || Ee.preventDefault();
      const _e = Ee.changedTouches[0];
      _e != null && (k.current = _e.identifier);
      const ie = my(Ee, k);
      if (ie !== !1) {
        const {
          newValue: Se,
          activeIndex: je
        } = ce({
          finger: ie
        });
        hy({
          sliderRef: L,
          activeIndex: je,
          setActive: P
        }), U(Se), $ && !gy(Se, j) && $(Ee, Se, je);
      }
      D.current = 0;
      const me = Or(L.current);
      me.addEventListener("touchmove", Z, {
        passive: !0
      }), me.addEventListener("touchend", ee, {
        passive: !0
      });
    }), le = C.useCallback(() => {
      const Ee = Or(L.current);
      Ee.removeEventListener("mousemove", Z), Ee.removeEventListener("mouseup", ee), Ee.removeEventListener("touchmove", Z), Ee.removeEventListener("touchend", ee);
    }, [ee, Z]);
    C.useEffect(() => {
      const {
        current: Ee
      } = L;
      return Ee.addEventListener("touchstart", oe, {
        passive: XL()
      }), () => {
        Ee.removeEventListener("touchstart", oe), le();
      };
    }, [le, oe]), C.useEffect(() => {
      r && le();
    }, [r, le]);
    const be = (Ee) => (_e) => {
      if (Ee.onMouseDown?.(_e), r || _e.defaultPrevented || _e.button !== 0)
        return;
      _e.preventDefault();
      const ie = my(_e, k);
      if (ie !== !1) {
        const {
          newValue: Se,
          activeIndex: je
        } = ce({
          finger: ie
        });
        hy({
          sliderRef: L,
          activeIndex: je,
          setActive: P
        }), U(Se), $ && !gy(Se, j) && $(_e, Se, je);
      }
      D.current = 0;
      const me = Or(L.current);
      me.addEventListener("mousemove", Z, {
        passive: !0
      }), me.addEventListener("mouseup", ee);
    }, ke = Ub(q ? B[0] : u, u, s), De = Ub(B[B.length - 1], u, s) - ke, ze = (Ee = {}) => {
      const _e = Np(Ee), ie = {
        onMouseDown: be(_e || {})
      }, me = {
        ..._e,
        ...ie
      };
      return {
        ...Ee,
        ref: K,
        ...me
      };
    }, Ue = (Ee) => (_e) => {
      Ee.onMouseOver?.(_e);
      const ie = Number(_e.currentTarget.getAttribute("data-index"));
      M(ie);
    }, He = (Ee) => (_e) => {
      Ee.onMouseLeave?.(_e), M(-1);
    }, Pe = (Ee = {}) => {
      const _e = Np(Ee), ie = {
        onMouseOver: Ue(_e || {}),
        onMouseLeave: He(_e || {})
      };
      return {
        ...Ee,
        ..._e,
        ...ie
      };
    }, It = (Ee) => ({
      // So the non active thumb doesn't show its label on hover.
      pointerEvents: E !== -1 && E !== Ee ? "none" : void 0
    });
    let Xe;
    return g === "vertical" && (Xe = a ? "vertical-rl" : "vertical-lr"), {
      active: E,
      axis: ae,
      axisProps: gIe,
      dragging: I,
      focusedThumbIndex: Y,
      getHiddenInputProps: (Ee = {}) => {
        const _e = Np(Ee), ie = {
          onChange: ne(_e || {}),
          onFocus: T(_e || {}),
          onBlur: V(_e || {}),
          onKeyDown: Q(_e || {})
        }, me = {
          ..._e,
          ...ie
        };
        return {
          tabIndex: w,
          "aria-labelledby": t,
          "aria-orientation": g,
          "aria-valuemax": y(s),
          "aria-valuemin": y(u),
          name: c,
          type: "range",
          min: e.min,
          max: e.max,
          step: e.step === null && e.marks ? "any" : e.step ?? void 0,
          disabled: r,
          ...Ee,
          ...me,
          style: {
            ...cIe,
            direction: a ? "rtl" : "ltr",
            // So that VoiceOver's focus indicator matches the thumb's dimensions
            width: "100%",
            height: "100%",
            writingMode: Xe
          }
        };
      },
      getRootProps: ze,
      getThumbProps: Pe,
      marks: G,
      open: O,
      range: q,
      rootRef: K,
      trackLeap: De,
      trackOffset: ke,
      values: B,
      getThumbStyle: It
    };
  }
  const bIe = (e) => !e || !Va(e);
  function wIe(e) {
    return rt("MuiSlider", e);
  }
  const Mo = tt("MuiSlider", ["root", "active", "colorPrimary", "colorSecondary", "colorError", "colorInfo", "colorSuccess", "colorWarning", "disabled", "dragging", "focusVisible", "mark", "markActive", "marked", "markLabel", "markLabelActive", "rail", "sizeSmall", "thumb", "thumbColorPrimary", "thumbColorSecondary", "thumbColorError", "thumbColorSuccess", "thumbColorInfo", "thumbColorWarning", "track", "trackInverted", "trackFalse", "thumbSizeSmall", "valueLabel", "valueLabelOpen", "valueLabelCircle", "valueLabelLabel", "vertical"]), xIe = (e) => {
    const {
      open: t
    } = e;
    return {
      offset: Le(t && Mo.valueLabelOpen),
      circle: Mo.valueLabelCircle,
      label: Mo.valueLabelLabel
    };
  };
  function kIe(e) {
    const {
      children: t,
      className: n,
      value: r
    } = e, o = xIe(e);
    return t ? /* @__PURE__ */ C.cloneElement(t, {
      className: t.props.className
    }, /* @__PURE__ */ S.jsxs(C.Fragment, {
      children: [t.props.children, /* @__PURE__ */ S.jsx("span", {
        className: Le(o.offset, n),
        "aria-hidden": !0,
        children: /* @__PURE__ */ S.jsx("span", {
          className: o.circle,
          children: /* @__PURE__ */ S.jsx("span", {
            className: o.label,
            children: r
          })
        })
      })]
    })) : null;
  }
  function YL(e) {
    return e;
  }
  const SIe = Me("span", {
    name: "MuiSlider",
    slot: "Root",
    overridesResolver: (e, t) => {
      const {
        ownerState: n
      } = e;
      return [t.root, t[`color${$e(n.color)}`], n.size !== "medium" && t[`size${$e(n.size)}`], n.marked && t.marked, n.orientation === "vertical" && t.vertical, n.track === "inverted" && t.trackInverted, n.track === !1 && t.trackFalse];
    }
  })(at(({
    theme: e
  }) => ({
    borderRadius: 12,
    boxSizing: "content-box",
    display: "inline-block",
    position: "relative",
    cursor: "pointer",
    touchAction: "none",
    WebkitTapHighlightColor: "transparent",
    "@media print": {
      colorAdjust: "exact"
    },
    [`&.${Mo.disabled}`]: {
      pointerEvents: "none",
      cursor: "default",
      color: (e.vars || e).palette.grey[400]
    },
    [`&.${Mo.dragging}`]: {
      [`& .${Mo.thumb}, & .${Mo.track}`]: {
        transition: "none"
      }
    },
    variants: [...Object.entries(e.palette).filter(xr()).map(([t]) => ({
      props: {
        color: t
      },
      style: {
        color: (e.vars || e).palette[t].main
      }
    })), {
      props: {
        orientation: "horizontal"
      },
      style: {
        height: 4,
        width: "100%",
        padding: "13px 0",
        // The primary input mechanism of the device includes a pointing device of limited accuracy.
        "@media (pointer: coarse)": {
          // Reach 42px touch target, about ~8mm on screen.
          padding: "20px 0"
        }
      }
    }, {
      props: {
        orientation: "horizontal",
        size: "small"
      },
      style: {
        height: 2
      }
    }, {
      props: {
        orientation: "horizontal",
        marked: !0
      },
      style: {
        marginBottom: 20
      }
    }, {
      props: {
        orientation: "vertical"
      },
      style: {
        height: "100%",
        width: 4,
        padding: "0 13px",
        // The primary input mechanism of the device includes a pointing device of limited accuracy.
        "@media (pointer: coarse)": {
          // Reach 42px touch target, about ~8mm on screen.
          padding: "0 20px"
        }
      }
    }, {
      props: {
        orientation: "vertical",
        size: "small"
      },
      style: {
        width: 2
      }
    }, {
      props: {
        orientation: "vertical",
        marked: !0
      },
      style: {
        marginRight: 44
      }
    }]
  }))), _Ie = Me("span", {
    name: "MuiSlider",
    slot: "Rail"
  })({
    display: "block",
    position: "absolute",
    borderRadius: "inherit",
    backgroundColor: "currentColor",
    opacity: 0.38,
    variants: [{
      props: {
        orientation: "horizontal"
      },
      style: {
        width: "100%",
        height: "inherit",
        top: "50%",
        transform: "translateY(-50%)"
      }
    }, {
      props: {
        orientation: "vertical"
      },
      style: {
        height: "100%",
        width: "inherit",
        left: "50%",
        transform: "translateX(-50%)"
      }
    }, {
      props: {
        track: "inverted"
      },
      style: {
        opacity: 1
      }
    }]
  }), EIe = Me("span", {
    name: "MuiSlider",
    slot: "Track"
  })(at(({
    theme: e
  }) => ({
    display: "block",
    position: "absolute",
    borderRadius: "inherit",
    border: "1px solid currentColor",
    backgroundColor: "currentColor",
    transition: e.transitions.create(["left", "width", "bottom", "height"], {
      duration: e.transitions.duration.shortest
    }),
    variants: [{
      props: {
        size: "small"
      },
      style: {
        border: "none"
      }
    }, {
      props: {
        orientation: "horizontal"
      },
      style: {
        height: "inherit",
        top: "50%",
        transform: "translateY(-50%)"
      }
    }, {
      props: {
        orientation: "vertical"
      },
      style: {
        width: "inherit",
        left: "50%",
        transform: "translateX(-50%)"
      }
    }, {
      props: {
        track: !1
      },
      style: {
        display: "none"
      }
    }, ...Object.entries(e.palette).filter(xr()).map(([t]) => ({
      props: {
        color: t,
        track: "inverted"
      },
      style: {
        ...e.vars ? {
          backgroundColor: e.vars.palette.Slider[`${t}Track`],
          borderColor: e.vars.palette.Slider[`${t}Track`]
        } : {
          backgroundColor: e.lighten(e.palette[t].main, 0.62),
          borderColor: e.lighten(e.palette[t].main, 0.62),
          ...e.applyStyles("dark", {
            backgroundColor: e.darken(e.palette[t].main, 0.5)
          }),
          ...e.applyStyles("dark", {
            borderColor: e.darken(e.palette[t].main, 0.5)
          })
        }
      }
    }))]
  }))), CIe = Me("span", {
    name: "MuiSlider",
    slot: "Thumb",
    overridesResolver: (e, t) => {
      const {
        ownerState: n
      } = e;
      return [t.thumb, t[`thumbColor${$e(n.color)}`], n.size !== "medium" && t[`thumbSize${$e(n.size)}`]];
    }
  })(at(({
    theme: e
  }) => ({
    position: "absolute",
    width: 20,
    height: 20,
    boxSizing: "border-box",
    borderRadius: "50%",
    outline: 0,
    backgroundColor: "currentColor",
    display: "flex",
    alignItems: "center",
    justifyContent: "center",
    transition: e.transitions.create(["box-shadow", "left", "bottom"], {
      duration: e.transitions.duration.shortest
    }),
    "&::before": {
      position: "absolute",
      content: '""',
      borderRadius: "inherit",
      width: "100%",
      height: "100%",
      boxShadow: (e.vars || e).shadows[2]
    },
    "&::after": {
      position: "absolute",
      content: '""',
      borderRadius: "50%",
      // 42px is the hit target
      width: 42,
      height: 42,
      top: "50%",
      left: "50%",
      transform: "translate(-50%, -50%)"
    },
    [`&.${Mo.disabled}`]: {
      "&:hover": {
        boxShadow: "none"
      }
    },
    variants: [{
      props: {
        size: "small"
      },
      style: {
        width: 12,
        height: 12,
        "&::before": {
          boxShadow: "none"
        }
      }
    }, {
      props: {
        orientation: "horizontal"
      },
      style: {
        top: "50%",
        transform: "translate(-50%, -50%)"
      }
    }, {
      props: {
        orientation: "vertical"
      },
      style: {
        left: "50%",
        transform: "translate(-50%, 50%)"
      }
    }, ...Object.entries(e.palette).filter(xr()).map(([t]) => ({
      props: {
        color: t
      },
      style: {
        [`&:hover, &.${Mo.focusVisible}`]: {
          boxShadow: `0px 0px 0px 8px ${e.alpha((e.vars || e).palette[t].main, 0.16)}`,
          "@media (hover: none)": {
            boxShadow: "none"
          }
        },
        [`&.${Mo.active}`]: {
          boxShadow: `0px 0px 0px 14px ${e.alpha((e.vars || e).palette[t].main, 0.16)}`
        }
      }
    }))]
  }))), PIe = Me(kIe, {
    name: "MuiSlider",
    slot: "ValueLabel"
  })(at(({
    theme: e
  }) => ({
    zIndex: 1,
    whiteSpace: "nowrap",
    ...e.typography.body2,
    fontWeight: 500,
    transition: e.transitions.create(["transform"], {
      duration: e.transitions.duration.shortest
    }),
    position: "absolute",
    backgroundColor: (e.vars || e).palette.grey[600],
    borderRadius: 2,
    color: (e.vars || e).palette.common.white,
    display: "flex",
    alignItems: "center",
    justifyContent: "center",
    padding: "0.25rem 0.75rem",
    variants: [{
      props: {
        orientation: "horizontal"
      },
      style: {
        transform: "translateY(-100%) scale(0)",
        top: "-10px",
        transformOrigin: "bottom center",
        "&::before": {
          position: "absolute",
          content: '""',
          width: 8,
          height: 8,
          transform: "translate(-50%, 50%) rotate(45deg)",
          backgroundColor: "inherit",
          bottom: 0,
          left: "50%"
        },
        [`&.${Mo.valueLabelOpen}`]: {
          transform: "translateY(-100%) scale(1)"
        }
      }
    }, {
      props: {
        orientation: "vertical"
      },
      style: {
        transform: "translateY(-50%) scale(0)",
        right: "30px",
        top: "50%",
        transformOrigin: "right center",
        "&::before": {
          position: "absolute",
          content: '""',
          width: 8,
          height: 8,
          transform: "translate(-50%, -50%) rotate(45deg)",
          backgroundColor: "inherit",
          right: -8,
          top: "50%"
        },
        [`&.${Mo.valueLabelOpen}`]: {
          transform: "translateY(-50%) scale(1)"
        }
      }
    }, {
      props: {
        size: "small"
      },
      style: {
        fontSize: e.typography.pxToRem(12),
        padding: "0.25rem 0.5rem"
      }
    }, {
      props: {
        orientation: "vertical",
        size: "small"
      },
      style: {
        right: "20px"
      }
    }]
  }))), OIe = Me("span", {
    name: "MuiSlider",
    slot: "Mark",
    shouldForwardProp: (e) => gw(e) && e !== "markActive",
    overridesResolver: (e, t) => {
      const {
        markActive: n
      } = e;
      return [t.mark, n && t.markActive];
    }
  })(at(({
    theme: e
  }) => ({
    position: "absolute",
    width: 2,
    height: 2,
    borderRadius: 1,
    backgroundColor: "currentColor",
    variants: [{
      props: {
        orientation: "horizontal"
      },
      style: {
        top: "50%",
        transform: "translate(-1px, -50%)"
      }
    }, {
      props: {
        orientation: "vertical"
      },
      style: {
        left: "50%",
        transform: "translate(-50%, 1px)"
      }
    }, {
      props: {
        markActive: !0
      },
      style: {
        backgroundColor: (e.vars || e).palette.background.paper,
        opacity: 0.8
      }
    }]
  }))), NIe = Me("span", {
    name: "MuiSlider",
    slot: "MarkLabel",
    shouldForwardProp: (e) => gw(e) && e !== "markLabelActive"
  })(at(({
    theme: e
  }) => ({
    ...e.typography.body2,
    color: (e.vars || e).palette.text.secondary,
    position: "absolute",
    whiteSpace: "nowrap",
    variants: [{
      props: {
        orientation: "horizontal"
      },
      style: {
        top: 30,
        transform: "translateX(-50%)",
        "@media (pointer: coarse)": {
          top: 40
        }
      }
    }, {
      props: {
        orientation: "vertical"
      },
      style: {
        left: 36,
        transform: "translateY(50%)",
        "@media (pointer: coarse)": {
          left: 44
        }
      }
    }, {
      props: {
        markLabelActive: !0
      },
      style: {
        color: (e.vars || e).palette.text.primary
      }
    }]
  }))), MIe = (e) => {
    const {
      disabled: t,
      dragging: n,
      marked: r,
      orientation: o,
      track: a,
      classes: i,
      color: s,
      size: u
    } = e, c = {
      root: ["root", t && "disabled", n && "dragging", r && "marked", o === "vertical" && "vertical", a === "inverted" && "trackInverted", a === !1 && "trackFalse", s && `color${$e(s)}`, u && `size${$e(u)}`],
      rail: ["rail"],
      track: ["track"],
      mark: ["mark"],
      markActive: ["markActive"],
      markLabel: ["markLabel"],
      markLabelActive: ["markLabelActive"],
      valueLabel: ["valueLabel"],
      thumb: ["thumb", t && "disabled", u && `thumbSize${$e(u)}`, s && `thumbColor${$e(s)}`],
      active: ["active"],
      disabled: ["disabled"],
      focusVisible: ["focusVisible"]
    };
    return nt(c, wIe, i);
  }, RIe = ({
    children: e
  }) => e, jIe = /* @__PURE__ */ C.forwardRef(function(e, t) {
    const n = lt({
      props: e,
      name: "MuiSlider"
    }), r = NT(), {
      "aria-label": o,
      "aria-valuetext": a,
      "aria-labelledby": i,
      // eslint-disable-next-line react/prop-types
      component: s = "span",
      components: u = {},
      componentsProps: c = {},
      color: f = "primary",
      classes: p,
      className: g,
      disableSwap: h = !1,
      disabled: y = !1,
      getAriaLabel: b,
      getAriaValueText: v,
      marks: w = !1,
      max: _ = 100,
      min: k = 0,
      name: E,
      onChange: P,
      onChangeCommitted: O,
      orientation: M = "horizontal",
      shiftStep: I = 10,
      size: A = "medium",
      step: D = 1,
      scale: F = YL,
      slotProps: j,
      slots: U,
      tabIndex: $,
      track: q = "normal",
      value: B,
      valueLabelDisplay: G = "off",
      valueLabelFormat: W = YL,
      ...Y
    } = n, z = {
      ...n,
      isRtl: r,
      max: _,
      min: k,
      classes: p,
      disabled: y,
      disableSwap: h,
      orientation: M,
      marks: w,
      color: f,
      size: A,
      step: D,
      shiftStep: I,
      scale: F,
      track: q,
      valueLabelDisplay: G,
      valueLabelFormat: W
    }, {
      axisProps: L,
      getRootProps: K,
      getHiddenInputProps: T,
      getThumbProps: V,
      open: X,
      active: Q,
      axis: ne,
      focusedThumbIndex: te,
      range: ae,
      dragging: ce,
      marks: Z,
      values: ee,
      trackOffset: oe,
      trackLeap: le,
      getThumbStyle: be
    } = yIe({
      ...z,
      rootRef: t
    });
    z.marked = Z.length > 0 && Z.some((on) => on.label), z.dragging = ce, z.focusedThumbIndex = te;
    const ke = MIe(z), De = U?.root ?? u.Root ?? SIe, ze = U?.rail ?? u.Rail ?? _Ie, Ue = U?.track ?? u.Track ?? EIe, He = U?.thumb ?? u.Thumb ?? CIe, Pe = U?.valueLabel ?? u.ValueLabel ?? PIe, It = U?.mark ?? u.Mark ?? OIe, Xe = U?.markLabel ?? u.MarkLabel ?? NIe, Ee = U?.input ?? u.Input ?? "input", _e = j?.root ?? c.root, ie = j?.rail ?? c.rail, me = j?.track ?? c.track, Se = j?.thumb ?? c.thumb, je = j?.valueLabel ?? c.valueLabel, Ae = j?.mark ?? c.mark, vt = j?.markLabel ?? c.markLabel, yt = j?.input ?? c.input, At = Ii({
      elementType: De,
      getSlotProps: K,
      externalSlotProps: _e,
      externalForwardedProps: Y,
      additionalProps: {
        ...bIe(De) && {
          as: s
        }
      },
      ownerState: {
        ...z,
        ..._e?.ownerState
      },
      className: [ke.root, g]
    }), qt = Ii({
      elementType: ze,
      externalSlotProps: ie,
      ownerState: z,
      className: ke.rail
    }), Mn = Ii({
      elementType: Ue,
      externalSlotProps: me,
      additionalProps: {
        style: {
          ...L[ne].offset(oe),
          ...L[ne].leap(le)
        }
      },
      ownerState: {
        ...z,
        ...me?.ownerState
      },
      className: ke.track
    }), Re = Ii({
      elementType: He,
      getSlotProps: V,
      externalSlotProps: Se,
      ownerState: {
        ...z,
        ...Se?.ownerState
      },
      className: ke.thumb
    }), bt = Ii({
      elementType: Pe,
      externalSlotProps: je,
      ownerState: {
        ...z,
        ...je?.ownerState
      },
      className: ke.valueLabel
    }), Ct = Ii({
      elementType: It,
      externalSlotProps: Ae,
      ownerState: z,
      className: ke.mark
    }), Rr = Ii({
      elementType: Xe,
      externalSlotProps: vt,
      ownerState: z,
      className: ke.markLabel
    }), Fo = Ii({
      elementType: Ee,
      getSlotProps: T,
      externalSlotProps: yt,
      ownerState: z
    });
    return /* @__PURE__ */ S.jsxs(De, {
      ...At,
      children: [/* @__PURE__ */ S.jsx(ze, {
        ...qt
      }), /* @__PURE__ */ S.jsx(Ue, {
        ...Mn
      }), Z.filter((on) => on.value >= k && on.value <= _).map((on, bn) => {
        const Kr = Ub(on.value, k, _), To = L[ne].offset(Kr);
        let tr;
        return q === !1 ? tr = ee.includes(on.value) : tr = q === "normal" && (ae ? on.value >= ee[0] && on.value <= ee[ee.length - 1] : on.value <= ee[0]) || q === "inverted" && (ae ? on.value <= ee[0] || on.value >= ee[ee.length - 1] : on.value >= ee[0]), /* @__PURE__ */ S.jsxs(C.Fragment, {
          children: [/* @__PURE__ */ S.jsx(It, {
            "data-index": bn,
            ...Ct,
            ...!Va(It) && {
              markActive: tr
            },
            style: {
              ...To,
              ...Ct.style
            },
            className: Le(Ct.className, tr && ke.markActive)
          }), on.label != null ? /* @__PURE__ */ S.jsx(Xe, {
            "aria-hidden": !0,
            "data-index": bn,
            ...Rr,
            ...!Va(Xe) && {
              markLabelActive: tr
            },
            style: {
              ...To,
              ...Rr.style
            },
            className: Le(ke.markLabel, Rr.className, tr && ke.markLabelActive),
            children: on.label
          }) : null]
        }, bn);
      }), ee.map((on, bn) => {
        const Kr = Ub(on, k, _), To = L[ne].offset(Kr), tr = G === "off" ? RIe : Pe;
        return (
          /* TODO v6: Change component structure. It will help in avoiding the complicated React.cloneElement API added in SliderValueLabel component. Should be: Thumb -> Input, ValueLabel. Follow Joy UI's Slider structure. */
          /* @__PURE__ */ S.jsx(tr, {
            ...!Va(tr) && {
              valueLabelFormat: W,
              valueLabelDisplay: G,
              value: typeof W == "function" ? W(F(on), bn) : W,
              index: bn,
              open: X === bn || Q === bn || G === "on",
              disabled: y
            },
            ...bt,
            children: /* @__PURE__ */ S.jsx(He, {
              "data-index": bn,
              ...Re,
              className: Le(ke.thumb, Re.className, Q === bn && ke.active, te === bn && ke.focusVisible),
              style: {
                ...To,
                ...be(bn),
                ...Re.style
              },
              children: /* @__PURE__ */ S.jsx(Ee, {
                "data-index": bn,
                "aria-label": b ? b(bn) : o,
                "aria-valuenow": F(on),
                "aria-labelledby": i,
                "aria-valuetext": v ? v(F(on), bn) : a,
                value: ee[bn],
                ...Fo
              })
            })
          }, bn)
        );
      })]
    });
  });
  function IIe(e) {
    const { value: t, readonly: n, disabled: r, onBlur: o, onFocus: a, options: i, schema: s, onChange: u, required: c, label: f, hideLabel: p, id: g } = e, h = { value: t, label: f, id: g, name: g, ...w1(s) }, y = (w, _) => {
      u(_ ?? i.emptyValue);
    }, b = ({ target: w }) => o(g, w && w.value), v = ({ target: w }) => a(g, w && w.value);
    return S.jsxs(S.Fragment, { children: [Ru(S.jsx(Rx, { required: c, htmlFor: g, children: f || void 0 }), p), S.jsx(jIe, { disabled: r || n, onChange: y, onBlur: b, onFocus: v, valueLabelDisplay: "auto", ...h, "aria-describedby": vo(g) })] });
  }
  function AIe(e) {
    return rt("MuiMenuItem", e);
  }
  const lp = tt("MuiMenuItem", ["root", "focusVisible", "dense", "disabled", "divider", "gutters", "selected"]), $Ie = (e, t) => {
    const {
      ownerState: n
    } = e;
    return [t.root, n.dense && t.dense, n.divider && t.divider, !n.disableGutters && t.gutters];
  }, DIe = (e) => {
    const {
      disabled: t,
      dense: n,
      divider: r,
      disableGutters: o,
      selected: a,
      classes: i
    } = e, s = nt({
      root: ["root", n && "dense", t && "disabled", !o && "gutters", r && "divider", a && "selected"]
    }, AIe, i);
    return {
      ...i,
      ...s
    };
  }, LIe = Me(zm, {
    shouldForwardProp: (e) => kr(e) || e === "classes",
    name: "MuiMenuItem",
    slot: "Root",
    overridesResolver: $Ie
  })(at(({
    theme: e
  }) => ({
    ...e.typography.body1,
    display: "flex",
    justifyContent: "flex-start",
    alignItems: "center",
    position: "relative",
    textDecoration: "none",
    minHeight: 48,
    paddingTop: 6,
    paddingBottom: 6,
    boxSizing: "border-box",
    whiteSpace: "nowrap",
    "&:hover": {
      textDecoration: "none",
      backgroundColor: (e.vars || e).palette.action.hover,
      // Reset on touch devices, it doesn't add specificity
      "@media (hover: none)": {
        backgroundColor: "transparent"
      }
    },
    [`&.${lp.selected}`]: {
      backgroundColor: e.alpha((e.vars || e).palette.primary.main, (e.vars || e).palette.action.selectedOpacity),
      [`&.${lp.focusVisible}`]: {
        backgroundColor: e.alpha((e.vars || e).palette.primary.main, `${(e.vars || e).palette.action.selectedOpacity} + ${(e.vars || e).palette.action.focusOpacity}`)
      }
    },
    [`&.${lp.selected}:hover`]: {
      backgroundColor: e.alpha((e.vars || e).palette.primary.main, `${(e.vars || e).palette.action.selectedOpacity} + ${(e.vars || e).palette.action.hoverOpacity}`),
      // Reset on touch devices, it doesn't add specificity
      "@media (hover: none)": {
        backgroundColor: e.alpha((e.vars || e).palette.primary.main, (e.vars || e).palette.action.selectedOpacity)
      }
    },
    [`&.${lp.focusVisible}`]: {
      backgroundColor: (e.vars || e).palette.action.focus
    },
    [`&.${lp.disabled}`]: {
      opacity: (e.vars || e).palette.action.disabledOpacity
    },
    [`& + .${WL.root}`]: {
      marginTop: e.spacing(1),
      marginBottom: e.spacing(1)
    },
    [`& + .${WL.inset}`]: {
      marginLeft: 52
    },
    [`& .${Yc.root}`]: {
      marginTop: 0,
      marginBottom: 0
    },
    [`& .${Yc.inset}`]: {
      paddingLeft: 36
    },
    [`& .${UL.root}`]: {
      minWidth: 36
    },
    variants: [{
      props: ({
        ownerState: t
      }) => !t.disableGutters,
      style: {
        paddingLeft: 16,
        paddingRight: 16
      }
    }, {
      props: ({
        ownerState: t
      }) => t.divider,
      style: {
        borderBottom: `1px solid ${(e.vars || e).palette.divider}`,
        backgroundClip: "padding-box"
      }
    }, {
      props: ({
        ownerState: t
      }) => !t.dense,
      style: {
        [e.breakpoints.up("sm")]: {
          minHeight: "auto"
        }
      }
    }, {
      props: ({
        ownerState: t
      }) => t.dense,
      style: {
        minHeight: 32,
        // https://m2.material.io/components/menus#specs > Dense
        paddingTop: 4,
        paddingBottom: 4,
        ...e.typography.body2,
        [`& .${UL.root} svg`]: {
          fontSize: "1.25rem"
        }
      }
    }]
  }))), JL = /* @__PURE__ */ C.forwardRef(function(e, t) {
    const n = lt({
      props: e,
      name: "MuiMenuItem"
    }), {
      autoFocus: r = !1,
      component: o = "li",
      dense: a = !1,
      divider: i = !1,
      disableGutters: s = !1,
      focusVisibleClassName: u,
      role: c = "menuitem",
      tabIndex: f,
      className: p,
      ...g
    } = n, h = C.useContext(Bi), y = C.useMemo(() => ({
      dense: a || h.dense || !1,
      disableGutters: s
    }), [h.dense, a, s]), b = C.useRef(null);
    ta(() => {
      r && (b.current && b.current.focus());
    }, [r]);
    const v = {
      ...n,
      dense: y.dense,
      divider: i,
      disableGutters: s
    }, w = DIe(n), _ = Zn(b, t);
    let k;
    return n.disabled || (k = f !== void 0 ? f : -1), /* @__PURE__ */ S.jsx(Bi.Provider, {
      value: y,
      children: /* @__PURE__ */ S.jsx(LIe, {
        ref: _,
        role: c,
        tabIndex: k,
        component: o,
        focusVisibleClassName: Le(w.focusVisible, u),
        className: Le(w.root, p),
        ...g,
        ownerState: v,
        classes: w
      })
    });
  });
  function FIe({
    schema: e,
    id: t,
    name: n,
    // remove this from textFieldProps
    htmlName: r,
    options: o,
    label: a,
    hideLabel: i,
    required: s,
    disabled: u,
    placeholder: c,
    readonly: f,
    value: p,
    multiple: g,
    autofocus: h,
    onChange: y,
    onBlur: b,
    onFocus: v,
    errorSchema: w,
    rawErrors: _ = [],
    registry: k,
    uiSchema: E,
    hideError: P,
    ...O
  }) {
    const { enumOptions: M, enumDisabled: I, emptyValue: A } = o;
    g = typeof g > "u" ? !1 : !!g;
    const D = g ? [] : "", F = typeof p > "u" || g && p.length < 1 || !g && p === D, j = ({ target: { value: L } }) => y(Qn(L, M, A)), U = ({ target: L }) => b(t, Qn(L && L.value, M, A)), $ = ({ target: L }) => v(t, Qn(L && L.value, M, A)), q = aO(p, M, g), { InputLabelProps: B, SelectProps: G, autocomplete: W, ...Y } = O, z = !g && e.default === void 0;
    return S.jsxs(jO, { id: t, name: r || t, label: Ru(a || void 0, i, void 0), value: !F && typeof q < "u" ? q : D, required: s, disabled: u || f, autoFocus: h, autoComplete: W, placeholder: c, error: _.length > 0, onChange: j, onBlur: U, onFocus: $, ...Y, select: !0, InputLabelProps: {
      ...B,
      shrink: !F
    }, SelectProps: {
      ...G,
      multiple: g
    }, "aria-describedby": vo(t), children: [z && S.jsx(JL, { value: "", children: c }), Array.isArray(M) && M.map(({ value: L, label: K }, T) => {
      const V = Array.isArray(I) && I.indexOf(L) !== -1;
      return S.jsx(JL, { value: String(T), disabled: V, children: K }, T);
    })] });
  }
  function TIe(e) {
    const { options: t, registry: n } = e, r = et("BaseInputTemplate", n, t);
    let o = 5;
    return (typeof t.rows == "string" || typeof t.rows == "number") && (o = t.rows), S.jsx(r, { ...e, multiline: !0, rows: o });
  }
  function zIe() {
    return {
      CheckboxWidget: V5e,
      CheckboxesWidget: q5e,
      RadioWidget: uIe,
      RangeWidget: IIe,
      SelectWidget: FIe,
      TextareaWidget: TIe
    };
  }
  function SU() {
    return {
      templates: _5e(),
      widgets: zIe()
    };
  }
  const BIe = SU();
  function VIe() {
    return Z1(SU());
  }
  VIe();
  const UIe = Z1(BIe), HIe = mw({
    cssVariables: { nativeColor: !0 },
    palette: {
      primary: {
        main: "var(--fn-primary-color)",
        contrastText: "var(--fn-app-background)"
      },
      text: {
        primary: "var(--fn-text-color-neutral)",
        secondary: "var(--fn-text-color-neutral)",
        disabled: "var(--fn-text-color-neutral)",
        primaryChannel: "var(--fn-text-color-neutral-channel)",
        secondaryChannel: "var(--fn-text-color-neutral-channel)"
      },
      common: {
        black: "var(--fn-primary-color)",
        white: "var(--fn-app-background)"
      },
      background: {
        default: "var(--fn-app-background)",
        paper: "var(--fn-app-background)",
        defaultChannel: "var(--fn-app-background-channel)",
        paperChannel: "var(--fn-app-background-channel)"
      }
    },
    shape: {
      borderRadius: "var(--fn-border-radius-s)"
    }
  }), _U = ({
    getter: e,
    setter: t,
    setter_calls_getter: n = !1,
    disabled: r = !1,
    readonly: o = !1
  }) => {
    const [a, i] = C.useState(null), [s, u] = C.useState(void 0), [c, f] = C.useState(void 0), p = C.useCallback(async () => {
      const h = await e();
      i(h.jsonSchema), u(h.uiSchema), f(h.formData);
    }, [e]), g = C.useCallback(
      async (h) => {
        await t(h), n && await p();
      },
      [t, n, p]
    );
    return C.useEffect(() => {
      p();
    }, [p]), a ? /* @__PURE__ */ S.jsx(bMe, { theme: HIe, children: /* @__PURE__ */ S.jsx(
      UIe,
      {
        schema: a,
        uiSchema: s || void 0,
        formData: c || void 0,
        validator: JCe,
        liveValidate: "onChange",
        onChange: ({ formData: h }) => f(h),
        onSubmit: ({ formData: h }) => g(h),
        disabled: r,
        readonly: o
      }
    ) }) : /* @__PURE__ */ S.jsx("div", { children: "Loading" });
  }, WIe = ({
    jsonSchema: e,
    uiSchema: t,
    full: n,
    readonly: r
  }) => {
    const o = {
      jsonSchema: e,
      uiSchema: t,
      formData: {}
    };
    r && (o.uiSchema = {
      ...o.uiSchema,
      "ui:readonly": !0,
      "ui:disabled": !0,
      "ui:submitButtonOptions": {
        norender: !0,
        props: {
          disabled: r,
          className: "btn btn-info"
        }
      }
    });
    const a = n?.value;
    return a && (typeof a == "object" && a !== null && "schema" in a && "data" in a ? (o.jsonSchema = a.schema, o.formData = a.data ?? {}) : o.formData = a), o;
  }, qIe = ({ inputconverter: e }) => {
    const t = Sn(), { preview: n, full: r } = t.valuestore(), o = t.use(), [a, i] = C.useState(!1), s = ih(), u = _u(o), c = o.render_options.schema, f = o.render_options.uiSchema, p = C.useMemo(() => {
      if (!c)
        throw new Error("No jsonSchema provided");
      return WIe({
        jsonSchema: c,
        uiSchema: f,
        full: r,
        readonly: o.connected
      });
    }, [c, f, r, n, o.connected]), g = C.useCallback(
      async () => p,
      [p]
    ), h = C.useCallback(
      async (y) => {
        u(y), i(!1);
      },
      [u]
    );
    return /* @__PURE__ */ S.jsx(
      Qa,
      {
        title: o.name,
        description: "Edit " + o.name,
        open: a,
        setOpen: i,
        trigger: /* @__PURE__ */ S.jsx("button", { className: "nodedatainput styledinput", children: "Edit" }),
        onOpenChange: (y) => {
          y && !r && s?.();
        },
        children: /* @__PURE__ */ S.jsx(
          _U,
          {
            getter: g,
            setter: h,
            setter_calls_getter: !1,
            disabled: o.connected,
            readonly: o.connected
          }
        )
      }
    );
  }, KIe = {
    float: xwe,
    int: kwe,
    bool: Jbe,
    string: b3,
    str: b3,
    color: Qbe,
    select: pm,
    enum: pm,
    json_schema: qIe,
    bytes: L7(NP, "")
  }, GIe = {}, XIe = {}, xa = {
    Inputrenderer: KIe,
    Outputrenderer: Gbe,
    HandlePreviewRenderer: qbe,
    DataOverlayRenderer: Wbe,
    DataPreviewViewRenderer: F7,
    DataViewRenderer: MP,
    InLineRenderer: Hbe,
    NodeRenderer: GIe,
    NodeHooks: XIe
  }, YIe = (e, t) => {
    const n = t.options || {}, r = n.overwrite === void 0 ? !0 : n.overwrite;
    switch (t.type) {
      case "EXTEND_INPUT_RENDER":
        return !r && e.Inputrenderer[t.payload.type] ? e : {
          ...e,
          Inputrenderer: {
            ...e.Inputrenderer,
            [t.payload.type]: t.payload.component
          }
        };
      case "EXTEND_FROM_PLUGIN": {
        let a = !1;
        const i = [
          [t.payload.plugin.input_renderers || {}, e.Inputrenderer],
          [t.payload.plugin.output_renderers || {}, e.Outputrenderer],
          [
            t.payload.plugin.handle_preview_renderers || {},
            e.HandlePreviewRenderer
          ],
          [
            t.payload.plugin.data_overlay_renderers || {},
            e.DataOverlayRenderer
          ],
          [
            t.payload.plugin.data_preview_renderers || {},
            e.DataPreviewViewRenderer
          ],
          [
            t.payload.plugin.data_view_renderers || {},
            e.DataViewRenderer
          ],
          [t.payload.plugin.node_renderers || {}, e.NodeRenderer],
          [t.payload.plugin.node_hooks || {}, e.NodeHooks]
        ];
        for (const [u, c] of i) {
          if (Object.keys(u).length > 0) {
            if (r)
              a = !0;
            else
              for (const f in u)
                if (!c[f]) {
                  a = !0;
                  break;
                }
          }
          if (a) break;
        }
        if (!a)
          return e;
        const s = { ...e };
        return i.forEach(([u, c]) => {
          Object.assign(c, u);
        }), s;
      }
      default:
        const o = {
          EXTEND_OUTPUT_RENDER: "Outputrenderer",
          EXTEND_HANDLE_PREVIEW_RENDER: "HandlePreviewRenderer",
          EXTEND_DATA_OVERLAY_RENDER: "DataOverlayRenderer",
          EXTEND_DATA_PREVIEW_RENDER: "DataPreviewViewRenderer",
          EXTEND_DATA_VIEW_RENDER: "DataViewRenderer",
          EXTEND_NODE_CONTEXT_EXTENDER: "NodeContextExtenders",
          EXTEND_NODE_RENDERER: "NodeRenderer",
          EXTEND_NODE_HOOKS: "NodeHooks"
        }[t.type];
        if (o) {
          const a = e[o];
          return !r && a[t.payload.type] ? e : {
            ...e,
            [o]: {
              ...a,
              [t.payload.type]: t.payload.component
            }
          };
        }
        return e;
    }
  }, JIe = ({
    children: e,
    plugins: t,
    fnrf_zst: n
  }) => {
    const [r, o] = C.useReducer(
      YIe,
      xa
    ), a = C.useCallback(
      (y, b, v) => {
        o({
          type: "EXTEND_INPUT_RENDER",
          payload: { type: y, component: b },
          options: v
        });
      },
      []
    ), i = C.useCallback(
      (y, b, v) => {
        o({
          type: "EXTEND_OUTPUT_RENDER",
          payload: { type: y, component: b },
          options: v
        });
      },
      []
    ), s = C.useCallback(
      (y, b, v) => {
        o({
          type: "EXTEND_HANDLE_PREVIEW_RENDER",
          payload: { type: y, component: b },
          options: v
        });
      },
      []
    ), u = C.useCallback(
      (y, b, v) => {
        o({
          type: "EXTEND_DATA_OVERLAY_RENDER",
          payload: { type: y, component: b },
          options: v
        });
      },
      []
    ), c = C.useCallback(
      (y, b, v) => {
        o({
          type: "EXTEND_DATA_PREVIEW_RENDER",
          payload: { type: y, component: b },
          options: v
        });
      },
      []
    ), f = C.useCallback(
      (y, b, v) => {
        o({
          type: "EXTEND_DATA_VIEW_RENDER",
          payload: { type: y, component: b },
          options: v
        });
      },
      []
    ), p = C.useCallback(
      (y, b, v) => {
        o({
          type: "EXTEND_NODE_RENDERER",
          payload: { type: y, component: b },
          options: v
        });
      },
      []
    ), g = C.useCallback(
      (y, b, v) => {
        o({
          type: "EXTEND_NODE_HOOKS",
          payload: { type: y, component: b },
          options: v
        });
      },
      []
    ), h = C.useCallback(
      (y, b) => {
        o({
          type: "EXTEND_FROM_PLUGIN",
          payload: { plugin: y },
          options: b
        });
      },
      []
    );
    return C.useEffect(() => {
      for (const y in t) {
        const b = t[y];
        if (!b) continue;
        const v = b.renderpluginfactory;
        v && h(v({ React: Rm, fnrf_zst: n, NodeContext: rx }));
      }
    }, [t, h, n]), /* @__PURE__ */ S.jsx(
      is.Provider,
      {
        value: {
          Inputrenderer: r.Inputrenderer,
          Outputrenderer: r.Outputrenderer,
          HandlePreviewRenderer: r.HandlePreviewRenderer,
          DataOverlayRenderer: r.DataOverlayRenderer,
          DataPreviewViewRenderer: r.DataPreviewViewRenderer,
          DataViewRenderer: r.DataViewRenderer,
          InLineRenderer: r.InLineRenderer,
          NodeRenderer: r.NodeRenderer,
          NodeHooks: r.NodeHooks,
          extendNodeRenderer: p,
          extendInputRenderMapping: a,
          extendOutputRenderMapping: i,
          extendHandlePreviewRenderMapping: s,
          extendDataOverlayRenderMapping: u,
          extendDataPreviewRenderMapping: c,
          extendDataViewRenderMapping: f,
          extendNodeHooks: g,
          extendFromPlugin: h
        },
        children: e
      }
    );
  }, is = C.createContext({
    Inputrenderer: xa.Inputrenderer,
    Outputrenderer: xa.Outputrenderer,
    HandlePreviewRenderer: xa.HandlePreviewRenderer,
    DataOverlayRenderer: xa.DataOverlayRenderer,
    DataPreviewViewRenderer: xa.DataPreviewViewRenderer,
    DataViewRenderer: xa.DataViewRenderer,
    InLineRenderer: xa.InLineRenderer,
    NodeRenderer: xa.NodeRenderer,
    NodeHooks: xa.NodeHooks,
    extendInputRenderMapping: (e, t, n) => {
    },
    extendOutputRenderMapping: (e, t, n) => {
    },
    extendHandlePreviewRenderMapping: (e, t, n) => {
    },
    extendDataOverlayRenderMapping: (e, t, n) => {
    },
    extendDataPreviewRenderMapping: (e, t, n) => {
    },
    extendDataViewRenderMapping: (e, t, n) => {
    },
    extendNodeRenderer: (e, t, n) => {
    },
    extendNodeHooks: (e, t, n) => {
    },
    extendFromPlugin: (e, t) => {
    }
  }), EU = (e) => {
    const t = Vt(), { DataOverlayRenderer: n, DataViewRenderer: r } = C.useContext(is);
    if (e === void 0) return;
    const o = t.render_options(), [a] = Su(e, o.typemap || {});
    return a ? n[a] ? n[a] : r[a] ? ox(r[a]) : y3 : y3;
  }, QIe = (e) => {
    const t = Vt(), n = EU(e), { DataPreviewViewRenderer: r, DataViewRenderer: o } = C.useContext(is), a = t.render_options();
    if (e === void 0) return [void 0, n];
    const [i] = Su(e, a.typemap || {});
    return i ? r[i] ? [r[i], n] : o[i] ? [
      zr(o[i]),
      n
    ] : [
      zr(jb),
      n
    ] : [
      zr(jb),
      n
    ];
  }, ZIe = (e) => {
    const t = Vt().render_options(), { HandlePreviewRenderer: n, DataPreviewViewRenderer: r } = C.useContext(is), o = EU(e);
    let a;
    if (e) {
      const [i] = Su(e, t.typemap || {});
      i ? n[i] ? a = n[i] : r[i] ? a = r[i] : a = zr(
        jb
      ) : a = zr(
        jb
      );
    }
    return [a, o];
  }, eAe = (e) => {
    const [t, n] = C.useState(!1), r = e.use((o) => o.in_trigger);
    return C.useEffect(() => {
      let o;
      return r && !t ? n(!0) : t && (o = setTimeout(() => n(!1), 200)), () => clearTimeout(o);
    }, [r, t]), { visualTrigger: t, nodestore: e };
  }, CU = ({
    iostore: e,
    Component: t
  }) => {
    const [n, r] = C.useState(void 0), [o, a] = C.useState(void 0), { full: i } = e.valuestore(), s = ih();
    C.useEffect(() => {
      i === void 0 ? s?.() : a(i.value);
    }, [i, s]);
    const u = () => {
      o !== void 0 && r(o);
    };
    return /* @__PURE__ */ S.jsx(
      t,
      {
        value: o,
        preValue: n,
        onLoaded: u
      }
    );
  }, PU = ({
    Component: e
  }) => /* @__PURE__ */ S.jsx(e, {}), CE = ({
    typestring: e,
    preview: t,
    ...n
  }) => {
    const [r, o] = C.useState(!1), [a, i] = C.useState(!1), s = Vt(), u = Sn(), c = u.use(), f = ih(), [p, g] = ZIe(c), h = s.local_state(() => s.reactflowRef);
    return (
      // <Tooltip.Provider>
      /* @__PURE__ */ S.jsxs(g9, { open: r || a, onOpenChange: i, children: [
        /* @__PURE__ */ S.jsx(v9, { asChild: !0, children: /* @__PURE__ */ S.jsx(fm, { id: c.id, "data-type": e, ...n }) }),
        /* @__PURE__ */ S.jsx(y9, { container: h, children: /* @__PURE__ */ S.jsxs(
          b9,
          {
            className: "iotooltipcontent",
            sideOffset: 5,
            avoidCollisions: !0,
            collisionBoundary: h,
            collisionPadding: 10,
            onOpenAutoFocus: (y) => y.preventDefault(),
            onCloseAutoFocus: (y) => y.preventDefault(),
            children: [
              /* @__PURE__ */ S.jsxs("div", { className: "iotooltip_container", children: [
                /* @__PURE__ */ S.jsxs("div", { className: "iotooltip_header", children: [
                  c.name,
                  r ? /* @__PURE__ */ S.jsx(Yoe, { onClick: () => o(!1) }) : /* @__PURE__ */ S.jsx(Xoe, { onClick: () => o(!0) }),
                  g && /* @__PURE__ */ S.jsx(
                    Qa,
                    {
                      title: c.full_id,
                      trigger: /* @__PURE__ */ S.jsx(Oz, {}),
                      onOpenChange: (y) => {
                        y && f?.(), o(y);
                      },
                      children: /* @__PURE__ */ S.jsx(
                        CU,
                        {
                          Component: g,
                          iostore: u
                        }
                      )
                    }
                  )
                ] }),
                p ? /* @__PURE__ */ S.jsx(PU, { Component: p }) : `no preview available for "${e}"`
              ] }),
              /* @__PURE__ */ S.jsx(Rie, { className: "iotooltipcontentarrow" })
            ]
          }
        ) })
      ] })
    );
  }, Rd = {
    "": [(e) => e, (e) => e],
    str_to_json: [
      (e) => JSON.parse(e),
      (e) => typeof e == "string" ? e : JSON.stringify(e)
    ],
    str_to_list: [
      (e) => {
        try {
          const t = JSON.parse(e);
          return Array.isArray(t) ? t : [t];
        } catch {
          try {
            return JSON.parse("[" + e + "]");
          } catch {
          }
        }
        throw new Error("Invalid list");
      },
      (e) => JSON.stringify(e)
    ]
  }, tAe = ({
    setNodeSettingsPath: e,
    setShowSettings: t
  }) => {
    const n = Vt().render_options(), r = Sn().use(), [o, a] = Su(r, n.typemap || {}), { Inputrenderer: i } = C.useContext(is), s = o ? r.value_options?.options ? pm : i[o] : void 0, u = Rd[(a && n.inputconverter?.[a]) ?? ""] || Rd[""], { keys: c } = $C(), f = (p) => {
      c.has("s") && (e && e("inputs/" + r.id), t && t(!0), p.stopPropagation());
    };
    return r.hidden ? null : /* @__PURE__ */ S.jsxs(
      "div",
      {
        className: "nodeinput",
        "data-type": o,
        onClick: f,
        children: [
          /* @__PURE__ */ S.jsx(
            CE,
            {
              typestring: o,
              position: Ve.Left,
              type: "target"
            }
          ),
          /* @__PURE__ */ S.jsxs("div", { className: "inner_nodeio", children: [
            s && /* @__PURE__ */ S.jsx("div", { className: "iovaluefield nodrag", "data-type": o, children: /* @__PURE__ */ S.jsx(s, { inputconverter: u }) }),
            /* @__PURE__ */ S.jsx("div", { className: "ioname", children: r.name })
          ] }),
          /* @__PURE__ */ S.jsx(
            CE,
            {
              typestring: o,
              position: Ve.Right,
              type: "source"
            }
          )
        ]
      }
    );
  }, nAe = ({
    setNodeSettingsPath: e,
    setShowSettings: t
  }) => {
    const n = Vt().render_options(), r = Sn().use(), [o] = Su(r, n.typemap || {}), { Outputrenderer: a } = C.useContext(is), { keys: i } = $C(), s = o ? a[o] : void 0, u = (c) => {
      i.has("s") && (e && e("outputs/" + r.id), t && t(!0), c.stopPropagation());
    };
    return r.hidden ? null : /* @__PURE__ */ S.jsxs(
      "div",
      {
        className: "nodeoutput",
        "data-type": o,
        onClick: u,
        children: [
          /* @__PURE__ */ S.jsx(
            CE,
            {
              typestring: o,
              position: Ve.Right,
              type: "source"
            }
          ),
          /* @__PURE__ */ S.jsxs("div", { className: "inner_nodeio", children: [
            /* @__PURE__ */ S.jsx("div", { className: "ioname", children: r.name }),
            s ? /* @__PURE__ */ S.jsx("div", { className: "iovaluefield nodrag", children: /* @__PURE__ */ S.jsx(s, {}) }) : /* @__PURE__ */ S.jsx("div", { className: "iovaluefield", children: /* @__PURE__ */ S.jsx(Kbe, {}) })
          ] })
        ]
      }
    );
  }, rAe = () => {
    const e = Vt().render_options(), t = Sn().use(), n = RP(), [r, o] = Su(t, e.typemap || {}), { Inputrenderer: a } = C.useContext(is), i = r ? t.value_options?.options ? pm : a[r] : void 0, s = Rd[(o && e.inputconverter?.[o]) ?? ""] || Rd[""];
    return /* @__PURE__ */ S.jsxs("div", { className: "nodesettings_component", children: [
      /* @__PURE__ */ S.jsx("div", { children: t.name }),
      i && /* @__PURE__ */ S.jsx(i, { inputconverter: s }),
      /* @__PURE__ */ S.jsx("div", { children: /* @__PURE__ */ S.jsxs("label", { children: [
        "hidden:",
        /* @__PURE__ */ S.jsx(
          "input",
          {
            className: "styledcheckbox",
            type: "checkbox",
            disabled: t.connected,
            onChange: (u) => {
              n?.(u.target.checked);
            },
            checked: t.hidden
          }
        )
      ] }) })
    ] });
  }, oAe = () => {
    const e = Sn().use(), t = RP();
    return /* @__PURE__ */ S.jsxs("div", { className: "nodesettings_component", children: [
      /* @__PURE__ */ S.jsx("div", { children: e.name }),
      /* @__PURE__ */ S.jsx("div", { children: /* @__PURE__ */ S.jsxs("label", { children: [
        "hidden:",
        /* @__PURE__ */ S.jsx(
          "input",
          {
            className: "styledcheckbox",
            type: "checkbox",
            disabled: e.connected,
            onChange: (n) => {
              t?.(n.target.checked);
            },
            checked: e.hidden
          }
        )
      ] }) })
    ] });
  }, OU = ({}) => {
    const e = Vt(), { node: t } = Nr(), n = Sn().use(), r = e.render_options(), o = RP(), [a, i] = C.useState(n.name);
    C.useEffect(() => i(n.name), [n.name]);
    const s = C.useCallback(
      (y) => i(y.target.value),
      []
    ), u = C.useCallback(() => {
      a !== n.name && t?.update_io_options({
        nid: n.node,
        ioid: n.id,
        options: { name: a }
      });
    }, [n, t, a]), [c, f] = Su(
      n,
      r.typemap || {}
    ), p = Rd[(f && r.inputconverter?.[f]) ?? ""] || Rd[""], { Inputrenderer: g } = C.useContext(is), h = c ? n.value_options?.options ? pm : g[c] : void 0;
    return /* @__PURE__ */ S.jsxs("div", { className: "nodesettings-io-entry funcnodes-control-group", children: [
      /* @__PURE__ */ S.jsxs("div", { className: "funcnodes-control-row", children: [
        /* @__PURE__ */ S.jsx("label", { htmlFor: `io-name-${n.id}`, children: "Name:" }),
        /* @__PURE__ */ S.jsx(
          "input",
          {
            id: `io-name-${n.id}`,
            type: "text",
            value: a,
            onChange: s,
            onBlur: u,
            className: "styledinput"
          }
        )
      ] }),
      /* @__PURE__ */ S.jsxs("div", { className: "funcnodes-control-row", children: [
        /* @__PURE__ */ S.jsx("label", { children: "ID:" }),
        /* @__PURE__ */ S.jsx("span", { children: n.id })
      ] }),
      /* @__PURE__ */ S.jsxs("div", { className: "funcnodes-control-row", children: [
        /* @__PURE__ */ S.jsx("label", { children: "Value:" }),
        h && /* @__PURE__ */ S.jsx(h, { inputconverter: p })
      ] }),
      /* @__PURE__ */ S.jsxs("div", { className: "funcnodes-control-row", children: [
        /* @__PURE__ */ S.jsx("label", { children: "Type:" }),
        /* @__PURE__ */ S.jsx("pre", { children: JSON.stringify(n.type, null, 2) })
      ] }),
      /* @__PURE__ */ S.jsxs("div", { className: "funcnodes-control-row", children: [
        /* @__PURE__ */ S.jsx("label", { htmlFor: `io-hidden-${n.id}`, children: "Hidden:" }),
        /* @__PURE__ */ S.jsx(
          "input",
          {
            id: `io-hidden-${n.id}`,
            type: "checkbox",
            checked: n.hidden,
            onChange: (y) => o?.(y.target.checked),
            className: "styledcheckbox",
            disabled: n.connected && n.is_input
          }
        )
      ] }),
      /* @__PURE__ */ S.jsxs("div", { className: "funcnodes-control-row", children: [
        /* @__PURE__ */ S.jsx("label", { children: "Value Options:" }),
        /* @__PURE__ */ S.jsx("pre", { children: JSON.stringify(n.value_options, null, 2) })
      ] }),
      /* @__PURE__ */ S.jsxs("div", { className: "funcnodes-control-row", children: [
        /* @__PURE__ */ S.jsx("label", { children: "Render Options:" }),
        /* @__PURE__ */ S.jsx("pre", { className: "code-display", children: JSON.stringify(n.render_options, null, 2) })
      ] }),
      n.is_input && /* @__PURE__ */ S.jsxs(S.Fragment, { children: [
        /* @__PURE__ */ S.jsxs("div", { className: "funcnodes-control-row", children: [
          /* @__PURE__ */ S.jsx("label", { children: "Does Trigger:" }),
          /* @__PURE__ */ S.jsx("span", { children: String(n.does_trigger) })
        ] }),
        /* @__PURE__ */ S.jsxs("div", { className: "funcnodes-control-row", children: [
          /* @__PURE__ */ S.jsx("label", { children: "Required:" }),
          /* @__PURE__ */ S.jsx("span", { children: String(n.required) })
        ] })
      ] }),
      /* @__PURE__ */ S.jsxs("div", { className: "funcnodes-control-row", children: [
        /* @__PURE__ */ S.jsx("label", { children: "Emit Value Set:" }),
        /* @__PURE__ */ S.jsx("span", { children: String(n.emit_value_set) })
      ] }),
      /* @__PURE__ */ S.jsx("hr", {})
    ] });
  }, PE = {
    xxs: 0,
    xs: 320,
    s: 480,
    m: 768,
    l: 960,
    xl: 1280,
    xxl: 1920
  }, aAe = Object.entries(PE).sort(
    ([, e], [, t]) => t - e
  ), NU = C.createContext(void 0), iAe = (e, t) => {
    let n;
    return ((...r) => {
      clearTimeout(n), n = setTimeout(() => e(...r), t);
    });
  }, sAe = (e) => {
    for (const [t, n] of aAe)
      if (e >= n)
        return t;
    return "xxs";
  }, MU = C.memo(
    C.forwardRef(
      (e, t) => {
        const { className: n, children: r, ...o } = e, [a, i] = C.useState(
          {
            wKey: "m",
            w: 0,
            h: 0
          }
        ), s = C.useRef(null);
        C.useImperativeHandle(
          t,
          () => s.current,
          []
        );
        const u = C.useCallback((f) => {
          const p = f.width, g = f.height, h = sAe(p);
          i((y) => y.wKey === h && y.w === p && y.h === g ? y : { wKey: h, w: p, h: g });
        }, []), c = C.useMemo(
          () => iAe(u, 16),
          [u]
        );
        return C.useEffect(() => {
          const f = s.current;
          if (!f)
            return;
          const p = new ResizeObserver((g) => {
            const h = g[0];
            h && c(h.contentRect);
          });
          return u(f.getBoundingClientRect()), p.observe(f), () => {
            p.disconnect();
          };
        }, [u, c]), /* @__PURE__ */ S.jsx(NU.Provider, { value: a, children: /* @__PURE__ */ S.jsx(
          "div",
          {
            ref: s,
            className: `size-context w-${a.wKey} ${n || ""}`.trim(),
            ...o,
            children: r
          }
        ) });
      }
    )
  );
  MU.displayName = "SizeContextContainer";
  const lAe = () => {
    const e = C.useContext(NU);
    if (!e)
      throw new Error(
        "useSizeContext must be used within a SizeContextContainerContext"
      );
    return e;
  }, uAe = (e, t) => e === t ? !1 : e === "" ? !0 : PE[e] < PE[t], cAe = (e) => {
    const { wKey: t } = lAe();
    return uAe(t, e);
  }, QL = (e, t, n = "", r = "") => {
    const o = [];
    return typeof e == "string" ? o.push(`${t}-${e}`) : typeof e == "boolean" ? o.push(e ? n : r) : e && typeof e == "object" && Object.entries(e).forEach(([a, i]) => {
      if (typeof i == "string")
        o.push(
          a === "" ? `${t}-${i}` : `${a}-${t}-${i}`
        );
      else if (typeof i == "boolean") {
        const s = i ? n : r;
        s && o.push(a === "" ? s : `${a}-${s}`);
      }
    }), o.filter(Boolean).join(" ");
  }, el = C.memo(
    ({
      direction: e,
      className: t = "",
      children: n,
      wrap: r = !1,
      grow: o = !1,
      ...a
    }) => {
      const i = "float-container", s = QL(e, "direction"), u = QL(o, "", "grow", "no-grow"), c = [
        i,
        s,
        u,
        typeof r == "boolean" && r ? "flex-wrap" : "",
        t
      ].filter(Boolean).join(" ");
      return /* @__PURE__ */ S.jsx("div", { className: c, ...a, children: n });
    }
  );
  el.displayName = "FloatContainer";
  const dAe = {
    up: (e) => /* @__PURE__ */ S.jsx(S.Fragment, { children: "" }),
    down: (e) => /* @__PURE__ */ S.jsx(S.Fragment, { children: "" }),
    left: (e) => /* @__PURE__ */ S.jsx(S.Fragment, { children: "" }),
    right: (e) => /* @__PURE__ */ S.jsx(S.Fragment, { children: "" })
  }, fAe = {
    up: (e) => /* @__PURE__ */ S.jsx(S.Fragment, { children: "" }),
    down: (e) => /* @__PURE__ */ S.jsx(S.Fragment, { children: "" }),
    left: (e) => /* @__PURE__ */ S.jsx(S.Fragment, { children: "" }),
    right: (e) => /* @__PURE__ */ S.jsx(S.Fragment, { children: "" })
  }, AO = C.memo(
    ({
      direction: e,
      expanded: t = !0,
      children: n,
      className: r,
      maxSize: o = "18.75rem",
      expanderSize: a = "2rem",
      containerStyle: i,
      style: s,
      containerClassName: u,
      expandIcons: c,
      collapseIcons: f,
      onExpandChange: p,
      ...g
    }) => {
      const [h, y] = C.useState(t);
      C.useEffect(() => {
        y(t);
      }, [t]);
      const b = C.useCallback(() => {
        y((D) => {
          const F = !D;
          return p?.(F), F;
        });
      }, [p]), v = C.useCallback(
        (D) => {
          (D.key === "Enter" || D.key === " ") && (D.preventDefault(), b());
        },
        [b]
      ), w = e === "right" || e === "left", _ = e === "left" || e === "up", k = h ? f?.[e] || fAe[e] : c?.[e] || dAe[e], E = `${e} ${h ? "expanded" : "collapsed"}`, P = C.useMemo(
        () => ({
          [w ? "width" : "height"]: h ? o : a
        }),
        [w, h, o, a]
      ), O = C.useMemo(
        () => ({
          [w ? "width" : "height"]: h ? o : 0
        }),
        [w, h, o]
      ), M = C.useMemo(
        () => ({
          [w ? "width" : "height"]: a
        }),
        [w, a]
      ), I = /* @__PURE__ */ S.jsx(
        "div",
        {
          className: `expanding_container_content ${E} ${r || ""}`.trim(),
          style: { ...s, ...O },
          ...g,
          children: n
        }
      ), A = /* @__PURE__ */ S.jsx(
        "div",
        {
          className: `expanding_container_expander ${E}`,
          onClick: b,
          onKeyDown: v,
          style: M,
          role: "button",
          tabIndex: 0,
          "aria-label": `${h ? "Collapse" : "Expand"} ${e}`,
          children: /* @__PURE__ */ S.jsx(k, {})
        }
      );
      return /* @__PURE__ */ S.jsxs(
        "div",
        {
          className: `expanding_container ${E} ${u || ""}`,
          style: { ...i, ...P },
          children: [
            _ ? A : I,
            _ ? I : A
          ]
        }
      );
    }
  );
  AO.displayName = "ExpandingContainer";
  const pAe = ({ nodestore: e }) => {
    const t = e.use();
    return /* @__PURE__ */ S.jsx(rx.Provider, { value: e, children: /* @__PURE__ */ S.jsxs("div", { className: "nodesettings_content", children: [
      /* @__PURE__ */ S.jsx("div", { className: "nodesettings_section", children: /* @__PURE__ */ S.jsxs("div", { className: "nodesettings_component", children: [
        /* @__PURE__ */ S.jsx("div", { children: "Name" }),
        /* @__PURE__ */ S.jsx("div", { children: /* @__PURE__ */ S.jsx(FO, {}) })
      ] }) }),
      /* @__PURE__ */ S.jsxs("div", { className: "nodesettings_section", children: [
        /* @__PURE__ */ S.jsx("div", { children: "Inputs" }),
        t.inputs.map((n) => {
          const r = e.io_stores.get(n);
          if (r)
            return /* @__PURE__ */ S.jsx(ul.Provider, { value: r, children: /* @__PURE__ */ S.jsx(rAe, {}) }, n);
        })
      ] }),
      /* @__PURE__ */ S.jsxs("div", { className: "nodesettings_section", children: [
        /* @__PURE__ */ S.jsx("div", { children: "Outputs" }),
        t.outputs.map((n) => {
          const r = e.io_stores.get(n);
          if (r)
            return /* @__PURE__ */ S.jsx(ul.Provider, { value: r, children: /* @__PURE__ */ S.jsx(oAe, {}) }, n);
        })
      ] })
    ] }) });
  }, mAe = () => {
    const e = Vt(), t = e.local_state((r) => r.selected_nodes);
    if (t.length === 0)
      return /* @__PURE__ */ S.jsx("div", { children: "Node Settings" });
    if (t.length > 1)
      return /* @__PURE__ */ S.jsx("div", { children: "Multiple Nodes Selected" });
    const n = e.nodespace.get_node(t[0]);
    return n ? /* @__PURE__ */ S.jsx(pAe, { nodestore: n }) : /* @__PURE__ */ S.jsx("div", { children: "Node not found" });
  }, hAe = () => {
    const e = Vt(), t = e.local_settings(
      (r) => r.view_settings.expand_node_props
    ), n = (r) => {
      e.update_view_settings({ expand_node_props: r });
    };
    return /* @__PURE__ */ S.jsx(
      AO,
      {
        direction: "left",
        expanded: t === void 0 ? !1 : t,
        containerClassName: "pos-right pos-top bg1 h-12",
        className: "nodesettings_content",
        onExpandChange: n,
        collapseIcons: {
          up: ub,
          down: em,
          left: Zp,
          right: lb
        },
        expandIcons: {
          up: em,
          down: ub,
          left: lb,
          right: Zp
        },
        children: /* @__PURE__ */ S.jsx(mAe, {})
      }
    );
  };
  var A0 = "rovingFocusGroup.onEntryFocus", gAe = { bubbles: !1, cancelable: !0 }, yh = "RovingFocusGroup", [OE, RU, vAe] = Lw(yh), [yAe, jx] = Ja(
    yh,
    [vAe]
  ), [bAe, wAe] = yAe(yh), jU = C.forwardRef(
    (e, t) => /* @__PURE__ */ S.jsx(OE.Provider, { scope: e.__scopeRovingFocusGroup, children: /* @__PURE__ */ S.jsx(OE.Slot, { scope: e.__scopeRovingFocusGroup, children: /* @__PURE__ */ S.jsx(xAe, { ...e, ref: t }) }) })
  );
  jU.displayName = yh;
  var xAe = C.forwardRef((e, t) => {
    const {
      __scopeRovingFocusGroup: n,
      orientation: r,
      loop: o = !1,
      dir: a,
      currentTabStopId: i,
      defaultCurrentTabStopId: s,
      onCurrentTabStopIdChange: u,
      onEntryFocus: c,
      preventScrollOnEntryFocus: f = !1,
      ...p
    } = e, g = C.useRef(null), h = un(t, g), y = ax(a), [b, v] = ml({
      prop: i,
      defaultProp: s ?? null,
      onChange: u,
      caller: yh
    }), [w, _] = C.useState(!1), k = Wr(c), E = RU(n), P = C.useRef(!1), [O, M] = C.useState(0);
    return C.useEffect(() => {
      const I = g.current;
      if (I)
        return I.addEventListener(A0, k), () => I.removeEventListener(A0, k);
    }, [k]), /* @__PURE__ */ S.jsx(
      bAe,
      {
        scope: n,
        orientation: r,
        dir: y,
        loop: o,
        currentTabStopId: b,
        onItemFocus: C.useCallback(
          (I) => v(I),
          [v]
        ),
        onItemShiftTab: C.useCallback(() => _(!0), []),
        onFocusableItemAdd: C.useCallback(
          () => M((I) => I + 1),
          []
        ),
        onFocusableItemRemove: C.useCallback(
          () => M((I) => I - 1),
          []
        ),
        children: /* @__PURE__ */ S.jsx(
          gt.div,
          {
            tabIndex: w || O === 0 ? -1 : 0,
            "data-orientation": r,
            ...p,
            ref: h,
            style: { outline: "none", ...e.style },
            onMouseDown: Te(e.onMouseDown, () => {
              P.current = !0;
            }),
            onFocus: Te(e.onFocus, (I) => {
              const A = !P.current;
              if (I.target === I.currentTarget && A && !w) {
                const D = new CustomEvent(A0, gAe);
                if (I.currentTarget.dispatchEvent(D), !D.defaultPrevented) {
                  const F = E().filter((q) => q.focusable), j = F.find((q) => q.active), U = F.find((q) => q.id === b), $ = [j, U, ...F].filter(
                    Boolean
                  ).map((q) => q.ref.current);
                  $U($, f);
                }
              }
              P.current = !1;
            }),
            onBlur: Te(e.onBlur, () => _(!1))
          }
        )
      }
    );
  }), IU = "RovingFocusGroupItem", AU = C.forwardRef(
    (e, t) => {
      const {
        __scopeRovingFocusGroup: n,
        focusable: r = !0,
        active: o = !1,
        tabStopId: a,
        children: i,
        ...s
      } = e, u = Ua(), c = a || u, f = wAe(IU, n), p = f.currentTabStopId === c, g = RU(n), { onFocusableItemAdd: h, onFocusableItemRemove: y, currentTabStopId: b } = f;
      return C.useEffect(() => {
        if (r)
          return h(), () => y();
      }, [r, h, y]), /* @__PURE__ */ S.jsx(
        OE.ItemSlot,
        {
          scope: n,
          id: c,
          focusable: r,
          active: o,
          children: /* @__PURE__ */ S.jsx(
            gt.span,
            {
              tabIndex: p ? 0 : -1,
              "data-orientation": f.orientation,
              ...s,
              ref: t,
              onMouseDown: Te(e.onMouseDown, (v) => {
                r ? f.onItemFocus(c) : v.preventDefault();
              }),
              onFocus: Te(e.onFocus, () => f.onItemFocus(c)),
              onKeyDown: Te(e.onKeyDown, (v) => {
                if (v.key === "Tab" && v.shiftKey) {
                  f.onItemShiftTab();
                  return;
                }
                if (v.target !== v.currentTarget) return;
                const w = _Ae(v, f.orientation, f.dir);
                if (w !== void 0) {
                  if (v.metaKey || v.ctrlKey || v.altKey || v.shiftKey) return;
                  v.preventDefault();
                  let _ = g().filter((k) => k.focusable).map((k) => k.ref.current);
                  if (w === "last") _.reverse();
                  else if (w === "prev" || w === "next") {
                    w === "prev" && _.reverse();
                    const k = _.indexOf(v.currentTarget);
                    _ = f.loop ? EAe(_, k + 1) : _.slice(k + 1);
                  }
                  setTimeout(() => $U(_));
                }
              }),
              children: typeof i == "function" ? i({ isCurrentTabStop: p, hasTabStop: b != null }) : i
            }
          )
        }
      );
    }
  );
  AU.displayName = IU;
  var kAe = {
    ArrowLeft: "prev",
    ArrowUp: "prev",
    ArrowRight: "next",
    ArrowDown: "next",
    PageUp: "first",
    Home: "first",
    PageDown: "last",
    End: "last"
  };
  function SAe(e, t) {
    return t !== "rtl" ? e : e === "ArrowLeft" ? "ArrowRight" : e === "ArrowRight" ? "ArrowLeft" : e;
  }
  function _Ae(e, t, n) {
    const r = SAe(e.key, n);
    if (!(t === "vertical" && ["ArrowLeft", "ArrowRight"].includes(r)) && !(t === "horizontal" && ["ArrowUp", "ArrowDown"].includes(r)))
      return kAe[r];
  }
  function $U(e, t = !1) {
    const n = document.activeElement;
    for (const r of e)
      if (r === n || (r.focus({ preventScroll: t }), document.activeElement !== n)) return;
  }
  function EAe(e, t) {
    return e.map((n, r) => e[(t + r) % e.length]);
  }
  var DU = jU, LU = AU, Ix = "Tabs", [CAe] = Ja(Ix, [
    jx
  ]), FU = jx(), [PAe, $O] = CAe(Ix), TU = C.forwardRef(
    (e, t) => {
      const {
        __scopeTabs: n,
        value: r,
        onValueChange: o,
        defaultValue: a,
        orientation: i = "horizontal",
        dir: s,
        activationMode: u = "automatic",
        ...c
      } = e, f = ax(s), [p, g] = ml({
        prop: r,
        onChange: o,
        defaultProp: a ?? "",
        caller: Ix
      });
      return /* @__PURE__ */ S.jsx(
        PAe,
        {
          scope: n,
          baseId: Ua(),
          value: p,
          onValueChange: g,
          orientation: i,
          dir: f,
          activationMode: u,
          children: /* @__PURE__ */ S.jsx(
            gt.div,
            {
              dir: f,
              "data-orientation": i,
              ...c,
              ref: t
            }
          )
        }
      );
    }
  );
  TU.displayName = Ix;
  var zU = "TabsList", BU = C.forwardRef(
    (e, t) => {
      const { __scopeTabs: n, loop: r = !0, ...o } = e, a = $O(zU, n), i = FU(n);
      return /* @__PURE__ */ S.jsx(
        DU,
        {
          asChild: !0,
          ...i,
          orientation: a.orientation,
          dir: a.dir,
          loop: r,
          children: /* @__PURE__ */ S.jsx(
            gt.div,
            {
              role: "tablist",
              "aria-orientation": a.orientation,
              ...o,
              ref: t
            }
          )
        }
      );
    }
  );
  BU.displayName = zU;
  var VU = "TabsTrigger", UU = C.forwardRef(
    (e, t) => {
      const { __scopeTabs: n, value: r, disabled: o = !1, ...a } = e, i = $O(VU, n), s = FU(n), u = qU(i.baseId, r), c = KU(i.baseId, r), f = r === i.value;
      return /* @__PURE__ */ S.jsx(
        LU,
        {
          asChild: !0,
          ...s,
          focusable: !o,
          active: f,
          children: /* @__PURE__ */ S.jsx(
            gt.button,
            {
              type: "button",
              role: "tab",
              "aria-selected": f,
              "aria-controls": c,
              "data-state": f ? "active" : "inactive",
              "data-disabled": o ? "" : void 0,
              disabled: o,
              id: u,
              ...a,
              ref: t,
              onMouseDown: Te(e.onMouseDown, (p) => {
                !o && p.button === 0 && p.ctrlKey === !1 ? i.onValueChange(r) : p.preventDefault();
              }),
              onKeyDown: Te(e.onKeyDown, (p) => {
                [" ", "Enter"].includes(p.key) && i.onValueChange(r);
              }),
              onFocus: Te(e.onFocus, () => {
                const p = i.activationMode !== "manual";
                !f && !o && p && i.onValueChange(r);
              })
            }
          )
        }
      );
    }
  );
  UU.displayName = VU;
  var HU = "TabsContent", WU = C.forwardRef(
    (e, t) => {
      const { __scopeTabs: n, value: r, forceMount: o, children: a, ...i } = e, s = $O(HU, n), u = qU(s.baseId, r), c = KU(s.baseId, r), f = r === s.value, p = C.useRef(f);
      return C.useEffect(() => {
        const g = requestAnimationFrame(() => p.current = !1);
        return () => cancelAnimationFrame(g);
      }, []), /* @__PURE__ */ S.jsx(ia, { present: o || f, children: ({ present: g }) => /* @__PURE__ */ S.jsx(
        gt.div,
        {
          "data-state": f ? "active" : "inactive",
          "data-orientation": s.orientation,
          role: "tabpanel",
          "aria-labelledby": u,
          hidden: !g,
          id: c,
          tabIndex: 0,
          ...i,
          ref: t,
          style: {
            ...e.style,
            animationDuration: p.current ? "0s" : void 0
          },
          children: g && a
        }
      ) });
    }
  );
  WU.displayName = HU;
  function qU(e, t) {
    return `${e}-trigger-${t}`;
  }
  function KU(e, t) {
    return `${e}-content-${t}`;
  }
  var DO = TU, LO = BU, Vp = UU, Up = WU;
  const OAe = ({}) => {
    const e = Vt(), t = go(), { description: n, id: r, node_id: o, node_name: a, reset_inputs_on_trigger: i } = t.useShallow((p) => ({
      description: p.description,
      id: p.id,
      node_id: p.node_id,
      node_name: p.node_name,
      reset_inputs_on_trigger: p.reset_inputs_on_trigger
    })), [s, u] = C.useState(
      n || ""
    );
    C.useEffect(() => u(n || ""), [n]);
    const c = (p) => u(p.target.value), f = () => {
      s !== (n || "") && e.on_node_action({
        type: "update",
        from_remote: !1,
        id: r,
        node: { description: s }
      });
    };
    return /* @__PURE__ */ S.jsxs("div", { className: "nodesettings-section funcnodes-control-group", children: [
      /* @__PURE__ */ S.jsxs("div", { className: "funcnodes-control-row", children: [
        /* @__PURE__ */ S.jsx("label", { htmlFor: `node-name-${r}`, children: "Name:" }),
        /* @__PURE__ */ S.jsx(FO, {})
      ] }),
      /* @__PURE__ */ S.jsxs("div", { className: "funcnodes-control-row", children: [
        /* @__PURE__ */ S.jsx("label", { children: "Instance ID:" }),
        /* @__PURE__ */ S.jsx("span", { children: r })
      ] }),
      /* @__PURE__ */ S.jsxs("div", { className: "funcnodes-control-row", children: [
        /* @__PURE__ */ S.jsx("label", { children: "Node Type ID:" }),
        /* @__PURE__ */ S.jsx("span", { children: o })
      ] }),
      /* @__PURE__ */ S.jsxs("div", { className: "funcnodes-control-row", children: [
        /* @__PURE__ */ S.jsx("label", { children: "Node Type Name:" }),
        /* @__PURE__ */ S.jsx("span", { children: a })
      ] }),
      /* @__PURE__ */ S.jsxs("div", { className: "funcnodes-control-row", children: [
        /* @__PURE__ */ S.jsx("label", { htmlFor: `node-desc-${r}`, children: "Description:" }),
        /* @__PURE__ */ S.jsx(
          "textarea",
          {
            id: `node-desc-${r}`,
            value: s,
            onChange: c,
            onBlur: f,
            className: "styledinput",
            rows: 3
          }
        )
      ] }),
      /* @__PURE__ */ S.jsxs("div", { className: "funcnodes-control-row", children: [
        /* @__PURE__ */ S.jsx("label", { children: "Reset Inputs on Trigger:" }),
        /* @__PURE__ */ S.jsx(
          "input",
          {
            type: "checkbox",
            checked: i,
            onChange: (p) => {
              e.on_node_action({
                type: "update",
                from_remote: !1,
                id: r,
                node: { reset_inputs_on_trigger: p.target.checked }
              });
            },
            className: "styledcheckbox"
          }
        )
      ] })
    ] });
  }, NAe = ({ splitnodesettingsPath: e = [] }) => {
    const t = go(), n = t.use((r) => r.inputs);
    return /* @__PURE__ */ S.jsxs(
      DO,
      {
        defaultValue: e[0] || n[0],
        className: "nodesettings-tabs funcnodes-control-root",
        children: [
          /* @__PURE__ */ S.jsx(
            LO,
            {
              className: "nodesettings-tabs-list",
              "aria-label": "Manage node inputs",
              children: n.map((r) => /* @__PURE__ */ S.jsx(
                Vp,
                {
                  value: r,
                  className: "nodesettings-tabs-trigger",
                  children: r
                },
                r
              ))
            }
          ),
          n.map((r) => {
            const o = t.io_stores.get(r);
            return /* @__PURE__ */ S.jsx(
              Up,
              {
                value: r,
                className: "nodesettings-tabs-content nodesettings-io-list",
                children: o && /* @__PURE__ */ S.jsx(ul.Provider, { value: o, children: /* @__PURE__ */ S.jsx(OU, {}) })
              },
              r
            );
          })
        ]
      }
    );
  }, MAe = ({ splitnodesettingsPath: e = [] }) => {
    const t = go(), n = t.use((r) => r.outputs);
    return /* @__PURE__ */ S.jsxs(
      DO,
      {
        defaultValue: e[0] || n[0],
        className: "nodesettings-tabs funcnodes-control-root",
        children: [
          /* @__PURE__ */ S.jsx(
            LO,
            {
              className: "nodesettings-tabs-list",
              "aria-label": "Manage node outputs",
              children: n.map((r) => /* @__PURE__ */ S.jsx(
                Vp,
                {
                  value: r,
                  className: "nodesettings-tabs-trigger",
                  children: r
                },
                r
              ))
            }
          ),
          n.map((r) => {
            const o = t.io_stores.get(r);
            return /* @__PURE__ */ S.jsx(
              Up,
              {
                value: r,
                className: "nodesettings-tabs-content nodesettings-io-list",
                children: o && /* @__PURE__ */ S.jsx(ul.Provider, { value: o, children: /* @__PURE__ */ S.jsx(OU, {}) })
              },
              r
            );
          })
        ]
      }
    );
  }, RAe = ({
    nodeSettingsPath: e
  }) => {
    const t = e.split("/") || ["general"];
    return /* @__PURE__ */ S.jsxs(
      DO,
      {
        defaultValue: t[0] || "general",
        className: "nodesettings-tabs funcnodes-control-root",
        children: [
          /* @__PURE__ */ S.jsxs(
            LO,
            {
              className: "nodesettings-tabs-list",
              "aria-label": "Manage node settings",
              children: [
                /* @__PURE__ */ S.jsx(Vp, { value: "general", className: "nodesettings-tabs-trigger", children: "General" }),
                /* @__PURE__ */ S.jsx(Vp, { value: "inputs", className: "nodesettings-tabs-trigger", children: "Inputs" }),
                /* @__PURE__ */ S.jsx(Vp, { value: "outputs", className: "nodesettings-tabs-trigger", children: "Outputs" })
              ]
            }
          ),
          /* @__PURE__ */ S.jsx(Up, { value: "general", className: "nodesettings-tabs-content", children: /* @__PURE__ */ S.jsx(OAe, {}) }),
          /* @__PURE__ */ S.jsx(
            Up,
            {
              value: "inputs",
              className: "nodesettings-tabs-content nodesettings-io-list",
              children: /* @__PURE__ */ S.jsx(
                NAe,
                {
                  splitnodesettingsPath: (
                    // all but first element
                    t.slice(1)
                  )
                }
              )
            }
          ),
          /* @__PURE__ */ S.jsx(
            Up,
            {
              value: "outputs",
              className: "nodesettings-tabs-content nodesettings-io-list",
              children: /* @__PURE__ */ S.jsx(
                MAe,
                {
                  splitnodesettingsPath: (
                    // all but first element
                    t.slice(1)
                  )
                }
              )
            }
          )
        ]
      }
    );
  }, jAe = C.memo(
    ({ isOpen: e, onOpenChange: t, nodeSettingsPath: n }) => {
      const r = go().use((o) => o.id);
      return /* @__PURE__ */ S.jsx(
        Qa,
        {
          title: `Node Settings: ${r}`,
          open: e,
          onOpenChange: t,
          dialogClassName: "nodesettings-dialog",
          children: /* @__PURE__ */ S.jsx(RAe, { nodeSettingsPath: n })
        }
      );
    }
  ), IAe = C.memo(({ toogleShowSettings: e }) => {
    const t = Vt(), { node: n } = Nr(), r = go(), { id: o, description: a, node_name: i } = r.useShallow((u) => ({
      id: u.id,
      description: u.description,
      node_name: u.node_name
    })), s = C.useCallback(() => {
      t.on_node_action({
        type: "trigger",
        from_remote: !1,
        id: o
      });
    }, [t, o]);
    return /* @__PURE__ */ S.jsxs("div", { className: "nodeheader", title: a || i, children: [
      /* @__PURE__ */ S.jsxs("div", { className: "nodeheader_element", children: [
        /* @__PURE__ */ S.jsx(
          Qoe,
          {
            fontSize: "inherit",
            className: "triggerbutton nodeheaderbutton ",
            onClick: s
          }
        ),
        /* @__PURE__ */ S.jsx(
          Joe,
          {
            fontSize: "inherit",
            className: "nodestatusbutton nodeheaderbutton",
            onClick: async () => {
              n && console.log("nodestatus", await n.get_node_status(o));
            }
          }
        ),
        /* @__PURE__ */ S.jsx(
          eae,
          {
            fontSize: "inherit",
            className: "nodesettingsbutton nodeheaderbutton",
            onClick: () => {
              e?.();
            }
          }
        )
      ] }),
      /* @__PURE__ */ S.jsx("div", { className: "nodeheader_element nodeheader_title", children: /* @__PURE__ */ S.jsx("div", { className: "nodeheader_title_text", children: i }) }),
      /* @__PURE__ */ S.jsx("div", { className: "nodeheader_element", children: /* @__PURE__ */ S.jsx(Wm, { fontSize: "inherit" }) })
    ] });
  }), AAe = C.memo(({ iostore: e }) => {
    const t = e.use(), n = go().use((i) => i.render_options), r = ih(t.id), [o, a] = QIe(t);
    return /* @__PURE__ */ S.jsx(
      "div",
      {
        className: "nodrag nodedatabody",
        "data-src": n?.data?.src || "",
        children: o && t && /* @__PURE__ */ S.jsx(ul.Provider, { value: e, children: /* @__PURE__ */ S.jsx(
          Qa,
          {
            title: t.full_id,
            trigger: /* @__PURE__ */ S.jsx("div", { className: "nodedatabutton", children: /* @__PURE__ */ S.jsx(PU, { Component: o }) }),
            onOpenChange: (i) => {
              i && r?.();
            },
            children: a && /* @__PURE__ */ S.jsx(CU, { Component: a, iostore: e })
          }
        ) })
      }
    );
  }), $Ae = C.memo(
    ({ setShowSettings: e, setNodeSettingsPath: t }) => {
      const n = go(), { render_options: r, outputs: o, inputs: a } = n.useShallow(
        (s) => ({
          render_options: s.render_options,
          outputs: s.outputs,
          inputs: s.inputs
        })
      ), i = r?.data?.src ? n.io_stores.get(r?.data?.src) : void 0;
      return /* @__PURE__ */ S.jsxs("div", { className: "nodebody nowheel ", children: [
        o.map((s) => {
          const u = n.io_stores.get(s);
          if (u)
            return /* @__PURE__ */ S.jsx(ul.Provider, { value: u, children: /* @__PURE__ */ S.jsx(
              nAe,
              {
                setNodeSettingsPath: t,
                setShowSettings: e
              }
            ) }, s);
        }),
        i && /* @__PURE__ */ S.jsx(AAe, { iostore: i }),
        a.map((s) => {
          const u = n.io_stores.get(s);
          if (u)
            return /* @__PURE__ */ S.jsx(ul.Provider, { value: u, children: /* @__PURE__ */ S.jsx(
              tAe,
              {
                setNodeSettingsPath: t,
                setShowSettings: e
              }
            ) }, s);
        })
      ] });
    }
  ), FO = () => {
    const e = go(), { original_name: t, id: n } = e.useShallow((u) => ({
      original_name: u.name,
      id: u.id
    })), [r, o] = C.useState(t);
    C.useEffect(() => {
      o(t);
    }, [t]);
    const a = Vt(), i = (u) => {
      o(u.target.value);
    }, s = (u) => {
      const c = u.target.value;
      c !== t && a.on_node_action({
        type: "update",
        from_remote: !1,
        id: n,
        node: { name: c }
      });
    };
    return /* @__PURE__ */ S.jsx(
      "input",
      {
        className: "nodename_input",
        value: r,
        onChange: i,
        onBlur: s
      }
    );
  }, DAe = () => {
    const e = go().use((t) => t.progress);
    return e ? /* @__PURE__ */ S.jsx(
      Vue,
      {
        state: e,
        className: "nodeprogress"
      }
    ) : null;
  }, LAe = C.memo(() => {
    const e = go().use((t) => t.error);
    return /* @__PURE__ */ S.jsxs("div", { className: "nodefooter", children: [
      e && /* @__PURE__ */ S.jsx("div", { className: "nodeerror", children: e }),
      /* @__PURE__ */ S.jsx(DAe, {})
    ] });
  }), FAe = () => {
    const e = go(), { collapsed: t, error: n, node_id: r } = e.useShallow((h) => ({
      collapsed: h.properties["frontend:collapsed"] || !1,
      error: h.error,
      node_id: h.node_id
    })), { visualTrigger: o } = eAe(e), [a, i] = C.useState(!1), [s, u] = C.useState(""), { keys: c } = $C(), f = C.useContext(is).NodeHooks[r] ?? [], p = C.useCallback(() => {
      i((h) => !h);
    }, []), g = (h) => {
      c.has("s") && !a && (u(""), i(!0), h.stopPropagation());
    };
    return /* @__PURE__ */ S.jsxs(
      "div",
      {
        className: "innernode" + (o ? " intrigger" : "") + (n ? " error" : ""),
        onClick: g,
        children: [
          /* @__PURE__ */ S.jsx(IAe, { toogleShowSettings: p }),
          /* @__PURE__ */ S.jsx(FO, {}),
          t ? null : /* @__PURE__ */ S.jsx(
            $Ae,
            {
              setNodeSettingsPath: u,
              setShowSettings: i
            }
          ),
          /* @__PURE__ */ S.jsx(LAe, {}),
          /* @__PURE__ */ S.jsx(
            jAe,
            {
              isOpen: a,
              onOpenChange: i,
              nodeSettingsPath: s
            }
          ),
          f.map((h, y) => /* @__PURE__ */ S.jsx(C.Fragment, { children: /* @__PURE__ */ S.jsx(h, {}) }, y))
        ]
      }
    );
  }, TAe = C.memo(
    ({ data: e }) => /* @__PURE__ */ S.jsx(rx.Provider, { value: e.nodestore, children: /* @__PURE__ */ S.jsx(FAe, {}) }),
    (e, t) => e.data.nodestore === t.data.nodestore
  ), zAe = ({
    id: e,
    sourceX: t,
    sourceY: n,
    targetX: r,
    targetY: o,
    sourcePosition: a,
    targetPosition: i,
    data: s,
    ...u
  }) => {
    const [c] = wP({
      sourceX: t,
      sourceY: n,
      sourcePosition: a,
      targetX: r,
      targetY: o,
      targetPosition: i
    });
    return /* @__PURE__ */ S.jsx(S.Fragment, { children: /* @__PURE__ */ S.jsx(ah, { id: e, path: c, ...u }) });
  }, BAe = {
    default: TAe,
    group: Bbe
  }, VAe = {
    default: zAe
  }, UAe = (e) => ({
    nodes: e.getNodes(),
    edges: e.getEdges(),
    onNodesChange: e.onNodesChange,
    onEdgesChange: e.onEdgesChange,
    onConnect: e.onConnect
  }), TO = (e) => {
    const t = /* @__PURE__ */ new Set(), n = e.filter(
      (o) => o.type === "group"
    );
    n.forEach((o) => {
      t.add(o.id);
    });
    const r = e.filter(
      (o) => !t.has(o.id)
    );
    return { group_nodes: n, default_nodes: r };
  };
  function zO(e) {
    const t = new Map(e.map((i) => [i.id, i])), n = /* @__PURE__ */ new Map(), r = [];
    for (const i of e)
      if (n.has(i.id) || n.set(i.id, []), i.parentId && t.has(i.parentId)) {
        const s = t.get(i.parentId);
        if (s) {
          const u = n.get(s.id) || [];
          u.push(i), n.set(s.id, u);
        } else
          r.push(i);
      } else
        r.push(i);
    const o = [];
    function a(i) {
      o.push(i);
      const s = n.get(i.id) || [];
      for (const u of s)
        a(u);
    }
    for (const i of r)
      a(i);
    if (o.length !== e.length) {
      console.warn(
        "Sorting mismatch: Not all nodes could be placed. Check for circular dependencies or missing parents."
      );
      const i = new Set(o.map((s) => s.id));
      e.forEach((s) => {
        i.has(s.id) || o.push(s);
      });
    }
    return o;
  }
  const GU = () => {
    const { getNodes: e } = ku();
    return {
      getNodes: e,
      getSelectedNodes: (t) => (t === void 0 && (t = e()), t.filter((n) => n.selected)),
      getSplitNodes: (t) => {
        t === void 0 && (t = e());
        const { group_nodes: n, default_nodes: r } = TO(t);
        return { group_nodes: n, default_nodes: r };
      },
      getSortedNodes: (t) => (t === void 0 && (t = e()), zO(t))
    };
  }, XU = (e, t) => {
    const n = e.getState(), { new_obj: r, change: o } = tl(n, t);
    o && e.setState(r);
  }, YU = (e) => Ro(e);
  function ZL(e) {
    return e != null && typeof e == "object" && "id" in e && typeof e.id == "string";
  }
  const JU = (e) => {
    let t = e.io ?? {}, n = e.io_order, r = [];
    const o = {};
    if (n === void 0)
      if (Array.isArray(t)) {
        const a = t.filter(ZL);
        r = a.map((i) => i.id);
        for (const i of a)
          o[i.id] = i;
      } else {
        r = Object.keys(t);
        for (const a in t)
          t[a] !== void 0 && (o[a] = t[a]);
      }
    else if (r = n, Array.isArray(t)) {
      const a = t.filter(ZL);
      for (const i of a)
        o[i.id] = i, r.includes(i.id) || r.push(i.id);
    } else
      for (const a in t)
        t[a] !== void 0 && (o[a] = t[a]), r.includes(a) || r.push(a);
    return { ...e, io_order: r, io: o };
  }, HAe = {
    id: "dummy",
    node_id: "dummy",
    node_name: "dummy",
    properties: {
      "frontend:size": [200, 100],
      "frontend:pos": [NaN, NaN],
      "frontend:collapsed": !1
    },
    io: {},
    io_order: [],
    name: "dummy",
    in_trigger: !1,
    reset_inputs_on_trigger: !1,
    progress: {
      ascii: !1,
      elapsed: 0,
      initial: 0,
      n: 0,
      prefix: "idle",
      unit: "it",
      unit_divisor: 1e3,
      unit_scale: !1
    }
  }, WAe = {
    id: "dummy",
    name: "dummy",
    node: "dummy",
    full_id: "dummy",
    type: "any",
    value: void 0,
    is_input: !1,
    connected: !1,
    does_trigger: !0,
    fullvalue: void 0,
    render_options: {
      set_default: !0,
      type: "any"
    },
    hidden: !1,
    emit_value_set: !0,
    required: !1
  }, qAe = Yb(HAe), KAe = Yb(WAe), GAe = (e) => {
    const t = e.io_order;
    if (t === void 0)
      throw new Error("Node must have io_order");
    return {
      ...e,
      inputs: Object.keys(e.io).filter((n) => e.io[n].is_input),
      outputs: Object.keys(e.io).filter((n) => !e.io[n].is_input),
      io_order: t
    };
  }, XAe = (e) => (e.value === "<NoValue>" && (e.value = void 0), e.fullvalue === "<NoValue>" && (e.fullvalue = void 0), e.hidden === void 0 && (e.hidden = !1), [{
    ...e
  }, e.value, e.fullvalue]), YAe = (e) => {
    if (!e.id)
      throw new Error("Node must have an id");
    const t = qAe(e);
    return GAe(t);
  }, JAe = (e, t) => {
    const n = e.getState(), r = {}, o = JU(t), a = Object.keys(o);
    for (const i of a)
      switch (i) {
        case "id": {
          const [s, u] = Co(
            n[i],
            o[i]
          );
          u && (r[i] = s);
          break;
        }
        case "node_id": {
          const [s, u] = Co(
            n[i],
            o[i]
          );
          u && (r[i] = s);
          break;
        }
        case "node_name": {
          const [s, u] = Co(
            n[i],
            o[i]
          );
          u && (r[i] = s);
          break;
        }
        case "name": {
          const [s, u] = Co(
            n[i],
            o[i]
          );
          u && (r[i] = s);
          break;
        }
        case "in_trigger": {
          const [s, u] = Co(
            n[i],
            o[i]
          );
          u && (r[i] = s);
          break;
        }
        case "error": {
          o[i] !== n[i] && (r[i] = o[i]);
          break;
        }
        case "render_options": {
          const [s, u] = Wc(
            n[i],
            o[i]
          );
          u && (r[i] = s);
          break;
        }
        case "io_order": {
          const [s, u] = ((c, f) => f === void 0 ? [c, !1] : [f, !HE(c, f)])(n[i], o[i]);
          u && (r[i] = s.filter((c) => c !== void 0));
          break;
        }
        case "io": {
          const s = o[i];
          if (s === void 0) break;
          for (const u in s) {
            const c = e.io_stores.get(u);
            if (!c) {
              console.error("io key not found in oldvalue:", u);
              continue;
            }
            c.update(s[u]);
          }
          break;
        }
        case "progress": {
          const [s, u] = Wc(
            n[i],
            o[i]
          );
          u && (r[i] = s);
          break;
        }
        case "description": {
          r[i] = o[i];
          break;
        }
        case "properties": {
          const [s, u] = Wc(
            n[i],
            o[i]
          );
          u && (r[i] = s);
          break;
        }
        case "status": {
          const [s, u] = Wc(
            n[i],
            o[i]
          );
          u && (r[i] = s);
          break;
        }
        case "reset_inputs_on_trigger": {
          const [s, u] = Co(
            n[i],
            o[i]
          );
          u && (r[i] = s);
          break;
        }
        default:
          try {
            ZF(i, o[i]);
          } catch (s) {
            console.error(s);
          }
      }
    Object.keys(r).length > 0 && e.setState(r);
  }, QAe = (e, t) => {
    const n = e.getState(), r = {}, o = {}, a = Object.keys(t);
    for (const i of a)
      switch (i) {
        case "name": {
          const [s, u] = Co(
            n[i],
            t[i]
          );
          u && (r[i] = s);
          break;
        }
        case "id": {
          const [s, u] = Co(
            n[i],
            t[i]
          );
          u && (r[i] = s);
          break;
        }
        case "connected": {
          const [s, u] = Co(
            n[i],
            t[i]
          );
          u && (r[i] = s);
          break;
        }
        case "does_trigger": {
          const [s, u] = Co(
            n[i],
            t[i]
          );
          u && (r[i] = s);
          break;
        }
        case "hidden": {
          const [s, u] = Co(
            n[i],
            t[i]
          );
          u && (r[i] = s);
          break;
        }
        case "full_id": {
          const [s, u] = Co(
            n[i],
            t[i]
          );
          u && (r[i] = s);
          break;
        }
        case "is_input":
          break;
        case "node":
          break;
        case "type":
          break;
        case "value": {
          o.preview = t[i];
          break;
        }
        case "fullvalue": {
          o.full = t[i];
          break;
        }
        case "render_options": {
          const [s, u] = Wc(
            n[i],
            t[i]
          );
          u && (r[i] = s);
          break;
        }
        case "value_options": {
          const [s, u] = Wc(
            n[i],
            t[i]
          );
          u && (r[i] = s);
          break;
        }
        case "valuepreview_type": {
          r[i] = t[i];
          break;
        }
        case "emit_value_set": {
          r[i] = t[i];
          break;
        }
        case "default": {
          r[i] = t[i];
          break;
        }
        case "required": {
          r[i] = t[i];
          break;
        }
        default:
          try {
            ZF(i, t[i]);
          } catch (s) {
            console.error(s);
          }
      }
    Object.keys(o).length > 0 && e.updateValueStore(o), Object.keys(r).length > 0 && e.setState(r);
  }, ZAe = (e) => {
    if (!e.id)
      throw new Error(
        "IO must have an id but is missing for " + JSON.stringify(e)
      );
    e.name === void 0 && (e.name = e.id);
    const t = KAe(e);
    return (t.render_options.type === "any" || t.render_options.type === void 0) && (t.render_options.type = t.type), XAe(t);
  }, e$e = (e, t) => {
    let n;
    const [r, o, a] = ZAe(t);
    return n = {
      io_state: YU((i, s) => r),
      use: (i) => i ? n.io_state(i) : n.io_state(),
      useShallow: (i) => n.io_state(OP(i)),
      getState: () => n.io_state.getState(),
      setState: (i) => {
        n.io_state.setState(i);
      },
      update: (i) => {
        QAe(n, i);
      },
      valuestore: Ro((i, s) => {
        let u = o;
        u === "<NoValue>" && (u = void 0), !(u instanceof Ia) && u !== void 0 && (u = Gs.fromObject(u));
        let c = a;
        return c === "<NoValue>" && (c = void 0), !(c instanceof Ia) && c !== void 0 && (c = Gs.fromObject(c)), {
          preview: u,
          full: c
        };
      }),
      updateValueStore: (i) => {
        n.valuestore.setState((s) => (s.preview && typeof s.preview.dispose == "function" && s.preview.dispose(), s.full && typeof s.full.dispose == "function" && s.full.dispose(), i.preview !== void 0 && i.full === void 0 && (i.full = void 0, s.full = void 0), i.preview !== void 0 && !(i.preview instanceof Ia) && (i.preview = Gs.fromObject(i.preview)), i.full !== void 0 && !(i.full instanceof Ia) && (i.full = Gs.fromObject(i.full)), { ...s, ...i }));
      },
      node: e,
      serialize: () => {
        const i = n.io_state.getState(), s = n.valuestore.getState();
        return {
          ...i,
          value: s.preview,
          fullvalue: s.full,
          render_options: i.render_options,
          valuepreview_type: i.valuepreview_type,
          emit_value_set: i.emit_value_set
        };
      }
    }, n;
  }, t$e = (e) => {
    const t = {
      use: (a) => a ? r.node_state(a) : r.node_state(),
      useShallow: (a) => r.node_state(OP(a)),
      io_stores: /* @__PURE__ */ new Map(),
      getState: () => r.node_state.getState(),
      setState: (a) => {
        r.node_state.setState(a);
      },
      update: (a) => {
        JAe(r, a);
      },
      serialize: () => ({
        ...r.node_state.getState(),
        io: Object.fromEntries(
          Array.from(r.io_stores.entries()).map(([a, i]) => [
            a,
            i.serialize()
          ])
        )
      })
    }, n = JU(e), r = {
      ...t,
      node_state: YU((a, i) => YAe(n))
    }, o = n.io;
    return Object.entries(o).forEach(([a, i]) => {
      i !== void 0 && r.io_stores.set(a, e$e(n.id, i));
    }), r;
  }, n$e = () => {
    const e = Vt();
    return {
      onSelectionChange: C.useCallback(
        ({ nodes: t, edges: n }) => {
          const { group_nodes: r, default_nodes: o } = TO(t), a = e.local_state.getState();
          e.local_state.setState({
            ...a,
            selected_nodes: o.map((i) => i.id),
            selected_edges: n.map((i) => i.id),
            selected_groups: r.map((i) => i.id)
          });
        },
        [e]
      )
    };
  }, r$e = () => {
    const e = ku(), t = Vt();
    return t.rf_instance = e, /* @__PURE__ */ S.jsx(S.Fragment, {});
  }, o$e = () => {
    const e = Vt(), { getEdges: t } = ku(), { getSelectedNodes: n } = GU();
    return {
      copySelectedNodes: C.useCallback(() => {
        const r = t(), o = n();
        if (o.length === 0) return;
        const a = { nodes: [], edges: [] };
        for (const u of o) {
          const c = e.nodespace.get_node(u.id, !1);
          c && a.nodes.push(c.serialize());
        }
        const i = new Set(o.map((u) => u.id)), s = r.filter(
          (u) => i.has(u.source) && i.has(u.target)
        );
        for (const u of s)
          !u.sourceHandle || !u.targetHandle || a.edges.push({
            src_nid: u.source,
            src_ioid: u.sourceHandle,
            trg_nid: u.target,
            trg_ioid: u.targetHandle
          });
        navigator.clipboard.writeText(JSON.stringify(a));
      }, [n, t, e])
    };
  }, a$e = () => {
    const e = Li("Delete"), t = Li(["Meta+c", "Control+c", "Strg+c"]), n = Li(["Control+g", "Meta+g"]), r = Li(["Control+Alt+g", "Meta+Alt+g"]), o = Tbe(), { getEdges: a } = ku(), { getNodes: i, getSelectedNodes: s, getSplitNodes: u } = GU(), { copySelectedNodes: c } = o$e(), { node: f, group: p, edge: g } = Nr();
    return C.useEffect(() => {
      if (e) {
        const h = a().filter((w) => w.selected);
        for (const w of h)
          !w.source || !w.target || !w.sourceHandle || !w.targetHandle || g?.remove_edge({
            src_nid: w.source,
            src_ioid: w.sourceHandle,
            trg_nid: w.target,
            trg_ioid: w.targetHandle
          });
        const y = s(), { group_nodes: b, default_nodes: v } = u(y);
        for (const w of v)
          f?.remove_node(w.id);
        for (const w of b)
          p?.remove_group(w.id);
      }
    }, [e, i, a, f, p, g]), C.useEffect(() => {
      t && c();
    }, [t, c]), C.useEffect(() => {
      if (n) {
        const h = s(), { group_nodes: y, default_nodes: b } = u(h);
        h.length > 0 && o(
          b.map((v) => v.id),
          y.map((v) => v.id)
        );
      }
    }, [n, i]), C.useEffect(() => {
      if (r) {
        const h = s(), { group_nodes: y } = u(h);
        y.forEach((b) => {
          p?.remove_group(b.id);
        });
      }
    }, [r, i]), /* @__PURE__ */ S.jsx(S.Fragment, {});
  }, i$e = () => {
    const { node: e, edge: t } = Nr(), n = Vt();
    return C.useCallback(
      async (r, o) => {
        try {
          if (!r || !e || !t) return;
          const a = JSON.parse(r);
          if (!a || !n.worker || !a.nodes) return;
          const i = [0, 0];
          for (const u of a.nodes)
            i[0] += u.properties["frontend:pos"][0], i[1] += u.properties["frontend:pos"][1];
          i[0] /= a.nodes.length, i[1] /= a.nodes.length;
          const s = [];
          for (const u of a.nodes) {
            const c = {
              id: u.node_id,
              src_id: u.id,
              position: [
                u.properties["frontend:pos"][0] - i[0],
                u.properties["frontend:pos"][1] - i[1]
              ]
            };
            s.push(c);
          }
          for (const u of s) {
            const c = await e.add_node(u.id);
            !c || !n.nodespace.get_node(c.id, !1) || (u.new_id = c.id, o([
              {
                id: c.id,
                type: "position",
                position: {
                  x: u.position[0] + c.properties["frontend:pos"][0],
                  y: u.position[1] + c.properties["frontend:pos"][1]
                }
              }
            ]));
          }
          for (const u of a.edges) {
            const c = s.find(
              (p) => p.src_id === u.src_nid
            ), f = s.find(
              (p) => p.src_id === u.trg_nid
            );
            !c || !f || !c.new_id || !f.new_id || t.add_edge({
              src_nid: c.new_id,
              src_ioid: u.src_ioid,
              trg_nid: f.new_id,
              trg_ioid: u.trg_ioid
            });
          }
        } catch (a) {
          console.error("Failed to process pasted data:", a);
        }
      },
      [e, t, n]
    );
  }, s$e = (e, t) => {
    const n = e.properties || {};
    n["frontend:size"] || (n["frontend:size"] = [200, 100]);
    const r = n["frontend:pos"];
    if (!r || r.length !== 2 || isNaN(r[0]) || r[0] === null || isNaN(r[1]) || r[1] === null)
      if (!t || !t.rf_instance || t.reactflowRef === null)
        n["frontend:pos"] = [0, 0];
      else {
        const o = t.reactflowRef.getBoundingClientRect(), a = o.left + o.width / 2, i = o.top + o.height / 2, s = t.rf_instance.screenToFlowPosition({
          x: a,
          y: i
        });
        n["frontend:pos"] = [
          s.x - n["frontend:size"][0] / 2,
          s.y - n["frontend:size"][0] / 2
        ];
      }
    n["frontend:collapsed"] || (n["frontend:collapsed"] = !1), e.properties = n;
  }, l$e = (e, t) => {
    const n = e.getState();
    if (s$e(n, t), n.id === void 0)
      throw new Error("Node must have an id");
    const r = {
      nodestore: e
    };
    return {
      position: {
        x: n.properties["frontend:pos"][0],
        y: n.properties["frontend:pos"][1]
      },
      data: r,
      type: "default",
      zIndex: 1003,
      // expandParent: true,
      ...n
    };
  }, eF = {
    default: Cr.Dots,
    metal: Cr.Cross,
    light: Cr.Dots,
    solarized: Cr.Dots,
    midnight: Cr.Dots,
    forest: Cr.Dots,
    scientific: Cr.Lines
  }, u$e = (e) => {
    const t = Vt(), n = C.useRef(null), { colorTheme: r } = jz(), { onSelectionChange: o } = n$e(), a = Lce();
    C.useEffect(() => {
      t.getStateManager().toaster = a;
    }, []), C.useEffect(() => {
      t.reactflowRef = n.current;
    }, [n]);
    const { nodes: i, edges: s, onNodesChange: u, onEdgesChange: c, onConnect: f } = t.useReactFlowStore(OP(UAe)), p = i$e(), g = C.useCallback(
      (h) => {
        const y = n.current;
        if (!y) return;
        let b = h.target, v = 0;
        for (; b && b.parentElement && b !== y; )
          v++, b = b.parentElement;
        t.logger.debug(`onPasteCapture: ${v} steps to reactflow`), v <= 2 && p(
          h.clipboardData.getData("text/plain"),
          u
        );
      },
      [p, u, t.logger]
    );
    return /* @__PURE__ */ S.jsx("div", { className: "reactflowlayer", children: /* @__PURE__ */ S.jsxs(
      ube,
      {
        onPasteCapture: g,
        nodes: i,
        edges: s,
        onNodesChange: u,
        onEdgesChange: c,
        onConnect: f,
        nodeTypes: BAe,
        edgeTypes: VAe,
        minZoom: e.minZoom,
        maxZoom: e.maxZoom,
        fitView: !0,
        onSelectionChange: o,
        ref: n,
        panOnDrag: !e.static,
        children: [
          /* @__PURE__ */ S.jsx(r$e, {}),
          /* @__PURE__ */ S.jsx(a$e, {}),
          /* @__PURE__ */ S.jsx(
            mbe,
            {
              color: "#888",
              gap: 24,
              size: 2,
              variant: eF[r] || eF.default,
              patternClassName: "fn-background-pattern"
            }
          ),
          e.minimap && /* @__PURE__ */ S.jsx(
            Ibe,
            {
              nodeStrokeWidth: 3,
              pannable: !e.static,
              zoomable: !e.static,
              zoomStep: 3
            }
          )
        ]
      }
    ) });
  }, c$e = ({
    on_node_change: e,
    on_edge_change: t,
    on_connect: n
  }) => {
    const r = e || ((i) => {
    }), o = t || ((i) => {
    }), a = n || ((i) => {
    });
    return Ro((i, s) => ({
      _nodes: [],
      _edges: [],
      _nodes_map: /* @__PURE__ */ new Map(),
      update_nodes: (u) => {
        u = zO(u), i({
          _nodes: u,
          _nodes_map: new Map(u.map((c) => [c.id, c]))
        });
      },
      partial_update_nodes: (u) => {
        const c = s(), f = c._nodes, p = new Map(
          f.map((g) => [g.id, g])
        );
        for (const g of u)
          p.set(g.id, g);
        c.update_nodes(Array.from(p.values()));
      },
      update_edges: (u) => {
        i({
          _edges: u
        });
      },
      onNodesChange: (u) => {
        const c = s();
        c.update_nodes(CP(u, c._nodes)), r(u);
      },
      onEdgesChange: (u) => {
        i({
          _edges: o7(u, s()._edges)
        }), o(u);
      },
      onConnect: (u) => {
        u.source == null || u.target == null || a(u);
      },
      getNode: (u) => s()._nodes_map.get(u),
      getNodes: () => s()._nodes,
      getEdges: () => s()._edges
    }));
  }, d$e = () => {
    const e = Vt().progress_state();
    return /* @__PURE__ */ S.jsxs("div", { className: "statusbar", children: [
      /* @__PURE__ */ S.jsx(
        "span",
        {
          className: "statusbar-progressbar",
          style: { width: Math.min(100, 100 * e.progress) + "%" }
        }
      ),
      /* @__PURE__ */ S.jsx("span", { className: "statusbar-message", children: e.message })
    ] });
  }, Cm = () => window?._FUNCNODES_DEV ?? !1;
  var NE = ["Enter", " "], f$e = ["ArrowDown", "PageUp", "Home"], QU = ["ArrowUp", "PageDown", "End"], p$e = [...f$e, ...QU], m$e = {
    ltr: [...NE, "ArrowRight"],
    rtl: [...NE, "ArrowLeft"]
  }, h$e = {
    ltr: ["ArrowLeft"],
    rtl: ["ArrowRight"]
  }, bh = "Menu", [Pm, g$e, v$e] = Lw(bh), [Iu, ZU] = Ja(bh, [
    v$e,
    Aw,
    jx
  ]), wh = Aw(), eH = jx(), [tH, Au] = Iu(bh), [y$e, xh] = Iu(bh), nH = (e) => {
    const { __scopeMenu: t, open: n = !1, children: r, dir: o, onOpenChange: a, modal: i = !0 } = e, s = wh(t), [u, c] = C.useState(null), f = C.useRef(!1), p = Wr(a), g = ax(o);
    return C.useEffect(() => {
      const h = () => {
        f.current = !0, document.addEventListener("pointerdown", y, { capture: !0, once: !0 }), document.addEventListener("pointermove", y, { capture: !0, once: !0 });
      }, y = () => f.current = !1;
      return document.addEventListener("keydown", h, { capture: !0 }), () => {
        document.removeEventListener("keydown", h, { capture: !0 }), document.removeEventListener("pointerdown", y, { capture: !0 }), document.removeEventListener("pointermove", y, { capture: !0 });
      };
    }, []), /* @__PURE__ */ S.jsx(WC, { ...s, children: /* @__PURE__ */ S.jsx(
      tH,
      {
        scope: t,
        open: n,
        onOpenChange: p,
        content: u,
        onContentChange: c,
        children: /* @__PURE__ */ S.jsx(
          y$e,
          {
            scope: t,
            onClose: C.useCallback(() => p(!1), [p]),
            isUsingKeyboardRef: f,
            dir: g,
            modal: i,
            children: r
          }
        )
      }
    ) });
  };
  nH.displayName = bh;
  var b$e = "MenuAnchor", BO = C.forwardRef(
    (e, t) => {
      const { __scopeMenu: n, ...r } = e, o = wh(n);
      return /* @__PURE__ */ S.jsx(qC, { ...o, ...r, ref: t });
    }
  );
  BO.displayName = b$e;
  var w$e = "MenuPortal", [r9e, rH] = Iu(w$e, {
    forceMount: void 0
  }), jo = "MenuContent", [x$e, VO] = Iu(jo), oH = C.forwardRef(
    (e, t) => {
      const n = rH(jo, e.__scopeMenu), { forceMount: r = n.forceMount, ...o } = e, a = Au(jo, e.__scopeMenu), i = xh(jo, e.__scopeMenu);
      return /* @__PURE__ */ S.jsx(Pm.Provider, { scope: e.__scopeMenu, children: /* @__PURE__ */ S.jsx(ia, { present: r || a.open, children: /* @__PURE__ */ S.jsx(Pm.Slot, { scope: e.__scopeMenu, children: i.modal ? /* @__PURE__ */ S.jsx(k$e, { ...o, ref: t }) : /* @__PURE__ */ S.jsx(S$e, { ...o, ref: t }) }) }) });
    }
  ), k$e = C.forwardRef(
    (e, t) => {
      const n = Au(jo, e.__scopeMenu), r = C.useRef(null), o = un(t, r);
      return C.useEffect(() => {
        const a = r.current;
        if (a) return yC(a);
      }, []), /* @__PURE__ */ S.jsx(
        UO,
        {
          ...e,
          ref: o,
          trapFocus: n.open,
          disableOutsidePointerEvents: n.open,
          disableOutsideScroll: !0,
          onFocusOutside: Te(
            e.onFocusOutside,
            (a) => a.preventDefault(),
            { checkForDefaultPrevented: !1 }
          ),
          onDismiss: () => n.onOpenChange(!1)
        }
      );
    }
  ), S$e = C.forwardRef((e, t) => {
    const n = Au(jo, e.__scopeMenu);
    return /* @__PURE__ */ S.jsx(
      UO,
      {
        ...e,
        ref: t,
        trapFocus: !1,
        disableOutsidePointerEvents: !1,
        disableOutsideScroll: !1,
        onDismiss: () => n.onOpenChange(!1)
      }
    );
  }), _$e = /* @__PURE__ */ fd("MenuContent.ScrollLock"), UO = C.forwardRef(
    (e, t) => {
      const {
        __scopeMenu: n,
        loop: r = !1,
        trapFocus: o,
        onOpenAutoFocus: a,
        onCloseAutoFocus: i,
        disableOutsidePointerEvents: s,
        onEntryFocus: u,
        onEscapeKeyDown: c,
        onPointerDownOutside: f,
        onFocusOutside: p,
        onInteractOutside: g,
        onDismiss: h,
        disableOutsideScroll: y,
        ...b
      } = e, v = Au(jo, n), w = xh(jo, n), _ = wh(n), k = eH(n), E = g$e(n), [P, O] = C.useState(null), M = C.useRef(null), I = un(t, M, v.onContentChange), A = C.useRef(0), D = C.useRef(""), F = C.useRef(0), j = C.useRef(null), U = C.useRef("right"), $ = C.useRef(0), q = y ? Sw : C.Fragment, B = y ? { as: _$e, allowPinchZoom: !0 } : void 0, G = (Y) => {
        const z = D.current + Y, L = E().filter((ne) => !ne.disabled), K = document.activeElement, T = L.find((ne) => ne.ref.current === K)?.textValue, V = L.map((ne) => ne.textValue), X = D$e(V, z, T), Q = L.find((ne) => ne.textValue === X)?.ref.current;
        (function ne(te) {
          D.current = te, window.clearTimeout(A.current), te !== "" && (A.current = window.setTimeout(() => ne(""), 1e3));
        })(z), Q && setTimeout(() => Q.focus());
      };
      C.useEffect(() => () => window.clearTimeout(A.current), []), vC();
      const W = C.useCallback((Y) => U.current === j.current?.side && F$e(Y, j.current?.area), []);
      return /* @__PURE__ */ S.jsx(
        x$e,
        {
          scope: n,
          searchRef: D,
          onItemEnter: C.useCallback(
            (Y) => {
              W(Y) && Y.preventDefault();
            },
            [W]
          ),
          onItemLeave: C.useCallback(
            (Y) => {
              W(Y) || (M.current?.focus(), O(null));
            },
            [W]
          ),
          onTriggerLeave: C.useCallback(
            (Y) => {
              W(Y) && Y.preventDefault();
            },
            [W]
          ),
          pointerGraceTimerRef: F,
          onPointerGraceIntentChange: C.useCallback((Y) => {
            j.current = Y;
          }, []),
          children: /* @__PURE__ */ S.jsx(q, { ...B, children: /* @__PURE__ */ S.jsx(
            ww,
            {
              asChild: !0,
              trapped: o,
              onMountAutoFocus: Te(a, (Y) => {
                Y.preventDefault(), M.current?.focus({ preventScroll: !0 });
              }),
              onUnmountAutoFocus: i,
              children: /* @__PURE__ */ S.jsx(
                Bm,
                {
                  asChild: !0,
                  disableOutsidePointerEvents: s,
                  onEscapeKeyDown: c,
                  onPointerDownOutside: f,
                  onFocusOutside: p,
                  onInteractOutside: g,
                  onDismiss: h,
                  children: /* @__PURE__ */ S.jsx(
                    DU,
                    {
                      asChild: !0,
                      ...k,
                      dir: w.dir,
                      orientation: "vertical",
                      loop: r,
                      currentTabStopId: P,
                      onCurrentTabStopIdChange: O,
                      onEntryFocus: Te(u, (Y) => {
                        w.isUsingKeyboardRef.current || Y.preventDefault();
                      }),
                      preventScrollOnEntryFocus: !0,
                      children: /* @__PURE__ */ S.jsx(
                        r9,
                        {
                          role: "menu",
                          "aria-orientation": "vertical",
                          "data-state": xH(v.open),
                          "data-radix-menu-content": "",
                          dir: w.dir,
                          ..._,
                          ...b,
                          ref: I,
                          style: { outline: "none", ...b.style },
                          onKeyDown: Te(b.onKeyDown, (Y) => {
                            const z = Y.target.closest("[data-radix-menu-content]") === Y.currentTarget, L = Y.ctrlKey || Y.altKey || Y.metaKey, K = Y.key.length === 1;
                            z && (Y.key === "Tab" && Y.preventDefault(), !L && K && G(Y.key));
                            const T = M.current;
                            if (Y.target !== T || !p$e.includes(Y.key)) return;
                            Y.preventDefault();
                            const V = E().filter((X) => !X.disabled).map((X) => X.ref.current);
                            QU.includes(Y.key) && V.reverse(), A$e(V);
                          }),
                          onBlur: Te(e.onBlur, (Y) => {
                            Y.currentTarget.contains(Y.target) || (window.clearTimeout(A.current), D.current = "");
                          }),
                          onPointerMove: Te(
                            e.onPointerMove,
                            Om((Y) => {
                              const z = Y.target, L = $.current !== Y.clientX;
                              if (Y.currentTarget.contains(z) && L) {
                                const K = Y.clientX > $.current ? "right" : "left";
                                U.current = K, $.current = Y.clientX;
                              }
                            })
                          )
                        }
                      )
                    }
                  )
                }
              )
            }
          ) })
        }
      );
    }
  );
  oH.displayName = jo;
  var E$e = "MenuGroup", HO = C.forwardRef(
    (e, t) => {
      const { __scopeMenu: n, ...r } = e;
      return /* @__PURE__ */ S.jsx(gt.div, { role: "group", ...r, ref: t });
    }
  );
  HO.displayName = E$e;
  var C$e = "MenuLabel", aH = C.forwardRef(
    (e, t) => {
      const { __scopeMenu: n, ...r } = e;
      return /* @__PURE__ */ S.jsx(gt.div, { ...r, ref: t });
    }
  );
  aH.displayName = C$e;
  var Hb = "MenuItem", tF = "menu.itemSelect", Ax = C.forwardRef(
    (e, t) => {
      const { disabled: n = !1, onSelect: r, ...o } = e, a = C.useRef(null), i = xh(Hb, e.__scopeMenu), s = VO(Hb, e.__scopeMenu), u = un(t, a), c = C.useRef(!1), f = () => {
        const p = a.current;
        if (!n && p) {
          const g = new CustomEvent(tF, { bubbles: !0, cancelable: !0 });
          p.addEventListener(tF, (h) => r?.(h), { once: !0 }), gC(p, g), g.defaultPrevented ? c.current = !1 : i.onClose();
        }
      };
      return /* @__PURE__ */ S.jsx(
        iH,
        {
          ...o,
          ref: u,
          disabled: n,
          onClick: Te(e.onClick, f),
          onPointerDown: (p) => {
            e.onPointerDown?.(p), c.current = !0;
          },
          onPointerUp: Te(e.onPointerUp, (p) => {
            c.current || p.currentTarget?.click();
          }),
          onKeyDown: Te(e.onKeyDown, (p) => {
            const g = s.searchRef.current !== "";
            n || g && p.key === " " || NE.includes(p.key) && (p.currentTarget.click(), p.preventDefault());
          })
        }
      );
    }
  );
  Ax.displayName = Hb;
  var iH = C.forwardRef(
    (e, t) => {
      const { __scopeMenu: n, disabled: r = !1, textValue: o, ...a } = e, i = VO(Hb, n), s = eH(n), u = C.useRef(null), c = un(t, u), [f, p] = C.useState(!1), [g, h] = C.useState("");
      return C.useEffect(() => {
        const y = u.current;
        y && h((y.textContent ?? "").trim());
      }, [a.children]), /* @__PURE__ */ S.jsx(
        Pm.ItemSlot,
        {
          scope: n,
          disabled: r,
          textValue: o ?? g,
          children: /* @__PURE__ */ S.jsx(LU, { asChild: !0, ...s, focusable: !r, children: /* @__PURE__ */ S.jsx(
            gt.div,
            {
              role: "menuitem",
              "data-highlighted": f ? "" : void 0,
              "aria-disabled": r || void 0,
              "data-disabled": r ? "" : void 0,
              ...a,
              ref: c,
              onPointerMove: Te(
                e.onPointerMove,
                Om((y) => {
                  r ? i.onItemLeave(y) : (i.onItemEnter(y), y.defaultPrevented || y.currentTarget.focus({ preventScroll: !0 }));
                })
              ),
              onPointerLeave: Te(
                e.onPointerLeave,
                Om((y) => i.onItemLeave(y))
              ),
              onFocus: Te(e.onFocus, () => p(!0)),
              onBlur: Te(e.onBlur, () => p(!1))
            }
          ) })
        }
      );
    }
  ), P$e = "MenuCheckboxItem", sH = C.forwardRef(
    (e, t) => {
      const { checked: n = !1, onCheckedChange: r, ...o } = e;
      return /* @__PURE__ */ S.jsx(fH, { scope: e.__scopeMenu, checked: n, children: /* @__PURE__ */ S.jsx(
        Ax,
        {
          role: "menuitemcheckbox",
          "aria-checked": Wb(n) ? "mixed" : n,
          ...o,
          ref: t,
          "data-state": KO(n),
          onSelect: Te(
            o.onSelect,
            () => r?.(Wb(n) ? !0 : !n),
            { checkForDefaultPrevented: !1 }
          )
        }
      ) });
    }
  );
  sH.displayName = P$e;
  var lH = "MenuRadioGroup", [O$e, N$e] = Iu(
    lH,
    { value: void 0, onValueChange: () => {
    } }
  ), uH = C.forwardRef(
    (e, t) => {
      const { value: n, onValueChange: r, ...o } = e, a = Wr(r);
      return /* @__PURE__ */ S.jsx(O$e, { scope: e.__scopeMenu, value: n, onValueChange: a, children: /* @__PURE__ */ S.jsx(HO, { ...o, ref: t }) });
    }
  );
  uH.displayName = lH;
  var cH = "MenuRadioItem", dH = C.forwardRef(
    (e, t) => {
      const { value: n, ...r } = e, o = N$e(cH, e.__scopeMenu), a = n === o.value;
      return /* @__PURE__ */ S.jsx(fH, { scope: e.__scopeMenu, checked: a, children: /* @__PURE__ */ S.jsx(
        Ax,
        {
          role: "menuitemradio",
          "aria-checked": a,
          ...r,
          ref: t,
          "data-state": KO(a),
          onSelect: Te(
            r.onSelect,
            () => o.onValueChange?.(n),
            { checkForDefaultPrevented: !1 }
          )
        }
      ) });
    }
  );
  dH.displayName = cH;
  var WO = "MenuItemIndicator", [fH, M$e] = Iu(
    WO,
    { checked: !1 }
  ), pH = C.forwardRef(
    (e, t) => {
      const { __scopeMenu: n, forceMount: r, ...o } = e, a = M$e(WO, n);
      return /* @__PURE__ */ S.jsx(
        ia,
        {
          present: r || Wb(a.checked) || a.checked === !0,
          children: /* @__PURE__ */ S.jsx(
            gt.span,
            {
              ...o,
              ref: t,
              "data-state": KO(a.checked)
            }
          )
        }
      );
    }
  );
  pH.displayName = WO;
  var R$e = "MenuSeparator", mH = C.forwardRef(
    (e, t) => {
      const { __scopeMenu: n, ...r } = e;
      return /* @__PURE__ */ S.jsx(
        gt.div,
        {
          role: "separator",
          "aria-orientation": "horizontal",
          ...r,
          ref: t
        }
      );
    }
  );
  mH.displayName = R$e;
  var j$e = "MenuArrow", hH = C.forwardRef(
    (e, t) => {
      const { __scopeMenu: n, ...r } = e, o = wh(n);
      return /* @__PURE__ */ S.jsx(o9, { ...o, ...r, ref: t });
    }
  );
  hH.displayName = j$e;
  var qO = "MenuSub", [I$e, gH] = Iu(qO), vH = (e) => {
    const { __scopeMenu: t, children: n, open: r = !1, onOpenChange: o } = e, a = Au(qO, t), i = wh(t), [s, u] = C.useState(null), [c, f] = C.useState(null), p = Wr(o);
    return C.useEffect(() => (a.open === !1 && p(!1), () => p(!1)), [a.open, p]), /* @__PURE__ */ S.jsx(WC, { ...i, children: /* @__PURE__ */ S.jsx(
      tH,
      {
        scope: t,
        open: r,
        onOpenChange: p,
        content: c,
        onContentChange: f,
        children: /* @__PURE__ */ S.jsx(
          I$e,
          {
            scope: t,
            contentId: Ua(),
            triggerId: Ua(),
            trigger: s,
            onTriggerChange: u,
            children: n
          }
        )
      }
    ) });
  };
  vH.displayName = qO;
  var Cp = "MenuSubTrigger", yH = C.forwardRef(
    (e, t) => {
      const n = Au(Cp, e.__scopeMenu), r = xh(Cp, e.__scopeMenu), o = gH(Cp, e.__scopeMenu), a = VO(Cp, e.__scopeMenu), i = C.useRef(null), { pointerGraceTimerRef: s, onPointerGraceIntentChange: u } = a, c = { __scopeMenu: e.__scopeMenu }, f = C.useCallback(() => {
        i.current && window.clearTimeout(i.current), i.current = null;
      }, []);
      return C.useEffect(() => f, [f]), C.useEffect(() => {
        const p = s.current;
        return () => {
          window.clearTimeout(p), u(null);
        };
      }, [s, u]), /* @__PURE__ */ S.jsx(BO, { asChild: !0, ...c, children: /* @__PURE__ */ S.jsx(
        iH,
        {
          id: o.triggerId,
          "aria-haspopup": "menu",
          "aria-expanded": n.open,
          "aria-controls": o.contentId,
          "data-state": xH(n.open),
          ...e,
          ref: bw(t, o.onTriggerChange),
          onClick: (p) => {
            e.onClick?.(p), !(e.disabled || p.defaultPrevented) && (p.currentTarget.focus(), n.open || n.onOpenChange(!0));
          },
          onPointerMove: Te(
            e.onPointerMove,
            Om((p) => {
              a.onItemEnter(p), !p.defaultPrevented && !e.disabled && !n.open && !i.current && (a.onPointerGraceIntentChange(null), i.current = window.setTimeout(() => {
                n.onOpenChange(!0), f();
              }, 100));
            })
          ),
          onPointerLeave: Te(
            e.onPointerLeave,
            Om((p) => {
              f();
              const g = n.content?.getBoundingClientRect();
              if (g) {
                const h = n.content?.dataset.side, y = h === "right", b = y ? -5 : 5, v = g[y ? "left" : "right"], w = g[y ? "right" : "left"];
                a.onPointerGraceIntentChange({
                  area: [
                    // Apply a bleed on clientX to ensure that our exit point is
                    // consistently within polygon bounds
                    { x: p.clientX + b, y: p.clientY },
                    { x: v, y: g.top },
                    { x: w, y: g.top },
                    { x: w, y: g.bottom },
                    { x: v, y: g.bottom }
                  ],
                  side: h
                }), window.clearTimeout(s.current), s.current = window.setTimeout(
                  () => a.onPointerGraceIntentChange(null),
                  300
                );
              } else {
                if (a.onTriggerLeave(p), p.defaultPrevented) return;
                a.onPointerGraceIntentChange(null);
              }
            })
          ),
          onKeyDown: Te(e.onKeyDown, (p) => {
            const g = a.searchRef.current !== "";
            e.disabled || g && p.key === " " || m$e[r.dir].includes(p.key) && (n.onOpenChange(!0), n.content?.focus(), p.preventDefault());
          })
        }
      ) });
    }
  );
  yH.displayName = Cp;
  var bH = "MenuSubContent", wH = C.forwardRef(
    (e, t) => {
      const n = rH(jo, e.__scopeMenu), { forceMount: r = n.forceMount, ...o } = e, a = Au(jo, e.__scopeMenu), i = xh(jo, e.__scopeMenu), s = gH(bH, e.__scopeMenu), u = C.useRef(null), c = un(t, u);
      return /* @__PURE__ */ S.jsx(Pm.Provider, { scope: e.__scopeMenu, children: /* @__PURE__ */ S.jsx(ia, { present: r || a.open, children: /* @__PURE__ */ S.jsx(Pm.Slot, { scope: e.__scopeMenu, children: /* @__PURE__ */ S.jsx(
        UO,
        {
          id: s.contentId,
          "aria-labelledby": s.triggerId,
          ...o,
          ref: c,
          align: "start",
          side: i.dir === "rtl" ? "left" : "right",
          disableOutsidePointerEvents: !1,
          disableOutsideScroll: !1,
          trapFocus: !1,
          onOpenAutoFocus: (f) => {
            i.isUsingKeyboardRef.current && u.current?.focus(), f.preventDefault();
          },
          onCloseAutoFocus: (f) => f.preventDefault(),
          onFocusOutside: Te(e.onFocusOutside, (f) => {
            f.target !== s.trigger && a.onOpenChange(!1);
          }),
          onEscapeKeyDown: Te(e.onEscapeKeyDown, (f) => {
            i.onClose(), f.preventDefault();
          }),
          onKeyDown: Te(e.onKeyDown, (f) => {
            const p = f.currentTarget.contains(f.target), g = h$e[i.dir].includes(f.key);
            p && g && (a.onOpenChange(!1), s.trigger?.focus(), f.preventDefault());
          })
        }
      ) }) }) });
    }
  );
  wH.displayName = bH;
  function xH(e) {
    return e ? "open" : "closed";
  }
  function Wb(e) {
    return e === "indeterminate";
  }
  function KO(e) {
    return Wb(e) ? "indeterminate" : e ? "checked" : "unchecked";
  }
  function A$e(e) {
    const t = document.activeElement;
    for (const n of e)
      if (n === t || (n.focus(), document.activeElement !== t)) return;
  }
  function $$e(e, t) {
    return e.map((n, r) => e[(t + r) % e.length]);
  }
  function D$e(e, t, n) {
    const r = t.length > 1 && Array.from(t).every((s) => s === t[0]) ? t[0] : t, o = n ? e.indexOf(n) : -1;
    let a = $$e(e, Math.max(o, 0));
    r.length === 1 && (a = a.filter((s) => s !== n));
    const i = a.find(
      (s) => s.toLowerCase().startsWith(r.toLowerCase())
    );
    return i !== n ? i : void 0;
  }
  function L$e(e, t) {
    const { x: n, y: r } = e;
    let o = !1;
    for (let a = 0, i = t.length - 1; a < t.length; i = a++) {
      const s = t[a], u = t[i], c = s.x, f = s.y, p = u.x, g = u.y;
      f > r != g > r && n < (p - c) * (r - f) / (g - f) + c && (o = !o);
    }
    return o;
  }
  function F$e(e, t) {
    if (!t) return !1;
    const n = { x: e.clientX, y: e.clientY };
    return L$e(n, t);
  }
  function Om(e) {
    return (t) => t.pointerType === "mouse" ? e(t) : void 0;
  }
  var T$e = nH, z$e = BO, B$e = oH, V$e = HO, U$e = aH, H$e = Ax, W$e = sH, q$e = uH, K$e = dH, G$e = pH, X$e = mH, Y$e = hH, J$e = vH, Q$e = yH, Z$e = wH, $x = "DropdownMenu", [e3e] = Ja(
    $x,
    [ZU]
  ), Mr = ZU(), [t3e, kH] = e3e($x), SH = (e) => {
    const {
      __scopeDropdownMenu: t,
      children: n,
      dir: r,
      open: o,
      defaultOpen: a,
      onOpenChange: i,
      modal: s = !0
    } = e, u = Mr(t), c = C.useRef(null), [f, p] = ml({
      prop: o,
      defaultProp: a ?? !1,
      onChange: i,
      caller: $x
    });
    return /* @__PURE__ */ S.jsx(
      t3e,
      {
        scope: t,
        triggerId: Ua(),
        triggerRef: c,
        contentId: Ua(),
        open: f,
        onOpenChange: p,
        onOpenToggle: C.useCallback(() => p((g) => !g), [p]),
        modal: s,
        children: /* @__PURE__ */ S.jsx(T$e, { ...u, open: f, onOpenChange: p, dir: r, modal: s, children: n })
      }
    );
  };
  SH.displayName = $x;
  var _H = "DropdownMenuTrigger", EH = C.forwardRef(
    (e, t) => {
      const { __scopeDropdownMenu: n, disabled: r = !1, ...o } = e, a = kH(_H, n), i = Mr(n);
      return /* @__PURE__ */ S.jsx(z$e, { asChild: !0, ...i, children: /* @__PURE__ */ S.jsx(
        gt.button,
        {
          type: "button",
          id: a.triggerId,
          "aria-haspopup": "menu",
          "aria-expanded": a.open,
          "aria-controls": a.open ? a.contentId : void 0,
          "data-state": a.open ? "open" : "closed",
          "data-disabled": r ? "" : void 0,
          disabled: r,
          ...o,
          ref: bw(t, a.triggerRef),
          onPointerDown: Te(e.onPointerDown, (s) => {
            !r && s.button === 0 && s.ctrlKey === !1 && (a.onOpenToggle(), a.open || s.preventDefault());
          }),
          onKeyDown: Te(e.onKeyDown, (s) => {
            r || (["Enter", " "].includes(s.key) && a.onOpenToggle(), s.key === "ArrowDown" && a.onOpenChange(!0), ["Enter", " ", "ArrowDown"].includes(s.key) && s.preventDefault());
          })
        }
      ) });
    }
  );
  EH.displayName = _H;
  var CH = "DropdownMenuContent", PH = C.forwardRef(
    (e, t) => {
      const { __scopeDropdownMenu: n, ...r } = e, o = kH(CH, n), a = Mr(n), i = C.useRef(!1);
      return /* @__PURE__ */ S.jsx(
        B$e,
        {
          id: o.contentId,
          "aria-labelledby": o.triggerId,
          ...a,
          ...r,
          ref: t,
          onCloseAutoFocus: Te(e.onCloseAutoFocus, (s) => {
            i.current || o.triggerRef.current?.focus(), i.current = !1, s.preventDefault();
          }),
          onInteractOutside: Te(e.onInteractOutside, (s) => {
            const u = s.detail.originalEvent, c = u.button === 0 && u.ctrlKey === !0, f = u.button === 2 || c;
            (!o.modal || f) && (i.current = !0);
          }),
          style: {
            ...e.style,
            "--radix-dropdown-menu-content-transform-origin": "var(--radix-popper-transform-origin)",
            "--radix-dropdown-menu-content-available-width": "var(--radix-popper-available-width)",
            "--radix-dropdown-menu-content-available-height": "var(--radix-popper-available-height)",
            "--radix-dropdown-menu-trigger-width": "var(--radix-popper-anchor-width)",
            "--radix-dropdown-menu-trigger-height": "var(--radix-popper-anchor-height)"
          }
        }
      );
    }
  );
  PH.displayName = CH;
  var n3e = "DropdownMenuGroup", OH = C.forwardRef(
    (e, t) => {
      const { __scopeDropdownMenu: n, ...r } = e, o = Mr(n);
      return /* @__PURE__ */ S.jsx(V$e, { ...o, ...r, ref: t });
    }
  );
  OH.displayName = n3e;
  var r3e = "DropdownMenuLabel", o3e = C.forwardRef(
    (e, t) => {
      const { __scopeDropdownMenu: n, ...r } = e, o = Mr(n);
      return /* @__PURE__ */ S.jsx(U$e, { ...o, ...r, ref: t });
    }
  );
  o3e.displayName = r3e;
  var a3e = "DropdownMenuItem", NH = C.forwardRef(
    (e, t) => {
      const { __scopeDropdownMenu: n, ...r } = e, o = Mr(n);
      return /* @__PURE__ */ S.jsx(H$e, { ...o, ...r, ref: t });
    }
  );
  NH.displayName = a3e;
  var i3e = "DropdownMenuCheckboxItem", s3e = C.forwardRef((e, t) => {
    const { __scopeDropdownMenu: n, ...r } = e, o = Mr(n);
    return /* @__PURE__ */ S.jsx(W$e, { ...o, ...r, ref: t });
  });
  s3e.displayName = i3e;
  var l3e = "DropdownMenuRadioGroup", MH = C.forwardRef((e, t) => {
    const { __scopeDropdownMenu: n, ...r } = e, o = Mr(n);
    return /* @__PURE__ */ S.jsx(q$e, { ...o, ...r, ref: t });
  });
  MH.displayName = l3e;
  var u3e = "DropdownMenuRadioItem", RH = C.forwardRef((e, t) => {
    const { __scopeDropdownMenu: n, ...r } = e, o = Mr(n);
    return /* @__PURE__ */ S.jsx(K$e, { ...o, ...r, ref: t });
  });
  RH.displayName = u3e;
  var c3e = "DropdownMenuItemIndicator", d3e = C.forwardRef((e, t) => {
    const { __scopeDropdownMenu: n, ...r } = e, o = Mr(n);
    return /* @__PURE__ */ S.jsx(G$e, { ...o, ...r, ref: t });
  });
  d3e.displayName = c3e;
  var f3e = "DropdownMenuSeparator", p3e = C.forwardRef((e, t) => {
    const { __scopeDropdownMenu: n, ...r } = e, o = Mr(n);
    return /* @__PURE__ */ S.jsx(X$e, { ...o, ...r, ref: t });
  });
  p3e.displayName = f3e;
  var m3e = "DropdownMenuArrow", h3e = C.forwardRef(
    (e, t) => {
      const { __scopeDropdownMenu: n, ...r } = e, o = Mr(n);
      return /* @__PURE__ */ S.jsx(Y$e, { ...o, ...r, ref: t });
    }
  );
  h3e.displayName = m3e;
  var g3e = (e) => {
    const { __scopeDropdownMenu: t, children: n, open: r, onOpenChange: o, defaultOpen: a } = e, i = Mr(t), [s, u] = ml({
      prop: r,
      defaultProp: a ?? !1,
      onChange: o,
      caller: "DropdownMenuSub"
    });
    return /* @__PURE__ */ S.jsx(J$e, { ...i, open: s, onOpenChange: u, children: n });
  }, v3e = "DropdownMenuSubTrigger", jH = C.forwardRef((e, t) => {
    const { __scopeDropdownMenu: n, ...r } = e, o = Mr(n);
    return /* @__PURE__ */ S.jsx(Q$e, { ...o, ...r, ref: t });
  });
  jH.displayName = v3e;
  var y3e = "DropdownMenuSubContent", IH = C.forwardRef((e, t) => {
    const { __scopeDropdownMenu: n, ...r } = e, o = Mr(n);
    return /* @__PURE__ */ S.jsx(
      Z$e,
      {
        ...o,
        ...r,
        ref: t,
        style: {
          ...e.style,
          "--radix-dropdown-menu-content-transform-origin": "var(--radix-popper-transform-origin)",
          "--radix-dropdown-menu-content-available-width": "var(--radix-popper-available-width)",
          "--radix-dropdown-menu-content-available-height": "var(--radix-popper-available-height)",
          "--radix-dropdown-menu-trigger-width": "var(--radix-popper-anchor-width)",
          "--radix-dropdown-menu-trigger-height": "var(--radix-popper-anchor-height)"
        }
      }
    );
  });
  IH.displayName = y3e;
  var GO = SH, XO = EH, YO = PH, JO = OH, $i = NH, b3e = MH, w3e = RH, x3e = g3e, k3e = jH, S3e = IH;
  const _3e = ({
    trigger: e,
    setOpen: t,
    open: n
  }) => {
    const [r, o] = C.useState(""), [a, i] = C.useState(!0), s = Vt();
    return s.options.useWorkerManager ? /* @__PURE__ */ S.jsxs(
      Qa,
      {
        setOpen: t,
        open: n,
        trigger: e,
        title: "New Worker",
        description: "Create a new worker",
        children: [
          /* @__PURE__ */ S.jsxs("div", { children: [
            "Name:",
            /* @__PURE__ */ S.jsx("br", {}),
            /* @__PURE__ */ S.jsx(
              "input",
              {
                className: "styledinput",
                onChange: (u) => {
                  o(u.currentTarget.value);
                },
                value: r
              }
            ),
            /* @__PURE__ */ S.jsxs("div", { style: { marginTop: 8 }, children: [
              /* @__PURE__ */ S.jsx(
                "input",
                {
                  type: "checkbox",
                  id: "inVenvCheckbox",
                  checked: a,
                  onChange: (u) => i(u.currentTarget.checked)
                }
              ),
              /* @__PURE__ */ S.jsx("label", { htmlFor: "inVenvCheckbox", style: { marginLeft: 4 }, children: "Create in new virtual environment" })
            ] })
          ] }),
          /* @__PURE__ */ S.jsx("div", { children: r && /* @__PURE__ */ S.jsx("div", { children: /* @__PURE__ */ S.jsx(
            "button",
            {
              className: "styledbtn",
              onClick: () => {
                s.workermanager?.new_worker({
                  name: r,
                  in_venv: a
                  // reference: reference.uuid,
                  // copyLib,
                  // copyNS,
                }), t(!1);
              },
              children: "Create"
            }
          ) }) })
        ]
      }
    ) : null;
  }, E3e = ({
    trigger: e,
    setOpen: t,
    open: n
  }) => {
    const r = Vt(), [o, a] = C.useState(!1), i = r.workers(), s = r.worker?.uuid, u = (s ? i[s]?.name : void 0) || s || "worker", c = async () => {
      if (!r.worker) return;
      const f = await r.worker.export({ withFiles: o });
      vG(f, u + ".fnw", "application/zip"), t(!1);
    };
    return /* @__PURE__ */ S.jsx(
      Qa,
      {
        setOpen: t,
        open: n,
        trigger: e,
        title: "Export Worker",
        description: "Export the worker as a .fnw file",
        children: /* @__PURE__ */ S.jsxs("div", { children: [
          /* @__PURE__ */ S.jsxs("div", { children: [
            /* @__PURE__ */ S.jsx(
              "input",
              {
                type: "checkbox",
                className: "styledcheckbox",
                checked: o,
                onChange: (f) => {
                  a(f.currentTarget.checked);
                }
              }
            ),
            "Include Files"
          ] }),
          /* @__PURE__ */ S.jsx("button", { className: "styledbtn", onClick: c, children: "Export" })
        ] })
      }
    );
  }, C3e = () => {
    const e = Vt(), t = e.workers(), [n, r] = C.useState(!1), [o, a] = C.useState(!1), i = (g) => {
      g !== "__select__" && e.workers && e.workermanager && t[g] && (!t[g].active && !window.confirm(
        "this is an inactive worker, selecting it will start it, continue?"
      ) || e.workermanager.set_active(g));
    }, s = async () => {
      if (!e.worker || !window.confirm(
        "Updateing the worker might replace the current nodespace, continue?"
      )) return;
      const g = await wG(".fnw");
      e.worker.update_from_export(g);
    }, u = e.options.useWorkerManager && e.workermanager && e.workermanager.open || Cm(), c = u && Object.keys(t).length > 0, f = e.worker && e.worker.is_open, p = f && u;
    return u || f ? /* @__PURE__ */ S.jsxs(S.Fragment, { children: [
      /* @__PURE__ */ S.jsxs(GO, { children: [
        /* @__PURE__ */ S.jsx(XO, { asChild: !0, children: /* @__PURE__ */ S.jsx("button", { className: "styledbtn", children: /* @__PURE__ */ S.jsxs(el, { direction: "row", children: [
          "Worker ",
          /* @__PURE__ */ S.jsx(AC, { className: "m-x-s" })
        ] }) }) }),
        /* @__PURE__ */ S.jsx(YO, { className: "headermenucontent funcnodescontainer", children: /* @__PURE__ */ S.jsxs(JO, { children: [
          c && /* @__PURE__ */ S.jsxs(x3e, { children: [
            /* @__PURE__ */ S.jsx(k3e, { className: "headermenuitem submenuitem", children: /* @__PURE__ */ S.jsxs(el, { direction: "row", children: [
              "Select",
              /* @__PURE__ */ S.jsx(Zp, {})
            ] }) }),
            /* @__PURE__ */ S.jsx(
              S3e,
              {
                className: "headermenucontent funcnodescontainer",
                sideOffset: 2,
                alignOffset: -5,
                children: /* @__PURE__ */ S.jsx(
                  b3e,
                  {
                    value: e.worker?.uuid,
                    onValueChange: (g) => {
                      i(g);
                    },
                    children: Object.keys(t).sort((g, h) => {
                      if (t[g].active && !t[h].active)
                        return -1;
                      if (!t[g].active && t[h].active)
                        return 1;
                      const y = t[g].name || g, b = t[h].name || h;
                      return y.localeCompare(b);
                    }).map((g) => /* @__PURE__ */ S.jsx(
                      w3e,
                      {
                        className: "headermenuitem workerselectoption" + (t[g]?.active ? " active" : " inactive") + " headermenuitem",
                        value: g,
                        disabled: g === e.worker?.uuid,
                        children: t[g]?.name || g
                      },
                      g
                    ))
                  }
                )
              }
            )
          ] }),
          f && /* @__PURE__ */ S.jsxs(S.Fragment, { children: [
            p && /* @__PURE__ */ S.jsx(
              $i,
              {
                className: "headermenuitem",
                onClick: () => {
                  if (e.worker) {
                    if (!e.workermanager)
                      return e.logger.error("no workermanager");
                    e.workermanager?.restart_worker(
                      e.worker.uuid
                    );
                  }
                },
                children: "Restart"
              }
            ),
            /* @__PURE__ */ S.jsx(
              $i,
              {
                className: "headermenuitem",
                onClick: () => {
                  e.worker && e.worker.stop();
                },
                children: "Stop"
              }
            ),
            /* @__PURE__ */ S.jsx(
              $i,
              {
                className: "headermenuitem",
                onClick: () => a(!0),
                children: "Export"
              }
            ),
            /* @__PURE__ */ S.jsx(
              $i,
              {
                className: "headermenuitem",
                onClick: s,
                children: "Update"
              }
            )
          ] }),
          u && /* @__PURE__ */ S.jsx(S.Fragment, { children: /* @__PURE__ */ S.jsx(
            $i,
            {
              className: "headermenuitem",
              onClick: () => r(!0),
              children: "New"
            }
          ) })
        ] }) })
      ] }),
      /* @__PURE__ */ S.jsx(
        _3e,
        {
          open: n,
          setOpen: r
        }
      ),
      /* @__PURE__ */ S.jsx(
        E3e,
        {
          open: o,
          setOpen: a
        }
      )
    ] }) : null;
  }, P3e = () => {
    const e = Vt(), t = () => {
      window.confirm("Are you sure you want to start a new flow?") && e.worker?.clear();
    }, n = async () => {
      const o = await e.worker?.save();
      if (!o) return;
      const a = new Blob([JSON.stringify(o)], {
        type: "application/json"
      }), i = URL.createObjectURL(a), s = document.createElement("a");
      s.href = i, s.download = "flow.json", s.click(), URL.revokeObjectURL(i), s.remove();
    }, r = async () => {
      const o = document.createElement("input");
      o.type = "file", o.accept = ".json", o.onchange = async (a) => {
        const i = a.target.files?.[0];
        if (!i) return;
        const s = new FileReader();
        s.onload = async (u) => {
          const c = u.target?.result;
          if (!c) return;
          const f = JSON.parse(c);
          await e.worker?.load(f);
        }, s.readAsText(i);
      }, o.click();
    };
    return /* @__PURE__ */ S.jsx(S.Fragment, { children: /* @__PURE__ */ S.jsxs(GO, { children: [
      /* @__PURE__ */ S.jsx(XO, { asChild: !0, children: /* @__PURE__ */ S.jsx("button", { className: "styledbtn", children: /* @__PURE__ */ S.jsxs(el, { direction: "row", children: [
        "Nodespace ",
        /* @__PURE__ */ S.jsx(AC, { className: "m-x-s" })
      ] }) }) }),
      /* @__PURE__ */ S.jsx(YO, { className: "headermenucontent funcnodescontainer", children: /* @__PURE__ */ S.jsxs(JO, { children: [
        /* @__PURE__ */ S.jsx($i, { className: "headermenuitem", onClick: t, children: "New" }),
        /* @__PURE__ */ S.jsx($i, { className: "headermenuitem", onClick: n, children: "Save" }),
        /* @__PURE__ */ S.jsx($i, { className: "headermenuitem", onClick: r, children: "Load" })
      ] }) })
    ] }) });
  }, O3e = ({ theme: e, selected: t }) => /* @__PURE__ */ S.jsxs(
    "div",
    {
      style: {
        width: 80,
        height: 54,
        borderRadius: "var(--fn-border-radius-s, 8px)",
        border: t ? "2.5px solid #1976d2" : "1.5px solid #bbb",
        boxShadow: t ? "0 0 0 2px #1976d2" : "0 1px 4px #0002",
        background: "var(--fn-app-background)",
        display: "flex",
        flexDirection: "column",
        alignItems: "stretch",
        justifyContent: "flex-start",
        position: "relative",
        overflow: "hidden",
        transition: "border 0.2s, box-shadow 0.2s"
      },
      "fn-data-color-theme": e,
      children: [
        /* @__PURE__ */ S.jsx(
          "div",
          {
            style: {
              height: 10,
              background: "var(--fn-primary-color)",
              borderBottom: "1px solid var(--fn-neutral-element-border)"
            }
          }
        ),
        /* @__PURE__ */ S.jsxs("div", { style: { display: "flex", flex: 1 }, children: [
          /* @__PURE__ */ S.jsx(
            "div",
            {
              style: {
                width: 12,
                background: "var(--fn-surface-elevation-low, var(--fn-container-background))",
                borderRight: "1px solid var(--fn-neutral-element-border)"
              }
            }
          ),
          /* @__PURE__ */ S.jsx(
            "div",
            {
              style: {
                flex: 1,
                display: "flex",
                alignItems: "center",
                justifyContent: "center",
                background: "var(--fn-container-background)"
              },
              children: /* @__PURE__ */ S.jsxs(
                "div",
                {
                  style: {
                    width: 22,
                    height: 14,
                    borderRadius: "var(--fn-border-radius-xs, 4px)",
                    background: "var(--fn-node-background)",
                    border: "1px solid var(--fn-node-header-color)",
                    boxShadow: "0 1px 2px #0002",
                    display: "flex",
                    flexDirection: "column"
                  },
                  children: [
                    /* @__PURE__ */ S.jsx(
                      "div",
                      {
                        style: {
                          height: 5,
                          background: "var(--fn-node-header-color)",
                          borderTopLeftRadius: "var(--fn-border-radius-xs, 4px)",
                          borderTopRightRadius: "var(--fn-border-radius-xs, 4px)"
                        }
                      }
                    ),
                    /* @__PURE__ */ S.jsx(
                      "div",
                      {
                        style: {
                          flex: 1,
                          background: "transparent"
                        }
                      }
                    )
                  ]
                }
              )
            }
          )
        ] }),
        /* @__PURE__ */ S.jsx(
          "span",
          {
            style: {
              position: "absolute",
              bottom: 2,
              right: 4,
              fontSize: 9,
              color: "var(--fn-text-color-neutral)",
              opacity: 0.7,
              textTransform: "capitalize",
              fontWeight: 600,
              pointerEvents: "none"
            },
            children: e
          }
        ),
        t && /* @__PURE__ */ S.jsx(
          "span",
          {
            style: {
              position: "absolute",
              top: 2,
              left: 6,
              fontSize: 14,
              color: "#1976d2",
              fontWeight: 900,
              pointerEvents: "none"
            },
            "aria-label": "Selected",
            children: ""
          }
        )
      ]
    }
  ), N3e = () => {
    const { colorTheme: e, setColorTheme: t } = jz(), [n, r] = C.useState(null), [o, a] = C.useState(null), i = (u) => {
      u !== e && (a(e), t(u), r(u));
    }, s = (u) => {
      n === u && o && o !== u && t(o), r(null), a(null);
    };
    return /* @__PURE__ */ S.jsxs("div", { style: { display: "flex", flexDirection: "column", gap: "1em" }, children: [
      /* @__PURE__ */ S.jsx("div", { style: { marginBottom: 8, fontWeight: 500 }, children: "Theme:" }),
      /* @__PURE__ */ S.jsx("div", { style: {
        display: "grid",
        gridTemplateColumns: "repeat(auto-fill, minmax(80px, 1fr))",
        gap: 16,
        justifyItems: "center"
      }, children: q8.map((u) => /* @__PURE__ */ S.jsx(
        "button",
        {
          onClick: () => {
            t(u), r(null), a(null);
          },
          onMouseEnter: () => i(u),
          onMouseLeave: () => s(u),
          style: {
            background: "none",
            border: "none",
            padding: 0,
            cursor: "pointer",
            outline: "none",
            borderRadius: 8
          },
          "aria-label": `Select ${u} theme`,
          children: /* @__PURE__ */ S.jsx(
            O3e,
            {
              theme: u,
              selected: e === u
            }
          )
        },
        u
      )) })
    ] });
  }, M3e = () => {
    const [e, t] = C.useState(!1), n = () => {
      t(!0);
    };
    return /* @__PURE__ */ S.jsxs(S.Fragment, { children: [
      /* @__PURE__ */ S.jsxs(GO, { children: [
        /* @__PURE__ */ S.jsx(XO, { asChild: !0, children: /* @__PURE__ */ S.jsx("button", { className: "styledbtn", children: /* @__PURE__ */ S.jsxs(el, { direction: "row", children: [
          "Settings ",
          /* @__PURE__ */ S.jsx(AC, { className: "m-x-s" })
        ] }) }) }),
        /* @__PURE__ */ S.jsx(YO, { className: "headermenucontent funcnodescontainer", children: /* @__PURE__ */ S.jsx(JO, { children: /* @__PURE__ */ S.jsx(
          $i,
          {
            className: "headermenuitem",
            onClick: n,
            children: "Appearance"
          }
        ) }) })
      ] }),
      /* @__PURE__ */ S.jsx(
        Qa,
        {
          open: e,
          setOpen: t,
          title: "Appearance",
          description: "Change the color theme.",
          closebutton: !0,
          children: /* @__PURE__ */ S.jsx(N3e, {})
        }
      )
    ] });
  }, R3e = ({
    ...e
  }) => {
    const t = Vt(), n = t.workerstate();
    return Object.keys(e).length > 0 && t.logger.debug("headerprops", e), /* @__PURE__ */ S.jsxs(el, { className: "funcnodesreactflowheader", direction: "row", wrap: !0, children: [
      /* @__PURE__ */ S.jsx(
        el,
        {
          className: "headerelement m-w-6",
          grow: {
            "": !0,
            m: !1
          },
          children: /* @__PURE__ */ S.jsx(d$e, {})
        }
      ),
      (e.showmenu || Cm()) && /* @__PURE__ */ S.jsxs(el, { direction: "row", wrap: !0, children: [
        /* @__PURE__ */ S.jsx("div", { className: "headerelement", children: /* @__PURE__ */ S.jsx(C3e, {}) }),
        (t.worker && n.is_open || Cm()) && /* @__PURE__ */ S.jsx("div", { className: "headerelement", children: /* @__PURE__ */ S.jsx(P3e, {}) }),
        /* @__PURE__ */ S.jsx("div", { className: "headerelement", children: /* @__PURE__ */ S.jsx(M3e, {}) })
      ] })
    ] });
  }, AH = ({ item: e }) => {
    const { node: t } = Nr(), n = C.useCallback(() => {
      t?.add_node(e.node_id);
    }, [e.node_id, t]), r = C.useCallback(
      (o) => {
        o.detail === 2 && n();
      },
      [n]
    );
    return /* @__PURE__ */ S.jsx("div", { className: "libnodeentry", onClick: r, title: e.description, children: e.node_name || e.node_id });
  }, $H = (e, t) => {
    const n = e.nodes?.some(
      (o) => o.node_id.toLowerCase().includes(t.toLowerCase())
    ) ?? !1, r = e.subshelves?.some((o) => $H(o, t)) ?? !1;
    return n || r;
  }, QO = ({
    item: e,
    filter: t,
    parentkey: n
  }) => {
    const [r, o] = C.useState(!1), a = () => o(!r), i = e.nodes?.filter(
      (u) => u.node_id.toLowerCase().includes(t.toLowerCase())
    ), s = r || t.length > 0;
    return $H(e, t) ? /* @__PURE__ */ S.jsxs("div", { className: "shelfcontainer", children: [
      /* @__PURE__ */ S.jsxs(
        "div",
        {
          className: "shelftitle",
          onClick: a,
          style: { cursor: "pointer" },
          title: e.description,
          children: [
            /* @__PURE__ */ S.jsx("div", { className: "shelftitle_text", children: e.name }),
            /* @__PURE__ */ S.jsx("div", { className: "expandicon " + (s ? "open" : "close"), children: /* @__PURE__ */ S.jsx(Wm, {}) })
          ]
        }
      ),
      /* @__PURE__ */ S.jsx("div", { className: "libnodecontainer " + (s ? "open" : "close"), children: /* @__PURE__ */ S.jsxs("div", { className: "libnodecontainer_inner", children: [
        i && /* @__PURE__ */ S.jsx(S.Fragment, { children: i.map((u) => /* @__PURE__ */ S.jsx(AH, { item: u }, u.node_id)) }),
        e.subshelves && /* @__PURE__ */ S.jsx(S.Fragment, { children: e.subshelves.map((u) => /* @__PURE__ */ S.jsx(
          QO,
          {
            item: u,
            filter: t,
            parentkey: n + u.name
          },
          n + u.name
        )) })
      ] }) }),
      /* @__PURE__ */ S.jsx("hr", {})
    ] }) : /* @__PURE__ */ S.jsx(S.Fragment, {});
  }, j3e = ({
    filter: e,
    setFilter: t
  }) => /* @__PURE__ */ S.jsxs("div", { className: "libfilter", children: [
    /* @__PURE__ */ S.jsx(Zoe, { fontSize: "inherit" }),
    /* @__PURE__ */ S.jsx(
      "input",
      {
        type: "text",
        placeholder: "Filter",
        value: e,
        onChange: (n) => {
          t(n.target.value);
        }
      }
    ),
    e && /* @__PURE__ */ S.jsx(
      Mw,
      {
        fontSize: "inherit",
        onClick: () => {
          t("");
        }
      }
    )
  ] }), I3e = ({
    children: e
  }) => {
    const [t, n] = C.useState(""), r = Vt(), [o, a] = C.useState(!0), [i, s] = C.useState(!0), [u, c] = C.useState(!0), [f, p] = C.useState({
      installed: [],
      available: [],
      active: []
    }), [g, h] = C.useState(!1), { lib: y } = Nr(), b = (I) => {
      I && (r.worker === void 0 || !r.worker.is_open || y?.get_available_modules({
        on_load: (A) => {
          p(A);
        }
      }).then((A) => {
        p(A);
      }));
    };
    if (!r.worker)
      return /* @__PURE__ */ S.jsx(S.Fragment, {});
    const v = C.useCallback(
      (I, A) => {
        h(!1), y?.add_lib(I.name, A);
      },
      [y]
    ), w = C.useCallback(
      (I, A) => {
        h(!1), y?.add_lib(I.name, A);
      },
      [y]
    ), _ = C.useCallback(
      (I) => {
        h(!1), y?.remove_lib(I.name);
      },
      [y]
    ), k = C.useCallback(
      (I, A) => {
        h(!1), y?.add_lib(I.name, A);
      },
      [y]
    ), E = C.useCallback(
      (I) => I.filter(
        (A) => A.name.toLowerCase().includes(t.toLowerCase()) || A.description.toLowerCase().includes(t.toLowerCase())
      ),
      [t]
    ), P = E(f.available), O = E(f.installed), M = E(f.active);
    return /* @__PURE__ */ S.jsxs(
      Qa,
      {
        title: "Manage Library",
        trigger: e,
        description: "Add or remove libraries to the current worker.",
        onOpenChange: b,
        open: g,
        setOpen: h,
        children: [
          /* @__PURE__ */ S.jsx(
            "input",
            {
              className: "filter-input styledinput",
              type: "text",
              placeholder: "Filter modules...",
              value: t,
              onChange: (I) => n(I.target.value)
            }
          ),
          /* @__PURE__ */ S.jsxs(
            "div",
            {
              className: "packagelist",
              style: { maxHeight: "70%", overflow: "auto" },
              children: [
                O.length > 0 && /* @__PURE__ */ S.jsx(
                  "h3",
                  {
                    onClick: () => {
                      c(!u);
                    },
                    children: "Installed"
                  }
                ),
                u && O.map((I) => /* @__PURE__ */ S.jsx(
                  aze,
                  {
                    availableModule: I,
                    on_add: v
                  },
                  I.name + I.source
                )),
                P.length > 0 && /* @__PURE__ */ S.jsx(
                  "h3",
                  {
                    onClick: () => {
                      s(!i);
                    },
                    children: "Available"
                  }
                ),
                i && P.map((I) => /* @__PURE__ */ S.jsx(
                  ize,
                  {
                    availableModule: I,
                    on_add: w
                  },
                  I.name + I.source
                )),
                M.length > 0 && /* @__PURE__ */ S.jsx(
                  "h3",
                  {
                    onClick: () => {
                      a(!o);
                    },
                    children: "Active"
                  }
                ),
                o && M.map((I) => /* @__PURE__ */ S.jsx(
                  oze,
                  {
                    availableModule: I,
                    on_remove: _,
                    on_update: k
                  },
                  I.name + I.source
                ))
              ]
            }
          )
        ]
      }
    );
  }, ZO = ({
    availableModule: e
  }) => /* @__PURE__ */ S.jsxs("div", { className: "module-links", children: [
    e.homepage && /* @__PURE__ */ S.jsx(S.Fragment, { children: /* @__PURE__ */ S.jsx(
      "a",
      {
        href: e.homepage,
        target: "_blank",
        rel: "noopener noreferrer",
        children: "Homepage"
      }
    ) }),
    e.source && e.homepage && " | ",
    e.source && /* @__PURE__ */ S.jsx(S.Fragment, { children: /* @__PURE__ */ S.jsx(
      "a",
      {
        href: e.source,
        target: "_blank",
        rel: "noopener noreferrer",
        children: "Source"
      }
    ) })
  ] });
  function A3e(e, t) {
    const n = {};
    return (e[e.length - 1] === "" ? [...e, ""] : e).join(
      (n.padRight ? " " : "") + "," + (n.padLeft === !1 ? "" : " ")
    ).trim();
  }
  const $3e = /^[$_\p{ID_Start}][$_\u{200C}\u{200D}\p{ID_Continue}]*$/u, D3e = /^[$_\p{ID_Start}][-$_\u{200C}\u{200D}\p{ID_Continue}]*$/u, L3e = {};
  function nF(e, t) {
    return (L3e.jsx ? D3e : $3e).test(e);
  }
  const F3e = /[ \t\n\f\r]/g;
  function T3e(e) {
    return typeof e == "object" ? e.type === "text" ? rF(e.value) : !1 : rF(e);
  }
  function rF(e) {
    return e.replace(F3e, "") === "";
  }
  class kh {
    /**
     * @param {SchemaType['property']} property
     *   Property.
     * @param {SchemaType['normal']} normal
     *   Normal.
     * @param {Space | undefined} [space]
     *   Space.
     * @returns
     *   Schema.
     */
    constructor(t, n, r) {
      this.normal = n, this.property = t, r && (this.space = r);
    }
  }
  kh.prototype.normal = {};
  kh.prototype.property = {};
  kh.prototype.space = void 0;
  function DH(e, t) {
    const n = {}, r = {};
    for (const o of e)
      Object.assign(n, o.property), Object.assign(r, o.normal);
    return new kh(n, r, t);
  }
  function ME(e) {
    return e.toLowerCase();
  }
  class qr {
    /**
     * @param {string} property
     *   Property.
     * @param {string} attribute
     *   Attribute.
     * @returns
     *   Info.
     */
    constructor(t, n) {
      this.attribute = n, this.property = t;
    }
  }
  qr.prototype.attribute = "";
  qr.prototype.booleanish = !1;
  qr.prototype.boolean = !1;
  qr.prototype.commaOrSpaceSeparated = !1;
  qr.prototype.commaSeparated = !1;
  qr.prototype.defined = !1;
  qr.prototype.mustUseProperty = !1;
  qr.prototype.number = !1;
  qr.prototype.overloadedBoolean = !1;
  qr.prototype.property = "";
  qr.prototype.spaceSeparated = !1;
  qr.prototype.space = void 0;
  let z3e = 0;
  const ct = $u(), Vn = $u(), RE = $u(), Oe = $u(), dn = $u(), cd = $u(), ro = $u();
  function $u() {
    return 2 ** ++z3e;
  }
  const jE = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    boolean: ct,
    booleanish: Vn,
    commaOrSpaceSeparated: ro,
    commaSeparated: cd,
    number: Oe,
    overloadedBoolean: RE,
    spaceSeparated: dn
  }, Symbol.toStringTag, { value: "Module" })), $0 = (
    /** @type {ReadonlyArray<keyof typeof types>} */
    Object.keys(jE)
  );
  class eN extends qr {
    /**
     * @constructor
     * @param {string} property
     *   Property.
     * @param {string} attribute
     *   Attribute.
     * @param {number | null | undefined} [mask]
     *   Mask.
     * @param {Space | undefined} [space]
     *   Space.
     * @returns
     *   Info.
     */
    constructor(t, n, r, o) {
      let a = -1;
      if (super(t, n), oF(this, "space", o), typeof r == "number")
        for (; ++a < $0.length; ) {
          const i = $0[a];
          oF(this, $0[a], (r & jE[i]) === jE[i]);
        }
    }
  }
  eN.prototype.defined = !0;
  function oF(e, t, n) {
    n && (e[t] = n);
  }
  function Kd(e) {
    const t = {}, n = {};
    for (const [r, o] of Object.entries(e.properties)) {
      const a = new eN(
        r,
        e.transform(e.attributes || {}, r),
        o,
        e.space
      );
      e.mustUseProperty && e.mustUseProperty.includes(r) && (a.mustUseProperty = !0), t[r] = a, n[ME(r)] = r, n[ME(a.attribute)] = r;
    }
    return new kh(t, n, e.space);
  }
  const LH = Kd({
    properties: {
      ariaActiveDescendant: null,
      ariaAtomic: Vn,
      ariaAutoComplete: null,
      ariaBusy: Vn,
      ariaChecked: Vn,
      ariaColCount: Oe,
      ariaColIndex: Oe,
      ariaColSpan: Oe,
      ariaControls: dn,
      ariaCurrent: null,
      ariaDescribedBy: dn,
      ariaDetails: null,
      ariaDisabled: Vn,
      ariaDropEffect: dn,
      ariaErrorMessage: null,
      ariaExpanded: Vn,
      ariaFlowTo: dn,
      ariaGrabbed: Vn,
      ariaHasPopup: null,
      ariaHidden: Vn,
      ariaInvalid: null,
      ariaKeyShortcuts: null,
      ariaLabel: null,
      ariaLabelledBy: dn,
      ariaLevel: Oe,
      ariaLive: null,
      ariaModal: Vn,
      ariaMultiLine: Vn,
      ariaMultiSelectable: Vn,
      ariaOrientation: null,
      ariaOwns: dn,
      ariaPlaceholder: null,
      ariaPosInSet: Oe,
      ariaPressed: Vn,
      ariaReadOnly: Vn,
      ariaRelevant: null,
      ariaRequired: Vn,
      ariaRoleDescription: dn,
      ariaRowCount: Oe,
      ariaRowIndex: Oe,
      ariaRowSpan: Oe,
      ariaSelected: Vn,
      ariaSetSize: Oe,
      ariaSort: null,
      ariaValueMax: Oe,
      ariaValueMin: Oe,
      ariaValueNow: Oe,
      ariaValueText: null,
      role: null
    },
    transform(e, t) {
      return t === "role" ? t : "aria-" + t.slice(4).toLowerCase();
    }
  });
  function FH(e, t) {
    return t in e ? e[t] : t;
  }
  function TH(e, t) {
    return FH(e, t.toLowerCase());
  }
  const B3e = Kd({
    attributes: {
      acceptcharset: "accept-charset",
      classname: "class",
      htmlfor: "for",
      httpequiv: "http-equiv"
    },
    mustUseProperty: ["checked", "multiple", "muted", "selected"],
    properties: {
      // Standard Properties.
      abbr: null,
      accept: cd,
      acceptCharset: dn,
      accessKey: dn,
      action: null,
      allow: null,
      allowFullScreen: ct,
      allowPaymentRequest: ct,
      allowUserMedia: ct,
      alt: null,
      as: null,
      async: ct,
      autoCapitalize: null,
      autoComplete: dn,
      autoFocus: ct,
      autoPlay: ct,
      blocking: dn,
      capture: null,
      charSet: null,
      checked: ct,
      cite: null,
      className: dn,
      cols: Oe,
      colSpan: null,
      content: null,
      contentEditable: Vn,
      controls: ct,
      controlsList: dn,
      coords: Oe | cd,
      crossOrigin: null,
      data: null,
      dateTime: null,
      decoding: null,
      default: ct,
      defer: ct,
      dir: null,
      dirName: null,
      disabled: ct,
      download: RE,
      draggable: Vn,
      encType: null,
      enterKeyHint: null,
      fetchPriority: null,
      form: null,
      formAction: null,
      formEncType: null,
      formMethod: null,
      formNoValidate: ct,
      formTarget: null,
      headers: dn,
      height: Oe,
      hidden: RE,
      high: Oe,
      href: null,
      hrefLang: null,
      htmlFor: dn,
      httpEquiv: dn,
      id: null,
      imageSizes: null,
      imageSrcSet: null,
      inert: ct,
      inputMode: null,
      integrity: null,
      is: null,
      isMap: ct,
      itemId: null,
      itemProp: dn,
      itemRef: dn,
      itemScope: ct,
      itemType: dn,
      kind: null,
      label: null,
      lang: null,
      language: null,
      list: null,
      loading: null,
      loop: ct,
      low: Oe,
      manifest: null,
      max: null,
      maxLength: Oe,
      media: null,
      method: null,
      min: null,
      minLength: Oe,
      multiple: ct,
      muted: ct,
      name: null,
      nonce: null,
      noModule: ct,
      noValidate: ct,
      onAbort: null,
      onAfterPrint: null,
      onAuxClick: null,
      onBeforeMatch: null,
      onBeforePrint: null,
      onBeforeToggle: null,
      onBeforeUnload: null,
      onBlur: null,
      onCancel: null,
      onCanPlay: null,
      onCanPlayThrough: null,
      onChange: null,
      onClick: null,
      onClose: null,
      onContextLost: null,
      onContextMenu: null,
      onContextRestored: null,
      onCopy: null,
      onCueChange: null,
      onCut: null,
      onDblClick: null,
      onDrag: null,
      onDragEnd: null,
      onDragEnter: null,
      onDragExit: null,
      onDragLeave: null,
      onDragOver: null,
      onDragStart: null,
      onDrop: null,
      onDurationChange: null,
      onEmptied: null,
      onEnded: null,
      onError: null,
      onFocus: null,
      onFormData: null,
      onHashChange: null,
      onInput: null,
      onInvalid: null,
      onKeyDown: null,
      onKeyPress: null,
      onKeyUp: null,
      onLanguageChange: null,
      onLoad: null,
      onLoadedData: null,
      onLoadedMetadata: null,
      onLoadEnd: null,
      onLoadStart: null,
      onMessage: null,
      onMessageError: null,
      onMouseDown: null,
      onMouseEnter: null,
      onMouseLeave: null,
      onMouseMove: null,
      onMouseOut: null,
      onMouseOver: null,
      onMouseUp: null,
      onOffline: null,
      onOnline: null,
      onPageHide: null,
      onPageShow: null,
      onPaste: null,
      onPause: null,
      onPlay: null,
      onPlaying: null,
      onPopState: null,
      onProgress: null,
      onRateChange: null,
      onRejectionHandled: null,
      onReset: null,
      onResize: null,
      onScroll: null,
      onScrollEnd: null,
      onSecurityPolicyViolation: null,
      onSeeked: null,
      onSeeking: null,
      onSelect: null,
      onSlotChange: null,
      onStalled: null,
      onStorage: null,
      onSubmit: null,
      onSuspend: null,
      onTimeUpdate: null,
      onToggle: null,
      onUnhandledRejection: null,
      onUnload: null,
      onVolumeChange: null,
      onWaiting: null,
      onWheel: null,
      open: ct,
      optimum: Oe,
      pattern: null,
      ping: dn,
      placeholder: null,
      playsInline: ct,
      popover: null,
      popoverTarget: null,
      popoverTargetAction: null,
      poster: null,
      preload: null,
      readOnly: ct,
      referrerPolicy: null,
      rel: dn,
      required: ct,
      reversed: ct,
      rows: Oe,
      rowSpan: Oe,
      sandbox: dn,
      scope: null,
      scoped: ct,
      seamless: ct,
      selected: ct,
      shadowRootClonable: ct,
      shadowRootDelegatesFocus: ct,
      shadowRootMode: null,
      shape: null,
      size: Oe,
      sizes: null,
      slot: null,
      span: Oe,
      spellCheck: Vn,
      src: null,
      srcDoc: null,
      srcLang: null,
      srcSet: null,
      start: Oe,
      step: null,
      style: null,
      tabIndex: Oe,
      target: null,
      title: null,
      translate: null,
      type: null,
      typeMustMatch: ct,
      useMap: null,
      value: Vn,
      width: Oe,
      wrap: null,
      writingSuggestions: null,
      // Legacy.
      // See: https://html.spec.whatwg.org/#other-elements,-attributes-and-apis
      align: null,
      // Several. Use CSS `text-align` instead,
      aLink: null,
      // `<body>`. Use CSS `a:active {color}` instead
      archive: dn,
      // `<object>`. List of URIs to archives
      axis: null,
      // `<td>` and `<th>`. Use `scope` on `<th>`
      background: null,
      // `<body>`. Use CSS `background-image` instead
      bgColor: null,
      // `<body>` and table elements. Use CSS `background-color` instead
      border: Oe,
      // `<table>`. Use CSS `border-width` instead,
      borderColor: null,
      // `<table>`. Use CSS `border-color` instead,
      bottomMargin: Oe,
      // `<body>`
      cellPadding: null,
      // `<table>`
      cellSpacing: null,
      // `<table>`
      char: null,
      // Several table elements. When `align=char`, sets the character to align on
      charOff: null,
      // Several table elements. When `char`, offsets the alignment
      classId: null,
      // `<object>`
      clear: null,
      // `<br>`. Use CSS `clear` instead
      code: null,
      // `<object>`
      codeBase: null,
      // `<object>`
      codeType: null,
      // `<object>`
      color: null,
      // `<font>` and `<hr>`. Use CSS instead
      compact: ct,
      // Lists. Use CSS to reduce space between items instead
      declare: ct,
      // `<object>`
      event: null,
      // `<script>`
      face: null,
      // `<font>`. Use CSS instead
      frame: null,
      // `<table>`
      frameBorder: null,
      // `<iframe>`. Use CSS `border` instead
      hSpace: Oe,
      // `<img>` and `<object>`
      leftMargin: Oe,
      // `<body>`
      link: null,
      // `<body>`. Use CSS `a:link {color: *}` instead
      longDesc: null,
      // `<frame>`, `<iframe>`, and `<img>`. Use an `<a>`
      lowSrc: null,
      // `<img>`. Use a `<picture>`
      marginHeight: Oe,
      // `<body>`
      marginWidth: Oe,
      // `<body>`
      noResize: ct,
      // `<frame>`
      noHref: ct,
      // `<area>`. Use no href instead of an explicit `nohref`
      noShade: ct,
      // `<hr>`. Use background-color and height instead of borders
      noWrap: ct,
      // `<td>` and `<th>`
      object: null,
      // `<applet>`
      profile: null,
      // `<head>`
      prompt: null,
      // `<isindex>`
      rev: null,
      // `<link>`
      rightMargin: Oe,
      // `<body>`
      rules: null,
      // `<table>`
      scheme: null,
      // `<meta>`
      scrolling: Vn,
      // `<frame>`. Use overflow in the child context
      standby: null,
      // `<object>`
      summary: null,
      // `<table>`
      text: null,
      // `<body>`. Use CSS `color` instead
      topMargin: Oe,
      // `<body>`
      valueType: null,
      // `<param>`
      version: null,
      // `<html>`. Use a doctype.
      vAlign: null,
      // Several. Use CSS `vertical-align` instead
      vLink: null,
      // `<body>`. Use CSS `a:visited {color}` instead
      vSpace: Oe,
      // `<img>` and `<object>`
      // Non-standard Properties.
      allowTransparency: null,
      autoCorrect: null,
      autoSave: null,
      disablePictureInPicture: ct,
      disableRemotePlayback: ct,
      prefix: null,
      property: null,
      results: Oe,
      security: null,
      unselectable: null
    },
    space: "html",
    transform: TH
  }), V3e = Kd({
    attributes: {
      accentHeight: "accent-height",
      alignmentBaseline: "alignment-baseline",
      arabicForm: "arabic-form",
      baselineShift: "baseline-shift",
      capHeight: "cap-height",
      className: "class",
      clipPath: "clip-path",
      clipRule: "clip-rule",
      colorInterpolation: "color-interpolation",
      colorInterpolationFilters: "color-interpolation-filters",
      colorProfile: "color-profile",
      colorRendering: "color-rendering",
      crossOrigin: "crossorigin",
      dataType: "datatype",
      dominantBaseline: "dominant-baseline",
      enableBackground: "enable-background",
      fillOpacity: "fill-opacity",
      fillRule: "fill-rule",
      floodColor: "flood-color",
      floodOpacity: "flood-opacity",
      fontFamily: "font-family",
      fontSize: "font-size",
      fontSizeAdjust: "font-size-adjust",
      fontStretch: "font-stretch",
      fontStyle: "font-style",
      fontVariant: "font-variant",
      fontWeight: "font-weight",
      glyphName: "glyph-name",
      glyphOrientationHorizontal: "glyph-orientation-horizontal",
      glyphOrientationVertical: "glyph-orientation-vertical",
      hrefLang: "hreflang",
      horizAdvX: "horiz-adv-x",
      horizOriginX: "horiz-origin-x",
      horizOriginY: "horiz-origin-y",
      imageRendering: "image-rendering",
      letterSpacing: "letter-spacing",
      lightingColor: "lighting-color",
      markerEnd: "marker-end",
      markerMid: "marker-mid",
      markerStart: "marker-start",
      navDown: "nav-down",
      navDownLeft: "nav-down-left",
      navDownRight: "nav-down-right",
      navLeft: "nav-left",
      navNext: "nav-next",
      navPrev: "nav-prev",
      navRight: "nav-right",
      navUp: "nav-up",
      navUpLeft: "nav-up-left",
      navUpRight: "nav-up-right",
      onAbort: "onabort",
      onActivate: "onactivate",
      onAfterPrint: "onafterprint",
      onBeforePrint: "onbeforeprint",
      onBegin: "onbegin",
      onCancel: "oncancel",
      onCanPlay: "oncanplay",
      onCanPlayThrough: "oncanplaythrough",
      onChange: "onchange",
      onClick: "onclick",
      onClose: "onclose",
      onCopy: "oncopy",
      onCueChange: "oncuechange",
      onCut: "oncut",
      onDblClick: "ondblclick",
      onDrag: "ondrag",
      onDragEnd: "ondragend",
      onDragEnter: "ondragenter",
      onDragExit: "ondragexit",
      onDragLeave: "ondragleave",
      onDragOver: "ondragover",
      onDragStart: "ondragstart",
      onDrop: "ondrop",
      onDurationChange: "ondurationchange",
      onEmptied: "onemptied",
      onEnd: "onend",
      onEnded: "onended",
      onError: "onerror",
      onFocus: "onfocus",
      onFocusIn: "onfocusin",
      onFocusOut: "onfocusout",
      onHashChange: "onhashchange",
      onInput: "oninput",
      onInvalid: "oninvalid",
      onKeyDown: "onkeydown",
      onKeyPress: "onkeypress",
      onKeyUp: "onkeyup",
      onLoad: "onload",
      onLoadedData: "onloadeddata",
      onLoadedMetadata: "onloadedmetadata",
      onLoadStart: "onloadstart",
      onMessage: "onmessage",
      onMouseDown: "onmousedown",
      onMouseEnter: "onmouseenter",
      onMouseLeave: "onmouseleave",
      onMouseMove: "onmousemove",
      onMouseOut: "onmouseout",
      onMouseOver: "onmouseover",
      onMouseUp: "onmouseup",
      onMouseWheel: "onmousewheel",
      onOffline: "onoffline",
      onOnline: "ononline",
      onPageHide: "onpagehide",
      onPageShow: "onpageshow",
      onPaste: "onpaste",
      onPause: "onpause",
      onPlay: "onplay",
      onPlaying: "onplaying",
      onPopState: "onpopstate",
      onProgress: "onprogress",
      onRateChange: "onratechange",
      onRepeat: "onrepeat",
      onReset: "onreset",
      onResize: "onresize",
      onScroll: "onscroll",
      onSeeked: "onseeked",
      onSeeking: "onseeking",
      onSelect: "onselect",
      onShow: "onshow",
      onStalled: "onstalled",
      onStorage: "onstorage",
      onSubmit: "onsubmit",
      onSuspend: "onsuspend",
      onTimeUpdate: "ontimeupdate",
      onToggle: "ontoggle",
      onUnload: "onunload",
      onVolumeChange: "onvolumechange",
      onWaiting: "onwaiting",
      onZoom: "onzoom",
      overlinePosition: "overline-position",
      overlineThickness: "overline-thickness",
      paintOrder: "paint-order",
      panose1: "panose-1",
      pointerEvents: "pointer-events",
      referrerPolicy: "referrerpolicy",
      renderingIntent: "rendering-intent",
      shapeRendering: "shape-rendering",
      stopColor: "stop-color",
      stopOpacity: "stop-opacity",
      strikethroughPosition: "strikethrough-position",
      strikethroughThickness: "strikethrough-thickness",
      strokeDashArray: "stroke-dasharray",
      strokeDashOffset: "stroke-dashoffset",
      strokeLineCap: "stroke-linecap",
      strokeLineJoin: "stroke-linejoin",
      strokeMiterLimit: "stroke-miterlimit",
      strokeOpacity: "stroke-opacity",
      strokeWidth: "stroke-width",
      tabIndex: "tabindex",
      textAnchor: "text-anchor",
      textDecoration: "text-decoration",
      textRendering: "text-rendering",
      transformOrigin: "transform-origin",
      typeOf: "typeof",
      underlinePosition: "underline-position",
      underlineThickness: "underline-thickness",
      unicodeBidi: "unicode-bidi",
      unicodeRange: "unicode-range",
      unitsPerEm: "units-per-em",
      vAlphabetic: "v-alphabetic",
      vHanging: "v-hanging",
      vIdeographic: "v-ideographic",
      vMathematical: "v-mathematical",
      vectorEffect: "vector-effect",
      vertAdvY: "vert-adv-y",
      vertOriginX: "vert-origin-x",
      vertOriginY: "vert-origin-y",
      wordSpacing: "word-spacing",
      writingMode: "writing-mode",
      xHeight: "x-height",
      // These were camelcased in Tiny. Now lowercased in SVG 2
      playbackOrder: "playbackorder",
      timelineBegin: "timelinebegin"
    },
    properties: {
      about: ro,
      accentHeight: Oe,
      accumulate: null,
      additive: null,
      alignmentBaseline: null,
      alphabetic: Oe,
      amplitude: Oe,
      arabicForm: null,
      ascent: Oe,
      attributeName: null,
      attributeType: null,
      azimuth: Oe,
      bandwidth: null,
      baselineShift: null,
      baseFrequency: null,
      baseProfile: null,
      bbox: null,
      begin: null,
      bias: Oe,
      by: null,
      calcMode: null,
      capHeight: Oe,
      className: dn,
      clip: null,
      clipPath: null,
      clipPathUnits: null,
      clipRule: null,
      color: null,
      colorInterpolation: null,
      colorInterpolationFilters: null,
      colorProfile: null,
      colorRendering: null,
      content: null,
      contentScriptType: null,
      contentStyleType: null,
      crossOrigin: null,
      cursor: null,
      cx: null,
      cy: null,
      d: null,
      dataType: null,
      defaultAction: null,
      descent: Oe,
      diffuseConstant: Oe,
      direction: null,
      display: null,
      dur: null,
      divisor: Oe,
      dominantBaseline: null,
      download: ct,
      dx: null,
      dy: null,
      edgeMode: null,
      editable: null,
      elevation: Oe,
      enableBackground: null,
      end: null,
      event: null,
      exponent: Oe,
      externalResourcesRequired: null,
      fill: null,
      fillOpacity: Oe,
      fillRule: null,
      filter: null,
      filterRes: null,
      filterUnits: null,
      floodColor: null,
      floodOpacity: null,
      focusable: null,
      focusHighlight: null,
      fontFamily: null,
      fontSize: null,
      fontSizeAdjust: null,
      fontStretch: null,
      fontStyle: null,
      fontVariant: null,
      fontWeight: null,
      format: null,
      fr: null,
      from: null,
      fx: null,
      fy: null,
      g1: cd,
      g2: cd,
      glyphName: cd,
      glyphOrientationHorizontal: null,
      glyphOrientationVertical: null,
      glyphRef: null,
      gradientTransform: null,
      gradientUnits: null,
      handler: null,
      hanging: Oe,
      hatchContentUnits: null,
      hatchUnits: null,
      height: null,
      href: null,
      hrefLang: null,
      horizAdvX: Oe,
      horizOriginX: Oe,
      horizOriginY: Oe,
      id: null,
      ideographic: Oe,
      imageRendering: null,
      initialVisibility: null,
      in: null,
      in2: null,
      intercept: Oe,
      k: Oe,
      k1: Oe,
      k2: Oe,
      k3: Oe,
      k4: Oe,
      kernelMatrix: ro,
      kernelUnitLength: null,
      keyPoints: null,
      // SEMI_COLON_SEPARATED
      keySplines: null,
      // SEMI_COLON_SEPARATED
      keyTimes: null,
      // SEMI_COLON_SEPARATED
      kerning: null,
      lang: null,
      lengthAdjust: null,
      letterSpacing: null,
      lightingColor: null,
      limitingConeAngle: Oe,
      local: null,
      markerEnd: null,
      markerMid: null,
      markerStart: null,
      markerHeight: null,
      markerUnits: null,
      markerWidth: null,
      mask: null,
      maskContentUnits: null,
      maskUnits: null,
      mathematical: null,
      max: null,
      media: null,
      mediaCharacterEncoding: null,
      mediaContentEncodings: null,
      mediaSize: Oe,
      mediaTime: null,
      method: null,
      min: null,
      mode: null,
      name: null,
      navDown: null,
      navDownLeft: null,
      navDownRight: null,
      navLeft: null,
      navNext: null,
      navPrev: null,
      navRight: null,
      navUp: null,
      navUpLeft: null,
      navUpRight: null,
      numOctaves: null,
      observer: null,
      offset: null,
      onAbort: null,
      onActivate: null,
      onAfterPrint: null,
      onBeforePrint: null,
      onBegin: null,
      onCancel: null,
      onCanPlay: null,
      onCanPlayThrough: null,
      onChange: null,
      onClick: null,
      onClose: null,
      onCopy: null,
      onCueChange: null,
      onCut: null,
      onDblClick: null,
      onDrag: null,
      onDragEnd: null,
      onDragEnter: null,
      onDragExit: null,
      onDragLeave: null,
      onDragOver: null,
      onDragStart: null,
      onDrop: null,
      onDurationChange: null,
      onEmptied: null,
      onEnd: null,
      onEnded: null,
      onError: null,
      onFocus: null,
      onFocusIn: null,
      onFocusOut: null,
      onHashChange: null,
      onInput: null,
      onInvalid: null,
      onKeyDown: null,
      onKeyPress: null,
      onKeyUp: null,
      onLoad: null,
      onLoadedData: null,
      onLoadedMetadata: null,
      onLoadStart: null,
      onMessage: null,
      onMouseDown: null,
      onMouseEnter: null,
      onMouseLeave: null,
      onMouseMove: null,
      onMouseOut: null,
      onMouseOver: null,
      onMouseUp: null,
      onMouseWheel: null,
      onOffline: null,
      onOnline: null,
      onPageHide: null,
      onPageShow: null,
      onPaste: null,
      onPause: null,
      onPlay: null,
      onPlaying: null,
      onPopState: null,
      onProgress: null,
      onRateChange: null,
      onRepeat: null,
      onReset: null,
      onResize: null,
      onScroll: null,
      onSeeked: null,
      onSeeking: null,
      onSelect: null,
      onShow: null,
      onStalled: null,
      onStorage: null,
      onSubmit: null,
      onSuspend: null,
      onTimeUpdate: null,
      onToggle: null,
      onUnload: null,
      onVolumeChange: null,
      onWaiting: null,
      onZoom: null,
      opacity: null,
      operator: null,
      order: null,
      orient: null,
      orientation: null,
      origin: null,
      overflow: null,
      overlay: null,
      overlinePosition: Oe,
      overlineThickness: Oe,
      paintOrder: null,
      panose1: null,
      path: null,
      pathLength: Oe,
      patternContentUnits: null,
      patternTransform: null,
      patternUnits: null,
      phase: null,
      ping: dn,
      pitch: null,
      playbackOrder: null,
      pointerEvents: null,
      points: null,
      pointsAtX: Oe,
      pointsAtY: Oe,
      pointsAtZ: Oe,
      preserveAlpha: null,
      preserveAspectRatio: null,
      primitiveUnits: null,
      propagate: null,
      property: ro,
      r: null,
      radius: null,
      referrerPolicy: null,
      refX: null,
      refY: null,
      rel: ro,
      rev: ro,
      renderingIntent: null,
      repeatCount: null,
      repeatDur: null,
      requiredExtensions: ro,
      requiredFeatures: ro,
      requiredFonts: ro,
      requiredFormats: ro,
      resource: null,
      restart: null,
      result: null,
      rotate: null,
      rx: null,
      ry: null,
      scale: null,
      seed: null,
      shapeRendering: null,
      side: null,
      slope: null,
      snapshotTime: null,
      specularConstant: Oe,
      specularExponent: Oe,
      spreadMethod: null,
      spacing: null,
      startOffset: null,
      stdDeviation: null,
      stemh: null,
      stemv: null,
      stitchTiles: null,
      stopColor: null,
      stopOpacity: null,
      strikethroughPosition: Oe,
      strikethroughThickness: Oe,
      string: null,
      stroke: null,
      strokeDashArray: ro,
      strokeDashOffset: null,
      strokeLineCap: null,
      strokeLineJoin: null,
      strokeMiterLimit: Oe,
      strokeOpacity: Oe,
      strokeWidth: null,
      style: null,
      surfaceScale: Oe,
      syncBehavior: null,
      syncBehaviorDefault: null,
      syncMaster: null,
      syncTolerance: null,
      syncToleranceDefault: null,
      systemLanguage: ro,
      tabIndex: Oe,
      tableValues: null,
      target: null,
      targetX: Oe,
      targetY: Oe,
      textAnchor: null,
      textDecoration: null,
      textRendering: null,
      textLength: null,
      timelineBegin: null,
      title: null,
      transformBehavior: null,
      type: null,
      typeOf: ro,
      to: null,
      transform: null,
      transformOrigin: null,
      u1: null,
      u2: null,
      underlinePosition: Oe,
      underlineThickness: Oe,
      unicode: null,
      unicodeBidi: null,
      unicodeRange: null,
      unitsPerEm: Oe,
      values: null,
      vAlphabetic: Oe,
      vMathematical: Oe,
      vectorEffect: null,
      vHanging: Oe,
      vIdeographic: Oe,
      version: null,
      vertAdvY: Oe,
      vertOriginX: Oe,
      vertOriginY: Oe,
      viewBox: null,
      viewTarget: null,
      visibility: null,
      width: null,
      widths: null,
      wordSpacing: null,
      writingMode: null,
      x: null,
      x1: null,
      x2: null,
      xChannelSelector: null,
      xHeight: Oe,
      y: null,
      y1: null,
      y2: null,
      yChannelSelector: null,
      z: null,
      zoomAndPan: null
    },
    space: "svg",
    transform: FH
  }), zH = Kd({
    properties: {
      xLinkActuate: null,
      xLinkArcRole: null,
      xLinkHref: null,
      xLinkRole: null,
      xLinkShow: null,
      xLinkTitle: null,
      xLinkType: null
    },
    space: "xlink",
    transform(e, t) {
      return "xlink:" + t.slice(5).toLowerCase();
    }
  }), BH = Kd({
    attributes: { xmlnsxlink: "xmlns:xlink" },
    properties: { xmlnsXLink: null, xmlns: null },
    space: "xmlns",
    transform: TH
  }), VH = Kd({
    properties: { xmlBase: null, xmlLang: null, xmlSpace: null },
    space: "xml",
    transform(e, t) {
      return "xml:" + t.slice(3).toLowerCase();
    }
  }), U3e = {
    classId: "classID",
    dataType: "datatype",
    itemId: "itemID",
    strokeDashArray: "strokeDasharray",
    strokeDashOffset: "strokeDashoffset",
    strokeLineCap: "strokeLinecap",
    strokeLineJoin: "strokeLinejoin",
    strokeMiterLimit: "strokeMiterlimit",
    typeOf: "typeof",
    xLinkActuate: "xlinkActuate",
    xLinkArcRole: "xlinkArcrole",
    xLinkHref: "xlinkHref",
    xLinkRole: "xlinkRole",
    xLinkShow: "xlinkShow",
    xLinkTitle: "xlinkTitle",
    xLinkType: "xlinkType",
    xmlnsXLink: "xmlnsXlink"
  }, H3e = /[A-Z]/g, aF = /-[a-z]/g, W3e = /^data[-\w.:]+$/i;
  function q3e(e, t) {
    const n = ME(t);
    let r = t, o = qr;
    if (n in e.normal)
      return e.property[e.normal[n]];
    if (n.length > 4 && n.slice(0, 4) === "data" && W3e.test(t)) {
      if (t.charAt(4) === "-") {
        const a = t.slice(5).replace(aF, G3e);
        r = "data" + a.charAt(0).toUpperCase() + a.slice(1);
      } else {
        const a = t.slice(4);
        if (!aF.test(a)) {
          let i = a.replace(H3e, K3e);
          i.charAt(0) !== "-" && (i = "-" + i), t = "data" + i;
        }
      }
      o = eN;
    }
    return new o(r, t);
  }
  function K3e(e) {
    return "-" + e.toLowerCase();
  }
  function G3e(e) {
    return e.charAt(1).toUpperCase();
  }
  const X3e = DH([LH, B3e, zH, BH, VH], "html"), tN = DH([LH, V3e, zH, BH, VH], "svg");
  function Y3e(e) {
    return e.join(" ").trim();
  }
  var Lc = {}, D0, iF;
  function J3e() {
    if (iF) return D0;
    iF = 1;
    var e = /\/\*[^*]*\*+([^/*][^*]*\*+)*\//g, t = /\n/g, n = /^\s*/, r = /^(\*?[-#/*\\\w]+(\[[0-9a-z_-]+\])?)\s*/, o = /^:\s*/, a = /^((?:'(?:\\'|.)*?'|"(?:\\"|.)*?"|\([^)]*?\)|[^};])+)/, i = /^[;\s]*/, s = /^\s+|\s+$/g, u = `
`, c = "/", f = "*", p = "", g = "comment", h = "declaration";
    D0 = function(b, v) {
      if (typeof b != "string")
        throw new TypeError("First argument must be a string");
      if (!b) return [];
      v = v || {};
      var w = 1, _ = 1;
      function k(U) {
        var $ = U.match(t);
        $ && (w += $.length);
        var q = U.lastIndexOf(u);
        _ = ~q ? U.length - q : _ + U.length;
      }
      function E() {
        var U = { line: w, column: _ };
        return function($) {
          return $.position = new P(U), I(), $;
        };
      }
      function P(U) {
        this.start = U, this.end = { line: w, column: _ }, this.source = v.source;
      }
      P.prototype.content = b;
      function O(U) {
        var $ = new Error(
          v.source + ":" + w + ":" + _ + ": " + U
        );
        if ($.reason = U, $.filename = v.source, $.line = w, $.column = _, $.source = b, !v.silent) throw $;
      }
      function M(U) {
        var $ = U.exec(b);
        if ($) {
          var q = $[0];
          return k(q), b = b.slice(q.length), $;
        }
      }
      function I() {
        M(n);
      }
      function A(U) {
        var $;
        for (U = U || []; $ = D(); )
          $ !== !1 && U.push($);
        return U;
      }
      function D() {
        var U = E();
        if (!(c != b.charAt(0) || f != b.charAt(1))) {
          for (var $ = 2; p != b.charAt($) && (f != b.charAt($) || c != b.charAt($ + 1)); )
            ++$;
          if ($ += 2, p === b.charAt($ - 1))
            return O("End of comment missing");
          var q = b.slice(2, $ - 2);
          return _ += 2, k(q), b = b.slice($), _ += 2, U({
            type: g,
            comment: q
          });
        }
      }
      function F() {
        var U = E(), $ = M(r);
        if ($) {
          if (D(), !M(o)) return O("property missing ':'");
          var q = M(a), B = U({
            type: h,
            property: y($[0].replace(e, p)),
            value: q ? y(q[0].replace(e, p)) : p
          });
          return M(i), B;
        }
      }
      function j() {
        var U = [];
        A(U);
        for (var $; $ = F(); )
          $ !== !1 && (U.push($), A(U));
        return U;
      }
      return I(), j();
    };
    function y(b) {
      return b ? b.replace(s, p) : p;
    }
    return D0;
  }
  var sF;
  function Q3e() {
    if (sF) return Lc;
    sF = 1;
    var e = Lc && Lc.__importDefault || function(r) {
      return r && r.__esModule ? r : { default: r };
    };
    Object.defineProperty(Lc, "__esModule", { value: !0 }), Lc.default = n;
    var t = e(J3e());
    function n(r, o) {
      var a = null;
      if (!r || typeof r != "string")
        return a;
      var i = (0, t.default)(r), s = typeof o == "function";
      return i.forEach(function(u) {
        if (u.type === "declaration") {
          var c = u.property, f = u.value;
          s ? o(c, f, u) : f && (a = a || {}, a[c] = f);
        }
      }), a;
    }
    return Lc;
  }
  var up = {}, lF;
  function Z3e() {
    if (lF) return up;
    lF = 1, Object.defineProperty(up, "__esModule", { value: !0 }), up.camelCase = void 0;
    var e = /^--[a-zA-Z0-9_-]+$/, t = /-([a-z])/g, n = /^[^-]+$/, r = /^-(webkit|moz|ms|o|khtml)-/, o = /^-(ms)-/, a = function(c) {
      return !c || n.test(c) || e.test(c);
    }, i = function(c, f) {
      return f.toUpperCase();
    }, s = function(c, f) {
      return "".concat(f, "-");
    }, u = function(c, f) {
      return f === void 0 && (f = {}), a(c) ? c : (c = c.toLowerCase(), f.reactCompat ? c = c.replace(o, s) : c = c.replace(r, s), c.replace(t, i));
    };
    return up.camelCase = u, up;
  }
  var cp, uF;
  function e4e() {
    if (uF) return cp;
    uF = 1;
    var e = cp && cp.__importDefault || function(o) {
      return o && o.__esModule ? o : { default: o };
    }, t = e(Q3e()), n = Z3e();
    function r(o, a) {
      var i = {};
      return !o || typeof o != "string" || (0, t.default)(o, function(s, u) {
        s && u && (i[(0, n.camelCase)(s, a)] = u);
      }), i;
    }
    return r.default = r, cp = r, cp;
  }
  var t4e = e4e();
  const n4e = /* @__PURE__ */ Qi(t4e), UH = HH("end"), nN = HH("start");
  function HH(e) {
    return t;
    function t(n) {
      const r = n && n.position && n.position[e] || {};
      if (typeof r.line == "number" && r.line > 0 && typeof r.column == "number" && r.column > 0)
        return {
          line: r.line,
          column: r.column,
          offset: typeof r.offset == "number" && r.offset > -1 ? r.offset : void 0
        };
    }
  }
  function r4e(e) {
    const t = nN(e), n = UH(e);
    if (t && n)
      return { start: t, end: n };
  }
  function Hp(e) {
    return !e || typeof e != "object" ? "" : "position" in e || "type" in e ? cF(e.position) : "start" in e || "end" in e ? cF(e) : "line" in e || "column" in e ? IE(e) : "";
  }
  function IE(e) {
    return dF(e && e.line) + ":" + dF(e && e.column);
  }
  function cF(e) {
    return IE(e && e.start) + "-" + IE(e && e.end);
  }
  function dF(e) {
    return e && typeof e == "number" ? e : 1;
  }
  class Sr extends Error {
    /**
     * Create a message for `reason`.
     *
     * >  **Note**: also has obsolete signatures.
     *
     * @overload
     * @param {string} reason
     * @param {Options | null | undefined} [options]
     * @returns
     *
     * @overload
     * @param {string} reason
     * @param {Node | NodeLike | null | undefined} parent
     * @param {string | null | undefined} [origin]
     * @returns
     *
     * @overload
     * @param {string} reason
     * @param {Point | Position | null | undefined} place
     * @param {string | null | undefined} [origin]
     * @returns
     *
     * @overload
     * @param {string} reason
     * @param {string | null | undefined} [origin]
     * @returns
     *
     * @overload
     * @param {Error | VFileMessage} cause
     * @param {Node | NodeLike | null | undefined} parent
     * @param {string | null | undefined} [origin]
     * @returns
     *
     * @overload
     * @param {Error | VFileMessage} cause
     * @param {Point | Position | null | undefined} place
     * @param {string | null | undefined} [origin]
     * @returns
     *
     * @overload
     * @param {Error | VFileMessage} cause
     * @param {string | null | undefined} [origin]
     * @returns
     *
     * @param {Error | VFileMessage | string} causeOrReason
     *   Reason for message, should use markdown.
     * @param {Node | NodeLike | Options | Point | Position | string | null | undefined} [optionsOrParentOrPlace]
     *   Configuration (optional).
     * @param {string | null | undefined} [origin]
     *   Place in code where the message originates (example:
     *   `'my-package:my-rule'` or `'my-rule'`).
     * @returns
     *   Instance of `VFileMessage`.
     */
    // eslint-disable-next-line complexity
    constructor(t, n, r) {
      super(), typeof n == "string" && (r = n, n = void 0);
      let o = "", a = {}, i = !1;
      if (n && ("line" in n && "column" in n ? a = { place: n } : "start" in n && "end" in n ? a = { place: n } : "type" in n ? a = {
        ancestors: [n],
        place: n.position
      } : a = { ...n }), typeof t == "string" ? o = t : !a.cause && t && (i = !0, o = t.message, a.cause = t), !a.ruleId && !a.source && typeof r == "string") {
        const u = r.indexOf(":");
        u === -1 ? a.ruleId = r : (a.source = r.slice(0, u), a.ruleId = r.slice(u + 1));
      }
      if (!a.place && a.ancestors && a.ancestors) {
        const u = a.ancestors[a.ancestors.length - 1];
        u && (a.place = u.position);
      }
      const s = a.place && "start" in a.place ? a.place.start : a.place;
      this.ancestors = a.ancestors || void 0, this.cause = a.cause || void 0, this.column = s ? s.column : void 0, this.fatal = void 0, this.file, this.message = o, this.line = s ? s.line : void 0, this.name = Hp(a.place) || "1:1", this.place = a.place || void 0, this.reason = this.message, this.ruleId = a.ruleId || void 0, this.source = a.source || void 0, this.stack = i && a.cause && typeof a.cause.stack == "string" ? a.cause.stack : "", this.actual, this.expected, this.note, this.url;
    }
  }
  Sr.prototype.file = "";
  Sr.prototype.name = "";
  Sr.prototype.reason = "";
  Sr.prototype.message = "";
  Sr.prototype.stack = "";
  Sr.prototype.column = void 0;
  Sr.prototype.line = void 0;
  Sr.prototype.ancestors = void 0;
  Sr.prototype.cause = void 0;
  Sr.prototype.fatal = void 0;
  Sr.prototype.place = void 0;
  Sr.prototype.ruleId = void 0;
  Sr.prototype.source = void 0;
  const rN = {}.hasOwnProperty, o4e = /* @__PURE__ */ new Map(), a4e = /[A-Z]/g, i4e = /* @__PURE__ */ new Set(["table", "tbody", "thead", "tfoot", "tr"]), s4e = /* @__PURE__ */ new Set(["td", "th"]), WH = "https://github.com/syntax-tree/hast-util-to-jsx-runtime";
  function l4e(e, t) {
    if (!t || t.Fragment === void 0)
      throw new TypeError("Expected `Fragment` in options");
    const n = t.filePath || void 0;
    let r;
    if (t.development) {
      if (typeof t.jsxDEV != "function")
        throw new TypeError(
          "Expected `jsxDEV` in options when `development: true`"
        );
      r = g4e(n, t.jsxDEV);
    } else {
      if (typeof t.jsx != "function")
        throw new TypeError("Expected `jsx` in production options");
      if (typeof t.jsxs != "function")
        throw new TypeError("Expected `jsxs` in production options");
      r = h4e(n, t.jsx, t.jsxs);
    }
    const o = {
      Fragment: t.Fragment,
      ancestors: [],
      components: t.components || {},
      create: r,
      elementAttributeNameCase: t.elementAttributeNameCase || "react",
      evaluater: t.createEvaluater ? t.createEvaluater() : void 0,
      filePath: n,
      ignoreInvalidStyle: t.ignoreInvalidStyle || !1,
      passKeys: t.passKeys !== !1,
      passNode: t.passNode || !1,
      schema: t.space === "svg" ? tN : X3e,
      stylePropertyNameCase: t.stylePropertyNameCase || "dom",
      tableCellAlignToStyle: t.tableCellAlignToStyle !== !1
    }, a = qH(o, e, void 0);
    return a && typeof a != "string" ? a : o.create(
      e,
      o.Fragment,
      { children: a || void 0 },
      void 0
    );
  }
  function qH(e, t, n) {
    if (t.type === "element")
      return u4e(e, t, n);
    if (t.type === "mdxFlowExpression" || t.type === "mdxTextExpression")
      return c4e(e, t);
    if (t.type === "mdxJsxFlowElement" || t.type === "mdxJsxTextElement")
      return f4e(e, t, n);
    if (t.type === "mdxjsEsm")
      return d4e(e, t);
    if (t.type === "root")
      return p4e(e, t, n);
    if (t.type === "text")
      return m4e(e, t);
  }
  function u4e(e, t, n) {
    const r = e.schema;
    let o = r;
    t.tagName.toLowerCase() === "svg" && r.space === "html" && (o = tN, e.schema = o), e.ancestors.push(t);
    const a = GH(e, t.tagName, !1), i = v4e(e, t);
    let s = aN(e, t);
    return i4e.has(t.tagName) && (s = s.filter(function(u) {
      return typeof u == "string" ? !T3e(u) : !0;
    })), KH(e, i, a, t), oN(i, s), e.ancestors.pop(), e.schema = r, e.create(t, a, i, n);
  }
  function c4e(e, t) {
    if (t.data && t.data.estree && e.evaluater) {
      const n = t.data.estree.body[0];
      return n.type, /** @type {Child | undefined} */
      e.evaluater.evaluateExpression(n.expression);
    }
    Nm(e, t.position);
  }
  function d4e(e, t) {
    if (t.data && t.data.estree && e.evaluater)
      return (
        /** @type {Child | undefined} */
        e.evaluater.evaluateProgram(t.data.estree)
      );
    Nm(e, t.position);
  }
  function f4e(e, t, n) {
    const r = e.schema;
    let o = r;
    t.name === "svg" && r.space === "html" && (o = tN, e.schema = o), e.ancestors.push(t);
    const a = t.name === null ? e.Fragment : GH(e, t.name, !0), i = y4e(e, t), s = aN(e, t);
    return KH(e, i, a, t), oN(i, s), e.ancestors.pop(), e.schema = r, e.create(t, a, i, n);
  }
  function p4e(e, t, n) {
    const r = {};
    return oN(r, aN(e, t)), e.create(t, e.Fragment, r, n);
  }
  function m4e(e, t) {
    return t.value;
  }
  function KH(e, t, n, r) {
    typeof n != "string" && n !== e.Fragment && e.passNode && (t.node = r);
  }
  function oN(e, t) {
    if (t.length > 0) {
      const n = t.length > 1 ? t : t[0];
      n && (e.children = n);
    }
  }
  function h4e(e, t, n) {
    return r;
    function r(o, a, i, s) {
      const u = Array.isArray(i.children) ? n : t;
      return s ? u(a, i, s) : u(a, i);
    }
  }
  function g4e(e, t) {
    return n;
    function n(r, o, a, i) {
      const s = Array.isArray(a.children), u = nN(r);
      return t(
        o,
        a,
        i,
        s,
        {
          columnNumber: u ? u.column - 1 : void 0,
          fileName: e,
          lineNumber: u ? u.line : void 0
        },
        void 0
      );
    }
  }
  function v4e(e, t) {
    const n = {};
    let r, o;
    for (o in t.properties)
      if (o !== "children" && rN.call(t.properties, o)) {
        const a = b4e(e, o, t.properties[o]);
        if (a) {
          const [i, s] = a;
          e.tableCellAlignToStyle && i === "align" && typeof s == "string" && s4e.has(t.tagName) ? r = s : n[i] = s;
        }
      }
    if (r) {
      const a = (
        /** @type {Style} */
        n.style || (n.style = {})
      );
      a[e.stylePropertyNameCase === "css" ? "text-align" : "textAlign"] = r;
    }
    return n;
  }
  function y4e(e, t) {
    const n = {};
    for (const r of t.attributes)
      if (r.type === "mdxJsxExpressionAttribute")
        if (r.data && r.data.estree && e.evaluater) {
          const o = r.data.estree.body[0];
          o.type;
          const a = o.expression;
          a.type;
          const i = a.properties[0];
          i.type, Object.assign(
            n,
            e.evaluater.evaluateExpression(i.argument)
          );
        } else
          Nm(e, t.position);
      else {
        const o = r.name;
        let a;
        if (r.value && typeof r.value == "object")
          if (r.value.data && r.value.data.estree && e.evaluater) {
            const i = r.value.data.estree.body[0];
            i.type, a = e.evaluater.evaluateExpression(i.expression);
          } else
            Nm(e, t.position);
        else
          a = r.value === null ? !0 : r.value;
        n[o] = /** @type {Props[keyof Props]} */
        a;
      }
    return n;
  }
  function aN(e, t) {
    const n = [];
    let r = -1;
    const o = e.passKeys ? /* @__PURE__ */ new Map() : o4e;
    for (; ++r < t.children.length; ) {
      const a = t.children[r];
      let i;
      if (e.passKeys) {
        const u = a.type === "element" ? a.tagName : a.type === "mdxJsxFlowElement" || a.type === "mdxJsxTextElement" ? a.name : void 0;
        if (u) {
          const c = o.get(u) || 0;
          i = u + "-" + c, o.set(u, c + 1);
        }
      }
      const s = qH(e, a, i);
      s !== void 0 && n.push(s);
    }
    return n;
  }
  function b4e(e, t, n) {
    const r = q3e(e.schema, t);
    if (!(n == null || typeof n == "number" && Number.isNaN(n))) {
      if (Array.isArray(n) && (n = r.commaSeparated ? A3e(n) : Y3e(n)), r.property === "style") {
        let o = typeof n == "object" ? n : w4e(e, String(n));
        return e.stylePropertyNameCase === "css" && (o = x4e(o)), ["style", o];
      }
      return [
        e.elementAttributeNameCase === "react" && r.space ? U3e[r.property] || r.property : r.attribute,
        n
      ];
    }
  }
  function w4e(e, t) {
    try {
      return n4e(t, { reactCompat: !0 });
    } catch (n) {
      if (e.ignoreInvalidStyle)
        return {};
      const r = (
        /** @type {Error} */
        n
      ), o = new Sr("Cannot parse `style` attribute", {
        ancestors: e.ancestors,
        cause: r,
        ruleId: "style",
        source: "hast-util-to-jsx-runtime"
      });
      throw o.file = e.filePath || void 0, o.url = WH + "#cannot-parse-style-attribute", o;
    }
  }
  function GH(e, t, n) {
    let r;
    if (!n)
      r = { type: "Literal", value: t };
    else if (t.includes(".")) {
      const o = t.split(".");
      let a = -1, i;
      for (; ++a < o.length; ) {
        const s = nF(o[a]) ? { type: "Identifier", name: o[a] } : { type: "Literal", value: o[a] };
        i = i ? {
          type: "MemberExpression",
          object: i,
          property: s,
          computed: !!(a && s.type === "Literal"),
          optional: !1
        } : s;
      }
      r = i;
    } else
      r = nF(t) && !/^[a-z]/.test(t) ? { type: "Identifier", name: t } : { type: "Literal", value: t };
    if (r.type === "Literal") {
      const o = (
        /** @type {string | number} */
        r.value
      );
      return rN.call(e.components, o) ? e.components[o] : o;
    }
    if (e.evaluater)
      return e.evaluater.evaluateExpression(r);
    Nm(e);
  }
  function Nm(e, t) {
    const n = new Sr(
      "Cannot handle MDX estrees without `createEvaluater`",
      {
        ancestors: e.ancestors,
        place: t,
        ruleId: "mdx-estree",
        source: "hast-util-to-jsx-runtime"
      }
    );
    throw n.file = e.filePath || void 0, n.url = WH + "#cannot-handle-mdx-estrees-without-createevaluater", n;
  }
  function x4e(e) {
    const t = {};
    let n;
    for (n in e)
      rN.call(e, n) && (t[k4e(n)] = e[n]);
    return t;
  }
  function k4e(e) {
    let t = e.replace(a4e, S4e);
    return t.slice(0, 3) === "ms-" && (t = "-" + t), t;
  }
  function S4e(e) {
    return "-" + e.toLowerCase();
  }
  const L0 = {
    action: ["form"],
    cite: ["blockquote", "del", "ins", "q"],
    data: ["object"],
    formAction: ["button", "input"],
    href: ["a", "area", "base", "link"],
    icon: ["menuitem"],
    itemId: null,
    manifest: ["html"],
    ping: ["a", "area"],
    poster: ["video"],
    src: [
      "audio",
      "embed",
      "iframe",
      "img",
      "input",
      "script",
      "source",
      "track",
      "video"
    ]
  }, _4e = {};
  function iN(e, t) {
    const n = _4e, r = typeof n.includeImageAlt == "boolean" ? n.includeImageAlt : !0, o = typeof n.includeHtml == "boolean" ? n.includeHtml : !0;
    return XH(e, r, o);
  }
  function XH(e, t, n) {
    if (E4e(e)) {
      if ("value" in e)
        return e.type === "html" && !n ? "" : e.value;
      if (t && "alt" in e && e.alt)
        return e.alt;
      if ("children" in e)
        return fF(e.children, t, n);
    }
    return Array.isArray(e) ? fF(e, t, n) : "";
  }
  function fF(e, t, n) {
    const r = [];
    let o = -1;
    for (; ++o < e.length; )
      r[o] = XH(e[o], t, n);
    return r.join("");
  }
  function E4e(e) {
    return !!(e && typeof e == "object");
  }
  const pF = document.createElement("i");
  function sN(e) {
    const t = "&" + e + ";";
    pF.innerHTML = t;
    const n = pF.textContent;
    return (
      // @ts-expect-error: TypeScript is wrong that `textContent` on elements can
      // yield `null`.
      n.charCodeAt(n.length - 1) === 59 && e !== "semi" || n === t ? !1 : n
    );
  }
  function fo(e, t, n, r) {
    const o = e.length;
    let a = 0, i;
    if (t < 0 ? t = -t > o ? 0 : o + t : t = t > o ? o : t, n = n > 0 ? n : 0, r.length < 1e4)
      i = Array.from(r), i.unshift(t, n), e.splice(...i);
    else
      for (n && e.splice(t, n); a < r.length; )
        i = r.slice(a, a + 1e4), i.unshift(t, 0), e.splice(...i), a += 1e4, t += 1e4;
  }
  function No(e, t) {
    return e.length > 0 ? (fo(e, e.length, 0, t), e) : t;
  }
  const mF = {}.hasOwnProperty;
  function YH(e) {
    const t = {};
    let n = -1;
    for (; ++n < e.length; )
      C4e(t, e[n]);
    return t;
  }
  function C4e(e, t) {
    let n;
    for (n in t) {
      const r = (mF.call(e, n) ? e[n] : void 0) || (e[n] = {}), o = t[n];
      let a;
      if (o)
        for (a in o) {
          mF.call(r, a) || (r[a] = []);
          const i = o[a];
          P4e(
            // @ts-expect-error Looks like a list.
            r[a],
            Array.isArray(i) ? i : i ? [i] : []
          );
        }
    }
  }
  function P4e(e, t) {
    let n = -1;
    const r = [];
    for (; ++n < t.length; )
      (t[n].add === "after" ? e : r).push(t[n]);
    fo(e, 0, 0, r);
  }
  function JH(e, t) {
    const n = Number.parseInt(e, t);
    return (
      // C0 except for HT, LF, FF, CR, space.
      n < 9 || n === 11 || n > 13 && n < 32 || // Control character (DEL) of C0, and C1 controls.
      n > 126 && n < 160 || // Lone high surrogates and low surrogates.
      n > 55295 && n < 57344 || // Noncharacters.
      n > 64975 && n < 65008 || /* eslint-disable no-bitwise */
      (n & 65535) === 65535 || (n & 65535) === 65534 || /* eslint-enable no-bitwise */
      // Out of range
      n > 1114111 ? "" : String.fromCodePoint(n)
    );
  }
  function ea(e) {
    return e.replace(/[\t\n\r ]+/g, " ").replace(/^ | $/g, "").toLowerCase().toUpperCase();
  }
  const Pr = yl(/[A-Za-z]/), br = yl(/[\dA-Za-z]/), O4e = yl(/[#-'*+\--9=?A-Z^-~]/);
  function qb(e) {
    return (
      // Special whitespace codes (which have negative values), C0 and Control
      // character DEL
      e !== null && (e < 32 || e === 127)
    );
  }
  const AE = yl(/\d/), N4e = yl(/[\dA-Fa-f]/), M4e = yl(/[!-/:-@[-`{-~]/);
  function Je(e) {
    return e !== null && e < -2;
  }
  function ln(e) {
    return e !== null && (e < 0 || e === 32);
  }
  function kt(e) {
    return e === -2 || e === -1 || e === 32;
  }
  const Dx = yl(new RegExp("\\p{P}|\\p{S}", "u")), wu = yl(/\s/);
  function yl(e) {
    return t;
    function t(n) {
      return n !== null && n > -1 && e.test(String.fromCharCode(n));
    }
  }
  function Gd(e) {
    const t = [];
    let n = -1, r = 0, o = 0;
    for (; ++n < e.length; ) {
      const a = e.charCodeAt(n);
      let i = "";
      if (a === 37 && br(e.charCodeAt(n + 1)) && br(e.charCodeAt(n + 2)))
        o = 2;
      else if (a < 128)
        /[!#$&-;=?-Z_a-z~]/.test(String.fromCharCode(a)) || (i = String.fromCharCode(a));
      else if (a > 55295 && a < 57344) {
        const s = e.charCodeAt(n + 1);
        a < 56320 && s > 56319 && s < 57344 ? (i = String.fromCharCode(a, s), o = 1) : i = "";
      } else
        i = String.fromCharCode(a);
      i && (t.push(e.slice(r, n), encodeURIComponent(i)), r = n + o + 1, i = ""), o && (n += o, o = 0);
    }
    return t.join("") + e.slice(r);
  }
  function Mt(e, t, n, r) {
    const o = r ? r - 1 : Number.POSITIVE_INFINITY;
    let a = 0;
    return i;
    function i(u) {
      return kt(u) ? (e.enter(n), s(u)) : t(u);
    }
    function s(u) {
      return kt(u) && a++ < o ? (e.consume(u), s) : (e.exit(n), t(u));
    }
  }
  const R4e = {
    tokenize: j4e
  };
  function j4e(e) {
    const t = e.attempt(this.parser.constructs.contentInitial, r, o);
    let n;
    return t;
    function r(s) {
      if (s === null) {
        e.consume(s);
        return;
      }
      return e.enter("lineEnding"), e.consume(s), e.exit("lineEnding"), Mt(e, t, "linePrefix");
    }
    function o(s) {
      return e.enter("paragraph"), a(s);
    }
    function a(s) {
      const u = e.enter("chunkText", {
        contentType: "text",
        previous: n
      });
      return n && (n.next = u), n = u, i(s);
    }
    function i(s) {
      if (s === null) {
        e.exit("chunkText"), e.exit("paragraph"), e.consume(s);
        return;
      }
      return Je(s) ? (e.consume(s), e.exit("chunkText"), a) : (e.consume(s), i);
    }
  }
  const I4e = {
    tokenize: A4e
  }, hF = {
    tokenize: $4e
  };
  function A4e(e) {
    const t = this, n = [];
    let r = 0, o, a, i;
    return s;
    function s(k) {
      if (r < n.length) {
        const E = n[r];
        return t.containerState = E[1], e.attempt(E[0].continuation, u, c)(k);
      }
      return c(k);
    }
    function u(k) {
      if (r++, t.containerState._closeFlow) {
        t.containerState._closeFlow = void 0, o && _();
        const E = t.events.length;
        let P = E, O;
        for (; P--; )
          if (t.events[P][0] === "exit" && t.events[P][1].type === "chunkFlow") {
            O = t.events[P][1].end;
            break;
          }
        w(r);
        let M = E;
        for (; M < t.events.length; )
          t.events[M][1].end = {
            ...O
          }, M++;
        return fo(t.events, P + 1, 0, t.events.slice(E)), t.events.length = M, c(k);
      }
      return s(k);
    }
    function c(k) {
      if (r === n.length) {
        if (!o)
          return g(k);
        if (o.currentConstruct && o.currentConstruct.concrete)
          return y(k);
        t.interrupt = !!(o.currentConstruct && !o._gfmTableDynamicInterruptHack);
      }
      return t.containerState = {}, e.check(hF, f, p)(k);
    }
    function f(k) {
      return o && _(), w(r), g(k);
    }
    function p(k) {
      return t.parser.lazy[t.now().line] = r !== n.length, i = t.now().offset, y(k);
    }
    function g(k) {
      return t.containerState = {}, e.attempt(hF, h, y)(k);
    }
    function h(k) {
      return r++, n.push([t.currentConstruct, t.containerState]), g(k);
    }
    function y(k) {
      if (k === null) {
        o && _(), w(0), e.consume(k);
        return;
      }
      return o = o || t.parser.flow(t.now()), e.enter("chunkFlow", {
        _tokenizer: o,
        contentType: "flow",
        previous: a
      }), b(k);
    }
    function b(k) {
      if (k === null) {
        v(e.exit("chunkFlow"), !0), w(0), e.consume(k);
        return;
      }
      return Je(k) ? (e.consume(k), v(e.exit("chunkFlow")), r = 0, t.interrupt = void 0, s) : (e.consume(k), b);
    }
    function v(k, E) {
      const P = t.sliceStream(k);
      if (E && P.push(null), k.previous = a, a && (a.next = k), a = k, o.defineSkip(k.start), o.write(P), t.parser.lazy[k.start.line]) {
        let O = o.events.length;
        for (; O--; )
          if (
            // The token starts before the line ending
            o.events[O][1].start.offset < i && // and either is not ended yet
            (!o.events[O][1].end || // or ends after it.
            o.events[O][1].end.offset > i)
          )
            return;
        const M = t.events.length;
        let I = M, A, D;
        for (; I--; )
          if (t.events[I][0] === "exit" && t.events[I][1].type === "chunkFlow") {
            if (A) {
              D = t.events[I][1].end;
              break;
            }
            A = !0;
          }
        for (w(r), O = M; O < t.events.length; )
          t.events[O][1].end = {
            ...D
          }, O++;
        fo(t.events, I + 1, 0, t.events.slice(M)), t.events.length = O;
      }
    }
    function w(k) {
      let E = n.length;
      for (; E-- > k; ) {
        const P = n[E];
        t.containerState = P[1], P[0].exit.call(t, e);
      }
      n.length = k;
    }
    function _() {
      o.write([null]), a = void 0, o = void 0, t.containerState._closeFlow = void 0;
    }
  }
  function $4e(e, t, n) {
    return Mt(e, e.attempt(this.parser.constructs.document, t, n), "linePrefix", this.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4);
  }
  function jd(e) {
    if (e === null || ln(e) || wu(e))
      return 1;
    if (Dx(e))
      return 2;
  }
  function Lx(e, t, n) {
    const r = [];
    let o = -1;
    for (; ++o < e.length; ) {
      const a = e[o].resolveAll;
      a && !r.includes(a) && (t = a(t, n), r.push(a));
    }
    return t;
  }
  const $E = {
    name: "attention",
    resolveAll: D4e,
    tokenize: L4e
  };
  function D4e(e, t) {
    let n = -1, r, o, a, i, s, u, c, f;
    for (; ++n < e.length; )
      if (e[n][0] === "enter" && e[n][1].type === "attentionSequence" && e[n][1]._close) {
        for (r = n; r--; )
          if (e[r][0] === "exit" && e[r][1].type === "attentionSequence" && e[r][1]._open && // If the markers are the same:
          t.sliceSerialize(e[r][1]).charCodeAt(0) === t.sliceSerialize(e[n][1]).charCodeAt(0)) {
            if ((e[r][1]._close || e[n][1]._open) && (e[n][1].end.offset - e[n][1].start.offset) % 3 && !((e[r][1].end.offset - e[r][1].start.offset + e[n][1].end.offset - e[n][1].start.offset) % 3))
              continue;
            u = e[r][1].end.offset - e[r][1].start.offset > 1 && e[n][1].end.offset - e[n][1].start.offset > 1 ? 2 : 1;
            const p = {
              ...e[r][1].end
            }, g = {
              ...e[n][1].start
            };
            gF(p, -u), gF(g, u), i = {
              type: u > 1 ? "strongSequence" : "emphasisSequence",
              start: p,
              end: {
                ...e[r][1].end
              }
            }, s = {
              type: u > 1 ? "strongSequence" : "emphasisSequence",
              start: {
                ...e[n][1].start
              },
              end: g
            }, a = {
              type: u > 1 ? "strongText" : "emphasisText",
              start: {
                ...e[r][1].end
              },
              end: {
                ...e[n][1].start
              }
            }, o = {
              type: u > 1 ? "strong" : "emphasis",
              start: {
                ...i.start
              },
              end: {
                ...s.end
              }
            }, e[r][1].end = {
              ...i.start
            }, e[n][1].start = {
              ...s.end
            }, c = [], e[r][1].end.offset - e[r][1].start.offset && (c = No(c, [["enter", e[r][1], t], ["exit", e[r][1], t]])), c = No(c, [["enter", o, t], ["enter", i, t], ["exit", i, t], ["enter", a, t]]), c = No(c, Lx(t.parser.constructs.insideSpan.null, e.slice(r + 1, n), t)), c = No(c, [["exit", a, t], ["enter", s, t], ["exit", s, t], ["exit", o, t]]), e[n][1].end.offset - e[n][1].start.offset ? (f = 2, c = No(c, [["enter", e[n][1], t], ["exit", e[n][1], t]])) : f = 0, fo(e, r - 1, n - r + 3, c), n = r + c.length - f - 2;
            break;
          }
      }
    for (n = -1; ++n < e.length; )
      e[n][1].type === "attentionSequence" && (e[n][1].type = "data");
    return e;
  }
  function L4e(e, t) {
    const n = this.parser.constructs.attentionMarkers.null, r = this.previous, o = jd(r);
    let a;
    return i;
    function i(u) {
      return a = u, e.enter("attentionSequence"), s(u);
    }
    function s(u) {
      if (u === a)
        return e.consume(u), s;
      const c = e.exit("attentionSequence"), f = jd(u), p = !f || f === 2 && o || n.includes(u), g = !o || o === 2 && f || n.includes(r);
      return c._open = !!(a === 42 ? p : p && (o || !g)), c._close = !!(a === 42 ? g : g && (f || !p)), t(u);
    }
  }
  function gF(e, t) {
    e.column += t, e.offset += t, e._bufferIndex += t;
  }
  const F4e = {
    name: "autolink",
    tokenize: T4e
  };
  function T4e(e, t, n) {
    let r = 0;
    return o;
    function o(h) {
      return e.enter("autolink"), e.enter("autolinkMarker"), e.consume(h), e.exit("autolinkMarker"), e.enter("autolinkProtocol"), a;
    }
    function a(h) {
      return Pr(h) ? (e.consume(h), i) : h === 64 ? n(h) : c(h);
    }
    function i(h) {
      return h === 43 || h === 45 || h === 46 || br(h) ? (r = 1, s(h)) : c(h);
    }
    function s(h) {
      return h === 58 ? (e.consume(h), r = 0, u) : (h === 43 || h === 45 || h === 46 || br(h)) && r++ < 32 ? (e.consume(h), s) : (r = 0, c(h));
    }
    function u(h) {
      return h === 62 ? (e.exit("autolinkProtocol"), e.enter("autolinkMarker"), e.consume(h), e.exit("autolinkMarker"), e.exit("autolink"), t) : h === null || h === 32 || h === 60 || qb(h) ? n(h) : (e.consume(h), u);
    }
    function c(h) {
      return h === 64 ? (e.consume(h), f) : O4e(h) ? (e.consume(h), c) : n(h);
    }
    function f(h) {
      return br(h) ? p(h) : n(h);
    }
    function p(h) {
      return h === 46 ? (e.consume(h), r = 0, f) : h === 62 ? (e.exit("autolinkProtocol").type = "autolinkEmail", e.enter("autolinkMarker"), e.consume(h), e.exit("autolinkMarker"), e.exit("autolink"), t) : g(h);
    }
    function g(h) {
      if ((h === 45 || br(h)) && r++ < 63) {
        const y = h === 45 ? g : p;
        return e.consume(h), y;
      }
      return n(h);
    }
  }
  const Sh = {
    partial: !0,
    tokenize: z4e
  };
  function z4e(e, t, n) {
    return r;
    function r(a) {
      return kt(a) ? Mt(e, o, "linePrefix")(a) : o(a);
    }
    function o(a) {
      return a === null || Je(a) ? t(a) : n(a);
    }
  }
  const QH = {
    continuation: {
      tokenize: V4e
    },
    exit: U4e,
    name: "blockQuote",
    tokenize: B4e
  };
  function B4e(e, t, n) {
    const r = this;
    return o;
    function o(i) {
      if (i === 62) {
        const s = r.containerState;
        return s.open || (e.enter("blockQuote", {
          _container: !0
        }), s.open = !0), e.enter("blockQuotePrefix"), e.enter("blockQuoteMarker"), e.consume(i), e.exit("blockQuoteMarker"), a;
      }
      return n(i);
    }
    function a(i) {
      return kt(i) ? (e.enter("blockQuotePrefixWhitespace"), e.consume(i), e.exit("blockQuotePrefixWhitespace"), e.exit("blockQuotePrefix"), t) : (e.exit("blockQuotePrefix"), t(i));
    }
  }
  function V4e(e, t, n) {
    const r = this;
    return o;
    function o(i) {
      return kt(i) ? Mt(e, a, "linePrefix", r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(i) : a(i);
    }
    function a(i) {
      return e.attempt(QH, t, n)(i);
    }
  }
  function U4e(e) {
    e.exit("blockQuote");
  }
  const ZH = {
    name: "characterEscape",
    tokenize: H4e
  };
  function H4e(e, t, n) {
    return r;
    function r(a) {
      return e.enter("characterEscape"), e.enter("escapeMarker"), e.consume(a), e.exit("escapeMarker"), o;
    }
    function o(a) {
      return M4e(a) ? (e.enter("characterEscapeValue"), e.consume(a), e.exit("characterEscapeValue"), e.exit("characterEscape"), t) : n(a);
    }
  }
  const eW = {
    name: "characterReference",
    tokenize: W4e
  };
  function W4e(e, t, n) {
    const r = this;
    let o = 0, a, i;
    return s;
    function s(p) {
      return e.enter("characterReference"), e.enter("characterReferenceMarker"), e.consume(p), e.exit("characterReferenceMarker"), u;
    }
    function u(p) {
      return p === 35 ? (e.enter("characterReferenceMarkerNumeric"), e.consume(p), e.exit("characterReferenceMarkerNumeric"), c) : (e.enter("characterReferenceValue"), a = 31, i = br, f(p));
    }
    function c(p) {
      return p === 88 || p === 120 ? (e.enter("characterReferenceMarkerHexadecimal"), e.consume(p), e.exit("characterReferenceMarkerHexadecimal"), e.enter("characterReferenceValue"), a = 6, i = N4e, f) : (e.enter("characterReferenceValue"), a = 7, i = AE, f(p));
    }
    function f(p) {
      if (p === 59 && o) {
        const g = e.exit("characterReferenceValue");
        return i === br && !sN(r.sliceSerialize(g)) ? n(p) : (e.enter("characterReferenceMarker"), e.consume(p), e.exit("characterReferenceMarker"), e.exit("characterReference"), t);
      }
      return i(p) && o++ < a ? (e.consume(p), f) : n(p);
    }
  }
  const vF = {
    partial: !0,
    tokenize: K4e
  }, yF = {
    concrete: !0,
    name: "codeFenced",
    tokenize: q4e
  };
  function q4e(e, t, n) {
    const r = this, o = {
      partial: !0,
      tokenize: P
    };
    let a = 0, i = 0, s;
    return u;
    function u(O) {
      return c(O);
    }
    function c(O) {
      const M = r.events[r.events.length - 1];
      return a = M && M[1].type === "linePrefix" ? M[2].sliceSerialize(M[1], !0).length : 0, s = O, e.enter("codeFenced"), e.enter("codeFencedFence"), e.enter("codeFencedFenceSequence"), f(O);
    }
    function f(O) {
      return O === s ? (i++, e.consume(O), f) : i < 3 ? n(O) : (e.exit("codeFencedFenceSequence"), kt(O) ? Mt(e, p, "whitespace")(O) : p(O));
    }
    function p(O) {
      return O === null || Je(O) ? (e.exit("codeFencedFence"), r.interrupt ? t(O) : e.check(vF, b, E)(O)) : (e.enter("codeFencedFenceInfo"), e.enter("chunkString", {
        contentType: "string"
      }), g(O));
    }
    function g(O) {
      return O === null || Je(O) ? (e.exit("chunkString"), e.exit("codeFencedFenceInfo"), p(O)) : kt(O) ? (e.exit("chunkString"), e.exit("codeFencedFenceInfo"), Mt(e, h, "whitespace")(O)) : O === 96 && O === s ? n(O) : (e.consume(O), g);
    }
    function h(O) {
      return O === null || Je(O) ? p(O) : (e.enter("codeFencedFenceMeta"), e.enter("chunkString", {
        contentType: "string"
      }), y(O));
    }
    function y(O) {
      return O === null || Je(O) ? (e.exit("chunkString"), e.exit("codeFencedFenceMeta"), p(O)) : O === 96 && O === s ? n(O) : (e.consume(O), y);
    }
    function b(O) {
      return e.attempt(o, E, v)(O);
    }
    function v(O) {
      return e.enter("lineEnding"), e.consume(O), e.exit("lineEnding"), w;
    }
    function w(O) {
      return a > 0 && kt(O) ? Mt(e, _, "linePrefix", a + 1)(O) : _(O);
    }
    function _(O) {
      return O === null || Je(O) ? e.check(vF, b, E)(O) : (e.enter("codeFlowValue"), k(O));
    }
    function k(O) {
      return O === null || Je(O) ? (e.exit("codeFlowValue"), _(O)) : (e.consume(O), k);
    }
    function E(O) {
      return e.exit("codeFenced"), t(O);
    }
    function P(O, M, I) {
      let A = 0;
      return D;
      function D(q) {
        return O.enter("lineEnding"), O.consume(q), O.exit("lineEnding"), F;
      }
      function F(q) {
        return O.enter("codeFencedFence"), kt(q) ? Mt(O, j, "linePrefix", r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(q) : j(q);
      }
      function j(q) {
        return q === s ? (O.enter("codeFencedFenceSequence"), U(q)) : I(q);
      }
      function U(q) {
        return q === s ? (A++, O.consume(q), U) : A >= i ? (O.exit("codeFencedFenceSequence"), kt(q) ? Mt(O, $, "whitespace")(q) : $(q)) : I(q);
      }
      function $(q) {
        return q === null || Je(q) ? (O.exit("codeFencedFence"), M(q)) : I(q);
      }
    }
  }
  function K4e(e, t, n) {
    const r = this;
    return o;
    function o(i) {
      return i === null ? n(i) : (e.enter("lineEnding"), e.consume(i), e.exit("lineEnding"), a);
    }
    function a(i) {
      return r.parser.lazy[r.now().line] ? n(i) : t(i);
    }
  }
  const F0 = {
    name: "codeIndented",
    tokenize: X4e
  }, G4e = {
    partial: !0,
    tokenize: Y4e
  };
  function X4e(e, t, n) {
    const r = this;
    return o;
    function o(c) {
      return e.enter("codeIndented"), Mt(e, a, "linePrefix", 5)(c);
    }
    function a(c) {
      const f = r.events[r.events.length - 1];
      return f && f[1].type === "linePrefix" && f[2].sliceSerialize(f[1], !0).length >= 4 ? i(c) : n(c);
    }
    function i(c) {
      return c === null ? u(c) : Je(c) ? e.attempt(G4e, i, u)(c) : (e.enter("codeFlowValue"), s(c));
    }
    function s(c) {
      return c === null || Je(c) ? (e.exit("codeFlowValue"), i(c)) : (e.consume(c), s);
    }
    function u(c) {
      return e.exit("codeIndented"), t(c);
    }
  }
  function Y4e(e, t, n) {
    const r = this;
    return o;
    function o(i) {
      return r.parser.lazy[r.now().line] ? n(i) : Je(i) ? (e.enter("lineEnding"), e.consume(i), e.exit("lineEnding"), o) : Mt(e, a, "linePrefix", 5)(i);
    }
    function a(i) {
      const s = r.events[r.events.length - 1];
      return s && s[1].type === "linePrefix" && s[2].sliceSerialize(s[1], !0).length >= 4 ? t(i) : Je(i) ? o(i) : n(i);
    }
  }
  const J4e = {
    name: "codeText",
    previous: Z4e,
    resolve: Q4e,
    tokenize: eDe
  };
  function Q4e(e) {
    let t = e.length - 4, n = 3, r, o;
    if ((e[n][1].type === "lineEnding" || e[n][1].type === "space") && (e[t][1].type === "lineEnding" || e[t][1].type === "space")) {
      for (r = n; ++r < t; )
        if (e[r][1].type === "codeTextData") {
          e[n][1].type = "codeTextPadding", e[t][1].type = "codeTextPadding", n += 2, t -= 2;
          break;
        }
    }
    for (r = n - 1, t++; ++r <= t; )
      o === void 0 ? r !== t && e[r][1].type !== "lineEnding" && (o = r) : (r === t || e[r][1].type === "lineEnding") && (e[o][1].type = "codeTextData", r !== o + 2 && (e[o][1].end = e[r - 1][1].end, e.splice(o + 2, r - o - 2), t -= r - o - 2, r = o + 2), o = void 0);
    return e;
  }
  function Z4e(e) {
    return e !== 96 || this.events[this.events.length - 1][1].type === "characterEscape";
  }
  function eDe(e, t, n) {
    let r = 0, o, a;
    return i;
    function i(p) {
      return e.enter("codeText"), e.enter("codeTextSequence"), s(p);
    }
    function s(p) {
      return p === 96 ? (e.consume(p), r++, s) : (e.exit("codeTextSequence"), u(p));
    }
    function u(p) {
      return p === null ? n(p) : p === 32 ? (e.enter("space"), e.consume(p), e.exit("space"), u) : p === 96 ? (a = e.enter("codeTextSequence"), o = 0, f(p)) : Je(p) ? (e.enter("lineEnding"), e.consume(p), e.exit("lineEnding"), u) : (e.enter("codeTextData"), c(p));
    }
    function c(p) {
      return p === null || p === 32 || p === 96 || Je(p) ? (e.exit("codeTextData"), u(p)) : (e.consume(p), c);
    }
    function f(p) {
      return p === 96 ? (e.consume(p), o++, f) : o === r ? (e.exit("codeTextSequence"), e.exit("codeText"), t(p)) : (a.type = "codeTextData", c(p));
    }
  }
  class tDe {
    /**
     * @param {ReadonlyArray<T> | null | undefined} [initial]
     *   Initial items (optional).
     * @returns
     *   Splice buffer.
     */
    constructor(t) {
      this.left = t ? [...t] : [], this.right = [];
    }
    /**
     * Array access;
     * does not move the cursor.
     *
     * @param {number} index
     *   Index.
     * @return {T}
     *   Item.
     */
    get(t) {
      if (t < 0 || t >= this.left.length + this.right.length)
        throw new RangeError("Cannot access index `" + t + "` in a splice buffer of size `" + (this.left.length + this.right.length) + "`");
      return t < this.left.length ? this.left[t] : this.right[this.right.length - t + this.left.length - 1];
    }
    /**
     * The length of the splice buffer, one greater than the largest index in the
     * array.
     */
    get length() {
      return this.left.length + this.right.length;
    }
    /**
     * Remove and return `list[0]`;
     * moves the cursor to `0`.
     *
     * @returns {T | undefined}
     *   Item, optional.
     */
    shift() {
      return this.setCursor(0), this.right.pop();
    }
    /**
     * Slice the buffer to get an array;
     * does not move the cursor.
     *
     * @param {number} start
     *   Start.
     * @param {number | null | undefined} [end]
     *   End (optional).
     * @returns {Array<T>}
     *   Array of items.
     */
    slice(t, n) {
      const r = n ?? Number.POSITIVE_INFINITY;
      return r < this.left.length ? this.left.slice(t, r) : t > this.left.length ? this.right.slice(this.right.length - r + this.left.length, this.right.length - t + this.left.length).reverse() : this.left.slice(t).concat(this.right.slice(this.right.length - r + this.left.length).reverse());
    }
    /**
     * Mimics the behavior of Array.prototype.splice() except for the change of
     * interface necessary to avoid segfaults when patching in very large arrays.
     *
     * This operation moves cursor is moved to `start` and results in the cursor
     * placed after any inserted items.
     *
     * @param {number} start
     *   Start;
     *   zero-based index at which to start changing the array;
     *   negative numbers count backwards from the end of the array and values
     *   that are out-of bounds are clamped to the appropriate end of the array.
     * @param {number | null | undefined} [deleteCount=0]
     *   Delete count (default: `0`);
     *   maximum number of elements to delete, starting from start.
     * @param {Array<T> | null | undefined} [items=[]]
     *   Items to include in place of the deleted items (default: `[]`).
     * @return {Array<T>}
     *   Any removed items.
     */
    splice(t, n, r) {
      const o = n || 0;
      this.setCursor(Math.trunc(t));
      const a = this.right.splice(this.right.length - o, Number.POSITIVE_INFINITY);
      return r && dp(this.left, r), a.reverse();
    }
    /**
     * Remove and return the highest-numbered item in the array, so
     * `list[list.length - 1]`;
     * Moves the cursor to `length`.
     *
     * @returns {T | undefined}
     *   Item, optional.
     */
    pop() {
      return this.setCursor(Number.POSITIVE_INFINITY), this.left.pop();
    }
    /**
     * Inserts a single item to the high-numbered side of the array;
     * moves the cursor to `length`.
     *
     * @param {T} item
     *   Item.
     * @returns {undefined}
     *   Nothing.
     */
    push(t) {
      this.setCursor(Number.POSITIVE_INFINITY), this.left.push(t);
    }
    /**
     * Inserts many items to the high-numbered side of the array.
     * Moves the cursor to `length`.
     *
     * @param {Array<T>} items
     *   Items.
     * @returns {undefined}
     *   Nothing.
     */
    pushMany(t) {
      this.setCursor(Number.POSITIVE_INFINITY), dp(this.left, t);
    }
    /**
     * Inserts a single item to the low-numbered side of the array;
     * Moves the cursor to `0`.
     *
     * @param {T} item
     *   Item.
     * @returns {undefined}
     *   Nothing.
     */
    unshift(t) {
      this.setCursor(0), this.right.push(t);
    }
    /**
     * Inserts many items to the low-numbered side of the array;
     * moves the cursor to `0`.
     *
     * @param {Array<T>} items
     *   Items.
     * @returns {undefined}
     *   Nothing.
     */
    unshiftMany(t) {
      this.setCursor(0), dp(this.right, t.reverse());
    }
    /**
     * Move the cursor to a specific position in the array. Requires
     * time proportional to the distance moved.
     *
     * If `n < 0`, the cursor will end up at the beginning.
     * If `n > length`, the cursor will end up at the end.
     *
     * @param {number} n
     *   Position.
     * @return {undefined}
     *   Nothing.
     */
    setCursor(t) {
      if (!(t === this.left.length || t > this.left.length && this.right.length === 0 || t < 0 && this.left.length === 0))
        if (t < this.left.length) {
          const n = this.left.splice(t, Number.POSITIVE_INFINITY);
          dp(this.right, n.reverse());
        } else {
          const n = this.right.splice(this.left.length + this.right.length - t, Number.POSITIVE_INFINITY);
          dp(this.left, n.reverse());
        }
    }
  }
  function dp(e, t) {
    let n = 0;
    if (t.length < 1e4)
      e.push(...t);
    else
      for (; n < t.length; )
        e.push(...t.slice(n, n + 1e4)), n += 1e4;
  }
  function tW(e) {
    const t = {};
    let n = -1, r, o, a, i, s, u, c;
    const f = new tDe(e);
    for (; ++n < f.length; ) {
      for (; n in t; )
        n = t[n];
      if (r = f.get(n), n && r[1].type === "chunkFlow" && f.get(n - 1)[1].type === "listItemPrefix" && (u = r[1]._tokenizer.events, a = 0, a < u.length && u[a][1].type === "lineEndingBlank" && (a += 2), a < u.length && u[a][1].type === "content"))
        for (; ++a < u.length && u[a][1].type !== "content"; )
          u[a][1].type === "chunkText" && (u[a][1]._isInFirstContentOfListItem = !0, a++);
      if (r[0] === "enter")
        r[1].contentType && (Object.assign(t, nDe(f, n)), n = t[n], c = !0);
      else if (r[1]._container) {
        for (a = n, o = void 0; a--; )
          if (i = f.get(a), i[1].type === "lineEnding" || i[1].type === "lineEndingBlank")
            i[0] === "enter" && (o && (f.get(o)[1].type = "lineEndingBlank"), i[1].type = "lineEnding", o = a);
          else if (!(i[1].type === "linePrefix" || i[1].type === "listItemIndent")) break;
        o && (r[1].end = {
          ...f.get(o)[1].start
        }, s = f.slice(o, n), s.unshift(r), f.splice(o, n - o + 1, s));
      }
    }
    return fo(e, 0, Number.POSITIVE_INFINITY, f.slice(0)), !c;
  }
  function nDe(e, t) {
    const n = e.get(t)[1], r = e.get(t)[2];
    let o = t - 1;
    const a = [];
    let i = n._tokenizer;
    i || (i = r.parser[n.contentType](n.start), n._contentTypeTextTrailing && (i._contentTypeTextTrailing = !0));
    const s = i.events, u = [], c = {};
    let f, p, g = -1, h = n, y = 0, b = 0;
    const v = [b];
    for (; h; ) {
      for (; e.get(++o)[1] !== h; )
        ;
      a.push(o), h._tokenizer || (f = r.sliceStream(h), h.next || f.push(null), p && i.defineSkip(h.start), h._isInFirstContentOfListItem && (i._gfmTasklistFirstContentOfListItem = !0), i.write(f), h._isInFirstContentOfListItem && (i._gfmTasklistFirstContentOfListItem = void 0)), p = h, h = h.next;
    }
    for (h = n; ++g < s.length; )
      s[g][0] === "exit" && s[g - 1][0] === "enter" && s[g][1].type === s[g - 1][1].type && s[g][1].start.line !== s[g][1].end.line && (b = g + 1, v.push(b), h._tokenizer = void 0, h.previous = void 0, h = h.next);
    for (i.events = [], h ? (h._tokenizer = void 0, h.previous = void 0) : v.pop(), g = v.length; g--; ) {
      const w = s.slice(v[g], v[g + 1]), _ = a.pop();
      u.push([_, _ + w.length - 1]), e.splice(_, 2, w);
    }
    for (u.reverse(), g = -1; ++g < u.length; )
      c[y + u[g][0]] = y + u[g][1], y += u[g][1] - u[g][0] - 1;
    return c;
  }
  const rDe = {
    resolve: aDe,
    tokenize: iDe
  }, oDe = {
    partial: !0,
    tokenize: sDe
  };
  function aDe(e) {
    return tW(e), e;
  }
  function iDe(e, t) {
    let n;
    return r;
    function r(s) {
      return e.enter("content"), n = e.enter("chunkContent", {
        contentType: "content"
      }), o(s);
    }
    function o(s) {
      return s === null ? a(s) : Je(s) ? e.check(oDe, i, a)(s) : (e.consume(s), o);
    }
    function a(s) {
      return e.exit("chunkContent"), e.exit("content"), t(s);
    }
    function i(s) {
      return e.consume(s), e.exit("chunkContent"), n.next = e.enter("chunkContent", {
        contentType: "content",
        previous: n
      }), n = n.next, o;
    }
  }
  function sDe(e, t, n) {
    const r = this;
    return o;
    function o(i) {
      return e.exit("chunkContent"), e.enter("lineEnding"), e.consume(i), e.exit("lineEnding"), Mt(e, a, "linePrefix");
    }
    function a(i) {
      if (i === null || Je(i))
        return n(i);
      const s = r.events[r.events.length - 1];
      return !r.parser.constructs.disable.null.includes("codeIndented") && s && s[1].type === "linePrefix" && s[2].sliceSerialize(s[1], !0).length >= 4 ? t(i) : e.interrupt(r.parser.constructs.flow, n, t)(i);
    }
  }
  function nW(e, t, n, r, o, a, i, s, u) {
    const c = u || Number.POSITIVE_INFINITY;
    let f = 0;
    return p;
    function p(w) {
      return w === 60 ? (e.enter(r), e.enter(o), e.enter(a), e.consume(w), e.exit(a), g) : w === null || w === 32 || w === 41 || qb(w) ? n(w) : (e.enter(r), e.enter(i), e.enter(s), e.enter("chunkString", {
        contentType: "string"
      }), b(w));
    }
    function g(w) {
      return w === 62 ? (e.enter(a), e.consume(w), e.exit(a), e.exit(o), e.exit(r), t) : (e.enter(s), e.enter("chunkString", {
        contentType: "string"
      }), h(w));
    }
    function h(w) {
      return w === 62 ? (e.exit("chunkString"), e.exit(s), g(w)) : w === null || w === 60 || Je(w) ? n(w) : (e.consume(w), w === 92 ? y : h);
    }
    function y(w) {
      return w === 60 || w === 62 || w === 92 ? (e.consume(w), h) : h(w);
    }
    function b(w) {
      return !f && (w === null || w === 41 || ln(w)) ? (e.exit("chunkString"), e.exit(s), e.exit(i), e.exit(r), t(w)) : f < c && w === 40 ? (e.consume(w), f++, b) : w === 41 ? (e.consume(w), f--, b) : w === null || w === 32 || w === 40 || qb(w) ? n(w) : (e.consume(w), w === 92 ? v : b);
    }
    function v(w) {
      return w === 40 || w === 41 || w === 92 ? (e.consume(w), b) : b(w);
    }
  }
  function rW(e, t, n, r, o, a) {
    const i = this;
    let s = 0, u;
    return c;
    function c(h) {
      return e.enter(r), e.enter(o), e.consume(h), e.exit(o), e.enter(a), f;
    }
    function f(h) {
      return s > 999 || h === null || h === 91 || h === 93 && !u || // To do: remove in the future once weve switched from
      // `micromark-extension-footnote` to `micromark-extension-gfm-footnote`,
      // which doesnt need this.
      // Hidden footnotes hook.
      /* c8 ignore next 3 */
      h === 94 && !s && "_hiddenFootnoteSupport" in i.parser.constructs ? n(h) : h === 93 ? (e.exit(a), e.enter(o), e.consume(h), e.exit(o), e.exit(r), t) : Je(h) ? (e.enter("lineEnding"), e.consume(h), e.exit("lineEnding"), f) : (e.enter("chunkString", {
        contentType: "string"
      }), p(h));
    }
    function p(h) {
      return h === null || h === 91 || h === 93 || Je(h) || s++ > 999 ? (e.exit("chunkString"), f(h)) : (e.consume(h), u || (u = !kt(h)), h === 92 ? g : p);
    }
    function g(h) {
      return h === 91 || h === 92 || h === 93 ? (e.consume(h), s++, p) : p(h);
    }
  }
  function oW(e, t, n, r, o, a) {
    let i;
    return s;
    function s(g) {
      return g === 34 || g === 39 || g === 40 ? (e.enter(r), e.enter(o), e.consume(g), e.exit(o), i = g === 40 ? 41 : g, u) : n(g);
    }
    function u(g) {
      return g === i ? (e.enter(o), e.consume(g), e.exit(o), e.exit(r), t) : (e.enter(a), c(g));
    }
    function c(g) {
      return g === i ? (e.exit(a), u(i)) : g === null ? n(g) : Je(g) ? (e.enter("lineEnding"), e.consume(g), e.exit("lineEnding"), Mt(e, c, "linePrefix")) : (e.enter("chunkString", {
        contentType: "string"
      }), f(g));
    }
    function f(g) {
      return g === i || g === null || Je(g) ? (e.exit("chunkString"), c(g)) : (e.consume(g), g === 92 ? p : f);
    }
    function p(g) {
      return g === i || g === 92 ? (e.consume(g), f) : f(g);
    }
  }
  function Wp(e, t) {
    let n;
    return r;
    function r(o) {
      return Je(o) ? (e.enter("lineEnding"), e.consume(o), e.exit("lineEnding"), n = !0, r) : kt(o) ? Mt(e, r, n ? "linePrefix" : "lineSuffix")(o) : t(o);
    }
  }
  const lDe = {
    name: "definition",
    tokenize: cDe
  }, uDe = {
    partial: !0,
    tokenize: dDe
  };
  function cDe(e, t, n) {
    const r = this;
    let o;
    return a;
    function a(h) {
      return e.enter("definition"), i(h);
    }
    function i(h) {
      return rW.call(
        r,
        e,
        s,
        // Note: we dont need to reset the way `markdown-rs` does.
        n,
        "definitionLabel",
        "definitionLabelMarker",
        "definitionLabelString"
      )(h);
    }
    function s(h) {
      return o = ea(r.sliceSerialize(r.events[r.events.length - 1][1]).slice(1, -1)), h === 58 ? (e.enter("definitionMarker"), e.consume(h), e.exit("definitionMarker"), u) : n(h);
    }
    function u(h) {
      return ln(h) ? Wp(e, c)(h) : c(h);
    }
    function c(h) {
      return nW(
        e,
        f,
        // Note: we dont need to reset the way `markdown-rs` does.
        n,
        "definitionDestination",
        "definitionDestinationLiteral",
        "definitionDestinationLiteralMarker",
        "definitionDestinationRaw",
        "definitionDestinationString"
      )(h);
    }
    function f(h) {
      return e.attempt(uDe, p, p)(h);
    }
    function p(h) {
      return kt(h) ? Mt(e, g, "whitespace")(h) : g(h);
    }
    function g(h) {
      return h === null || Je(h) ? (e.exit("definition"), r.parser.defined.push(o), t(h)) : n(h);
    }
  }
  function dDe(e, t, n) {
    return r;
    function r(s) {
      return ln(s) ? Wp(e, o)(s) : n(s);
    }
    function o(s) {
      return oW(e, a, n, "definitionTitle", "definitionTitleMarker", "definitionTitleString")(s);
    }
    function a(s) {
      return kt(s) ? Mt(e, i, "whitespace")(s) : i(s);
    }
    function i(s) {
      return s === null || Je(s) ? t(s) : n(s);
    }
  }
  const fDe = {
    name: "hardBreakEscape",
    tokenize: pDe
  };
  function pDe(e, t, n) {
    return r;
    function r(a) {
      return e.enter("hardBreakEscape"), e.consume(a), o;
    }
    function o(a) {
      return Je(a) ? (e.exit("hardBreakEscape"), t(a)) : n(a);
    }
  }
  const mDe = {
    name: "headingAtx",
    resolve: hDe,
    tokenize: gDe
  };
  function hDe(e, t) {
    let n = e.length - 2, r = 3, o, a;
    return e[r][1].type === "whitespace" && (r += 2), n - 2 > r && e[n][1].type === "whitespace" && (n -= 2), e[n][1].type === "atxHeadingSequence" && (r === n - 1 || n - 4 > r && e[n - 2][1].type === "whitespace") && (n -= r + 1 === n ? 2 : 4), n > r && (o = {
      type: "atxHeadingText",
      start: e[r][1].start,
      end: e[n][1].end
    }, a = {
      type: "chunkText",
      start: e[r][1].start,
      end: e[n][1].end,
      contentType: "text"
    }, fo(e, r, n - r + 1, [["enter", o, t], ["enter", a, t], ["exit", a, t], ["exit", o, t]])), e;
  }
  function gDe(e, t, n) {
    let r = 0;
    return o;
    function o(f) {
      return e.enter("atxHeading"), a(f);
    }
    function a(f) {
      return e.enter("atxHeadingSequence"), i(f);
    }
    function i(f) {
      return f === 35 && r++ < 6 ? (e.consume(f), i) : f === null || ln(f) ? (e.exit("atxHeadingSequence"), s(f)) : n(f);
    }
    function s(f) {
      return f === 35 ? (e.enter("atxHeadingSequence"), u(f)) : f === null || Je(f) ? (e.exit("atxHeading"), t(f)) : kt(f) ? Mt(e, s, "whitespace")(f) : (e.enter("atxHeadingText"), c(f));
    }
    function u(f) {
      return f === 35 ? (e.consume(f), u) : (e.exit("atxHeadingSequence"), s(f));
    }
    function c(f) {
      return f === null || f === 35 || ln(f) ? (e.exit("atxHeadingText"), s(f)) : (e.consume(f), c);
    }
  }
  const vDe = [
    "address",
    "article",
    "aside",
    "base",
    "basefont",
    "blockquote",
    "body",
    "caption",
    "center",
    "col",
    "colgroup",
    "dd",
    "details",
    "dialog",
    "dir",
    "div",
    "dl",
    "dt",
    "fieldset",
    "figcaption",
    "figure",
    "footer",
    "form",
    "frame",
    "frameset",
    "h1",
    "h2",
    "h3",
    "h4",
    "h5",
    "h6",
    "head",
    "header",
    "hr",
    "html",
    "iframe",
    "legend",
    "li",
    "link",
    "main",
    "menu",
    "menuitem",
    "nav",
    "noframes",
    "ol",
    "optgroup",
    "option",
    "p",
    "param",
    "search",
    "section",
    "summary",
    "table",
    "tbody",
    "td",
    "tfoot",
    "th",
    "thead",
    "title",
    "tr",
    "track",
    "ul"
  ], bF = ["pre", "script", "style", "textarea"], yDe = {
    concrete: !0,
    name: "htmlFlow",
    resolveTo: xDe,
    tokenize: kDe
  }, bDe = {
    partial: !0,
    tokenize: _De
  }, wDe = {
    partial: !0,
    tokenize: SDe
  };
  function xDe(e) {
    let t = e.length;
    for (; t-- && !(e[t][0] === "enter" && e[t][1].type === "htmlFlow"); )
      ;
    return t > 1 && e[t - 2][1].type === "linePrefix" && (e[t][1].start = e[t - 2][1].start, e[t + 1][1].start = e[t - 2][1].start, e.splice(t - 2, 2)), e;
  }
  function kDe(e, t, n) {
    const r = this;
    let o, a, i, s, u;
    return c;
    function c(T) {
      return f(T);
    }
    function f(T) {
      return e.enter("htmlFlow"), e.enter("htmlFlowData"), e.consume(T), p;
    }
    function p(T) {
      return T === 33 ? (e.consume(T), g) : T === 47 ? (e.consume(T), a = !0, b) : T === 63 ? (e.consume(T), o = 3, r.interrupt ? t : z) : Pr(T) ? (e.consume(T), i = String.fromCharCode(T), v) : n(T);
    }
    function g(T) {
      return T === 45 ? (e.consume(T), o = 2, h) : T === 91 ? (e.consume(T), o = 5, s = 0, y) : Pr(T) ? (e.consume(T), o = 4, r.interrupt ? t : z) : n(T);
    }
    function h(T) {
      return T === 45 ? (e.consume(T), r.interrupt ? t : z) : n(T);
    }
    function y(T) {
      const V = "CDATA[";
      return T === V.charCodeAt(s++) ? (e.consume(T), s === V.length ? r.interrupt ? t : j : y) : n(T);
    }
    function b(T) {
      return Pr(T) ? (e.consume(T), i = String.fromCharCode(T), v) : n(T);
    }
    function v(T) {
      if (T === null || T === 47 || T === 62 || ln(T)) {
        const V = T === 47, X = i.toLowerCase();
        return !V && !a && bF.includes(X) ? (o = 1, r.interrupt ? t(T) : j(T)) : vDe.includes(i.toLowerCase()) ? (o = 6, V ? (e.consume(T), w) : r.interrupt ? t(T) : j(T)) : (o = 7, r.interrupt && !r.parser.lazy[r.now().line] ? n(T) : a ? _(T) : k(T));
      }
      return T === 45 || br(T) ? (e.consume(T), i += String.fromCharCode(T), v) : n(T);
    }
    function w(T) {
      return T === 62 ? (e.consume(T), r.interrupt ? t : j) : n(T);
    }
    function _(T) {
      return kt(T) ? (e.consume(T), _) : D(T);
    }
    function k(T) {
      return T === 47 ? (e.consume(T), D) : T === 58 || T === 95 || Pr(T) ? (e.consume(T), E) : kt(T) ? (e.consume(T), k) : D(T);
    }
    function E(T) {
      return T === 45 || T === 46 || T === 58 || T === 95 || br(T) ? (e.consume(T), E) : P(T);
    }
    function P(T) {
      return T === 61 ? (e.consume(T), O) : kt(T) ? (e.consume(T), P) : k(T);
    }
    function O(T) {
      return T === null || T === 60 || T === 61 || T === 62 || T === 96 ? n(T) : T === 34 || T === 39 ? (e.consume(T), u = T, M) : kt(T) ? (e.consume(T), O) : I(T);
    }
    function M(T) {
      return T === u ? (e.consume(T), u = null, A) : T === null || Je(T) ? n(T) : (e.consume(T), M);
    }
    function I(T) {
      return T === null || T === 34 || T === 39 || T === 47 || T === 60 || T === 61 || T === 62 || T === 96 || ln(T) ? P(T) : (e.consume(T), I);
    }
    function A(T) {
      return T === 47 || T === 62 || kt(T) ? k(T) : n(T);
    }
    function D(T) {
      return T === 62 ? (e.consume(T), F) : n(T);
    }
    function F(T) {
      return T === null || Je(T) ? j(T) : kt(T) ? (e.consume(T), F) : n(T);
    }
    function j(T) {
      return T === 45 && o === 2 ? (e.consume(T), B) : T === 60 && o === 1 ? (e.consume(T), G) : T === 62 && o === 4 ? (e.consume(T), L) : T === 63 && o === 3 ? (e.consume(T), z) : T === 93 && o === 5 ? (e.consume(T), Y) : Je(T) && (o === 6 || o === 7) ? (e.exit("htmlFlowData"), e.check(bDe, K, U)(T)) : T === null || Je(T) ? (e.exit("htmlFlowData"), U(T)) : (e.consume(T), j);
    }
    function U(T) {
      return e.check(wDe, $, K)(T);
    }
    function $(T) {
      return e.enter("lineEnding"), e.consume(T), e.exit("lineEnding"), q;
    }
    function q(T) {
      return T === null || Je(T) ? U(T) : (e.enter("htmlFlowData"), j(T));
    }
    function B(T) {
      return T === 45 ? (e.consume(T), z) : j(T);
    }
    function G(T) {
      return T === 47 ? (e.consume(T), i = "", W) : j(T);
    }
    function W(T) {
      if (T === 62) {
        const V = i.toLowerCase();
        return bF.includes(V) ? (e.consume(T), L) : j(T);
      }
      return Pr(T) && i.length < 8 ? (e.consume(T), i += String.fromCharCode(T), W) : j(T);
    }
    function Y(T) {
      return T === 93 ? (e.consume(T), z) : j(T);
    }
    function z(T) {
      return T === 62 ? (e.consume(T), L) : T === 45 && o === 2 ? (e.consume(T), z) : j(T);
    }
    function L(T) {
      return T === null || Je(T) ? (e.exit("htmlFlowData"), K(T)) : (e.consume(T), L);
    }
    function K(T) {
      return e.exit("htmlFlow"), t(T);
    }
  }
  function SDe(e, t, n) {
    const r = this;
    return o;
    function o(i) {
      return Je(i) ? (e.enter("lineEnding"), e.consume(i), e.exit("lineEnding"), a) : n(i);
    }
    function a(i) {
      return r.parser.lazy[r.now().line] ? n(i) : t(i);
    }
  }
  function _De(e, t, n) {
    return r;
    function r(o) {
      return e.enter("lineEnding"), e.consume(o), e.exit("lineEnding"), e.attempt(Sh, t, n);
    }
  }
  const EDe = {
    name: "htmlText",
    tokenize: CDe
  };
  function CDe(e, t, n) {
    const r = this;
    let o, a, i;
    return s;
    function s(z) {
      return e.enter("htmlText"), e.enter("htmlTextData"), e.consume(z), u;
    }
    function u(z) {
      return z === 33 ? (e.consume(z), c) : z === 47 ? (e.consume(z), P) : z === 63 ? (e.consume(z), k) : Pr(z) ? (e.consume(z), I) : n(z);
    }
    function c(z) {
      return z === 45 ? (e.consume(z), f) : z === 91 ? (e.consume(z), a = 0, y) : Pr(z) ? (e.consume(z), _) : n(z);
    }
    function f(z) {
      return z === 45 ? (e.consume(z), h) : n(z);
    }
    function p(z) {
      return z === null ? n(z) : z === 45 ? (e.consume(z), g) : Je(z) ? (i = p, G(z)) : (e.consume(z), p);
    }
    function g(z) {
      return z === 45 ? (e.consume(z), h) : p(z);
    }
    function h(z) {
      return z === 62 ? B(z) : z === 45 ? g(z) : p(z);
    }
    function y(z) {
      const L = "CDATA[";
      return z === L.charCodeAt(a++) ? (e.consume(z), a === L.length ? b : y) : n(z);
    }
    function b(z) {
      return z === null ? n(z) : z === 93 ? (e.consume(z), v) : Je(z) ? (i = b, G(z)) : (e.consume(z), b);
    }
    function v(z) {
      return z === 93 ? (e.consume(z), w) : b(z);
    }
    function w(z) {
      return z === 62 ? B(z) : z === 93 ? (e.consume(z), w) : b(z);
    }
    function _(z) {
      return z === null || z === 62 ? B(z) : Je(z) ? (i = _, G(z)) : (e.consume(z), _);
    }
    function k(z) {
      return z === null ? n(z) : z === 63 ? (e.consume(z), E) : Je(z) ? (i = k, G(z)) : (e.consume(z), k);
    }
    function E(z) {
      return z === 62 ? B(z) : k(z);
    }
    function P(z) {
      return Pr(z) ? (e.consume(z), O) : n(z);
    }
    function O(z) {
      return z === 45 || br(z) ? (e.consume(z), O) : M(z);
    }
    function M(z) {
      return Je(z) ? (i = M, G(z)) : kt(z) ? (e.consume(z), M) : B(z);
    }
    function I(z) {
      return z === 45 || br(z) ? (e.consume(z), I) : z === 47 || z === 62 || ln(z) ? A(z) : n(z);
    }
    function A(z) {
      return z === 47 ? (e.consume(z), B) : z === 58 || z === 95 || Pr(z) ? (e.consume(z), D) : Je(z) ? (i = A, G(z)) : kt(z) ? (e.consume(z), A) : B(z);
    }
    function D(z) {
      return z === 45 || z === 46 || z === 58 || z === 95 || br(z) ? (e.consume(z), D) : F(z);
    }
    function F(z) {
      return z === 61 ? (e.consume(z), j) : Je(z) ? (i = F, G(z)) : kt(z) ? (e.consume(z), F) : A(z);
    }
    function j(z) {
      return z === null || z === 60 || z === 61 || z === 62 || z === 96 ? n(z) : z === 34 || z === 39 ? (e.consume(z), o = z, U) : Je(z) ? (i = j, G(z)) : kt(z) ? (e.consume(z), j) : (e.consume(z), $);
    }
    function U(z) {
      return z === o ? (e.consume(z), o = void 0, q) : z === null ? n(z) : Je(z) ? (i = U, G(z)) : (e.consume(z), U);
    }
    function $(z) {
      return z === null || z === 34 || z === 39 || z === 60 || z === 61 || z === 96 ? n(z) : z === 47 || z === 62 || ln(z) ? A(z) : (e.consume(z), $);
    }
    function q(z) {
      return z === 47 || z === 62 || ln(z) ? A(z) : n(z);
    }
    function B(z) {
      return z === 62 ? (e.consume(z), e.exit("htmlTextData"), e.exit("htmlText"), t) : n(z);
    }
    function G(z) {
      return e.exit("htmlTextData"), e.enter("lineEnding"), e.consume(z), e.exit("lineEnding"), W;
    }
    function W(z) {
      return kt(z) ? Mt(e, Y, "linePrefix", r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(z) : Y(z);
    }
    function Y(z) {
      return e.enter("htmlTextData"), i(z);
    }
  }
  const lN = {
    name: "labelEnd",
    resolveAll: MDe,
    resolveTo: RDe,
    tokenize: jDe
  }, PDe = {
    tokenize: IDe
  }, ODe = {
    tokenize: ADe
  }, NDe = {
    tokenize: $De
  };
  function MDe(e) {
    let t = -1;
    const n = [];
    for (; ++t < e.length; ) {
      const r = e[t][1];
      if (n.push(e[t]), r.type === "labelImage" || r.type === "labelLink" || r.type === "labelEnd") {
        const o = r.type === "labelImage" ? 4 : 2;
        r.type = "data", t += o;
      }
    }
    return e.length !== n.length && fo(e, 0, e.length, n), e;
  }
  function RDe(e, t) {
    let n = e.length, r = 0, o, a, i, s;
    for (; n--; )
      if (o = e[n][1], a) {
        if (o.type === "link" || o.type === "labelLink" && o._inactive)
          break;
        e[n][0] === "enter" && o.type === "labelLink" && (o._inactive = !0);
      } else if (i) {
        if (e[n][0] === "enter" && (o.type === "labelImage" || o.type === "labelLink") && !o._balanced && (a = n, o.type !== "labelLink")) {
          r = 2;
          break;
        }
      } else o.type === "labelEnd" && (i = n);
    const u = {
      type: e[a][1].type === "labelLink" ? "link" : "image",
      start: {
        ...e[a][1].start
      },
      end: {
        ...e[e.length - 1][1].end
      }
    }, c = {
      type: "label",
      start: {
        ...e[a][1].start
      },
      end: {
        ...e[i][1].end
      }
    }, f = {
      type: "labelText",
      start: {
        ...e[a + r + 2][1].end
      },
      end: {
        ...e[i - 2][1].start
      }
    };
    return s = [["enter", u, t], ["enter", c, t]], s = No(s, e.slice(a + 1, a + r + 3)), s = No(s, [["enter", f, t]]), s = No(s, Lx(t.parser.constructs.insideSpan.null, e.slice(a + r + 4, i - 3), t)), s = No(s, [["exit", f, t], e[i - 2], e[i - 1], ["exit", c, t]]), s = No(s, e.slice(i + 1)), s = No(s, [["exit", u, t]]), fo(e, a, e.length, s), e;
  }
  function jDe(e, t, n) {
    const r = this;
    let o = r.events.length, a, i;
    for (; o--; )
      if ((r.events[o][1].type === "labelImage" || r.events[o][1].type === "labelLink") && !r.events[o][1]._balanced) {
        a = r.events[o][1];
        break;
      }
    return s;
    function s(g) {
      return a ? a._inactive ? p(g) : (i = r.parser.defined.includes(ea(r.sliceSerialize({
        start: a.end,
        end: r.now()
      }))), e.enter("labelEnd"), e.enter("labelMarker"), e.consume(g), e.exit("labelMarker"), e.exit("labelEnd"), u) : n(g);
    }
    function u(g) {
      return g === 40 ? e.attempt(PDe, f, i ? f : p)(g) : g === 91 ? e.attempt(ODe, f, i ? c : p)(g) : i ? f(g) : p(g);
    }
    function c(g) {
      return e.attempt(NDe, f, p)(g);
    }
    function f(g) {
      return t(g);
    }
    function p(g) {
      return a._balanced = !0, n(g);
    }
  }
  function IDe(e, t, n) {
    return r;
    function r(p) {
      return e.enter("resource"), e.enter("resourceMarker"), e.consume(p), e.exit("resourceMarker"), o;
    }
    function o(p) {
      return ln(p) ? Wp(e, a)(p) : a(p);
    }
    function a(p) {
      return p === 41 ? f(p) : nW(e, i, s, "resourceDestination", "resourceDestinationLiteral", "resourceDestinationLiteralMarker", "resourceDestinationRaw", "resourceDestinationString", 32)(p);
    }
    function i(p) {
      return ln(p) ? Wp(e, u)(p) : f(p);
    }
    function s(p) {
      return n(p);
    }
    function u(p) {
      return p === 34 || p === 39 || p === 40 ? oW(e, c, n, "resourceTitle", "resourceTitleMarker", "resourceTitleString")(p) : f(p);
    }
    function c(p) {
      return ln(p) ? Wp(e, f)(p) : f(p);
    }
    function f(p) {
      return p === 41 ? (e.enter("resourceMarker"), e.consume(p), e.exit("resourceMarker"), e.exit("resource"), t) : n(p);
    }
  }
  function ADe(e, t, n) {
    const r = this;
    return o;
    function o(s) {
      return rW.call(r, e, a, i, "reference", "referenceMarker", "referenceString")(s);
    }
    function a(s) {
      return r.parser.defined.includes(ea(r.sliceSerialize(r.events[r.events.length - 1][1]).slice(1, -1))) ? t(s) : n(s);
    }
    function i(s) {
      return n(s);
    }
  }
  function $De(e, t, n) {
    return r;
    function r(a) {
      return e.enter("reference"), e.enter("referenceMarker"), e.consume(a), e.exit("referenceMarker"), o;
    }
    function o(a) {
      return a === 93 ? (e.enter("referenceMarker"), e.consume(a), e.exit("referenceMarker"), e.exit("reference"), t) : n(a);
    }
  }
  const DDe = {
    name: "labelStartImage",
    resolveAll: lN.resolveAll,
    tokenize: LDe
  };
  function LDe(e, t, n) {
    const r = this;
    return o;
    function o(s) {
      return e.enter("labelImage"), e.enter("labelImageMarker"), e.consume(s), e.exit("labelImageMarker"), a;
    }
    function a(s) {
      return s === 91 ? (e.enter("labelMarker"), e.consume(s), e.exit("labelMarker"), e.exit("labelImage"), i) : n(s);
    }
    function i(s) {
      return s === 94 && "_hiddenFootnoteSupport" in r.parser.constructs ? n(s) : t(s);
    }
  }
  const FDe = {
    name: "labelStartLink",
    resolveAll: lN.resolveAll,
    tokenize: TDe
  };
  function TDe(e, t, n) {
    const r = this;
    return o;
    function o(i) {
      return e.enter("labelLink"), e.enter("labelMarker"), e.consume(i), e.exit("labelMarker"), e.exit("labelLink"), a;
    }
    function a(i) {
      return i === 94 && "_hiddenFootnoteSupport" in r.parser.constructs ? n(i) : t(i);
    }
  }
  const T0 = {
    name: "lineEnding",
    tokenize: zDe
  };
  function zDe(e, t) {
    return n;
    function n(r) {
      return e.enter("lineEnding"), e.consume(r), e.exit("lineEnding"), Mt(e, t, "linePrefix");
    }
  }
  const Xy = {
    name: "thematicBreak",
    tokenize: BDe
  };
  function BDe(e, t, n) {
    let r = 0, o;
    return a;
    function a(c) {
      return e.enter("thematicBreak"), i(c);
    }
    function i(c) {
      return o = c, s(c);
    }
    function s(c) {
      return c === o ? (e.enter("thematicBreakSequence"), u(c)) : r >= 3 && (c === null || Je(c)) ? (e.exit("thematicBreak"), t(c)) : n(c);
    }
    function u(c) {
      return c === o ? (e.consume(c), r++, u) : (e.exit("thematicBreakSequence"), kt(c) ? Mt(e, s, "whitespace")(c) : s(c));
    }
  }
  const Tr = {
    continuation: {
      tokenize: WDe
    },
    exit: KDe,
    name: "list",
    tokenize: HDe
  }, VDe = {
    partial: !0,
    tokenize: GDe
  }, UDe = {
    partial: !0,
    tokenize: qDe
  };
  function HDe(e, t, n) {
    const r = this, o = r.events[r.events.length - 1];
    let a = o && o[1].type === "linePrefix" ? o[2].sliceSerialize(o[1], !0).length : 0, i = 0;
    return s;
    function s(h) {
      const y = r.containerState.type || (h === 42 || h === 43 || h === 45 ? "listUnordered" : "listOrdered");
      if (y === "listUnordered" ? !r.containerState.marker || h === r.containerState.marker : AE(h)) {
        if (r.containerState.type || (r.containerState.type = y, e.enter(y, {
          _container: !0
        })), y === "listUnordered")
          return e.enter("listItemPrefix"), h === 42 || h === 45 ? e.check(Xy, n, c)(h) : c(h);
        if (!r.interrupt || h === 49)
          return e.enter("listItemPrefix"), e.enter("listItemValue"), u(h);
      }
      return n(h);
    }
    function u(h) {
      return AE(h) && ++i < 10 ? (e.consume(h), u) : (!r.interrupt || i < 2) && (r.containerState.marker ? h === r.containerState.marker : h === 41 || h === 46) ? (e.exit("listItemValue"), c(h)) : n(h);
    }
    function c(h) {
      return e.enter("listItemMarker"), e.consume(h), e.exit("listItemMarker"), r.containerState.marker = r.containerState.marker || h, e.check(
        Sh,
        // Cant be empty when interrupting.
        r.interrupt ? n : f,
        e.attempt(VDe, g, p)
      );
    }
    function f(h) {
      return r.containerState.initialBlankLine = !0, a++, g(h);
    }
    function p(h) {
      return kt(h) ? (e.enter("listItemPrefixWhitespace"), e.consume(h), e.exit("listItemPrefixWhitespace"), g) : n(h);
    }
    function g(h) {
      return r.containerState.size = a + r.sliceSerialize(e.exit("listItemPrefix"), !0).length, t(h);
    }
  }
  function WDe(e, t, n) {
    const r = this;
    return r.containerState._closeFlow = void 0, e.check(Sh, o, a);
    function o(s) {
      return r.containerState.furtherBlankLines = r.containerState.furtherBlankLines || r.containerState.initialBlankLine, Mt(e, t, "listItemIndent", r.containerState.size + 1)(s);
    }
    function a(s) {
      return r.containerState.furtherBlankLines || !kt(s) ? (r.containerState.furtherBlankLines = void 0, r.containerState.initialBlankLine = void 0, i(s)) : (r.containerState.furtherBlankLines = void 0, r.containerState.initialBlankLine = void 0, e.attempt(UDe, t, i)(s));
    }
    function i(s) {
      return r.containerState._closeFlow = !0, r.interrupt = void 0, Mt(e, e.attempt(Tr, t, n), "linePrefix", r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(s);
    }
  }
  function qDe(e, t, n) {
    const r = this;
    return Mt(e, o, "listItemIndent", r.containerState.size + 1);
    function o(a) {
      const i = r.events[r.events.length - 1];
      return i && i[1].type === "listItemIndent" && i[2].sliceSerialize(i[1], !0).length === r.containerState.size ? t(a) : n(a);
    }
  }
  function KDe(e) {
    e.exit(this.containerState.type);
  }
  function GDe(e, t, n) {
    const r = this;
    return Mt(e, o, "listItemPrefixWhitespace", r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 5);
    function o(a) {
      const i = r.events[r.events.length - 1];
      return !kt(a) && i && i[1].type === "listItemPrefixWhitespace" ? t(a) : n(a);
    }
  }
  const wF = {
    name: "setextUnderline",
    resolveTo: XDe,
    tokenize: YDe
  };
  function XDe(e, t) {
    let n = e.length, r, o, a;
    for (; n--; )
      if (e[n][0] === "enter") {
        if (e[n][1].type === "content") {
          r = n;
          break;
        }
        e[n][1].type === "paragraph" && (o = n);
      } else
        e[n][1].type === "content" && e.splice(n, 1), !a && e[n][1].type === "definition" && (a = n);
    const i = {
      type: "setextHeading",
      start: {
        ...e[r][1].start
      },
      end: {
        ...e[e.length - 1][1].end
      }
    };
    return e[o][1].type = "setextHeadingText", a ? (e.splice(o, 0, ["enter", i, t]), e.splice(a + 1, 0, ["exit", e[r][1], t]), e[r][1].end = {
      ...e[a][1].end
    }) : e[r][1] = i, e.push(["exit", i, t]), e;
  }
  function YDe(e, t, n) {
    const r = this;
    let o;
    return a;
    function a(c) {
      let f = r.events.length, p;
      for (; f--; )
        if (r.events[f][1].type !== "lineEnding" && r.events[f][1].type !== "linePrefix" && r.events[f][1].type !== "content") {
          p = r.events[f][1].type === "paragraph";
          break;
        }
      return !r.parser.lazy[r.now().line] && (r.interrupt || p) ? (e.enter("setextHeadingLine"), o = c, i(c)) : n(c);
    }
    function i(c) {
      return e.enter("setextHeadingLineSequence"), s(c);
    }
    function s(c) {
      return c === o ? (e.consume(c), s) : (e.exit("setextHeadingLineSequence"), kt(c) ? Mt(e, u, "lineSuffix")(c) : u(c));
    }
    function u(c) {
      return c === null || Je(c) ? (e.exit("setextHeadingLine"), t(c)) : n(c);
    }
  }
  const JDe = {
    tokenize: QDe
  };
  function QDe(e) {
    const t = this, n = e.attempt(
      // Try to parse a blank line.
      Sh,
      r,
      // Try to parse initial flow (essentially, only code).
      e.attempt(this.parser.constructs.flowInitial, o, Mt(e, e.attempt(this.parser.constructs.flow, o, e.attempt(rDe, o)), "linePrefix"))
    );
    return n;
    function r(a) {
      if (a === null) {
        e.consume(a);
        return;
      }
      return e.enter("lineEndingBlank"), e.consume(a), e.exit("lineEndingBlank"), t.currentConstruct = void 0, n;
    }
    function o(a) {
      if (a === null) {
        e.consume(a);
        return;
      }
      return e.enter("lineEnding"), e.consume(a), e.exit("lineEnding"), t.currentConstruct = void 0, n;
    }
  }
  const ZDe = {
    resolveAll: iW()
  }, eLe = aW("string"), tLe = aW("text");
  function aW(e) {
    return {
      resolveAll: iW(e === "text" ? nLe : void 0),
      tokenize: t
    };
    function t(n) {
      const r = this, o = this.parser.constructs[e], a = n.attempt(o, i, s);
      return i;
      function i(f) {
        return c(f) ? a(f) : s(f);
      }
      function s(f) {
        if (f === null) {
          n.consume(f);
          return;
        }
        return n.enter("data"), n.consume(f), u;
      }
      function u(f) {
        return c(f) ? (n.exit("data"), a(f)) : (n.consume(f), u);
      }
      function c(f) {
        if (f === null)
          return !0;
        const p = o[f];
        let g = -1;
        if (p)
          for (; ++g < p.length; ) {
            const h = p[g];
            if (!h.previous || h.previous.call(r, r.previous))
              return !0;
          }
        return !1;
      }
    }
  }
  function iW(e) {
    return t;
    function t(n, r) {
      let o = -1, a;
      for (; ++o <= n.length; )
        a === void 0 ? n[o] && n[o][1].type === "data" && (a = o, o++) : (!n[o] || n[o][1].type !== "data") && (o !== a + 2 && (n[a][1].end = n[o - 1][1].end, n.splice(a + 2, o - a - 2), o = a + 2), a = void 0);
      return e ? e(n, r) : n;
    }
  }
  function nLe(e, t) {
    let n = 0;
    for (; ++n <= e.length; )
      if ((n === e.length || e[n][1].type === "lineEnding") && e[n - 1][1].type === "data") {
        const r = e[n - 1][1], o = t.sliceStream(r);
        let a = o.length, i = -1, s = 0, u;
        for (; a--; ) {
          const c = o[a];
          if (typeof c == "string") {
            for (i = c.length; c.charCodeAt(i - 1) === 32; )
              s++, i--;
            if (i) break;
            i = -1;
          } else if (c === -2)
            u = !0, s++;
          else if (c !== -1) {
            a++;
            break;
          }
        }
        if (t._contentTypeTextTrailing && n === e.length && (s = 0), s) {
          const c = {
            type: n === e.length || u || s < 2 ? "lineSuffix" : "hardBreakTrailing",
            start: {
              _bufferIndex: a ? i : r.start._bufferIndex + i,
              _index: r.start._index + a,
              line: r.end.line,
              column: r.end.column - s,
              offset: r.end.offset - s
            },
            end: {
              ...r.end
            }
          };
          r.end = {
            ...c.start
          }, r.start.offset === r.end.offset ? Object.assign(r, c) : (e.splice(n, 0, ["enter", c, t], ["exit", c, t]), n += 2);
        }
        n++;
      }
    return e;
  }
  const rLe = {
    42: Tr,
    43: Tr,
    45: Tr,
    48: Tr,
    49: Tr,
    50: Tr,
    51: Tr,
    52: Tr,
    53: Tr,
    54: Tr,
    55: Tr,
    56: Tr,
    57: Tr,
    62: QH
  }, oLe = {
    91: lDe
  }, aLe = {
    [-2]: F0,
    [-1]: F0,
    32: F0
  }, iLe = {
    35: mDe,
    42: Xy,
    45: [wF, Xy],
    60: yDe,
    61: wF,
    95: Xy,
    96: yF,
    126: yF
  }, sLe = {
    38: eW,
    92: ZH
  }, lLe = {
    [-5]: T0,
    [-4]: T0,
    [-3]: T0,
    33: DDe,
    38: eW,
    42: $E,
    60: [F4e, EDe],
    91: FDe,
    92: [fDe, ZH],
    93: lN,
    95: $E,
    96: J4e
  }, uLe = {
    null: [$E, ZDe]
  }, cLe = {
    null: [42, 95]
  }, dLe = {
    null: []
  }, fLe = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    attentionMarkers: cLe,
    contentInitial: oLe,
    disable: dLe,
    document: rLe,
    flow: iLe,
    flowInitial: aLe,
    insideSpan: uLe,
    string: sLe,
    text: lLe
  }, Symbol.toStringTag, { value: "Module" }));
  function pLe(e, t, n) {
    let r = {
      _bufferIndex: -1,
      _index: 0,
      line: n && n.line || 1,
      column: n && n.column || 1,
      offset: n && n.offset || 0
    };
    const o = {}, a = [];
    let i = [], s = [];
    const u = {
      attempt: M(P),
      check: M(O),
      consume: _,
      enter: k,
      exit: E,
      interrupt: M(O, {
        interrupt: !0
      })
    }, c = {
      code: null,
      containerState: {},
      defineSkip: b,
      events: [],
      now: y,
      parser: e,
      previous: null,
      sliceSerialize: g,
      sliceStream: h,
      write: p
    };
    let f = t.tokenize.call(c, u);
    return t.resolveAll && a.push(t), c;
    function p(F) {
      return i = No(i, F), v(), i[i.length - 1] !== null ? [] : (I(t, 0), c.events = Lx(a, c.events, c), c.events);
    }
    function g(F, j) {
      return hLe(h(F), j);
    }
    function h(F) {
      return mLe(i, F);
    }
    function y() {
      const {
        _bufferIndex: F,
        _index: j,
        line: U,
        column: $,
        offset: q
      } = r;
      return {
        _bufferIndex: F,
        _index: j,
        line: U,
        column: $,
        offset: q
      };
    }
    function b(F) {
      o[F.line] = F.column, D();
    }
    function v() {
      let F;
      for (; r._index < i.length; ) {
        const j = i[r._index];
        if (typeof j == "string")
          for (F = r._index, r._bufferIndex < 0 && (r._bufferIndex = 0); r._index === F && r._bufferIndex < j.length; )
            w(j.charCodeAt(r._bufferIndex));
        else
          w(j);
      }
    }
    function w(F) {
      f = f(F);
    }
    function _(F) {
      Je(F) ? (r.line++, r.column = 1, r.offset += F === -3 ? 2 : 1, D()) : F !== -1 && (r.column++, r.offset++), r._bufferIndex < 0 ? r._index++ : (r._bufferIndex++, r._bufferIndex === // Points w/ non-negative `_bufferIndex` reference
      // strings.
      /** @type {string} */
      i[r._index].length && (r._bufferIndex = -1, r._index++)), c.previous = F;
    }
    function k(F, j) {
      const U = j || {};
      return U.type = F, U.start = y(), c.events.push(["enter", U, c]), s.push(U), U;
    }
    function E(F) {
      const j = s.pop();
      return j.end = y(), c.events.push(["exit", j, c]), j;
    }
    function P(F, j) {
      I(F, j.from);
    }
    function O(F, j) {
      j.restore();
    }
    function M(F, j) {
      return U;
      function U($, q, B) {
        let G, W, Y, z;
        return Array.isArray($) ? (
          /* c8 ignore next 1 */
          K($)
        ) : "tokenize" in $ ? (
          // Looks like a construct.
          K([
            /** @type {Construct} */
            $
          ])
        ) : L($);
        function L(Q) {
          return ne;
          function ne(te) {
            const ae = te !== null && Q[te], ce = te !== null && Q.null, Z = [
              // To do: add more extension tests.
              /* c8 ignore next 2 */
              ...Array.isArray(ae) ? ae : ae ? [ae] : [],
              ...Array.isArray(ce) ? ce : ce ? [ce] : []
            ];
            return K(Z)(te);
          }
        }
        function K(Q) {
          return G = Q, W = 0, Q.length === 0 ? B : T(Q[W]);
        }
        function T(Q) {
          return ne;
          function ne(te) {
            return z = A(), Y = Q, Q.partial || (c.currentConstruct = Q), Q.name && c.parser.constructs.disable.null.includes(Q.name) ? X() : Q.tokenize.call(
              // If we do have fields, create an object w/ `context` as its
              // prototype.
              // This allows a live binding, which is needed for `interrupt`.
              j ? Object.assign(Object.create(c), j) : c,
              u,
              V,
              X
            )(te);
          }
        }
        function V(Q) {
          return F(Y, z), q;
        }
        function X(Q) {
          return z.restore(), ++W < G.length ? T(G[W]) : B;
        }
      }
    }
    function I(F, j) {
      F.resolveAll && !a.includes(F) && a.push(F), F.resolve && fo(c.events, j, c.events.length - j, F.resolve(c.events.slice(j), c)), F.resolveTo && (c.events = F.resolveTo(c.events, c));
    }
    function A() {
      const F = y(), j = c.previous, U = c.currentConstruct, $ = c.events.length, q = Array.from(s);
      return {
        from: $,
        restore: B
      };
      function B() {
        r = F, c.previous = j, c.currentConstruct = U, c.events.length = $, s = q, D();
      }
    }
    function D() {
      r.line in o && r.column < 2 && (r.column = o[r.line], r.offset += o[r.line] - 1);
    }
  }
  function mLe(e, t) {
    const n = t.start._index, r = t.start._bufferIndex, o = t.end._index, a = t.end._bufferIndex;
    let i;
    if (n === o)
      i = [e[n].slice(r, a)];
    else {
      if (i = e.slice(n, o), r > -1) {
        const s = i[0];
        typeof s == "string" ? i[0] = s.slice(r) : i.shift();
      }
      a > 0 && i.push(e[o].slice(0, a));
    }
    return i;
  }
  function hLe(e, t) {
    let n = -1;
    const r = [];
    let o;
    for (; ++n < e.length; ) {
      const a = e[n];
      let i;
      if (typeof a == "string")
        i = a;
      else switch (a) {
        case -5: {
          i = "\r";
          break;
        }
        case -4: {
          i = `
`;
          break;
        }
        case -3: {
          i = `\r
`;
          break;
        }
        case -2: {
          i = t ? " " : "	";
          break;
        }
        case -1: {
          if (!t && o) continue;
          i = " ";
          break;
        }
        default:
          i = String.fromCharCode(a);
      }
      o = a === -2, r.push(i);
    }
    return r.join("");
  }
  function gLe(e) {
    const t = {
      constructs: (
        /** @type {FullNormalizedExtension} */
        YH([fLe, ...(e || {}).extensions || []])
      ),
      content: n(R4e),
      defined: [],
      document: n(I4e),
      flow: n(JDe),
      lazy: {},
      string: n(eLe),
      text: n(tLe)
    };
    return t;
    function n(r) {
      return o;
      function o(a) {
        return pLe(t, r, a);
      }
    }
  }
  function vLe(e) {
    for (; !tW(e); )
      ;
    return e;
  }
  const xF = /[\0\t\n\r]/g;
  function yLe() {
    let e = 1, t = "", n = !0, r;
    return o;
    function o(a, i, s) {
      const u = [];
      let c, f, p, g, h;
      for (a = t + (typeof a == "string" ? a.toString() : new TextDecoder(i || void 0).decode(a)), p = 0, t = "", n && (a.charCodeAt(0) === 65279 && p++, n = void 0); p < a.length; ) {
        if (xF.lastIndex = p, c = xF.exec(a), g = c && c.index !== void 0 ? c.index : a.length, h = a.charCodeAt(g), !c) {
          t = a.slice(p);
          break;
        }
        if (h === 10 && p === g && r)
          u.push(-3), r = void 0;
        else
          switch (r && (u.push(-5), r = void 0), p < g && (u.push(a.slice(p, g)), e += g - p), h) {
            case 0: {
              u.push(65533), e++;
              break;
            }
            case 9: {
              for (f = Math.ceil(e / 4) * 4, u.push(-2); e++ < f; ) u.push(-1);
              break;
            }
            case 10: {
              u.push(-4), e = 1;
              break;
            }
            default:
              r = !0, e = 1;
          }
        p = g + 1;
      }
      return s && (r && u.push(-5), t && u.push(t), u.push(null)), u;
    }
  }
  const bLe = /\\([!-/:-@[-`{-~])|&(#(?:\d{1,7}|x[\da-f]{1,6})|[\da-z]{1,31});/gi;
  function wLe(e) {
    return e.replace(bLe, xLe);
  }
  function xLe(e, t, n) {
    if (t)
      return t;
    if (n.charCodeAt(0) === 35) {
      const r = n.charCodeAt(1), o = r === 120 || r === 88;
      return JH(n.slice(o ? 2 : 1), o ? 16 : 10);
    }
    return sN(n) || e;
  }
  const sW = {}.hasOwnProperty;
  function kLe(e, t, n) {
    return typeof t != "string" && (n = t, t = void 0), SLe(n)(vLe(gLe(n).document().write(yLe()(e, t, !0))));
  }
  function SLe(e) {
    const t = {
      transforms: [],
      canContainEols: ["emphasis", "fragment", "heading", "paragraph", "strong"],
      enter: {
        autolink: a(Ue),
        autolinkProtocol: A,
        autolinkEmail: A,
        atxHeading: a(be),
        blockQuote: a(ce),
        characterEscape: A,
        characterReference: A,
        codeFenced: a(Z),
        codeFencedFenceInfo: i,
        codeFencedFenceMeta: i,
        codeIndented: a(Z, i),
        codeText: a(ee, i),
        codeTextData: A,
        data: A,
        codeFlowValue: A,
        definition: a(oe),
        definitionDestinationString: i,
        definitionLabelString: i,
        definitionTitleString: i,
        emphasis: a(le),
        hardBreakEscape: a(ke),
        hardBreakTrailing: a(ke),
        htmlFlow: a(De, i),
        htmlFlowData: A,
        htmlText: a(De, i),
        htmlTextData: A,
        image: a(ze),
        label: i,
        link: a(Ue),
        listItem: a(Pe),
        listItemValue: g,
        listOrdered: a(He, p),
        listUnordered: a(He),
        paragraph: a(It),
        reference: T,
        referenceString: i,
        resourceDestinationString: i,
        resourceTitleString: i,
        setextHeading: a(be),
        strong: a(Xe),
        thematicBreak: a(_e)
      },
      exit: {
        atxHeading: u(),
        atxHeadingSequence: P,
        autolink: u(),
        autolinkEmail: ae,
        autolinkProtocol: te,
        blockQuote: u(),
        characterEscapeValue: D,
        characterReferenceMarkerHexadecimal: X,
        characterReferenceMarkerNumeric: X,
        characterReferenceValue: Q,
        characterReference: ne,
        codeFenced: u(v),
        codeFencedFence: b,
        codeFencedFenceInfo: h,
        codeFencedFenceMeta: y,
        codeFlowValue: D,
        codeIndented: u(w),
        codeText: u(q),
        codeTextData: D,
        data: D,
        definition: u(),
        definitionDestinationString: E,
        definitionLabelString: _,
        definitionTitleString: k,
        emphasis: u(),
        hardBreakEscape: u(j),
        hardBreakTrailing: u(j),
        htmlFlow: u(U),
        htmlFlowData: D,
        htmlText: u($),
        htmlTextData: D,
        image: u(G),
        label: Y,
        labelText: W,
        lineEnding: F,
        link: u(B),
        listItem: u(),
        listOrdered: u(),
        listUnordered: u(),
        paragraph: u(),
        referenceString: V,
        resourceDestinationString: z,
        resourceTitleString: L,
        resource: K,
        setextHeading: u(I),
        setextHeadingLineSequence: M,
        setextHeadingText: O,
        strong: u(),
        thematicBreak: u()
      }
    };
    lW(t, (e || {}).mdastExtensions || []);
    const n = {};
    return r;
    function r(ie) {
      let me = {
        type: "root",
        children: []
      };
      const Se = {
        stack: [me],
        tokenStack: [],
        config: t,
        enter: s,
        exit: c,
        buffer: i,
        resume: f,
        data: n
      }, je = [];
      let Ae = -1;
      for (; ++Ae < ie.length; )
        if (ie[Ae][1].type === "listOrdered" || ie[Ae][1].type === "listUnordered")
          if (ie[Ae][0] === "enter")
            je.push(Ae);
          else {
            const vt = je.pop();
            Ae = o(ie, vt, Ae);
          }
      for (Ae = -1; ++Ae < ie.length; ) {
        const vt = t[ie[Ae][0]];
        sW.call(vt, ie[Ae][1].type) && vt[ie[Ae][1].type].call(Object.assign({
          sliceSerialize: ie[Ae][2].sliceSerialize
        }, Se), ie[Ae][1]);
      }
      if (Se.tokenStack.length > 0) {
        const vt = Se.tokenStack[Se.tokenStack.length - 1];
        (vt[1] || kF).call(Se, void 0, vt[0]);
      }
      for (me.position = {
        start: zs(ie.length > 0 ? ie[0][1].start : {
          line: 1,
          column: 1,
          offset: 0
        }),
        end: zs(ie.length > 0 ? ie[ie.length - 2][1].end : {
          line: 1,
          column: 1,
          offset: 0
        })
      }, Ae = -1; ++Ae < t.transforms.length; )
        me = t.transforms[Ae](me) || me;
      return me;
    }
    function o(ie, me, Se) {
      let je = me - 1, Ae = -1, vt = !1, yt, At, qt, Mn;
      for (; ++je <= Se; ) {
        const Re = ie[je];
        switch (Re[1].type) {
          case "listUnordered":
          case "listOrdered":
          case "blockQuote": {
            Re[0] === "enter" ? Ae++ : Ae--, Mn = void 0;
            break;
          }
          case "lineEndingBlank": {
            Re[0] === "enter" && (yt && !Mn && !Ae && !qt && (qt = je), Mn = void 0);
            break;
          }
          case "linePrefix":
          case "listItemValue":
          case "listItemMarker":
          case "listItemPrefix":
          case "listItemPrefixWhitespace":
            break;
          default:
            Mn = void 0;
        }
        if (!Ae && Re[0] === "enter" && Re[1].type === "listItemPrefix" || Ae === -1 && Re[0] === "exit" && (Re[1].type === "listUnordered" || Re[1].type === "listOrdered")) {
          if (yt) {
            let bt = je;
            for (At = void 0; bt--; ) {
              const Ct = ie[bt];
              if (Ct[1].type === "lineEnding" || Ct[1].type === "lineEndingBlank") {
                if (Ct[0] === "exit") continue;
                At && (ie[At][1].type = "lineEndingBlank", vt = !0), Ct[1].type = "lineEnding", At = bt;
              } else if (!(Ct[1].type === "linePrefix" || Ct[1].type === "blockQuotePrefix" || Ct[1].type === "blockQuotePrefixWhitespace" || Ct[1].type === "blockQuoteMarker" || Ct[1].type === "listItemIndent")) break;
            }
            qt && (!At || qt < At) && (yt._spread = !0), yt.end = Object.assign({}, At ? ie[At][1].start : Re[1].end), ie.splice(At || je, 0, ["exit", yt, Re[2]]), je++, Se++;
          }
          if (Re[1].type === "listItemPrefix") {
            const bt = {
              type: "listItem",
              _spread: !1,
              start: Object.assign({}, Re[1].start),
              // @ts-expect-error: well add `end` in a second.
              end: void 0
            };
            yt = bt, ie.splice(je, 0, ["enter", bt, Re[2]]), je++, Se++, qt = void 0, Mn = !0;
          }
        }
      }
      return ie[me][1]._spread = vt, Se;
    }
    function a(ie, me) {
      return Se;
      function Se(je) {
        s.call(this, ie(je), je), me && me.call(this, je);
      }
    }
    function i() {
      this.stack.push({
        type: "fragment",
        children: []
      });
    }
    function s(ie, me, Se) {
      this.stack[this.stack.length - 1].children.push(ie), this.stack.push(ie), this.tokenStack.push([me, Se || void 0]), ie.position = {
        start: zs(me.start),
        // @ts-expect-error: `end` will be patched later.
        end: void 0
      };
    }
    function u(ie) {
      return me;
      function me(Se) {
        ie && ie.call(this, Se), c.call(this, Se);
      }
    }
    function c(ie, me) {
      const Se = this.stack.pop(), je = this.tokenStack.pop();
      if (je)
        je[0].type !== ie.type && (me ? me.call(this, ie, je[0]) : (je[1] || kF).call(this, ie, je[0]));
      else throw new Error("Cannot close `" + ie.type + "` (" + Hp({
        start: ie.start,
        end: ie.end
      }) + "): its not open");
      Se.position.end = zs(ie.end);
    }
    function f() {
      return iN(this.stack.pop());
    }
    function p() {
      this.data.expectingFirstListItemValue = !0;
    }
    function g(ie) {
      if (this.data.expectingFirstListItemValue) {
        const me = this.stack[this.stack.length - 2];
        me.start = Number.parseInt(this.sliceSerialize(ie), 10), this.data.expectingFirstListItemValue = void 0;
      }
    }
    function h() {
      const ie = this.resume(), me = this.stack[this.stack.length - 1];
      me.lang = ie;
    }
    function y() {
      const ie = this.resume(), me = this.stack[this.stack.length - 1];
      me.meta = ie;
    }
    function b() {
      this.data.flowCodeInside || (this.buffer(), this.data.flowCodeInside = !0);
    }
    function v() {
      const ie = this.resume(), me = this.stack[this.stack.length - 1];
      me.value = ie.replace(/^(\r?\n|\r)|(\r?\n|\r)$/g, ""), this.data.flowCodeInside = void 0;
    }
    function w() {
      const ie = this.resume(), me = this.stack[this.stack.length - 1];
      me.value = ie.replace(/(\r?\n|\r)$/g, "");
    }
    function _(ie) {
      const me = this.resume(), Se = this.stack[this.stack.length - 1];
      Se.label = me, Se.identifier = ea(this.sliceSerialize(ie)).toLowerCase();
    }
    function k() {
      const ie = this.resume(), me = this.stack[this.stack.length - 1];
      me.title = ie;
    }
    function E() {
      const ie = this.resume(), me = this.stack[this.stack.length - 1];
      me.url = ie;
    }
    function P(ie) {
      const me = this.stack[this.stack.length - 1];
      if (!me.depth) {
        const Se = this.sliceSerialize(ie).length;
        me.depth = Se;
      }
    }
    function O() {
      this.data.setextHeadingSlurpLineEnding = !0;
    }
    function M(ie) {
      const me = this.stack[this.stack.length - 1];
      me.depth = this.sliceSerialize(ie).codePointAt(0) === 61 ? 1 : 2;
    }
    function I() {
      this.data.setextHeadingSlurpLineEnding = void 0;
    }
    function A(ie) {
      const me = this.stack[this.stack.length - 1].children;
      let Se = me[me.length - 1];
      (!Se || Se.type !== "text") && (Se = Ee(), Se.position = {
        start: zs(ie.start),
        // @ts-expect-error: well add `end` later.
        end: void 0
      }, me.push(Se)), this.stack.push(Se);
    }
    function D(ie) {
      const me = this.stack.pop();
      me.value += this.sliceSerialize(ie), me.position.end = zs(ie.end);
    }
    function F(ie) {
      const me = this.stack[this.stack.length - 1];
      if (this.data.atHardBreak) {
        const Se = me.children[me.children.length - 1];
        Se.position.end = zs(ie.end), this.data.atHardBreak = void 0;
        return;
      }
      !this.data.setextHeadingSlurpLineEnding && t.canContainEols.includes(me.type) && (A.call(this, ie), D.call(this, ie));
    }
    function j() {
      this.data.atHardBreak = !0;
    }
    function U() {
      const ie = this.resume(), me = this.stack[this.stack.length - 1];
      me.value = ie;
    }
    function $() {
      const ie = this.resume(), me = this.stack[this.stack.length - 1];
      me.value = ie;
    }
    function q() {
      const ie = this.resume(), me = this.stack[this.stack.length - 1];
      me.value = ie;
    }
    function B() {
      const ie = this.stack[this.stack.length - 1];
      if (this.data.inReference) {
        const me = this.data.referenceType || "shortcut";
        ie.type += "Reference", ie.referenceType = me, delete ie.url, delete ie.title;
      } else
        delete ie.identifier, delete ie.label;
      this.data.referenceType = void 0;
    }
    function G() {
      const ie = this.stack[this.stack.length - 1];
      if (this.data.inReference) {
        const me = this.data.referenceType || "shortcut";
        ie.type += "Reference", ie.referenceType = me, delete ie.url, delete ie.title;
      } else
        delete ie.identifier, delete ie.label;
      this.data.referenceType = void 0;
    }
    function W(ie) {
      const me = this.sliceSerialize(ie), Se = this.stack[this.stack.length - 2];
      Se.label = wLe(me), Se.identifier = ea(me).toLowerCase();
    }
    function Y() {
      const ie = this.stack[this.stack.length - 1], me = this.resume(), Se = this.stack[this.stack.length - 1];
      if (this.data.inReference = !0, Se.type === "link") {
        const je = ie.children;
        Se.children = je;
      } else
        Se.alt = me;
    }
    function z() {
      const ie = this.resume(), me = this.stack[this.stack.length - 1];
      me.url = ie;
    }
    function L() {
      const ie = this.resume(), me = this.stack[this.stack.length - 1];
      me.title = ie;
    }
    function K() {
      this.data.inReference = void 0;
    }
    function T() {
      this.data.referenceType = "collapsed";
    }
    function V(ie) {
      const me = this.resume(), Se = this.stack[this.stack.length - 1];
      Se.label = me, Se.identifier = ea(this.sliceSerialize(ie)).toLowerCase(), this.data.referenceType = "full";
    }
    function X(ie) {
      this.data.characterReferenceType = ie.type;
    }
    function Q(ie) {
      const me = this.sliceSerialize(ie), Se = this.data.characterReferenceType;
      let je;
      Se ? (je = JH(me, Se === "characterReferenceMarkerNumeric" ? 10 : 16), this.data.characterReferenceType = void 0) : je = sN(me);
      const Ae = this.stack[this.stack.length - 1];
      Ae.value += je;
    }
    function ne(ie) {
      const me = this.stack.pop();
      me.position.end = zs(ie.end);
    }
    function te(ie) {
      D.call(this, ie);
      const me = this.stack[this.stack.length - 1];
      me.url = this.sliceSerialize(ie);
    }
    function ae(ie) {
      D.call(this, ie);
      const me = this.stack[this.stack.length - 1];
      me.url = "mailto:" + this.sliceSerialize(ie);
    }
    function ce() {
      return {
        type: "blockquote",
        children: []
      };
    }
    function Z() {
      return {
        type: "code",
        lang: null,
        meta: null,
        value: ""
      };
    }
    function ee() {
      return {
        type: "inlineCode",
        value: ""
      };
    }
    function oe() {
      return {
        type: "definition",
        identifier: "",
        label: null,
        title: null,
        url: ""
      };
    }
    function le() {
      return {
        type: "emphasis",
        children: []
      };
    }
    function be() {
      return {
        type: "heading",
        // @ts-expect-error `depth` will be set later.
        depth: 0,
        children: []
      };
    }
    function ke() {
      return {
        type: "break"
      };
    }
    function De() {
      return {
        type: "html",
        value: ""
      };
    }
    function ze() {
      return {
        type: "image",
        title: null,
        url: "",
        alt: null
      };
    }
    function Ue() {
      return {
        type: "link",
        title: null,
        url: "",
        children: []
      };
    }
    function He(ie) {
      return {
        type: "list",
        ordered: ie.type === "listOrdered",
        start: null,
        spread: ie._spread,
        children: []
      };
    }
    function Pe(ie) {
      return {
        type: "listItem",
        spread: ie._spread,
        checked: null,
        children: []
      };
    }
    function It() {
      return {
        type: "paragraph",
        children: []
      };
    }
    function Xe() {
      return {
        type: "strong",
        children: []
      };
    }
    function Ee() {
      return {
        type: "text",
        value: ""
      };
    }
    function _e() {
      return {
        type: "thematicBreak"
      };
    }
  }
  function zs(e) {
    return {
      line: e.line,
      column: e.column,
      offset: e.offset
    };
  }
  function lW(e, t) {
    let n = -1;
    for (; ++n < t.length; ) {
      const r = t[n];
      Array.isArray(r) ? lW(e, r) : _Le(e, r);
    }
  }
  function _Le(e, t) {
    let n;
    for (n in t)
      if (sW.call(t, n))
        switch (n) {
          case "canContainEols": {
            const r = t[n];
            r && e[n].push(...r);
            break;
          }
          case "transforms": {
            const r = t[n];
            r && e[n].push(...r);
            break;
          }
          case "enter":
          case "exit": {
            const r = t[n];
            r && Object.assign(e[n], r);
            break;
          }
        }
  }
  function kF(e, t) {
    throw e ? new Error("Cannot close `" + e.type + "` (" + Hp({
      start: e.start,
      end: e.end
    }) + "): a different token (`" + t.type + "`, " + Hp({
      start: t.start,
      end: t.end
    }) + ") is open") : new Error("Cannot close document, a token (`" + t.type + "`, " + Hp({
      start: t.start,
      end: t.end
    }) + ") is still open");
  }
  function ELe(e) {
    const t = this;
    t.parser = n;
    function n(r) {
      return kLe(r, {
        ...t.data("settings"),
        ...e,
        // Note: these options are not in the readme.
        // The goal is for them to be set by plugins on `data` instead of being
        // passed by users.
        extensions: t.data("micromarkExtensions") || [],
        mdastExtensions: t.data("fromMarkdownExtensions") || []
      });
    }
  }
  function CLe(e, t) {
    const n = {
      type: "element",
      tagName: "blockquote",
      properties: {},
      children: e.wrap(e.all(t), !0)
    };
    return e.patch(t, n), e.applyData(t, n);
  }
  function PLe(e, t) {
    const n = { type: "element", tagName: "br", properties: {}, children: [] };
    return e.patch(t, n), [e.applyData(t, n), { type: "text", value: `
` }];
  }
  function OLe(e, t) {
    const n = t.value ? t.value + `
` : "", r = {};
    t.lang && (r.className = ["language-" + t.lang]);
    let o = {
      type: "element",
      tagName: "code",
      properties: r,
      children: [{ type: "text", value: n }]
    };
    return t.meta && (o.data = { meta: t.meta }), e.patch(t, o), o = e.applyData(t, o), o = { type: "element", tagName: "pre", properties: {}, children: [o] }, e.patch(t, o), o;
  }
  function NLe(e, t) {
    const n = {
      type: "element",
      tagName: "del",
      properties: {},
      children: e.all(t)
    };
    return e.patch(t, n), e.applyData(t, n);
  }
  function MLe(e, t) {
    const n = {
      type: "element",
      tagName: "em",
      properties: {},
      children: e.all(t)
    };
    return e.patch(t, n), e.applyData(t, n);
  }
  function RLe(e, t) {
    const n = typeof e.options.clobberPrefix == "string" ? e.options.clobberPrefix : "user-content-", r = String(t.identifier).toUpperCase(), o = Gd(r.toLowerCase()), a = e.footnoteOrder.indexOf(r);
    let i, s = e.footnoteCounts.get(r);
    s === void 0 ? (s = 0, e.footnoteOrder.push(r), i = e.footnoteOrder.length) : i = a + 1, s += 1, e.footnoteCounts.set(r, s);
    const u = {
      type: "element",
      tagName: "a",
      properties: {
        href: "#" + n + "fn-" + o,
        id: n + "fnref-" + o + (s > 1 ? "-" + s : ""),
        dataFootnoteRef: !0,
        ariaDescribedBy: ["footnote-label"]
      },
      children: [{ type: "text", value: String(i) }]
    };
    e.patch(t, u);
    const c = {
      type: "element",
      tagName: "sup",
      properties: {},
      children: [u]
    };
    return e.patch(t, c), e.applyData(t, c);
  }
  function jLe(e, t) {
    const n = {
      type: "element",
      tagName: "h" + t.depth,
      properties: {},
      children: e.all(t)
    };
    return e.patch(t, n), e.applyData(t, n);
  }
  function ILe(e, t) {
    if (e.options.allowDangerousHtml) {
      const n = { type: "raw", value: t.value };
      return e.patch(t, n), e.applyData(t, n);
    }
  }
  function uW(e, t) {
    const n = t.referenceType;
    let r = "]";
    if (n === "collapsed" ? r += "[]" : n === "full" && (r += "[" + (t.label || t.identifier) + "]"), t.type === "imageReference")
      return [{ type: "text", value: "![" + t.alt + r }];
    const o = e.all(t), a = o[0];
    a && a.type === "text" ? a.value = "[" + a.value : o.unshift({ type: "text", value: "[" });
    const i = o[o.length - 1];
    return i && i.type === "text" ? i.value += r : o.push({ type: "text", value: r }), o;
  }
  function ALe(e, t) {
    const n = String(t.identifier).toUpperCase(), r = e.definitionById.get(n);
    if (!r)
      return uW(e, t);
    const o = { src: Gd(r.url || ""), alt: t.alt };
    r.title !== null && r.title !== void 0 && (o.title = r.title);
    const a = { type: "element", tagName: "img", properties: o, children: [] };
    return e.patch(t, a), e.applyData(t, a);
  }
  function $Le(e, t) {
    const n = { src: Gd(t.url) };
    t.alt !== null && t.alt !== void 0 && (n.alt = t.alt), t.title !== null && t.title !== void 0 && (n.title = t.title);
    const r = { type: "element", tagName: "img", properties: n, children: [] };
    return e.patch(t, r), e.applyData(t, r);
  }
  function DLe(e, t) {
    const n = { type: "text", value: t.value.replace(/\r?\n|\r/g, " ") };
    e.patch(t, n);
    const r = {
      type: "element",
      tagName: "code",
      properties: {},
      children: [n]
    };
    return e.patch(t, r), e.applyData(t, r);
  }
  function LLe(e, t) {
    const n = String(t.identifier).toUpperCase(), r = e.definitionById.get(n);
    if (!r)
      return uW(e, t);
    const o = { href: Gd(r.url || "") };
    r.title !== null && r.title !== void 0 && (o.title = r.title);
    const a = {
      type: "element",
      tagName: "a",
      properties: o,
      children: e.all(t)
    };
    return e.patch(t, a), e.applyData(t, a);
  }
  function FLe(e, t) {
    const n = { href: Gd(t.url) };
    t.title !== null && t.title !== void 0 && (n.title = t.title);
    const r = {
      type: "element",
      tagName: "a",
      properties: n,
      children: e.all(t)
    };
    return e.patch(t, r), e.applyData(t, r);
  }
  function TLe(e, t, n) {
    const r = e.all(t), o = n ? zLe(n) : cW(t), a = {}, i = [];
    if (typeof t.checked == "boolean") {
      const f = r[0];
      let p;
      f && f.type === "element" && f.tagName === "p" ? p = f : (p = { type: "element", tagName: "p", properties: {}, children: [] }, r.unshift(p)), p.children.length > 0 && p.children.unshift({ type: "text", value: " " }), p.children.unshift({
        type: "element",
        tagName: "input",
        properties: { type: "checkbox", checked: t.checked, disabled: !0 },
        children: []
      }), a.className = ["task-list-item"];
    }
    let s = -1;
    for (; ++s < r.length; ) {
      const f = r[s];
      (o || s !== 0 || f.type !== "element" || f.tagName !== "p") && i.push({ type: "text", value: `
` }), f.type === "element" && f.tagName === "p" && !o ? i.push(...f.children) : i.push(f);
    }
    const u = r[r.length - 1];
    u && (o || u.type !== "element" || u.tagName !== "p") && i.push({ type: "text", value: `
` });
    const c = { type: "element", tagName: "li", properties: a, children: i };
    return e.patch(t, c), e.applyData(t, c);
  }
  function zLe(e) {
    let t = !1;
    if (e.type === "list") {
      t = e.spread || !1;
      const n = e.children;
      let r = -1;
      for (; !t && ++r < n.length; )
        t = cW(n[r]);
    }
    return t;
  }
  function cW(e) {
    return e.spread ?? e.children.length > 1;
  }
  function BLe(e, t) {
    const n = {}, r = e.all(t);
    let o = -1;
    for (typeof t.start == "number" && t.start !== 1 && (n.start = t.start); ++o < r.length; ) {
      const i = r[o];
      if (i.type === "element" && i.tagName === "li" && i.properties && Array.isArray(i.properties.className) && i.properties.className.includes("task-list-item")) {
        n.className = ["contains-task-list"];
        break;
      }
    }
    const a = {
      type: "element",
      tagName: t.ordered ? "ol" : "ul",
      properties: n,
      children: e.wrap(r, !0)
    };
    return e.patch(t, a), e.applyData(t, a);
  }
  function VLe(e, t) {
    const n = {
      type: "element",
      tagName: "p",
      properties: {},
      children: e.all(t)
    };
    return e.patch(t, n), e.applyData(t, n);
  }
  function ULe(e, t) {
    const n = { type: "root", children: e.wrap(e.all(t)) };
    return e.patch(t, n), e.applyData(t, n);
  }
  function HLe(e, t) {
    const n = {
      type: "element",
      tagName: "strong",
      properties: {},
      children: e.all(t)
    };
    return e.patch(t, n), e.applyData(t, n);
  }
  function WLe(e, t) {
    const n = e.all(t), r = n.shift(), o = [];
    if (r) {
      const i = {
        type: "element",
        tagName: "thead",
        properties: {},
        children: e.wrap([r], !0)
      };
      e.patch(t.children[0], i), o.push(i);
    }
    if (n.length > 0) {
      const i = {
        type: "element",
        tagName: "tbody",
        properties: {},
        children: e.wrap(n, !0)
      }, s = nN(t.children[1]), u = UH(t.children[t.children.length - 1]);
      s && u && (i.position = { start: s, end: u }), o.push(i);
    }
    const a = {
      type: "element",
      tagName: "table",
      properties: {},
      children: e.wrap(o, !0)
    };
    return e.patch(t, a), e.applyData(t, a);
  }
  function qLe(e, t, n) {
    const r = n ? n.children : void 0, o = (r ? r.indexOf(t) : 1) === 0 ? "th" : "td", a = n && n.type === "table" ? n.align : void 0, i = a ? a.length : t.children.length;
    let s = -1;
    const u = [];
    for (; ++s < i; ) {
      const f = t.children[s], p = {}, g = a ? a[s] : void 0;
      g && (p.align = g);
      let h = { type: "element", tagName: o, properties: p, children: [] };
      f && (h.children = e.all(f), e.patch(f, h), h = e.applyData(f, h)), u.push(h);
    }
    const c = {
      type: "element",
      tagName: "tr",
      properties: {},
      children: e.wrap(u, !0)
    };
    return e.patch(t, c), e.applyData(t, c);
  }
  function KLe(e, t) {
    const n = {
      type: "element",
      tagName: "td",
      // Assume body cell.
      properties: {},
      children: e.all(t)
    };
    return e.patch(t, n), e.applyData(t, n);
  }
  const SF = 9, _F = 32;
  function GLe(e) {
    const t = String(e), n = /\r?\n|\r/g;
    let r = n.exec(t), o = 0;
    const a = [];
    for (; r; )
      a.push(
        EF(t.slice(o, r.index), o > 0, !0),
        r[0]
      ), o = r.index + r[0].length, r = n.exec(t);
    return a.push(EF(t.slice(o), o > 0, !1)), a.join("");
  }
  function EF(e, t, n) {
    let r = 0, o = e.length;
    if (t) {
      let a = e.codePointAt(r);
      for (; a === SF || a === _F; )
        r++, a = e.codePointAt(r);
    }
    if (n) {
      let a = e.codePointAt(o - 1);
      for (; a === SF || a === _F; )
        o--, a = e.codePointAt(o - 1);
    }
    return o > r ? e.slice(r, o) : "";
  }
  function XLe(e, t) {
    const n = { type: "text", value: GLe(String(t.value)) };
    return e.patch(t, n), e.applyData(t, n);
  }
  function YLe(e, t) {
    const n = {
      type: "element",
      tagName: "hr",
      properties: {},
      children: []
    };
    return e.patch(t, n), e.applyData(t, n);
  }
  const JLe = {
    blockquote: CLe,
    break: PLe,
    code: OLe,
    delete: NLe,
    emphasis: MLe,
    footnoteReference: RLe,
    heading: jLe,
    html: ILe,
    imageReference: ALe,
    image: $Le,
    inlineCode: DLe,
    linkReference: LLe,
    link: FLe,
    listItem: TLe,
    list: BLe,
    paragraph: VLe,
    // @ts-expect-error: root is different, but hard to type.
    root: ULe,
    strong: HLe,
    table: WLe,
    tableCell: KLe,
    tableRow: qLe,
    text: XLe,
    thematicBreak: YLe,
    toml: yy,
    yaml: yy,
    definition: yy,
    footnoteDefinition: yy
  };
  function yy() {
  }
  const dW = -1, Fx = 0, qp = 1, Kb = 2, uN = 3, cN = 4, dN = 5, fN = 6, fW = 7, pW = 8, CF = typeof self == "object" ? self : globalThis, QLe = (e, t) => {
    const n = (o, a) => (e.set(a, o), o), r = (o) => {
      if (e.has(o))
        return e.get(o);
      const [a, i] = t[o];
      switch (a) {
        case Fx:
        case dW:
          return n(i, o);
        case qp: {
          const s = n([], o);
          for (const u of i)
            s.push(r(u));
          return s;
        }
        case Kb: {
          const s = n({}, o);
          for (const [u, c] of i)
            s[r(u)] = r(c);
          return s;
        }
        case uN:
          return n(new Date(i), o);
        case cN: {
          const { source: s, flags: u } = i;
          return n(new RegExp(s, u), o);
        }
        case dN: {
          const s = n(/* @__PURE__ */ new Map(), o);
          for (const [u, c] of i)
            s.set(r(u), r(c));
          return s;
        }
        case fN: {
          const s = n(/* @__PURE__ */ new Set(), o);
          for (const u of i)
            s.add(r(u));
          return s;
        }
        case fW: {
          const { name: s, message: u } = i;
          return n(new CF[s](u), o);
        }
        case pW:
          return n(BigInt(i), o);
        case "BigInt":
          return n(Object(BigInt(i)), o);
        case "ArrayBuffer":
          return n(new Uint8Array(i).buffer, i);
        case "DataView": {
          const { buffer: s } = new Uint8Array(i);
          return n(new DataView(s), i);
        }
      }
      return n(new CF[a](i), o);
    };
    return r;
  }, PF = (e) => QLe(/* @__PURE__ */ new Map(), e)(0), Fc = "", { toString: ZLe } = {}, { keys: eFe } = Object, fp = (e) => {
    const t = typeof e;
    if (t !== "object" || !e)
      return [Fx, t];
    const n = ZLe.call(e).slice(8, -1);
    switch (n) {
      case "Array":
        return [qp, Fc];
      case "Object":
        return [Kb, Fc];
      case "Date":
        return [uN, Fc];
      case "RegExp":
        return [cN, Fc];
      case "Map":
        return [dN, Fc];
      case "Set":
        return [fN, Fc];
      case "DataView":
        return [qp, n];
    }
    return n.includes("Array") ? [qp, n] : n.includes("Error") ? [fW, n] : [Kb, n];
  }, by = ([e, t]) => e === Fx && (t === "function" || t === "symbol"), tFe = (e, t, n, r) => {
    const o = (i, s) => {
      const u = r.push(i) - 1;
      return n.set(s, u), u;
    }, a = (i) => {
      if (n.has(i))
        return n.get(i);
      let [s, u] = fp(i);
      switch (s) {
        case Fx: {
          let f = i;
          switch (u) {
            case "bigint":
              s = pW, f = i.toString();
              break;
            case "function":
            case "symbol":
              if (e)
                throw new TypeError("unable to serialize " + u);
              f = null;
              break;
            case "undefined":
              return o([dW], i);
          }
          return o([s, f], i);
        }
        case qp: {
          if (u) {
            let g = i;
            return u === "DataView" ? g = new Uint8Array(i.buffer) : u === "ArrayBuffer" && (g = new Uint8Array(i)), o([u, [...g]], i);
          }
          const f = [], p = o([s, f], i);
          for (const g of i)
            f.push(a(g));
          return p;
        }
        case Kb: {
          if (u)
            switch (u) {
              case "BigInt":
                return o([u, i.toString()], i);
              case "Boolean":
              case "Number":
              case "String":
                return o([u, i.valueOf()], i);
            }
          if (t && "toJSON" in i)
            return a(i.toJSON());
          const f = [], p = o([s, f], i);
          for (const g of eFe(i))
            (e || !by(fp(i[g]))) && f.push([a(g), a(i[g])]);
          return p;
        }
        case uN:
          return o([s, i.toISOString()], i);
        case cN: {
          const { source: f, flags: p } = i;
          return o([s, { source: f, flags: p }], i);
        }
        case dN: {
          const f = [], p = o([s, f], i);
          for (const [g, h] of i)
            (e || !(by(fp(g)) || by(fp(h)))) && f.push([a(g), a(h)]);
          return p;
        }
        case fN: {
          const f = [], p = o([s, f], i);
          for (const g of i)
            (e || !by(fp(g))) && f.push(a(g));
          return p;
        }
      }
      const { message: c } = i;
      return o([s, { name: u, message: c }], i);
    };
    return a;
  }, OF = (e, { json: t, lossy: n } = {}) => {
    const r = [];
    return tFe(!(t || n), !!t, /* @__PURE__ */ new Map(), r)(e), r;
  }, Gb = typeof structuredClone == "function" ? (
    /* c8 ignore start */
    ((e, t) => t && ("json" in t || "lossy" in t) ? PF(OF(e, t)) : structuredClone(e))
  ) : (e, t) => PF(OF(e, t));
  function nFe(e, t) {
    const n = [{ type: "text", value: "" }];
    return t > 1 && n.push({
      type: "element",
      tagName: "sup",
      properties: {},
      children: [{ type: "text", value: String(t) }]
    }), n;
  }
  function rFe(e, t) {
    return "Back to reference " + (e + 1) + (t > 1 ? "-" + t : "");
  }
  function oFe(e) {
    const t = typeof e.options.clobberPrefix == "string" ? e.options.clobberPrefix : "user-content-", n = e.options.footnoteBackContent || nFe, r = e.options.footnoteBackLabel || rFe, o = e.options.footnoteLabel || "Footnotes", a = e.options.footnoteLabelTagName || "h2", i = e.options.footnoteLabelProperties || {
      className: ["sr-only"]
    }, s = [];
    let u = -1;
    for (; ++u < e.footnoteOrder.length; ) {
      const c = e.footnoteById.get(
        e.footnoteOrder[u]
      );
      if (!c)
        continue;
      const f = e.all(c), p = String(c.identifier).toUpperCase(), g = Gd(p.toLowerCase());
      let h = 0;
      const y = [], b = e.footnoteCounts.get(p);
      for (; b !== void 0 && ++h <= b; ) {
        y.length > 0 && y.push({ type: "text", value: " " });
        let _ = typeof n == "string" ? n : n(u, h);
        typeof _ == "string" && (_ = { type: "text", value: _ }), y.push({
          type: "element",
          tagName: "a",
          properties: {
            href: "#" + t + "fnref-" + g + (h > 1 ? "-" + h : ""),
            dataFootnoteBackref: "",
            ariaLabel: typeof r == "string" ? r : r(u, h),
            className: ["data-footnote-backref"]
          },
          children: Array.isArray(_) ? _ : [_]
        });
      }
      const v = f[f.length - 1];
      if (v && v.type === "element" && v.tagName === "p") {
        const _ = v.children[v.children.length - 1];
        _ && _.type === "text" ? _.value += " " : v.children.push({ type: "text", value: " " }), v.children.push(...y);
      } else
        f.push(...y);
      const w = {
        type: "element",
        tagName: "li",
        properties: { id: t + "fn-" + g },
        children: e.wrap(f, !0)
      };
      e.patch(c, w), s.push(w);
    }
    if (s.length !== 0)
      return {
        type: "element",
        tagName: "section",
        properties: { dataFootnotes: !0, className: ["footnotes"] },
        children: [
          {
            type: "element",
            tagName: a,
            properties: {
              ...Gb(i),
              id: "footnote-label"
            },
            children: [{ type: "text", value: o }]
          },
          { type: "text", value: `
` },
          {
            type: "element",
            tagName: "ol",
            properties: {},
            children: e.wrap(s, !0)
          },
          { type: "text", value: `
` }
        ]
      };
  }
  const Tx = (
    // Note: overloads in JSDoc cant yet use different `@template`s.
    /**
     * @type {(
     *   (<Condition extends string>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & {type: Condition}) &
     *   (<Condition extends Props>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & Condition) &
     *   (<Condition extends TestFunction>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & Predicate<Condition, Node>) &
     *   ((test?: null | undefined) => (node?: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node) &
     *   ((test?: Test) => Check)
     * )}
     */
    /**
     * @param {Test} [test]
     * @returns {Check}
     */
    (function(e) {
      if (e == null)
        return lFe;
      if (typeof e == "function")
        return zx(e);
      if (typeof e == "object")
        return Array.isArray(e) ? aFe(e) : iFe(e);
      if (typeof e == "string")
        return sFe(e);
      throw new Error("Expected function, string, or object as test");
    })
  );
  function aFe(e) {
    const t = [];
    let n = -1;
    for (; ++n < e.length; )
      t[n] = Tx(e[n]);
    return zx(r);
    function r(...o) {
      let a = -1;
      for (; ++a < t.length; )
        if (t[a].apply(this, o)) return !0;
      return !1;
    }
  }
  function iFe(e) {
    const t = (
      /** @type {Record<string, unknown>} */
      e
    );
    return zx(n);
    function n(r) {
      const o = (
        /** @type {Record<string, unknown>} */
        /** @type {unknown} */
        r
      );
      let a;
      for (a in e)
        if (o[a] !== t[a]) return !1;
      return !0;
    }
  }
  function sFe(e) {
    return zx(t);
    function t(n) {
      return n && n.type === e;
    }
  }
  function zx(e) {
    return t;
    function t(n, r, o) {
      return !!(uFe(n) && e.call(
        this,
        n,
        typeof r == "number" ? r : void 0,
        o || void 0
      ));
    }
  }
  function lFe() {
    return !0;
  }
  function uFe(e) {
    return e !== null && typeof e == "object" && "type" in e;
  }
  const mW = [], cFe = !0, DE = !1, dFe = "skip";
  function hW(e, t, n, r) {
    let o;
    typeof t == "function" && typeof n != "function" ? (r = n, n = t) : o = t;
    const a = Tx(o), i = r ? -1 : 1;
    s(e, void 0, [])();
    function s(u, c, f) {
      const p = (
        /** @type {Record<string, unknown>} */
        u && typeof u == "object" ? u : {}
      );
      if (typeof p.type == "string") {
        const h = (
          // `hast`
          typeof p.tagName == "string" ? p.tagName : (
            // `xast`
            typeof p.name == "string" ? p.name : void 0
          )
        );
        Object.defineProperty(g, "name", {
          value: "node (" + (u.type + (h ? "<" + h + ">" : "")) + ")"
        });
      }
      return g;
      function g() {
        let h = mW, y, b, v;
        if ((!t || a(u, c, f[f.length - 1] || void 0)) && (h = fFe(n(u, f)), h[0] === DE))
          return h;
        if ("children" in u && u.children) {
          const w = (
            /** @type {UnistParent} */
            u
          );
          if (w.children && h[0] !== dFe)
            for (b = (r ? w.children.length : -1) + i, v = f.concat(w); b > -1 && b < w.children.length; ) {
              const _ = w.children[b];
              if (y = s(_, b, v)(), y[0] === DE)
                return y;
              b = typeof y[1] == "number" ? y[1] : b + i;
            }
        }
        return h;
      }
    }
  }
  function fFe(e) {
    return Array.isArray(e) ? e : typeof e == "number" ? [cFe, e] : e == null ? mW : [e];
  }
  function pN(e, t, n, r) {
    let o, a, i;
    typeof t == "function" && typeof n != "function" ? (a = void 0, i = t, o = n) : (a = t, i = n, o = r), hW(e, a, s, o);
    function s(u, c) {
      const f = c[c.length - 1], p = f ? f.children.indexOf(u) : void 0;
      return i(u, p, f);
    }
  }
  const LE = {}.hasOwnProperty, pFe = {};
  function mFe(e, t) {
    const n = t || pFe, r = /* @__PURE__ */ new Map(), o = /* @__PURE__ */ new Map(), a = /* @__PURE__ */ new Map(), i = { ...JLe, ...n.handlers }, s = {
      all: c,
      applyData: gFe,
      definitionById: r,
      footnoteById: o,
      footnoteCounts: a,
      footnoteOrder: [],
      handlers: i,
      one: u,
      options: n,
      patch: hFe,
      wrap: yFe
    };
    return pN(e, function(f) {
      if (f.type === "definition" || f.type === "footnoteDefinition") {
        const p = f.type === "definition" ? r : o, g = String(f.identifier).toUpperCase();
        p.has(g) || p.set(g, f);
      }
    }), s;
    function u(f, p) {
      const g = f.type, h = s.handlers[g];
      if (LE.call(s.handlers, g) && h)
        return h(s, f, p);
      if (s.options.passThrough && s.options.passThrough.includes(g)) {
        if ("children" in f) {
          const { children: y, ...b } = f, v = Gb(b);
          return v.children = s.all(f), v;
        }
        return Gb(f);
      }
      return (s.options.unknownHandler || vFe)(s, f, p);
    }
    function c(f) {
      const p = [];
      if ("children" in f) {
        const g = f.children;
        let h = -1;
        for (; ++h < g.length; ) {
          const y = s.one(g[h], f);
          if (y) {
            if (h && g[h - 1].type === "break" && (!Array.isArray(y) && y.type === "text" && (y.value = NF(y.value)), !Array.isArray(y) && y.type === "element")) {
              const b = y.children[0];
              b && b.type === "text" && (b.value = NF(b.value));
            }
            Array.isArray(y) ? p.push(...y) : p.push(y);
          }
        }
      }
      return p;
    }
  }
  function hFe(e, t) {
    e.position && (t.position = r4e(e));
  }
  function gFe(e, t) {
    let n = t;
    if (e && e.data) {
      const r = e.data.hName, o = e.data.hChildren, a = e.data.hProperties;
      if (typeof r == "string")
        if (n.type === "element")
          n.tagName = r;
        else {
          const i = "children" in n ? n.children : [n];
          n = { type: "element", tagName: r, properties: {}, children: i };
        }
      n.type === "element" && a && Object.assign(n.properties, Gb(a)), "children" in n && n.children && o !== null && o !== void 0 && (n.children = o);
    }
    return n;
  }
  function vFe(e, t) {
    const n = t.data || {}, r = "value" in t && !(LE.call(n, "hProperties") || LE.call(n, "hChildren")) ? { type: "text", value: t.value } : {
      type: "element",
      tagName: "div",
      properties: {},
      children: e.all(t)
    };
    return e.patch(t, r), e.applyData(t, r);
  }
  function yFe(e, t) {
    const n = [];
    let r = -1;
    for (t && n.push({ type: "text", value: `
` }); ++r < e.length; )
      r && n.push({ type: "text", value: `
` }), n.push(e[r]);
    return t && e.length > 0 && n.push({ type: "text", value: `
` }), n;
  }
  function NF(e) {
    let t = 0, n = e.charCodeAt(t);
    for (; n === 9 || n === 32; )
      t++, n = e.charCodeAt(t);
    return e.slice(t);
  }
  function MF(e, t) {
    const n = mFe(e, t), r = n.one(e, void 0), o = oFe(n), a = Array.isArray(r) ? { type: "root", children: r } : r || { type: "root", children: [] };
    return o && a.children.push({ type: "text", value: `
` }, o), a;
  }
  function bFe(e, t) {
    return e && "run" in e ? async function(n, r) {
      const o = (
        /** @type {HastRoot} */
        MF(n, { file: r, ...t })
      );
      await e.run(o, r);
    } : function(n, r) {
      return (
        /** @type {HastRoot} */
        MF(n, { file: r, ...e || t })
      );
    };
  }
  function RF(e) {
    if (e)
      throw e;
  }
  var z0, jF;
  function wFe() {
    if (jF) return z0;
    jF = 1;
    var e = Object.prototype.hasOwnProperty, t = Object.prototype.toString, n = Object.defineProperty, r = Object.getOwnPropertyDescriptor, o = function(u) {
      return typeof Array.isArray == "function" ? Array.isArray(u) : t.call(u) === "[object Array]";
    }, a = function(u) {
      if (!u || t.call(u) !== "[object Object]")
        return !1;
      var c = e.call(u, "constructor"), f = u.constructor && u.constructor.prototype && e.call(u.constructor.prototype, "isPrototypeOf");
      if (u.constructor && !c && !f)
        return !1;
      var p;
      for (p in u)
        ;
      return typeof p > "u" || e.call(u, p);
    }, i = function(u, c) {
      n && c.name === "__proto__" ? n(u, c.name, {
        enumerable: !0,
        configurable: !0,
        value: c.newValue,
        writable: !0
      }) : u[c.name] = c.newValue;
    }, s = function(u, c) {
      if (c === "__proto__")
        if (e.call(u, c)) {
          if (r)
            return r(u, c).value;
        } else return;
      return u[c];
    };
    return z0 = function u() {
      var c, f, p, g, h, y, b = arguments[0], v = 1, w = arguments.length, _ = !1;
      for (typeof b == "boolean" && (_ = b, b = arguments[1] || {}, v = 2), (b == null || typeof b != "object" && typeof b != "function") && (b = {}); v < w; ++v)
        if (c = arguments[v], c != null)
          for (f in c)
            p = s(b, f), g = s(c, f), b !== g && (_ && g && (a(g) || (h = o(g))) ? (h ? (h = !1, y = p && o(p) ? p : []) : y = p && a(p) ? p : {}, i(b, { name: f, newValue: u(_, y, g) })) : typeof g < "u" && i(b, { name: f, newValue: g }));
      return b;
    }, z0;
  }
  var xFe = wFe();
  const B0 = /* @__PURE__ */ Qi(xFe);
  function FE(e) {
    if (typeof e != "object" || e === null)
      return !1;
    const t = Object.getPrototypeOf(e);
    return (t === null || t === Object.prototype || Object.getPrototypeOf(t) === null) && !(Symbol.toStringTag in e) && !(Symbol.iterator in e);
  }
  function kFe() {
    const e = [], t = { run: n, use: r };
    return t;
    function n(...o) {
      let a = -1;
      const i = o.pop();
      if (typeof i != "function")
        throw new TypeError("Expected function as last argument, not " + i);
      s(null, ...o);
      function s(u, ...c) {
        const f = e[++a];
        let p = -1;
        if (u) {
          i(u);
          return;
        }
        for (; ++p < o.length; )
          (c[p] === null || c[p] === void 0) && (c[p] = o[p]);
        o = c, f ? SFe(f, s)(...c) : i(null, ...c);
      }
    }
    function r(o) {
      if (typeof o != "function")
        throw new TypeError(
          "Expected `middelware` to be a function, not " + o
        );
      return e.push(o), t;
    }
  }
  function SFe(e, t) {
    let n;
    return r;
    function r(...i) {
      const s = e.length > i.length;
      let u;
      s && i.push(o);
      try {
        u = e.apply(this, i);
      } catch (c) {
        const f = (
          /** @type {Error} */
          c
        );
        if (s && n)
          throw f;
        return o(f);
      }
      s || (u && u.then && typeof u.then == "function" ? u.then(a, o) : u instanceof Error ? o(u) : a(u));
    }
    function o(i, ...s) {
      n || (n = !0, t(i, ...s));
    }
    function a(i) {
      o(null, i);
    }
  }
  const Sa = { basename: _Fe, dirname: EFe, extname: CFe, join: PFe, sep: "/" };
  function _Fe(e, t) {
    if (t !== void 0 && typeof t != "string")
      throw new TypeError('"ext" argument must be a string');
    _h(e);
    let n = 0, r = -1, o = e.length, a;
    if (t === void 0 || t.length === 0 || t.length > e.length) {
      for (; o--; )
        if (e.codePointAt(o) === 47) {
          if (a) {
            n = o + 1;
            break;
          }
        } else r < 0 && (a = !0, r = o + 1);
      return r < 0 ? "" : e.slice(n, r);
    }
    if (t === e)
      return "";
    let i = -1, s = t.length - 1;
    for (; o--; )
      if (e.codePointAt(o) === 47) {
        if (a) {
          n = o + 1;
          break;
        }
      } else
        i < 0 && (a = !0, i = o + 1), s > -1 && (e.codePointAt(o) === t.codePointAt(s--) ? s < 0 && (r = o) : (s = -1, r = i));
    return n === r ? r = i : r < 0 && (r = e.length), e.slice(n, r);
  }
  function EFe(e) {
    if (_h(e), e.length === 0)
      return ".";
    let t = -1, n = e.length, r;
    for (; --n; )
      if (e.codePointAt(n) === 47) {
        if (r) {
          t = n;
          break;
        }
      } else r || (r = !0);
    return t < 0 ? e.codePointAt(0) === 47 ? "/" : "." : t === 1 && e.codePointAt(0) === 47 ? "//" : e.slice(0, t);
  }
  function CFe(e) {
    _h(e);
    let t = e.length, n = -1, r = 0, o = -1, a = 0, i;
    for (; t--; ) {
      const s = e.codePointAt(t);
      if (s === 47) {
        if (i) {
          r = t + 1;
          break;
        }
        continue;
      }
      n < 0 && (i = !0, n = t + 1), s === 46 ? o < 0 ? o = t : a !== 1 && (a = 1) : o > -1 && (a = -1);
    }
    return o < 0 || n < 0 || // We saw a non-dot character immediately before the dot.
    a === 0 || // The (right-most) trimmed path component is exactly `..`.
    a === 1 && o === n - 1 && o === r + 1 ? "" : e.slice(o, n);
  }
  function PFe(...e) {
    let t = -1, n;
    for (; ++t < e.length; )
      _h(e[t]), e[t] && (n = n === void 0 ? e[t] : n + "/" + e[t]);
    return n === void 0 ? "." : OFe(n);
  }
  function OFe(e) {
    _h(e);
    const t = e.codePointAt(0) === 47;
    let n = NFe(e, !t);
    return n.length === 0 && !t && (n = "."), n.length > 0 && e.codePointAt(e.length - 1) === 47 && (n += "/"), t ? "/" + n : n;
  }
  function NFe(e, t) {
    let n = "", r = 0, o = -1, a = 0, i = -1, s, u;
    for (; ++i <= e.length; ) {
      if (i < e.length)
        s = e.codePointAt(i);
      else {
        if (s === 47)
          break;
        s = 47;
      }
      if (s === 47) {
        if (!(o === i - 1 || a === 1)) if (o !== i - 1 && a === 2) {
          if (n.length < 2 || r !== 2 || n.codePointAt(n.length - 1) !== 46 || n.codePointAt(n.length - 2) !== 46) {
            if (n.length > 2) {
              if (u = n.lastIndexOf("/"), u !== n.length - 1) {
                u < 0 ? (n = "", r = 0) : (n = n.slice(0, u), r = n.length - 1 - n.lastIndexOf("/")), o = i, a = 0;
                continue;
              }
            } else if (n.length > 0) {
              n = "", r = 0, o = i, a = 0;
              continue;
            }
          }
          t && (n = n.length > 0 ? n + "/.." : "..", r = 2);
        } else
          n.length > 0 ? n += "/" + e.slice(o + 1, i) : n = e.slice(o + 1, i), r = i - o - 1;
        o = i, a = 0;
      } else s === 46 && a > -1 ? a++ : a = -1;
    }
    return n;
  }
  function _h(e) {
    if (typeof e != "string")
      throw new TypeError(
        "Path must be a string. Received " + JSON.stringify(e)
      );
  }
  const MFe = { cwd: RFe };
  function RFe() {
    return "/";
  }
  function TE(e) {
    return !!(e !== null && typeof e == "object" && "href" in e && e.href && "protocol" in e && e.protocol && // @ts-expect-error: indexing is fine.
    e.auth === void 0);
  }
  function jFe(e) {
    if (typeof e == "string")
      e = new URL(e);
    else if (!TE(e)) {
      const t = new TypeError(
        'The "path" argument must be of type string or an instance of URL. Received `' + e + "`"
      );
      throw t.code = "ERR_INVALID_ARG_TYPE", t;
    }
    if (e.protocol !== "file:") {
      const t = new TypeError("The URL must be of scheme file");
      throw t.code = "ERR_INVALID_URL_SCHEME", t;
    }
    return IFe(e);
  }
  function IFe(e) {
    if (e.hostname !== "") {
      const r = new TypeError(
        'File URL host must be "localhost" or empty on darwin'
      );
      throw r.code = "ERR_INVALID_FILE_URL_HOST", r;
    }
    const t = e.pathname;
    let n = -1;
    for (; ++n < t.length; )
      if (t.codePointAt(n) === 37 && t.codePointAt(n + 1) === 50) {
        const r = t.codePointAt(n + 2);
        if (r === 70 || r === 102) {
          const o = new TypeError(
            "File URL path must not include encoded / characters"
          );
          throw o.code = "ERR_INVALID_FILE_URL_PATH", o;
        }
      }
    return decodeURIComponent(t);
  }
  const V0 = (
    /** @type {const} */
    [
      "history",
      "path",
      "basename",
      "stem",
      "extname",
      "dirname"
    ]
  );
  class gW {
    /**
     * Create a new virtual file.
     *
     * `options` is treated as:
     *
     * *   `string` or `Uint8Array`  `{value: options}`
     * *   `URL`  `{path: options}`
     * *   `VFile`  shallow copies its data over to the new file
     * *   `object`  all fields are shallow copied over to the new file
     *
     * Path related fields are set in the following order (least specific to
     * most specific): `history`, `path`, `basename`, `stem`, `extname`,
     * `dirname`.
     *
     * You cannot set `dirname` or `extname` without setting either `history`,
     * `path`, `basename`, or `stem` too.
     *
     * @param {Compatible | null | undefined} [value]
     *   File value.
     * @returns
     *   New instance.
     */
    constructor(t) {
      let n;
      t ? TE(t) ? n = { path: t } : typeof t == "string" || AFe(t) ? n = { value: t } : n = t : n = {}, this.cwd = "cwd" in n ? "" : MFe.cwd(), this.data = {}, this.history = [], this.messages = [], this.value, this.map, this.result, this.stored;
      let r = -1;
      for (; ++r < V0.length; ) {
        const a = V0[r];
        a in n && n[a] !== void 0 && n[a] !== null && (this[a] = a === "history" ? [...n[a]] : n[a]);
      }
      let o;
      for (o in n)
        V0.includes(o) || (this[o] = n[o]);
    }
    /**
     * Get the basename (including extname) (example: `'index.min.js'`).
     *
     * @returns {string | undefined}
     *   Basename.
     */
    get basename() {
      return typeof this.path == "string" ? Sa.basename(this.path) : void 0;
    }
    /**
     * Set basename (including extname) (`'index.min.js'`).
     *
     * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\'`
     * on windows).
     * Cannot be nullified (use `file.path = file.dirname` instead).
     *
     * @param {string} basename
     *   Basename.
     * @returns {undefined}
     *   Nothing.
     */
    set basename(t) {
      H0(t, "basename"), U0(t, "basename"), this.path = Sa.join(this.dirname || "", t);
    }
    /**
     * Get the parent path (example: `'~'`).
     *
     * @returns {string | undefined}
     *   Dirname.
     */
    get dirname() {
      return typeof this.path == "string" ? Sa.dirname(this.path) : void 0;
    }
    /**
     * Set the parent path (example: `'~'`).
     *
     * Cannot be set if theres no `path` yet.
     *
     * @param {string | undefined} dirname
     *   Dirname.
     * @returns {undefined}
     *   Nothing.
     */
    set dirname(t) {
      IF(this.basename, "dirname"), this.path = Sa.join(t || "", this.basename);
    }
    /**
     * Get the extname (including dot) (example: `'.js'`).
     *
     * @returns {string | undefined}
     *   Extname.
     */
    get extname() {
      return typeof this.path == "string" ? Sa.extname(this.path) : void 0;
    }
    /**
     * Set the extname (including dot) (example: `'.js'`).
     *
     * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\'`
     * on windows).
     * Cannot be set if theres no `path` yet.
     *
     * @param {string | undefined} extname
     *   Extname.
     * @returns {undefined}
     *   Nothing.
     */
    set extname(t) {
      if (U0(t, "extname"), IF(this.dirname, "extname"), t) {
        if (t.codePointAt(0) !== 46)
          throw new Error("`extname` must start with `.`");
        if (t.includes(".", 1))
          throw new Error("`extname` cannot contain multiple dots");
      }
      this.path = Sa.join(this.dirname, this.stem + (t || ""));
    }
    /**
     * Get the full path (example: `'~/index.min.js'`).
     *
     * @returns {string}
     *   Path.
     */
    get path() {
      return this.history[this.history.length - 1];
    }
    /**
     * Set the full path (example: `'~/index.min.js'`).
     *
     * Cannot be nullified.
     * You can set a file URL (a `URL` object with a `file:` protocol) which will
     * be turned into a path with `url.fileURLToPath`.
     *
     * @param {URL | string} path
     *   Path.
     * @returns {undefined}
     *   Nothing.
     */
    set path(t) {
      TE(t) && (t = jFe(t)), H0(t, "path"), this.path !== t && this.history.push(t);
    }
    /**
     * Get the stem (basename w/o extname) (example: `'index.min'`).
     *
     * @returns {string | undefined}
     *   Stem.
     */
    get stem() {
      return typeof this.path == "string" ? Sa.basename(this.path, this.extname) : void 0;
    }
    /**
     * Set the stem (basename w/o extname) (example: `'index.min'`).
     *
     * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\'`
     * on windows).
     * Cannot be nullified (use `file.path = file.dirname` instead).
     *
     * @param {string} stem
     *   Stem.
     * @returns {undefined}
     *   Nothing.
     */
    set stem(t) {
      H0(t, "stem"), U0(t, "stem"), this.path = Sa.join(this.dirname || "", t + (this.extname || ""));
    }
    // Normal prototypal methods.
    /**
     * Create a fatal message for `reason` associated with the file.
     *
     * The `fatal` field of the message is set to `true` (error; file not usable)
     * and the `file` field is set to the current file path.
     * The message is added to the `messages` field on `file`.
     *
     * >  **Note**: also has obsolete signatures.
     *
     * @overload
     * @param {string} reason
     * @param {MessageOptions | null | undefined} [options]
     * @returns {never}
     *
     * @overload
     * @param {string} reason
     * @param {Node | NodeLike | null | undefined} parent
     * @param {string | null | undefined} [origin]
     * @returns {never}
     *
     * @overload
     * @param {string} reason
     * @param {Point | Position | null | undefined} place
     * @param {string | null | undefined} [origin]
     * @returns {never}
     *
     * @overload
     * @param {string} reason
     * @param {string | null | undefined} [origin]
     * @returns {never}
     *
     * @overload
     * @param {Error | VFileMessage} cause
     * @param {Node | NodeLike | null | undefined} parent
     * @param {string | null | undefined} [origin]
     * @returns {never}
     *
     * @overload
     * @param {Error | VFileMessage} cause
     * @param {Point | Position | null | undefined} place
     * @param {string | null | undefined} [origin]
     * @returns {never}
     *
     * @overload
     * @param {Error | VFileMessage} cause
     * @param {string | null | undefined} [origin]
     * @returns {never}
     *
     * @param {Error | VFileMessage | string} causeOrReason
     *   Reason for message, should use markdown.
     * @param {Node | NodeLike | MessageOptions | Point | Position | string | null | undefined} [optionsOrParentOrPlace]
     *   Configuration (optional).
     * @param {string | null | undefined} [origin]
     *   Place in code where the message originates (example:
     *   `'my-package:my-rule'` or `'my-rule'`).
     * @returns {never}
     *   Never.
     * @throws {VFileMessage}
     *   Message.
     */
    fail(t, n, r) {
      const o = this.message(t, n, r);
      throw o.fatal = !0, o;
    }
    /**
     * Create an info message for `reason` associated with the file.
     *
     * The `fatal` field of the message is set to `undefined` (info; change
     * likely not needed) and the `file` field is set to the current file path.
     * The message is added to the `messages` field on `file`.
     *
     * >  **Note**: also has obsolete signatures.
     *
     * @overload
     * @param {string} reason
     * @param {MessageOptions | null | undefined} [options]
     * @returns {VFileMessage}
     *
     * @overload
     * @param {string} reason
     * @param {Node | NodeLike | null | undefined} parent
     * @param {string | null | undefined} [origin]
     * @returns {VFileMessage}
     *
     * @overload
     * @param {string} reason
     * @param {Point | Position | null | undefined} place
     * @param {string | null | undefined} [origin]
     * @returns {VFileMessage}
     *
     * @overload
     * @param {string} reason
     * @param {string | null | undefined} [origin]
     * @returns {VFileMessage}
     *
     * @overload
     * @param {Error | VFileMessage} cause
     * @param {Node | NodeLike | null | undefined} parent
     * @param {string | null | undefined} [origin]
     * @returns {VFileMessage}
     *
     * @overload
     * @param {Error | VFileMessage} cause
     * @param {Point | Position | null | undefined} place
     * @param {string | null | undefined} [origin]
     * @returns {VFileMessage}
     *
     * @overload
     * @param {Error | VFileMessage} cause
     * @param {string | null | undefined} [origin]
     * @returns {VFileMessage}
     *
     * @param {Error | VFileMessage | string} causeOrReason
     *   Reason for message, should use markdown.
     * @param {Node | NodeLike | MessageOptions | Point | Position | string | null | undefined} [optionsOrParentOrPlace]
     *   Configuration (optional).
     * @param {string | null | undefined} [origin]
     *   Place in code where the message originates (example:
     *   `'my-package:my-rule'` or `'my-rule'`).
     * @returns {VFileMessage}
     *   Message.
     */
    info(t, n, r) {
      const o = this.message(t, n, r);
      return o.fatal = void 0, o;
    }
    /**
     * Create a message for `reason` associated with the file.
     *
     * The `fatal` field of the message is set to `false` (warning; change may be
     * needed) and the `file` field is set to the current file path.
     * The message is added to the `messages` field on `file`.
     *
     * >  **Note**: also has obsolete signatures.
     *
     * @overload
     * @param {string} reason
     * @param {MessageOptions | null | undefined} [options]
     * @returns {VFileMessage}
     *
     * @overload
     * @param {string} reason
     * @param {Node | NodeLike | null | undefined} parent
     * @param {string | null | undefined} [origin]
     * @returns {VFileMessage}
     *
     * @overload
     * @param {string} reason
     * @param {Point | Position | null | undefined} place
     * @param {string | null | undefined} [origin]
     * @returns {VFileMessage}
     *
     * @overload
     * @param {string} reason
     * @param {string | null | undefined} [origin]
     * @returns {VFileMessage}
     *
     * @overload
     * @param {Error | VFileMessage} cause
     * @param {Node | NodeLike | null | undefined} parent
     * @param {string | null | undefined} [origin]
     * @returns {VFileMessage}
     *
     * @overload
     * @param {Error | VFileMessage} cause
     * @param {Point | Position | null | undefined} place
     * @param {string | null | undefined} [origin]
     * @returns {VFileMessage}
     *
     * @overload
     * @param {Error | VFileMessage} cause
     * @param {string | null | undefined} [origin]
     * @returns {VFileMessage}
     *
     * @param {Error | VFileMessage | string} causeOrReason
     *   Reason for message, should use markdown.
     * @param {Node | NodeLike | MessageOptions | Point | Position | string | null | undefined} [optionsOrParentOrPlace]
     *   Configuration (optional).
     * @param {string | null | undefined} [origin]
     *   Place in code where the message originates (example:
     *   `'my-package:my-rule'` or `'my-rule'`).
     * @returns {VFileMessage}
     *   Message.
     */
    message(t, n, r) {
      const o = new Sr(
        // @ts-expect-error: the overloads are fine.
        t,
        n,
        r
      );
      return this.path && (o.name = this.path + ":" + o.name, o.file = this.path), o.fatal = !1, this.messages.push(o), o;
    }
    /**
     * Serialize the file.
     *
     * > **Note**: which encodings are supported depends on the engine.
     * > For info on Node.js, see:
     * > <https://nodejs.org/api/util.html#whatwg-supported-encodings>.
     *
     * @param {string | null | undefined} [encoding='utf8']
     *   Character encoding to understand `value` as when its a `Uint8Array`
     *   (default: `'utf-8'`).
     * @returns {string}
     *   Serialized file.
     */
    toString(t) {
      return this.value === void 0 ? "" : typeof this.value == "string" ? this.value : new TextDecoder(t || void 0).decode(this.value);
    }
  }
  function U0(e, t) {
    if (e && e.includes(Sa.sep))
      throw new Error(
        "`" + t + "` cannot be a path: did not expect `" + Sa.sep + "`"
      );
  }
  function H0(e, t) {
    if (!e)
      throw new Error("`" + t + "` cannot be empty");
  }
  function IF(e, t) {
    if (!e)
      throw new Error("Setting `" + t + "` requires `path` to be set too");
  }
  function AFe(e) {
    return !!(e && typeof e == "object" && "byteLength" in e && "byteOffset" in e);
  }
  const $Fe = (
    /**
     * @type {new <Parameters extends Array<unknown>, Result>(property: string | symbol) => (...parameters: Parameters) => Result}
     */
    /** @type {unknown} */
    /**
     * @this {Function}
     * @param {string | symbol} property
     * @returns {(...parameters: Array<unknown>) => unknown}
     */
    (function(e) {
      const t = (
        /** @type {Record<string | symbol, Function>} */
        // Prototypes do exist.
        // type-coverage:ignore-next-line
        this.constructor.prototype
      ), n = t[e], r = function() {
        return n.apply(r, arguments);
      };
      return Object.setPrototypeOf(r, t), r;
    })
  ), DFe = {}.hasOwnProperty;
  class mN extends $Fe {
    /**
     * Create a processor.
     */
    constructor() {
      super("copy"), this.Compiler = void 0, this.Parser = void 0, this.attachers = [], this.compiler = void 0, this.freezeIndex = -1, this.frozen = void 0, this.namespace = {}, this.parser = void 0, this.transformers = kFe();
    }
    /**
     * Copy a processor.
     *
     * @deprecated
     *   This is a private internal method and should not be used.
     * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
     *   New *unfrozen* processor ({@linkcode Processor}) that is
     *   configured to work the same as its ancestor.
     *   When the descendant processor is configured in the future it does not
     *   affect the ancestral processor.
     */
    copy() {
      const t = (
        /** @type {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>} */
        new mN()
      );
      let n = -1;
      for (; ++n < this.attachers.length; ) {
        const r = this.attachers[n];
        t.use(...r);
      }
      return t.data(B0(!0, {}, this.namespace)), t;
    }
    /**
     * Configure the processor with info available to all plugins.
     * Information is stored in an object.
     *
     * Typically, options can be given to a specific plugin, but sometimes it
     * makes sense to have information shared with several plugins.
     * For example, a list of HTML elements that are self-closing, which is
     * needed during all phases.
     *
     * > **Note**: setting information cannot occur on *frozen* processors.
     * > Call the processor first to create a new unfrozen processor.
     *
     * > **Note**: to register custom data in TypeScript, augment the
     * > {@linkcode Data} interface.
     *
     * @example
     *   This example show how to get and set info:
     *
     *   ```js
     *   import {unified} from 'unified'
     *
     *   const processor = unified().data('alpha', 'bravo')
     *
     *   processor.data('alpha') // => 'bravo'
     *
     *   processor.data() // => {alpha: 'bravo'}
     *
     *   processor.data({charlie: 'delta'})
     *
     *   processor.data() // => {charlie: 'delta'}
     *   ```
     *
     * @template {keyof Data} Key
     *
     * @overload
     * @returns {Data}
     *
     * @overload
     * @param {Data} dataset
     * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
     *
     * @overload
     * @param {Key} key
     * @returns {Data[Key]}
     *
     * @overload
     * @param {Key} key
     * @param {Data[Key]} value
     * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
     *
     * @param {Data | Key} [key]
     *   Key to get or set, or entire dataset to set, or nothing to get the
     *   entire dataset (optional).
     * @param {Data[Key]} [value]
     *   Value to set (optional).
     * @returns {unknown}
     *   The current processor when setting, the value at `key` when getting, or
     *   the entire dataset when getting without key.
     */
    data(t, n) {
      return typeof t == "string" ? arguments.length === 2 ? (K0("data", this.frozen), this.namespace[t] = n, this) : DFe.call(this.namespace, t) && this.namespace[t] || void 0 : t ? (K0("data", this.frozen), this.namespace = t, this) : this.namespace;
    }
    /**
     * Freeze a processor.
     *
     * Frozen processors are meant to be extended and not to be configured
     * directly.
     *
     * When a processor is frozen it cannot be unfrozen.
     * New processors working the same way can be created by calling the
     * processor.
     *
     * Its possible to freeze processors explicitly by calling `.freeze()`.
     * Processors freeze automatically when `.parse()`, `.run()`, `.runSync()`,
     * `.stringify()`, `.process()`, or `.processSync()` are called.
     *
     * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
     *   The current processor.
     */
    freeze() {
      if (this.frozen)
        return this;
      const t = (
        /** @type {Processor} */
        /** @type {unknown} */
        this
      );
      for (; ++this.freezeIndex < this.attachers.length; ) {
        const [n, ...r] = this.attachers[this.freezeIndex];
        if (r[0] === !1)
          continue;
        r[0] === !0 && (r[0] = void 0);
        const o = n.call(t, ...r);
        typeof o == "function" && this.transformers.use(o);
      }
      return this.frozen = !0, this.freezeIndex = Number.POSITIVE_INFINITY, this;
    }
    /**
     * Parse text to a syntax tree.
     *
     * > **Note**: `parse` freezes the processor if not already *frozen*.
     *
     * > **Note**: `parse` performs the parse phase, not the run phase or other
     * > phases.
     *
     * @param {Compatible | undefined} [file]
     *   file to parse (optional); typically `string` or `VFile`; any value
     *   accepted as `x` in `new VFile(x)`.
     * @returns {ParseTree extends undefined ? Node : ParseTree}
     *   Syntax tree representing `file`.
     */
    parse(t) {
      this.freeze();
      const n = wy(t), r = this.parser || this.Parser;
      return W0("parse", r), r(String(n), n);
    }
    /**
     * Process the given file as configured on the processor.
     *
     * > **Note**: `process` freezes the processor if not already *frozen*.
     *
     * > **Note**: `process` performs the parse, run, and stringify phases.
     *
     * @overload
     * @param {Compatible | undefined} file
     * @param {ProcessCallback<VFileWithOutput<CompileResult>>} done
     * @returns {undefined}
     *
     * @overload
     * @param {Compatible | undefined} [file]
     * @returns {Promise<VFileWithOutput<CompileResult>>}
     *
     * @param {Compatible | undefined} [file]
     *   File (optional); typically `string` or `VFile`]; any value accepted as
     *   `x` in `new VFile(x)`.
     * @param {ProcessCallback<VFileWithOutput<CompileResult>> | undefined} [done]
     *   Callback (optional).
     * @returns {Promise<VFile> | undefined}
     *   Nothing if `done` is given.
     *   Otherwise a promise, rejected with a fatal error or resolved with the
     *   processed file.
     *
     *   The parsed, transformed, and compiled value is available at
     *   `file.value` (see note).
     *
     *   > **Note**: unified typically compiles by serializing: most
     *   > compilers return `string` (or `Uint8Array`).
     *   > Some compilers, such as the one configured with
     *   > [`rehype-react`][rehype-react], return other values (in this case, a
     *   > React tree).
     *   > If youre using a compiler that doesnt serialize, expect different
     *   > result values.
     *   >
     *   > To register custom results in TypeScript, add them to
     *   > {@linkcode CompileResultMap}.
     *
     *   [rehype-react]: https://github.com/rehypejs/rehype-react
     */
    process(t, n) {
      const r = this;
      return this.freeze(), W0("process", this.parser || this.Parser), q0("process", this.compiler || this.Compiler), n ? o(void 0, n) : new Promise(o);
      function o(a, i) {
        const s = wy(t), u = (
          /** @type {HeadTree extends undefined ? Node : HeadTree} */
          /** @type {unknown} */
          r.parse(s)
        );
        r.run(u, s, function(f, p, g) {
          if (f || !p || !g)
            return c(f);
          const h = (
            /** @type {CompileTree extends undefined ? Node : CompileTree} */
            /** @type {unknown} */
            p
          ), y = r.stringify(h, g);
          TFe(y) ? g.value = y : g.result = y, c(
            f,
            /** @type {VFileWithOutput<CompileResult>} */
            g
          );
        });
        function c(f, p) {
          f || !p ? i(f) : a ? a(p) : n(void 0, p);
        }
      }
    }
    /**
     * Process the given file as configured on the processor.
     *
     * An error is thrown if asynchronous transforms are configured.
     *
     * > **Note**: `processSync` freezes the processor if not already *frozen*.
     *
     * > **Note**: `processSync` performs the parse, run, and stringify phases.
     *
     * @param {Compatible | undefined} [file]
     *   File (optional); typically `string` or `VFile`; any value accepted as
     *   `x` in `new VFile(x)`.
     * @returns {VFileWithOutput<CompileResult>}
     *   The processed file.
     *
     *   The parsed, transformed, and compiled value is available at
     *   `file.value` (see note).
     *
     *   > **Note**: unified typically compiles by serializing: most
     *   > compilers return `string` (or `Uint8Array`).
     *   > Some compilers, such as the one configured with
     *   > [`rehype-react`][rehype-react], return other values (in this case, a
     *   > React tree).
     *   > If youre using a compiler that doesnt serialize, expect different
     *   > result values.
     *   >
     *   > To register custom results in TypeScript, add them to
     *   > {@linkcode CompileResultMap}.
     *
     *   [rehype-react]: https://github.com/rehypejs/rehype-react
     */
    processSync(t) {
      let n = !1, r;
      return this.freeze(), W0("processSync", this.parser || this.Parser), q0("processSync", this.compiler || this.Compiler), this.process(t, o), $F("processSync", "process", n), r;
      function o(a, i) {
        n = !0, RF(a), r = i;
      }
    }
    /**
     * Run *transformers* on a syntax tree.
     *
     * > **Note**: `run` freezes the processor if not already *frozen*.
     *
     * > **Note**: `run` performs the run phase, not other phases.
     *
     * @overload
     * @param {HeadTree extends undefined ? Node : HeadTree} tree
     * @param {RunCallback<TailTree extends undefined ? Node : TailTree>} done
     * @returns {undefined}
     *
     * @overload
     * @param {HeadTree extends undefined ? Node : HeadTree} tree
     * @param {Compatible | undefined} file
     * @param {RunCallback<TailTree extends undefined ? Node : TailTree>} done
     * @returns {undefined}
     *
     * @overload
     * @param {HeadTree extends undefined ? Node : HeadTree} tree
     * @param {Compatible | undefined} [file]
     * @returns {Promise<TailTree extends undefined ? Node : TailTree>}
     *
     * @param {HeadTree extends undefined ? Node : HeadTree} tree
     *   Tree to transform and inspect.
     * @param {(
     *   RunCallback<TailTree extends undefined ? Node : TailTree> |
     *   Compatible
     * )} [file]
     *   File associated with `node` (optional); any value accepted as `x` in
     *   `new VFile(x)`.
     * @param {RunCallback<TailTree extends undefined ? Node : TailTree>} [done]
     *   Callback (optional).
     * @returns {Promise<TailTree extends undefined ? Node : TailTree> | undefined}
     *   Nothing if `done` is given.
     *   Otherwise, a promise rejected with a fatal error or resolved with the
     *   transformed tree.
     */
    run(t, n, r) {
      AF(t), this.freeze();
      const o = this.transformers;
      return !r && typeof n == "function" && (r = n, n = void 0), r ? a(void 0, r) : new Promise(a);
      function a(i, s) {
        const u = wy(n);
        o.run(t, u, c);
        function c(f, p, g) {
          const h = (
            /** @type {TailTree extends undefined ? Node : TailTree} */
            p || t
          );
          f ? s(f) : i ? i(h) : r(void 0, h, g);
        }
      }
    }
    /**
     * Run *transformers* on a syntax tree.
     *
     * An error is thrown if asynchronous transforms are configured.
     *
     * > **Note**: `runSync` freezes the processor if not already *frozen*.
     *
     * > **Note**: `runSync` performs the run phase, not other phases.
     *
     * @param {HeadTree extends undefined ? Node : HeadTree} tree
     *   Tree to transform and inspect.
     * @param {Compatible | undefined} [file]
     *   File associated with `node` (optional); any value accepted as `x` in
     *   `new VFile(x)`.
     * @returns {TailTree extends undefined ? Node : TailTree}
     *   Transformed tree.
     */
    runSync(t, n) {
      let r = !1, o;
      return this.run(t, n, a), $F("runSync", "run", r), o;
      function a(i, s) {
        RF(i), o = s, r = !0;
      }
    }
    /**
     * Compile a syntax tree.
     *
     * > **Note**: `stringify` freezes the processor if not already *frozen*.
     *
     * > **Note**: `stringify` performs the stringify phase, not the run phase
     * > or other phases.
     *
     * @param {CompileTree extends undefined ? Node : CompileTree} tree
     *   Tree to compile.
     * @param {Compatible | undefined} [file]
     *   File associated with `node` (optional); any value accepted as `x` in
     *   `new VFile(x)`.
     * @returns {CompileResult extends undefined ? Value : CompileResult}
     *   Textual representation of the tree (see note).
     *
     *   > **Note**: unified typically compiles by serializing: most compilers
     *   > return `string` (or `Uint8Array`).
     *   > Some compilers, such as the one configured with
     *   > [`rehype-react`][rehype-react], return other values (in this case, a
     *   > React tree).
     *   > If youre using a compiler that doesnt serialize, expect different
     *   > result values.
     *   >
     *   > To register custom results in TypeScript, add them to
     *   > {@linkcode CompileResultMap}.
     *
     *   [rehype-react]: https://github.com/rehypejs/rehype-react
     */
    stringify(t, n) {
      this.freeze();
      const r = wy(n), o = this.compiler || this.Compiler;
      return q0("stringify", o), AF(t), o(t, r);
    }
    /**
     * Configure the processor to use a plugin, a list of usable values, or a
     * preset.
     *
     * If the processor is already using a plugin, the previous plugin
     * configuration is changed based on the options that are passed in.
     * In other words, the plugin is not added a second time.
     *
     * > **Note**: `use` cannot be called on *frozen* processors.
     * > Call the processor first to create a new unfrozen processor.
     *
     * @example
     *   There are many ways to pass plugins to `.use()`.
     *   This example gives an overview:
     *
     *   ```js
     *   import {unified} from 'unified'
     *
     *   unified()
     *     // Plugin with options:
     *     .use(pluginA, {x: true, y: true})
     *     // Passing the same plugin again merges configuration (to `{x: true, y: false, z: true}`):
     *     .use(pluginA, {y: false, z: true})
     *     // Plugins:
     *     .use([pluginB, pluginC])
     *     // Two plugins, the second with options:
     *     .use([pluginD, [pluginE, {}]])
     *     // Preset with plugins and settings:
     *     .use({plugins: [pluginF, [pluginG, {}]], settings: {position: false}})
     *     // Settings only:
     *     .use({settings: {position: false}})
     *   ```
     *
     * @template {Array<unknown>} [Parameters=[]]
     * @template {Node | string | undefined} [Input=undefined]
     * @template [Output=Input]
     *
     * @overload
     * @param {Preset | null | undefined} [preset]
     * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
     *
     * @overload
     * @param {PluggableList} list
     * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
     *
     * @overload
     * @param {Plugin<Parameters, Input, Output>} plugin
     * @param {...(Parameters | [boolean])} parameters
     * @returns {UsePlugin<ParseTree, HeadTree, TailTree, CompileTree, CompileResult, Input, Output>}
     *
     * @param {PluggableList | Plugin | Preset | null | undefined} value
     *   Usable value.
     * @param {...unknown} parameters
     *   Parameters, when a plugin is given as a usable value.
     * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
     *   Current processor.
     */
    use(t, ...n) {
      const r = this.attachers, o = this.namespace;
      if (K0("use", this.frozen), t != null) if (typeof t == "function")
        u(t, n);
      else if (typeof t == "object")
        Array.isArray(t) ? s(t) : i(t);
      else
        throw new TypeError("Expected usable value, not `" + t + "`");
      return this;
      function a(c) {
        if (typeof c == "function")
          u(c, []);
        else if (typeof c == "object")
          if (Array.isArray(c)) {
            const [f, ...p] = (
              /** @type {PluginTuple<Array<unknown>>} */
              c
            );
            u(f, p);
          } else
            i(c);
        else
          throw new TypeError("Expected usable value, not `" + c + "`");
      }
      function i(c) {
        if (!("plugins" in c) && !("settings" in c))
          throw new Error(
            "Expected usable value but received an empty preset, which is probably a mistake: presets typically come with `plugins` and sometimes with `settings`, but this has neither"
          );
        s(c.plugins), c.settings && (o.settings = B0(!0, o.settings, c.settings));
      }
      function s(c) {
        let f = -1;
        if (c != null) if (Array.isArray(c))
          for (; ++f < c.length; ) {
            const p = c[f];
            a(p);
          }
        else
          throw new TypeError("Expected a list of plugins, not `" + c + "`");
      }
      function u(c, f) {
        let p = -1, g = -1;
        for (; ++p < r.length; )
          if (r[p][0] === c) {
            g = p;
            break;
          }
        if (g === -1)
          r.push([c, ...f]);
        else if (f.length > 0) {
          let [h, ...y] = f;
          const b = r[g][1];
          FE(b) && FE(h) && (h = B0(!0, b, h)), r[g] = [c, h, ...y];
        }
      }
    }
  }
  const LFe = new mN().freeze();
  function W0(e, t) {
    if (typeof t != "function")
      throw new TypeError("Cannot `" + e + "` without `parser`");
  }
  function q0(e, t) {
    if (typeof t != "function")
      throw new TypeError("Cannot `" + e + "` without `compiler`");
  }
  function K0(e, t) {
    if (t)
      throw new Error(
        "Cannot call `" + e + "` on a frozen processor.\nCreate a new processor first, by calling it: use `processor()` instead of `processor`."
      );
  }
  function AF(e) {
    if (!FE(e) || typeof e.type != "string")
      throw new TypeError("Expected node, got `" + e + "`");
  }
  function $F(e, t, n) {
    if (!n)
      throw new Error(
        "`" + e + "` finished async. Use `" + t + "` instead"
      );
  }
  function wy(e) {
    return FFe(e) ? e : new gW(e);
  }
  function FFe(e) {
    return !!(e && typeof e == "object" && "message" in e && "messages" in e);
  }
  function TFe(e) {
    return typeof e == "string" || zFe(e);
  }
  function zFe(e) {
    return !!(e && typeof e == "object" && "byteLength" in e && "byteOffset" in e);
  }
  const BFe = "https://github.com/remarkjs/react-markdown/blob/main/changelog.md", DF = [], LF = { allowDangerousHtml: !0 }, VFe = /^(https?|ircs?|mailto|xmpp)$/i, UFe = [
    { from: "astPlugins", id: "remove-buggy-html-in-markdown-parser" },
    { from: "allowDangerousHtml", id: "remove-buggy-html-in-markdown-parser" },
    {
      from: "allowNode",
      id: "replace-allownode-allowedtypes-and-disallowedtypes",
      to: "allowElement"
    },
    {
      from: "allowedTypes",
      id: "replace-allownode-allowedtypes-and-disallowedtypes",
      to: "allowedElements"
    },
    { from: "className", id: "remove-classname" },
    {
      from: "disallowedTypes",
      id: "replace-allownode-allowedtypes-and-disallowedtypes",
      to: "disallowedElements"
    },
    { from: "escapeHtml", id: "remove-buggy-html-in-markdown-parser" },
    { from: "includeElementIndex", id: "#remove-includeelementindex" },
    {
      from: "includeNodeIndex",
      id: "change-includenodeindex-to-includeelementindex"
    },
    { from: "linkTarget", id: "remove-linktarget" },
    { from: "plugins", id: "change-plugins-to-remarkplugins", to: "remarkPlugins" },
    { from: "rawSourcePos", id: "#remove-rawsourcepos" },
    { from: "renderers", id: "change-renderers-to-components", to: "components" },
    { from: "source", id: "change-source-to-children", to: "children" },
    { from: "sourcePos", id: "#remove-sourcepos" },
    { from: "transformImageUri", id: "#add-urltransform", to: "urlTransform" },
    { from: "transformLinkUri", id: "#add-urltransform", to: "urlTransform" }
  ];
  function HFe(e) {
    const t = WFe(e), n = qFe(e);
    return KFe(t.runSync(t.parse(n), n), e);
  }
  function WFe(e) {
    const t = e.rehypePlugins || DF, n = e.remarkPlugins || DF, r = e.remarkRehypeOptions ? { ...e.remarkRehypeOptions, ...LF } : LF;
    return LFe().use(ELe).use(n).use(bFe, r).use(t);
  }
  function qFe(e) {
    const t = e.children || "", n = new gW();
    return typeof t == "string" && (n.value = t), n;
  }
  function KFe(e, t) {
    const n = t.allowedElements, r = t.allowElement, o = t.components, a = t.disallowedElements, i = t.skipHtml, s = t.unwrapDisallowed, u = t.urlTransform || GFe;
    for (const f of UFe)
      Object.hasOwn(t, f.from) && "" + f.from + (f.to ? "use `" + f.to + "` instead" : "remove it") + BFe + f.id;
    return pN(e, c), l4e(e, {
      Fragment: S.Fragment,
      components: o,
      ignoreInvalidStyle: !0,
      jsx: S.jsx,
      jsxs: S.jsxs,
      passKeys: !0,
      passNode: !0
    });
    function c(f, p, g) {
      if (f.type === "raw" && g && typeof p == "number")
        return i ? g.children.splice(p, 1) : g.children[p] = { type: "text", value: f.value }, p;
      if (f.type === "element") {
        let h;
        for (h in L0)
          if (Object.hasOwn(L0, h) && Object.hasOwn(f.properties, h)) {
            const y = f.properties[h], b = L0[h];
            (b === null || b.includes(f.tagName)) && (f.properties[h] = u(String(y || ""), h, f));
          }
      }
      if (f.type === "element") {
        let h = n ? !n.includes(f.tagName) : a ? a.includes(f.tagName) : !1;
        if (!h && r && typeof p == "number" && (h = !r(f, p, g)), h && g && typeof p == "number")
          return s && f.children ? g.children.splice(p, 1, ...f.children) : g.children.splice(p, 1), p;
      }
    }
  }
  function GFe(e) {
    const t = e.indexOf(":"), n = e.indexOf("?"), r = e.indexOf("#"), o = e.indexOf("/");
    return (
      // If there is no protocol, its relative.
      t === -1 || // If the first colon is after a `?`, `#`, or `/`, its not a protocol.
      o !== -1 && t > o || n !== -1 && t > n || r !== -1 && t > r || // It is a protocol, it should be allowed.
      VFe.test(e.slice(0, t)) ? e : ""
    );
  }
  function FF(e, t) {
    const n = String(e);
    if (typeof t != "string")
      throw new TypeError("Expected character");
    let r = 0, o = n.indexOf(t);
    for (; o !== -1; )
      r++, o = n.indexOf(t, o + t.length);
    return r;
  }
  function XFe(e) {
    if (typeof e != "string")
      throw new TypeError("Expected a string");
    return e.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d");
  }
  function YFe(e, t, n) {
    const r = Tx((n || {}).ignore || []), o = JFe(t);
    let a = -1;
    for (; ++a < o.length; )
      hW(e, "text", i);
    function i(u, c) {
      let f = -1, p;
      for (; ++f < c.length; ) {
        const g = c[f], h = p ? p.children : void 0;
        if (r(
          g,
          h ? h.indexOf(g) : void 0,
          p
        ))
          return;
        p = g;
      }
      if (p)
        return s(u, c);
    }
    function s(u, c) {
      const f = c[c.length - 1], p = o[a][0], g = o[a][1];
      let h = 0;
      const y = f.children.indexOf(u);
      let b = !1, v = [];
      p.lastIndex = 0;
      let w = p.exec(u.value);
      for (; w; ) {
        const _ = w.index, k = {
          index: w.index,
          input: w.input,
          stack: [...c, u]
        };
        let E = g(...w, k);
        if (typeof E == "string" && (E = E.length > 0 ? { type: "text", value: E } : void 0), E === !1 ? p.lastIndex = _ + 1 : (h !== _ && v.push({
          type: "text",
          value: u.value.slice(h, _)
        }), Array.isArray(E) ? v.push(...E) : E && v.push(E), h = _ + w[0].length, b = !0), !p.global)
          break;
        w = p.exec(u.value);
      }
      return b ? (h < u.value.length && v.push({ type: "text", value: u.value.slice(h) }), f.children.splice(y, 1, ...v)) : v = [u], y + v.length;
    }
  }
  function JFe(e) {
    const t = [];
    if (!Array.isArray(e))
      throw new TypeError("Expected find and replace tuple or list of tuples");
    const n = !e[0] || Array.isArray(e[0]) ? e : [e];
    let r = -1;
    for (; ++r < n.length; ) {
      const o = n[r];
      t.push([QFe(o[0]), ZFe(o[1])]);
    }
    return t;
  }
  function QFe(e) {
    return typeof e == "string" ? new RegExp(XFe(e), "g") : e;
  }
  function ZFe(e) {
    return typeof e == "function" ? e : function() {
      return e;
    };
  }
  const G0 = "phrasing", X0 = ["autolink", "link", "image", "label"];
  function eTe() {
    return {
      transforms: [sTe],
      enter: {
        literalAutolink: nTe,
        literalAutolinkEmail: Y0,
        literalAutolinkHttp: Y0,
        literalAutolinkWww: Y0
      },
      exit: {
        literalAutolink: iTe,
        literalAutolinkEmail: aTe,
        literalAutolinkHttp: rTe,
        literalAutolinkWww: oTe
      }
    };
  }
  function tTe() {
    return {
      unsafe: [
        {
          character: "@",
          before: "[+\\-.\\w]",
          after: "[\\-.\\w]",
          inConstruct: G0,
          notInConstruct: X0
        },
        {
          character: ".",
          before: "[Ww]",
          after: "[\\-.\\w]",
          inConstruct: G0,
          notInConstruct: X0
        },
        {
          character: ":",
          before: "[ps]",
          after: "\\/",
          inConstruct: G0,
          notInConstruct: X0
        }
      ]
    };
  }
  function nTe(e) {
    this.enter({ type: "link", title: null, url: "", children: [] }, e);
  }
  function Y0(e) {
    this.config.enter.autolinkProtocol.call(this, e);
  }
  function rTe(e) {
    this.config.exit.autolinkProtocol.call(this, e);
  }
  function oTe(e) {
    this.config.exit.data.call(this, e);
    const t = this.stack[this.stack.length - 1];
    t.type, t.url = "http://" + this.sliceSerialize(e);
  }
  function aTe(e) {
    this.config.exit.autolinkEmail.call(this, e);
  }
  function iTe(e) {
    this.exit(e);
  }
  function sTe(e) {
    YFe(
      e,
      [
        [/(https?:\/\/|www(?=\.))([-.\w]+)([^ \t\r\n]*)/gi, lTe],
        [new RegExp("(?<=^|\\s|\\p{P}|\\p{S})([-.\\w+]+)@([-\\w]+(?:\\.[-\\w]+)+)", "gu"), uTe]
      ],
      { ignore: ["link", "linkReference"] }
    );
  }
  function lTe(e, t, n, r, o) {
    let a = "";
    if (!vW(o) || (/^w/i.test(t) && (n = t + n, t = "", a = "http://"), !cTe(n)))
      return !1;
    const i = dTe(n + r);
    if (!i[0]) return !1;
    const s = {
      type: "link",
      title: null,
      url: a + t + i[0],
      children: [{ type: "text", value: t + i[0] }]
    };
    return i[1] ? [s, { type: "text", value: i[1] }] : s;
  }
  function uTe(e, t, n, r) {
    return (
      // Not an expected previous character.
      !vW(r, !0) || // Label ends in not allowed character.
      /[-\d_]$/.test(n) ? !1 : {
        type: "link",
        title: null,
        url: "mailto:" + t + "@" + n,
        children: [{ type: "text", value: t + "@" + n }]
      }
    );
  }
  function cTe(e) {
    const t = e.split(".");
    return !(t.length < 2 || t[t.length - 1] && (/_/.test(t[t.length - 1]) || !/[a-zA-Z\d]/.test(t[t.length - 1])) || t[t.length - 2] && (/_/.test(t[t.length - 2]) || !/[a-zA-Z\d]/.test(t[t.length - 2])));
  }
  function dTe(e) {
    const t = /[!"&'),.:;<>?\]}]+$/.exec(e);
    if (!t)
      return [e, void 0];
    e = e.slice(0, t.index);
    let n = t[0], r = n.indexOf(")");
    const o = FF(e, "(");
    let a = FF(e, ")");
    for (; r !== -1 && o > a; )
      e += n.slice(0, r + 1), n = n.slice(r + 1), r = n.indexOf(")"), a++;
    return [e, n];
  }
  function vW(e, t) {
    const n = e.input.charCodeAt(e.index - 1);
    return (e.index === 0 || wu(n) || Dx(n)) && // If its an email, the previous character should not be a slash.
    (!t || n !== 47);
  }
  yW.peek = wTe;
  function fTe() {
    this.buffer();
  }
  function pTe(e) {
    this.enter({ type: "footnoteReference", identifier: "", label: "" }, e);
  }
  function mTe() {
    this.buffer();
  }
  function hTe(e) {
    this.enter(
      { type: "footnoteDefinition", identifier: "", label: "", children: [] },
      e
    );
  }
  function gTe(e) {
    const t = this.resume(), n = this.stack[this.stack.length - 1];
    n.type, n.identifier = ea(
      this.sliceSerialize(e)
    ).toLowerCase(), n.label = t;
  }
  function vTe(e) {
    this.exit(e);
  }
  function yTe(e) {
    const t = this.resume(), n = this.stack[this.stack.length - 1];
    n.type, n.identifier = ea(
      this.sliceSerialize(e)
    ).toLowerCase(), n.label = t;
  }
  function bTe(e) {
    this.exit(e);
  }
  function wTe() {
    return "[";
  }
  function yW(e, t, n, r) {
    const o = n.createTracker(r);
    let a = o.move("[^");
    const i = n.enter("footnoteReference"), s = n.enter("reference");
    return a += o.move(
      n.safe(n.associationId(e), { after: "]", before: a })
    ), s(), i(), a += o.move("]"), a;
  }
  function xTe() {
    return {
      enter: {
        gfmFootnoteCallString: fTe,
        gfmFootnoteCall: pTe,
        gfmFootnoteDefinitionLabelString: mTe,
        gfmFootnoteDefinition: hTe
      },
      exit: {
        gfmFootnoteCallString: gTe,
        gfmFootnoteCall: vTe,
        gfmFootnoteDefinitionLabelString: yTe,
        gfmFootnoteDefinition: bTe
      }
    };
  }
  function kTe(e) {
    let t = !1;
    return e && e.firstLineBlank && (t = !0), {
      handlers: { footnoteDefinition: n, footnoteReference: yW },
      // This is on by default already.
      unsafe: [{ character: "[", inConstruct: ["label", "phrasing", "reference"] }]
    };
    function n(r, o, a, i) {
      const s = a.createTracker(i);
      let u = s.move("[^");
      const c = a.enter("footnoteDefinition"), f = a.enter("label");
      return u += s.move(
        a.safe(a.associationId(r), { before: u, after: "]" })
      ), f(), u += s.move("]:"), r.children && r.children.length > 0 && (s.shift(4), u += s.move(
        (t ? `
` : " ") + a.indentLines(
          a.containerFlow(r, s.current()),
          t ? bW : STe
        )
      )), c(), u;
    }
  }
  function STe(e, t, n) {
    return t === 0 ? e : bW(e, t, n);
  }
  function bW(e, t, n) {
    return (n ? "" : "    ") + e;
  }
  const _Te = [
    "autolink",
    "destinationLiteral",
    "destinationRaw",
    "reference",
    "titleQuote",
    "titleApostrophe"
  ];
  wW.peek = NTe;
  function ETe() {
    return {
      canContainEols: ["delete"],
      enter: { strikethrough: PTe },
      exit: { strikethrough: OTe }
    };
  }
  function CTe() {
    return {
      unsafe: [
        {
          character: "~",
          inConstruct: "phrasing",
          notInConstruct: _Te
        }
      ],
      handlers: { delete: wW }
    };
  }
  function PTe(e) {
    this.enter({ type: "delete", children: [] }, e);
  }
  function OTe(e) {
    this.exit(e);
  }
  function wW(e, t, n, r) {
    const o = n.createTracker(r), a = n.enter("strikethrough");
    let i = o.move("~~");
    return i += n.containerPhrasing(e, {
      ...o.current(),
      before: i,
      after: "~"
    }), i += o.move("~~"), a(), i;
  }
  function NTe() {
    return "~";
  }
  function MTe(e) {
    return e.length;
  }
  function RTe(e, t) {
    const n = t || {}, r = (n.align || []).concat(), o = n.stringLength || MTe, a = [], i = [], s = [], u = [];
    let c = 0, f = -1;
    for (; ++f < e.length; ) {
      const b = [], v = [];
      let w = -1;
      for (e[f].length > c && (c = e[f].length); ++w < e[f].length; ) {
        const _ = jTe(e[f][w]);
        if (n.alignDelimiters !== !1) {
          const k = o(_);
          v[w] = k, (u[w] === void 0 || k > u[w]) && (u[w] = k);
        }
        b.push(_);
      }
      i[f] = b, s[f] = v;
    }
    let p = -1;
    if (typeof r == "object" && "length" in r)
      for (; ++p < c; )
        a[p] = TF(r[p]);
    else {
      const b = TF(r);
      for (; ++p < c; )
        a[p] = b;
    }
    p = -1;
    const g = [], h = [];
    for (; ++p < c; ) {
      const b = a[p];
      let v = "", w = "";
      b === 99 ? (v = ":", w = ":") : b === 108 ? v = ":" : b === 114 && (w = ":");
      let _ = n.alignDelimiters === !1 ? 1 : Math.max(
        1,
        u[p] - v.length - w.length
      );
      const k = v + "-".repeat(_) + w;
      n.alignDelimiters !== !1 && (_ = v.length + _ + w.length, _ > u[p] && (u[p] = _), h[p] = _), g[p] = k;
    }
    i.splice(1, 0, g), s.splice(1, 0, h), f = -1;
    const y = [];
    for (; ++f < i.length; ) {
      const b = i[f], v = s[f];
      p = -1;
      const w = [];
      for (; ++p < c; ) {
        const _ = b[p] || "";
        let k = "", E = "";
        if (n.alignDelimiters !== !1) {
          const P = u[p] - (v[p] || 0), O = a[p];
          O === 114 ? k = " ".repeat(P) : O === 99 ? P % 2 ? (k = " ".repeat(P / 2 + 0.5), E = " ".repeat(P / 2 - 0.5)) : (k = " ".repeat(P / 2), E = k) : E = " ".repeat(P);
        }
        n.delimiterStart !== !1 && !p && w.push("|"), n.padding !== !1 && // Dont add the opening space if were not aligning and the cell is
        // empty: there will be a closing space.
        !(n.alignDelimiters === !1 && _ === "") && (n.delimiterStart !== !1 || p) && w.push(" "), n.alignDelimiters !== !1 && w.push(k), w.push(_), n.alignDelimiters !== !1 && w.push(E), n.padding !== !1 && w.push(" "), (n.delimiterEnd !== !1 || p !== c - 1) && w.push("|");
      }
      y.push(
        n.delimiterEnd === !1 ? w.join("").replace(/ +$/, "") : w.join("")
      );
    }
    return y.join(`
`);
  }
  function jTe(e) {
    return e == null ? "" : String(e);
  }
  function TF(e) {
    const t = typeof e == "string" ? e.codePointAt(0) : 0;
    return t === 67 || t === 99 ? 99 : t === 76 || t === 108 ? 108 : t === 82 || t === 114 ? 114 : 0;
  }
  function ITe(e, t, n, r) {
    const o = n.enter("blockquote"), a = n.createTracker(r);
    a.move("> "), a.shift(2);
    const i = n.indentLines(
      n.containerFlow(e, a.current()),
      ATe
    );
    return o(), i;
  }
  function ATe(e, t, n) {
    return ">" + (n ? "" : " ") + e;
  }
  function $Te(e, t) {
    return zF(e, t.inConstruct, !0) && !zF(e, t.notInConstruct, !1);
  }
  function zF(e, t, n) {
    if (typeof t == "string" && (t = [t]), !t || t.length === 0)
      return n;
    let r = -1;
    for (; ++r < t.length; )
      if (e.includes(t[r]))
        return !0;
    return !1;
  }
  function BF(e, t, n, r) {
    let o = -1;
    for (; ++o < n.unsafe.length; )
      if (n.unsafe[o].character === `
` && $Te(n.stack, n.unsafe[o]))
        return /[ \t]/.test(r.before) ? "" : " ";
    return `\\
`;
  }
  function DTe(e, t) {
    const n = String(e);
    let r = n.indexOf(t), o = r, a = 0, i = 0;
    if (typeof t != "string")
      throw new TypeError("Expected substring");
    for (; r !== -1; )
      r === o ? ++a > i && (i = a) : a = 1, o = r + t.length, r = n.indexOf(t, o);
    return i;
  }
  function LTe(e, t) {
    return !!(t.options.fences === !1 && e.value && // If theres no info
    !e.lang && // And theres a non-whitespace character
    /[^ \r\n]/.test(e.value) && // And the value doesnt start or end in a blank
    !/^[\t ]*(?:[\r\n]|$)|(?:^|[\r\n])[\t ]*$/.test(e.value));
  }
  function FTe(e) {
    const t = e.options.fence || "`";
    if (t !== "`" && t !== "~")
      throw new Error(
        "Cannot serialize code with `" + t + "` for `options.fence`, expected `` ` `` or `~`"
      );
    return t;
  }
  function TTe(e, t, n, r) {
    const o = FTe(n), a = e.value || "", i = o === "`" ? "GraveAccent" : "Tilde";
    if (LTe(e, n)) {
      const p = n.enter("codeIndented"), g = n.indentLines(a, zTe);
      return p(), g;
    }
    const s = n.createTracker(r), u = o.repeat(Math.max(DTe(a, o) + 1, 3)), c = n.enter("codeFenced");
    let f = s.move(u);
    if (e.lang) {
      const p = n.enter(`codeFencedLang${i}`);
      f += s.move(
        n.safe(e.lang, {
          before: f,
          after: " ",
          encode: ["`"],
          ...s.current()
        })
      ), p();
    }
    if (e.lang && e.meta) {
      const p = n.enter(`codeFencedMeta${i}`);
      f += s.move(" "), f += s.move(
        n.safe(e.meta, {
          before: f,
          after: `
`,
          encode: ["`"],
          ...s.current()
        })
      ), p();
    }
    return f += s.move(`
`), a && (f += s.move(a + `
`)), f += s.move(u), c(), f;
  }
  function zTe(e, t, n) {
    return (n ? "" : "    ") + e;
  }
  function hN(e) {
    const t = e.options.quote || '"';
    if (t !== '"' && t !== "'")
      throw new Error(
        "Cannot serialize title with `" + t + "` for `options.quote`, expected `\"`, or `'`"
      );
    return t;
  }
  function BTe(e, t, n, r) {
    const o = hN(n), a = o === '"' ? "Quote" : "Apostrophe", i = n.enter("definition");
    let s = n.enter("label");
    const u = n.createTracker(r);
    let c = u.move("[");
    return c += u.move(
      n.safe(n.associationId(e), {
        before: c,
        after: "]",
        ...u.current()
      })
    ), c += u.move("]: "), s(), // If theres no url, or
    !e.url || // If there are control characters or whitespace.
    /[\0- \u007F]/.test(e.url) ? (s = n.enter("destinationLiteral"), c += u.move("<"), c += u.move(
      n.safe(e.url, { before: c, after: ">", ...u.current() })
    ), c += u.move(">")) : (s = n.enter("destinationRaw"), c += u.move(
      n.safe(e.url, {
        before: c,
        after: e.title ? " " : `
`,
        ...u.current()
      })
    )), s(), e.title && (s = n.enter(`title${a}`), c += u.move(" " + o), c += u.move(
      n.safe(e.title, {
        before: c,
        after: o,
        ...u.current()
      })
    ), c += u.move(o), s()), i(), c;
  }
  function VTe(e) {
    const t = e.options.emphasis || "*";
    if (t !== "*" && t !== "_")
      throw new Error(
        "Cannot serialize emphasis with `" + t + "` for `options.emphasis`, expected `*`, or `_`"
      );
    return t;
  }
  function Mm(e) {
    return "&#x" + e.toString(16).toUpperCase() + ";";
  }
  function Xb(e, t, n) {
    const r = jd(e), o = jd(t);
    return r === void 0 ? o === void 0 ? (
      // Letter inside:
      // we have to encode *both* letters for `_` as it is looser.
      // it already forms for `*` (and GFMs `~`).
      n === "_" ? { inside: !0, outside: !0 } : { inside: !1, outside: !1 }
    ) : o === 1 ? (
      // Whitespace inside: encode both (letter, whitespace).
      { inside: !0, outside: !0 }
    ) : (
      // Punctuation inside: encode outer (letter)
      { inside: !1, outside: !0 }
    ) : r === 1 ? o === void 0 ? (
      // Letter inside: already forms.
      { inside: !1, outside: !1 }
    ) : o === 1 ? (
      // Whitespace inside: encode both (whitespace).
      { inside: !0, outside: !0 }
    ) : (
      // Punctuation inside: already forms.
      { inside: !1, outside: !1 }
    ) : o === void 0 ? (
      // Letter inside: already forms.
      { inside: !1, outside: !1 }
    ) : o === 1 ? (
      // Whitespace inside: encode inner (whitespace).
      { inside: !0, outside: !1 }
    ) : (
      // Punctuation inside: already forms.
      { inside: !1, outside: !1 }
    );
  }
  xW.peek = UTe;
  function xW(e, t, n, r) {
    const o = VTe(n), a = n.enter("emphasis"), i = n.createTracker(r), s = i.move(o);
    let u = i.move(
      n.containerPhrasing(e, {
        after: o,
        before: s,
        ...i.current()
      })
    );
    const c = u.charCodeAt(0), f = Xb(
      r.before.charCodeAt(r.before.length - 1),
      c,
      o
    );
    f.inside && (u = Mm(c) + u.slice(1));
    const p = u.charCodeAt(u.length - 1), g = Xb(r.after.charCodeAt(0), p, o);
    g.inside && (u = u.slice(0, -1) + Mm(p));
    const h = i.move(o);
    return a(), n.attentionEncodeSurroundingInfo = {
      after: g.outside,
      before: f.outside
    }, s + u + h;
  }
  function UTe(e, t, n) {
    return n.options.emphasis || "*";
  }
  function HTe(e, t) {
    let n = !1;
    return pN(e, function(r) {
      if ("value" in r && /\r?\n|\r/.test(r.value) || r.type === "break")
        return n = !0, DE;
    }), !!((!e.depth || e.depth < 3) && iN(e) && (t.options.setext || n));
  }
  function WTe(e, t, n, r) {
    const o = Math.max(Math.min(6, e.depth || 1), 1), a = n.createTracker(r);
    if (HTe(e, n)) {
      const f = n.enter("headingSetext"), p = n.enter("phrasing"), g = n.containerPhrasing(e, {
        ...a.current(),
        before: `
`,
        after: `
`
      });
      return p(), f(), g + `
` + (o === 1 ? "=" : "-").repeat(
        // The whole size
        g.length - // Minus the position of the character after the last EOL (or
        // 0 if there is none)
        (Math.max(g.lastIndexOf("\r"), g.lastIndexOf(`
`)) + 1)
      );
    }
    const i = "#".repeat(o), s = n.enter("headingAtx"), u = n.enter("phrasing");
    a.move(i + " ");
    let c = n.containerPhrasing(e, {
      before: "# ",
      after: `
`,
      ...a.current()
    });
    return /^[\t ]/.test(c) && (c = Mm(c.charCodeAt(0)) + c.slice(1)), c = c ? i + " " + c : i, n.options.closeAtx && (c += " " + i), u(), s(), c;
  }
  kW.peek = qTe;
  function kW(e) {
    return e.value || "";
  }
  function qTe() {
    return "<";
  }
  SW.peek = KTe;
  function SW(e, t, n, r) {
    const o = hN(n), a = o === '"' ? "Quote" : "Apostrophe", i = n.enter("image");
    let s = n.enter("label");
    const u = n.createTracker(r);
    let c = u.move("![");
    return c += u.move(
      n.safe(e.alt, { before: c, after: "]", ...u.current() })
    ), c += u.move("]("), s(), // If theres no url but there is a title
    !e.url && e.title || // If there are control characters or whitespace.
    /[\0- \u007F]/.test(e.url) ? (s = n.enter("destinationLiteral"), c += u.move("<"), c += u.move(
      n.safe(e.url, { before: c, after: ">", ...u.current() })
    ), c += u.move(">")) : (s = n.enter("destinationRaw"), c += u.move(
      n.safe(e.url, {
        before: c,
        after: e.title ? " " : ")",
        ...u.current()
      })
    )), s(), e.title && (s = n.enter(`title${a}`), c += u.move(" " + o), c += u.move(
      n.safe(e.title, {
        before: c,
        after: o,
        ...u.current()
      })
    ), c += u.move(o), s()), c += u.move(")"), i(), c;
  }
  function KTe() {
    return "!";
  }
  _W.peek = GTe;
  function _W(e, t, n, r) {
    const o = e.referenceType, a = n.enter("imageReference");
    let i = n.enter("label");
    const s = n.createTracker(r);
    let u = s.move("![");
    const c = n.safe(e.alt, {
      before: u,
      after: "]",
      ...s.current()
    });
    u += s.move(c + "]["), i();
    const f = n.stack;
    n.stack = [], i = n.enter("reference");
    const p = n.safe(n.associationId(e), {
      before: u,
      after: "]",
      ...s.current()
    });
    return i(), n.stack = f, a(), o === "full" || !c || c !== p ? u += s.move(p + "]") : o === "shortcut" ? u = u.slice(0, -1) : u += s.move("]"), u;
  }
  function GTe() {
    return "!";
  }
  EW.peek = XTe;
  function EW(e, t, n) {
    let r = e.value || "", o = "`", a = -1;
    for (; new RegExp("(^|[^`])" + o + "([^`]|$)").test(r); )
      o += "`";
    for (/[^ \r\n]/.test(r) && (/^[ \r\n]/.test(r) && /[ \r\n]$/.test(r) || /^`|`$/.test(r)) && (r = " " + r + " "); ++a < n.unsafe.length; ) {
      const i = n.unsafe[a], s = n.compilePattern(i);
      let u;
      if (i.atBreak)
        for (; u = s.exec(r); ) {
          let c = u.index;
          r.charCodeAt(c) === 10 && r.charCodeAt(c - 1) === 13 && c--, r = r.slice(0, c) + " " + r.slice(u.index + 1);
        }
    }
    return o + r + o;
  }
  function XTe() {
    return "`";
  }
  function CW(e, t) {
    const n = iN(e);
    return !!(!t.options.resourceLink && // If theres a url
    e.url && // And theres a no title
    !e.title && // And the content of `node` is a single text node
    e.children && e.children.length === 1 && e.children[0].type === "text" && // And if the url is the same as the content
    (n === e.url || "mailto:" + n === e.url) && // And that starts w/ a protocol
    /^[a-z][a-z+.-]+:/i.test(e.url) && // And that doesnt contain ASCII control codes (character escapes and
    // references dont work), space, or angle brackets
    !/[\0- <>\u007F]/.test(e.url));
  }
  PW.peek = YTe;
  function PW(e, t, n, r) {
    const o = hN(n), a = o === '"' ? "Quote" : "Apostrophe", i = n.createTracker(r);
    let s, u;
    if (CW(e, n)) {
      const f = n.stack;
      n.stack = [], s = n.enter("autolink");
      let p = i.move("<");
      return p += i.move(
        n.containerPhrasing(e, {
          before: p,
          after: ">",
          ...i.current()
        })
      ), p += i.move(">"), s(), n.stack = f, p;
    }
    s = n.enter("link"), u = n.enter("label");
    let c = i.move("[");
    return c += i.move(
      n.containerPhrasing(e, {
        before: c,
        after: "](",
        ...i.current()
      })
    ), c += i.move("]("), u(), // If theres no url but there is a title
    !e.url && e.title || // If there are control characters or whitespace.
    /[\0- \u007F]/.test(e.url) ? (u = n.enter("destinationLiteral"), c += i.move("<"), c += i.move(
      n.safe(e.url, { before: c, after: ">", ...i.current() })
    ), c += i.move(">")) : (u = n.enter("destinationRaw"), c += i.move(
      n.safe(e.url, {
        before: c,
        after: e.title ? " " : ")",
        ...i.current()
      })
    )), u(), e.title && (u = n.enter(`title${a}`), c += i.move(" " + o), c += i.move(
      n.safe(e.title, {
        before: c,
        after: o,
        ...i.current()
      })
    ), c += i.move(o), u()), c += i.move(")"), s(), c;
  }
  function YTe(e, t, n) {
    return CW(e, n) ? "<" : "[";
  }
  OW.peek = JTe;
  function OW(e, t, n, r) {
    const o = e.referenceType, a = n.enter("linkReference");
    let i = n.enter("label");
    const s = n.createTracker(r);
    let u = s.move("[");
    const c = n.containerPhrasing(e, {
      before: u,
      after: "]",
      ...s.current()
    });
    u += s.move(c + "]["), i();
    const f = n.stack;
    n.stack = [], i = n.enter("reference");
    const p = n.safe(n.associationId(e), {
      before: u,
      after: "]",
      ...s.current()
    });
    return i(), n.stack = f, a(), o === "full" || !c || c !== p ? u += s.move(p + "]") : o === "shortcut" ? u = u.slice(0, -1) : u += s.move("]"), u;
  }
  function JTe() {
    return "[";
  }
  function gN(e) {
    const t = e.options.bullet || "*";
    if (t !== "*" && t !== "+" && t !== "-")
      throw new Error(
        "Cannot serialize items with `" + t + "` for `options.bullet`, expected `*`, `+`, or `-`"
      );
    return t;
  }
  function QTe(e) {
    const t = gN(e), n = e.options.bulletOther;
    if (!n)
      return t === "*" ? "-" : "*";
    if (n !== "*" && n !== "+" && n !== "-")
      throw new Error(
        "Cannot serialize items with `" + n + "` for `options.bulletOther`, expected `*`, `+`, or `-`"
      );
    if (n === t)
      throw new Error(
        "Expected `bullet` (`" + t + "`) and `bulletOther` (`" + n + "`) to be different"
      );
    return n;
  }
  function ZTe(e) {
    const t = e.options.bulletOrdered || ".";
    if (t !== "." && t !== ")")
      throw new Error(
        "Cannot serialize items with `" + t + "` for `options.bulletOrdered`, expected `.` or `)`"
      );
    return t;
  }
  function NW(e) {
    const t = e.options.rule || "*";
    if (t !== "*" && t !== "-" && t !== "_")
      throw new Error(
        "Cannot serialize rules with `" + t + "` for `options.rule`, expected `*`, `-`, or `_`"
      );
    return t;
  }
  function e6e(e, t, n, r) {
    const o = n.enter("list"), a = n.bulletCurrent;
    let i = e.ordered ? ZTe(n) : gN(n);
    const s = e.ordered ? i === "." ? ")" : "." : QTe(n);
    let u = t && n.bulletLastUsed ? i === n.bulletLastUsed : !1;
    if (!e.ordered) {
      const f = e.children ? e.children[0] : void 0;
      if (
        // Bullet could be used as a thematic break marker:
        (i === "*" || i === "-") && // Empty first list item:
        f && (!f.children || !f.children[0]) && // Directly in two other list items:
        n.stack[n.stack.length - 1] === "list" && n.stack[n.stack.length - 2] === "listItem" && n.stack[n.stack.length - 3] === "list" && n.stack[n.stack.length - 4] === "listItem" && // That are each the first child.
        n.indexStack[n.indexStack.length - 1] === 0 && n.indexStack[n.indexStack.length - 2] === 0 && n.indexStack[n.indexStack.length - 3] === 0 && (u = !0), NW(n) === i && f
      ) {
        let p = -1;
        for (; ++p < e.children.length; ) {
          const g = e.children[p];
          if (g && g.type === "listItem" && g.children && g.children[0] && g.children[0].type === "thematicBreak") {
            u = !0;
            break;
          }
        }
      }
    }
    u && (i = s), n.bulletCurrent = i;
    const c = n.containerFlow(e, r);
    return n.bulletLastUsed = i, n.bulletCurrent = a, o(), c;
  }
  function t6e(e) {
    const t = e.options.listItemIndent || "one";
    if (t !== "tab" && t !== "one" && t !== "mixed")
      throw new Error(
        "Cannot serialize items with `" + t + "` for `options.listItemIndent`, expected `tab`, `one`, or `mixed`"
      );
    return t;
  }
  function n6e(e, t, n, r) {
    const o = t6e(n);
    let a = n.bulletCurrent || gN(n);
    t && t.type === "list" && t.ordered && (a = (typeof t.start == "number" && t.start > -1 ? t.start : 1) + (n.options.incrementListMarker === !1 ? 0 : t.children.indexOf(e)) + a);
    let i = a.length + 1;
    (o === "tab" || o === "mixed" && (t && t.type === "list" && t.spread || e.spread)) && (i = Math.ceil(i / 4) * 4);
    const s = n.createTracker(r);
    s.move(a + " ".repeat(i - a.length)), s.shift(i);
    const u = n.enter("listItem"), c = n.indentLines(
      n.containerFlow(e, s.current()),
      f
    );
    return u(), c;
    function f(p, g, h) {
      return g ? (h ? "" : " ".repeat(i)) + p : (h ? a : a + " ".repeat(i - a.length)) + p;
    }
  }
  function r6e(e, t, n, r) {
    const o = n.enter("paragraph"), a = n.enter("phrasing"), i = n.containerPhrasing(e, r);
    return a(), o(), i;
  }
  const o6e = (
    /** @type {(node?: unknown) => node is Exclude<PhrasingContent, Html>} */
    Tx([
      "break",
      "delete",
      "emphasis",
      // To do: next major: removed since footnotes were added to GFM.
      "footnote",
      "footnoteReference",
      "image",
      "imageReference",
      "inlineCode",
      // Enabled by `mdast-util-math`:
      "inlineMath",
      "link",
      "linkReference",
      // Enabled by `mdast-util-mdx`:
      "mdxJsxTextElement",
      // Enabled by `mdast-util-mdx`:
      "mdxTextExpression",
      "strong",
      "text",
      // Enabled by `mdast-util-directive`:
      "textDirective"
    ])
  );
  function a6e(e, t, n, r) {
    return (e.children.some(function(o) {
      return o6e(o);
    }) ? n.containerPhrasing : n.containerFlow).call(n, e, r);
  }
  function i6e(e) {
    const t = e.options.strong || "*";
    if (t !== "*" && t !== "_")
      throw new Error(
        "Cannot serialize strong with `" + t + "` for `options.strong`, expected `*`, or `_`"
      );
    return t;
  }
  MW.peek = s6e;
  function MW(e, t, n, r) {
    const o = i6e(n), a = n.enter("strong"), i = n.createTracker(r), s = i.move(o + o);
    let u = i.move(
      n.containerPhrasing(e, {
        after: o,
        before: s,
        ...i.current()
      })
    );
    const c = u.charCodeAt(0), f = Xb(
      r.before.charCodeAt(r.before.length - 1),
      c,
      o
    );
    f.inside && (u = Mm(c) + u.slice(1));
    const p = u.charCodeAt(u.length - 1), g = Xb(r.after.charCodeAt(0), p, o);
    g.inside && (u = u.slice(0, -1) + Mm(p));
    const h = i.move(o + o);
    return a(), n.attentionEncodeSurroundingInfo = {
      after: g.outside,
      before: f.outside
    }, s + u + h;
  }
  function s6e(e, t, n) {
    return n.options.strong || "*";
  }
  function l6e(e, t, n, r) {
    return n.safe(e.value, r);
  }
  function u6e(e) {
    const t = e.options.ruleRepetition || 3;
    if (t < 3)
      throw new Error(
        "Cannot serialize rules with repetition `" + t + "` for `options.ruleRepetition`, expected `3` or more"
      );
    return t;
  }
  function c6e(e, t, n) {
    const r = (NW(n) + (n.options.ruleSpaces ? " " : "")).repeat(u6e(n));
    return n.options.ruleSpaces ? r.slice(0, -1) : r;
  }
  const RW = {
    blockquote: ITe,
    break: BF,
    code: TTe,
    definition: BTe,
    emphasis: xW,
    hardBreak: BF,
    heading: WTe,
    html: kW,
    image: SW,
    imageReference: _W,
    inlineCode: EW,
    link: PW,
    linkReference: OW,
    list: e6e,
    listItem: n6e,
    paragraph: r6e,
    root: a6e,
    strong: MW,
    text: l6e,
    thematicBreak: c6e
  };
  function d6e() {
    return {
      enter: {
        table: f6e,
        tableData: VF,
        tableHeader: VF,
        tableRow: m6e
      },
      exit: {
        codeText: h6e,
        table: p6e,
        tableData: J0,
        tableHeader: J0,
        tableRow: J0
      }
    };
  }
  function f6e(e) {
    const t = e._align;
    this.enter(
      {
        type: "table",
        align: t.map(function(n) {
          return n === "none" ? null : n;
        }),
        children: []
      },
      e
    ), this.data.inTable = !0;
  }
  function p6e(e) {
    this.exit(e), this.data.inTable = void 0;
  }
  function m6e(e) {
    this.enter({ type: "tableRow", children: [] }, e);
  }
  function J0(e) {
    this.exit(e);
  }
  function VF(e) {
    this.enter({ type: "tableCell", children: [] }, e);
  }
  function h6e(e) {
    let t = this.resume();
    this.data.inTable && (t = t.replace(/\\([\\|])/g, g6e));
    const n = this.stack[this.stack.length - 1];
    n.type, n.value = t, this.exit(e);
  }
  function g6e(e, t) {
    return t === "|" ? t : e;
  }
  function v6e(e) {
    const t = e || {}, n = t.tableCellPadding, r = t.tablePipeAlign, o = t.stringLength, a = n ? " " : "|";
    return {
      unsafe: [
        { character: "\r", inConstruct: "tableCell" },
        { character: `
`, inConstruct: "tableCell" },
        // A pipe, when followed by a tab or space (padding), or a dash or colon
        // (unpadded delimiter row), could result in a table.
        { atBreak: !0, character: "|", after: "[	 :-]" },
        // A pipe in a cell must be encoded.
        { character: "|", inConstruct: "tableCell" },
        // A colon must be followed by a dash, in which case it could start a
        // delimiter row.
        { atBreak: !0, character: ":", after: "-" },
        // A delimiter row can also start with a dash, when followed by more
        // dashes, a colon, or a pipe.
        // This is a stricter version than the built in check for lists, thematic
        // breaks, and setex heading underlines though:
        // <https://github.com/syntax-tree/mdast-util-to-markdown/blob/51a2038/lib/unsafe.js#L57>
        { atBreak: !0, character: "-", after: "[:|-]" }
      ],
      handlers: {
        inlineCode: g,
        table: i,
        tableCell: u,
        tableRow: s
      }
    };
    function i(h, y, b, v) {
      return c(f(h, b, v), h.align);
    }
    function s(h, y, b, v) {
      const w = p(h, b, v), _ = c([w]);
      return _.slice(0, _.indexOf(`
`));
    }
    function u(h, y, b, v) {
      const w = b.enter("tableCell"), _ = b.enter("phrasing"), k = b.containerPhrasing(h, {
        ...v,
        before: a,
        after: a
      });
      return _(), w(), k;
    }
    function c(h, y) {
      return RTe(h, {
        align: y,
        // @ts-expect-error: `markdown-table` types should support `null`.
        alignDelimiters: r,
        // @ts-expect-error: `markdown-table` types should support `null`.
        padding: n,
        // @ts-expect-error: `markdown-table` types should support `null`.
        stringLength: o
      });
    }
    function f(h, y, b) {
      const v = h.children;
      let w = -1;
      const _ = [], k = y.enter("table");
      for (; ++w < v.length; )
        _[w] = p(v[w], y, b);
      return k(), _;
    }
    function p(h, y, b) {
      const v = h.children;
      let w = -1;
      const _ = [], k = y.enter("tableRow");
      for (; ++w < v.length; )
        _[w] = u(v[w], h, y, b);
      return k(), _;
    }
    function g(h, y, b) {
      let v = RW.inlineCode(h, y, b);
      return b.stack.includes("tableCell") && (v = v.replace(/\|/g, "\\$&")), v;
    }
  }
  function y6e() {
    return {
      exit: {
        taskListCheckValueChecked: UF,
        taskListCheckValueUnchecked: UF,
        paragraph: w6e
      }
    };
  }
  function b6e() {
    return {
      unsafe: [{ atBreak: !0, character: "-", after: "[:|-]" }],
      handlers: { listItem: x6e }
    };
  }
  function UF(e) {
    const t = this.stack[this.stack.length - 2];
    t.type, t.checked = e.type === "taskListCheckValueChecked";
  }
  function w6e(e) {
    const t = this.stack[this.stack.length - 2];
    if (t && t.type === "listItem" && typeof t.checked == "boolean") {
      const n = this.stack[this.stack.length - 1];
      n.type;
      const r = n.children[0];
      if (r && r.type === "text") {
        const o = t.children;
        let a = -1, i;
        for (; ++a < o.length; ) {
          const s = o[a];
          if (s.type === "paragraph") {
            i = s;
            break;
          }
        }
        i === n && (r.value = r.value.slice(1), r.value.length === 0 ? n.children.shift() : n.position && r.position && typeof r.position.start.offset == "number" && (r.position.start.column++, r.position.start.offset++, n.position.start = Object.assign({}, r.position.start)));
      }
    }
    this.exit(e);
  }
  function x6e(e, t, n, r) {
    const o = e.children[0], a = typeof e.checked == "boolean" && o && o.type === "paragraph", i = "[" + (e.checked ? "x" : " ") + "] ", s = n.createTracker(r);
    a && s.move(i);
    let u = RW.listItem(e, t, n, {
      ...r,
      ...s.current()
    });
    return a && (u = u.replace(/^(?:[*+-]|\d+\.)([\r\n]| {1,3})/, c)), u;
    function c(f) {
      return f + i;
    }
  }
  function k6e() {
    return [
      eTe(),
      xTe(),
      ETe(),
      d6e(),
      y6e()
    ];
  }
  function S6e(e) {
    return {
      extensions: [
        tTe(),
        kTe(e),
        CTe(),
        v6e(e),
        b6e()
      ]
    };
  }
  const _6e = {
    tokenize: M6e,
    partial: !0
  }, jW = {
    tokenize: R6e,
    partial: !0
  }, IW = {
    tokenize: j6e,
    partial: !0
  }, AW = {
    tokenize: I6e,
    partial: !0
  }, E6e = {
    tokenize: A6e,
    partial: !0
  }, $W = {
    name: "wwwAutolink",
    tokenize: O6e,
    previous: LW
  }, DW = {
    name: "protocolAutolink",
    tokenize: N6e,
    previous: FW
  }, ss = {
    name: "emailAutolink",
    tokenize: P6e,
    previous: TW
  }, ri = {};
  function C6e() {
    return {
      text: ri
    };
  }
  let ql = 48;
  for (; ql < 123; )
    ri[ql] = ss, ql++, ql === 58 ? ql = 65 : ql === 91 && (ql = 97);
  ri[43] = ss;
  ri[45] = ss;
  ri[46] = ss;
  ri[95] = ss;
  ri[72] = [ss, DW];
  ri[104] = [ss, DW];
  ri[87] = [ss, $W];
  ri[119] = [ss, $W];
  function P6e(e, t, n) {
    const r = this;
    let o, a;
    return i;
    function i(p) {
      return !zE(p) || !TW.call(r, r.previous) || vN(r.events) ? n(p) : (e.enter("literalAutolink"), e.enter("literalAutolinkEmail"), s(p));
    }
    function s(p) {
      return zE(p) ? (e.consume(p), s) : p === 64 ? (e.consume(p), u) : n(p);
    }
    function u(p) {
      return p === 46 ? e.check(E6e, f, c)(p) : p === 45 || p === 95 || br(p) ? (a = !0, e.consume(p), u) : f(p);
    }
    function c(p) {
      return e.consume(p), o = !0, u;
    }
    function f(p) {
      return a && o && Pr(r.previous) ? (e.exit("literalAutolinkEmail"), e.exit("literalAutolink"), t(p)) : n(p);
    }
  }
  function O6e(e, t, n) {
    const r = this;
    return o;
    function o(i) {
      return i !== 87 && i !== 119 || !LW.call(r, r.previous) || vN(r.events) ? n(i) : (e.enter("literalAutolink"), e.enter("literalAutolinkWww"), e.check(_6e, e.attempt(jW, e.attempt(IW, a), n), n)(i));
    }
    function a(i) {
      return e.exit("literalAutolinkWww"), e.exit("literalAutolink"), t(i);
    }
  }
  function N6e(e, t, n) {
    const r = this;
    let o = "", a = !1;
    return i;
    function i(p) {
      return (p === 72 || p === 104) && FW.call(r, r.previous) && !vN(r.events) ? (e.enter("literalAutolink"), e.enter("literalAutolinkHttp"), o += String.fromCodePoint(p), e.consume(p), s) : n(p);
    }
    function s(p) {
      if (Pr(p) && o.length < 5)
        return o += String.fromCodePoint(p), e.consume(p), s;
      if (p === 58) {
        const g = o.toLowerCase();
        if (g === "http" || g === "https")
          return e.consume(p), u;
      }
      return n(p);
    }
    function u(p) {
      return p === 47 ? (e.consume(p), a ? c : (a = !0, u)) : n(p);
    }
    function c(p) {
      return p === null || qb(p) || ln(p) || wu(p) || Dx(p) ? n(p) : e.attempt(jW, e.attempt(IW, f), n)(p);
    }
    function f(p) {
      return e.exit("literalAutolinkHttp"), e.exit("literalAutolink"), t(p);
    }
  }
  function M6e(e, t, n) {
    let r = 0;
    return o;
    function o(i) {
      return (i === 87 || i === 119) && r < 3 ? (r++, e.consume(i), o) : i === 46 && r === 3 ? (e.consume(i), a) : n(i);
    }
    function a(i) {
      return i === null ? n(i) : t(i);
    }
  }
  function R6e(e, t, n) {
    let r, o, a;
    return i;
    function i(c) {
      return c === 46 || c === 95 ? e.check(AW, u, s)(c) : c === null || ln(c) || wu(c) || c !== 45 && Dx(c) ? u(c) : (a = !0, e.consume(c), i);
    }
    function s(c) {
      return c === 95 ? r = !0 : (o = r, r = void 0), e.consume(c), i;
    }
    function u(c) {
      return o || r || !a ? n(c) : t(c);
    }
  }
  function j6e(e, t) {
    let n = 0, r = 0;
    return o;
    function o(i) {
      return i === 40 ? (n++, e.consume(i), o) : i === 41 && r < n ? a(i) : i === 33 || i === 34 || i === 38 || i === 39 || i === 41 || i === 42 || i === 44 || i === 46 || i === 58 || i === 59 || i === 60 || i === 63 || i === 93 || i === 95 || i === 126 ? e.check(AW, t, a)(i) : i === null || ln(i) || wu(i) ? t(i) : (e.consume(i), o);
    }
    function a(i) {
      return i === 41 && r++, e.consume(i), o;
    }
  }
  function I6e(e, t, n) {
    return r;
    function r(s) {
      return s === 33 || s === 34 || s === 39 || s === 41 || s === 42 || s === 44 || s === 46 || s === 58 || s === 59 || s === 63 || s === 95 || s === 126 ? (e.consume(s), r) : s === 38 ? (e.consume(s), a) : s === 93 ? (e.consume(s), o) : (
        // `<` is an end.
        s === 60 || // So is whitespace.
        s === null || ln(s) || wu(s) ? t(s) : n(s)
      );
    }
    function o(s) {
      return s === null || s === 40 || s === 91 || ln(s) || wu(s) ? t(s) : r(s);
    }
    function a(s) {
      return Pr(s) ? i(s) : n(s);
    }
    function i(s) {
      return s === 59 ? (e.consume(s), r) : Pr(s) ? (e.consume(s), i) : n(s);
    }
  }
  function A6e(e, t, n) {
    return r;
    function r(a) {
      return e.consume(a), o;
    }
    function o(a) {
      return br(a) ? n(a) : t(a);
    }
  }
  function LW(e) {
    return e === null || e === 40 || e === 42 || e === 95 || e === 91 || e === 93 || e === 126 || ln(e);
  }
  function FW(e) {
    return !Pr(e);
  }
  function TW(e) {
    return !(e === 47 || zE(e));
  }
  function zE(e) {
    return e === 43 || e === 45 || e === 46 || e === 95 || br(e);
  }
  function vN(e) {
    let t = e.length, n = !1;
    for (; t--; ) {
      const r = e[t][1];
      if ((r.type === "labelLink" || r.type === "labelImage") && !r._balanced) {
        n = !0;
        break;
      }
      if (r._gfmAutolinkLiteralWalkedInto) {
        n = !1;
        break;
      }
    }
    return e.length > 0 && !n && (e[e.length - 1][1]._gfmAutolinkLiteralWalkedInto = !0), n;
  }
  const $6e = {
    tokenize: U6e,
    partial: !0
  };
  function D6e() {
    return {
      document: {
        91: {
          name: "gfmFootnoteDefinition",
          tokenize: z6e,
          continuation: {
            tokenize: B6e
          },
          exit: V6e
        }
      },
      text: {
        91: {
          name: "gfmFootnoteCall",
          tokenize: T6e
        },
        93: {
          name: "gfmPotentialFootnoteCall",
          add: "after",
          tokenize: L6e,
          resolveTo: F6e
        }
      }
    };
  }
  function L6e(e, t, n) {
    const r = this;
    let o = r.events.length;
    const a = r.parser.gfmFootnotes || (r.parser.gfmFootnotes = []);
    let i;
    for (; o--; ) {
      const u = r.events[o][1];
      if (u.type === "labelImage") {
        i = u;
        break;
      }
      if (u.type === "gfmFootnoteCall" || u.type === "labelLink" || u.type === "label" || u.type === "image" || u.type === "link")
        break;
    }
    return s;
    function s(u) {
      if (!i || !i._balanced)
        return n(u);
      const c = ea(r.sliceSerialize({
        start: i.end,
        end: r.now()
      }));
      return c.codePointAt(0) !== 94 || !a.includes(c.slice(1)) ? n(u) : (e.enter("gfmFootnoteCallLabelMarker"), e.consume(u), e.exit("gfmFootnoteCallLabelMarker"), t(u));
    }
  }
  function F6e(e, t) {
    let n = e.length;
    for (; n--; )
      if (e[n][1].type === "labelImage" && e[n][0] === "enter") {
        e[n][1];
        break;
      }
    e[n + 1][1].type = "data", e[n + 3][1].type = "gfmFootnoteCallLabelMarker";
    const r = {
      type: "gfmFootnoteCall",
      start: Object.assign({}, e[n + 3][1].start),
      end: Object.assign({}, e[e.length - 1][1].end)
    }, o = {
      type: "gfmFootnoteCallMarker",
      start: Object.assign({}, e[n + 3][1].end),
      end: Object.assign({}, e[n + 3][1].end)
    };
    o.end.column++, o.end.offset++, o.end._bufferIndex++;
    const a = {
      type: "gfmFootnoteCallString",
      start: Object.assign({}, o.end),
      end: Object.assign({}, e[e.length - 1][1].start)
    }, i = {
      type: "chunkString",
      contentType: "string",
      start: Object.assign({}, a.start),
      end: Object.assign({}, a.end)
    }, s = [
      // Take the `labelImageMarker` (now `data`, the `!`)
      e[n + 1],
      e[n + 2],
      ["enter", r, t],
      // The `[`
      e[n + 3],
      e[n + 4],
      // The `^`.
      ["enter", o, t],
      ["exit", o, t],
      // Everything in between.
      ["enter", a, t],
      ["enter", i, t],
      ["exit", i, t],
      ["exit", a, t],
      // The ending (`]`, properly parsed and labelled).
      e[e.length - 2],
      e[e.length - 1],
      ["exit", r, t]
    ];
    return e.splice(n, e.length - n + 1, ...s), e;
  }
  function T6e(e, t, n) {
    const r = this, o = r.parser.gfmFootnotes || (r.parser.gfmFootnotes = []);
    let a = 0, i;
    return s;
    function s(p) {
      return e.enter("gfmFootnoteCall"), e.enter("gfmFootnoteCallLabelMarker"), e.consume(p), e.exit("gfmFootnoteCallLabelMarker"), u;
    }
    function u(p) {
      return p !== 94 ? n(p) : (e.enter("gfmFootnoteCallMarker"), e.consume(p), e.exit("gfmFootnoteCallMarker"), e.enter("gfmFootnoteCallString"), e.enter("chunkString").contentType = "string", c);
    }
    function c(p) {
      if (
        // Too long.
        a > 999 || // Closing brace with nothing.
        p === 93 && !i || // Space or tab is not supported by GFM for some reason.
        // `\n` and `[` not being supported makes sense.
        p === null || p === 91 || ln(p)
      )
        return n(p);
      if (p === 93) {
        e.exit("chunkString");
        const g = e.exit("gfmFootnoteCallString");
        return o.includes(ea(r.sliceSerialize(g))) ? (e.enter("gfmFootnoteCallLabelMarker"), e.consume(p), e.exit("gfmFootnoteCallLabelMarker"), e.exit("gfmFootnoteCall"), t) : n(p);
      }
      return ln(p) || (i = !0), a++, e.consume(p), p === 92 ? f : c;
    }
    function f(p) {
      return p === 91 || p === 92 || p === 93 ? (e.consume(p), a++, c) : c(p);
    }
  }
  function z6e(e, t, n) {
    const r = this, o = r.parser.gfmFootnotes || (r.parser.gfmFootnotes = []);
    let a, i = 0, s;
    return u;
    function u(y) {
      return e.enter("gfmFootnoteDefinition")._container = !0, e.enter("gfmFootnoteDefinitionLabel"), e.enter("gfmFootnoteDefinitionLabelMarker"), e.consume(y), e.exit("gfmFootnoteDefinitionLabelMarker"), c;
    }
    function c(y) {
      return y === 94 ? (e.enter("gfmFootnoteDefinitionMarker"), e.consume(y), e.exit("gfmFootnoteDefinitionMarker"), e.enter("gfmFootnoteDefinitionLabelString"), e.enter("chunkString").contentType = "string", f) : n(y);
    }
    function f(y) {
      if (
        // Too long.
        i > 999 || // Closing brace with nothing.
        y === 93 && !s || // Space or tab is not supported by GFM for some reason.
        // `\n` and `[` not being supported makes sense.
        y === null || y === 91 || ln(y)
      )
        return n(y);
      if (y === 93) {
        e.exit("chunkString");
        const b = e.exit("gfmFootnoteDefinitionLabelString");
        return a = ea(r.sliceSerialize(b)), e.enter("gfmFootnoteDefinitionLabelMarker"), e.consume(y), e.exit("gfmFootnoteDefinitionLabelMarker"), e.exit("gfmFootnoteDefinitionLabel"), g;
      }
      return ln(y) || (s = !0), i++, e.consume(y), y === 92 ? p : f;
    }
    function p(y) {
      return y === 91 || y === 92 || y === 93 ? (e.consume(y), i++, f) : f(y);
    }
    function g(y) {
      return y === 58 ? (e.enter("definitionMarker"), e.consume(y), e.exit("definitionMarker"), o.includes(a) || o.push(a), Mt(e, h, "gfmFootnoteDefinitionWhitespace")) : n(y);
    }
    function h(y) {
      return t(y);
    }
  }
  function B6e(e, t, n) {
    return e.check(Sh, t, e.attempt($6e, t, n));
  }
  function V6e(e) {
    e.exit("gfmFootnoteDefinition");
  }
  function U6e(e, t, n) {
    const r = this;
    return Mt(e, o, "gfmFootnoteDefinitionIndent", 5);
    function o(a) {
      const i = r.events[r.events.length - 1];
      return i && i[1].type === "gfmFootnoteDefinitionIndent" && i[2].sliceSerialize(i[1], !0).length === 4 ? t(a) : n(a);
    }
  }
  function H6e(e) {
    let t = (e || {}).singleTilde;
    const n = {
      name: "strikethrough",
      tokenize: o,
      resolveAll: r
    };
    return t == null && (t = !0), {
      text: {
        126: n
      },
      insideSpan: {
        null: [n]
      },
      attentionMarkers: {
        null: [126]
      }
    };
    function r(a, i) {
      let s = -1;
      for (; ++s < a.length; )
        if (a[s][0] === "enter" && a[s][1].type === "strikethroughSequenceTemporary" && a[s][1]._close) {
          let u = s;
          for (; u--; )
            if (a[u][0] === "exit" && a[u][1].type === "strikethroughSequenceTemporary" && a[u][1]._open && // If the sizes are the same:
            a[s][1].end.offset - a[s][1].start.offset === a[u][1].end.offset - a[u][1].start.offset) {
              a[s][1].type = "strikethroughSequence", a[u][1].type = "strikethroughSequence";
              const c = {
                type: "strikethrough",
                start: Object.assign({}, a[u][1].start),
                end: Object.assign({}, a[s][1].end)
              }, f = {
                type: "strikethroughText",
                start: Object.assign({}, a[u][1].end),
                end: Object.assign({}, a[s][1].start)
              }, p = [["enter", c, i], ["enter", a[u][1], i], ["exit", a[u][1], i], ["enter", f, i]], g = i.parser.constructs.insideSpan.null;
              g && fo(p, p.length, 0, Lx(g, a.slice(u + 1, s), i)), fo(p, p.length, 0, [["exit", f, i], ["enter", a[s][1], i], ["exit", a[s][1], i], ["exit", c, i]]), fo(a, u - 1, s - u + 3, p), s = u + p.length - 2;
              break;
            }
        }
      for (s = -1; ++s < a.length; )
        a[s][1].type === "strikethroughSequenceTemporary" && (a[s][1].type = "data");
      return a;
    }
    function o(a, i, s) {
      const u = this.previous, c = this.events;
      let f = 0;
      return p;
      function p(h) {
        return u === 126 && c[c.length - 1][1].type !== "characterEscape" ? s(h) : (a.enter("strikethroughSequenceTemporary"), g(h));
      }
      function g(h) {
        const y = jd(u);
        if (h === 126)
          return f > 1 ? s(h) : (a.consume(h), f++, g);
        if (f < 2 && !t) return s(h);
        const b = a.exit("strikethroughSequenceTemporary"), v = jd(h);
        return b._open = !v || v === 2 && !!y, b._close = !y || y === 2 && !!v, i(h);
      }
    }
  }
  class W6e {
    /**
     * Create a new edit map.
     */
    constructor() {
      this.map = [];
    }
    /**
     * Create an edit: a remove and/or add at a certain place.
     *
     * @param {number} index
     * @param {number} remove
     * @param {Array<Event>} add
     * @returns {undefined}
     */
    add(t, n, r) {
      q6e(this, t, n, r);
    }
    // To do: add this when moving to `micromark`.
    // /**
    //  * Create an edit: but insert `add` before existing additions.
    //  *
    //  * @param {number} index
    //  * @param {number} remove
    //  * @param {Array<Event>} add
    //  * @returns {undefined}
    //  */
    // addBefore(index, remove, add) {
    //   addImplementation(this, index, remove, add, true)
    // }
    /**
     * Done, change the events.
     *
     * @param {Array<Event>} events
     * @returns {undefined}
     */
    consume(t) {
      if (this.map.sort(function(a, i) {
        return a[0] - i[0];
      }), this.map.length === 0)
        return;
      let n = this.map.length;
      const r = [];
      for (; n > 0; )
        n -= 1, r.push(t.slice(this.map[n][0] + this.map[n][1]), this.map[n][2]), t.length = this.map[n][0];
      r.push(t.slice()), t.length = 0;
      let o = r.pop();
      for (; o; ) {
        for (const a of o)
          t.push(a);
        o = r.pop();
      }
      this.map.length = 0;
    }
  }
  function q6e(e, t, n, r) {
    let o = 0;
    if (!(n === 0 && r.length === 0)) {
      for (; o < e.map.length; ) {
        if (e.map[o][0] === t) {
          e.map[o][1] += n, e.map[o][2].push(...r);
          return;
        }
        o += 1;
      }
      e.map.push([t, n, r]);
    }
  }
  function K6e(e, t) {
    let n = !1;
    const r = [];
    for (; t < e.length; ) {
      const o = e[t];
      if (n) {
        if (o[0] === "enter")
          o[1].type === "tableContent" && r.push(e[t + 1][1].type === "tableDelimiterMarker" ? "left" : "none");
        else if (o[1].type === "tableContent") {
          if (e[t - 1][1].type === "tableDelimiterMarker") {
            const a = r.length - 1;
            r[a] = r[a] === "left" ? "center" : "right";
          }
        } else if (o[1].type === "tableDelimiterRow")
          break;
      } else o[0] === "enter" && o[1].type === "tableDelimiterRow" && (n = !0);
      t += 1;
    }
    return r;
  }
  function G6e() {
    return {
      flow: {
        null: {
          name: "table",
          tokenize: X6e,
          resolveAll: Y6e
        }
      }
    };
  }
  function X6e(e, t, n) {
    const r = this;
    let o = 0, a = 0, i;
    return s;
    function s(D) {
      let F = r.events.length - 1;
      for (; F > -1; ) {
        const $ = r.events[F][1].type;
        if ($ === "lineEnding" || // Note: markdown-rs uses `whitespace` instead of `linePrefix`
        $ === "linePrefix") F--;
        else break;
      }
      const j = F > -1 ? r.events[F][1].type : null, U = j === "tableHead" || j === "tableRow" ? O : u;
      return U === O && r.parser.lazy[r.now().line] ? n(D) : U(D);
    }
    function u(D) {
      return e.enter("tableHead"), e.enter("tableRow"), c(D);
    }
    function c(D) {
      return D === 124 || (i = !0, a += 1), f(D);
    }
    function f(D) {
      return D === null ? n(D) : Je(D) ? a > 1 ? (a = 0, r.interrupt = !0, e.exit("tableRow"), e.enter("lineEnding"), e.consume(D), e.exit("lineEnding"), h) : n(D) : kt(D) ? Mt(e, f, "whitespace")(D) : (a += 1, i && (i = !1, o += 1), D === 124 ? (e.enter("tableCellDivider"), e.consume(D), e.exit("tableCellDivider"), i = !0, f) : (e.enter("data"), p(D)));
    }
    function p(D) {
      return D === null || D === 124 || ln(D) ? (e.exit("data"), f(D)) : (e.consume(D), D === 92 ? g : p);
    }
    function g(D) {
      return D === 92 || D === 124 ? (e.consume(D), p) : p(D);
    }
    function h(D) {
      return r.interrupt = !1, r.parser.lazy[r.now().line] ? n(D) : (e.enter("tableDelimiterRow"), i = !1, kt(D) ? Mt(e, y, "linePrefix", r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(D) : y(D));
    }
    function y(D) {
      return D === 45 || D === 58 ? v(D) : D === 124 ? (i = !0, e.enter("tableCellDivider"), e.consume(D), e.exit("tableCellDivider"), b) : P(D);
    }
    function b(D) {
      return kt(D) ? Mt(e, v, "whitespace")(D) : v(D);
    }
    function v(D) {
      return D === 58 ? (a += 1, i = !0, e.enter("tableDelimiterMarker"), e.consume(D), e.exit("tableDelimiterMarker"), w) : D === 45 ? (a += 1, w(D)) : D === null || Je(D) ? E(D) : P(D);
    }
    function w(D) {
      return D === 45 ? (e.enter("tableDelimiterFiller"), _(D)) : P(D);
    }
    function _(D) {
      return D === 45 ? (e.consume(D), _) : D === 58 ? (i = !0, e.exit("tableDelimiterFiller"), e.enter("tableDelimiterMarker"), e.consume(D), e.exit("tableDelimiterMarker"), k) : (e.exit("tableDelimiterFiller"), k(D));
    }
    function k(D) {
      return kt(D) ? Mt(e, E, "whitespace")(D) : E(D);
    }
    function E(D) {
      return D === 124 ? y(D) : D === null || Je(D) ? !i || o !== a ? P(D) : (e.exit("tableDelimiterRow"), e.exit("tableHead"), t(D)) : P(D);
    }
    function P(D) {
      return n(D);
    }
    function O(D) {
      return e.enter("tableRow"), M(D);
    }
    function M(D) {
      return D === 124 ? (e.enter("tableCellDivider"), e.consume(D), e.exit("tableCellDivider"), M) : D === null || Je(D) ? (e.exit("tableRow"), t(D)) : kt(D) ? Mt(e, M, "whitespace")(D) : (e.enter("data"), I(D));
    }
    function I(D) {
      return D === null || D === 124 || ln(D) ? (e.exit("data"), M(D)) : (e.consume(D), D === 92 ? A : I);
    }
    function A(D) {
      return D === 92 || D === 124 ? (e.consume(D), I) : I(D);
    }
  }
  function Y6e(e, t) {
    let n = -1, r = !0, o = 0, a = [0, 0, 0, 0], i = [0, 0, 0, 0], s = !1, u = 0, c, f, p;
    const g = new W6e();
    for (; ++n < e.length; ) {
      const h = e[n], y = h[1];
      h[0] === "enter" ? y.type === "tableHead" ? (s = !1, u !== 0 && (HF(g, t, u, c, f), f = void 0, u = 0), c = {
        type: "table",
        start: Object.assign({}, y.start),
        // Note: correct end is set later.
        end: Object.assign({}, y.end)
      }, g.add(n, 0, [["enter", c, t]])) : y.type === "tableRow" || y.type === "tableDelimiterRow" ? (r = !0, p = void 0, a = [0, 0, 0, 0], i = [0, n + 1, 0, 0], s && (s = !1, f = {
        type: "tableBody",
        start: Object.assign({}, y.start),
        // Note: correct end is set later.
        end: Object.assign({}, y.end)
      }, g.add(n, 0, [["enter", f, t]])), o = y.type === "tableDelimiterRow" ? 2 : f ? 3 : 1) : o && (y.type === "data" || y.type === "tableDelimiterMarker" || y.type === "tableDelimiterFiller") ? (r = !1, i[2] === 0 && (a[1] !== 0 && (i[0] = i[1], p = xy(g, t, a, o, void 0, p), a = [0, 0, 0, 0]), i[2] = n)) : y.type === "tableCellDivider" && (r ? r = !1 : (a[1] !== 0 && (i[0] = i[1], p = xy(g, t, a, o, void 0, p)), a = i, i = [a[1], n, 0, 0])) : y.type === "tableHead" ? (s = !0, u = n) : y.type === "tableRow" || y.type === "tableDelimiterRow" ? (u = n, a[1] !== 0 ? (i[0] = i[1], p = xy(g, t, a, o, n, p)) : i[1] !== 0 && (p = xy(g, t, i, o, n, p)), o = 0) : o && (y.type === "data" || y.type === "tableDelimiterMarker" || y.type === "tableDelimiterFiller") && (i[3] = n);
    }
    for (u !== 0 && HF(g, t, u, c, f), g.consume(t.events), n = -1; ++n < t.events.length; ) {
      const h = t.events[n];
      h[0] === "enter" && h[1].type === "table" && (h[1]._align = K6e(t.events, n));
    }
    return e;
  }
  function xy(e, t, n, r, o, a) {
    const i = r === 1 ? "tableHeader" : r === 2 ? "tableDelimiter" : "tableData", s = "tableContent";
    n[0] !== 0 && (a.end = Object.assign({}, Uc(t.events, n[0])), e.add(n[0], 0, [["exit", a, t]]));
    const u = Uc(t.events, n[1]);
    if (a = {
      type: i,
      start: Object.assign({}, u),
      // Note: correct end is set later.
      end: Object.assign({}, u)
    }, e.add(n[1], 0, [["enter", a, t]]), n[2] !== 0) {
      const c = Uc(t.events, n[2]), f = Uc(t.events, n[3]), p = {
        type: s,
        start: Object.assign({}, c),
        end: Object.assign({}, f)
      };
      if (e.add(n[2], 0, [["enter", p, t]]), r !== 2) {
        const g = t.events[n[2]], h = t.events[n[3]];
        if (g[1].end = Object.assign({}, h[1].end), g[1].type = "chunkText", g[1].contentType = "text", n[3] > n[2] + 1) {
          const y = n[2] + 1, b = n[3] - n[2] - 1;
          e.add(y, b, []);
        }
      }
      e.add(n[3] + 1, 0, [["exit", p, t]]);
    }
    return o !== void 0 && (a.end = Object.assign({}, Uc(t.events, o)), e.add(o, 0, [["exit", a, t]]), a = void 0), a;
  }
  function HF(e, t, n, r, o) {
    const a = [], i = Uc(t.events, n);
    o && (o.end = Object.assign({}, i), a.push(["exit", o, t])), r.end = Object.assign({}, i), a.push(["exit", r, t]), e.add(n + 1, 0, a);
  }
  function Uc(e, t) {
    const n = e[t], r = n[0] === "enter" ? "start" : "end";
    return n[1][r];
  }
  const J6e = {
    name: "tasklistCheck",
    tokenize: Z6e
  };
  function Q6e() {
    return {
      text: {
        91: J6e
      }
    };
  }
  function Z6e(e, t, n) {
    const r = this;
    return o;
    function o(u) {
      return (
        // Exit if theres stuff before.
        r.previous !== null || // Exit if not in the first content that is the first child of a list
        // item.
        !r._gfmTasklistFirstContentOfListItem ? n(u) : (e.enter("taskListCheck"), e.enter("taskListCheckMarker"), e.consume(u), e.exit("taskListCheckMarker"), a)
      );
    }
    function a(u) {
      return ln(u) ? (e.enter("taskListCheckValueUnchecked"), e.consume(u), e.exit("taskListCheckValueUnchecked"), i) : u === 88 || u === 120 ? (e.enter("taskListCheckValueChecked"), e.consume(u), e.exit("taskListCheckValueChecked"), i) : n(u);
    }
    function i(u) {
      return u === 93 ? (e.enter("taskListCheckMarker"), e.consume(u), e.exit("taskListCheckMarker"), e.exit("taskListCheck"), s) : n(u);
    }
    function s(u) {
      return Je(u) ? t(u) : kt(u) ? e.check({
        tokenize: eze
      }, t, n)(u) : n(u);
    }
  }
  function eze(e, t, n) {
    return Mt(e, r, "whitespace");
    function r(o) {
      return o === null ? n(o) : t(o);
    }
  }
  function tze(e) {
    return YH([
      C6e(),
      D6e(),
      H6e(e),
      G6e(),
      Q6e()
    ]);
  }
  const nze = {};
  function rze(e) {
    const t = (
      /** @type {Processor<Root>} */
      this
    ), n = e || nze, r = t.data(), o = r.micromarkExtensions || (r.micromarkExtensions = []), a = r.fromMarkdownExtensions || (r.fromMarkdownExtensions = []), i = r.toMarkdownExtensions || (r.toMarkdownExtensions = []);
    o.push(tze(n)), a.push(k6e()), i.push(S6e(n));
  }
  const yN = ({
    availableModule: e
  }) => {
    const [t, n] = C.useState(!1), r = () => n(!t), o = 150, a = e.description.length > o ? e.description.substring(0, o) + "..." : e.description;
    return /* @__PURE__ */ S.jsxs("div", { className: "module-description", children: [
      /* @__PURE__ */ S.jsx(HFe, { remarkPlugins: [rze], children: t ? e.description.replace(/\\n/g, `
`) : a.replace(/\\n/g, `
`) }),
      e.description.length > o && /* @__PURE__ */ S.jsx("button", { onClick: r, className: "toggle-description", children: t ? "Show less" : "Show more" })
    ] });
  }, WF = [
    ">=",
    "==",
    "<=",
    "<",
    ">"
  ], Bx = ">=", bN = ({
    availableModule: e,
    on_change: t
  }) => {
    const [n, r] = C.useState(
      e.version || "latest"
    ), [o, a] = C.useState(Bx), i = (u) => {
      const c = u.target.value;
      r(c), t(c !== "latest" ? o + c : c);
    }, s = (u) => {
      u.target.value !== o && WF.includes(u.target.value) && (a(u.target.value), n !== "latest" && t(u.target.value + n));
    };
    return e.releases && !e.releases.includes(n) && e.releases.unshift(n), /* @__PURE__ */ S.jsxs(S.Fragment, { children: [
      /* @__PURE__ */ S.jsx("select", { value: o, onChange: s, children: WF.map((u) => /* @__PURE__ */ S.jsx("option", { value: u, children: u }, u)) }),
      /* @__PURE__ */ S.jsx("select", { onChange: i, value: n, children: e.releases && e.releases.map((u) => /* @__PURE__ */ S.jsx("option", { value: u, children: u }, u)) })
    ] });
  }, oze = ({
    availableModule: e,
    on_remove: t,
    on_update: n
  }) => {
    const [r, o] = C.useState(
      Bx + e.version || "latest"
    );
    return /* @__PURE__ */ S.jsxs("div", { className: "addable-module", children: [
      /* @__PURE__ */ S.jsx("div", { className: "module-name", children: e.name + (e.version ? ` (${e.version})` : "") }),
      /* @__PURE__ */ S.jsx(ZO, { availableModule: e }),
      /* @__PURE__ */ S.jsx(yN, { availableModule: e }),
      /* @__PURE__ */ S.jsxs("div", { children: [
        /* @__PURE__ */ S.jsx(
          bN,
          {
            availableModule: e,
            on_change: o
          }
        ),
        /* @__PURE__ */ S.jsx(
          "button",
          {
            className: "update-button",
            disabled: r === e.version,
            onClick: () => {
              n(e, r);
            },
            children: "Update"
          }
        ),
        /* @__PURE__ */ S.jsx(
          "button",
          {
            className: "remove-button",
            onClick: () => {
              t(e);
            },
            children: "Remove"
          }
        )
      ] })
    ] });
  }, aze = ({
    availableModule: e,
    on_add: t
  }) => {
    const [n, r] = C.useState(
      Bx + e.version || "latest"
    );
    return /* @__PURE__ */ S.jsxs("div", { className: "addable-module", children: [
      /* @__PURE__ */ S.jsx("div", { className: "module-name", children: e.name + (e.version ? ` (${e.version})` : "") }),
      /* @__PURE__ */ S.jsx(ZO, { availableModule: e }),
      /* @__PURE__ */ S.jsx(yN, { availableModule: e }),
      /* @__PURE__ */ S.jsxs("div", { children: [
        /* @__PURE__ */ S.jsx(
          bN,
          {
            availableModule: e,
            on_change: r
          }
        ),
        /* @__PURE__ */ S.jsx(
          "button",
          {
            className: "add-button",
            onClick: () => {
              t(e, n);
            },
            children: "Add"
          }
        )
      ] })
    ] });
  }, ize = ({
    availableModule: e,
    on_add: t
  }) => {
    const [n, r] = C.useState(
      Bx + e.version || "latest"
    );
    return /* @__PURE__ */ S.jsxs("div", { className: "addable-module", children: [
      /* @__PURE__ */ S.jsx("div", { className: "module-name", children: e.name }),
      /* @__PURE__ */ S.jsx(ZO, { availableModule: e }),
      /* @__PURE__ */ S.jsx(yN, { availableModule: e }),
      /* @__PURE__ */ S.jsxs("div", { children: [
        /* @__PURE__ */ S.jsx(
          bN,
          {
            availableModule: e,
            on_change: r
          }
        ),
        /* @__PURE__ */ S.jsx(
          "button",
          {
            className: "add-button",
            onClick: () => {
              t(e, n);
            },
            children: "Add"
          }
        )
      ] })
    ] });
  }, sze = ({
    ins: e
  }) => {
    const [t, n] = C.useState(e.name), r = Vt(), { lib: o } = Nr(), a = () => {
      r.worker && o?.remove_external_worker(e.uuid, e.nodeclassid);
    }, i = () => {
      r.worker && (r.worker.update_external_worker(e.uuid, e.nodeclassid, {
        name: t
      }), e.name = t);
    };
    return /* @__PURE__ */ S.jsx(S.Fragment, { children: /* @__PURE__ */ S.jsx(
      Qa,
      {
        title: e.name,
        description: "Settings for " + e.name,
        trigger: /* @__PURE__ */ S.jsx("div", { children: "Settings" }),
        buttons: [
          {
            text: "Save",
            onClick: i,
            close: !0
          },
          {
            text: "Delete",
            onClick: a,
            close: !0
          }
        ],
        children: /* @__PURE__ */ S.jsxs("div", { children: [
          /* @__PURE__ */ S.jsxs("div", { children: [
            /* @__PURE__ */ S.jsx("label", { htmlFor: "name", children: "Name: " }),
            /* @__PURE__ */ S.jsx(
              "input",
              {
                type: "text",
                name: "name",
                value: t,
                onChange: (s) => n(s.target.value),
                className: "styledinput"
              }
            )
          ] }),
          o && /* @__PURE__ */ S.jsx(
            _U,
            {
              getter: () => o.get_external_worker_config(e.uuid, e.nodeclassid),
              setter: async (s) => {
                if (r.worker)
                  return await r.worker.update_external_worker(
                    e.uuid,
                    e.nodeclassid,
                    {
                      name: t,
                      config: s
                    }
                  );
              },
              setter_calls_getter: !0
            }
          )
        ] })
      }
    ) });
  }, lze = ({
    ins: e,
    lib: t,
    filter: n = "",
    parentkey: r
  }) => {
    const [o, a] = C.useState(!1), i = () => a(!o), s = t?.nodes?.filter(
      (u) => u.node_id.toLowerCase().includes(n.toLowerCase())
    );
    return /* @__PURE__ */ S.jsxs("div", { className: "shelfcontainer", children: [
      /* @__PURE__ */ S.jsxs(
        "div",
        {
          className: "shelftitle",
          onClick: i,
          style: { cursor: "pointer" },
          title: e.name,
          children: [
            /* @__PURE__ */ S.jsx("div", { className: "shelftitle_text", children: e.name }),
            /* @__PURE__ */ S.jsx("div", { className: "expandicon " + (o ? "open" : "close"), children: /* @__PURE__ */ S.jsx(Wm, {}) })
          ]
        }
      ),
      /* @__PURE__ */ S.jsx("div", { className: "libnodecontainer " + (o ? "open" : "close"), children: /* @__PURE__ */ S.jsx("div", { className: "libnodecontainer_inner", children: o && /* @__PURE__ */ S.jsxs(S.Fragment, { children: [
        /* @__PURE__ */ S.jsx("div", { className: "libnodeentry", title: e.uuid, children: /* @__PURE__ */ S.jsx(sze, { ins: e }) }),
        t && /* @__PURE__ */ S.jsxs(S.Fragment, { children: [
          s && /* @__PURE__ */ S.jsx(S.Fragment, { children: s.map((u) => /* @__PURE__ */ S.jsx(
            AH,
            {
              item: u
            },
            r + u.node_id
          )) }),
          t.subshelves.map((u) => /* @__PURE__ */ S.jsx(
            QO,
            {
              item: u,
              filter: n,
              parentkey: r + u.name
            },
            r + u.name
          ))
        ] })
      ] }) }) })
    ] });
  }, uze = ({
    item: e,
    mod: t,
    lib: n
  }) => {
    const { lib: r } = Nr(), [o, a] = C.useState(!1), i = () => a(!o), s = C.useCallback(() => {
      r?.add_external_worker({
        module: t,
        cls_module: e.module,
        cls_name: e.class_name
      });
    }, [r, t, e]), u = (f) => {
      f.detail === 2 && s();
    }, c = e.name || e.module + "." + e.class_name;
    return /* @__PURE__ */ S.jsxs("div", { className: "shelfcontainer", children: [
      /* @__PURE__ */ S.jsxs(
        "div",
        {
          className: "shelftitle",
          onClick: i,
          style: { cursor: "pointer" },
          title: c,
          children: [
            /* @__PURE__ */ S.jsx("div", { className: "shelftitle_text", children: c }),
            /* @__PURE__ */ S.jsx("div", { className: "expandicon " + (o ? "open" : "close"), children: /* @__PURE__ */ S.jsx(Wm, {}) })
          ]
        }
      ),
      /* @__PURE__ */ S.jsx("div", { className: "libnodecontainer " + (o ? "open" : "close"), children: /* @__PURE__ */ S.jsx("div", { className: "libnodecontainer_inner", children: o && /* @__PURE__ */ S.jsxs(S.Fragment, { children: [
        /* @__PURE__ */ S.jsx(
          "div",
          {
            className: "libnodeentry",
            onClick: u,
            title: e.name,
            children: "New Instance"
          }
        ),
        e.instances.map((f) => /* @__PURE__ */ S.jsx(
          lze,
          {
            ins: f,
            lib: n?.subshelves.find(
              (p) => p.name === f.uuid
            ),
            parentkey: f.uuid
          },
          f.uuid
        ))
      ] }) }) })
    ] });
  }, cze = ({
    externalworkermod: e,
    lib: t
  }) => {
    const [n, r] = C.useState(!1), o = () => r(!n), a = n;
    return /* @__PURE__ */ S.jsxs("div", { className: "shelfcontainer", children: [
      /* @__PURE__ */ S.jsxs(
        "div",
        {
          className: "shelftitle",
          onClick: o,
          style: { cursor: "pointer" },
          title: e.module,
          children: [
            /* @__PURE__ */ S.jsx("div", { className: "shelftitle_text", children: e.module }),
            /* @__PURE__ */ S.jsx("div", { className: "expandicon " + (a ? "open" : "close"), children: /* @__PURE__ */ S.jsx(Wm, {}) })
          ]
        }
      ),
      /* @__PURE__ */ S.jsx("div", { className: "libnodecontainer " + (a ? "open" : "close"), children: /* @__PURE__ */ S.jsx("div", { className: "libnodecontainer_inner", children: e.worker_classes.map((i) => /* @__PURE__ */ S.jsx(
        uze,
        {
          item: i,
          mod: e.module,
          lib: t
        },
        i.module + i.class_name
      )) }) }),
      /* @__PURE__ */ S.jsx("hr", {})
    ] });
  }, dze = () => {
    const e = Vt(), t = e.lib.libstate(), n = e.local_settings(
      (u) => u.view_settings.expand_lib
    ), r = (u) => {
      e.update_view_settings({ expand_lib: u });
    }, o = cAe("m"), [a, i] = C.useState(""), s = e.workerstate((u) => u.is_open);
    return /* @__PURE__ */ S.jsx(
      AO,
      {
        maxSize: o ? "100%" : "18.75rem",
        direction: o ? "down" : "right",
        containerClassName: "pos-left pos-top bg1 h-12",
        onExpandChange: r,
        expanded: n === void 0 ? !0 : n,
        collapseIcons: {
          up: ub,
          down: em,
          left: Zp,
          right: lb
        },
        expandIcons: {
          up: em,
          down: ub,
          left: lb,
          right: Zp
        },
        children: /* @__PURE__ */ S.jsxs("div", { className: "libcontainer", children: [
          /* @__PURE__ */ S.jsxs("div", { className: "library", children: [
            /* @__PURE__ */ S.jsx("div", { className: "libtitle", children: "Lib" }),
            /* @__PURE__ */ S.jsx("hr", { className: "hr_prominent" }),
            /* @__PURE__ */ S.jsx(j3e, { filter: a, setFilter: i }),
            /* @__PURE__ */ S.jsx("div", { className: "vscrollcontainer", children: t.lib.shelves.filter((u) => u.name !== "_external_worker").map((u) => /* @__PURE__ */ S.jsx(
              QO,
              {
                item: u,
                filter: a,
                parentkey: u.name
              },
              u.name
            )) }),
            /* @__PURE__ */ S.jsx("hr", {}),
            /* @__PURE__ */ S.jsx("div", { className: "libtitle", children: "External Worker" }),
            /* @__PURE__ */ S.jsx("hr", { className: "hr_prominent" }),
            /* @__PURE__ */ S.jsx("div", { className: "vscrollcontainer", children: t.external_worker?.map((u) => /* @__PURE__ */ S.jsx(
              cze,
              {
                externalworkermod: u,
                lib: t.lib.shelves.find(
                  (c) => c.name === "_external_worker"
                )
              },
              u.module
            )) }),
            /* @__PURE__ */ S.jsx("hr", {})
          ] }),
          s && /* @__PURE__ */ S.jsx("div", { className: "addlib", children: /* @__PURE__ */ S.jsx(I3e, { children: /* @__PURE__ */ S.jsx("button", { children: "Manage Libraries" }) }) })
        ] })
      }
    );
  }, fze = ({
    fnrf_zst: e,
    header: t,
    flow: n,
    library: r
  }) => {
    const [o, a] = C.useState(
      e.options.worker || e.getWorkerManager().worker
    ), i = C.useRef(null);
    e.workermanager && (e.workermanager.on_setWorker = a), C.useEffect(() => {
      e.auto_progress();
    }, []), C.useEffect(() => {
      e.local_state.setState({ funcnodescontainerRef: i.current });
    }, [i]);
    const s = e.plugins();
    return /* @__PURE__ */ S.jsx(JIe, { plugins: s, fnrf_zst: e, children: /* @__PURE__ */ S.jsx(rae, { children: /* @__PURE__ */ S.jsx(Nz.Provider, { value: e, children: /* @__PURE__ */ S.jsx(Ks, { asChild: !0, children: /* @__PURE__ */ S.jsx(Ai, { asChild: !0, children: /* @__PURE__ */ S.jsx(
      MU,
      {
        style: {
          height: "100%",
          width: "100%",
          display: "flex",
          flexDirection: "column",
          flex: 1
        },
        children: /* @__PURE__ */ S.jsxs(
          "div",
          {
            ref: i,
            className: "funcnodesreactflowcontainer funcnodescontainer",
            children: [
              t.show && /* @__PURE__ */ S.jsx(R3e, { ...t }),
              /* @__PURE__ */ S.jsxs("div", { className: "funcnodesreactflowbody", children: [
                /* @__PURE__ */ S.jsx(u$e, { ...n }),
                o && r.show && /* @__PURE__ */ S.jsx(dze, {}),
                o && n.showNodeSettings && /* @__PURE__ */ S.jsx(hAe, {})
              ] }),
              /* @__PURE__ */ S.jsxs("div", { className: "funcnodesflaotingmenu", children: [
                /* @__PURE__ */ S.jsx(Ai.OutFullScreen, { children: n.allowExpand && /* @__PURE__ */ S.jsxs(Ks.Trigger, { children: [
                  /* @__PURE__ */ S.jsx(Ks.Expanded, { children: /* @__PURE__ */ S.jsx(
                    Koe,
                    {
                      size: "xl",
                      style: { padding: "4px" }
                    }
                  ) }),
                  /* @__PURE__ */ S.jsx(Ks.Collapsed, { children: /* @__PURE__ */ S.jsx(
                    Goe,
                    {
                      size: "xl",
                      style: { padding: "4px" }
                    }
                  ) })
                ] }) }),
                n.allowFullScreen && /* @__PURE__ */ S.jsxs(Ai.Trigger, { children: [
                  /* @__PURE__ */ S.jsx(Ai.OutFullScreen, { children: /* @__PURE__ */ S.jsx(
                    Oz,
                    {
                      size: "xl",
                      style: { padding: "4px" }
                    }
                  ) }),
                  /* @__PURE__ */ S.jsx(Ai.InFullScreen, { children: /* @__PURE__ */ S.jsx(
                    qoe,
                    {
                      size: "xl",
                      style: { padding: "4px" }
                    }
                  ) })
                ] })
              ] })
            ]
          }
        )
      }
    ) }) }) }) }) });
  };
  class Xd {
    constructor(t) {
      this.context = t;
    }
    get nodespaceManager() {
      return this.context.rf.getNodespaceManager();
    }
    get libManager() {
      return this.context.rf.getLibManager();
    }
    get workerManager() {
      return this.context.rf.getWorkerManager();
    }
    get stateManager() {
      return this.context.rf.getStateManager();
    }
    get pluginManager() {
      return this.context.rf.getPluginManager();
    }
    get reactFlowManager() {
      return this.context.rf.getReactFlowManager();
    }
  }
  const qF = ({
    src_nid: e,
    src_ioid: t,
    trg_nid: n,
    trg_ioid: r
  }) => [`${e}:${t}`, `${n}:${r}`].sort().join("--"), pze = ({}) => {
    const e = /* @__PURE__ */ new Map();
    return {
      nodesstates: e,
      get_node: (t, n = !0) => {
        const r = e.get(t);
        if (!r && n) {
          const o = e.keys();
          throw new Error(
            `Node ${t} not found, available nodes: ${Array.from(o)}`
          );
        }
        return r;
      }
    };
  };
  class mze extends Xd {
    constructor(t) {
      super(t), this.on_node_action = (n) => {
        switch (n.type) {
          case "add":
            return this._add_node(n);
          case "update":
            return this._update_node(n);
          case "delete":
            return this._delete_node(n);
          case "error":
            return this._error_action(n);
          case "trigger":
            return this._trigger_action(n);
          default:
            this.context.rf.logger.error("Unknown node action", n);
            return;
        }
      }, this.on_edge_action = (n) => {
        const r = this.reactFlowManager.useReactFlowStore.getState();
        switch (n.type) {
          case "add":
            if (n.from_remote) {
              const o = r.getEdges(), a = qF(n);
              if (o.some((s) => s.id === a))
                return;
              const i = {
                id: a,
                source: n.src_nid,
                target: n.trg_nid,
                sourceHandle: n.src_ioid,
                targetHandle: n.trg_ioid,
                className: "funcnodes-edge animated",
                zIndex: 1003
                // just above elevated groups
              };
              this.context.rf.logger.info("Adding edge", i), r.update_edges([...o, i]), this.workerManager.worker?.api.node.get_remote_node_state(
                n.src_nid
              ), this.workerManager.worker?.api.node.get_remote_node_state(
                n.trg_nid
              );
            }
            break;
          case "delete":
            if (n.from_remote) {
              const o = r.getEdges(), a = qF(n);
              this.context.rf.logger.info("Deleting edge", a);
              const i = o.filter((s) => s.id !== a);
              r.update_edges(i), this.workerManager.worker?.api.node.get_remote_node_state(
                n.src_nid
              ), this.workerManager.worker?.api.node.get_remote_node_state(
                n.trg_nid
              );
            }
            break;
          default:
            this.context.rf.logger.error("Unknown edge action", n);
        }
      }, this.on_group_action = (n) => {
        switch (n.type) {
          case "set":
            return this._set_groups(n.groups);
          case "update":
            return this._update_group(n);
          default:
            this.context.rf.logger.error("Unknown group action", n);
        }
      }, this.clear_all = () => {
        this.context.rf.logger.debug("Clearing all nodespace"), this.workerManager.worker?.disconnect(), this.workerManager.set_worker(void 0), this.workerManager.workermanager?.setWorker(void 0), this.libManager.lib.libstate.getState().set({ lib: { shelves: [] }, external_worker: [] }), this.nodespace.nodesstates.clear(), this.reactFlowManager.useReactFlowStore.getState().update_nodes([]), this.reactFlowManager.useReactFlowStore.getState().update_edges([]), this.stateManager.auto_progress();
      }, this.center_node = (n) => {
        if (!this.reactFlowManager.rf_instance)
          return;
        n = Array.isArray(n) ? n : [n];
        const r = this.reactFlowManager.useReactFlowStore.getState().getNodes().filter((o) => n.includes(o.id));
        r.length > 0 && this.reactFlowManager.rf_instance?.fitView({ padding: 0.2, nodes: r });
      }, this.auto_resize_group = (n) => {
        const r = this.reactFlowManager.useReactFlowStore.getState(), o = r.getNode(n);
        if (o === void 0 || o.type !== "group")
          return;
        const a = o.data.group.node_ids.map((f) => r.getNode(f)).filter((f) => f !== void 0), i = o.data.group.child_groups.map((f) => r.getNode(f)).filter((f) => f !== void 0), s = [...a, ...i], u = this.reactFlowManager.rf_instance?.getNodesBounds(s);
        if (u === void 0)
          return;
        const c = {
          ...o,
          position: {
            x: u.x,
            y: u.y
          },
          height: u.height,
          width: u.width
        };
        c.data.group.position = [u.x, u.y], r.partial_update_nodes([c]);
      }, this.change_group_position = (n) => {
        if (n.position === void 0)
          return;
        const r = this.reactFlowManager.useReactFlowStore.getState(), o = r.getNode(n.id);
        if (o === void 0 || o.type !== "group")
          return;
        const a = [
          ...o.data.group.node_ids,
          ...o.data.group.child_groups
        ], i = this.reactFlowManager.rf_instance?.getNodesBounds(a);
        if (i === void 0)
          return;
        const s = n.position.x - i?.x, u = n.position.y - i?.y, c = [];
        for (const f of a) {
          const p = r.getNode(f);
          p !== void 0 && c.push({
            id: f,
            type: "position",
            position: {
              x: p.position.x + s,
              y: p.position.y + u
            }
          });
        }
        r.onNodesChange(c);
      }, this.change_fn_node_position = (n) => {
        n.position !== void 0 && this.on_node_action({
          type: "update",
          id: n.id,
          node: {
            properties: {
              "frontend:pos": [n.position.x, n.position.y]
            }
          },
          from_remote: !1
        });
      }, this.change_group_dimensions = (n) => {
        if (n.dimensions === void 0)
          return;
        const r = this.reactFlowManager.useReactFlowStore.getState().getNode(n.id);
        r !== void 0 && this.reactFlowManager.useReactFlowStore.getState().partial_update_nodes(CP([n], [r]));
      }, this.change_fn_node_dimensions = (n) => {
        n.dimensions !== void 0 && this.on_node_action({
          type: "update",
          id: n.id,
          node: {
            properties: {
              "frontend:size": [n.dimensions.width, n.dimensions.height]
            }
          },
          from_remote: !1
        });
      }, this._update_group = (n) => {
        if (n.from_remote) {
          const r = this.reactFlowManager.useReactFlowStore.getState(), o = r.getNode(n.id);
          if (o === void 0 || o.type !== "group")
            return;
          const { new_obj: a, change: i } = tl(o.data.group, n.group);
          i && (o.data.group = a), r.partial_update_nodes([o]);
        } else
          this.workerManager.worker && this.workerManager.worker.api.group.locally_update_group(n);
      }, this._set_groups = (n) => {
        const r = this.reactFlowManager.useReactFlowStore.getState(), { default_nodes: o } = TO(r.getNodes()), a = [...o], i = {};
        for (const u in n) {
          const c = n[u];
          for (const p of c.node_ids)
            i[p] = u;
          for (const p of c.child_groups)
            i[p] = u;
          c.position === void 0 && (c.position = [0, 0]);
          const f = {
            id: u,
            type: "group",
            data: { group: n[u], id: u },
            position: { x: c.position[0], y: c.position[1] },
            zIndex: 2
          };
          c.parent_group && (f.data.groupID = c.parent_group), a.push(f);
        }
        for (const u of a)
          u.id in i ? u.data.groupID = i[u.id] : u.data.groupID = void 0;
        const s = zO(a);
        r.update_nodes(s);
        for (const u of s.reverse())
          u.type === "group" && this.auto_resize_group(u.id);
      }, this._add_node = (n) => {
        this.context.rf.logger.info("add node", n);
        const r = this.reactFlowManager.useReactFlowStore.getState();
        if (n.from_remote) {
          let o = this.nodespace.get_node(n.node.id, !1);
          if (o)
            return;
          if (!o)
            try {
              o = t$e(n.node), this.nodespace.nodesstates.set(n.node.id, o);
            } catch (u) {
              this.context.rf.logger.error(`Failed to create node store ${u}`);
              return;
            }
          const a = o.getState();
          this.context.rf.logger.info("Add node", a.id, a.name);
          const i = l$e(o, this.context.rf), s = [...r.getNodes(), i];
          this.reactFlowManager.useReactFlowStore.getState().update_nodes(s);
          for (const u of i.io_order)
            this.workerManager.worker?.api.node.get_io_value({
              nid: i.id,
              ioid: u
            });
          return setTimeout(() => {
            this.workerManager.worker?.api.hooks.call_hooks("node_added", {
              node: a.id
            });
          }, 0), a;
        }
      }, this._update_node = (n) => {
        if (Object.keys(n.node).length === 0) {
          this.context.rf.logger.error(
            "Node update is empty",
            new Error(JSON.stringify(n))
          );
          return;
        }
        if (n.node.in_trigger && (n.node.error = void 0), n.from_remote) {
          const r = this.nodespace.get_node(n.id, !1);
          if (!r) {
            console.error("Node not found to update", n.id);
            return;
          }
          return r.update(n.node), r.getState();
        } else
          this.workerManager.worker && this.workerManager.worker.api.node.locally_update_node(n);
      }, this._sync_nodes = () => {
        const n = this.reactFlowManager.useReactFlowStore.getState().getNodes(), r = this.nodespace.nodesstates;
        for (const o of r.keys())
          n.some((a) => a.id === o) || r.delete(o);
      }, this._delete_node = (n) => {
        this.context.rf.logger.info("Deleting node", n.id), n.from_remote ? (this.reactFlowManager.useReactFlowStore.getState().onNodesChange([
          {
            type: "remove",
            id: n.id
          }
        ]), this._sync_nodes()) : this.workerManager.worker?.api.node.remove_node(n.id);
      }, this._error_action = (n) => (this.context.rf.logger.error("Error", new Error(JSON.stringify(n))), this.on_node_action({
        type: "update",
        id: n.id,
        node: {
          in_trigger: !1,
          error: n.error
        },
        from_remote: !0
      })), this._trigger_action = (n) => {
        if (n.from_remote)
          return this.on_node_action({
            type: "update",
            id: n.id,
            node: {
              in_trigger: !0,
              error: void 0
            },
            from_remote: !0
          });
        this.workerManager.worker?.api.node.trigger_node(n.id);
      }, this.nodespace = pze({});
    }
    center_all() {
      this.reactFlowManager.rf_instance?.fitView({ padding: 0.2 });
    }
  }
  const hze = () => ({
    libstate: Ro((e, t) => ({
      lib: {
        shelves: []
      },
      external_worker: [],
      set: (n) => e((r) => ({ ...r, ...n })),
      get_lib: () => t().lib,
      get_external_worker: () => t().external_worker
    }))
  });
  class gze extends Xd {
    constructor(t) {
      super(t), this.lib = hze();
    }
  }
  class vze extends Xd {
    constructor(t) {
      super(t), t.rf.logger.debug("Initializing worker manager handler"), this.workers = Ro((n, r) => ({})), this.workerstate = Ro((n, r) => ({
        is_open: !1
      }));
    }
    set_worker(t) {
      t !== this.worker && (this._unsubscribeFromWorker && (this._unsubscribeFromWorker(), this._unsubscribeFromWorker = void 0), t ? (this.context.rf.logger.debug("Setting worker in worker manager"), this._unsubscribeFromWorker = t.state.subscribe((n) => {
        this.workerstate.setState(n);
      }), this.workerstate.setState(t.state.getState())) : this.context.rf.logger.debug("Removing worker in worker manager"), this.worker = t, t?.set_zustand(this.context.rf));
    }
  }
  class yze extends Xd {
    constructor(t) {
      super(t), this.progress_state = Ro((n, r) => ({
        message: "please select worker",
        status: "info",
        progress: 0,
        blocking: !1
      })), this.local_settings = Ro(
        (n, r) => ({
          view_settings: {
            expand_node_props: !1,
            expand_lib: !1
          }
        })
      ), this.local_state = Ro((n, r) => ({
        selected_nodes: [],
        selected_edges: [],
        selected_groups: [],
        funcnodescontainerRef: null
      }));
    }
    set_progress(t) {
      if (t.message === "")
        return this.auto_progress();
      const n = this.progress_state.getState(), { new_obj: r, change: o } = tl(n, t);
      o && this.progress_state.setState(r);
    }
    auto_progress() {
      const t = this.workerManager.workermanager, n = this.workerManager.worker;
      if (t !== void 0 && !t.open)
        return this.set_progress({
          progress: 0,
          message: "connecting to worker manager",
          status: "error",
          blocking: !1
        });
      if (n === void 0)
        return this.set_progress({
          progress: 0,
          message: "please select worker",
          status: "error",
          blocking: !1
        });
      if (!n.is_open)
        return this.set_progress({
          progress: 0,
          message: "connecting to worker",
          status: "info",
          blocking: !0
        });
      this.set_progress({
        progress: 1,
        message: "running",
        status: "info",
        blocking: !1
      });
    }
    update_view_settings(t) {
      XU(this.local_settings, { view_settings: t });
    }
  }
  const zW = "1.0.0", bze = ["1"], wze = (e) => {
    if (!e.v.toString().includes(".") || // old polugin version without "."
    !bze.includes(e.v.toString().split(".")[0]))
      throw new Error(`Unsupported version: ${e.v}`);
    return { ...e, v: zW };
  };
  class xze extends Xd {
    constructor(t) {
      super(t), this.plugins = Ro((n, r) => ({})), this.render_options = Ro((n, r) => ({}));
    }
    add_plugin(t, n) {
      if (n !== void 0)
        try {
          const r = wze(n);
          this.plugins.setState((o) => ({ ...o, [t]: r }));
        } catch (r) {
          r instanceof Error ? this.context.rf.logger.error(`Error loading plugin ${t}`, r) : this.context.rf.logger.error(
            `Error loading plugin ${t}`,
            new Error(String(r))
          ), this.stateManager.toaster?.error({
            title: "Error",
            description: `Error loading plugin ${t}: ${r instanceof Error ? r.message : String(r)}`,
            duration: 5e3
          });
        }
    }
    update_render_options(t) {
      XU(this.render_options, t);
    }
    async add_packed_plugin(t, n) {
      if (n.js)
        for (const r of n.js) {
          const o = document.createElement("script");
          o.text = atob(r), document.body.appendChild(o);
        }
      if (n.css)
        for (const r of n.css) {
          const o = document.createElement("style");
          o.innerHTML = atob(r), document.head.appendChild(o);
        }
      if (n.module !== void 0) {
        const r = atob(n.module);
        try {
          const o = await new Function(
            "React",
            "FuncNodesReactFlow",
            `
          return (async () => {
            ${r}
            return FuncNodesPlugin;
          })();
        `
          )(Rm, nG);
          this.add_plugin(t, o);
        } catch (o) {
          o instanceof Error ? this.context.rf.logger.error(`Error building plugin ${t}`, o) : this.context.rf.logger.error(
            `Error building plugin ${t}`,
            new Error(String(o))
          ), this.stateManager.toaster?.error({
            title: "Error",
            description: `Error building plugin ${t}: ${o}`,
            duration: 5e3
          });
        }
      }
    }
  }
  class kze extends Xd {
    constructor(t) {
      super(t), this.on_rf_node_change = (n) => {
        const r = this.useReactFlowStore.getState();
        for (const o of n)
          switch (o.type) {
            case "position":
              if (o.position) {
                const a = r.getNode(o.id);
                if (a === void 0)
                  continue;
                a.type === "group" ? this.nodespaceManager.change_group_position(o) : this.nodespaceManager.change_fn_node_position(o), a.data.groupID && this.nodespaceManager.auto_resize_group(a.data.groupID);
              }
              break;
            case "dimensions":
              if (o.dimensions) {
                const a = r.getNode(o.id);
                if (a === void 0)
                  continue;
                a.type === "group" ? this.nodespaceManager.change_group_dimensions(o) : this.nodespaceManager.change_fn_node_dimensions(o), a.data.groupID && this.nodespaceManager.auto_resize_group(
                  a.data.groupID
                );
              }
              break;
          }
      }, this.on_rf_edge_change = (n) => {
      }, this.on_connect = (n) => {
        n.source === null || n.target === null || n.sourceHandle === null || n.targetHandle === null || !this.workerManager.worker || this.workerManager.worker.api.edge.add_edge({
          src_nid: n.source,
          src_ioid: n.sourceHandle,
          trg_nid: n.target,
          trg_ioid: n.targetHandle,
          replace: !0
        });
      }, this.useReactFlowStore = c$e({
        on_node_change: this.on_rf_node_change.bind(this),
        on_edge_change: this.on_rf_edge_change.bind(this),
        on_connect: this.on_connect.bind(this)
      });
    }
  }
  let Sze = class {
    constructor(e) {
      this.reactflowRef = null, this.dev_settings = {
        debug: Cm()
      }, this.options = e, this.logger = e.logger ?? new UE("fn", Cm() ? JF : QF);
      const t = { rf: this };
      this._nodespaceManager = new mze(t), this._libManager = new gze(t), this._workerManager = new vze(t), this._stateManager = new yze(t), this._pluginManager = new xze(t), this._reactFlowManager = new kze(t);
    }
    // #region handlers
    getNodespaceManager() {
      return this._nodespaceManager;
    }
    getLibManager() {
      return this._libManager;
    }
    getWorkerManager() {
      return this._workerManager;
    }
    getStateManager() {
      return this._stateManager;
    }
    getPluginManager() {
      return this._pluginManager;
    }
    getReactFlowManager() {
      return this._reactFlowManager;
    }
    // #endregion handlers
    // #region nodespace manager
    get nodespace() {
      return this._nodespaceManager.nodespace;
    }
    get on_node_action() {
      return this._nodespaceManager.on_node_action.bind(this._nodespaceManager);
    }
    get on_edge_action() {
      return this._nodespaceManager.on_edge_action.bind(this._nodespaceManager);
    }
    get on_group_action() {
      return this._nodespaceManager.on_group_action.bind(this._nodespaceManager);
    }
    get clear_all() {
      return this._nodespaceManager.clear_all.bind(this._nodespaceManager);
    }
    get center_node() {
      return this._nodespaceManager.center_node.bind(this._nodespaceManager);
    }
    get center_all() {
      return this._nodespaceManager.center_all.bind(this._nodespaceManager);
    }
    // #endregion nodespace manager
    // #region lib manager
    get lib() {
      return this._libManager.lib;
    }
    // #endregion lib manager
    // #region worker manager
    get set_worker() {
      return this._workerManager.set_worker.bind(this._workerManager);
    }
    get workermanager() {
      return this._workerManager.workermanager;
    }
    set workermanager(e) {
      this._workerManager.workermanager = e;
    }
    get worker() {
      return this._workerManager.worker;
    }
    get workers() {
      return this._workerManager.workers;
    }
    get workerstate() {
      return this._workerManager.workerstate;
    }
    get _unsubscribeFromWorker() {
      return this._workerManager._unsubscribeFromWorker?.bind(
        this._workerManager
      );
    }
    // #endregion worker manager
    // #region statemanager
    get set_progress() {
      return this._stateManager.set_progress.bind(this._stateManager);
    }
    get auto_progress() {
      return this._stateManager.auto_progress.bind(this._stateManager);
    }
    get progress_state() {
      return this._stateManager.progress_state;
    }
    get local_settings() {
      return this._stateManager.local_settings;
    }
    get local_state() {
      return this._stateManager.local_state;
    }
    update_view_settings(e) {
      this._stateManager.update_view_settings(e);
    }
    // #endregion statemanager
    // #region plugis
    get plugins() {
      return this._pluginManager.plugins.bind(this._pluginManager);
    }
    get add_plugin() {
      return this._pluginManager.add_plugin.bind(this._pluginManager);
    }
    get add_packed_plugin() {
      return this._pluginManager.add_packed_plugin.bind(this._pluginManager);
    }
    get render_options() {
      return this._pluginManager.render_options.bind(this._pluginManager);
    }
    get update_render_options() {
      return this._pluginManager.update_render_options.bind(this._pluginManager);
    }
    // #endregion plugis
    // #region reactflow
    get useReactFlowStore() {
      return this._reactFlowManager.useReactFlowStore.bind(
        this._reactFlowManager
      );
    }
    get rf_instance() {
      return this._reactFlowManager.rf_instance;
    }
    set rf_instance(e) {
      this._reactFlowManager.rf_instance = e;
    }
    // #endregion reactflow
  };
  const _ze = Yb(
    zfe,
    (e) => (e.id = rP(), e)
  ), Eze = (e) => {
    if (!e.useWorkerManager && e.worker === void 0)
      throw new Error(
        "If you don't use a worker manager, you must provide a default worker."
      );
    if (e.useWorkerManager && e.workermanager_url === void 0)
      throw new Error(
        "Error: If you use a worker manager, you must provide a worker managerurl."
      );
  }, BE = {};
  window.fnrf_zst === void 0 && (window.fnrf_zst = BE);
  const BW = (e) => {
    const [t, n] = C.useState(void 0), [r, o] = C.useState(
      void 0
    ), [a, i] = C.useState(!1);
    if (C.useEffect(() => {
      const s = _ze(e);
      s.logger = s.logger || new UE("FuncNodes", s.debug ? "debug" : "info"), s.logger.debug("Initializing FuncNodes with props:", s), n(s), i(!1);
    }, [e]), C.useEffect(() => {
      if (!t) return;
      t.logger?.debug("Initializing/Getting Zustand store");
      const s = BE[t.id];
      if (s === void 0) {
        const u = new Sze(t);
        BE[t.id] = u, o(u);
      } else
        o(s), s.options.debug = t.debug;
    }, [t?.id, t?.debug]), C.useEffect(() => {
      if (!(!t || !r) && !(t.useWorkerManager || !t.worker_url))
        if (t.logger?.debug("Worker effect running"), t.worker) {
          t.worker.set_zustand(r);
          return;
        } else {
          t.logger?.debug("Creating WebSocket worker");
          const s = new W8({
            url: t.worker_url,
            uuid: t.id,
            on_sync_complete: t.on_sync_complete
          });
          return s.set_zustand(r), n(
            (u) => u && { ...u, worker: s, useWorkerManager: !1 }
          ), () => {
            t.logger?.debug("Disconnecting worker"), s.disconnect(), n((u) => u && { ...u, worker: void 0 });
          };
        }
    }, [
      t?.worker_url,
      t?.id,
      t?.useWorkerManager,
      r,
      t?.on_sync_complete
    ]), C.useEffect(() => {
      if (!t?.fnw_url || !t.worker) return;
      t.logger?.debug("Loading fnw_url data");
      let s = !1;
      const u = t.worker.getSyncManager().on_sync_complete;
      return (async () => {
        try {
          const c = await xG(t.fnw_url);
          !s && t.worker && (t.worker.getSyncManager().on_sync_complete = async (f) => {
            await f.update_from_export(c), t.worker.getSyncManager().on_sync_complete = u, u && u(f);
          });
        } catch (c) {
          c instanceof Error ? t.logger?.error("Failed to load fnw_url:", c) : t.logger?.error(
            "Failed to load fnw_url:",
            new Error(String(c))
          );
        }
      })(), () => {
        s = !0, t.worker && (t.worker.getSyncManager().on_sync_complete = u);
      };
    }, [t?.fnw_url, t?.worker]), C.useEffect(() => {
      if (!t || !r || !t.useWorkerManager) return;
      if (!t.workermanager_url)
        throw new Error(
          "Error: If you use a worker manager, you must provide a worker manager url."
        );
      r.logger.info("Worker manager effect running");
      const s = !r.workermanager, u = r.workermanager && r.workermanager.wsuri !== t.workermanager_url;
      if (s || u) {
        r.workermanager && (r.logger.info("Removing existing worker manager"), r.workermanager.remove(), r.workermanager = void 0), r.logger.info("Creating new worker manager");
        const c = new Dfe(
          t.workermanager_url,
          r
        );
        return r.workermanager = c, n((f) => f && { ...f, workermanager: c }), () => {
          r.logger.info("Worker manager cleanup running"), r.workermanager === c ? (r.logger.info("Removing worker manager instance"), c.remove(), r.workermanager = void 0) : r.logger.info(
            "Worker manager instance mismatch, skipping cleanup"
          );
        };
      } else {
        r.logger.info(
          "Worker manager already initialized with correct URL"
        );
        return;
      }
    }, [
      t?.useWorkerManager,
      t?.workermanager_url,
      t?.id,
      r
    ]), C.useEffect(() => {
      !t || !r || a || (t.useWorkerManager ? r.workermanager !== void 0 : t.worker !== void 0) && t.on_ready && typeof t.on_ready == "function" && (t.logger?.debug("Firing on_ready callback"), t.on_ready({ fnrf_zst: r }), i(!0));
    }, [
      t,
      r,
      a,
      t?.useWorkerManager,
      r?.workermanager,
      t?.worker
    ]), t === void 0 || r === void 0)
      return /* @__PURE__ */ S.jsx("div", { children: "Loading..." });
    try {
      Eze(t);
    } catch (s) {
      return /* @__PURE__ */ S.jsx(kG, { error: s });
    }
    return /* @__PURE__ */ S.jsx("div", { className: "FuncnodesApp", children: /* @__PURE__ */ S.jsx(oae, { available_themes: q8, children: /* @__PURE__ */ S.jsx(Dce, { duration: 5e3, children: /* @__PURE__ */ S.jsx(
      fze,
      {
        fnrf_zst: r,
        header: t.header,
        library: t.library,
        flow: t.flow
      }
    ) }) }) });
  }, Vx = (e, t) => {
    t === void 0 && (t = {});
    const { element: n, eleid: r } = typeof e == "string" ? {
      element: document.getElementById(e),
      eleid: e
    } : { element: e, eleid: e.id };
    uG.createRoot(n).render(
      /* @__PURE__ */ S.jsx(C.StrictMode, { children: /* @__PURE__ */ S.jsx(BW, { ...t, id: t.id || r }) })
    );
  };
  window.FuncNodes = Vx;
  window.FuncNodes.version = "2.2.0";
  window.FuncNodes.utils = {
    logger: {
      ConsoleLogger: UE,
      DivLogger: pG,
      BaseLogger: VE,
      DEBUG: JF,
      INFO: QF,
      WARN: cG,
      ERROR: dG
    }
  };
  const lr = [];
  for (let e = 0; e < 256; ++e)
    lr.push((e + 256).toString(16).slice(1));
  function Cze(e, t = 0) {
    return (lr[e[t + 0]] + lr[e[t + 1]] + lr[e[t + 2]] + lr[e[t + 3]] + "-" + lr[e[t + 4]] + lr[e[t + 5]] + "-" + lr[e[t + 6]] + lr[e[t + 7]] + "-" + lr[e[t + 8]] + lr[e[t + 9]] + "-" + lr[e[t + 10]] + lr[e[t + 11]] + lr[e[t + 12]] + lr[e[t + 13]] + lr[e[t + 14]] + lr[e[t + 15]]).toLowerCase();
  }
  let Q0;
  const Pze = new Uint8Array(16);
  function Oze() {
    if (!Q0) {
      if (typeof crypto > "u" || !crypto.getRandomValues)
        throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
      Q0 = crypto.getRandomValues.bind(crypto);
    }
    return Q0(Pze);
  }
  const Nze = typeof crypto < "u" && crypto.randomUUID && crypto.randomUUID.bind(crypto), KF = { randomUUID: Nze };
  function Mze(e, t, n) {
    e = e || {};
    const r = e.random ?? e.rng?.() ?? Oze();
    if (r.length < 16)
      throw new Error("Random bytes length must be >= 16");
    return r[6] = r[6] & 15 | 64, r[8] = r[8] & 63 | 128, Cze(r);
  }
  function Rze(e, t, n) {
    return KF.randomUUID && !e ? KF.randomUUID() : Mze(e);
  }
  const VW = '(function(){"use strict";const w="https://cdn.jsdelivr.net/pyodide/v0.29.0/full/pyodide.mjs",e=self;e.workerState={pyodide:null,pyodide_url:w,packages:[],state:{msg:"loading",loaded:!1,progress:0},micropip:null,worker:{},pyodideReady:!1,pyodideReadyPromise:null,debug:!1,interruptBuffer:null,receivepy:(r,t)=>{},receivepy_bytes:(r,t)=>{},handel_register:{},post_pyodide_ready:void 0},e.reset=async()=>{for(const r in e.list_workers())try{const t=await e.get_worker(r);t.worker&&t.worker.stop(),t.reject_promise?.("Worker reset")}catch{}e.workerState.pyodide&&e.interrupt(),e.workerState.pyodide=null,e.workerState.micropip=null,e.workerState.worker={},e.workerState.pyodideReady=!1;try{e.workerState.interruptBuffer=new Uint8Array(new SharedArrayBuffer(1)),e.workerState.interruptBuffer[0]=0}catch{}},e.initializePyodide=async()=>{if(!e.workerState.pyodide){console.log("initializePyodide with: Debug:",e.workerState.debug,"Pyodide URL:",e.workerState.pyodide_url,"Packages:",e.workerState.packages),console.debug("Loading Pyodide..."),e.workerState.state.msg="Loading Pyodide...",e.workerState.state.progress=0,await e.reset(),console.debug("Loading Pyodide module..."),e.workerState.state.msg="Loading Pyodide module...",e.workerState.state.progress=.1;const t=await import(e.workerState.pyodide_url);console.debug("Loading Pyodide instance..."),e.workerState.state.msg="Loading Pyodide instance...",e.workerState.state.progress=.2;const o=t.loadPyodide,a=new URL(e.workerState.pyodide_url),i=new URL(".",a).toString();e.workerState.debug&&console.debug("Pyodide indexURL:",i),e.workerState.pyodide=await o({packages:["micropip"],indexURL:i}),e.workerState.interruptBuffer&&e.workerState.pyodide.setInterruptBuffer(e.workerState.interruptBuffer)}e.workerState.micropip||(console.debug("Importing micropip..."),e.workerState.state.msg="Importing micropip...",e.workerState.state.progress=.3,e.workerState.micropip=e.workerState.pyodide.pyimport("micropip")),console.debug("Pyodide ready. Installing funcnodes...");for(const t of e.workerState.packages)console.log("Installing package:",t),e.workerState.state.msg=`Installing package: ${t}`,await e.workerState.micropip.install(t);return e.workerState.state.msg="Installing funcnodes",e.workerState.state.progress=.8,await e.workerState.micropip.install("funcnodes"),e.workerState.state.msg="Installing funcnodes-worker",await e.workerState.micropip.install("funcnodes-worker"),e.workerState.packages.some(t=>t.toLowerCase().endsWith(".whl")&&t.includes("funcnodes_pyodide"))?e.workerState.debug&&console.debug("Skipping PyPI funcnodes-pyodide install (wheel provided in packages)"):(e.workerState.state.msg="Installing funcnodes-pyodide",await e.workerState.micropip.install("funcnodes-pyodide")),e.workerState.state.msg="Installing funcnodes-react-flow",await e.workerState.micropip.install("funcnodes-react-flow"),e.workerState.state.msg="Importing funcnodes",console.debug("Importing funcnodes..."),await e.workerState.pyodide.runPythonAsync("import funcnodes_pyodide"),console.debug("Running post_pyodide_ready..."),await e.workerState.post_pyodide_ready?.(e.workerState),console.debug("Pyodide ready"),e.workerState.state.msg="ready",e.workerState.state.progress=.1,e.workerState.pyodideReady=!0,{pyodide:e.workerState.pyodide,micropip:e.workerState.micropip}},e.interrupt=()=>{e.workerState.interruptBuffer&&(e.workerState.interruptBuffer[0]=1)},e.list_workers=()=>Object.keys(e.workerState.worker),e.get_worker=async r=>{if(!r)throw new Error("Worker id is required");if(!e.workerState.worker[r])throw new Error(`Worker with id ${r} not found`);return await e.workerState.worker[r].make_promise,e.workerState.worker[r]},e.has_worker=r=>{if(!r)throw new Error("Worker id is required");return!!e.workerState.worker[r]},e.get_or_create_worker=async r=>{if(!r)throw new Error("Worker id is required");return e.workerState.worker[r]||(console.log("Creating worker with id",r),await e.initializeFuncNodesWorker(r)),e.get_worker(r)},e.initializeFuncNodesWorker=async r=>{try{if(!e.workerState.pyodideReadyPromise)throw new Error("Pyodide newer initialized");const{pyodide:t}=await e.workerState.pyodideReadyPromise;if(!e.has_worker(r)){e.workerState.worker[r]={worker:null,make_promise:void 0};const o=new Promise(async(a,i)=>{e.workerState.worker[r].reject_promise=i,console.debug(`Creating worker (${r})...`);const s=await t.runPythonAsync(`funcnodes_pyodide.new_worker(debug=${e.workerState.debug?1:0}, uuid="${r}")`);if(console.debug("Worker created:",s),typeof s.set_receiver=="function")s.set_receiver(self);else throw new Error("Worker does not expose a \'set_receiver\' method.");e.workerState.worker[r].worker=s,console.debug("Worker ready"),a(s)});e.workerState.worker[r].make_promise=o}return e.get_worker(r)}catch(t){throw console.error("Error during worker initialization:",t),t}},e.receivepy=(r,t)=>{try{let o={};if(typeof r=="string"?o.msg=r:o=r,o.msg===void 0)return;typeof o.msg!="string"&&(o.msg=JSON.stringify(o.msg)),t!==void 0&&(typeof t=="string"?o.worker_id||(o.worker_id=t):o={...t,...o});const a=o.worker_id;if(!a)throw new Error(`Worker id not provided in receivepy(${JSON.stringify(o)})`);if(!e.workerState.worker[a])throw new Error(`Worker with id ${a} not found in receivepy(${JSON.stringify(o)})`);e.workerState.receivepy(r,a)}catch(o){console.error("Error during receivepy:",o);return}},e.receivepy_bytes=(r,t)=>{let o=r;const a=r;if(a&&typeof a.toJs=="function")try{o=a.toJs({dict_converter:Object.fromEntries})}catch{o=a.toJs()}o instanceof Map&&(o=Object.fromEntries(o.entries()));try{let i={};if(o instanceof Uint8Array?i.msg=o:i=o,i.msg===void 0)return;let s=i.msg;const d=s;if(d&&typeof d.toJs=="function")try{s=d.toJs({dict_converter:Object.fromEntries})}catch{s=d.toJs()}if(s instanceof ArrayBuffer&&(s=new Uint8Array(s)),Array.isArray(s)&&(s=Uint8Array.from(s)),!(s instanceof Uint8Array))throw new Error(`receivepy_bytes expected Uint8Array payload, got ${typeof s}`);i.msg=s,t!==void 0&&(typeof t=="string"?i.worker_id||(i.worker_id=t):i={...t,...i});const c=i.worker_id;if(!c)throw new Error("Worker id not provided in receivepy_bytes");if(!e.workerState.worker[c])throw new Error(`Worker with id ${c} not found in receivepy_bytes`);e.workerState.receivepy_bytes(i.msg,c)}catch(i){console.error("Error during receivepy_bytes:",i);return}},e.startInitialization=({debug:r=!1,receivepy:t,receivepy_bytes:o,pyodide_url:a,post_pyodide_ready:i,packages:s})=>(e.workerState.debug=r,e.workerState.pyodide_url=a||w,e.workerState.packages=s,e.workerState.receivepy=t,e.workerState.receivepy_bytes=o,e.workerState.pyodideReadyPromise=null,e.workerState.post_pyodide_ready=i,e.workerState),e.register_cmd_message=(r,t)=>{if(e.workerState.handel_register[r])throw new Error(`Command ${r} already registered`);e.workerState.handel_register[r]=t},e.register_cmd_message("ping",async r=>"pong"),e.register_cmd_message("init",async r=>{if(e.workerState.pyodideReadyPromise)throw new Error("Pyodide is already initialized");r.data&&(r.data.pyodide_url&&(e.workerState.pyodide_url=r.data.pyodide_url),r.data.packages&&(e.workerState.packages=r.data.packages),r.data.debug&&(e.workerState.debug=r.data.debug)),e.workerState.pyodideReadyPromise=e.initializePyodide()}),e.register_cmd_message("_eval",async r=>{try{const t=await e.workerState.pyodide?.runPythonAsync(r.msg||"print(\'No code provided\')");return console.log("Eval result:",t),t}catch(t){console.error("Error during _eval:",t)}}),e.register_cmd_message("state",async r=>({state:{...e.workerState.state,loaded:e.workerState.pyodideReady}})),e.register_cmd_message("worker:state",async r=>({state:{loaded:!!(await e.get_or_create_worker(r.worker_id)).worker}})),e.register_cmd_message("worker:stop",async r=>{if(!e.has_worker(r.worker_id))return;const t=await e.get_or_create_worker(r.worker_id);return t.worker&&(t.worker.stop(),t.worker=null,t.reject_promise?.("Worker stopped")),delete e.workerState.worker[r.worker_id],{state:{loaded:!1}}}),e.register_cmd_message("worker:send",async r=>{const t=await e.get_or_create_worker(r.worker_id);if(!t.worker)throw new Error("Worker is not initialized");if(typeof t.worker.receivejs!="function")throw new Error(`Worker does not support receivejs: ${typeof t.worker.receivejs}`);t.worker.receivejs(r.msg)}),e.handleMessage=async r=>{const t={original:r};r.id&&(t.id=r.id),r.toJs===void 0&&(r.toJs=!0);try{if(r.cmd){const o=r;if(e.workerState.handel_register[o.cmd])t.result=await e.workerState.handel_register[o.cmd](o);else throw new Error("Unknown command: "+o.cmd)}else throw new Error("Unknown message format: "+JSON.stringify(r))}catch(o){t.error=o.message}return t},e.read_url_params=()=>{const r=new URLSearchParams(self.location.search),t=r.get("debug")?.toLowerCase()==="true",o=r.get("pyodide_url")||void 0,a=r.get("packages")?.split(",")||[];return{debug:t,pyodide_url:o,packages:a}};const n=e;n.general_initalization=r=>{const t=n.read_url_params();n.startInitialization({...r,...t})};const k=n,p=n;p.init_dedicated_worker=r=>{const t=e;t.onmessage=async a=>{const i=a.data,s=await t.handleMessage(i);t.postMessage(s)};const o={...r,receivepy:(a,i)=>{t.postMessage({cmd:"receive",msg:a,worker_id:i})},receivepy_bytes(a,i){t.postMessage({cmd:"receive_bytes",msg:a,worker_id:i})}};t.general_initalization(o)},k.init_shared_worker=r=>{const t=e;t.connectedPorts=[],t.onconnect=a=>{const i=a.ports[0];t.connectedPorts.push(i),i.start(),console.debug("Port connected in shared worker"),i.onmessage=async s=>{const d=s.data,c=await t.handleMessage(d);i.postMessage(c)}};const o={...r,receivepy:(a,i)=>{t.connectedPorts.forEach(s=>{s.postMessage({cmd:"receive",msg:a,worker_id:i})})},receivepy_bytes(a,i){t.connectedPorts.forEach(s=>{s.postMessage({cmd:"receive_bytes",msg:a,worker_id:i})})}};t.general_initalization(o)},(r=>{n.init_dedicated_worker(r)})({})})();\n', GF = typeof self < "u" && self.Blob && new Blob(["(self.URL || self.webkitURL).revokeObjectURL(self.location.href);", VW], { type: "text/javascript;charset=utf-8" });
  function jze(e) {
    let t;
    try {
      if (t = GF && (self.URL || self.webkitURL).createObjectURL(GF), !t) throw "";
      const n = new Worker(t, {
        name: e?.name
      });
      return n.addEventListener("error", () => {
        (self.URL || self.webkitURL).revokeObjectURL(t);
      }), n;
    } catch {
      return new Worker(
        "data:text/javascript;charset=utf-8," + encodeURIComponent(VW),
        {
          name: e?.name
        }
      );
    }
  }
  const Ize = '(function(){"use strict";const w="https://cdn.jsdelivr.net/pyodide/v0.29.0/full/pyodide.mjs",e=self;e.workerState={pyodide:null,pyodide_url:w,packages:[],state:{msg:"loading",loaded:!1,progress:0},micropip:null,worker:{},pyodideReady:!1,pyodideReadyPromise:null,debug:!1,interruptBuffer:null,receivepy:(r,t)=>{},receivepy_bytes:(r,t)=>{},handel_register:{},post_pyodide_ready:void 0},e.reset=async()=>{for(const r in e.list_workers())try{const t=await e.get_worker(r);t.worker&&t.worker.stop(),t.reject_promise?.("Worker reset")}catch{}e.workerState.pyodide&&e.interrupt(),e.workerState.pyodide=null,e.workerState.micropip=null,e.workerState.worker={},e.workerState.pyodideReady=!1;try{e.workerState.interruptBuffer=new Uint8Array(new SharedArrayBuffer(1)),e.workerState.interruptBuffer[0]=0}catch{}},e.initializePyodide=async()=>{if(!e.workerState.pyodide){console.log("initializePyodide with: Debug:",e.workerState.debug,"Pyodide URL:",e.workerState.pyodide_url,"Packages:",e.workerState.packages),console.debug("Loading Pyodide..."),e.workerState.state.msg="Loading Pyodide...",e.workerState.state.progress=0,await e.reset(),console.debug("Loading Pyodide module..."),e.workerState.state.msg="Loading Pyodide module...",e.workerState.state.progress=.1;const t=await import(e.workerState.pyodide_url);console.debug("Loading Pyodide instance..."),e.workerState.state.msg="Loading Pyodide instance...",e.workerState.state.progress=.2;const o=t.loadPyodide,a=new URL(e.workerState.pyodide_url),i=new URL(".",a).toString();e.workerState.debug&&console.debug("Pyodide indexURL:",i),e.workerState.pyodide=await o({packages:["micropip"],indexURL:i}),e.workerState.interruptBuffer&&e.workerState.pyodide.setInterruptBuffer(e.workerState.interruptBuffer)}e.workerState.micropip||(console.debug("Importing micropip..."),e.workerState.state.msg="Importing micropip...",e.workerState.state.progress=.3,e.workerState.micropip=e.workerState.pyodide.pyimport("micropip")),console.debug("Pyodide ready. Installing funcnodes...");for(const t of e.workerState.packages)console.log("Installing package:",t),e.workerState.state.msg=`Installing package: ${t}`,await e.workerState.micropip.install(t);return e.workerState.state.msg="Installing funcnodes",e.workerState.state.progress=.8,await e.workerState.micropip.install("funcnodes"),e.workerState.state.msg="Installing funcnodes-worker",await e.workerState.micropip.install("funcnodes-worker"),e.workerState.packages.some(t=>t.toLowerCase().endsWith(".whl")&&t.includes("funcnodes_pyodide"))?e.workerState.debug&&console.debug("Skipping PyPI funcnodes-pyodide install (wheel provided in packages)"):(e.workerState.state.msg="Installing funcnodes-pyodide",await e.workerState.micropip.install("funcnodes-pyodide")),e.workerState.state.msg="Installing funcnodes-react-flow",await e.workerState.micropip.install("funcnodes-react-flow"),e.workerState.state.msg="Importing funcnodes",console.debug("Importing funcnodes..."),await e.workerState.pyodide.runPythonAsync("import funcnodes_pyodide"),console.debug("Running post_pyodide_ready..."),await e.workerState.post_pyodide_ready?.(e.workerState),console.debug("Pyodide ready"),e.workerState.state.msg="ready",e.workerState.state.progress=.1,e.workerState.pyodideReady=!0,{pyodide:e.workerState.pyodide,micropip:e.workerState.micropip}},e.interrupt=()=>{e.workerState.interruptBuffer&&(e.workerState.interruptBuffer[0]=1)},e.list_workers=()=>Object.keys(e.workerState.worker),e.get_worker=async r=>{if(!r)throw new Error("Worker id is required");if(!e.workerState.worker[r])throw new Error(`Worker with id ${r} not found`);return await e.workerState.worker[r].make_promise,e.workerState.worker[r]},e.has_worker=r=>{if(!r)throw new Error("Worker id is required");return!!e.workerState.worker[r]},e.get_or_create_worker=async r=>{if(!r)throw new Error("Worker id is required");return e.workerState.worker[r]||(console.log("Creating worker with id",r),await e.initializeFuncNodesWorker(r)),e.get_worker(r)},e.initializeFuncNodesWorker=async r=>{try{if(!e.workerState.pyodideReadyPromise)throw new Error("Pyodide newer initialized");const{pyodide:t}=await e.workerState.pyodideReadyPromise;if(!e.has_worker(r)){e.workerState.worker[r]={worker:null,make_promise:void 0};const o=new Promise(async(a,i)=>{e.workerState.worker[r].reject_promise=i,console.debug(`Creating worker (${r})...`);const s=await t.runPythonAsync(`funcnodes_pyodide.new_worker(debug=${e.workerState.debug?1:0}, uuid="${r}")`);if(console.debug("Worker created:",s),typeof s.set_receiver=="function")s.set_receiver(self);else throw new Error("Worker does not expose a \'set_receiver\' method.");e.workerState.worker[r].worker=s,console.debug("Worker ready"),a(s)});e.workerState.worker[r].make_promise=o}return e.get_worker(r)}catch(t){throw console.error("Error during worker initialization:",t),t}},e.receivepy=(r,t)=>{try{let o={};if(typeof r=="string"?o.msg=r:o=r,o.msg===void 0)return;typeof o.msg!="string"&&(o.msg=JSON.stringify(o.msg)),t!==void 0&&(typeof t=="string"?o.worker_id||(o.worker_id=t):o={...t,...o});const a=o.worker_id;if(!a)throw new Error(`Worker id not provided in receivepy(${JSON.stringify(o)})`);if(!e.workerState.worker[a])throw new Error(`Worker with id ${a} not found in receivepy(${JSON.stringify(o)})`);e.workerState.receivepy(r,a)}catch(o){console.error("Error during receivepy:",o);return}},e.receivepy_bytes=(r,t)=>{let o=r;const a=r;if(a&&typeof a.toJs=="function")try{o=a.toJs({dict_converter:Object.fromEntries})}catch{o=a.toJs()}o instanceof Map&&(o=Object.fromEntries(o.entries()));try{let i={};if(o instanceof Uint8Array?i.msg=o:i=o,i.msg===void 0)return;let s=i.msg;const d=s;if(d&&typeof d.toJs=="function")try{s=d.toJs({dict_converter:Object.fromEntries})}catch{s=d.toJs()}if(s instanceof ArrayBuffer&&(s=new Uint8Array(s)),Array.isArray(s)&&(s=Uint8Array.from(s)),!(s instanceof Uint8Array))throw new Error(`receivepy_bytes expected Uint8Array payload, got ${typeof s}`);i.msg=s,t!==void 0&&(typeof t=="string"?i.worker_id||(i.worker_id=t):i={...t,...i});const c=i.worker_id;if(!c)throw new Error("Worker id not provided in receivepy_bytes");if(!e.workerState.worker[c])throw new Error(`Worker with id ${c} not found in receivepy_bytes`);e.workerState.receivepy_bytes(i.msg,c)}catch(i){console.error("Error during receivepy_bytes:",i);return}},e.startInitialization=({debug:r=!1,receivepy:t,receivepy_bytes:o,pyodide_url:a,post_pyodide_ready:i,packages:s})=>(e.workerState.debug=r,e.workerState.pyodide_url=a||w,e.workerState.packages=s,e.workerState.receivepy=t,e.workerState.receivepy_bytes=o,e.workerState.pyodideReadyPromise=null,e.workerState.post_pyodide_ready=i,e.workerState),e.register_cmd_message=(r,t)=>{if(e.workerState.handel_register[r])throw new Error(`Command ${r} already registered`);e.workerState.handel_register[r]=t},e.register_cmd_message("ping",async r=>"pong"),e.register_cmd_message("init",async r=>{if(e.workerState.pyodideReadyPromise)throw new Error("Pyodide is already initialized");r.data&&(r.data.pyodide_url&&(e.workerState.pyodide_url=r.data.pyodide_url),r.data.packages&&(e.workerState.packages=r.data.packages),r.data.debug&&(e.workerState.debug=r.data.debug)),e.workerState.pyodideReadyPromise=e.initializePyodide()}),e.register_cmd_message("_eval",async r=>{try{const t=await e.workerState.pyodide?.runPythonAsync(r.msg||"print(\'No code provided\')");return console.log("Eval result:",t),t}catch(t){console.error("Error during _eval:",t)}}),e.register_cmd_message("state",async r=>({state:{...e.workerState.state,loaded:e.workerState.pyodideReady}})),e.register_cmd_message("worker:state",async r=>({state:{loaded:!!(await e.get_or_create_worker(r.worker_id)).worker}})),e.register_cmd_message("worker:stop",async r=>{if(!e.has_worker(r.worker_id))return;const t=await e.get_or_create_worker(r.worker_id);return t.worker&&(t.worker.stop(),t.worker=null,t.reject_promise?.("Worker stopped")),delete e.workerState.worker[r.worker_id],{state:{loaded:!1}}}),e.register_cmd_message("worker:send",async r=>{const t=await e.get_or_create_worker(r.worker_id);if(!t.worker)throw new Error("Worker is not initialized");if(typeof t.worker.receivejs!="function")throw new Error(`Worker does not support receivejs: ${typeof t.worker.receivejs}`);t.worker.receivejs(r.msg)}),e.handleMessage=async r=>{const t={original:r};r.id&&(t.id=r.id),r.toJs===void 0&&(r.toJs=!0);try{if(r.cmd){const o=r;if(e.workerState.handel_register[o.cmd])t.result=await e.workerState.handel_register[o.cmd](o);else throw new Error("Unknown command: "+o.cmd)}else throw new Error("Unknown message format: "+JSON.stringify(r))}catch(o){t.error=o.message}return t},e.read_url_params=()=>{const r=new URLSearchParams(self.location.search),t=r.get("debug")?.toLowerCase()==="true",o=r.get("pyodide_url")||void 0,a=r.get("packages")?.split(",")||[];return{debug:t,pyodide_url:o,packages:a}};const n=e;n.general_initalization=r=>{const t=n.read_url_params();n.startInitialization({...r,...t})};const k=n,p=n;p.init_dedicated_worker=r=>{const t=e;t.onmessage=async a=>{const i=a.data,s=await t.handleMessage(i);t.postMessage(s)};const o={...r,receivepy:(a,i)=>{t.postMessage({cmd:"receive",msg:a,worker_id:i})},receivepy_bytes(a,i){t.postMessage({cmd:"receive_bytes",msg:a,worker_id:i})}};t.general_initalization(o)},k.init_shared_worker=r=>{const t=e;t.connectedPorts=[],t.onconnect=a=>{const i=a.ports[0];t.connectedPorts.push(i),i.start(),console.debug("Port connected in shared worker"),i.onmessage=async s=>{const d=s.data,c=await t.handleMessage(d);i.postMessage(c)}};const o={...r,receivepy:(a,i)=>{t.connectedPorts.forEach(s=>{s.postMessage({cmd:"receive",msg:a,worker_id:i})})},receivepy_bytes(a,i){t.connectedPorts.forEach(s=>{s.postMessage({cmd:"receive_bytes",msg:a,worker_id:i})})}};t.general_initalization(o)},(r=>{n.init_shared_worker(r)})({})})();\n';
  function Aze(e) {
    return new SharedWorker(
      "data:text/javascript;charset=utf-8," + encodeURIComponent(Ize),
      {
        name: e?.name
      }
    );
  }
  const $ze = (e, t) => {
    if (!e?.length) return e;
    const n = t ?? (typeof window < "u" && window.location ? window.location.href : void 0);
    return n ? e.map((r) => /^[a-zA-Z][a-zA-Z0-9+.-]*:/.test(r) ? r : r.startsWith("/") || r.startsWith("./") || r.startsWith("../") ? new URL(r, n).toString() : r) : e;
  }, Dze = (e) => (e.worker || (e.worker_classes || (e.worker_classes = {
    Shared: Aze,
    Dedicated: jze
  }), e.shared_worker ? e.worker_url === void 0 ? e.worker = new e.worker_classes.Shared({
    name: e.uuid
  }) : e.worker = new SharedWorker(e.worker_url, {
    name: e.uuid,
    type: "module"
  }) : e.worker_url === void 0 ? e.worker = new e.worker_classes.Dedicated({
    name: e.uuid
  }) : e.worker = new Worker(e.worker_url, {
    name: e.uuid,
    type: "module"
  })), e.worker);
  class UW extends oP {
    constructor(t) {
      const n = {
        uuid: Rze(),
        ...t
      };
      if (super(n), this._message_hooks = [], this._worker = Dze(n), this._worker instanceof SharedWorker)
        n.shared_worker = !0, this._port = this._worker.port, this._port.start(), this._port.addEventListener("message", this.onmessage.bind(this));
      else if (this._worker instanceof Worker)
        n.shared_worker = !1, this._worker.addEventListener("message", this.onmessage.bind(this));
      else
        throw new Error("worker must be an instance of Worker or SharedWorker");
      this.postMessage({
        cmd: "init",
        data: {
          debug: n.debug,
          pyodide_url: n.pyodide_url,
          packages: $ze(n.packages, n.worker_baseurl)
        }
      });
      const r = setInterval(() => {
        this.postMessage({ cmd: "state" });
      }, 400);
      this._workerstate = { loaded: !1, msg: "loading", progress: 0 }, this.initPromise = new Promise(async (o) => {
        for (; !this._workerstate.loaded; )
          this._zustand?.set_progress({
            message: this._workerstate.msg,
            status: "info",
            progress: this._workerstate.progress,
            blocking: !0
          }), await new Promise((a) => setTimeout(a, 100));
        clearInterval(r), this.is_open = !0, this._zustand?.auto_progress(), o();
      }), this.initPromise.then(async () => {
        if (n.restore_worker_state_on_load) {
          const o = typeof n.restore_worker_state_on_load == "string" ? n.restore_worker_state_on_load : this._storage_key();
          await this.restore_worker_state(o) || await this.getSyncManager().stepwise_fullsync();
        }
        n.post_worker_initialized && await n.post_worker_initialized(this);
      });
    }
    async send(t) {
      await this.initPromise, this.postMessage({
        cmd: "worker:send",
        msg: JSON.stringify(t),
        worker_id: this.uuid
      });
    }
    postMessage(t) {
      t.worker_id = this.uuid, this._port ? this._port.postMessage(t) : this._worker.postMessage(t);
    }
    registerMessageHook(t) {
      return this._message_hooks.push(t), () => {
        this._message_hooks = this._message_hooks.filter((n) => n !== t);
      };
    }
    onmessage(t) {
      for (const n of this._message_hooks)
        n(t.data);
      if (t.data.result)
        t.data.result.state && (this._workerstate = {
          ...this._workerstate,
          ...t.data.result.state
        }, t.data.result.state.msg && t.data.result.state.msg !== "ready" && this._zustand?.set_progress({
          message: this._workerstate.msg,
          status: "info",
          progress: this._workerstate.progress,
          blocking: !0
        }));
      else if (t.data.cmd) {
        if (t.data.cmd === "receive") {
          if (t.data.worker_id === void 0)
            throw new Error("worker_id is undefined");
          t.data.worker_id === this.uuid && this.getCommunicationManager().receive(JSON.parse(t.data.msg));
        } else if (t.data.cmd === "receive_bytes") {
          if (t.data.worker_id === void 0)
            throw new Error("worker_id is undefined");
          t.data.worker_id === this.uuid && this.getCommunicationManager().onbytes(t.data.msg);
        }
      }
    }
    async upload_file({
      files: t,
      onProgressCallback: n,
      root: r
    }) {
      const o = [], a = t.length;
      let i = 0;
      if (t.length === 0)
        return "";
      for (let c = 0; c < t.length; c++) {
        const f = t[c], p = new FileReader(), g = new Promise((h, y) => {
          p.onload = async (b) => {
            try {
              const v = b.target.result?.replace(/^data:.+;base64,/, ""), w = f.webkitRelativePath || f.name, _ = r ? `${r}/${w}` : w, k = await this._send_cmd({
                cmd: "upload",
                kwargs: { data: v, filename: _ },
                wait_for_response: !0
              });
              i++, n && n(i, a), h(k);
            } catch (v) {
              y(v);
            }
          }, p.readAsDataURL(f);
        });
        o.push(g);
      }
      const s = await Promise.all(o);
      return s.reduce((c, f) => {
        const p = f.split("/"), g = c.split("/"), h = [];
        for (let y = 0; y < p.length && p[y] === g[y]; y++)
          h.push(p[y]);
        return h.join("/");
      }, s[0]);
    }
    get ready() {
      return this._workerstate.loaded;
    }
    _storage_key() {
      return `funcnodes_pyodide:worker_export:${this.uuid}`;
    }
    _has_local_storage() {
      try {
        return typeof globalThis < "u" && "localStorage" in globalThis;
      } catch {
        return !1;
      }
    }
    async save_worker_state({ withFiles: t = !0 } = {}) {
      const n = await this.export({ withFiles: t }), r = typeof n == "string" ? n : n?.data;
      if (typeof r != "string")
        throw new Error("export_worker did not return a string export");
      return this._has_local_storage() && globalThis.localStorage.setItem(this._storage_key(), r), r;
    }
    async restore_worker_state(t) {
      if (!this._has_local_storage()) return !1;
      const n = globalThis.localStorage.getItem(
        t || this._storage_key()
      );
      if (!n) return !1;
      try {
        return await this.update_from_export(n), !0;
      } catch (r) {
        return console.warn("Failed to restore worker state from storage", r), !1;
      }
    }
  }
  const Lze = (e, t, n = {}) => {
    if (t.shared_worker ? t.shared_worker = !0 : t.shared_worker = !1, !t.uuid) {
      const a = typeof e == "string" ? e : e.id;
      a !== void 0 && (t.uuid = a);
    }
    const r = new UW(t), o = {
      ...n,
      worker: r,
      useWorkerManager: !1,
      id: r.uuid,
      debug: t.debug || !1,
      worker_url: "dummy"
      // dummy url as the current implementation requires one (will be removed in the next release of funcnodes_react_flow)
    };
    Vx(e, o);
  };
  window.FuncNodes || (window.FuncNodes = Vx);
  window.FuncNodes.FuncnodesPyodideWorker = UW;
  window.FuncNodes.FuncnodesPyodide = Lze;
});
export default Fze();
